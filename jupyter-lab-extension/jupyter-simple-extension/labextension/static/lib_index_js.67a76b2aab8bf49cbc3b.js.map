{"version":3,"file":"lib_index_js.67a76b2aab8bf49cbc3b.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC7Ib;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB,mBAAO,CAAC,4FAA2B,GAAG;AAC9D;AACA,wDAAwD,kCAAkC,GAAG;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACrEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB,IAAI,+BAA+B;AACnC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;;;;;;;;;;ACjBY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,2BAA2B,mBAAO,CAAC,4DAAwB,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,4BAA4B;AACnH;AACA,mBAAmB;AACnB,sFAAsF,4BAA4B;AAClH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;ACvIT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,iCAAiC,mBAAO,CAAC,8EAAiC,GAAG;AAC7E,kBAAkB,mBAAO,CAAC,8CAAiB,GAAG;AAC9C,2BAA2B,mBAAO,CAAC,4DAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,oDAAoD,KAAK,UAAU,MAAM,SAAS,KAAK;AACvF;AACA,4CAA4C;AAC5C,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,iCAAiC;AACvG;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,uEAAuE;AACvE,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,kCAAkC;AAClC;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,0DAA0D,iCAAiC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,qDAAqD;AACrD;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,wCAAwC;AACxC,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa,SAAS,cAAc,SAAS,WAAW,EAAE,wDAAwD;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,8BAA8B;AAC9B;AACA;AACA,yCAAyC,cAAc,qBAAqB;AAC5E;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,mCAAmC,MAAM,SAAS,uBAAuB,GAAG,qBAAqB;AACjG,mCAAmC,MAAM,UAAU,qBAAqB,QAAQ,sBAAsB,IAAI,mBAAmB,GAAG,sBAAsB;AACtJ;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB,GAAG,qBAAqB;AAC3F,6CAA6C,qBAAqB,QAAQ,sBAAsB,IAAI,mBAAmB,GAAG,sBAAsB;AAChJ;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA,0BAA0B,OAAO,EAAE,gBAAgB,EAAE,OAAO;AAC5D;AACA;AACA,2EAA2E;AAC3E,8BAA8B;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA,8DAA8D,MAAM;AACpE;AACA,yCAAyC,MAAM;AAC/C;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,yCAAyC;AACzC,6CAA6C;AAC7C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO,MAAM,aAAa,SAAS,cAAc,IAAI,6BAA6B;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,4EAA4E,MAAM;AAClF;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,yCAAyC;AACzC,6CAA6C;AAC7C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,4EAA4E,MAAM;AAClF;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA,2DAA2D,MAAM;AACjE;AACA,yCAAyC,MAAM;AAC/C;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E,gCAAgC,gBAAgB;AAChD,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA,YAAY;AACZ;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC/7BP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,2BAA2B,mBAAO,CAAC,4DAAwB;AAC3D,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE,kBAAkB,mBAAO,CAAC,8CAAiB,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ,eAAe,WAAW;AAC1F,yDAAyD,kBAAkB,WAAW,WAAW;AACjG;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,gEAAgE;AAChE,iDAAiD;AACjD,8CAA8C;AAC9C;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,4FAA4F;AAC5F;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,aAAa,WAAW,SAAS,OAAO;AAC9G,uEAAuE,kBAAkB,WAAW,WAAW;AAC/G;AACA;AACA,gEAAgE,6BAA6B;AAC7F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,eAAe;AACf;AACA,sFAAsF,WAAW;AACjG;AACA,+EAA+E,YAAY;AAC3F;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,8EAA8E,2BAA2B;AACzG;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA,iFAAiF;AACjF;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,kBAAkB;AACnH,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc;AACjG;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;;;;;;;;;;;ACjLT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,mBAAmB,mBAAO,CAAC,kDAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,yEAAyE,WAAW;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;ACrSN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,wEAAwE,QAAQ,IAAI,QAAQ;AAC5F;AACA;AACA;AACA;AACA,4EAA4E,QAAQ,IAAI,QAAQ;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,mBAAmB;AACnB;AACA,2CAA2C;AAC3C;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAyD;AACvE,cAAc,2DAA2D;AACzE,cAAc,0DAA0D;AACxE,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gEAAgE,MAAM,EAAE,SAAS;AACjF;AACA,qBAAqB;AACrB;AACA;AACA,kGAAkG,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wCAAwC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,EAAE,kBAAkB,EAAE,iBAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS,UAAU,KAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kFAAkF;AAC5G,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,GAAG;AACrE;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK,GAAG,yDAAyD;AACzG;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,UAAU,KAAK;AACxE;AACA;AACA,oCAAoC,0DAA0D;AAC9F;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB,UAAU,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,aAAa,oBAAoB;AAC9G;AACA,4BAA4B,SAAS,GAAG,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD,qBAAqB;AACrB;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wCAAwC,mBAAmB,kBAAkB,SAAS;AACtF;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,KAAK,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc,KAAK,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,UAAU;AAC7E;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA,4EAA4E,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW,IAAI,UAAU;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS,YAAY,UAAU;AACrF,+CAA+C,SAAS;AACxD,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;ACrjCX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,KAAK,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC/FV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE,kBAAkB,mBAAO,CAAC,8CAAiB,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,uEAAuE;AACvE;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,2GAA2G,aAAa,SAAS,cAAc;AAC/I,yEAAyE,mCAAmC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,kGAAkG;AAClG,mFAAmF;AACnF,0PAA0P;AAC1P;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD,kBAAkB,mBAAO,CAAC,6CAAgB;AAC1C,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,+BAA+B,mBAAO,CAAC,6DAAwB;AAC/D,YAAY,YAAY;AACxB;AACA,mBAAO,CAAC,6CAAoB;AAC5B;AACA,mBAAmB,mBAAO,CAAC,mDAAmB;AAC9C,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACrCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,gBAAgB,mBAAO,CAAC,yCAAc;AACtC,qBAAqB,mBAAO,CAAC,mDAAmB;AAChD,6BAA6B,mBAAO,CAAC,2EAA+B;AACpE,2BAA2B,mBAAO,CAAC,uEAA6B;AAChE,yBAAyB,mBAAO,CAAC,uDAAqB;AACtD,yBAAyB,mBAAO,CAAC,uDAAqB;AACtD,qBAAqB,mBAAO,CAAC,qDAAoB;AACjD,yBAAyB,mBAAO,CAAC,6DAAwB;AACzD,wBAAwB,mBAAO,CAAC,iEAA0B;AAC1D,0BAA0B,mBAAO,CAAC,qEAA4B;AAC9D,0BAA0B,mBAAO,CAAC,qEAA4B;AAC9D,2BAA2B,mBAAO,CAAC,uEAA6B;AAChE,qBAAqB,mBAAO,CAAC,+CAAiB;AAC9C,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,kBAAkB,mBAAO,CAAC,6CAAgB;AAC1C,qBAAqB,mBAAO,CAAC,qDAAoB;AACjD,uBAAuB,mBAAO,CAAC,+DAAyB;AACxD;AACA,oBAAoB,mBAAO,CAAC,mDAAmB;AAC/C,+BAA+B,mBAAO,CAAC,yEAA8B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,iDAAiD;AACjD,UAAU;AACV;AACA;AACA,kDAAkD;AAClD,uDAAuD;AACvD,qDAAqD;AACrD,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,wBAAwB;AACxB,6DAA6D,QAAQ,cAAc,WAAW,IAAI;AAClG;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kCAAkC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,kFAAkF;AAClF,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,WAAW,QAAQ,cAAc;AACzH;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA,aAAa;AACb,uCAAuC,QAAQ,+FAA+F,QAAQ,KAAK;AAC3J,gDAAgD,QAAQ,uGAAuG;AAC/J,+CAA+C,QAAQ,sGAAsG;AAC7J;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA,0DAA0D,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,qFAAqF;AAC7H,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gFAAgF,iBAAiB;AACjG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gCAAgC;AACxF,wDAAwD,kCAAkC;AAC1F,+BAA+B,gCAAgC,GAAG;AAClE;AACA;AACA,aAAa;AACb,mCAAmC,QAAQ,+GAA+G;AAC1J,qCAAqC,QAAQ;AAC7C;AACA;AACA,uCAAuC,QAAQ,2FAA2F;AAC1I,uCAAuC,QAAQ,8FAA8F;AAC7I,gCAAgC;AAChC;AACA,eAAe;AACf,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,2BAA2B;;;;;;;;;;;ACtZd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,uDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,kHAAkH;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB,MAAM,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iBAAiB;;;;;;;;;;;ACvHJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,uDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,4BAA4B;AAC1F,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iBAAiB;;;;;;;;;;;ACzGJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACnER;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,oBAAoB;AACpB,kBAAkB;AAClB,sBAAsB;AACtB,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,0DAA0D,yBAAyB,kBAAkB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,6DAA6D,yBAAyB,oBAAoB;AAC1G;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,gEAAgE,yBAAyB,sBAAsB;AAC/G;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;;;;;;;;;;ACtHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA,2DAA2D,uCAAuC;AAClG;AACA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D,yCAAyC;AACtG;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA,2DAA2D,gDAAgD,mBAAmB;AAC9H;AACA,+DAA+D,4CAA4C;AAC3G;AACA,wDAAwD,8DAA8D;AACtH,8DAA8D,0CAA0C;AACxG;AACA,4DAA4D,wCAAwC;AACpG;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mEAAmE,gDAAgD;AACnH,wDAAwD,yBAAyB,8CAA8C,iDAAiD;AAChL;AACA;AACA;AACA,4DAA4D,yBAAyB,uBAAuB,iDAAiD;AAC7J;AACA;AACA;AACA,8DAA8D,0BAA0B,mBAAmB,iDAAiD;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2DAA2D;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6DAA6D;AACpH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChKa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,yBAAyB;AACzB,wBAAwB;AACxB,sCAAsC;AACtC,uCAAuC;AACvC,6BAA6B;AAC7B,mCAAmC;AACnC,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,oCAAoC;AACpC,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C,kBAAkB,mBAAO,CAAC,8CAAiB,GAAG;AAC9C;AACA,YAAY,gEAAgE;AAC5E;AACA,YAAY,mBAAmB;AAC/B,uBAAuB,mBAAO,CAAC,0DAAuB;AACtD,0BAA0B,mBAAO,CAAC,gEAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D,kEAAkE,mBAAmB,WAAW,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,oCAAoC;AACpC;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA,8CAA8C;AAC9C;AACA,qCAAqC;AACrC;AACA;AACA,+DAA+D;AAC/D,iCAAiC,MAAM;AACvC;AACA;AACA,sEAAsE;AACtE,sCAAsC,MAAM;AAC5C;AACA;AACA,mDAAmD;AACnD;AACA;AACA,gEAAgE,MAAM,kBAAkB,UAAU;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa,GAAG,aAAa,GAAG,MAAM,GAAG;AACtE,gCAAgC,OAAO,GAAG,2CAA2C,OAAO,aAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU,OAAO,UAAU,GAAG,QAAQ;AAClG,iCAAiC,qBAAqB,GAAG,sBAAsB,GAAG,SAAS;AAC3F;AACA,sEAAsE,UAAU,aAAa,UAAU,GAAG,QAAQ;AAClH,+CAA+C,qBAAqB,SAAS,sBAAsB,IAAI,cAAc;AACrH;AACA;AACA,0CAA0C,MAAM,GAAG;AACnD,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,UAAU;AAClF,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,gBAAgB;AACvG;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB,GAAG;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE,sCAAsC;AACtC,2CAA2C;AAC3C,qCAAqC;AACrC,8CAA8C;AAC9C,4DAA4D;AAC5D,sDAAsD;AACtD;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,sCAAsC;AACtC;AACA,wBAAwB;AACxB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,sBAAsB,mBAAmB,GAAG,sBAAsB;AAClE;AACA,4BAA4B,qBAAqB,GAAG,MAAM;AAC1D,4BAA4B,qBAAqB,QAAQ,sBAAsB;AAC/E;AACA,2BAA2B,qBAAqB,SAAS,sBAAsB,IAAI,MAAM;AACzF,2BAA2B,qBAAqB,UAAU,sBAAsB;AAChF;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE,oCAAoC,SAAS;AAC7C,iCAAiC,SAAS,GAAG;AAC7C,4CAA4C;AAC5C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,6EAA6E;AAC7E,mCAAmC,QAAQ;AAC3C,sCAAsC,QAAQ,GAAG;AACjD,2CAA2C;AAC3C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,qCAAqC;AACrC;AACA,uCAAuC;AACvC;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACpwBV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;AC1Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,sCAAsC;AACtC;AACA,sEAAsE;AACtE,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;AClHR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,UAAU,YAAY,eAAe,WAAW,WAAW;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,8CAA8C;AAC9C;AACA,uEAAuE,iCAAiC;AACxG,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,mFAAmF,oBAAoB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,iGAAiG,oBAAoB;AACrH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oDAAoD;AACpD,uDAAuD;AACvD;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,KAAK,QAAQ;AACvD;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,4GAA4G,KAAK,GAAG;AACpH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,6FAA6F,aAAa,SAAS,cAAc;AACjI;AACA;AACA,0DAA0D,mCAAmC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,kBAAkB;AACzH,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;AClsBJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG,SAAS;AACT;AACA,yGAAyG;AACzG,SAAS;AACT;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA,4GAA4G;AAC5G,aAAa;AACb;AACA;AACA,+DAA+D;AAC/D,6GAA6G;AAC7G,aAAa;AACb,SAAS;AACT;AACA;AACA,4DAA4D;AAC5D,yGAAyG;AACzG,SAAS;AACT;AACA;AACA;AACA,gDAAgD;AAChD,qGAAqG;AACrG;AACA;;;;;;;;;;;AChFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB,GAAG;AAChD;AACA;;;;;;;;;;;AC9Fa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,qBAAqB;AACrB,uCAAuC,mBAAO,CAAC,+EAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,GAAG,cAAc,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA,uCAAuC,sBAAsB;AAC7D;AACA;;;;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B;AAC1B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,uBAAuB;AACvB,wBAAwB;AACxB,wCAAwC;AACxC,kBAAkB;AAClB,oBAAoB;AACpB,6BAA6B;AAC7B,gCAAgC;AAChC,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC,aAAa;AACb;AACA,yBAAyB;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA","sources":["webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/core/api-client.js","webpack://jupyter-simple-extension/./lib/core/globals.js","webpack://jupyter-simple-extension/./lib/core/icons.js","webpack://jupyter-simple-extension/./lib/handlers/history-handler.js","webpack://jupyter-simple-extension/./lib/handlers/input-handler.js","webpack://jupyter-simple-extension/./lib/handlers/message-handler.js","webpack://jupyter-simple-extension/./lib/handlers/note-handler.js","webpack://jupyter-simple-extension/./lib/handlers/popup-menu-manager.js","webpack://jupyter-simple-extension/./lib/handlers/settings-handler.js","webpack://jupyter-simple-extension/./lib/handlers/shortcut-handler.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/sidebar-widget.js","webpack://jupyter-simple-extension/./lib/state/chat-state.js","webpack://jupyter-simple-extension/./lib/state/note-state.js","webpack://jupyter-simple-extension/./lib/state/settings-state.js","webpack://jupyter-simple-extension/./lib/ui/dom-elements.js","webpack://jupyter-simple-extension/./lib/ui/layout-builder.js","webpack://jupyter-simple-extension/./lib/ui/message-renderer.js","webpack://jupyter-simple-extension/./lib/ui/note-modal.js","webpack://jupyter-simple-extension/./lib/ui/settings-modal.js","webpack://jupyter-simple-extension/./lib/ui/ui-manager.js","webpack://jupyter-simple-extension/./lib/utils/clipboard.js","webpack://jupyter-simple-extension/./lib/utils/content-editable-utils.js","webpack://jupyter-simple-extension/./lib/utils/highlighting.js","webpack://jupyter-simple-extension/./lib/utils/markdown-config.js","webpack://jupyter-simple-extension/./lib/utils/markdown.js","webpack://jupyter-simple-extension/./lib/utils/notebook-integration.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CellContextTracker = void 0;\n/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nclass CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\nexports.CellContextTracker = CellContextTracker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerCommands = registerCommands;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\"); // Import LabIcon if needed as placeholder\n// Placeholder icon (replace if you have a specific icon)\nconst extensionIcon = ui_components_1.LabIcon.resolve({ icon: 'ui-components:jupyterlab' }); // Use resolve for built-in\n/**\n * Registers commands for the extension\n */\nfunction registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\n/**\n * API client for interacting with the backend LLM service\n */\nclass ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\nexports.ApiClient = ApiClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globals = void 0;\nexports.initGlobals = initGlobals;\n/**\n * Global references to key components in the application\n */\nexports.globals = {};\n/**\n * Initialize global references\n */\nfunction initGlobals(app, notebookTracker) {\n    exports.globals.app = app;\n    exports.globals.notebookTracker = notebookTracker;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extensionIcon = void 0;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexports.extensionIcon = new ui_components_1.LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryHandler = void 0;\nconst message_renderer_1 = require(\"../ui/message-renderer\"); // Assuming renderers are needed\n/**\n * Manages the display and interaction logic for the chat history view.\n */\nclass HistoryHandler {\n    constructor(chatState, uiManager, callbacks, rendererCallbacks) {\n        this.isHistoryViewActive = false;\n        this.chatState = chatState;\n        this.uiManager = uiManager;\n        this.callbacks = callbacks;\n        this.rendererCallbacks = rendererCallbacks;\n        // Get the history container element from UIManager\n        this.historyContainer = this.uiManager.getUIElements().historyContainer;\n    }\n    /**\n     * Toggles between the main chat view and the history view.\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Use UIManager to hide chat, show history\n            this.uiManager.showHistoryView();\n            this.renderChatHistory(); // Populate the history view\n        }\n        else {\n            // Use UIManager to show chat, hide history\n            this.uiManager.showChatView();\n            // Ensure the correct title is displayed when switching back\n            const currentChat = this.chatState.getCurrentChat();\n            if (currentChat) {\n                this.callbacks.updateTitleInput(currentChat.title);\n            }\n        }\n    }\n    /**\n     * Renders the list of past chats in the history container.\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = ''; // Clear previous list\n        const history = this.chatState.getChatHistory();\n        const currentChatId = this.chatState.getCurrentChatId();\n        // Create header with back button\n        const header = document.createElement('div');\n        header.className = 'jp-llm-ext-history-header';\n        // Create back button\n        const backButton = document.createElement('button');\n        backButton.className = 'jp-Button jp-llm-ext-back-button';\n        backButton.innerHTML = '<span class=\"jp-icon3 jp-icon-selectable\" role=\"presentation\"><svg viewBox=\"0 0 24 24\"><path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"/></svg></span>';\n        backButton.title = 'Back to chat';\n        backButton.addEventListener('click', () => this.hideHistoryView());\n        const title = document.createElement('h2');\n        title.textContent = 'Chat History';\n        header.appendChild(backButton);\n        header.appendChild(title);\n        this.historyContainer.appendChild(header);\n        if (history.length === 0) {\n            this.historyContainer.innerHTML += '<div class=\"jp-llm-ext-history-empty\">No chat history yet.</div>';\n            return;\n        }\n        const list = document.createElement('ul');\n        list.className = 'jp-llm-ext-history-list';\n        history.forEach(chat => {\n            const listItem = document.createElement('li');\n            listItem.className = 'jp-llm-ext-history-item';\n            if (chat.id === currentChatId) {\n                listItem.classList.add('jp-llm-ext-active');\n            }\n            // Simple representation: Title\n            // TODO: Add preview, timestamp, delete button etc.\n            const titleDiv = document.createElement('div');\n            titleDiv.className = 'jp-llm-ext-history-item-title';\n            titleDiv.textContent = chat.title || 'Untitled Chat';\n            listItem.appendChild(titleDiv);\n            // Add click event to load the chat\n            listItem.addEventListener('click', () => this.loadChat(chat.id));\n            list.appendChild(listItem);\n        });\n        this.historyContainer.appendChild(list);\n    }\n    /**\n     * Loads a specific chat session from history into the main view.\n     */\n    loadChat(chatId) {\n        const chat = this.chatState.getChatById(chatId);\n        if (!chat) {\n            console.error(`Chat with ID ${chatId} not found.`);\n            return;\n        }\n        // Set this chat as the active one in the state\n        this.chatState.setCurrentChatId(chatId);\n        // Update the main UI title input\n        this.callbacks.updateTitleInput(chat.title);\n        // Clear the current message display\n        this.callbacks.clearMessageContainer();\n        // Re-populate the message container with messages from the loaded chat\n        // Use the renderer functions via callbacks\n        chat.messages.forEach((msg) => {\n            let messageElement;\n            if (msg.sender === 'user') {\n                messageElement = (0, message_renderer_1.renderUserMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);\n            }\n            else { // 'bot'\n                messageElement = (0, message_renderer_1.renderBotMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);\n            }\n            // Add the rendered element to the message container via callback\n            this.callbacks.addRenderedMessage(messageElement);\n        });\n        // Switch back to the chat view if we were in the history view\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView(); // This will call uiManager.showChatView()\n        }\n        else {\n            // If already in chat view, ensure scrolling is correct\n            this.uiManager.scrollToBottom();\n        }\n        // Optional: Re-render history list to update the active item indicator\n        // Only really needed if not switching views\n        // if (!this.isHistoryViewActive) { this.renderChatHistory(); }\n    }\n    /**\n     * Hides the history view and shows the chat view.\n     */\n    hideHistoryView() {\n        this.isHistoryViewActive = false;\n        this.uiManager.showChatView();\n        // Ensure the correct title is displayed when switching back\n        const currentChat = this.chatState.getCurrentChat();\n        if (currentChat) {\n            this.callbacks.updateTitleInput(currentChat.title);\n        }\n    }\n}\nexports.HistoryHandler = HistoryHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputHandler = void 0;\nconst content_editable_utils_1 = require(\"../utils/content-editable-utils\"); // Helper needed\nconst globals_1 = require(\"../core/globals\"); // Import globals\nconst message_renderer_1 = require(\"../ui/message-renderer\");\n/**\n * Handles events and logic related to the chat input field.\n */\nclass InputHandler {\n    constructor(chatInput, callbacks\n    // uiManager: UIManager // Removed unused parameter\n    ) {\n        // private uiManager: UIManager; // Removed unused member\n        // --- Code Reference State ---\n        this.codeRefMap = new Map();\n        this.nextRefId = 1;\n        // ---------------------------\n        this.hasAtSymbol = false;\n        this.isMarkdownMode = false; // Internal state, potentially synced with UIManager\n        this.isInputExpanded = false; // Internal state, potentially synced with UIManager\n        // NEW Click handler for widget interactions (e.g., expand)\n        this._handleClick = (event) => {\n            const target = event.target;\n            const widget = target.closest('.jp-llm-ext-ref-widget');\n            if (widget && widget.isContentEditable) {\n                // Don't trigger preview if clicking inside the main editable div itself\n                // Only trigger if clicking directly on a non-editable widget span\n                if (widget === this.chatInput)\n                    return; // Ignore clicks on the main div background\n            }\n            if (widget && !widget.isContentEditable) { // Ensure it's our non-editable widget span\n                const type = widget.dataset.type;\n                const content = widget.dataset.content;\n                const refId = widget.dataset.refId;\n                const path = widget.dataset.path;\n                console.log(`Widget clicked: Type=${type}, RefID=${refId}, Path=${path}`);\n                if ((type === 'code' || type === 'cell') && content) {\n                    event.preventDefault(); // Prevent potential text selection issues\n                    event.stopPropagation(); // Stop event from bubbling further\n                    this.showWidgetPreview(widget, content);\n                }\n                else {\n                    // Handle click on file/dir or widget without content? Maybe do nothing.\n                    // Or potentially remove existing preview if any\n                    this.removeWidgetPreview();\n                }\n            }\n            else {\n                // Click was not on a widget, remove any existing preview\n                this.removeWidgetPreview();\n            }\n        };\n        // --- Widget Preview Logic ---\n        this.activePreviewElement = null;\n        // --- Private Event Handlers ---\n        this._handleKeyPress = (event) => {\n            // Handle Enter key press (send message)\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault(); // Prevent default newline insertion\n                // NEW: Use serialization method to get the raw message with placeholders\n                let message = this._serializeInputContent();\n                message = message.trim(); // Trim whitespace\n                if (message) {\n                    // Resolve code references with proper formatting based on markdown mode\n                    const resolvedMessage = this.resolveCodeReferences(message, this.isMarkdownMode);\n                    // Pass resolved message with current markdown state\n                    this.callbacks.handleSendMessage(resolvedMessage, this.isMarkdownMode);\n                }\n            }\n            // --- Handle Tab/Escape/Arrows for popup interaction ---\n            // Check if popup is visible (needs a way to know, maybe via callbacks or direct reference?)\n            // Assuming popupMenuManager reference is available or state is tracked\n            // else if (this.popupMenuManager.isPopupMenuVisible()) { // Pseudo-code\n            //    if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n            //        // Prevent default input field behavior\n            //        event.preventDefault();\n            //        // Let the PopupMenuManager's document handler manage the event\n            //    }\n            // }\n            // --- End Popup Interaction Handling ---\n        };\n        this._handleInput = () => {\n            // Use textContent for div\n            const currentText = this.chatInput.textContent || '';\n            // --- Update Code Ref Placeholders --- \n            // Optional: If we want visual placeholders to update live\n            // This could involve complex DOM manipulation or using a library.\n            // For now, we resolve refs only on send.\n            // --- At Symbol Detection for Popup --- \n            // This logic was moved to UIManager.handleInputForReference\n            // because UIManager needs to coordinate showing the popup.\n            // InputHandler might still need to know *if* an @ was typed recently\n            // to adjust behavior (e.g., how Enter works), but UIManager handles the popup trigger.\n            // Simple check if text contains '@' for potential state management\n            this.hasAtSymbol = currentText.includes('@');\n            // Adjust input height dynamically based on content?\n            // Can be complex with contenteditable divs. Requires careful calculation.\n            // this.adjustInputHeight(); \n        };\n        // NEW Keydown handler for widget deletion etc.\n        this._handleKeyDown = (event) => {\n            var _a, _b;\n            const selection = window.getSelection();\n            if (!selection || !selection.rangeCount || !selection.isCollapsed) {\n                // Only handle single cursor position, not range selection\n                return;\n            }\n            const range = selection.getRangeAt(0);\n            const container = range.startContainer;\n            const offset = range.startOffset;\n            const key = event.key;\n            let widgetToDelete = null;\n            let nodeToCheck = null;\n            if (key === 'Backspace') {\n                if (offset > 0 && container.nodeType === Node.TEXT_NODE) {\n                    // Cursor is within a text node, check the node *before* this text node\n                    // But only if the cursor is at the *start* of the text node (offset === 0? No, check previousSibling always?)\n                    // Let's check the node directly preceding the container\n                    nodeToCheck = container.previousSibling;\n                }\n                else if (offset > 0 && container === this.chatInput) {\n                    // Cursor is between nodes in the main input div\n                    nodeToCheck = container.childNodes[offset - 1];\n                }\n                else if (offset === 0 && container !== this.chatInput) {\n                    // Cursor is at the beginning of a non-div node (e.g., start of a text node after a widget)\n                    // Need to check the node before the container\n                    nodeToCheck = container.previousSibling;\n                }\n                // Check if the node to check is a ZWS or space node, if so, check the node before that\n                if (nodeToCheck && nodeToCheck.nodeType === Node.TEXT_NODE && (nodeToCheck.textContent === '\\u200B' || nodeToCheck.textContent === ' ')) {\n                    nodeToCheck = nodeToCheck.previousSibling;\n                }\n            }\n            else if (key === 'Delete') {\n                if (container.nodeType === Node.TEXT_NODE && offset < container.length) {\n                    // Cursor is within a text node, check the node *after* this text node\n                    nodeToCheck = container.nextSibling;\n                }\n                else if (container === this.chatInput && offset < container.childNodes.length) {\n                    // Cursor is between nodes in the main input div\n                    nodeToCheck = container.childNodes[offset];\n                }\n                else if (container !== this.chatInput && offset === (((_a = container.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0)) {\n                    // Cursor is at the end of a non-div node (e.g., end of a text node before a widget)\n                    // Need to check the node after the container\n                    nodeToCheck = container.nextSibling;\n                }\n                // Check if the node to check is a ZWS or space node, if so, check the node after that\n                if (nodeToCheck && nodeToCheck.nodeType === Node.TEXT_NODE && (nodeToCheck.textContent === '\\u200B' || nodeToCheck.textContent === ' ')) {\n                    nodeToCheck = nodeToCheck.nextSibling;\n                }\n            }\n            // Check if the final nodeToCheck is a widget\n            if (nodeToCheck && nodeToCheck.nodeType === Node.ELEMENT_NODE && ((_b = nodeToCheck.classList) === null || _b === void 0 ? void 0 : _b.contains('jp-llm-ext-ref-widget'))) {\n                widgetToDelete = nodeToCheck;\n                console.log(`${key} pressed adjacent to widget:`, widgetToDelete);\n            }\n            if (widgetToDelete) {\n                event.preventDefault();\n                const parent = widgetToDelete.parentNode;\n                if (parent) {\n                    // Define nodes to remove: widget itself, potentially space before, potentially ZWS after\n                    const nodesToRemove = [widgetToDelete];\n                    const spaceBefore = widgetToDelete.previousSibling;\n                    const zwsAfter = widgetToDelete.nextSibling;\n                    if (spaceBefore && spaceBefore.nodeType === Node.TEXT_NODE && spaceBefore.textContent === ' ') {\n                        nodesToRemove.unshift(spaceBefore); // Add space to beginning of removal list\n                    }\n                    if (zwsAfter && zwsAfter.nodeType === Node.TEXT_NODE && zwsAfter.textContent === '\\u200B') {\n                        nodesToRemove.push(zwsAfter); // Add ZWS to end of removal list\n                    }\n                    // Remove all identified nodes\n                    nodesToRemove.forEach(node => parent.removeChild(node));\n                    // Optional: Remove ref from map if it was a code/cell ref\n                    const refId = widgetToDelete.dataset.refId;\n                    if (refId && this.codeRefMap.has(refId)) {\n                        this.codeRefMap.delete(refId);\n                        console.log('Removed reference from map:', refId);\n                    }\n                    // Trigger input event manually after deletion\n                    this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n                }\n            }\n        };\n        this.chatInput = chatInput;\n        this.callbacks = callbacks;\n        // this.uiManager = uiManager; // Removed unused assignment\n        // Bind event listeners\n        this.chatInput.addEventListener('keypress', this._handleKeyPress);\n        this.chatInput.addEventListener('input', this._handleInput);\n        this.chatInput.addEventListener('keydown', this._handleKeyDown);\n        this.chatInput.addEventListener('click', this._handleClick); // ADDED Click Listener\n        // Note: Actual markdown toggle and expand buttons are likely managed by UIManager,\n        // which would then call methods like `setMarkdownMode` or `toggleExpansion` on this handler.\n    }\n    /**\n     * Removes event listeners.\n     */\n    dispose() {\n        this.chatInput.removeEventListener('keypress', this._handleKeyPress);\n        this.chatInput.removeEventListener('input', this._handleInput);\n        this.chatInput.removeEventListener('keydown', this._handleKeyDown);\n        this.chatInput.removeEventListener('click', this._handleClick); // ADDED\n    }\n    /**\n     * Appends text to the input field, potentially replacing a preceding '@' symbol.\n     */\n    appendToInput(text) {\n        try {\n            this.chatInput.focus(); // Ensure focus first\n            const selection = window.getSelection();\n            if (!selection || selection.rangeCount === 0) {\n                console.error('Cannot append to input: No selection found.');\n                // Fallback: append to end\n                this.chatInput.textContent = (this.chatInput.textContent || '') + text;\n                return;\n            }\n            const range = selection.getRangeAt(0);\n            const { startContainer, startOffset } = range;\n            let currentTextContent = this.chatInput.textContent || ''; // Use textContent\n            let insertPos = (0, content_editable_utils_1.getCaretPosition)(this.chatInput); // Get linear position\n            // Simple check: if the character before the linear caret position is '@'\n            if (insertPos > 0 && currentTextContent[insertPos - 1] === '@') {\n                // Replace the '@' - more complex with DOM manipulation,\n                // For simplicity, we'll replace in textContent and reset\n                const before = currentTextContent.slice(0, insertPos - 1);\n                const after = currentTextContent.slice(insertPos);\n                this.chatInput.textContent = before + text + after;\n                // Set cursor position after the inserted text\n                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, (insertPos - 1) + text.length);\n            }\n            else {\n                // Standard insertion - more complex with DOM manipulation\n                // For simplicity, we'll insert in textContent and reset\n                const before = currentTextContent.slice(0, insertPos);\n                const after = currentTextContent.slice(insertPos);\n                this.chatInput.textContent = before + text + after;\n                // Set cursor position after the inserted text\n                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, insertPos + text.length);\n            }\n            // Trigger input event manually since we're changing textContent directly\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error appending to input:', error);\n        }\n    }\n    /**\n     * Clears the input field and resets associated state after sending.\n     */\n    clearInput() {\n        // Use textContent for div\n        this.chatInput.textContent = '';\n        // Directly reset internal state instead of relying on callback\n        this.resetCodeReferences();\n        // Remove rows manipulation\n        // this.chatInput.rows = 1;\n        this.chatInput.style.height = ''; // Reset height\n        this.hasAtSymbol = false; // Reset @ state\n        // Reset expand button state if it was expanded\n        if (this.isInputExpanded) {\n            this.toggleInputExpansion(false); // Collapse input\n        }\n        // Trigger input event manually after clearing\n        this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n    }\n    /**\n     * Sets the markdown mode state and updates the placeholder.\n     */\n    setMarkdownMode(isMarkdown) {\n        this.isMarkdownMode = isMarkdown;\n        this.callbacks.updatePlaceholder(this.isMarkdownMode);\n        // Update placeholder directly (alternative to callback)\n        // this.chatInput.placeholder = this.isMarkdownMode ? \n        //   'Write markdown here...' : \n        //   'Ask me anything...';\n    }\n    /**\n     * Toggles the input expansion state and updates UI.\n     */\n    toggleInputExpansion(forceState) {\n        this.isInputExpanded = forceState !== undefined ? forceState : !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            // Use max-height or height for div\n            this.chatInput.style.height = '200px'; // Example height\n            // Allow vertical resizing if desired, or keep as 'none'\n            this.chatInput.style.resize = 'vertical';\n            this.chatInput.style.overflowY = 'auto'; // Ensure scrollbar appears if needed\n        }\n        else {\n            this.chatInput.style.height = ''; // Reset height\n            this.chatInput.style.resize = 'none';\n            // Remove rows manipulation\n            // this.chatInput.rows = 1; // Ensure it collapses back to 1 row height\n            this.chatInput.style.overflowY = 'hidden'; // Hide scrollbar when collapsed\n        }\n        // Notify UIManager/LayoutBuilder to update button appearance\n        this.callbacks.toggleInputExpansionUI(this.isInputExpanded);\n    }\n    // --- Code Reference Methods ---\n    /**\n     * Adds a code reference to the internal map and returns its ID.\n     * @param codeContent The actual code content.\n     * @param notebookName The name of the notebook the code is from.\n     * @param cellIndex The index of the cell the code is from (0-based).\n     * @param lineNumber The starting line number of the code within the cell (1-based).\n     * @param lineEndNumber The ending line number of the code within the cell (1-based).\n     * @returns The generated reference ID (e.g., \"ref-1\").\n     */\n    addCodeReference(codeContent, // Renamed parameter\n    notebookName, cellIndex, lineNumber, // Start line\n    lineEndNumber // End line\n    ) {\n        const refId = `ref-${this.nextRefId++}`;\n        // Store type and use 'content' field\n        const refData = {\n            type: 'code',\n            content: codeContent, // Use content field\n            notebookName,\n            cellIndex,\n            lineNumber,\n            lineEndNumber\n        };\n        this.codeRefMap.set(refId, refData);\n        console.log('Added code reference:', refId, '->', `(${notebookName}, Cell ${cellIndex + 1}, Line ${lineNumber}${lineNumber !== lineEndNumber ? '_' + lineEndNumber : ''}) ` +\n            codeContent.substring(0, 30) + '...' // Use codeContent\n        );\n        return refId;\n    }\n    /**\n     * Returns the current map of code references.\n     */\n    getCodeReferenceMap() {\n        return this.codeRefMap;\n    }\n    /**\n     * Clears the code reference map and resets the ID counter.\n     */\n    resetCodeReferences() {\n        // --- DEBUG LOG --- \n        console.log('[InputHandler] resetCodeReferences called!', new Error().stack); // Log call stack\n        // --- END DEBUG LOG --- \n        this.codeRefMap.clear();\n        this.nextRefId = 1;\n        console.log('Code references reset.'); // Debug log\n    }\n    /**\n     * Replaces code reference placeholders (e.g., \"[ref-1]\") in a message string\n     * with the actual code from the map.\n     * @param message The message string potentially containing placeholders.\n     * @param isMarkdown Whether the message should be formatted for markdown\n     * @returns The message string with placeholders resolved.\n     */\n    resolveCodeReferences(message, isMarkdown = false) {\n        if (this.codeRefMap.size === 0) {\n            return message; // No references to resolve\n        }\n        // Regex to find placeholders like [ref-1], [ref-12], etc.\n        // Adjusted regex slightly to be non-greedy if needed, though current format is fine.\n        const placeholderRegex = /@(?:code|Cell)\\[(ref-\\d+)\\]|@code\\((?:[^)]+)\\)\\[(ref-\\d+)\\]|\\[(ref-\\d+)\\]/g;\n        let resolvedMessage = message.replace(placeholderRegex, (match, refId1, refId2, refId3) => {\n            const refId = refId1 || refId2 || refId3; // Get the captured refId\n            if (!refId)\n                return match; // If somehow no refId captured, return original match\n            const refData = this.codeRefMap.get(refId);\n            if (refData) {\n                console.log(`Resolving ${refData.type} reference:`, refId); // Debug log type\n                // Use refData.content (renamed from refData.code)\n                // Add context based on type?\n                let prefix, suffix;\n                if (isMarkdown) {\n                    // Format for markdown with code block\n                    const lang = refData.type === 'code' ? 'python' : ''; // Default to python for code, blank for cell\n                    prefix = refData.type === 'cell' ?\n                        `\\n\\`\\`\\`${lang} # Cell ${refData.cellIndex + 1} (${refData.notebookName})\\n` :\n                        `\\n\\`\\`\\`${lang} # Code (${refData.notebookName}:Cell ${refData.cellIndex + 1}:L${refData.lineNumber}-${refData.lineEndNumber})\\n`;\n                    suffix = `\\n\\`\\`\\``;\n                }\n                else {\n                    // Plain text format\n                    prefix = refData.type === 'cell' ?\n                        `\\n--- Start Cell ${refData.cellIndex + 1} (${refData.notebookName}) ---\\n` :\n                        `\\n--- Start Code (${refData.notebookName}:Cell ${refData.cellIndex + 1}:L${refData.lineNumber}-${refData.lineEndNumber}) ---\\n`;\n                    suffix = refData.type === 'cell' ?\n                        `\\n--- End Cell ${refData.cellIndex + 1} ---` :\n                        `\\n--- End Code ---`;\n                }\n                return `${prefix}${refData.content}${suffix}`;\n            }\n            else {\n                console.warn('Could not find data for reference:', refId); // Warn if ref ID not found\n                return match; // Keep the placeholder if not found\n            }\n        });\n        return resolvedMessage;\n    }\n    // NEW method specifically for Ctrl+L shortcut\n    handleInsertCodeReferenceFromShortcut(selectedText) {\n        var _a, _b, _c;\n        const currentNotebookWidget = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;\n        const activeCell = (_b = globals_1.globals.notebookTracker) === null || _b === void 0 ? void 0 : _b.activeCell;\n        const editor = activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor;\n        const cmEditor = editor ? editor.editor : null; // CodeMirror view\n        if (!currentNotebookWidget || !activeCell || !editor || !cmEditor || !cmEditor.state) {\n            console.error('Cannot insert code reference: Missing notebook, cell, or editor context.');\n            // Optionally show an indicator via callbacks?\n            return;\n        }\n        try {\n            // 1. Gather Context\n            const notebookPath = currentNotebookWidget.context.path;\n            const notebookName = ((_c = notebookPath.split('/').pop()) === null || _c === void 0 ? void 0 : _c.split('.')[0]) || 'notebook';\n            const cellIndex = currentNotebookWidget.content.activeCellIndex;\n            const state = cmEditor.state;\n            const selection = state.selection.main;\n            const startLine = state.doc.lineAt(selection.from).number; // 1-based\n            const endLine = state.doc.lineAt(selection.to).number; // 1-based\n            if (cellIndex === undefined || cellIndex === null) {\n                console.error('Cannot insert code reference: Could not determine active cell index.');\n                return;\n            }\n            // 2. Create Ref Data (but don't necessarily add to map yet? Or do?)\n            // Let's add it now for consistency.\n            const refData = {\n                type: 'code',\n                content: selectedText,\n                notebookName,\n                cellIndex,\n                lineNumber: startLine,\n                lineEndNumber: endLine\n            };\n            const refId = `ref-${this.nextRefId++}`;\n            this.codeRefMap.set(refId, refData);\n            console.log(`Added code reference via shortcut: ${refId}`);\n            // ADDED: Construct placeholder\n            const placeholder = `@code[${refId}]`;\n            // 3. Insert RENDERED WIDGET Representation into Input Field\n            this.chatInput.focus(); // Ensure focus\n            const winSelection = window.getSelection();\n            if (!winSelection || winSelection.rangeCount === 0) {\n                console.error('Cannot insert reference widget: No window selection found.');\n                // Fallback might be complex, maybe just log error for now\n                return;\n            }\n            const range = winSelection.getRangeAt(0);\n            // Render the widget - Pass placeholder\n            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('code', refData, placeholder, refId);\n            // Create a zero-width space text node for cursor positioning\n            const zeroWidthSpace = document.createTextNode('\\u200B');\n            // Add a normal space for separation\n            const spaceNode = document.createTextNode(' ');\n            range.deleteContents(); // Clear any existing selection in the input field\n            range.insertNode(spaceNode); // Insert space first\n            range.insertNode(widgetElement); // Insert the widget element\n            range.insertNode(zeroWidthSpace); // Insert ZWS after widget\n            // Move cursor after the zero-width space (effectively after the widget + space)\n            range.setStartAfter(zeroWidthSpace);\n            range.setEndAfter(zeroWidthSpace);\n            winSelection.removeAllRanges();\n            winSelection.addRange(range);\n            // --- End Insertion Logic ---\n            // Trigger input event manually\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error handling insert code reference from shortcut:', error);\n        }\n    }\n    // NEW: Method to add a cell reference\n    addCellReference(notebookName, cellIndex) {\n        var _a;\n        const notebookPanel = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;\n        if (!notebookPanel || !notebookPanel.content.model || !notebookPanel.content.model.cells) {\n            console.error('Cannot add cell reference: Notebook or cells not found.');\n            return null;\n        }\n        const model = notebookPanel.content.model;\n        if (cellIndex < 0 || cellIndex >= model.cells.length) {\n            console.error(`Cannot add cell reference: Invalid cell index ${cellIndex}`);\n            return null;\n        }\n        const cell = model.cells.get(cellIndex);\n        let cellContent = '';\n        // Get cell content - handle different ways content might be stored\n        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {\n            cellContent = cell.sharedModel.getSource();\n        }\n        else {\n            const cellJson = cell.toJSON();\n            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n            if (typeof source === 'string') {\n                cellContent = source;\n            }\n            else if (Array.isArray(source)) {\n                cellContent = source.join('\\n'); // Corrected: Use actual newline\n            }\n        }\n        const refId = `ref-${this.nextRefId++}`;\n        const refData = {\n            type: 'cell',\n            content: cellContent,\n            notebookName,\n            cellIndex\n            // lineNumber/lineEndNumber are omitted\n        };\n        this.codeRefMap.set(refId, refData);\n        // Combine console.log into one line\n        console.log(`Added cell reference: ${refId} -> (${notebookName}, Cell ${cellIndex + 1}) ${cellContent.substring(0, 30)}...`);\n        return refId;\n    }\n    // NEW method specifically for Ctrl+L shortcut (Cell)\n    handleInsertCellReferenceFromShortcut() {\n        var _a, _b, _c;\n        const currentNotebookWidget = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;\n        const activeCell = (_b = globals_1.globals.notebookTracker) === null || _b === void 0 ? void 0 : _b.activeCell;\n        if (!currentNotebookWidget || !activeCell) {\n            console.error('Cannot insert cell reference: Missing notebook or cell context.');\n            return;\n        }\n        try {\n            // 1. Gather Context\n            const notebookPath = currentNotebookWidget.context.path;\n            const notebookName = ((_c = notebookPath.split('/').pop()) === null || _c === void 0 ? void 0 : _c.split('.')[0]) || 'notebook';\n            const cellIndex = currentNotebookWidget.content.activeCellIndex;\n            if (cellIndex === undefined || cellIndex === null) {\n                console.error('Cannot insert cell reference: Could not determine active cell index.');\n                return;\n            }\n            // 2. Add Cell Reference to Map and get data\n            const refId = this.addCellReference(notebookName, cellIndex);\n            if (!refId) {\n                console.error('Failed to add cell reference to map.');\n                return; // Stop if we couldn't create the reference data\n            }\n            const refData = this.codeRefMap.get(refId);\n            if (!refData) {\n                console.error(`Failed to retrieve data for cell reference ${refId}.`);\n                return;\n            }\n            // ADDED: Construct placeholder\n            const placeholder = `@Cell[${cellIndex + 1}]`;\n            // 3. Insert RENDERED WIDGET Representation into Input Field\n            this.chatInput.focus(); // Ensure focus\n            const winSelection = window.getSelection();\n            if (!winSelection || winSelection.rangeCount === 0) {\n                console.error('Cannot insert reference widget: No window selection found.');\n                return;\n            }\n            const range = winSelection.getRangeAt(0);\n            // Render the widget - Pass placeholder\n            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('cell', refData, placeholder, refId);\n            // Create a zero-width space text node for cursor positioning\n            const zeroWidthSpace = document.createTextNode('\\u200B');\n            // Add a normal space for separation\n            const spaceNode = document.createTextNode(' ');\n            range.deleteContents(); // Clear any existing selection in the input field\n            range.insertNode(spaceNode); // Insert space first\n            range.insertNode(widgetElement); // Insert the widget element\n            range.insertNode(zeroWidthSpace); // Insert ZWS after widget\n            // Move cursor after the zero-width space\n            range.setStartAfter(zeroWidthSpace);\n            range.setEndAfter(zeroWidthSpace);\n            winSelection.removeAllRanges();\n            winSelection.addRange(range);\n            // Trigger input event manually\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error handling insert cell reference from shortcut:', error);\n        }\n    }\n    // NEW method for inserting File widgets from Popup\n    handleInsertFileWidget(filePath) {\n        var _a;\n        try {\n            this.chatInput.focus(); // Ensure focus\n            const winSelection = window.getSelection();\n            if (!winSelection || winSelection.rangeCount === 0) {\n                console.error('Cannot insert file widget: No window selection found.');\n                return;\n            }\n            // Get the current selection range\n            const range = winSelection.getRangeAt(0);\n            // Construct placeholder\n            const placeholder = `@file[${filePath}]`;\n            // Render the widget - Pass placeholder (no refId needed)\n            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('file', filePath, placeholder);\n            // Create a zero-width space text node for cursor positioning\n            const zeroWidthSpace = document.createTextNode('\\u200B');\n            // Add a normal space for separation\n            const spaceNode = document.createTextNode(' ');\n            // Check if the character before the cursor is '@' and replace it\n            let replacedAtSymbol = false;\n            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {\n                const textBefore = (_a = range.startContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, range.startOffset);\n                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {\n                    // Modify the range to include the '@'\n                    range.setStart(range.startContainer, range.startOffset - 1);\n                    replacedAtSymbol = true;\n                    console.log(\"Replacing @ symbol before inserting file widget.\"); // Debug log\n                }\n            }\n            // Wrap the widget and additional nodes in a fragment for cleaner insertion\n            const fragment = document.createDocumentFragment();\n            fragment.appendChild(widgetElement);\n            fragment.appendChild(zeroWidthSpace);\n            fragment.appendChild(spaceNode);\n            // Delete any selected content (including @ if found)\n            range.deleteContents();\n            // Insert the fragment with all elements\n            range.insertNode(fragment);\n            // Explicitly move cursor after the inserted space node\n            const newRange = document.createRange();\n            newRange.setStartAfter(spaceNode);\n            newRange.setEndAfter(spaceNode);\n            winSelection.removeAllRanges();\n            winSelection.addRange(newRange);\n            // Trigger input event manually\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error handling insert file widget:', error);\n        }\n    }\n    // NEW method for inserting Directory widgets from Popup\n    handleInsertDirWidget(dirPath) {\n        var _a;\n        try {\n            this.chatInput.focus(); // Ensure focus\n            const winSelection = window.getSelection();\n            if (!winSelection || winSelection.rangeCount === 0) {\n                console.error('Cannot insert directory widget: No window selection found.');\n                return;\n            }\n            const range = winSelection.getRangeAt(0);\n            // Construct placeholder\n            const placeholder = `@dir[${dirPath}]`;\n            // Render the widget - Pass placeholder (no refId needed)\n            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('dir', dirPath, placeholder);\n            // Create a zero-width space text node for cursor positioning\n            const zeroWidthSpace = document.createTextNode('\\u200B');\n            // Add a normal space for separation\n            const spaceNode = document.createTextNode(' ');\n            // Check if the character before the cursor is '@' and replace it\n            let replacedAtSymbol = false;\n            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {\n                const textBefore = (_a = range.startContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, range.startOffset);\n                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {\n                    // Modify the range to include the '@'\n                    range.setStart(range.startContainer, range.startOffset - 1);\n                    replacedAtSymbol = true;\n                    console.log(\"Replacing @ symbol before inserting dir widget.\"); // Debug log\n                }\n            }\n            // Wrap the widget and additional nodes in a fragment for cleaner insertion\n            const fragment = document.createDocumentFragment();\n            fragment.appendChild(widgetElement);\n            fragment.appendChild(zeroWidthSpace);\n            fragment.appendChild(spaceNode);\n            // Delete any selected content (including @ if found)\n            range.deleteContents();\n            // Insert the fragment with all elements\n            range.insertNode(fragment);\n            // Explicitly move cursor after the inserted space node\n            const newRange = document.createRange();\n            newRange.setStartAfter(spaceNode);\n            newRange.setEndAfter(spaceNode);\n            winSelection.removeAllRanges();\n            winSelection.addRange(newRange);\n            // Trigger input event manually\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error handling insert directory widget:', error);\n        }\n    }\n    // NEW method for inserting Cell widgets from Popup\n    handleInsertCellWidgetFromPopup(cellIndex) {\n        var _a, _b, _c;\n        const currentNotebookWidget = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;\n        if (!currentNotebookWidget) {\n            console.error('Cannot insert cell widget: Missing notebook context.');\n            return;\n        }\n        try {\n            // 1. Gather Context (Notebook Name)\n            const notebookPath = currentNotebookWidget.context.path;\n            const notebookName = ((_b = notebookPath.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';\n            // Provided cellIndex is 0-based already\n            if (cellIndex === undefined || cellIndex === null || cellIndex < 0) {\n                console.error(`Cannot insert cell widget: Invalid cell index ${cellIndex}.`);\n                return;\n            }\n            // 2. Add Cell Reference to Map and get data\n            const refId = this.addCellReference(notebookName, cellIndex);\n            if (!refId) {\n                console.error('Failed to add cell reference to map for index:', cellIndex);\n                return; // Stop if we couldn't create the reference data\n            }\n            const refData = this.codeRefMap.get(refId);\n            if (!refData) {\n                console.error(`Failed to retrieve data for cell reference ${refId}.`);\n                return;\n            }\n            // ADDED: Construct placeholder\n            const placeholder = `@Cell[${cellIndex + 1}]`;\n            // 3. Insert RENDERED WIDGET Representation into Input Field\n            this.chatInput.focus(); // Ensure focus\n            const winSelection = window.getSelection();\n            if (!winSelection || winSelection.rangeCount === 0) {\n                console.error('Cannot insert cell widget: No window selection found.');\n                return;\n            }\n            const range = winSelection.getRangeAt(0);\n            // Render the widget - Pass placeholder\n            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('cell', refData, placeholder, refId);\n            const zeroWidthSpace = document.createTextNode('\\u200B');\n            const spaceNode = document.createTextNode(' ');\n            // Check if the character before the cursor is '@' and replace it\n            let replacedAtSymbol = false;\n            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {\n                const textBefore = (_c = range.startContainer.textContent) === null || _c === void 0 ? void 0 : _c.substring(0, range.startOffset);\n                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {\n                    range.setStart(range.startContainer, range.startOffset - 1);\n                    replacedAtSymbol = true;\n                    console.log(\"Replacing @ symbol before inserting cell widget.\");\n                }\n            }\n            // Create a fragment to hold our nodes in the correct order\n            const fragment = document.createDocumentFragment();\n            fragment.appendChild(widgetElement);\n            fragment.appendChild(zeroWidthSpace);\n            fragment.appendChild(spaceNode);\n            // Delete any selected content (including @ if found)\n            range.deleteContents();\n            // Insert all elements at once in the correct order\n            range.insertNode(fragment);\n            // Move cursor after the zero-width space\n            range.setStartAfter(spaceNode);\n            range.setEndAfter(spaceNode);\n            winSelection.removeAllRanges();\n            winSelection.addRange(range);\n            // Trigger input event manually\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error handling insert cell widget from popup:', error);\n        }\n    }\n    // NEW method for inserting Code widgets from Popup (via insertCollapsedCodeRef callback)\n    handleInsertCodeWidgetFromPopup(codeContent, notebookName, cellIndex, lineNumber // Assumes start line = end line from popup callback\n    ) {\n        var _a;\n        try {\n            // 1. Create Ref Data (assume start=end line)\n            const lineEndNumber = lineNumber;\n            const refData = {\n                type: 'code',\n                content: codeContent,\n                notebookName,\n                cellIndex,\n                lineNumber,\n                lineEndNumber\n            };\n            const refId = `ref-${this.nextRefId++}`;\n            this.codeRefMap.set(refId, refData);\n            console.log(`Added code reference via popup: ${refId}`);\n            // ADDED: Construct placeholder\n            const placeholder = `@code[${refId}]`;\n            // 2. Insert RENDERED WIDGET Representation into Input Field\n            this.chatInput.focus(); // Ensure focus\n            const winSelection = window.getSelection();\n            if (!winSelection || winSelection.rangeCount === 0) {\n                console.error('Cannot insert code widget: No window selection found.');\n                return;\n            }\n            const range = winSelection.getRangeAt(0);\n            // Render the widget - Pass placeholder\n            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('code', refData, placeholder, refId);\n            const zeroWidthSpace = document.createTextNode('\\u200B');\n            const spaceNode = document.createTextNode(' ');\n            // Check if the character before the cursor is '@' and replace it\n            let replacedAtSymbol = false;\n            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {\n                const textBefore = (_a = range.startContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, range.startOffset);\n                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {\n                    range.setStart(range.startContainer, range.startOffset - 1);\n                    replacedAtSymbol = true;\n                    console.log(\"Replacing @ symbol before inserting code widget.\");\n                }\n            }\n            // Create a fragment to hold our nodes in the correct order\n            const fragment = document.createDocumentFragment();\n            fragment.appendChild(widgetElement);\n            fragment.appendChild(zeroWidthSpace);\n            fragment.appendChild(spaceNode);\n            // Delete any selected content (including @ if found)\n            range.deleteContents();\n            // Insert all elements at once in the correct order\n            range.insertNode(fragment);\n            // Move cursor after the zero-width space\n            range.setStartAfter(spaceNode);\n            range.setEndAfter(spaceNode);\n            winSelection.removeAllRanges();\n            winSelection.addRange(range);\n            // Trigger input event manually\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error handling insert code widget from popup:', error);\n        }\n    }\n    // NEW method to serialize input content, converting widgets back to placeholders\n    _serializeInputContent() {\n        let serialized = '';\n        const nodes = this.chatInput.childNodes;\n        nodes.forEach(node => {\n            var _a;\n            if (node.nodeType === Node.TEXT_NODE) {\n                // Append text content directly\n                serialized += node.textContent || '';\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                // Check if it's our widget span\n                if ((_a = element.classList) === null || _a === void 0 ? void 0 : _a.contains('jp-llm-ext-ref-widget')) {\n                    // Append the stored placeholder text\n                    const placeholder = element.dataset.placeholder;\n                    if (placeholder) {\n                        serialized += placeholder;\n                    }\n                    else {\n                        // Fallback: append the visible text if placeholder is missing (shouldn't happen)\n                        console.warn('Widget found without data-placeholder:', element);\n                        serialized += element.textContent || '';\n                    }\n                }\n                else if (element.tagName === 'BR') {\n                    // Handle <br> as newline\n                    serialized += '\\n';\n                }\n                else if (element.tagName === 'DIV') {\n                    // Handle <div> elements, potentially introduced by pasting or Shift+Enter\n                    // Recursively serialize or just add newline?\n                    // Add newline before and serialize inner content recursively?\n                    // For now, let's treat div boundaries as potential newlines, similar to <br>\n                    // We might need a more robust HTML -> text conversion later\n                    serialized += '\\n'; // Simplified handling\n                }\n                else {\n                    // Append text content of other unknown elements?\n                    serialized += element.textContent || '';\n                }\n            }\n        });\n        // Trim potentially leading/trailing whitespace introduced during serialization\n        // or by the structure of the contenteditable div\n        return serialized.trim();\n    }\n    showWidgetPreview(widgetElement, content) {\n        // Remove existing preview first\n        this.removeWidgetPreview();\n        console.log('Showing preview for widget:', widgetElement);\n        const firstThreeLines = content.split('\\n').slice(0, 3).join('\\n');\n        const preview = document.createElement('div');\n        preview.className = 'jp-llm-ext-widget-preview';\n        // Basic styling (move to CSS later)\n        preview.style.position = 'absolute';\n        preview.style.border = '1px solid var(--jp-border-color1)';\n        preview.style.background = 'var(--jp-layout-color0)';\n        preview.style.padding = '5px';\n        preview.style.fontSize = '0.9em';\n        preview.style.maxWidth = '400px';\n        preview.style.maxHeight = '100px';\n        preview.style.overflow = 'hidden';\n        preview.style.whiteSpace = 'pre-wrap'; // Preserve whitespace and newlines\n        preview.style.fontFamily = 'monospace';\n        preview.style.zIndex = '10000'; // Ensure it's on top\n        preview.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';\n        preview.textContent = firstThreeLines + (content.split('\\n').length > 3 ? '\\n...' : '');\n        // Position near the widget\n        const widgetRect = widgetElement.getBoundingClientRect();\n        // Position above the widget for now\n        preview.style.bottom = `${window.innerHeight - widgetRect.top + 5}px`;\n        preview.style.left = `${widgetRect.left}px`;\n        document.body.appendChild(preview); // Append to body to avoid layout issues\n        this.activePreviewElement = preview;\n    }\n    removeWidgetPreview() {\n        if (this.activePreviewElement) {\n            console.log('Removing active preview');\n            this.activePreviewElement.remove();\n            this.activePreviewElement = null;\n        }\n    }\n    /**\n      // Handle @ symbol removal to hide popup using selection API\n      const selection = window.getSelection();\n      if (!selection || !selection.rangeCount) return;\n  \n      const range = selection.getRangeAt(0);\n      // Check if the input field contains the start of the range\n      if (!this.chatInput.contains(range.startContainer)) return;\n  \n      const cursorPosition = getCaretPosition(this.chatInput); // Use helper\n      if (cursorPosition === null) return;\n  \n      const textContent = this.chatInput.textContent || '';\n      const textBeforeCursor = textContent.slice(0, cursorPosition);\n  \n      // Check if the character immediately before the cursor is '@'\n      // and if it's preceded by whitespace or is at the start of the input.\n      const isAtSymbolContext = textBeforeCursor.endsWith('@') &&\n                             (cursorPosition === 1 ||\n                              cursorPosition > 1 && /\\s/.test(textBeforeCursor[cursorPosition - 2]));\n  \n      if (this.hasAtSymbol && !isAtSymbolContext) {\n        // @ symbol context was present but now it's gone, hide the popup\n        this.callbacks.hidePopupMenu();\n      }\n      // Update the state *after* checking the previous state\n      this.hasAtSymbol = isAtSymbolContext;\n  \n      // --- Auto-resize logic (optional) ---\n      // Simple auto-resize based on scroll height (might need refinement)\n      if (!this.isInputExpanded) { // Only auto-resize if not manually expanded\n          this.chatInput.style.height = 'auto'; // Temporarily shrink to content\n          const scrollHeight = this.chatInput.scrollHeight;\n          // Set a max height to prevent infinite growth, e.g., 150px\n          const maxHeight = 150;\n          const newHeight = Math.min(scrollHeight, maxHeight);\n           // Only update height if it actually changes to avoid flicker\n          if (this.chatInput.offsetHeight < newHeight) {\n               this.chatInput.style.height = `${newHeight}px`;\n               this.chatInput.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';\n          } else if (scrollHeight <= this.chatInput.clientHeight) {\n              // Shrink if content height is less than current height\n              this.chatInput.style.height = `${scrollHeight}px`;\n              this.chatInput.style.overflowY = 'hidden';\n          }\n      }\n      // -----------------------------------\n    };\n    \n    /**\n     * Explicitly sets the hasAtSymbol flag. Called by shortcut handler.\n     */\n    setHasAtSymbol(value) {\n        this.hasAtSymbol = value;\n    }\n    /**\n     * Gets the current value of the hasAtSymbol flag. Called by shortcut handler.\n     */\n    getHasAtSymbol() {\n        return this.hasAtSymbol;\n    }\n}\nexports.InputHandler = InputHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageHandler = void 0;\nconst message_renderer_1 = require(\"../ui/message-renderer\");\nconst notebook_integration_1 = require(\"../utils/notebook-integration\");\nconst globals_1 = require(\"../core/globals\"); // Import globals for notebook tracker\n/**\n * Handles sending messages, interacting with the API,\n * managing streaming responses, and updating the UI and state.\n */\nclass MessageHandler {\n    constructor(apiClient, chatState, uiManager, rendererCallbacks, inputHandler) {\n        this.apiClient = apiClient;\n        this.chatState = chatState;\n        this.uiManager = uiManager;\n        this.rendererCallbacks = rendererCallbacks;\n        this.inputHandler = inputHandler;\n    }\n    /**\n     * Processes and sends a user-initiated message.\n     * Also handles adding the user message to the UI and clearing the input.\n     * Accepts the message text.\n     */\n    handleSendMessage(message, isMarkdown = false) {\n        if (!message.trim())\n            return;\n        console.log(`[MessageHandler] Handling send: \"${message}\", Markdown: ${isMarkdown}`);\n        console.log(`[MessageHandler] isMarkdown type: ${typeof isMarkdown}, value: ${isMarkdown}`);\n        // Add user message to UI with isMarkdown flag\n        this.addMessage(message, 'user', isMarkdown);\n        // Clear input via InputHandler (which uses UIManager)\n        // REMOVED: this.inputHandler.clearInput(); // Input clearing is now handled by UIManager after the callback\n        // Send message to backend API and handle streaming response\n        this.streamAndRenderResponse(message);\n    }\n    /**\n     * Sends an automatic message (e.g., 'confirmed', 'rejected')\n     * to the backend and handles the streaming response.\n     * Also adds the user's confirmation/rejection action and a separator to the UI.\n     */\n    handleSendAutoMessage(message) {\n        if (!message.trim())\n            return;\n        // Add the user's action ('Confirmed' or 'Rejected') to the UI immediately\n        const userDisplayMessage = message.charAt(0).toUpperCase() + message.slice(1);\n        // Explicitly false for isMarkdown, true for isAuto\n        this.addMessage(userDisplayMessage, 'user', false, true);\n        // Create and add the separator element\n        console.log('[MessageHandler] Creating action separator element...'); // Debug log\n        const separatorDiv = document.createElement('div');\n        separatorDiv.className = 'jp-llm-ext-action-separator'; // Add a class for potential styling\n        separatorDiv.style.textAlign = 'center'; // Basic styling\n        separatorDiv.style.margin = '10px 0'; // Add some vertical space\n        separatorDiv.style.fontSize = '0.9em';\n        separatorDiv.style.color = 'var(--jp-ui-font-color2, grey)'; // Use JupyterLab theme variable\n        if (message === 'confirmed') {\n            separatorDiv.textContent = '--------✅ Confirmed--------';\n        }\n        else if (message === 'rejected') {\n            separatorDiv.textContent = '--------❌ Rejected--------';\n        }\n        else {\n            // Optional: Handle unexpected messages? Or just don't add a separator.\n            separatorDiv.textContent = `--------${userDisplayMessage}--------`;\n        }\n        // Add the separator directly to the UI Manager's container\n        console.log('[MessageHandler] Attempting to add separator element:', separatorDiv); // Debug log\n        this.uiManager.addChatMessageElement(separatorDiv);\n        console.log('[MessageHandler] Separator element should be added.'); // Debug log\n        // Send the technical message ('confirmed' or 'rejected') to the backend\n        // and handle the streaming response from the backend.\n        this.streamAndRenderResponse(message);\n    }\n    /**\n     * Adds a message to the UI via UIManager and saves to ChatState.\n     */\n    addMessage(text, sender, isMarkdown = false, // Default false, overridden below\n    isAuto = false // Flag for auto messages like confirm/reject\n    ) {\n        console.log(`[MessageHandler] Adding message: Sender=${sender}, Markdown=${isMarkdown}, Auto=${isAuto}`);\n        console.log(`[MessageHandler] isMarkdown type in addMessage: ${typeof isMarkdown}, value: ${isMarkdown}`);\n        let messageElement;\n        // Prepare extended callbacks for the renderer\n        const extendedCallbacks = Object.assign(Object.assign({}, this.rendererCallbacks), { getCodeRefData: (refId) => {\n                return this.inputHandler.getCodeReferenceMap().get(refId);\n            }, getCurrentNotebookContext: () => {\n                var _a, _b;\n                const currentNotebook = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;\n                if (currentNotebook === null || currentNotebook === void 0 ? void 0 : currentNotebook.context) {\n                    const path = currentNotebook.context.path;\n                    const name = ((_b = path.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';\n                    return { name, path };\n                }\n                return undefined;\n            } });\n        if (sender === 'user') {\n            console.log(`[MessageHandler] Calling renderUserMessage with isMarkdown=${isMarkdown}`);\n            // Pass the isMarkdown option and extended callbacks to the renderer\n            messageElement = (0, message_renderer_1.renderUserMessage)(text, { isMarkdown }, extendedCallbacks);\n        }\n        else {\n            // Bot messages usually are markdown unless specified otherwise\n            // Handle auto messages specifically if they shouldn't be parsed as markdown\n            const botIsMarkdown = !isAuto; // Assume auto messages aren't markdown\n            // Pass extended callbacks to bot message renderer too, in case it needs them later\n            messageElement = (0, message_renderer_1.renderBotMessage)(text, { isMarkdown: botIsMarkdown }, extendedCallbacks);\n        }\n        this.uiManager.addChatMessageElement(messageElement);\n        // Don't save internal 'confirmed'/'rejected' messages to history\n        if (!isAuto) {\n            // Add isMarkdown back to the saved message state\n            const chatMessage = { sender, text, isMarkdown };\n            this.chatState.addMessageToCurrentChat(chatMessage);\n        }\n    }\n    /**\n     * Core logic for sending a message to the API, handling the stream,\n     * rendering the response, and saving the final bot message.\n     */\n    streamAndRenderResponse(messageToSend) {\n        // --- Prepare streaming UI elements (managed by UIManager) ---\n        // UIManager should provide a method to create/get these elements\n        const { streamingDiv, contentDiv } = this.uiManager.createBotMessageContainer();\n        let completeResponse = '';\n        const cellContext = (0, notebook_integration_1.getCurrentCellContent)(); // Use utility\n        // Stream response from API\n        this.apiClient.streamChat(messageToSend, { cellContext }, \n        // On chunk received\n        (chunk) => {\n            completeResponse += chunk;\n            // Update the temporary streaming div\n            streamingDiv.textContent = completeResponse;\n            this.uiManager.scrollToBottom();\n        }, \n        // On complete\n        () => {\n            var _a;\n            // Hide streaming div, show final content div\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Render the complete response using the renderer function\n            const renderedContent = (0, message_renderer_1.renderBotMessage)(completeResponse, { isMarkdown: true }, this.rendererCallbacks);\n            contentDiv.innerHTML = ''; // Clear placeholder/previous content\n            // Append rendered nodes, skipping any potential wrapper/indicator added by renderBotMessage itself\n            while (renderedContent.firstChild) {\n                // Check if the node is the specific markdown indicator we might add/remove\n                // Or just append everything if renderBotMessage returns the pure content\n                if (!((_a = renderedContent.firstChild.classList) === null || _a === void 0 ? void 0 : _a.contains('markdown-indicator'))) {\n                    contentDiv.appendChild(renderedContent.firstChild);\n                }\n                else {\n                    // Remove the indicator if it was part of the returned fragment\n                    renderedContent.removeChild(renderedContent.firstChild);\n                }\n            }\n            // Save final bot response to history via ChatState\n            const isImage = completeResponse.trim().startsWith('/images/'); // Simple check\n            const botMessageData = {\n                text: completeResponse,\n                sender: 'bot',\n                isMarkdown: !isImage // Save as markdown unless it's an image URL\n            };\n            this.chatState.addMessageToCurrentChat(botMessageData);\n            this.uiManager.scrollToBottom();\n        }, \n        // On error\n        (error) => {\n            // Hide streaming div, show final content div with error\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Use a dedicated error rendering style/component if available\n            contentDiv.innerHTML = `<div class=\"jp-llm-ext-error-message\">Error: ${error.message}</div>`;\n            console.error('API Error:', error);\n            this.uiManager.scrollToBottom();\n        });\n    }\n}\nexports.MessageHandler = MessageHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoteHandler = void 0;\nconst note_modal_1 = require(\"../ui/note-modal\");\nconst markdown_1 = require(\"../utils/markdown\");\n/**\n * Manages the notes UI and interactions.\n */\nclass NoteHandler {\n    /**\n     * Creates a new NoteHandler.\n     * @param noteState The note state.\n     * @param uiManager The UI manager.\n     * @param callbacks Callbacks for note changes.\n     * @param parentNode The parent node where the note handler will append its elements.\n     */\n    constructor(noteState, uiManager, callbacks, parentNode) {\n        this.noteState = noteState;\n        this.uiManager = uiManager;\n        this.callbacks = callbacks;\n        this.parentNode = parentNode;\n        this.selectedNoteId = null;\n        this.isNotesViewVisible = false;\n        // Create main container for notes\n        this.notesContainer = document.createElement('div');\n        this.notesContainer.className = 'jp-llm-ext-notes-container';\n        this.notesContainer.style.display = 'none';\n        // Create container for the note list\n        this.noteListContainer = document.createElement('div');\n        this.noteListContainer.className = 'jp-llm-ext-note-list-container';\n        // Create container for note content\n        this.noteContentContainer = document.createElement('div');\n        this.noteContentContainer.className = 'jp-llm-ext-note-content-container';\n        // Create container for the note modal\n        this.noteModalContainer = document.createElement('div');\n        this.noteModalContainer.className = 'jp-llm-ext-note-modal-container';\n        // Append the modal container to the parent node (not inside the notes container)\n        // This allows the modal to appear as an overlay on the entire UI\n        this.parentNode.appendChild(this.noteModalContainer);\n        // Initialize the notes view\n        this.initializeNotesView();\n    }\n    /**\n     * Initializes the notes view with header, list and content sections.\n     */\n    initializeNotesView() {\n        // Create header\n        const header = document.createElement('div');\n        header.className = 'jp-llm-ext-notes-header';\n        // Create back button\n        const backButton = document.createElement('button');\n        backButton.className = 'jp-Button jp-llm-ext-back-button';\n        backButton.innerHTML = '<span class=\"jp-icon3 jp-icon-selectable\" role=\"presentation\"><svg viewBox=\"0 0 24 24\"><path d=\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\"/></svg></span>';\n        backButton.title = 'Back to chat';\n        backButton.addEventListener('click', () => this.hideNotesView());\n        const title = document.createElement('h2');\n        title.textContent = 'Notes';\n        const addButton = document.createElement('button');\n        addButton.className = 'jp-Button jp-llm-ext-add-note-button';\n        addButton.textContent = 'Add Note';\n        addButton.addEventListener('click', () => this.showAddNoteModal());\n        header.appendChild(backButton);\n        header.appendChild(title);\n        header.appendChild(addButton);\n        // Create flex container for list and content\n        const flexContainer = document.createElement('div');\n        flexContainer.className = 'jp-llm-ext-notes-flex-container';\n        flexContainer.appendChild(this.noteListContainer);\n        flexContainer.appendChild(this.noteContentContainer);\n        // Add components to the main container\n        this.notesContainer.appendChild(header);\n        this.notesContainer.appendChild(flexContainer);\n        // Initial render of notes\n        this.renderNotes();\n    }\n    /**\n     * Shows the add note modal.\n     */\n    showAddNoteModal() {\n        const modalCallbacks = {\n            handleSave: (title, content) => {\n                this.noteState.createNewNote(title, content);\n                this.renderNotes();\n                this.hideNoteModal();\n                this.onNoteChange();\n            },\n            handleCancel: () => {\n                this.hideNoteModal();\n            }\n        };\n        const modal = (0, note_modal_1.createNoteModalElement)(modalCallbacks);\n        this.showModal(modal);\n    }\n    /**\n     * Shows the edit note modal for a specific note.\n     * @param note The note to edit.\n     */\n    showEditNoteModal(note) {\n        const modalCallbacks = {\n            handleSave: (title, content) => {\n                this.noteState.updateNote(note.id, title, content);\n                this.renderNotes();\n                this.hideNoteModal();\n                if (this.selectedNoteId === note.id) {\n                    this.showNoteContent(note.id);\n                }\n                this.onNoteChange();\n            },\n            handleCancel: () => {\n                this.hideNoteModal();\n            }\n        };\n        const modal = (0, note_modal_1.createNoteModalElement)(modalCallbacks, note.title, note.content);\n        this.showModal(modal);\n    }\n    /**\n     * Called when a note is changed. Updates the UI title if needed.\n     */\n    onNoteChange() {\n        // Check if a note is selected and update the title input\n        const currentNote = this.noteState.getNoteById(this.selectedNoteId || '');\n        if (currentNote && this.callbacks.updateTitleInput) {\n            this.callbacks.updateTitleInput(currentNote.title);\n        }\n    }\n    /**\n     * Shows a modal in the note modal container.\n     * @param modal The modal element to show.\n     */\n    showModal(modal) {\n        // Clear any existing modal\n        this.noteModalContainer.innerHTML = '';\n        // Add the new modal\n        this.noteModalContainer.appendChild(modal);\n        // Show the modal container\n        this.noteModalContainer.style.display = 'block';\n    }\n    /**\n     * Hides the note modal.\n     */\n    hideNoteModal() {\n        this.noteModalContainer.style.display = 'none';\n        this.noteModalContainer.innerHTML = '';\n    }\n    /**\n     * Renders the list of notes.\n     */\n    renderNotes() {\n        // Clear the current list\n        this.noteListContainer.innerHTML = '';\n        // Get all notes\n        const notes = this.noteState.getAllNotes();\n        if (notes.length === 0) {\n            const emptyMessage = document.createElement('div');\n            emptyMessage.className = 'jp-llm-ext-note-empty-message';\n            emptyMessage.textContent = 'No notes yet. Click \"Add Note\" to create one.';\n            this.noteListContainer.appendChild(emptyMessage);\n            return;\n        }\n        // Create list\n        const notesList = document.createElement('ul');\n        notesList.className = 'jp-llm-ext-note-list';\n        // Add each note to the list\n        notes.forEach((note) => {\n            const noteItem = document.createElement('li');\n            noteItem.className = 'jp-llm-ext-note-item';\n            if (this.selectedNoteId === note.id) {\n                noteItem.classList.add('jp-llm-ext-note-item-selected');\n            }\n            // Note content (title and actions)\n            const noteContent = document.createElement('div');\n            noteContent.className = 'jp-llm-ext-note-item-content';\n            const noteTitle = document.createElement('span');\n            noteTitle.className = 'jp-llm-ext-note-item-title';\n            noteTitle.textContent = note.title;\n            const noteActions = document.createElement('div');\n            noteActions.className = 'jp-llm-ext-note-item-actions';\n            const editButton = document.createElement('button');\n            editButton.className = 'jp-Button jp-llm-ext-note-edit-button';\n            editButton.innerHTML = '<span class=\"jp-icon3 jp-icon-selectable\" role=\"presentation\"><svg viewBox=\"0 0 24 24\"><path d=\"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z\"/></svg></span>';\n            editButton.title = 'Edit note';\n            editButton.addEventListener('click', (e) => {\n                e.stopPropagation(); // Prevent note selection\n                this.showEditNoteModal(note);\n            });\n            const deleteButton = document.createElement('button');\n            deleteButton.className = 'jp-Button jp-llm-ext-note-delete-button';\n            deleteButton.innerHTML = '<span class=\"jp-icon3 jp-icon-selectable\" role=\"presentation\"><svg viewBox=\"0 0 24 24\"><path d=\"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\"/></svg></span>';\n            deleteButton.title = 'Delete note';\n            deleteButton.addEventListener('click', (e) => {\n                e.stopPropagation(); // Prevent note selection\n                if (confirm(`Are you sure you want to delete the note \"${note.title}\"?`)) {\n                    this.noteState.deleteNote(note.id);\n                    // If the deleted note was selected, clear the content container\n                    if (this.selectedNoteId === note.id) {\n                        this.selectedNoteId = null;\n                        this.noteContentContainer.innerHTML = '';\n                    }\n                    this.renderNotes();\n                    this.onNoteChange();\n                }\n            });\n            noteActions.appendChild(editButton);\n            noteActions.appendChild(deleteButton);\n            noteContent.appendChild(noteTitle);\n            noteContent.appendChild(noteActions);\n            noteItem.appendChild(noteContent);\n            // Add click event to show the note content\n            noteItem.addEventListener('click', () => {\n                this.showNoteContent(note.id);\n            });\n            notesList.appendChild(noteItem);\n        });\n        this.noteListContainer.appendChild(notesList);\n    }\n    /**\n     * Shows the content of a specific note.\n     * @param noteId The ID of the note to show.\n     */\n    showNoteContent(noteId) {\n        // Set as selected\n        this.selectedNoteId = noteId;\n        // Re-render notes to update selection\n        this.renderNotes();\n        // Clear current content\n        this.noteContentContainer.innerHTML = '';\n        // Get the note\n        const note = this.noteState.getNoteById(noteId);\n        if (!note)\n            return;\n        // Create content container\n        const contentWrapper = document.createElement('div');\n        contentWrapper.className = 'jp-llm-ext-note-content-wrapper';\n        // Note title\n        const title = document.createElement('h3');\n        title.className = 'jp-llm-ext-note-content-title';\n        title.textContent = note.title;\n        contentWrapper.appendChild(title);\n        // Note content\n        const content = document.createElement('div');\n        content.className = 'jp-llm-ext-note-content-text jp-RenderedMarkdown';\n        // Render markdown content\n        content.innerHTML = (0, markdown_1.renderMarkdown)(note.content);\n        contentWrapper.appendChild(content);\n        this.noteContentContainer.appendChild(contentWrapper);\n        // Update the title in parent UI if callback exists\n        if (this.callbacks.updateTitleInput) {\n            this.callbacks.updateTitleInput(note.title);\n        }\n    }\n    /**\n     * Toggles visibility of the notes view.\n     */\n    toggleNotesView() {\n        this.isNotesViewVisible = !this.isNotesViewVisible;\n        if (this.isNotesViewVisible) {\n            this.showNotesView();\n        }\n        else {\n            this.hideNotesView();\n        }\n    }\n    /**\n     * Shows the notes view.\n     */\n    showNotesView() {\n        this.notesContainer.style.display = 'flex';\n        this.isNotesViewVisible = true;\n        // Use UIManager to properly hide message containers and show notes view\n        this.uiManager.showNotesView();\n        // Find any other message containers that might be visible and hide them\n        const allMessageContainers = document.querySelectorAll('.jp-llm-ext-message-container');\n        allMessageContainers.forEach(container => {\n            container.style.display = 'none';\n        });\n    }\n    /**\n     * Hides the notes view.\n     */\n    hideNotesView() {\n        this.notesContainer.style.display = 'none';\n        this.isNotesViewVisible = false;\n        // Use UIManager to show the chat view again\n        this.uiManager.showChatView();\n    }\n    /**\n     * Returns the notes container.\n     * @returns The notes container element.\n     */\n    getContainer() {\n        return this.notesContainer;\n    }\n}\nexports.NoteHandler = NoteHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopupMenuManager = void 0;\nconst globals_1 = require(\"../core/globals\");\n/**\n * Manages the state and interactions of the multi-level popup menu.\n */\nclass PopupMenuManager {\n    constructor(docManager, widgetNode, callbacks) {\n        this.currentMenuLevel = 'top';\n        this.currentMenuPath = '';\n        this.menuHistory = [];\n        this.currentNotebook = null;\n        this.selectedMenuItemIndex = -1; // Track currently selected menu item\n        this.isRenderingContent = false; // Flag to prevent recursive renders\n        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders\n        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];\n        this.fileCache = new Map();\n        this.docManager = docManager;\n        this.widgetNode = widgetNode;\n        this.callbacks = callbacks;\n        this.popupMenuContainer = document.createElement('div');\n        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';\n        this.popupMenuContainer.style.display = 'none';\n        this.popupMenuContainer.style.position = 'absolute'; // Crucial for positioning relative to widgetNode\n        // Attach to the widget node instead of the body\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Create search input\n        this.searchInput = document.createElement('input');\n        this.searchInput.type = 'text';\n        this.searchInput.placeholder = 'Search...';\n        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling\n        // Use 'input' event instead of directly re-rendering on every keystroke\n        this.searchInput.addEventListener('input', () => {\n            // Only re-render if the search term has actually changed\n            if (this.searchInput.value !== this.lastSearchTerm) {\n                this.lastSearchTerm = this.searchInput.value;\n                this.renderMenuContent();\n            }\n        });\n        // Handle keydown in search input to stop propagation for navigation keys\n        this.searchInput.addEventListener('keydown', (event) => {\n            console.log(`POPUP Search KeyDown: Key='${event.key}'`);\n            // IMPORTANT: Prevent these keys from being captured by the document handler\n            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);\n                if (event.key === 'Escape') {\n                    // Handle Escape directly here\n                    this.hidePopupMenu();\n                }\n                else if (event.key === 'Enter') {\n                    // Select first item on Enter\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        // If we already have a selection, click it\n                        if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {\n                            menuItems[this.selectedMenuItemIndex].click();\n                        }\n                        else {\n                            // Otherwise, select and click the first item\n                            this.selectedMenuItemIndex = 0;\n                            this.updateSelectionHighlight();\n                            menuItems[0].click();\n                        }\n                    }\n                }\n                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        const direction = event.key === 'ArrowDown' ? 1 : -1;\n                        // If no selection yet, select first or last based on direction\n                        if (this.selectedMenuItemIndex < 0) {\n                            this.selectedMenuItemIndex = direction > 0 ? 0 : menuItems.length - 1;\n                        }\n                        else {\n                            // Otherwise move in the specified direction with wraparound\n                            this.selectedMenuItemIndex = (this.selectedMenuItemIndex + direction + menuItems.length) % menuItems.length;\n                        }\n                        this.updateSelectionHighlight();\n                        // Keep focus in search input but update selection visually\n                        this.searchInput.focus();\n                    }\n                }\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys\n            // This allows default behavior to work properly\n        }, true); // Use capture phase\n        document.addEventListener('click', this.handleDocumentClick.bind(this), true);\n        // IMPORTANT: Use a separate bound function for the document keydown\n        // so we can remove the exact same listener later\n        this.boundHandleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener('keydown', this.boundHandleKeyDown, true);\n        if (globals_1.globals.notebookTracker) {\n            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;\n            globals_1.globals.notebookTracker.currentChanged.connect((sender, notebook) => {\n                this.currentNotebook = notebook;\n            });\n        }\n    }\n    dispose() {\n        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);\n        // Remove using the exact same bound function\n        document.removeEventListener('keydown', this.boundHandleKeyDown, true);\n        // Remove from widgetNode if attached\n        if (this.popupMenuContainer.parentNode === this.widgetNode) {\n            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);\n        }\n    }\n    handleDocumentClick(event) {\n        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {\n            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');\n            if (atButton && atButton.contains(event.target)) {\n                console.log('POPUP: Click was on the @ button, not hiding.');\n                return;\n            }\n            console.log('POPUP: Click detected outside the menu.');\n            this.hidePopupMenu();\n        }\n    }\n    async showPopupMenu(trigger) {\n        let anchorX;\n        let anchorY;\n        if (trigger instanceof HTMLElement) {\n            const rect = trigger.getBoundingClientRect();\n            anchorX = rect.left; // Use button's top-left for anchor\n            anchorY = rect.top;\n            console.log(`POPUP: Showing menu triggered by element at (${anchorX}, ${anchorY})`);\n        }\n        else {\n            anchorX = trigger.x;\n            anchorY = trigger.y;\n            console.log(`POPUP: Showing menu triggered by coordinates at (${anchorX}, ${anchorY})`);\n        }\n        // Store the calculated anchor point for positioning\n        this._anchorX = anchorX;\n        this._anchorY = anchorY;\n        if (this.popupMenuContainer.style.display === 'none') {\n            this.currentMenuLevel = 'top';\n            this.currentMenuPath = '';\n            this.menuHistory = [];\n            this.searchInput.value = ''; // Clear search on show\n            this.lastSearchTerm = ''; // Reset last search term\n            await this.setCurrentDirectoryPath();\n        }\n        await this.renderMenuContent();\n        // Ensure it's attached to the widget node if somehow detached\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Add keydown listener when showing\n        document.addEventListener('keydown', this.boundHandleKeyDown, true);\n        // Position the popup menu - DEFER calculation slightly\n        setTimeout(() => {\n            console.log(\"POPUP: Deferred updatePopupPosition call.\");\n            try {\n                this.updatePopupPosition();\n            }\n            catch (error) {\n                console.error(\"POPUP: Error during deferred updatePopupPosition:\", error);\n            }\n            // Focus the search input *after* positioning if in file/dir view\n            // Otherwise, focus first menu item\n            if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                this.searchInput.focus();\n                console.log('POPUP: Focused search input after deferred positioning.');\n                this.selectedMenuItemIndex = -1; // Don't select an item if search is focused\n            }\n            else { // Top level or cells\n                this.selectedMenuItemIndex = -1;\n                this.selectNextMenuItem(); // Select first item\n                console.log('POPUP: Selected first menu item');\n            }\n        }, 0); // 0ms delay is usually sufficient\n    }\n    hidePopupMenu() {\n        if (this.popupMenuContainer.style.display !== 'none') {\n            console.log('POPUP: Hiding menu. Called from:', new Error().stack);\n            this.popupMenuContainer.style.display = 'none';\n            this.currentMenuLevel = 'top'; // Reset level\n            // Remove keydown listener when hiding\n            document.removeEventListener('keydown', this.boundHandleKeyDown, true);\n            console.log(\"POPUP: Removed keydown listener.\");\n            // Clear anchors\n            this._anchorX = undefined;\n            this._anchorY = undefined;\n        }\n    }\n    async renderMenuContent() {\n        // Prevent recursive renders\n        if (this.isRenderingContent) {\n            console.log('POPUP: Skipping render - already rendering');\n            return;\n        }\n        this.isRenderingContent = true;\n        try {\n            // Clear existing content\n            while (this.popupMenuContainer.firstChild) {\n                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);\n            }\n            // Only add search input if NOT at top level\n            if (this.currentMenuLevel !== 'top') {\n                // Add search input at the top of the menu\n                this.popupMenuContainer.appendChild(this.searchInput);\n                this.searchInput.value = ''; // Clear for file/dir/cell levels\n                this.lastSearchTerm = '';\n            }\n            // Render different menu content based on current level\n            switch (this.currentMenuLevel) {\n                case 'top':\n                    this.renderTopLevelItems();\n                    break;\n                case 'files':\n                case 'directories':\n                    await this.renderDirectoryBrowserItems();\n                    break;\n                case 'cells':\n                    await this.renderCellItems();\n                    break;\n            }\n            // Reset selection after rendering\n            this.selectedMenuItemIndex = -1;\n            this.updateSelectionHighlight();\n            // Update the position (might have changed due to content rendering)\n            console.log(\"POPUP: ===> About to call updatePopupPosition after renderMenuContent\");\n            try {\n                this.updatePopupPosition();\n            }\n            catch (err) {\n                console.error(\"POPUP: Error calling updatePopupPosition after render:\", err);\n            }\n        }\n        catch (error) {\n            console.error('POPUP: Error rendering menu content', error);\n        }\n        finally {\n            this.isRenderingContent = false;\n        }\n    }\n    renderTopLevelItems() {\n        const topLevelCommands = [\n            { label: 'Code', description: '', actionId: 'insert-code' },\n            { label: 'Cells', description: '', actionId: 'browse-cells' },\n            { label: 'File', description: '', actionId: 'browse-files' },\n            { label: 'Directory', description: '', actionId: 'browse-directories' }\n        ];\n        topLevelCommands.forEach(cmd => {\n            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);\n            this.popupMenuContainer.appendChild(item);\n        });\n    }\n    async renderDirectoryBrowserItems() {\n        var _a;\n        // Get search term\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        // Temporarily add loading item below search/path\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // If contents were already fetched recently and we're just filtering again,\n            // we could potentially cache the results to avoid unnecessary API calls\n            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';\n            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);\n            // Check if still in DOM before trying to remove\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (contents && contents.length > 0) {\n                // Filter based on search term\n                const filteredContents = contents.filter(item => {\n                    return item.name.toLowerCase().includes(searchTerm) ||\n                        item.relativePath.toLowerCase().includes(searchTerm);\n                });\n                if (filteredContents.length > 0) {\n                    filteredContents.forEach(item => {\n                        const itemName = item.name;\n                        const itemType = item.type;\n                        const itemPath = item.path;\n                        const relativePath = item.relativePath;\n                        const icon = itemType === 'directory' ? '📁' : '📄';\n                        let actionId;\n                        if (itemType === 'directory') {\n                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';\n                        }\n                        else { // itemType === 'file'\n                            actionId = 'select-file';\n                        }\n                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                }\n                else {\n                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');\n                    emptyItem.style.pointerEvents = 'none';\n                    this.popupMenuContainer.appendChild(emptyItem);\n                }\n            }\n            else {\n                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n            }\n        }\n        catch (error) {\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading/filtering directory contents:', error);\n        }\n    }\n    /**\n     * Renders all cells from the current notebook\n     */\n    async renderCellItems() {\n        var _a, _b;\n        // Get search term for filtering\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        // Create a loading indicator\n        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // Check if we have an active notebook\n            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {\n                // Remove loading item\n                if (this.popupMenuContainer.contains(loadingItem)) {\n                    this.popupMenuContainer.removeChild(loadingItem);\n                }\n                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');\n                errorItem.style.color = 'red';\n                errorItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(errorItem);\n                return;\n            }\n            const notebookModel = this.currentNotebook.content.model;\n            const cells = notebookModel.cells;\n            // Remove loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (!cells || cells.length === 0) {\n                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n                return;\n            }\n            // Process and display each cell\n            let filteredCellCount = 0;\n            for (let i = 0; i < cells.length; i++) {\n                const cell = cells.get(i);\n                const cellType = cell.type;\n                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :\n                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');\n                // Use type casting to avoid TypeScript errors\n                const executionCount = cellType === 'code' ?\n                    (cell.executionCount !== undefined && cell.executionCount !== null ?\n                        cell.executionCount : '*') :\n                    '';\n                // Create a preview of the cell content (truncate if needed)\n                const contentPreview = typeof cellContent === 'string' ?\n                    cellContent :\n                    (Array.isArray(cellContent) ? cellContent.join('\\n') : '');\n                const firstLine = contentPreview.split('\\n')[0] || '';\n                const truncatedContent = firstLine.length > 30 ?\n                    firstLine.substring(0, 30) + '...' :\n                    firstLine;\n                // Create cell label with styled type indicator\n                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';\n                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';\n                // Create menu item for this cell\n                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML\n                'select-cell', i.toString() // Store cell index in path\n                );\n                // Create styled content with HTML elements\n                const typeSpan = document.createElement('span');\n                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;\n                typeSpan.textContent = typeIndicator;\n                const execSpan = document.createElement('span');\n                execSpan.className = 'cell-exec-count';\n                execSpan.textContent = executionDisplay;\n                execSpan.style.marginRight = '8px';\n                const contentSpan = document.createElement('span');\n                contentSpan.className = 'cell-content-preview';\n                contentSpan.textContent = truncatedContent;\n                // Get the label span (first child of the menu item)\n                const labelSpan = cellItem.querySelector('span');\n                if (labelSpan) {\n                    labelSpan.textContent = ''; // Clear existing text\n                    labelSpan.appendChild(typeSpan);\n                    if (executionDisplay) {\n                        labelSpan.appendChild(execSpan);\n                    }\n                    labelSpan.appendChild(contentSpan);\n                }\n                // Construct full searchable text\n                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();\n                // Filter by search term if one is provided\n                if (searchTerm && !searchableText.includes(searchTerm)) {\n                    continue;\n                }\n                this.popupMenuContainer.appendChild(cellItem);\n                filteredCellCount++;\n            }\n            if (filteredCellCount === 0) {\n                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');\n                noMatchItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(noMatchItem);\n            }\n        }\n        catch (error) {\n            // Clean up loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading notebook cells:', error);\n        }\n    }\n    createMenuItem(text, actionId, path = '', description = '') {\n        const item = document.createElement('div');\n        item.className = 'jp-llm-ext-popup-menu-item';\n        item.dataset.actionId = actionId;\n        if (path) {\n            item.dataset.path = path;\n        }\n        // Add mouse events to coordinate with keyboard navigation\n        item.onmouseover = () => {\n            // Find index of this item\n            const menuItems = this.getMenuItems();\n            const index = menuItems.indexOf(item);\n            if (index !== -1) {\n                this.selectedMenuItemIndex = index;\n                this.updateSelectionHighlight();\n            }\n        };\n        item.onclick = (event) => this.handleMenuClick(event);\n        const labelSpan = document.createElement('span');\n        labelSpan.textContent = text;\n        item.appendChild(labelSpan);\n        if (description) {\n            const pathSpan = document.createElement('span');\n            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';\n            pathSpan.textContent = description;\n            pathSpan.style.fontSize = '0.85em';\n            pathSpan.style.color = 'var(--jp-ui-font-color2)';\n            pathSpan.style.marginLeft = '8px';\n            pathSpan.style.opacity = '0.8';\n            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed\n            item.appendChild(pathSpan);\n        }\n        return item;\n    }\n    async handleMenuClick(event) {\n        var _a;\n        const target = event.currentTarget;\n        const actionId = target.dataset.actionId;\n        const path = target.dataset.path || '';\n        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);\n        switch (actionId) {\n            case 'navigate-back':\n                this.navigateBackMenu();\n                break;\n            case 'insert-code': {\n                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;\n                if (selectedText) {\n                    // Show submenu for code insertion options\n                    const submenuItems = [\n                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },\n                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }\n                    ];\n                    // Replace current menu with submenu options\n                    this.popupMenuContainer.innerHTML = '';\n                    submenuItems.forEach(item => {\n                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                    // Add back button\n                    const backButton = this.createMenuItem('Back', 'navigate-back');\n                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';\n                    this.popupMenuContainer.appendChild(backButton);\n                    return; // Don't hide menu, wait for submenu selection\n                }\n                else {\n                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;\n                    if (cellContent) {\n                        this.callbacks.insertCode(cellContent);\n                    }\n                }\n                this.hidePopupMenu();\n                break;\n            }\n            case 'insert-plain-code': {\n                if (path) {\n                    this.callbacks.insertCode(path);\n                    this.hidePopupMenu();\n                }\n                break;\n            }\n            case 'collapse-code-ref': {\n                if (path && this.currentNotebook) {\n                    try {\n                        // Get notebook file name (without extension)\n                        const notebookPath = this.currentNotebook.context.path;\n                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';\n                        // Find current cell index and approximate line number\n                        const currentCell = this.currentNotebook.content.activeCell;\n                        if (!currentCell) {\n                            throw new Error('No active cell found');\n                        }\n                        // Get current cell index\n                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;\n                        // Estimate line number from cursor position\n                        let lineNumber = 1; // Default to line 1\n                        if (currentCell.editor) {\n                            const editor = currentCell.editor;\n                            const cursor = editor.getCursorPosition();\n                            if (cursor) {\n                                lineNumber = cursor.line + 1; // Convert to 1-indexed\n                            }\n                        }\n                        // Invoke the callback with all the information needed\n                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);\n                        this.hidePopupMenu();\n                    }\n                    catch (error) {\n                        console.error('Error creating collapsed code reference:', error);\n                        // Fallback to inserting code directly\n                        this.callbacks.insertCode(path);\n                        this.hidePopupMenu();\n                    }\n                }\n                else {\n                    // If something went wrong or no path provided, just insert as regular code\n                    if (path) {\n                        this.callbacks.insertCode(path);\n                    }\n                    this.hidePopupMenu();\n                }\n                break;\n            }\n            case 'browse-cells':\n                await this.navigateMenu('cells', '');\n                this.searchInput.value = '';\n                break;\n            case 'browse-files':\n                await this.navigateMenu('files', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'browse-directories':\n                await this.navigateMenu('directories', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'select-cell':\n                if (path) {\n                    const cellIndex = parseInt(path);\n                    if (!isNaN(cellIndex)) {\n                        // Construct the reference text (e.g., \"@Cell 3\")\n                        // const refText = `@Cell ${cellIndex + 1}`; // Use 1-based index for display\n                        // console.log(\"TODO: Implement cell reference insertion: \", refText);\n                        this.callbacks.insertCellByIndex(cellIndex); // Call the appropriate callback\n                        this.hidePopupMenu();\n                    }\n                    else {\n                        console.error('POPUP: Invalid cell index.');\n                    }\n                }\n                else {\n                    console.error('POPUP: Cell selected but index (path) is missing.');\n                }\n                break;\n            case 'select-file':\n                if (path) {\n                    // Construct the reference text (e.g., \"@file path/to/file.py\")\n                    // const refText = `@file ${path}`;\n                    // console.log(\"TODO: Implement file reference insertion: \", refText);\n                    this.callbacks.handleInsertFileWidget(path); // NEW: Call widget insertion callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: File selected but path is missing.');\n                }\n                break;\n            case 'select-directory':\n                if (path) {\n                    this.callbacks.handleInsertDirWidget(path); // NEW: Call widget insertion callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: Directory selected but path is missing.');\n                }\n                break;\n            case 'select-directory-navigate': // New action to navigate into dir when in file view\n                if (path) {\n                    // Clear the file cache for the specific directory to force a refresh\n                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;\n                    this.fileCache.delete(cacheKey);\n                    // Make sure we're passing the correct level type\n                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?\n                        this.currentMenuLevel : 'files';\n                    await this.navigateMenu(level, path);\n                    this.searchInput.value = ''; // Clear search on navigation\n                }\n                else {\n                    console.error('POPUP: Directory selected for navigation but path is missing.');\n                }\n                break;\n            case 'select-directory-callback': // New action to select dir when in directory view\n                if (path) {\n                    // Construct the reference text (e.g., \"@dir path/to/directory\")\n                    // const refText = `@dir ${path}`;\n                    // console.log(\"TODO: Implement directory reference insertion: \", refText);\n                    this.callbacks.handleInsertDirWidget(path); // Corrected to use the new widget insertion callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: Directory selected for callback but path is missing.');\n                }\n                break;\n            case 'placeholder-action':\n                console.log('Placeholder action triggered.');\n                this.hidePopupMenu();\n                break;\n            case 'loading':\n            case 'empty':\n            case 'error':\n                break;\n            default:\n                console.log('POPUP: Unknown menu action:', actionId);\n                this.hidePopupMenu();\n                break;\n        }\n        event.stopPropagation();\n    }\n    async navigateMenu(level, path) {\n        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);\n        // Only push history if we are actually moving to a new state\n        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {\n            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n        }\n        this.currentMenuLevel = level;\n        this.currentMenuPath = path;\n        // Don't clear search on programmatic navigation (like back button)\n        // this.searchInput.value = ''; // Maybe keep search term?\n        await this.renderMenuContent();\n        // Focus search input after navigating to file/dir view\n        if (level === 'files' || level === 'directories') {\n            setTimeout(() => this.searchInput.focus(), 0);\n            this.selectedMenuItemIndex = -1; // Reset selection\n        }\n        else {\n            // Select first item if navigating back to top level\n            this.selectedMenuItemIndex = -1;\n            setTimeout(() => this.selectNextMenuItem(), 0);\n        }\n    }\n    navigateBackMenu() {\n        const previousState = this.menuHistory.pop();\n        if (previousState) {\n            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);\n            this.currentMenuLevel = previousState.level;\n            this.currentMenuPath = previousState.path;\n            // Don't clear search on back navigation\n            this.renderMenuContent().then(() => {\n                // Focus search input if going back to file/dir view\n                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                    setTimeout(() => {\n                        this.searchInput.focus();\n                        // Move cursor to end of input text\n                        const length = this.searchInput.value.length;\n                        this.searchInput.setSelectionRange(length, length);\n                    }, 0);\n                    this.selectedMenuItemIndex = -1; // Reset selection\n                }\n                else {\n                    // Select first item if going back to top level\n                    this.selectedMenuItemIndex = -1;\n                    setTimeout(() => this.selectNextMenuItem(), 0);\n                }\n            });\n        }\n        else {\n            console.log('POPUP: Already at the top level.');\n            this.hidePopupMenu();\n        }\n    }\n    async listCurrentDirectoryContents(basePath, filterType) {\n        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);\n        // Check cache first\n        const cacheKey = `${basePath}:${filterType || 'all'}`;\n        if (this.fileCache.has(cacheKey)) {\n            console.log('POPUP: Using cached directory contents');\n            return this.fileCache.get(cacheKey) || null;\n        }\n        try {\n            const effectivePath = basePath === '/' ? '' : basePath;\n            // Ensure trailing slash removed for consistency unless it's root\n            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;\n            // Result array that will hold all files and directories\n            let allResults = [];\n            // Get the base directory contents (non-recursive)\n            const baseContents = await this.docManager.services.contents.get(pathForApi || '');\n            if (baseContents.type !== 'directory') {\n                console.error('Path is not a directory:', basePath);\n                return null;\n            }\n            // Process base directory items\n            for (const item of baseContents.content) {\n                const itemType = item.type === 'directory' ? 'directory' : 'file';\n                // Add directories if we're listing directories or both\n                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {\n                    allResults.push({\n                        name: item.name,\n                        path: item.path,\n                        type: 'directory',\n                        relativePath: `./${item.name}`\n                    });\n                }\n                // Add files if we're listing files and the extension is allowed\n                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {\n                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();\n                    if (this.allowedExtensions.includes(fileExt)) {\n                        allResults.push({\n                            name: item.name,\n                            path: item.path,\n                            type: 'file',\n                            relativePath: `./${item.name}`\n                        });\n                    }\n                }\n            }\n            // Sort the results appropriately\n            allResults = allResults.sort((a, b) => {\n                // If listing directories only, sort alphabetically\n                if (filterType === 'directory') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing files only, sort alphabetically\n                if (filterType === 'file') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing both, sort directories first, then files alphabetically\n                if (a.type === 'directory' && b.type !== 'directory')\n                    return -1;\n                if (a.type !== 'directory' && b.type === 'directory')\n                    return 1;\n                return a.name.localeCompare(b.name);\n            });\n            // Cache the results for future use\n            this.fileCache.set(cacheKey, allResults);\n            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);\n            return allResults;\n        }\n        catch (error) {\n            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);\n            return null;\n        }\n    }\n    async setCurrentDirectoryPath() {\n        var _a;\n        let dirPath = null;\n        const app = globals_1.globals.app;\n        if (!app) {\n            console.error('POPUP: Application reference not available');\n            this.currentMenuPath = '';\n            return;\n        }\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                dirPath = this.getParentDirectory(path);\n                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {\n            const notebookPath = this.currentNotebook.context.path;\n            if (typeof notebookPath === 'string') {\n                dirPath = this.getParentDirectory(notebookPath);\n                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null) {\n            try {\n                const leftWidgets = Array.from(app.shell.widgets('left'));\n                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');\n                if (fileBrowserWidget && typeof ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path) === 'string') {\n                    dirPath = fileBrowserWidget.model.path;\n                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);\n                }\n                else {\n                    console.log('POPUP: File browser widget path not directly accessible.');\n                }\n            }\n            catch (e) {\n                console.warn('POPUP: Could not get path from file browser.', e);\n            }\n        }\n        if (dirPath === null) {\n            dirPath = '';\n            console.log('POPUP: Falling back to server root path.');\n        }\n        this.currentMenuPath = dirPath;\n        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);\n    }\n    getParentDirectory(path) {\n        if (!path)\n            return '';\n        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n        if (lastSlash === -1)\n            return ''; // No directory part, likely root or just a filename\n        return path.substring(0, lastSlash);\n    }\n    /**\n     * Handle keyboard navigation when the popup menu is shown\n     */\n    handleKeyDown(event) {\n        if (this.popupMenuContainer.style.display === 'none')\n            return;\n        console.log(`POPUP (Document): KeyDown intercepted. Key='${event.key}'`);\n        // Prioritize search input if focused\n        if (document.activeElement === this.searchInput) {\n            console.log('POPUP (Document): KeyDown - Search input is focused, letting it handle.');\n            // Handle Tab and arrow keys specifically to move focus out of search\n            if (event.key === 'Tab' || event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                console.log(`POPUP (Document): Key='${event.key}' in search input - moving focus.`);\n                // Instead of blurring, let's handle arrows directly in the input\n                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                    const direction = event.key === 'ArrowDown' ? 1 : -1;\n                    const menuItems = this.getMenuItems();\n                    // If no items selected yet, select first/last based on direction\n                    if (this.selectedMenuItemIndex < 0) {\n                        this.selectedMenuItemIndex = direction > 0 ? 0 : menuItems.length - 1;\n                    }\n                    else {\n                        // Move selection in specified direction\n                        this.selectedMenuItemIndex =\n                            (this.selectedMenuItemIndex + direction + menuItems.length) % menuItems.length;\n                    }\n                    this.updateSelectionHighlight();\n                    // Keep search input focused\n                    this.searchInput.focus();\n                }\n                else if (event.key === 'Tab') {\n                    // Tab should select next item but keep search focused\n                    this.selectNextMenuItem();\n                    this.searchInput.focus();\n                }\n                event.preventDefault(); // Prevent default Tab behavior\n                event.stopPropagation();\n                return;\n            }\n            // Let other keys (like Escape, Enter) be handled by the search input's own listener\n            return;\n        }\n        // Handle navigation if search is not focused\n        if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n            console.log('POPUP (Document): Handling navigation key:', event.key);\n            event.preventDefault();\n            event.stopPropagation();\n            this.processMenuNavigation(event.key);\n        }\n        else {\n            // If typing characters and NOT in search input, focus search and add the character\n            if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories' || this.currentMenuLevel === 'cells') {\n                if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {\n                    console.log('POPUP (Document): Focusing search input due to character typed.');\n                    this.searchInput.focus();\n                    // Append the typed character to search input if it's a printable character\n                    if (event.key.match(/^[\\w\\d\\s.,\\-_=+;:'\"\\[\\]{}()*&^%$#@!~`|\\\\/<>?]$/)) {\n                        this.searchInput.value += event.key;\n                        // Trigger search input's 'input' event to update filtering\n                        this.searchInput.dispatchEvent(new Event('input', { bubbles: true }));\n                    }\n                    event.preventDefault();\n                    event.stopPropagation();\n                }\n            }\n        }\n    }\n    processMenuNavigation(key) {\n        switch (key) {\n            case 'ArrowDown':\n                console.log('POPUP: Arrow Down pressed');\n                this.selectNextMenuItem();\n                break;\n            case 'ArrowUp':\n                console.log('POPUP: Arrow Up pressed');\n                this.selectPreviousMenuItem();\n                break;\n            case 'Enter':\n            case 'Tab': // Treat Tab like Enter for selection\n                console.log(`POPUP: ${key} pressed`);\n                if (this.selectedMenuItemIndex >= 0) {\n                    const menuItems = this.getMenuItems();\n                    if (this.selectedMenuItemIndex < menuItems.length) {\n                        console.log('POPUP: Simulating click on selected item:', menuItems[this.selectedMenuItemIndex].textContent);\n                        // Simulate click to trigger handleMenuClick\n                        menuItems[this.selectedMenuItemIndex].click();\n                    }\n                    else {\n                        console.log('POPUP: Selected index out of bounds?');\n                    }\n                }\n                else {\n                    console.log('POPUP: Enter/Tab pressed but no item selected');\n                    // If no item is selected, select the first one and activate\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        this.selectedMenuItemIndex = 0;\n                        this.updateSelectionHighlight();\n                        // With Enter, always activate the newly selected item\n                        if (key === 'Enter') {\n                            menuItems[0].click(); // Activate first item\n                        }\n                    }\n                }\n                break;\n            case 'Escape':\n                console.log('POPUP: Escape pressed');\n                // If in a submenu, navigate back; otherwise, hide.\n                if (this.menuHistory.length > 0) {\n                    this.navigateBackMenu();\n                }\n                else {\n                    this.hidePopupMenu();\n                }\n                break;\n        }\n    }\n    updateSelectionHighlight() {\n        const menuItems = this.getMenuItems();\n        // Handle out-of-bounds index\n        if (this.selectedMenuItemIndex >= menuItems.length) {\n            this.selectedMenuItemIndex = menuItems.length - 1;\n        }\n        menuItems.forEach((item, index) => {\n            if (index === this.selectedMenuItemIndex) {\n                item.classList.add('jp-llm-ext-popup-menu-item-selected');\n                // Scroll into view if necessary\n                item.scrollIntoView({ block: 'nearest' });\n            }\n            else {\n                item.classList.remove('jp-llm-ext-popup-menu-item-selected');\n            }\n        });\n    }\n    deselectAllMenuItems() {\n        const menuItems = this.getMenuItems();\n        menuItems.forEach(item => {\n            item.classList.remove('jp-llm-ext-popup-menu-item-selected');\n        });\n        this.selectedMenuItemIndex = -1;\n    }\n    selectNextMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (menuItems.length === 0)\n            return;\n        this.selectedMenuItemIndex++;\n        if (this.selectedMenuItemIndex >= menuItems.length) {\n            this.selectedMenuItemIndex = 0; // Wrap around\n        }\n        this.updateSelectionHighlight();\n        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);\n    }\n    selectPreviousMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (menuItems.length === 0)\n            return;\n        this.selectedMenuItemIndex--;\n        if (this.selectedMenuItemIndex < 0) {\n            this.selectedMenuItemIndex = menuItems.length - 1; // Wrap around\n        }\n        this.updateSelectionHighlight();\n        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);\n    }\n    /**\n     * Get all interactive menu items currently displayed\n     */\n    getMenuItems() {\n        return Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));\n    }\n    /**\n     * Updates the position of the popup menu based on the active reference range\n     * or the initial anchor point. Tries to position the BOTTOM-LEFT corner of the menu\n     * just AT THE TOP-LEFT corner of the range/anchor.\n     */\n    updatePopupPosition() {\n        if (!this.widgetNode || this._anchorX === undefined || this._anchorY === undefined) {\n            console.warn(\"POPUP: Cannot update position - missing widgetNode or anchor points.\");\n            return;\n        }\n        const widgetRect = this.widgetNode.getBoundingClientRect();\n        // Target position is the viewport-relative anchor point\n        const targetTop = this._anchorY;\n        const targetLeft = this._anchorX;\n        console.log(`POPUP: Positioning relative to anchor: (${targetLeft}, ${targetTop})`);\n        // Make sure the popup is visible and rendered to get its dimensions\n        // Use visibility to prevent flicker while measuring\n        this.popupMenuContainer.style.visibility = 'hidden';\n        this.popupMenuContainer.style.display = 'block';\n        const popupHeight = this.popupMenuContainer.offsetHeight;\n        const popupWidth = this.popupMenuContainer.offsetWidth;\n        if (popupHeight === 0 || popupWidth === 0) {\n            console.warn(\"POPUP: Cannot update position - popup dimensions are zero.\");\n            this.popupMenuContainer.style.display = 'none'; // Hide if dimensions are invalid\n            return;\n        }\n        // Calculate desired viewport coordinates for popup's top-left\n        // Goal: popup bottom-left = anchor top-left\n        // popup top = anchor top - popup height\n        // popup left = anchor left\n        let desiredTop = targetTop - popupHeight;\n        let desiredLeft = targetLeft;\n        // --- Viewport Boundary checks ---\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        // Prevent going off the left viewport edge\n        if (desiredLeft < 0) {\n            desiredLeft = 5; // Small padding\n            console.log(\"POPUP Viewport Adjust: Corrected left edge\");\n        }\n        // Prevent going off the right viewport edge\n        if (desiredLeft + popupWidth > viewportWidth) {\n            desiredLeft = viewportWidth - popupWidth - 5; // Adjust left, add padding\n            console.log(\"POPUP Viewport Adjust: Corrected right edge\");\n        }\n        // Prevent going off the top viewport edge\n        if (desiredTop < 0) {\n            // If it goes off the top, try positioning it *below* the anchor instead\n            // Goal: popup top-left = anchor bottom-left\n            const desiredTopBelow = targetTop + 5; // Add small gap\n            if (desiredTopBelow + popupHeight <= viewportHeight) {\n                desiredTop = desiredTopBelow;\n                console.log(\"POPUP Viewport Adjust: Flipping below anchor (was off top)\");\n            }\n            else {\n                // Not enough space below either, clamp to top of viewport\n                desiredTop = 5; // Small padding from top\n                console.log(\"POPUP Viewport Adjust: Clamped to top edge (no space below)\");\n            }\n        }\n        // Note: No check for bottom edge needed if we prioritize positioning above or clamping to top.\n        // --- Convert viewport coordinates to style relative to widgetNode ---\n        const styleTop = desiredTop - widgetRect.top;\n        const styleLeft = desiredLeft - widgetRect.left;\n        console.log(`POPUP: Setting position - Top: ${styleTop}px, Left: ${styleLeft}px (Relative to Widget)`);\n        this.popupMenuContainer.style.top = `${styleTop}px`;\n        this.popupMenuContainer.style.left = `${styleLeft}px`;\n        // Make it visible again\n        this.popupMenuContainer.style.display = 'block';\n        this.popupMenuContainer.style.visibility = 'visible';\n    }\n    /**\n     * Checks if the popup menu is currently visible.\n     */\n    isPopupMenuVisible() {\n        return this.popupMenuContainer.style.display !== 'none';\n    }\n    /**\n     * Gets the current level of the popup menu.\n     */\n    getCurrentMenuLevel() {\n        return this.currentMenuLevel;\n    }\n}\nexports.PopupMenuManager = PopupMenuManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsHandler = void 0;\n/**\n * Handles the logic related to the settings modal:\n * displaying, hiding, populating, saving, and showing feedback.\n */\nclass SettingsHandler {\n    constructor(state, settingsModalContainer, uiManager // Pass UIManager for notifications\n    ) {\n        this.state = state;\n        this.settingsModalContainer = settingsModalContainer;\n        this.uiManager = uiManager;\n    }\n    /**\n     * Populates the settings form with current values and displays the modal.\n     */\n    showModal() {\n        const currentSettings = this.state.getSettings();\n        if (currentSettings) {\n            try {\n                // Query elements within the modal container\n                this.settingsModalContainer.querySelector('#settings-provider').value = currentSettings.provider;\n                this.settingsModalContainer.querySelector('#settings-api-key').value = currentSettings.apiKey;\n                this.settingsModalContainer.querySelector('#settings-api-url').value = currentSettings.apiUrl;\n                this.settingsModalContainer.querySelector('#settings-rules').value = currentSettings.rules;\n            }\n            catch (error) {\n                console.error('Error populating settings form:', error);\n                // Optionally show an error to the user\n            }\n        }\n        this.settingsModalContainer.style.display = 'flex';\n    }\n    /**\n     * Hides the settings modal.\n     */\n    hideModal() {\n        this.settingsModalContainer.style.display = 'none';\n    }\n    /**\n     * Reads values from the form, saves them using SettingsState,\n     * updates the ApiClient, hides the modal, and shows a success notification.\n     * This method is intended to be called by the modal's save button listener.\n     */\n    saveSettings() {\n        var _a, _b, _c, _d;\n        // Get values from form fields within the modal container\n        const provider = (_a = this.settingsModalContainer.querySelector('#settings-provider')) === null || _a === void 0 ? void 0 : _a.value;\n        const key = (_b = this.settingsModalContainer.querySelector('#settings-api-key')) === null || _b === void 0 ? void 0 : _b.value;\n        const url = (_c = this.settingsModalContainer.querySelector('#settings-api-url')) === null || _c === void 0 ? void 0 : _c.value;\n        const rules = (_d = this.settingsModalContainer.querySelector('#settings-rules')) === null || _d === void 0 ? void 0 : _d.value;\n        // Basic validation\n        if (provider === undefined || key === undefined || url === undefined || rules === undefined) {\n            console.error(\"Could not find all settings input elements.\");\n            this.showNotification('Error: Could not save settings. Input elements missing.', 'error');\n            return;\n        }\n        const settings = { provider, apiKey: key, apiUrl: url, rules };\n        try {\n            // Save settings using SettingsState\n            this.state.saveSettings(settings);\n            console.log('Settings saved via SettingsState:', settings);\n            // Reconfigure ApiClient instance\n            // TODO: The ApiClient should ideally observe the SettingsState \n            // or have a dedicated update method instead of creating a new instance.\n            // For now, we assume the main widget will recreate/update the ApiClient \n            // or pass an update callback.\n            // Example: this.apiClient.updateConfig(settings.apiUrl || undefined);\n            console.log('API Client needs reconfiguration with new settings.');\n            this.hideModal();\n            this.showNotification('Settings saved successfully', 'success');\n        }\n        catch (error) {\n            console.error('Error saving settings:', error);\n            this.showNotification(`Error saving settings: ${error}`, 'error');\n        }\n    }\n    /**\n     * Displays a temporary notification message.\n     * Relies on UIManager to provide the actual notification mechanism.\n     */\n    showNotification(message, type) {\n        // Delegate notification display to UIManager or a dedicated notification service\n        if (this.uiManager && typeof this.uiManager.showNotification === 'function') {\n            this.uiManager.showNotification(message, type);\n        }\n        else {\n            // Fallback or log if UIManager doesn't support notifications yet\n            console.log(`Notification (${type}): ${message}`);\n            // The old popSaveSuccess logic requires direct access to the widget node,\n            // which this handler shouldn't have. This needs to be handled by the UI layer.\n        }\n    }\n}\nexports.SettingsHandler = SettingsHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setupShortcuts = setupShortcuts;\nexports.removeShortcuts = removeShortcuts;\nconst notebook_integration_1 = require(\"../utils/notebook-integration\");\nconst globals_1 = require(\"../core/globals\"); // Import globals to get cell index etc.\nlet _handleKeyDown = null;\n/**\n * Sets up global keyboard shortcuts for the extension.\n *\n * @param inputHandler Instance of InputHandler to interact with input state/methods.\n * @param popupMenuManager Instance of PopupMenuManager.\n * @param callbacks Object containing callback functions for UI interactions.\n */\nfunction setupShortcuts(inputHandler, // Pass InputHandler instance directly\npopupMenuManager, callbacks) {\n    if (_handleKeyDown) {\n        console.warn('Shortcuts already set up. Removing previous listener.');\n        removeShortcuts();\n    }\n    _handleKeyDown = (event) => {\n        var _a, _b, _c;\n        const { showIndicator, appendToInput, showWidget, focusInput } = callbacks;\n        // Check for @ key - event.key should correctly report '@' even with Shift\n        // Also check for SHIFT+2 as an alternative way to trigger '@'\n        if (event.key === '@' || (event.shiftKey && event.key === '2')) {\n            console.log(\"SHORTCUT HANDLER: '@' key or SHIFT+2 detected\");\n            const inputField = document.activeElement;\n            const isContentEditableInput = inputField &&\n                inputField.getAttribute('contenteditable') === 'true' &&\n                inputField.classList.contains('jp-llm-ext-input-field');\n            // Handle the case where the input field is NOT the active element first\n            if (isContentEditableInput) { // Only handle if NOT our input field\n                console.log(\"SHORTCUT HANDLER: Input field is NOT active element. Handling '@' globally.\");\n                // If not in our input field, prevent default, show widget, focus, insert '@', and show popup.\n                event.preventDefault();\n                event.stopPropagation();\n                showWidget();\n                focusInput();\n                // After focus, show popup via window.setTimeout to ensure input is ready\n                window.setTimeout(() => {\n                    const inputElement = document.querySelector('.jp-llm-ext-input-field');\n                    if (inputElement) {\n                        const selection = window.getSelection();\n                        if (selection) { // Check if selection exists (even if rangeCount is 0 initially)\n                            // Ensure the input field has focus *before* manipulating the range\n                            if (document.activeElement !== inputElement) {\n                                inputElement.focus(); // Re-focus just in case\n                            }\n                            // Create or get the range\n                            let range;\n                            if (selection.rangeCount > 0) {\n                                range = selection.getRangeAt(0);\n                                // Double-check if the focus is now correctly inside the input element\n                                if (!inputElement.contains(range.commonAncestorContainer)) {\n                                    console.log(\"SHORTCUT HANDLER: Range is not inside the input field after focus. Creating new range.\");\n                                    // If range is not inside, create a new one collapsed at the end\n                                    range = document.createRange();\n                                    range.selectNodeContents(inputElement);\n                                    range.collapse(false); // Collapse to the end\n                                    selection.removeAllRanges();\n                                    selection.addRange(range);\n                                }\n                            }\n                            else {\n                                // If no range exists, create one collapsed at the end\n                                console.log(\"SHORTCUT HANDLER: No range found after focus. Creating new range.\");\n                                range = document.createRange();\n                                range.selectNodeContents(inputElement);\n                                range.collapse(false); // Collapse to the end\n                                selection.removeAllRanges();\n                                selection.addRange(range);\n                            }\n                            // Manually insert '@' since we prevented default\n                            const atNode = document.createTextNode('@');\n                            range.deleteContents(); // Clear any selection just in case\n                            range.insertNode(atNode);\n                            // Move cursor after the inserted '@'\n                            range.setStartAfter(atNode);\n                            range.setEndAfter(atNode);\n                            selection.removeAllRanges(); // Update selection to the new cursor position\n                            selection.addRange(range);\n                            // **NESTED TIMEOUT:** Give browser time to render before getting range position\n                            window.setTimeout(() => {\n                                console.log(\"SHORTCUT HANDLER: Showing popup after focusing, inserting '@', and nested timeout.\");\n                                // Ensure we get the most up-to-date range reference\n                                const currentSelection = window.getSelection();\n                                if (currentSelection && currentSelection.rangeCount > 0) {\n                                    const currentRange = currentSelection.getRangeAt(0);\n                                    // --- Insert temporary span to get reliable coords --- \n                                    const tempAnchorId = 'jp-llm-shortcut-popup-anchor';\n                                    let tempSpan = document.getElementById(tempAnchorId);\n                                    if (tempSpan)\n                                        tempSpan.remove(); // Clean up previous\n                                    tempSpan = document.createElement('span');\n                                    tempSpan.id = tempAnchorId;\n                                    tempSpan.style.visibility = 'hidden';\n                                    tempSpan.style.width = '0';\n                                    tempSpan.style.overflow = 'hidden';\n                                    tempSpan.textContent = '\\u200B'; // Zero-width space\n                                    currentRange.insertNode(tempSpan); // Insert at cursor\n                                    const spanRect = tempSpan.getBoundingClientRect();\n                                    tempSpan.remove(); // Remove immediately\n                                    // --- End temporary span logic ---\n                                    if (spanRect.top === 0 && spanRect.left === 0) {\n                                        console.error(\"SHORTCUT HANDLER: Failed to get valid coordinates from temp anchor span.\");\n                                    }\n                                    else {\n                                        console.log(`SHORTCUT HANDLER: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);\n                                        popupMenuManager.showPopupMenu({ x: spanRect.left, y: spanRect.top });\n                                        showIndicator('Browsing references...');\n                                    }\n                                }\n                                else {\n                                    console.error(\"SHORTCUT HANDLER: Could not get range immediately before showing popup.\");\n                                }\n                            }, 0); // 0ms delay is often sufficient\n                        }\n                        else {\n                            console.log(\"SHORTCUT HANDLER: No selection object after focus, cannot insert '@' or show popup reliably.\");\n                        }\n                    }\n                    else {\n                        console.log(\"SHORTCUT HANDLER: Could not find input element after timeout.\");\n                    }\n                }, 50); // Outer timeout remains 50ms\n            }\n            else {\n                // Input field IS focused. Let default '@' insertion happen.\n                // The 'input' listener in UIManager should handle the popup.\n                console.log(\"SHORTCUT HANDLER: Input field IS active element. Letting default '@' behavior proceed.\");\n            }\n        }\n        // Check for Ctrl+L (insert selection or cell)\n        else if (event.ctrlKey && event.key.toLowerCase() === 'l') {\n            event.preventDefault();\n            event.stopPropagation();\n            const selected = (0, notebook_integration_1.getSelectedText)();\n            // const cellContent = getCurrentCellContent(); // We don't need the content itself anymore\n            const isCellFocused = (0, notebook_integration_1.isInNotebookCellAndEditorFocused)(); // If the cursor is in the editor mode\n            const isCellSelected = (0, notebook_integration_1.isInNotebookCell)(); // If the cursor is in the notebook cell\n            const activeCellIndex = (_c = (_b = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.activeCellIndex; // Get index\n            let handled = false;\n            // Priority 1: Selected text in an active cell editor\n            if (isCellFocused && selected) {\n                // Call the new InputHandler method to create the reference and insert its representation\n                inputHandler.handleInsertCodeReferenceFromShortcut(selected);\n                showIndicator('Code reference inserted'); // Updated indicator message\n                handled = true;\n                // Priority 2: Active cell selected (not necessarily editor focus)\n            }\n            else if (isCellSelected && activeCellIndex !== undefined && activeCellIndex !== null) {\n                // Call the new InputHandler method to create the reference and insert its representation\n                inputHandler.handleInsertCellReferenceFromShortcut();\n                showIndicator('Cell reference inserted'); // Message remains the same\n                handled = true;\n            }\n            else {\n                // Invalid context for the shortcut\n                showIndicator('Cannot insert reference: Select code or an active cell.');\n                handled = true; // Still handled the shortcut, just showed a warning\n            }\n            // Ensure the sidebar is visible and input is focused only if an action was taken\n            if (handled) {\n                showWidget(); // Use callback\n                focusInput(); // Use callback\n            }\n        }\n    };\n    // Add the event listener to the document\n    document.addEventListener('keydown', _handleKeyDown);\n}\n/**\n * Removes the global keyboard shortcut listener.\n */\nfunction removeShortcuts() {\n    if (_handleKeyDown) {\n        document.removeEventListener('keydown', _handleKeyDown);\n        _handleKeyDown = null;\n        console.log('Removed keyboard shortcuts.');\n    }\n    else {\n        console.warn('Attempted to remove shortcuts, but none were active.');\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\nconst launcher_1 = require(\"@jupyterlab/launcher\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst docmanager_1 = require(\"@jupyterlab/docmanager\");\nconst sidebar_widget_1 = require(\"./sidebar-widget\");\nconst globals_1 = require(\"./core/globals\");\nconst commands_1 = require(\"./commands\");\nconst cell_context_tracker_1 = require(\"./cell-context-tracker\");\n// import { ApiClient } from './api-client';\n// Import the main CSS file\nrequire(\"../style/index.css\");\n// Export ApiClient for use by other components\nvar api_client_1 = require(\"./core/api-client\");\nObject.defineProperty(exports, \"ApiClient\", { enumerable: true, get: function () { return api_client_1.ApiClient; } });\n/**\n * Initialization data for the jupyter-simple-extension extension.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references\n        (0, globals_1.initGlobals)(jupyterApp, tracker);\n        // Initialize cell context tracker\n        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget\n        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands\n        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexports.default = plugin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSidebarWidget = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst icons_1 = require(\"./core/icons\");\nconst api_client_1 = require(\"./core/api-client\");\nconst popup_menu_manager_1 = require(\"./handlers/popup-menu-manager\");\nconst shortcut_handler_1 = require(\"./handlers/shortcut-handler\");\nconst layout_builder_1 = require(\"./ui/layout-builder\");\nconst settings_modal_1 = require(\"./ui/settings-modal\");\nconst chat_state_1 = require(\"./state/chat-state\");\nconst settings_state_1 = require(\"./state/settings-state\");\nconst input_handler_1 = require(\"./handlers/input-handler\");\nconst message_handler_1 = require(\"./handlers/message-handler\");\nconst history_handler_1 = require(\"./handlers/history-handler\");\nconst settings_handler_1 = require(\"./handlers/settings-handler\");\nconst ui_manager_1 = require(\"./ui/ui-manager\");\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\nconst globals_1 = require(\"./core/globals\");\nconst note_state_1 = require(\"./state/note-state\");\nconst note_handler_1 = require(\"./handlers/note-handler\");\n// --- Import Utility Functions ---\nconst clipboard_1 = require(\"./utils/clipboard\");\nconst notebook_integration_1 = require(\"./utils/notebook-integration\");\n/**\n * Main sidebar widget for the AI chat interface - Now acts as an orchestrator.\n */\nclass SimpleSidebarWidget extends widgets_1.Widget {\n    /**\n     * Helper function to replace a text range with a non-editable widget span.\n     */\n    createWidgetSpan(range, refText) {\n        if (!range)\n            return;\n        // Extract a display-friendly version (e.g., filename from path)\n        let displayLabel = refText;\n        if (refText.startsWith('@file ') || refText.startsWith('@dir ')) {\n            const parts = refText.split(' ');\n            if (parts.length > 1) {\n                const pathParts = parts[1].split(/[\\\\/]/);\n                displayLabel = pathParts[pathParts.length - 1] || parts[1]; // Use last part of path or full path\n            }\n        }\n        else if (refText.startsWith('@Cell ')) {\n            displayLabel = refText.substring(1); // Remove leading '@'\n        } // Add more conditions for other types if needed\n        // Create the widget span\n        const span = document.createElement('span');\n        span.className = 'jp-llm-ext-ref-widget'; // Class for styling\n        span.setAttribute('contenteditable', 'false'); // Make it non-editable\n        span.setAttribute('data-ref-text', refText); // Store original text for serialization\n        span.textContent = displayLabel; // Set visible text\n        // Replace the range content with the span\n        range.deleteContents();\n        range.insertNode(span);\n        // Move cursor after the inserted span\n        const selection = window.getSelection();\n        if (selection) {\n            const newRange = document.createRange();\n            newRange.setStartAfter(span);\n            newRange.setEndAfter(span);\n            selection.removeAllRanges();\n            selection.addRange(newRange);\n        }\n    }\n    constructor(docManager) {\n        super();\n        // Placeholder for handler methods used in UIManager callbacks\n        this.handleNewChat = () => {\n            var _a;\n            console.log('Handle New Chat clicked');\n            const newChat = this.chatState.createNewChat();\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);\n        };\n        this.handleToggleHistory = () => {\n            console.log('Handle Toggle History clicked');\n            this.historyHandler.toggleHistoryView();\n        };\n        this.handleToggleNotes = () => {\n            console.log('Handle Toggle Notes clicked');\n            this.noteHandler.toggleNotesView();\n        };\n        this.handleSendMessage = (message, isMarkdown = false) => {\n            // 1. Get the current text from the input field via UIManager or LayoutElements\n            // const text = this.layoutElements.inputField.value; // No longer needed, text is passed in\n            if (!message.trim())\n                return; // Don't send empty messages (check the passed message)\n            console.log(`[Widget] handleSendMessage: Text='${message}', Markdown=${isMarkdown}`); // Debug log using passed message\n            // 3. Call the MessageHandler's send method with text and state\n            this.messageHandler.handleSendMessage(message, isMarkdown); // Pass the received message and markdown state\n            // NOTE: Input clearing is now handled by UIManager after this callback returns.\n            // Do NOT clear input here or in MessageHandler.\n        };\n        this.handleShowSettings = (event) => {\n            console.log('Handle Show Settings clicked');\n            this.settingsHandler.showModal();\n        };\n        this.handleShowPopupMenu = (event, targetButton) => {\n            console.log('Handle Show Popup Menu clicked');\n            const rect = targetButton.getBoundingClientRect();\n            this.popupMenuManager.showPopupMenu({ x: rect.left, y: rect.bottom + 5 });\n        };\n        this.handleUpdateTitle = () => {\n            var _a;\n            const newTitle = ((_a = this.layoutElements.titleInput) === null || _a === void 0 ? void 0 : _a.value) || 'Chat';\n            console.log('Handle Update Title called:', newTitle);\n            this.chatState.updateCurrentChatTitle(newTitle);\n        };\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = icons_1.extensionIcon;\n        this.title.closable = true;\n        this.addClass('jp-llm-ext-sidebar');\n        // --- 1. Initialize Core Components & State ---\n        this.settingsState = new settings_state_1.SettingsState();\n        const initialSettings = this.settingsState.getSettings();\n        this.apiClient = new api_client_1.ApiClient((initialSettings === null || initialSettings === void 0 ? void 0 : initialSettings.apiUrl) || undefined);\n        this.chatState = new chat_state_1.ChatState();\n        this.noteState = new note_state_1.NoteState();\n        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {\n            insertCode: (code) => {\n                var _a, _b, _c;\n                if (!this.inputHandler || !globals_1.globals.notebookTracker)\n                    return;\n                const currentNotebookPanel = globals_1.globals.notebookTracker.currentWidget;\n                if (!currentNotebookPanel || !currentNotebookPanel.context || !currentNotebookPanel.content) {\n                    console.warn('Could not get notebook context for code reference, inserting raw code as fallback.');\n                    (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(code);\n                    return;\n                }\n                const notebookPath = currentNotebookPanel.context.path;\n                const notebookName = ((_b = notebookPath.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';\n                const currentCell = currentNotebookPanel.content.activeCell;\n                if (!currentCell) {\n                    console.warn('Could not get active cell for code reference, inserting raw code as fallback.');\n                    (_c = this.inputHandler) === null || _c === void 0 ? void 0 : _c.appendToInput(code);\n                    return;\n                }\n                const cellIndex = currentNotebookPanel.content.activeCellIndex;\n                let lineNumber = 1; // Default line number\n                let lineEndNumber = 1; // Default end line number\n                // --- DEBUG LOG --- \n                console.log('Are we currently in a code cell?');\n                // check if currentCell is in editor \n                console.log(currentCell.editor);\n                // --- END DEBUG LOG ---\n                if (currentCell.editor) {\n                    const editor = currentCell.editor;\n                    const cmEditor = editor.editor; // Access CodeMirror editor instance (EditorView)\n                    if (cmEditor && cmEditor.state) {\n                        const state = cmEditor.state;\n                        const selection = state.selection.main;\n                        if (!selection.empty) {\n                            lineNumber = state.doc.lineAt(selection.from).number; // 1-based start line\n                            lineEndNumber = state.doc.lineAt(selection.to).number; // 1-based end line\n                        }\n                        else {\n                            // Fallback for cursor position if no selection\n                            const cursor = editor.getCursorPosition();\n                            if (cursor) {\n                                lineNumber = cursor.line + 1; // 1-based line number\n                                lineEndNumber = lineNumber; // Start and end are the same for cursor\n                            }\n                        }\n                    }\n                    else {\n                        // Fallback if cmEditor or state is not available (should not happen often)\n                        console.warn('Could not access CodeMirror state for line numbers.');\n                        const cursor = editor.getCursorPosition();\n                        if (cursor) {\n                            lineNumber = cursor.line + 1;\n                            lineEndNumber = lineNumber;\n                        }\n                    }\n                }\n                else {\n                    console.warn('Could not access cell editor for line numbers.');\n                    // Keep default line numbers 1, 1 if editor is not available\n                }\n                // --- DEBUG LOG --- \n                console.log(`[SimpleSidebarWidget.insertCode] Determined lines: Start=${lineNumber}, End=${lineEndNumber}`);\n                // --- END DEBUG LOG ---\n                // Pass both start and end line numbers\n                const refId = this.inputHandler.addCodeReference(code, notebookName, cellIndex, lineNumber, lineEndNumber);\n                const placeholder = `@code[${refId}]`;\n                this.inputHandler.appendToInput(placeholder);\n            },\n            insertCell: (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@cell ${content}`); },\n            handleInsertFileWidget: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.handleInsertFileWidget(path); },\n            handleInsertDirWidget: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.handleInsertDirWidget(path); },\n            getSelectedText: notebook_integration_1.getSelectedText,\n            getCurrentCellContent: notebook_integration_1.getCurrentCellContent,\n            insertCellByIndex: (index) => {\n                var _a;\n                (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.handleInsertCellWidgetFromPopup(index);\n            },\n            // TODO: insertCollapsedCodeRef should later be merged with insertCode\n            // as we only expect one kind of behavior from the input handler.\n            // this change will also involve ui changes\n            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {\n                if (!this.inputHandler)\n                    return;\n                this.inputHandler.handleInsertCodeWidgetFromPopup(code, notebookName, cellIndex, lineNumber);\n            }\n        });\n        // --- 2. Define Callbacks (used by buildLayout and Handlers) ---\n        // Callbacks for UI actions (passed to buildLayout)\n        const createNewChatCallback = () => {\n            var _a;\n            const newChat = this.chatState.createNewChat();\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);\n        };\n        const toggleHistoryCallback = () => {\n            var _a;\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.toggleHistoryView();\n        };\n        const toggleNotesCallback = () => {\n            this.noteHandler.toggleNotesView();\n        };\n        const showSettingsCallback = () => {\n            var _a;\n            (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.showModal();\n        };\n        const showPopupMenuCallback = (event) => {\n            const rect = event.target.getBoundingClientRect();\n            this.popupMenuManager.showPopupMenu({ x: rect.left + 60, y: rect.top - 20 });\n            event.preventDefault();\n            event.stopPropagation();\n        };\n        const sendMessageViaButtonCallback = () => {\n            const inputElement = this.layoutElements.inputField;\n            const event = new KeyboardEvent('keypress', { key: 'Enter', bubbles: true });\n            inputElement.dispatchEvent(event);\n        };\n        const toggleMarkdownModeCallback = (isMarkdown) => {\n            var _a;\n            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.setMarkdownMode(isMarkdown);\n        };\n        const toggleExpandInputCallback = (button) => {\n            var _a;\n            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.toggleInputExpansion();\n        };\n        // Callbacks for Message Rendering (passed to MessageHandler -> UIManager -> renderers)\n        const messageRendererCallbacks = {\n            showCopyFeedback: (button, success = true) => {\n                const originalHTML = button.innerHTML;\n                button.innerHTML = success ? 'Copied!' : 'Failed!';\n                button.disabled = true;\n                setTimeout(() => {\n                    button.innerHTML = originalHTML;\n                    button.disabled = false;\n                }, 1000);\n            },\n            addMessageToCell: notebook_integration_1.addMessageToCell,\n            copyToClipboard: (text, feedbackCb) => {\n                navigator.clipboard.writeText(text).then(() => feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb()).catch(err => {\n                    console.error('Failed to copy text: ', err);\n                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();\n                });\n            },\n            copyImageToClipboard: (imageUrl, feedbackCb) => {\n                (0, clipboard_1.copyImageToClipboard)(imageUrl, (success) => {\n                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();\n                });\n            },\n            copyMessageToClipboard: (text, feedbackCb) => {\n                (0, clipboard_1.copyMessageToClipboard)(text, (success) => {\n                    feedbackCb();\n                });\n            },\n            handleConfirmInterrupt: () => {\n                var _a;\n                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('confirmed');\n            },\n            handleRejectInterrupt: () => {\n                var _a;\n                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('rejected');\n            }\n        };\n        const settingsModalCallbacks = {\n            handleSave: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.saveSettings(); },\n            handleCancel: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.hideModal(); }\n        };\n        const historyHandlerCallbacks = {\n            updateTitleInput: (title) => this.uiManager.updateTitleInput(title),\n            clearMessageContainer: () => this.uiManager.clearMessageContainer(),\n            addRenderedMessage: (messageElement) => this.uiManager.addChatMessageElement(messageElement)\n        };\n        const noteHandlerCallbacks = {\n            updateTitleInput: (title) => this.uiManager.updateTitleInput(title)\n        };\n        const inputHandlerCallbacks = {\n            handleSendMessage: (message, isMarkdown) => {\n                if (this.messageHandler) {\n                    this.messageHandler.handleSendMessage(message, isMarkdown);\n                }\n                else {\n                    console.error('MessageHandler not initialized when trying to send message from InputHandler');\n                }\n            },\n            showPopupMenu: (left, top) => this.popupMenuManager.showPopupMenu({ x: left, y: top }),\n            hidePopupMenu: () => this.popupMenuManager.hidePopupMenu(),\n            updatePlaceholder: (isMarkdown) => {\n                // Use dataset for data-placeholder attribute\n                this.layoutElements.inputField.dataset.placeholder = isMarkdown ? 'Enter markdown...' : 'Ask anything...';\n            },\n            toggleInputExpansionUI: (isExpanded) => {\n                const button = this.layoutElements.expandButton;\n                // Clear existing content (text or old icon)\n                while (button.firstChild) {\n                    button.removeChild(button.firstChild);\n                }\n                // Add the appropriate icon using LabIcon.resolve\n                const icon = isExpanded\n                    ? ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-up' })\n                    : ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-down' });\n                icon.element({ container: button, tag: 'span' }); // Add icon to button\n                // Update title for accessibility\n                button.title = isExpanded ? 'Collapse input' : 'Expand input';\n            },\n            getCodeRefMap: () => { var _a; return ((_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.getCodeReferenceMap()) || new Map(); },\n            resetCodeRefMap: () => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.resetCodeReferences(); }\n        };\n        const shortcutCallbacks = {\n            showIndicator: (text) => { var _a; return (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showIndicator(text); },\n            appendToInput: (text) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(text); },\n            showWidget: () => { if (this.isHidden) {\n                this.show();\n            } },\n            focusInput: () => { var _a, _b; return (_b = (_a = this.layoutElements) === null || _a === void 0 ? void 0 : _a.inputField) === null || _b === void 0 ? void 0 : _b.focus(); }\n        };\n        // --- 3. Build UI Layout ---\n        this.layoutElements = (0, layout_builder_1.buildLayout)({\n            onNewChatClick: createNewChatCallback,\n            onHistoryToggleClick: toggleHistoryCallback,\n            onNotesClick: toggleNotesCallback,\n            onSettingsClick: showSettingsCallback,\n            onTitleChange: this.handleUpdateTitle,\n            onAtButtonClick: showPopupMenuCallback,\n            onSendMessageClick: sendMessageViaButtonCallback,\n            onMarkdownToggleChange: toggleMarkdownModeCallback,\n            onExpandToggleClick: toggleExpandInputCallback,\n        });\n        this.settingsModalContainer = (0, settings_modal_1.createSettingsModalElement)(settingsModalCallbacks);\n        // --- Initialize State Managers ---\n        this.chatState = new chat_state_1.ChatState();\n        this.settingsState = new settings_state_1.SettingsState();\n        this.noteState = new note_state_1.NoteState();\n        // --- Initialize Core Components ---\n        this.apiClient = new api_client_1.ApiClient();\n        // --- Initialize UI Manager (needs dependencies) ---\n        const uiManagerCallbacks = {\n            handleNewChat: this.handleNewChat,\n            handleToggleHistory: this.handleToggleHistory,\n            handleToggleNotes: this.handleToggleNotes,\n            handleSendMessage: this.handleSendMessage,\n            handleShowSettings: this.handleShowSettings,\n            handleShowPopupMenu: this.handleShowPopupMenu,\n            handleUpdateTitle: this.handleUpdateTitle\n        };\n        this.uiManager = new ui_manager_1.UIManager(this.popupMenuManager, uiManagerCallbacks, this.layoutElements);\n        // --- 4. Initialize Handlers (using UI elements and core components) ---\n        this.inputHandler = new input_handler_1.InputHandler(this.layoutElements.inputField, inputHandlerCallbacks);\n        this.messageHandler = new message_handler_1.MessageHandler(this.apiClient, this.chatState, this.uiManager, messageRendererCallbacks, this.inputHandler);\n        this.historyHandler = new history_handler_1.HistoryHandler(this.chatState, this.uiManager, historyHandlerCallbacks, messageRendererCallbacks);\n        this.noteHandler = new note_handler_1.NoteHandler(this.noteState, this.uiManager, noteHandlerCallbacks, this.node);\n        // Replace the layout's notes container with the one from NoteHandler\n        const noteContainer = this.noteHandler.getContainer();\n        const layoutNoteContainer = this.layoutElements.notesContainer;\n        const parent = layoutNoteContainer.parentNode;\n        if (parent) {\n            parent.replaceChild(noteContainer, layoutNoteContainer);\n            // Update the reference in layoutElements\n            this.layoutElements.notesContainer = noteContainer;\n        }\n        this.settingsHandler = new settings_handler_1.SettingsHandler(this.settingsState, this.settingsModalContainer, this.uiManager);\n        // --- 5. Final Setup (Attach event listeners, connect signals, etc.) ---\n        const initialChatId = this.chatState.getCurrentChatId();\n        if (initialChatId) {\n            this.historyHandler.loadChat(initialChatId);\n        }\n        else {\n            const newChat = this.chatState.createNewChat();\n            this.historyHandler.loadChat(newChat.id);\n        }\n        // Setup global keyboard shortcuts with the UIManager for proper @ key handling\n        (0, shortcut_handler_1.setupShortcuts)(this.inputHandler, this.popupMenuManager, shortcutCallbacks);\n        this.node.appendChild(this.layoutElements.mainElement);\n        this.node.appendChild(this.settingsModalContainer);\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        var _a, _b;\n        if (this.isDisposed) {\n            return;\n        }\n        (0, shortcut_handler_1.removeShortcuts)();\n        (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this.popupMenuManager) === null || _b === void 0 ? void 0 : _b.dispose();\n        super.dispose();\n    }\n} // End of SimpleSidebarWidget class\nexports.SimpleSidebarWidget = SimpleSidebarWidget;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatState = void 0;\nconst uuid_1 = require(\"uuid\");\n/**\n * Manages the state of chat history and the currently active chat.\n */\nclass ChatState {\n    constructor() {\n        var _a;\n        this.chatHistory = [];\n        this.currentChatId = null;\n        // Potential: Load initial state from storage if persistence is added later\n        if (this.chatHistory.length === 0) {\n            this.createNewChat('Welcome Chat'); // Create an initial chat if none exists\n        }\n        else {\n            this.currentChatId = ((_a = this.chatHistory[0]) === null || _a === void 0 ? void 0 : _a.id) || null; // Set current chat to the first one\n        }\n    }\n    /**\n     * Creates a new chat session and sets it as the current chat.\n     * @param title - The initial title for the new chat.\n     * @returns The newly created chat item.\n     */\n    createNewChat(title = 'New Chat') {\n        const chatId = `chat-${(0, uuid_1.v4)()}`; // Use UUID for better uniqueness\n        const newChat = {\n            id: chatId,\n            title: title,\n            messages: [],\n            // Optional: Add timestamp or other metadata if needed later\n            // createdAt: Date; \n        };\n        this.chatHistory.push(newChat);\n        this.currentChatId = chatId;\n        console.log('Created new chat:', newChat);\n        return newChat;\n    }\n    /**\n     * Sets the currently active chat ID.\n     * @param chatId - The ID of the chat to set as current.\n     */\n    setCurrentChatId(chatId) {\n        if (this.chatHistory.some(chat => chat.id === chatId)) {\n            this.currentChatId = chatId;\n        }\n        else {\n            console.warn(`Chat ID ${chatId} not found in history.`);\n        }\n    }\n    /**\n     * Gets the ID of the currently active chat.\n     * @returns The current chat ID or null if none is active.\n     */\n    getCurrentChatId() {\n        return this.currentChatId;\n    }\n    /**\n     * Retrieves a specific chat by its ID.\n     * @param chatId - The ID of the chat to retrieve.\n     * @returns The chat item or undefined if not found.\n     */\n    getChatById(chatId) {\n        return this.chatHistory.find(chat => chat.id === chatId);\n    }\n    /**\n     * Retrieves the currently active chat item.\n     * @returns The current chat item or undefined if no chat is active or found.\n     */\n    getCurrentChat() {\n        if (!this.currentChatId) {\n            return undefined;\n        }\n        return this.getChatById(this.currentChatId);\n    }\n    /**\n     * Updates the title of the currently active chat.\n     * @param newTitle - The new title for the chat.\n     */\n    updateCurrentChatTitle(newTitle) {\n        const currentChat = this.getCurrentChat();\n        if (currentChat) {\n            currentChat.title = newTitle;\n            console.log(`Updated title for chat ${this.currentChatId} to \"${newTitle}\"`);\n        }\n        else {\n            console.warn('Cannot update title: No current chat selected.');\n        }\n    }\n    /**\n     * Adds a message to the currently active chat.\n     * @param message - The message object to add.\n     */\n    addMessageToCurrentChat(message) {\n        const currentChat = this.getCurrentChat();\n        if (currentChat) {\n            currentChat.messages.push(message);\n        }\n        else {\n            console.warn('Cannot add message: No current chat selected.');\n        }\n    }\n    /**\n     * Gets all messages from the currently active chat.\n     * @returns An array of messages or an empty array if no chat is active.\n     */\n    getCurrentChatMessages() {\n        const currentChat = this.getCurrentChat();\n        return currentChat ? currentChat.messages : [];\n    }\n    /**\n     * Gets the entire chat history.\n     * @returns An array of all chat history items.\n     */\n    getChatHistory() {\n        return [...this.chatHistory]; // Return a copy to prevent direct modification\n    }\n}\nexports.ChatState = ChatState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoteState = void 0;\nconst uuid_1 = require(\"uuid\");\n/**\n * Manages the state of notes and the currently selected note.\n */\nclass NoteState {\n    constructor() {\n        this.notes = [];\n        this.currentNoteId = null;\n        // In the future, we might load notes from persistent storage here\n    }\n    /**\n     * Creates a new note.\n     * @param title - The title for the new note.\n     * @param content - The content for the new note.\n     * @returns The newly created note.\n     */\n    createNewNote(title, content) {\n        const timestamp = new Date().toISOString();\n        const newNote = {\n            id: (0, uuid_1.v4)(),\n            title,\n            content,\n            createdAt: timestamp,\n            updatedAt: timestamp\n        };\n        this.notes.push(newNote);\n        this.currentNoteId = newNote.id;\n        return newNote;\n    }\n    /**\n     * Sets the currently selected note ID.\n     * @param noteId - The ID of the note to set as current.\n     */\n    setCurrentNoteId(noteId) {\n        this.currentNoteId = noteId;\n    }\n    /**\n     * Gets the ID of the currently selected note.\n     * @returns The current note ID or null if none is selected.\n     */\n    getCurrentNoteId() {\n        return this.currentNoteId;\n    }\n    /**\n     * Retrieves a specific note by its ID.\n     * @param noteId - The ID of the note to retrieve.\n     * @returns The note or undefined if not found.\n     */\n    getNoteById(noteId) {\n        return this.notes.find(note => note.id === noteId);\n    }\n    /**\n     * Retrieves the currently selected note.\n     * @returns The current note or undefined if no note is selected or found.\n     */\n    getCurrentNote() {\n        if (!this.currentNoteId) {\n            return undefined;\n        }\n        return this.getNoteById(this.currentNoteId);\n    }\n    /**\n     * Updates a note's title and content.\n     * @param noteId - The ID of the note to update.\n     * @param title - The new title for the note.\n     * @param content - The new content for the note.\n     * @returns The updated note or undefined if not found.\n     */\n    updateNote(noteId, title, content) {\n        const noteIndex = this.notes.findIndex(note => note.id === noteId);\n        if (noteIndex < 0) {\n            return undefined;\n        }\n        this.notes[noteIndex] = Object.assign(Object.assign({}, this.notes[noteIndex]), { title,\n            content, updatedAt: new Date().toISOString() });\n        return this.notes[noteIndex];\n    }\n    /**\n     * Deletes a note by its ID.\n     * @param noteId - The ID of the note to delete.\n     * @returns True if the note was found and deleted, false otherwise.\n     */\n    deleteNote(noteId) {\n        const initialLength = this.notes.length;\n        this.notes = this.notes.filter(note => note.id !== noteId);\n        if (this.notes.length < initialLength) {\n            // If the deleted note was the current one, reset current or set to the first note\n            if (this.currentNoteId === noteId) {\n                this.currentNoteId = this.notes.length > 0 ? this.notes[0].id : null;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Gets all notes.\n     * @returns An array of all notes.\n     */\n    getAllNotes() {\n        return [...this.notes]; // Return a copy to prevent direct mutation\n    }\n}\nexports.NoteState = NoteState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsState = void 0;\nconst SETTINGS_STORAGE_KEY = 'jp-llm-ext-settings';\n/**\n * Manages loading and saving application settings to localStorage.\n */\nclass SettingsState {\n    constructor() {\n        this.currentSettings = null;\n        this.currentSettings = this.loadSettings();\n    }\n    /**\n     * Loads settings from localStorage.\n     * @returns The loaded settings or null if none are saved or an error occurs.\n     */\n    loadSettings() {\n        const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);\n        if (savedSettings) {\n            try {\n                const settings = JSON.parse(savedSettings);\n                // Basic validation (can be expanded)\n                if (settings && settings.provider) {\n                    this.currentSettings = settings;\n                    console.log('Loaded settings:', this.currentSettings);\n                    return this.currentSettings;\n                }\n            }\n            catch (error) {\n                console.error('Error loading saved settings:', error);\n                localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear corrupted data\n            }\n        }\n        console.log('No valid settings found in localStorage.');\n        return null;\n    }\n    /**\n     * Saves the provided settings to localStorage.\n     * @param settings - The settings object to save.\n     */\n    saveSettings(settings) {\n        try {\n            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));\n            this.currentSettings = Object.assign({}, settings); // Update internal state\n            console.log('Settings saved:', this.currentSettings);\n        }\n        catch (error) {\n            console.error('Error saving settings:', error);\n            // Optional: Notify user of save failure\n        }\n    }\n    /**\n     * Gets the currently loaded settings.\n     * @returns The current settings object or null if not loaded.\n     */\n    getSettings() {\n        return this.currentSettings ? Object.assign({}, this.currentSettings) : null; // Return a copy\n    }\n    /**\n     * Gets a specific setting value.\n     * @param key - The key of the setting to retrieve.\n     * @returns The value of the setting or undefined if not found.\n     */\n    getSetting(key) {\n        return this.currentSettings ? this.currentSettings[key] : undefined;\n    }\n}\nexports.SettingsState = SettingsState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDiv = createDiv;\nexports.createButton = createButton;\nexports.createSpan = createSpan;\nexports.createTextArea = createTextArea;\nexports.createInputElement = createInputElement;\nexports.createImageElement = createImageElement;\nexports.createAnchorElement = createAnchorElement;\nexports.createLabelElement = createLabelElement;\nexports.createFormElement = createFormElement;\n/**\n * Generic function to create an HTMLElement.\n *\n * @param tagName - The HTML tag name (e.g., 'div', 'button').\n * @param options - Optional configuration for the element.\n * @returns The created HTMLElement.\n */\nfunction createElement(tagName, options = {}) {\n    const element = document.createElement(tagName);\n    if (options.id) {\n        element.id = options.id;\n    }\n    if (options.classes) {\n        const classesToAdd = Array.isArray(options.classes)\n            ? options.classes\n            : options.classes.split(' ').filter(c => c);\n        element.classList.add(...classesToAdd);\n    }\n    if (options.text) {\n        element.textContent = options.text;\n    }\n    else if (options.html) {\n        element.innerHTML = options.html; // Be cautious with HTML injection\n    }\n    if (options.attributes) {\n        for (const key in options.attributes) {\n            if (options.attributes.hasOwnProperty(key)) {\n                element.setAttribute(key, options.attributes[key]);\n            }\n        }\n    }\n    if (options.style) {\n        for (const key in options.style) {\n            if (options.style.hasOwnProperty(key)) {\n                element.style[key] = options.style[key];\n            }\n        }\n    }\n    if (options.children) {\n        options.children.forEach(child => {\n            if (typeof child === 'string') {\n                element.appendChild(document.createTextNode(child));\n            }\n            else {\n                element.appendChild(child);\n            }\n        });\n    }\n    return element;\n}\n/** Creates a <div> element. */\nfunction createDiv(options = {}) {\n    return createElement('div', options);\n}\n/** Creates a <button> element. */\nfunction createButton(options = {}) {\n    return createElement('button', options);\n}\n/** Creates a <span> element. */\nfunction createSpan(options = {}) {\n    return createElement('span', options);\n}\n/** Creates a <textarea> element. */\nfunction createTextArea(options = {}) {\n    return createElement('textarea', options);\n}\n/** Creates an <input> element. */\nfunction createInputElement(options = {}) {\n    var _a;\n    // Ensure type is set if provided in attributes, otherwise default or leave unset\n    if ((_a = options.attributes) === null || _a === void 0 ? void 0 : _a.type) {\n        // Type is already set in attributes, do nothing extra\n    }\n    else if (!options.attributes) {\n        options.attributes = { type: 'text' }; // Default to text if no attributes specified\n    }\n    else if (!options.attributes.type) {\n        options.attributes.type = 'text'; // Default to text if type is not in attributes\n    }\n    return createElement('input', options);\n}\n/** Creates an <img> element. */\nfunction createImageElement(options) {\n    const imgOptions = Object.assign({}, options);\n    imgOptions.attributes = Object.assign(Object.assign({}, options.attributes), { src: options.src });\n    if (options.alt) {\n        imgOptions.attributes.alt = options.alt;\n    }\n    return createElement('img', imgOptions);\n}\n/** Creates an <a> element. */\nfunction createAnchorElement(options) {\n    const anchorOptions = Object.assign({}, options);\n    anchorOptions.attributes = Object.assign(Object.assign({}, options.attributes), { href: options.href });\n    return createElement('a', anchorOptions);\n}\n/** Creates a <label> element. */\nfunction createLabelElement(options) {\n    const labelOptions = Object.assign({}, options);\n    if (options.htmlFor) {\n        labelOptions.attributes = Object.assign(Object.assign({}, options.attributes), { for: options.htmlFor });\n    }\n    return createElement('label', labelOptions);\n}\n/** Creates a <form> element. */\nfunction createFormElement(options = {}) {\n    return createElement('form', options);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildLayout = buildLayout;\nconst dom_elements_1 = require(\"./dom-elements\");\n/**\n * Builds the main HTML structure for the sidebar widget.\n *\n * @param callbacks - An object containing callback functions for various UI interactions.\n * @returns An object containing the main widget HTMLElement and references to key interactive elements.\n */\nfunction buildLayout(callbacks = {}) {\n    // --- Main Content Wrapper ---\n    const mainElement = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-content-wrapper'\n    });\n    // --- Title Bar ---\n    const titleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-title-container' });\n    const titleInput = (0, dom_elements_1.createInputElement)({\n        id: 'chat-title-input',\n        classes: 'chat-title-input',\n        attributes: { type: 'text', placeholder: 'Chat title', value: 'New Chat' }\n    });\n    if (callbacks.onTitleChange) {\n        titleInput.addEventListener('change', () => callbacks.onTitleChange(titleInput.value));\n    }\n    titleContainer.appendChild(titleInput);\n    // --- Message & History Containers ---\n    const messageContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-message-container' });\n    const historyContainer = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-history-container',\n        style: { display: 'none' } // Hidden by default\n    });\n    // --- Notes Container ---\n    const notesContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-notes-container', style: { display: 'none' } });\n    // --- Bottom Bar Area ---\n    const bottomBarContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-container' });\n    // Row 1: Controls (Markdown Toggle, @, Expand, Settings)\n    const controlsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row' });\n    const controlsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-controls-container' });\n    // Markdown Toggle\n    const toggleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-toggle-container' });\n    const markdownToggleButton = (0, dom_elements_1.createInputElement)({\n        id: 'markdown-toggle',\n        attributes: { type: 'checkbox' }\n    });\n    const toggleLabel = (0, dom_elements_1.createLabelElement)({\n        text: 'Markdown mode',\n        htmlFor: 'markdown-toggle'\n    });\n    if (callbacks.onMarkdownToggleChange) {\n        markdownToggleButton.addEventListener('change', () => {\n            callbacks.onMarkdownToggleChange(markdownToggleButton.checked);\n        });\n    }\n    toggleContainer.appendChild(markdownToggleButton);\n    toggleContainer.appendChild(toggleLabel);\n    // Action Buttons (@, Expand, Settings)\n    const actionButtonsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-action-buttons-container' });\n    const atButton = (0, dom_elements_1.createButton)({ text: '@', attributes: { title: 'Browse cells, code, files, and more' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onAtButtonClick) {\n        atButton.addEventListener('click', callbacks.onAtButtonClick);\n    }\n    const expandButton = (0, dom_elements_1.createButton)({ text: '⤢', attributes: { title: 'Expand input' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onExpandToggleClick) {\n        expandButton.addEventListener('click', () => callbacks.onExpandToggleClick(expandButton));\n    }\n    const settingsButton = (0, dom_elements_1.createButton)({ text: '⚙️', attributes: { title: 'Settings' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onSettingsClick) {\n        settingsButton.addEventListener('click', callbacks.onSettingsClick);\n    }\n    actionButtonsContainer.appendChild(atButton);\n    actionButtonsContainer.appendChild(expandButton);\n    actionButtonsContainer.appendChild(settingsButton);\n    controlsContainer.appendChild(toggleContainer);\n    controlsContainer.appendChild(actionButtonsContainer);\n    controlsRow.appendChild(controlsContainer);\n    // Row 2: Input Field\n    const inputRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row' });\n    const inputField = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-input-field',\n        attributes: {\n            contenteditable: 'true',\n            role: 'textbox',\n            'aria-multiline': 'true',\n            'data-placeholder': 'Ask me anything...'\n        },\n        style: { minHeight: '20px', overflowY: 'hidden' }\n    });\n    if (callbacks.onInputFieldKeyPress) {\n        inputField.addEventListener('keypress', callbacks.onInputFieldKeyPress);\n    }\n    if (callbacks.onInputFieldValueChange) {\n        inputField.addEventListener('input', () => callbacks.onInputFieldValueChange(inputField.textContent || ''));\n    }\n    inputRow.appendChild(inputField);\n    // Row 3: Main Buttons (Send, New Chat, History)\n    const buttonsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row' });\n    const sendButton = (0, dom_elements_1.createButton)({\n        text: 'Send',\n        classes: 'jp-Button jp-llm-ext-send-button'\n    });\n    if (callbacks.onSendMessageClick) {\n        sendButton.addEventListener('click', callbacks.onSendMessageClick);\n    }\n    const newChatButton = (0, dom_elements_1.createButton)({\n        text: '+ New Chat',\n        attributes: { title: 'Start a new chat' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onNewChatClick) {\n        newChatButton.addEventListener('click', callbacks.onNewChatClick);\n    }\n    const historyButton = (0, dom_elements_1.createButton)({\n        text: 'History',\n        attributes: { title: 'View chat history' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onHistoryToggleClick) {\n        historyButton.addEventListener('click', callbacks.onHistoryToggleClick);\n    }\n    // Notes button\n    const notesButton = (0, dom_elements_1.createButton)({\n        text: 'Notes',\n        attributes: { title: 'View notes' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onNotesClick) {\n        notesButton.addEventListener('click', callbacks.onNotesClick);\n    }\n    buttonsRow.appendChild(sendButton);\n    buttonsRow.appendChild(newChatButton);\n    buttonsRow.appendChild(historyButton);\n    buttonsRow.appendChild(notesButton);\n    // Assemble Bottom Bar\n    bottomBarContainer.appendChild(controlsRow);\n    bottomBarContainer.appendChild(inputRow);\n    bottomBarContainer.appendChild(buttonsRow);\n    // --- Assemble Main Element ---\n    mainElement.appendChild(titleContainer);\n    mainElement.appendChild(messageContainer);\n    mainElement.appendChild(historyContainer);\n    mainElement.appendChild(notesContainer);\n    mainElement.appendChild(bottomBarContainer);\n    return {\n        mainElement,\n        titleInput,\n        messageContainer,\n        historyContainer,\n        notesContainer,\n        inputField,\n        bottomBarContainer,\n        sendButton,\n        newChatButton,\n        historyButton,\n        notesButton,\n        markdownToggleButton,\n        expandButton,\n        atButton,\n        settingsButton\n    };\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageRenderer = void 0;\nexports.renderUserMessage = renderUserMessage;\nexports.renderBotMessage = renderBotMessage;\nexports.renderBotMessageStreamingStart = renderBotMessageStreamingStart;\nexports.renderBotMessageStreamingUpdate = renderBotMessageStreamingUpdate;\nexports.renderBotMessageFinal = renderBotMessageFinal;\nexports.renderReferenceWidgetInline = renderReferenceWidgetInline;\nconst marked_1 = require(\"marked\");\nconst dompurify_1 = __importDefault(require(\"dompurify\"));\n// import hljs from 'highlight.js'; // Removed unused import\nconst dom_elements_1 = require(\"./dom-elements\");\nconst globals_1 = require(\"../core/globals\"); // Import globals\n// Removed unused import block for clipboard utils (used via callbacks)\n// import { copyToClipboard, copyImageToClipboard, copyMessageToClipboard } from '../utils/clipboard';\n// Removed unused import (used via callbacks)\n// import { addMessageToCell } from '../utils/notebook-integration';\nconst highlighting_1 = require(\"../utils/highlighting\");\nconst markdown_config_1 = require(\"../utils/markdown-config\");\n/**\n * Base function to create a message container div.\n */\nfunction createMessageDiv(sender) {\n    const messageDiv = document.createElement('div');\n    messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';\n    return messageDiv;\n}\n/**\n * Renders a user message.\n */\nfunction renderUserMessage(text, options = {}, callbacks = {}) {\n    console.log(`[renderUserMessage] Rendering with isMarkdown: ${options.isMarkdown}, text: \"${text}\"`);\n    const messageDiv = createMessageDiv('user');\n    if (options.isMarkdown) {\n        // Use 'markdown-content' class for consistent styling\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'markdown-content';\n        try {\n            // Preprocess, parse, and sanitize like in bot messages\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // Add markdown indicator (similar to bot messages)\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            messageDiv.appendChild(markdownIndicator);\n            // Enhance code blocks if user messages can contain them\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                // Pass only relevant callbacks if needed for user code blocks\n                enhanceCodeBlock(block, callbacks);\n            });\n        }\n        catch (error) {\n            console.error('Failed to render user markdown:', error);\n            // Fallback to plain text if Markdown rendering fails\n            contentDiv.textContent = text;\n        }\n        messageDiv.appendChild(contentDiv);\n    }\n    else {\n        // Non-Markdown user message (plain text)\n        // Replace simple textContent assignment with ref-aware rendering\n        // messageDiv.textContent = text;\n        renderMessageContentWithRefs(messageDiv, text, callbacks);\n    }\n    return messageDiv;\n}\n/**\n * NEW: Renders message content, replacing @references with widgets.\n */\nfunction renderMessageContentWithRefs(container, text, callbacks) {\n    // --- DEBUG LOG --- \n    console.log('[renderMessageContentWithRefs] Processing text:', JSON.stringify(text)); // Log exact text\n    // --- END DEBUG LOG ---\n    // Regex to find @file, @dir, @Cell, @code references (with optional surrounding whitespace)\n    const refRegex = /\\s*(@(file|dir|Cell|code)\\[([^\\]]+?)\\])\\s*/g;\n    let lastIndex = 0;\n    let match;\n    // Reset regex state just in case\n    refRegex.lastIndex = 0;\n    while ((match = refRegex.exec(text)) !== null) {\n        // Append text before the match\n        if (match.index > lastIndex) {\n            container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));\n        }\n        // Process the matched reference\n        const fullMatchWithWhitespace = match[0]; // Includes potential whitespace\n        const fullMatch = match[1]; // The actual @type[value] part\n        const type = match[2];\n        const value = match[3];\n        try {\n            const widget = createRefWidget(type, value, fullMatch, callbacks); // Pass the clean match\n            container.appendChild(widget);\n        }\n        catch (error) {\n            console.error(`Failed to create widget for reference: ${fullMatch}`, error);\n            // Fallback: append the original reference text (with potential whitespace)\n            container.appendChild(document.createTextNode(fullMatchWithWhitespace));\n        }\n        lastIndex = refRegex.lastIndex;\n    }\n    // Append any remaining text after the last match\n    if (lastIndex < text.length) {\n        container.appendChild(document.createTextNode(text.substring(lastIndex)));\n    }\n}\n/**\n * NEW: Creates a reference widget span.\n */\nfunction createRefWidget(type, value, originalRefText, // The full @type[value] string\ncallbacks) {\n    const widget = document.createElement('span');\n    widget.className = `jp-llm-ext-ref-widget ref-${type.toLowerCase()}`;\n    widget.setAttribute('contenteditable', 'false');\n    widget.dataset.refText = originalRefText; // Store the original reference\n    let displayText = '';\n    let titleText = originalRefText; // Default tooltip\n    switch (type) {\n        case 'file':\n            displayText = value.split(/[\\\\/]/).pop() || value; // Extract filename\n            titleText = `File: ${value}`;\n            break;\n        case 'dir':\n            displayText = value.split(/[\\\\/]/).pop() || value || '/'; // Extract dirname, handle root\n            titleText = `Directory: ${value}`;\n            break;\n        case 'Cell': {\n            const cellIndex = parseInt(value) - 1; // Convert back to 0-based index\n            const notebookContext = callbacks.getCurrentNotebookContext ? callbacks.getCurrentNotebookContext() : undefined;\n            // --- DEBUG LOG --- \n            console.log(`[createRefWidget @Cell] Input Value: ${value}, Parsed Index: ${cellIndex}, Notebook Context:`, notebookContext);\n            // --- END DEBUG LOG --- \n            const notebookName = (notebookContext === null || notebookContext === void 0 ? void 0 : notebookContext.name) || 'notebook';\n            let cellTypeChar = '?';\n            if (notebookContext && globals_1.globals.notebookTracker) {\n                const currentNotebookPanel = globals_1.globals.notebookTracker.find(widget => widget.context.path === notebookContext.path);\n                if (currentNotebookPanel && currentNotebookPanel.model) {\n                    const cellModel = currentNotebookPanel.model.cells.get(cellIndex);\n                    if (cellModel) {\n                        cellTypeChar = cellModel.type === 'markdown' ? 'M' : 'C';\n                    }\n                }\n            }\n            displayText = `${notebookName}-${cellTypeChar}-${value}`; // value is 1-based index\n            titleText = `Cell ${value} (${cellTypeChar === 'M' ? 'Markdown' : 'Code'}) in ${notebookName}`;\n            break;\n        }\n        case 'code': {\n            const refId = value;\n            const refData = callbacks.getCodeRefData ? callbacks.getCodeRefData(refId) : undefined;\n            // --- DEBUG LOG --- \n            console.log(`[createRefWidget @code] Input Value (refId): ${refId}, Ref Data Found:`, refData);\n            // --- END DEBUG LOG --- \n            if (refData) {\n                // Construct display text using start and end lines\n                const startLine = refData.lineNumber;\n                const endLine = refData.lineEndNumber;\n                const linePart = startLine === endLine ? `${startLine}` : `${startLine}_${endLine}`;\n                displayText = `${refData.notebookName}-${refData.cellIndex + 1}-${linePart}`;\n                // Update title text as well\n                const titleLinePart = startLine === endLine ? `Line ${startLine}` : `Lines ${startLine}-${endLine}`;\n                titleText = `Code Reference: ${refData.notebookName}, Cell ${refData.cellIndex + 1}, ${titleLinePart}`;\n            }\n            else {\n                displayText = `code-ref-${refId}`; // Fallback display\n                titleText = `Code Reference ID: ${refId} (Data not found)`;\n            }\n            break;\n        }\n    }\n    widget.textContent = displayText;\n    widget.title = titleText; // Add tooltip\n    return widget;\n}\n/**\n * NEW: Recursively finds and replaces @references within text nodes of an element.\n */\nfunction renderRefsInElement(element, callbacks) {\n    // Use the same updated regex here\n    const refRegex = /\\s*(@(file|dir|Cell|code)\\[([^\\]]+?)\\])\\s*/g;\n    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);\n    let node;\n    const nodesToProcess = [];\n    while ((node = walker.nextNode())) {\n        if (node instanceof Text &&\n            node.textContent &&\n            !(node.parentElement && node.parentElement.closest('.jp-llm-ext-ref-widget'))) {\n            // Test with the specific regex before adding\n            refRegex.lastIndex = 0; // Reset before test\n            if (refRegex.test(node.textContent)) {\n                nodesToProcess.push(node);\n            }\n        }\n    }\n    // Now, process the collected text nodes\n    nodesToProcess.forEach(textNode => {\n        const parent = textNode.parentNode;\n        if (!parent)\n            return;\n        const text = textNode.textContent || '';\n        const fragment = document.createDocumentFragment();\n        let lastIndex = 0;\n        let match;\n        refRegex.lastIndex = 0; // Reset regex state for each node\n        while ((match = refRegex.exec(text)) !== null) {\n            // Append text before the match\n            if (match.index > lastIndex) {\n                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));\n            }\n            // Process the matched reference\n            const fullMatchWithWhitespace = match[0];\n            const fullMatch = match[1];\n            const type = match[2];\n            const value = match[3];\n            try {\n                const widget = createRefWidget(type, value, fullMatch, callbacks);\n                fragment.appendChild(widget);\n            }\n            catch (error) {\n                console.error(`Failed to create widget for reference: ${fullMatch}`, error);\n                fragment.appendChild(document.createTextNode(fullMatchWithWhitespace)); // Fallback\n            }\n            lastIndex = refRegex.lastIndex;\n        }\n        // Append any remaining text after the last match\n        if (lastIndex < text.length) {\n            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));\n        }\n        // Replace the original text node with the fragment\n        parent.replaceChild(fragment, textNode);\n    });\n}\n/**\n * Renders a bot message (text, markdown, images, code blocks).\n */\nfunction renderBotMessage(text, options = { isMarkdown: true }, callbacks = {}) {\n    const messageDiv = createMessageDiv('bot');\n    // Check if the message is an image URL\n    const isImageUrl = text.trim().startsWith('/images/') &&\n        (text.trim().endsWith('.png') ||\n            text.trim().endsWith('.jpg') ||\n            text.trim().endsWith('.jpeg') ||\n            text.trim().endsWith('.gif'));\n    if (isImageUrl) {\n        // Construct full URL (TODO: Make base URL configurable)\n        const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;\n        // Call dedicated image rendering function\n        renderImageMessage(messageDiv, fullImageUrl, callbacks);\n    }\n    else if (options.isMarkdown) {\n        // Render as markdown (logic from addMessage)\n        const markdownIndicator = document.createElement('div');\n        markdownIndicator.textContent = \"MD\";\n        markdownIndicator.className = 'markdown-indicator';\n        messageDiv.appendChild(markdownIndicator);\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'markdown-content';\n        try {\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // --- NEW: Render references within the sanitized HTML --- \n            renderRefsInElement(contentDiv, callbacks);\n            // --- End NEW ---\n            // Enhance code blocks after setting innerHTML and rendering refs\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                enhanceCodeBlock(block, callbacks);\n            });\n            // Check for and render interrupt buttons\n            const isInterrupt = text.startsWith('**[INTERRUPT]**');\n            if (isInterrupt) {\n                renderInterruptButtons(contentDiv, callbacks);\n            }\n        }\n        catch (error) {\n            contentDiv.textContent = text; // Fallback to plain text\n            console.error('Failed to render markdown:', error);\n        }\n        messageDiv.appendChild(contentDiv);\n        // Add overall message action buttons AFTER content is added\n        addBotMessageActions(messageDiv, text, callbacks);\n    }\n    else {\n        // Render as plain text\n        messageDiv.textContent = text;\n        // Add overall message action buttons even for plain text bot messages\n        addBotMessageActions(messageDiv, text, callbacks);\n    }\n    return messageDiv;\n}\n// Define createMessageWrapper based on createMessageDiv\nfunction createMessageWrapper(sender) {\n    return createMessageDiv(sender);\n}\n// --- More specific rendering functions or helpers can be added below ---\n/**\n * Renders an image message with action buttons inside a container.\n *\n * @param container The parent HTML element to append the image message to.\n * @param imageUrl The full URL of the image to render.\n * @param callbacks Callbacks for actions like copy image, add path.\n */\nfunction renderImageMessage(container, imageUrl, callbacks = {}) {\n    // Create a container for the image that allows positioning the buttons\n    const imageContainer = document.createElement('div');\n    imageContainer.className = 'jp-llm-ext-image-container';\n    imageContainer.style.position = 'relative';\n    // Render as an image tag\n    const img = document.createElement('img');\n    img.src = imageUrl;\n    img.alt = 'Image from bot';\n    img.style.maxWidth = '100%'; // Ensure image fits within the container\n    img.style.height = 'auto';\n    imageContainer.appendChild(img);\n    // Add action buttons for the image\n    const imgActionsDiv = document.createElement('div');\n    imgActionsDiv.className = 'jp-llm-ext-image-actions';\n    imgActionsDiv.style.position = 'absolute';\n    imgActionsDiv.style.bottom = '10px';\n    imgActionsDiv.style.right = '10px';\n    imgActionsDiv.style.display = 'flex';\n    imgActionsDiv.style.gap = '8px';\n    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)'; // Added slight background for visibility\n    imgActionsDiv.style.borderRadius = '4px';\n    imgActionsDiv.style.padding = '4px';\n    // Copy image button (using callback)\n    if (callbacks.copyImageToClipboard && callbacks.showCopyFeedback) {\n        const copyImgBtn = document.createElement('button');\n        copyImgBtn.className = 'jp-llm-ext-image-action-button';\n        copyImgBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyImgBtn.title = 'Copy image to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyImgBtn);\n        copyImgBtn.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyImageToClipboard(imageUrl, feedbackCb);\n        });\n        imgActionsDiv.appendChild(copyImgBtn);\n    }\n    // Add file path button (using callback)\n    if (callbacks.addMessageToCell) {\n        const addPathBtn = document.createElement('button');\n        addPathBtn.className = 'jp-llm-ext-image-action-button';\n        addPathBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addPathBtn.title = 'Add image path to current cell';\n        addPathBtn.addEventListener('click', (event) => {\n            event.stopPropagation();\n            // Pass the image URL (which is the message text in this case)\n            callbacks.addMessageToCell(imageUrl);\n        });\n        imgActionsDiv.appendChild(addPathBtn);\n    }\n    // Only add the actions div if it has buttons\n    if (imgActionsDiv.hasChildNodes()) {\n        imageContainer.appendChild(imgActionsDiv);\n    }\n    // Add the image container to the main message div\n    container.appendChild(imageContainer);\n}\n/**\n * Creates the initial structure for a bot message that will receive streaming content.\n *\n * @returns Object containing the wrapper, streaming div, and final content div.\n */\nfunction renderBotMessageStreamingStart() {\n    const wrapper = createMessageWrapper('bot');\n    const markdownIndicator = (0, dom_elements_1.createDiv)({\n        text: 'MD',\n        classes: 'markdown-indicator'\n    });\n    wrapper.appendChild(markdownIndicator);\n    const streamingDiv = (0, dom_elements_1.createDiv)({\n        classes: 'streaming-content',\n        style: {\n            whiteSpace: 'pre-wrap',\n            fontFamily: 'monospace',\n            fontSize: '0.9em'\n        }\n    });\n    wrapper.appendChild(streamingDiv);\n    const contentDiv = (0, dom_elements_1.createDiv)({\n        classes: 'markdown-content',\n        style: { display: 'none' } // Initially hidden\n    });\n    wrapper.appendChild(contentDiv);\n    return { wrapper, streamingDiv, contentDiv };\n}\n/**\n * Updates the streaming div with a new chunk of text.\n *\n * @param streamingDiv - The div displaying streaming content.\n * @param chunk - The new text chunk to append.\n */\nfunction renderBotMessageStreamingUpdate(streamingDiv, chunk) {\n    // Simple append, might need refinement for complex streams\n    streamingDiv.textContent += chunk;\n}\n/**\n * Renders the final content of a bot message after streaming is complete.\n * Handles markdown, images, code blocks, and interrupts.\n *\n * @param contentDiv - The div where the final content should be rendered.\n * @param streamingDiv - The div that was used for streaming (will be hidden).\n * @param completeResponse - The full text content from the bot.\n * @param options - Rendering options including callbacks for actions.\n * @returns The populated contentDiv.\n */\nfunction renderBotMessageFinal(contentDiv, streamingDiv, completeResponse, options = {}, callbacks = {}) {\n    // Hide streaming div, show final content div\n    streamingDiv.style.display = 'none';\n    contentDiv.style.display = 'block';\n    // Consolidate callbacks access\n    const effectiveCallbacks = Object.assign(Object.assign({}, options), callbacks);\n    // --- Image Handling ---\n    const isImageUrl = completeResponse.trim().startsWith('/images/') &&\n        (completeResponse.trim().endsWith('.png') ||\n            completeResponse.trim().endsWith('.jpg') ||\n            completeResponse.trim().endsWith('.jpeg') ||\n            completeResponse.trim().endsWith('.gif'));\n    if (isImageUrl) {\n        const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // TODO: Make base URL configurable\n        renderImageMessage(contentDiv, fullImageUrl, effectiveCallbacks);\n    }\n    else {\n        // --- Markdown & Code Block Handling ---\n        try {\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // --- NEW: Render references within the sanitized HTML --- \n            renderRefsInElement(contentDiv, effectiveCallbacks);\n            // --- End NEW ---\n            // --- Interrupt Handling ---\n            const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');\n            if (isInterrupt) {\n                renderInterruptButtons(contentDiv, effectiveCallbacks);\n            }\n            // --- Code Block Enhancements ---\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                enhanceCodeBlock(block, effectiveCallbacks);\n            });\n        }\n        catch (error) {\n            console.error('Error rendering markdown:', error);\n            contentDiv.textContent = completeResponse; // Fallback to plain text\n        }\n    }\n    return contentDiv;\n}\n/**\n * Enhances a code block element with highlighting and action buttons.\n *\n * @param codeBlockElement The <code> element within a <pre>.\n * @param callbacks Callbacks for actions like copy code, add to cell.\n */\nfunction enhanceCodeBlock(codeBlockElement, callbacks = {}) {\n    var _a;\n    const preElement = codeBlockElement.parentElement;\n    if (!preElement || preElement.tagName !== 'PRE') {\n        console.warn('Code block enhancement called on element not within a <pre> tag.');\n        return;\n    }\n    // Add standard JupyterLab classes for consistency\n    codeBlockElement.classList.add('jp-RenderedText');\n    preElement.classList.add('jp-RenderedHTMLCommon');\n    // Get code content\n    const codeContent = codeBlockElement.textContent || '';\n    // Create code block header for buttons and language indicator\n    const codeHeader = document.createElement('div');\n    codeHeader.className = 'jp-llm-ext-code-header';\n    // Add language indicator if detected\n    const language = (0, highlighting_1.detectLanguage)(codeContent); // Use imported util\n    if (language) {\n        const langIndicator = document.createElement('span');\n        langIndicator.className = 'jp-llm-ext-code-language';\n        langIndicator.textContent = language;\n        codeHeader.appendChild(langIndicator);\n        codeBlockElement.classList.add(`language-${language}`);\n    }\n    // Apply syntax highlighting\n    try {\n        // Use imported util (handles auto-detection if language is empty)\n        codeBlockElement.innerHTML = (0, highlighting_1.highlightCode)(codeContent, language);\n    }\n    catch (error) {\n        console.error('Error applying syntax highlighting:', error);\n        // codeBlockElement might contain original text or partially highlighted\n    }\n    // Add action buttons to the code header\n    const actionsDiv = document.createElement('div');\n    actionsDiv.className = 'jp-llm-ext-code-actions';\n    // Copy button\n    if (callbacks.copyToClipboard && callbacks.showCopyFeedback) {\n        const copyButton = document.createElement('button');\n        copyButton.className = 'jp-llm-ext-code-action-button';\n        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyButton.title = 'Copy code to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);\n        copyButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyToClipboard(codeContent, feedbackCb);\n        });\n        actionsDiv.appendChild(copyButton);\n    }\n    // Add to cell button\n    if (callbacks.addMessageToCell) {\n        const addToButton = document.createElement('button');\n        addToButton.className = 'jp-llm-ext-code-action-button';\n        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addToButton.title = 'Add code to current cell';\n        addToButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.addMessageToCell(codeContent);\n        });\n        actionsDiv.appendChild(addToButton);\n    }\n    // Add the actions to the header, and insert header before the <pre>\n    if (actionsDiv.hasChildNodes()) {\n        codeHeader.appendChild(actionsDiv);\n    }\n    if (codeHeader.hasChildNodes()) {\n        (_a = preElement.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(codeHeader, preElement);\n    }\n}\n/**\n * Renders Confirm/Reject buttons for an interrupt message.\n *\n * @param container The parent HTML element (message content div) to append buttons to.\n * @param callbacks Callbacks for confirm and reject actions.\n */\nfunction renderInterruptButtons(container, callbacks = {}) {\n    if (!callbacks.handleConfirmInterrupt || !callbacks.handleRejectInterrupt) {\n        console.warn('Interrupt message needs confirm/reject callbacks.');\n        return;\n    }\n    const buttonsContainer = document.createElement('div');\n    buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';\n    buttonsContainer.style.marginTop = '12px';\n    buttonsContainer.style.display = 'flex';\n    buttonsContainer.style.gap = '8px';\n    // Create confirm button\n    const confirmButton = document.createElement('button');\n    confirmButton.className = 'jp-llm-ext-confirm-button';\n    confirmButton.textContent = 'Confirm';\n    // Apply specific styling (can be moved to CSS)\n    confirmButton.style.padding = '6px 12px';\n    confirmButton.style.background = '#4CAF50';\n    confirmButton.style.color = 'white';\n    confirmButton.style.border = 'none';\n    confirmButton.style.borderRadius = '4px';\n    confirmButton.style.cursor = 'pointer';\n    confirmButton.style.fontWeight = 'bold';\n    // Create reject button\n    const rejectButton = document.createElement('button');\n    rejectButton.className = 'jp-llm-ext-reject-button';\n    rejectButton.textContent = 'Reject';\n    // Apply specific styling (can be moved to CSS)\n    rejectButton.style.padding = '6px 12px';\n    rejectButton.style.background = '#F44336';\n    rejectButton.style.color = 'white';\n    rejectButton.style.border = 'none';\n    rejectButton.style.borderRadius = '4px';\n    rejectButton.style.cursor = 'pointer';\n    rejectButton.style.fontWeight = 'bold';\n    // Add event listeners\n    confirmButton.addEventListener('click', () => {\n        confirmButton.disabled = true;\n        rejectButton.disabled = true;\n        confirmButton.style.opacity = '0.5';\n        rejectButton.style.opacity = '0.5';\n        callbacks.handleConfirmInterrupt();\n    });\n    rejectButton.addEventListener('click', () => {\n        confirmButton.disabled = true;\n        rejectButton.disabled = true;\n        confirmButton.style.opacity = '0.5';\n        rejectButton.style.opacity = '0.5';\n        callbacks.handleRejectInterrupt();\n    });\n    // Add buttons to container and container to message\n    buttonsContainer.appendChild(confirmButton);\n    buttonsContainer.appendChild(rejectButton);\n    container.appendChild(buttonsContainer);\n}\n/**\n * Adds overall action buttons (Copy, Add to Cell) to a bot message container.\n *\n * @param messageDiv The main div container for the bot message.\n * @param messageText The raw text content of the message.\n * @param callbacks Callbacks for actions like copy message, add to cell.\n */\nfunction addBotMessageActions(messageDiv, messageText, callbacks = {}) {\n    // Only add actions if corresponding callbacks are provided\n    if (!callbacks.copyMessageToClipboard && !callbacks.addMessageToCell) {\n        return;\n    }\n    console.log('Adding action buttons to bot message'); // Keep debug log for now\n    const actionsDiv = document.createElement('div');\n    actionsDiv.className = 'jp-llm-ext-message-actions';\n    // actionsDiv.style.display = 'flex'; // Ensure display via CSS if needed\n    // Copy Message button\n    if (callbacks.copyMessageToClipboard && callbacks.showCopyFeedback) {\n        const copyButton = document.createElement('button');\n        copyButton.className = 'jp-llm-ext-message-action-button';\n        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyButton.title = 'Copy message to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);\n        copyButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyMessageToClipboard(messageText, feedbackCb);\n        });\n        actionsDiv.appendChild(copyButton);\n    }\n    // Add to Cell button\n    if (callbacks.addMessageToCell) {\n        const addToButton = document.createElement('button');\n        addToButton.className = 'jp-llm-ext-message-action-button';\n        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addToButton.title = 'Add message to current cell';\n        addToButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.addMessageToCell(messageText);\n        });\n        actionsDiv.appendChild(addToButton);\n    }\n    // Append the actions container if it has any buttons\n    if (actionsDiv.hasChildNodes()) {\n        messageDiv.appendChild(actionsDiv);\n        console.log('Action buttons added to bot message:', actionsDiv); // Keep debug log\n    }\n}\n/**\n * Renders a reference widget as an HTMLElement suitable for inline display\n * (e.g., within the input field or a message).\n *\n * @param type - The type of reference ('code', 'cell', 'file', 'dir').\n * @param data - The data associated with the reference (CodeRefData, path string, etc.).\n * @param refId - Optional reference ID (e.g., 'ref-1') to store on the element.\n * @returns An HTMLElement representing the widget.\n */\nfunction renderReferenceWidgetInline(type, data, // string for file/dir paths\nplaceholder, // ADDED: The original placeholder text (e.g., @code[ref-1])\nrefId // Keep refId separate for map lookups if needed\n) {\n    const widget = document.createElement('span');\n    widget.classList.add('jp-llm-ext-ref-widget', `jp-llm-ext-ref-${type}`);\n    widget.contentEditable = 'false'; // Make the widget non-editable itself\n    widget.style.display = 'inline-block'; // Ensure it behaves like a block for styling/selection\n    widget.style.cursor = 'pointer'; // Change cursor to pointer to indicate clickability\n    widget.dataset.placeholder = placeholder; // ADDED: Store the placeholder\n    const displayTextSpan = document.createElement('span'); // Span for the main text\n    const previewDiv = document.createElement('div'); // Div for the preview content\n    previewDiv.className = 'jp-llm-ext-ref-preview';\n    previewDiv.style.display = 'none'; // Initially hidden\n    previewDiv.style.border = '1px solid var(--jp-border-color1)';\n    previewDiv.style.padding = '4px';\n    previewDiv.style.marginTop = '2px';\n    previewDiv.style.fontSize = '0.9em';\n    previewDiv.style.backgroundColor = 'var(--jp-layout-color0)';\n    previewDiv.style.whiteSpace = 'pre-wrap'; // Preserve line breaks\n    previewDiv.style.fontFamily = 'monospace';\n    previewDiv.style.cursor = 'text'; // Keep text cursor for preview\n    let displayText = '';\n    let baseTitle = ''; // Tooltip for the main widget text, without preview\n    let previewContent = '';\n    switch (type) {\n        case 'code':\n        case 'cell': { // Combine logic for code and cell previews\n            const refData = data;\n            const isCode = type === 'code';\n            const lines = refData.lineNumber === refData.lineEndNumber\n                ? `L${refData.lineNumber}`\n                : `L${refData.lineNumber}-${refData.lineEndNumber}`;\n            displayText = isCode\n                ? `@code (${refData.notebookName}:${lines})`\n                : `@Cell (${refData.notebookName}:Cell ${refData.cellIndex + 1})`;\n            baseTitle = isCode\n                ? `Code: ${refData.notebookName}, Cell ${refData.cellIndex + 1}, ${lines}`\n                : `Cell: ${refData.notebookName}, Index ${refData.cellIndex + 1}`;\n            if (refId)\n                widget.dataset.refId = refId;\n            widget.dataset.notebookName = refData.notebookName;\n            widget.dataset.cellIndex = String(refData.cellIndex);\n            widget.dataset.content = refData.content; // Store content\n            if (isCode) {\n                widget.dataset.startLine = String(refData.lineNumber);\n                widget.dataset.endLine = String(refData.lineEndNumber);\n            }\n            // Prepare preview content\n            if (refData.content) {\n                const contentLines = refData.content.split('\\n');\n                previewContent = contentLines.slice(0, 3).join('\\n');\n                if (contentLines.length > 3) {\n                    previewContent += '\\n...';\n                }\n            }\n            break;\n        }\n        case 'file':\n            const filePath = data;\n            const fileName = filePath.split(/[\\/\\\\]/).pop() || filePath; // Handle windows paths\n            displayText = `@file (${fileName})`;\n            baseTitle = `File: ${filePath}`; // Tooltip shows full path\n            widget.dataset.path = filePath; // Store full path\n            // No preview for files/dirs\n            widget.style.cursor = 'default'; // No expansion for file/dir\n            break;\n        case 'dir':\n            const dirPath = data;\n            const dirName = dirPath.split(/[\\/\\\\]/).pop() || dirPath || '/'; // Handle windows paths\n            displayText = `@dir (${dirName})`;\n            baseTitle = `Directory: ${dirPath}`; // Tooltip shows full path\n            widget.dataset.path = dirPath; // Store full path\n            // No preview for files/dirs\n            widget.style.cursor = 'default'; // No expansion for file/dir\n            break;\n        default:\n            displayText = '@unknown-ref';\n            baseTitle = 'Unknown Reference';\n            widget.style.cursor = 'default';\n    }\n    displayTextSpan.textContent = displayText;\n    widget.title = baseTitle; // Set base tooltip for the main part\n    widget.appendChild(displayTextSpan);\n    // Add preview div and click listener only if there's preview content\n    if (previewContent) {\n        previewDiv.textContent = previewContent;\n        widget.appendChild(previewDiv);\n        // Add click listener to the main widget span to toggle preview\n        widget.addEventListener('click', (event) => {\n            // Prevent the click from propagating to the input div listener if needed\n            event.stopPropagation();\n            const isHidden = previewDiv.style.display === 'none';\n            previewDiv.style.display = isHidden ? 'block' : 'none';\n            // Optional: Change an indicator icon here\n        });\n        // Prevent clicks *inside* the preview div from closing it\n        previewDiv.addEventListener('click', (event) => {\n            event.stopPropagation();\n        });\n    }\n    else {\n        // Ensure cursor remains default if no preview/expansion\n        widget.style.cursor = 'default';\n    }\n    return widget;\n}\n// Potential future additions:\n// - renderErrorMessage\n// - renderSystemMessage\n// - A main renderMessage function that delegates based on type? \n/**\n * Handles rendering individual messages (user, bot, system) into HTML elements.\n */\nclass MessageRenderer {\n    // private callbacks: MessageRendererCallbacks; // Removed unused member\n    // private uiManager: UIManager; // Might not be needed directly if callbacks handle UI updates\n    constructor( /* callbacks: MessageRendererCallbacks */ /* , uiManager: UIManager */) {\n        // this.callbacks = callbacks; // Removed unused assignment\n        // this.uiManager = uiManager;\n    }\n}\nexports.MessageRenderer = MessageRenderer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNoteModalElement = createNoteModalElement;\n/**\n * Creates a note modal element.\n * @param callbacks Callbacks for the modal actions.\n * @param initialTitle Optional initial title for editing.\n * @param initialContent Optional initial content for editing.\n * @returns The modal element.\n */\nfunction createNoteModalElement(callbacks, initialTitle = '', initialContent = '') {\n    // Create backdrop for the modal\n    const modalBackdrop = document.createElement('div');\n    modalBackdrop.className = 'jp-llm-ext-note-modal-backdrop';\n    // Create modal container\n    const modal = document.createElement('div');\n    modal.className = 'jp-llm-ext-note-modal';\n    // Create modal content\n    const modalContent = document.createElement('div');\n    modalContent.className = 'jp-llm-ext-note-modal-content';\n    // Create modal title\n    const modalTitle = document.createElement('h3');\n    modalTitle.className = 'jp-llm-ext-note-modal-title';\n    modalTitle.textContent = initialTitle ? 'Edit Note' : 'Add New Note';\n    modalContent.appendChild(modalTitle);\n    // Create form\n    const form = document.createElement('form');\n    form.className = 'jp-llm-ext-note-modal-form';\n    form.addEventListener('submit', (e) => {\n        e.preventDefault();\n        const titleInput = form.querySelector('.jp-llm-ext-note-modal-input');\n        const contentTextarea = form.querySelector('.jp-llm-ext-note-modal-textarea');\n        if (titleInput && contentTextarea) {\n            callbacks.handleSave(titleInput.value, contentTextarea.value);\n        }\n    });\n    // Create title input\n    const titleLabel = document.createElement('label');\n    titleLabel.className = 'jp-llm-ext-note-modal-label';\n    titleLabel.textContent = 'Title';\n    titleLabel.htmlFor = 'note-title-input';\n    const titleInput = document.createElement('input');\n    titleInput.className = 'jp-llm-ext-note-modal-input';\n    titleInput.type = 'text';\n    titleInput.id = 'note-title-input';\n    titleInput.placeholder = 'Enter note title';\n    titleInput.value = initialTitle;\n    titleInput.required = true;\n    // Create content textarea\n    const contentLabel = document.createElement('label');\n    contentLabel.className = 'jp-llm-ext-note-modal-label';\n    contentLabel.textContent = 'Content (Markdown supported)';\n    contentLabel.htmlFor = 'note-content-textarea';\n    const contentTextarea = document.createElement('textarea');\n    contentTextarea.className = 'jp-llm-ext-note-modal-textarea';\n    contentTextarea.id = 'note-content-textarea';\n    contentTextarea.placeholder = 'Enter note content (supports Markdown)';\n    contentTextarea.value = initialContent;\n    contentTextarea.required = true;\n    contentTextarea.rows = 10;\n    // Create buttons\n    const buttonsContainer = document.createElement('div');\n    buttonsContainer.className = 'jp-llm-ext-note-modal-buttons';\n    const cancelButton = document.createElement('button');\n    cancelButton.className = 'jp-Button jp-llm-ext-note-modal-cancel';\n    cancelButton.textContent = 'Cancel';\n    cancelButton.type = 'button';\n    cancelButton.addEventListener('click', () => {\n        callbacks.handleCancel();\n    });\n    const saveButton = document.createElement('button');\n    saveButton.className = 'jp-Button jp-llm-ext-note-modal-save';\n    saveButton.textContent = 'Save';\n    saveButton.type = 'submit';\n    // Add elements to form\n    form.appendChild(titleLabel);\n    form.appendChild(titleInput);\n    form.appendChild(contentLabel);\n    form.appendChild(contentTextarea);\n    buttonsContainer.appendChild(cancelButton);\n    buttonsContainer.appendChild(saveButton);\n    form.appendChild(buttonsContainer);\n    modalContent.appendChild(form);\n    modal.appendChild(modalContent);\n    modalBackdrop.appendChild(modal);\n    // Auto-focus the title input when the modal is shown\n    setTimeout(() => {\n        titleInput.focus();\n    }, 0);\n    return modalBackdrop;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsModal = void 0;\nexports.createSettingsModalElement = createSettingsModalElement;\n/**\n * Creates the HTML element for the settings modal.\n * @param callbacks Callbacks for save and cancel actions.\n * @returns The main modal HTMLElement.\n */\nfunction createSettingsModalElement(callbacks) {\n    const modal = document.createElement('div');\n    modal.className = 'jp-llm-ext-settings-modal';\n    modal.style.display = 'none'; // Initially hidden\n    const content = document.createElement('div');\n    content.className = 'jp-llm-ext-settings-content';\n    const title = document.createElement('h2');\n    title.className = 'jp-llm-ext-settings-title';\n    title.textContent = 'Settings';\n    content.appendChild(title);\n    const form = document.createElement('form');\n    form.className = 'jp-llm-ext-settings-form';\n    // Provider selection\n    const providerLabel = document.createElement('label');\n    providerLabel.className = 'jp-llm-ext-settings-label';\n    providerLabel.textContent = 'API Provider:';\n    form.appendChild(providerLabel);\n    const providerSelect = document.createElement('select');\n    providerSelect.className = 'jp-llm-ext-settings-select';\n    providerSelect.id = 'settings-provider'; // Keep ID for retrieval\n    ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {\n        const option = document.createElement('option');\n        option.value = opt;\n        option.textContent = opt;\n        providerSelect.appendChild(option);\n    });\n    form.appendChild(providerSelect);\n    // API Key input\n    const apiKeyLabel = document.createElement('label');\n    apiKeyLabel.className = 'jp-llm-ext-settings-label';\n    apiKeyLabel.textContent = 'API Key:';\n    form.appendChild(apiKeyLabel);\n    const apiKeyInput = document.createElement('input');\n    apiKeyInput.className = 'jp-llm-ext-settings-input';\n    apiKeyInput.type = 'password';\n    apiKeyInput.id = 'settings-api-key'; // Keep ID for retrieval\n    form.appendChild(apiKeyInput);\n    // API URL input\n    const apiUrlLabel = document.createElement('label');\n    apiUrlLabel.className = 'jp-llm-ext-settings-label';\n    apiUrlLabel.textContent = 'API URL (optional):';\n    form.appendChild(apiUrlLabel);\n    const apiUrlInput = document.createElement('input');\n    apiUrlInput.className = 'jp-llm-ext-settings-input';\n    apiUrlInput.type = 'text';\n    apiUrlInput.id = 'settings-api-url'; // Keep ID for retrieval\n    form.appendChild(apiUrlInput);\n    // Rules input\n    const rulesLabel = document.createElement('label');\n    rulesLabel.className = 'jp-llm-ext-settings-label';\n    rulesLabel.textContent = 'Custom Rules (optional):';\n    form.appendChild(rulesLabel);\n    const rulesInput = document.createElement('textarea');\n    rulesInput.className = 'jp-llm-ext-settings-textarea';\n    rulesInput.id = 'settings-rules'; // Keep ID for retrieval\n    form.appendChild(rulesInput);\n    // Buttons container\n    const btnContainer = document.createElement('div');\n    btnContainer.className = 'jp-llm-ext-settings-buttons';\n    const saveBtn = document.createElement('button');\n    saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';\n    saveBtn.textContent = 'Save';\n    saveBtn.type = 'button'; // Prevent default form submission\n    saveBtn.addEventListener('click', (event) => {\n        event.preventDefault();\n        // The callback implementation will handle reading values and saving\n        const settings = {\n            apiKey: apiKeyInput.value,\n            apiUrl: apiUrlInput.value,\n            rules: rulesInput.value,\n            provider: providerSelect.value\n        };\n        callbacks.handleSave(settings);\n    });\n    const cancelBtn = document.createElement('button');\n    cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';\n    cancelBtn.textContent = 'Cancel';\n    cancelBtn.type = 'button'; // Prevent default form submission\n    cancelBtn.addEventListener('click', (event) => {\n        event.preventDefault();\n        callbacks.handleCancel();\n    });\n    btnContainer.appendChild(saveBtn);\n    btnContainer.appendChild(cancelBtn);\n    form.appendChild(btnContainer);\n    content.appendChild(form);\n    modal.appendChild(content);\n    return modal;\n}\n/**\n * Creates and manages the settings modal dialog.\n */\nclass SettingsModal {\n    // private modalElement: HTMLDivElement; // Commented out - unused\n    // private settings: AppSettings; // Commented out - unused\n    constructor(callbacks) {\n        // this.modalElement = createSettingsModalElement(callbacks); // Commented out - unused assignment\n        // this.settings = { // Commented out - unused initialization\n        //     provider: '', \n        //     apiKey: '', \n        //     apiUrl: '', \n        //     rules: '' \n        // }; \n    }\n}\nexports.SettingsModal = SettingsModal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UIManager = void 0;\n/**\n * Manages UI elements and transitions for the chat interface.\n * This acts as a central point for UI manipulations, simplifying dependencies for handlers.\n */\nclass UIManager {\n    constructor(popupMenuManager, callbacks, layoutElements) {\n        this.notificationTimeout = null; // Timeout for the shortcut indicator\n        // Internal UI state\n        this.isInputExpanded = false;\n        this.isMarkdownMode = false;\n        this.popupMenuManager = popupMenuManager;\n        this.callbacks = callbacks;\n        this.layoutElements = layoutElements; // Store the layout elements passed in\n        // Assign class properties directly from the passed layoutElements\n        this.inputField = layoutElements.inputField; // Use provided input field\n        this.messageContainer = layoutElements.messageContainer;\n        this.historyContainer = layoutElements.historyContainer;\n        this.titleInput = layoutElements.titleInput;\n        this.bottomBarContainer = layoutElements.bottomBarContainer;\n        this.notesContainer = layoutElements.notesContainer;\n        // Initialize and append the keyboard shortcut indicator\n        this.keyboardShortcutIndicator = document.createElement('div');\n        this.keyboardShortcutIndicator.className = 'jp-llm-ext-shortcut-indicator';\n        this.keyboardShortcutIndicator.style.display = 'none'; // Hidden by default\n        // Append the indicator to the main layout or another appropriate place\n        // Ensure the necessary element (e.g., bottomBarContainer) exists before appending\n        if (this.bottomBarContainer) { // Check if bottomBarContainer exists from layoutElements\n            // Prepend within the main content wrapper, before other elements\n            // Or append to bottom bar, depending on desired position\n            // Appending after bottomBarContainer seems reasonable\n            this.bottomBarContainer.insertAdjacentElement('afterend', this.keyboardShortcutIndicator);\n        }\n        else {\n            // If bottomBarContainer is not available, maybe append to mainElement? \n            // Or log an error if it's essential.\n            console.error('UIManager: bottomBarContainer element not found during indicator initialization.');\n        }\n    }\n    /**\n     * Returns the core layout elements.\n     */\n    getUIElements() {\n        return this.layoutElements;\n    }\n    /**\n     * Creates the main layout structure for the sidebar.\n     * @returns References to key DOM elements.\n     */\n    createLayout() {\n        // Create the main container\n        const mainContent = document.createElement('div');\n        mainContent.className = 'jp-llm-ext-content-wrapper';\n        // --- Title Container ---\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'jp-llm-ext-title-container';\n        this.titleInput = document.createElement('input');\n        this.titleInput.className = 'chat-title-input';\n        this.titleInput.type = 'text';\n        this.titleInput.placeholder = 'Chat title';\n        this.titleInput.value = 'New Chat'; // Default value, widget might update later\n        this.titleInput.addEventListener('change', this.callbacks.handleUpdateTitle);\n        titleContainer.appendChild(this.titleInput);\n        // --- Message & History Containers ---\n        this.messageContainer = document.createElement('div');\n        this.messageContainer.className = 'jp-llm-ext-message-container';\n        this.historyContainer = document.createElement('div');\n        this.historyContainer.className = 'jp-llm-ext-history-container';\n        this.historyContainer.style.display = 'none'; // Initially hidden\n        // --- Bottom Bar ---\n        this.bottomBarContainer = document.createElement('div');\n        this.bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';\n        // Controls Row (Markdown Toggle, Action Buttons)\n        const topRow = document.createElement('div');\n        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';\n        const controlsContainer = this.createControlsContainer(); // Creates markdown toggle, @, expand, settings\n        topRow.appendChild(controlsContainer);\n        // Input Row\n        const middleRow = document.createElement('div');\n        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';\n        this.inputField = document.createElement('div');\n        this.inputField.setAttribute('contenteditable', 'true');\n        this.inputField.setAttribute('role', 'textbox');\n        this.inputField.setAttribute('aria-multiline', 'true');\n        this.inputField.setAttribute('data-placeholder', 'Ask me anything...');\n        this.inputField.className = 'jp-llm-ext-input-field';\n        // --- Input Event Listener for @ detection ---\n        this.inputField.addEventListener('input', (event) => {\n            this.handleInputForReference();\n        });\n        // --- End Input Event Listener ---\n        this.inputField.addEventListener('keydown', (event) => {\n            console.log(`UI_MANAGER KeyDown: Key='${event.key}', Shift='${event.shiftKey}', Code='${event.code}'`);\n            const selection = window.getSelection();\n            // --- Backspace handling for widgets ---\n            if (event.key === 'Backspace' && selection && selection.isCollapsed) {\n                const range = selection.getRangeAt(0);\n                const nodeBefore = range.startContainer.childNodes[range.startOffset - 1] || range.startContainer.previousSibling;\n                // Check nodeBefore more carefully\n                let potentialWidget = null;\n                if (range.startOffset > 0 && range.startContainer.childNodes.length >= range.startOffset) {\n                    potentialWidget = range.startContainer.childNodes[range.startOffset - 1];\n                }\n                else if (range.startOffset === 0 && range.startContainer.previousSibling) {\n                    potentialWidget = range.startContainer.previousSibling;\n                }\n                else if (range.startContainer !== this.inputField && range.startContainer.parentNode === this.inputField && range.startOffset === 0) {\n                    // Cursor might be at the start of a text node following a widget\n                    potentialWidget = range.startContainer.previousSibling;\n                }\n                if (potentialWidget &&\n                    potentialWidget.nodeType === Node.ELEMENT_NODE &&\n                    potentialWidget.classList.contains('jp-llm-ext-ref-widget')) {\n                    event.preventDefault(); // Stop default backspace\n                    potentialWidget.remove(); // Remove the entire widget node\n                    // Manually trigger input event for consistency?\n                    this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n                    return; // Stop further processing for this keydown\n                }\n            }\n            // --- End Backspace handling ---\n            // --- @ Key Direct Handling ---\n            // REMOVED: This logic is now centralized in shortcut-handler.ts\n            // --- End @ Key Direct Handling ---\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault(); // Prevent default newline insertion\n                const message = this.getSerializedInput();\n                if (message.trim()) {\n                    console.log(`[UIManager] Sending message with markdown mode: ${this.isMarkdownMode}`);\n                    this.callbacks.handleSendMessage(message, this.isMarkdownMode);\n                    this.clearInputField();\n                }\n            }\n            // --- New: Handle Tab/Escape for popup interaction ---\n            else if (this.popupMenuManager.isPopupMenuVisible()) {\n                if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'Enter') {\n                    // Let the PopupMenuManager's document keydown handler manage these\n                    // We just need to prevent the default input field behavior\n                    if (event.key !== 'Enter') { // Allow Enter to potentially work if menu doesn't handle it\n                        event.preventDefault();\n                        // We don't stop propagation here; let the document handler in PopupMenuManager receive it.\n                    }\n                }\n            }\n            // --- End New ---\n        });\n        // --- Copy/Paste Event Listeners ---\n        this.inputField.addEventListener('copy', (event) => {\n            this.handleCopy(event);\n        });\n        this.inputField.addEventListener('paste', (event) => {\n            this.handlePaste(event);\n        });\n        // --- End Copy/Paste ---\n        middleRow.appendChild(this.inputField);\n        // Buttons Row (Send, New Chat, History)\n        const bottomRow = document.createElement('div');\n        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';\n        const sendButton = this.createButton('Send', 'Send message');\n        sendButton.classList.add('jp-llm-ext-send-button'); // Specific class for send\n        sendButton.addEventListener('click', () => {\n            const message = this.getSerializedInput();\n            if (message.trim()) {\n                console.log(`[UIManager] Sending message from button click with markdown mode: ${this.isMarkdownMode}`);\n                this.callbacks.handleSendMessage(message, this.isMarkdownMode);\n                this.clearInputField();\n            }\n        });\n        const newChatButton = this.createButton('+ New Chat', 'Start a new chat');\n        newChatButton.addEventListener('click', this.callbacks.handleNewChat);\n        const historyButton = this.createButton('History', 'View chat history');\n        historyButton.addEventListener('click', this.callbacks.handleToggleHistory);\n        bottomRow.appendChild(sendButton);\n        bottomRow.appendChild(newChatButton);\n        bottomRow.appendChild(historyButton);\n        // Assemble Bottom Bar\n        this.bottomBarContainer.appendChild(topRow);\n        this.bottomBarContainer.appendChild(middleRow);\n        this.bottomBarContainer.appendChild(bottomRow);\n        // --- Assemble Main Content ---\n        mainContent.appendChild(titleContainer);\n        mainContent.appendChild(this.messageContainer);\n        mainContent.appendChild(this.historyContainer);\n        mainContent.appendChild(this.bottomBarContainer);\n        // Return references to key elements\n        return {\n            mainLayout: mainContent,\n            messageContainer: this.messageContainer,\n            inputField: this.inputField,\n            titleInput: this.titleInput,\n            historyContainer: this.historyContainer,\n            bottomBarContainer: this.bottomBarContainer,\n            notesContainer: this.notesContainer,\n        };\n    }\n    /**\n     * Creates the controls container with toggles and action buttons.\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'jp-llm-ext-controls-container';\n        // --- Markdown Toggle ---\n        const toggleContainer = document.createElement('div');\n        toggleContainer.className = 'jp-llm-ext-toggle-container';\n        this.markdownToggle = document.createElement('input');\n        this.markdownToggle.type = 'checkbox';\n        this.markdownToggle.id = 'markdown-toggle'; // Ensure unique ID or handle differently\n        this.markdownToggle.addEventListener('change', (e) => {\n            const target = e.target;\n            this.isMarkdownMode = target.checked;\n            console.log(`[UIManager] Markdown mode changed to: ${this.isMarkdownMode}`);\n            const placeholderText = this.isMarkdownMode\n                ? 'Write markdown here...\\\\n\\\\n# Example heading\\\\n- List item\\\\n\\\\n```code block```'\n                : 'Ask me anything...';\n            this.inputField.setAttribute('data-placeholder', placeholderText);\n            this.inputField.blur();\n            this.inputField.focus();\n        });\n        const toggleLabel = document.createElement('label');\n        toggleLabel.htmlFor = 'markdown-toggle';\n        toggleLabel.textContent = 'Markdown mode';\n        toggleContainer.appendChild(this.markdownToggle);\n        toggleContainer.appendChild(toggleLabel);\n        // --- Action Buttons (@, Expand, Settings) ---\n        const actionButtonsContainer = document.createElement('div');\n        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';\n        // '@' Button\n        const atButton = this.createButton('@', 'Browse cells, code, files, and more');\n        atButton.addEventListener('click', (event) => {\n            this.callbacks.handleShowPopupMenu(event, event.currentTarget);\n        });\n        // Expand Button (store reference)\n        this.expandButton = this.createButton('⤢', 'Expand input');\n        this.expandButton.addEventListener('click', () => this.toggleInputExpansion());\n        // Settings Button\n        const settingsButton = this.createButton('⚙️', 'Settings');\n        settingsButton.addEventListener('click', this.callbacks.handleShowSettings);\n        // Add buttons to container\n        actionButtonsContainer.appendChild(atButton);\n        actionButtonsContainer.appendChild(this.expandButton);\n        actionButtonsContainer.appendChild(settingsButton);\n        // Assemble Controls Container\n        controlsContainer.appendChild(toggleContainer);\n        controlsContainer.appendChild(actionButtonsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Toggles the expansion state of the input field.\n     */\n    toggleInputExpansion() {\n        if (!this.inputField || !this.expandButton)\n            return; // Ensure elements exist\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.inputField.style.height = '200px'; // Keep for now, consider CSS classes\n            this.inputField.style.resize = 'vertical'; // Works on divs too (if overflow visible/auto)\n            this.expandButton.textContent = '⤡';\n            this.expandButton.title = 'Collapse input';\n        }\n        else {\n            this.inputField.style.height = ''; // Reset height\n            this.inputField.style.resize = 'none';\n            this.expandButton.textContent = '⤢';\n            this.expandButton.title = 'Expand input';\n        }\n        // Future: Notify widget/handler if needed: this.callbacks.handleToggleExpansion(this.isInputExpanded);\n    }\n    /**\n     * Helper function to create a styled button.\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        // Apply base JupyterLab button class and our specific class\n        button.className = 'jp-Button jp-llm-ext-action-button';\n        return button;\n    }\n    /**\n     * Appends a new chat message element to the message container and scrolls down.\n     * @param element The message element (user or bot) to add.\n     */\n    addChatMessageElement(element) {\n        if (this.messageContainer) {\n            this.messageContainer.appendChild(element);\n            this.scrollToBottom(); // Scroll after adding the new element\n        }\n        else {\n            console.error('Message container not initialized in UIManager.');\n        }\n    }\n    /**\n     * Scrolls the message container to the bottom.\n     */\n    scrollToBottom() {\n        if (this.messageContainer) {\n            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        }\n        else {\n            console.error('Message container not initialized in UIManager.');\n        }\n    }\n    /**\n     * Switches the view to show the notes.\n     */\n    showNotesView() {\n        this.layoutElements.messageContainer.style.display = 'none';\n        this.layoutElements.historyContainer.style.display = 'none';\n        this.layoutElements.notesContainer.style.display = 'block';\n        this.layoutElements.bottomBarContainer.style.display = 'none';\n    }\n    /**\n     * Switches the view to show the chat history.\n     */\n    showHistoryView() {\n        this.layoutElements.messageContainer.style.display = 'none';\n        this.layoutElements.historyContainer.style.display = 'block';\n        this.layoutElements.notesContainer.style.display = 'none';\n        this.layoutElements.bottomBarContainer.style.display = 'none';\n        // Optionally update header/title elements if needed\n    }\n    /**\n     * Switches the view to show the main chat interface.\n     */\n    showChatView() {\n        this.layoutElements.historyContainer.style.display = 'none';\n        this.layoutElements.notesContainer.style.display = 'none';\n        this.layoutElements.messageContainer.style.display = 'block';\n        this.layoutElements.bottomBarContainer.style.display = 'flex'; // Assuming flex display\n        this.scrollToBottom(); // Scroll down when showing chat\n    }\n    /**\n     * Clears all messages from the message container.\n     */\n    clearMessageContainer() {\n        this.layoutElements.messageContainer.innerHTML = '';\n    }\n    /**\n     * Updates the value of the title input field.\n     */\n    updateTitleInput(title) {\n        if (this.layoutElements.titleInput) {\n            this.layoutElements.titleInput.value = title;\n        }\n    }\n    /**\n     * Creates and returns a container structure for a bot message,\n     * including elements for streaming text and final rendered content.\n     * This helps manage the transition from streaming to final message display.\n     */\n    createBotMessageContainer() {\n        const botMessageDiv = document.createElement('div');\n        botMessageDiv.className = 'jp-llm-ext-bot-message'; // Base class\n        // Div for streaming content (initially visible)\n        const streamingDiv = document.createElement('div');\n        streamingDiv.className = 'jp-llm-ext-streaming-content';\n        streamingDiv.style.display = 'block'; // Show streaming initially\n        // Div for final rendered content (initially hidden)\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'jp-llm-ext-rendered-content';\n        contentDiv.style.display = 'none'; // Hide final content initially\n        botMessageDiv.appendChild(streamingDiv);\n        botMessageDiv.appendChild(contentDiv);\n        // Add the whole container to the message list *before* streaming starts\n        this.addChatMessageElement(botMessageDiv);\n        return { botMessageDiv, streamingDiv, contentDiv };\n    }\n    /**\n     * Displays a temporary notification message.\n     * TODO: Implement a more robust notification system (e.g., toast).\n     */\n    showNotification(message, type, duration = 3000) {\n        console.log(`Notification (${type}): ${message}`);\n        // Basic temporary implementation using the existing indicator element\n        const indicator = this.layoutElements.mainElement.querySelector('.jp-llm-ext-keyboard-shortcut-indicator');\n        if (indicator) {\n            if (this.notificationTimeout) {\n                clearTimeout(this.notificationTimeout); // Clear previous timeout\n            }\n            indicator.textContent = message;\n            indicator.className = `jp-llm-ext-keyboard-shortcut-indicator visible jp-llm-ext-notification-${type}`; // Add type class\n            this.notificationTimeout = window.setTimeout(() => {\n                indicator.classList.remove('visible');\n                this.notificationTimeout = null;\n            }, duration);\n        }\n        else {\n            console.warn('Notification indicator element not found for UIManager.');\n        }\n    }\n    /**\n     * Shows a visual indicator for keyboard shortcuts.\n     * @param text The text to display in the indicator.\n     */\n    showIndicator(text) {\n        if (!this.keyboardShortcutIndicator)\n            return; // Guard\n        this.keyboardShortcutIndicator.textContent = text;\n        this.keyboardShortcutIndicator.classList.add('visible');\n        // Clear any existing timeout to prevent multiple timeouts running\n        if (this.notificationTimeout) {\n            clearTimeout(this.notificationTimeout);\n        }\n        // Set new timeout to hide the indicator\n        this.notificationTimeout = window.setTimeout(() => {\n            if (this.keyboardShortcutIndicator) { // Check if element still exists\n                this.keyboardShortcutIndicator.classList.remove('visible');\n            }\n            this.notificationTimeout = null;\n        }, 1000); // Hide after 1 second\n    }\n    /**\n     * Clears the indicator immediately and cancels any pending hide timeout.\n     * Useful if the widget is hidden while the indicator is shown.\n     */\n    clearIndicator() {\n        if (!this.keyboardShortcutIndicator)\n            return;\n        this.keyboardShortcutIndicator.classList.remove('visible');\n        this.keyboardShortcutIndicator.textContent = '';\n        if (this.notificationTimeout) {\n            clearTimeout(this.notificationTimeout);\n            this.notificationTimeout = null;\n        }\n    }\n    /**\n     * Checks the input field content and cursor position to determine if\n     * the reference suggestion popup should be shown or hidden.\n     * Triggered on 'input' events.\n     */\n    handleInputForReference() {\n        var _a, _b;\n        const selection = window.getSelection();\n        if (!selection || !selection.rangeCount || !selection.isCollapsed) {\n            // Need a collapsed selection (cursor) inside the input field\n            this.popupMenuManager.hidePopupMenu();\n            return;\n        }\n        const range = selection.getRangeAt(0);\n        const container = range.startContainer;\n        const offset = range.startOffset;\n        // Ensure the cursor is within the input field itself\n        if (!this.inputField.contains(container)) {\n            this.popupMenuManager.hidePopupMenu();\n            return;\n        }\n        // Combine text content from preceding siblings if cursor is at the start of a text node\n        let textBeforeCursor = '';\n        let currentContainer = container;\n        let currentOffset = offset;\n        while (currentContainer) {\n            if (currentContainer.nodeType === Node.TEXT_NODE) {\n                textBeforeCursor = ((_a = currentContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, currentOffset)) + textBeforeCursor;\n            }\n            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.classList.contains('jp-llm-ext-ref-widget')) {\n                // If we encounter a widget before the cursor, we can't be right after '@'\n                textBeforeCursor = '[widget]' + textBeforeCursor; // Add placeholder to break '@' sequence\n            }\n            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.tagName === 'BR') {\n                textBeforeCursor = '\\n' + textBeforeCursor; // Treat BR as newline\n            }\n            // Move to the previous sibling or parent's previous sibling\n            if (currentContainer.previousSibling) {\n                currentContainer = currentContainer.previousSibling;\n                // If moving to a new node, take its full content\n                currentOffset = (currentContainer.textContent || '').length;\n            }\n            else {\n                // Move up to parent, continue search from before the parent\n                currentContainer = currentContainer.parentNode;\n                if (currentContainer === this.inputField || !currentContainer) {\n                    break; // Stop if we reached the input field or top\n                }\n                currentOffset = Array.prototype.indexOf.call(((_b = currentContainer.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes) || [], currentContainer);\n            }\n        }\n        console.log(`UI_MANAGER handleInput: Text before cursor: \"${textBeforeCursor}\"`);\n        // --- Check for trigger conditions --- \n        const endsWithAt = textBeforeCursor.endsWith('@');\n        const endsWithAtSpace = textBeforeCursor.endsWith('@ ');\n        if (endsWithAt || endsWithAtSpace) {\n            if (this.popupMenuManager.isPopupMenuVisible()) {\n                // TODO: If visible, maybe just update the query in the popup?\n                console.log('UI_MANAGER handleInput: Popup already visible, skipping show.');\n            }\n            else {\n                // Find the start of the query (after '@' or '@ ')\n                const atIndex = textBeforeCursor.lastIndexOf('@');\n                let queryStartIndex = atIndex + 1;\n                if (endsWithAtSpace) {\n                    queryStartIndex = atIndex + 2;\n                }\n                const query = textBeforeCursor.substring(queryStartIndex);\n                // --- Insert temporary span to get reliable coordinates --- \n                const tempAnchorId = 'jp-llm-temp-popup-anchor';\n                let tempSpan = document.getElementById(tempAnchorId);\n                if (tempSpan)\n                    tempSpan.remove(); // Clean up previous if any\n                tempSpan = document.createElement('span');\n                tempSpan.id = tempAnchorId;\n                // Style to be invisible and take no space\n                tempSpan.style.visibility = 'hidden';\n                tempSpan.style.width = '0';\n                tempSpan.style.height = '0';\n                tempSpan.style.overflow = 'hidden';\n                tempSpan.textContent = '\\u200B'; // Zero-width space might help rendering\n                // Insert the span at the current cursor position\n                range.insertNode(tempSpan);\n                const spanRect = tempSpan.getBoundingClientRect();\n                tempSpan.remove(); // Remove immediately after getting coords\n                // --- End temporary span logic ---\n                if (spanRect.top === 0 && spanRect.left === 0) {\n                    console.error(\"UI_MANAGER handleInput: Failed to get valid coordinates from temp anchor span.\");\n                    // Fallback or alternative positioning might be needed here\n                    // Maybe position relative to input field bottom-left?\n                    this.popupMenuManager.hidePopupMenu(); // Don't show if coords are bad\n                }\n                else {\n                    console.log(`UI_MANAGER handleInput: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);\n                    // Show the TOP LEVEL suggestions using the reliable coordinates\n                    // Pass the coordinates directly to showPopupMenu\n                    this.popupMenuManager.showPopupMenu({ x: spanRect.left, y: spanRect.top });\n                }\n            }\n        }\n        else {\n            // If text doesn't end with @ or @-space, hide the popup\n            // Only hide if it was previously showing the 'top' or 'references' menu triggered by '@'\n            // Avoid hiding menus triggered by the button click unnecessarily\n            if (this.popupMenuManager.isPopupMenuVisible()) { // && (this.popupMenuManager.getCurrentMenuLevel() === 'references' || /* Need way to know if triggered by @ */ )) {\n                console.log('UI_MANAGER handleInput: Hiding popup, trigger condition no longer met.');\n                this.popupMenuManager.hidePopupMenu();\n            }\n        }\n        // TODO: Update popup query if it's already visible and the text after @ changes\n        // (Need more robust logic here, considering backspace, etc.)\n    }\n    /**\n     * Serializes the content of the input field, converting known widgets\n     * back to their reference strings (e.g., @file:path/to/file.txt).\n     *\n     * NOTE: This currently uses a simple text serialization. For full fidelity\n     * preserving structure (like multiple paragraphs), a more complex approach\n     * (e.g., HTML processing or a dedicated editor model) would be needed.\n     *\n     * @returns {string} The serialized plain text content of the input field.\n     */\n    getSerializedInput() {\n        let serialized = '';\n        const nodes = this.inputField.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (node.nodeType === Node.TEXT_NODE) {\n                serialized += node.textContent;\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {\n                    // Append the reference text stored in the data attribute\n                    serialized += element.dataset.referenceText;\n                }\n                else if (element.tagName === 'BR') {\n                    // Convert BR tags back to newlines\n                    serialized += '\\n';\n                }\n                else if (element.tagName === 'DIV') {\n                    // Handle DIV elements (might be inserted by browser on paste/enter)\n                    // Add newline before if needed, then serialize children recursively?\n                    if (i > 0) { // Add newline only if not the first element\n                        serialized += '\\n';\n                    }\n                    serialized += this.serializeNodeChildren(element); // Recursively serialize children\n                }\n                else {\n                    // Include text content of other unexpected elements, but log a warning\n                    console.warn('UIManager getSerializedInput: Encountered unexpected element:', element.tagName);\n                    serialized += element.textContent;\n                }\n            } // Ignore other node types (comments, etc.)\n        }\n        return serialized.trim(); // Trim leading/trailing whitespace\n    }\n    // Helper to serialize children of a node (e.g., for DIVs)\n    serializeNodeChildren(parentNode) {\n        let content = '';\n        const nodes = parentNode.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (node.nodeType === Node.TEXT_NODE) {\n                content += node.textContent;\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {\n                    content += element.dataset.referenceText;\n                }\n                else if (element.tagName === 'BR') {\n                    content += '\\n';\n                }\n                else {\n                    // Recursively handle nested elements if necessary, or just get text content\n                    content += this.serializeNodeChildren(element);\n                }\n            }\n        }\n        return content;\n    }\n    clearInputField() {\n        this.inputField.innerHTML = ''; // Clear all content\n        // Reset expansion state if needed\n        if (this.isInputExpanded) {\n            this.toggleInputExpansion();\n        }\n        // Ensure placeholder reappears if using CSS for it\n        this.inputField.dispatchEvent(new Event('input')); // Trigger event to update UI state if necessary\n    }\n    /**\n     * Handles the 'copy' event to put serialized plain text onto the clipboard.\n     */\n    handleCopy(event) {\n        const selection = window.getSelection();\n        if (!selection || selection.isCollapsed || !event.clipboardData) {\n            return; // Nothing selected or no clipboard data object\n        }\n        const range = selection.getRangeAt(0);\n        // Ensure the selection is within our input field\n        if (!this.inputField.contains(range.commonAncestorContainer)) {\n            return;\n        }\n        const selectedText = this.serializeRangeContent(range);\n        event.preventDefault(); // Prevent default copy behavior\n        event.clipboardData.setData('text/plain', selectedText);\n        console.log('UIManager handleCopy: Copied serialized text:', selectedText);\n    }\n    /**\n     * Handles the 'paste' event to insert plain text content.\n     */\n    handlePaste(event) {\n        var _a;\n        if (!event.clipboardData) {\n            return;\n        }\n        const text = event.clipboardData.getData('text/plain');\n        if (text) {\n            event.preventDefault(); // Prevent default paste behavior\n            // Insert the plain text at the current cursor position\n            const selection = window.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                const range = selection.getRangeAt(0);\n                range.deleteContents(); // Delete selected content if any\n                const textNode = document.createTextNode(text);\n                range.insertNode(textNode);\n                // Move cursor after inserted text\n                range.setStartAfter(textNode);\n                range.setEndAfter(textNode);\n                selection.removeAllRanges();\n                selection.addRange(range);\n                // Ensure scroll into view and trigger input event for potential updates\n                this.inputField.focus();\n                (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'nearest' });\n                this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n            }\n            console.log('UIManager handlePaste: Pasted text:', text);\n        }\n    }\n    // --- Methods for updating UI elements will be added later ---\n    // e.g., updateMessageContainer(html: string), showHistoryView(), showChatView()\n    // --- Potentially add methods to get element references if needed externally ---\n    // public getInputField(): HTMLTextAreaElement { return this.inputField; }\n    // etc.\n    // Helper to serialize a range (needed for copy)\n    serializeRangeContent(range) {\n        const fragment = range.cloneContents();\n        let tempDiv = document.createElement('div');\n        tempDiv.appendChild(fragment);\n        // Now, serialize tempDiv's content like we do for getSerializedInput\n        let serialized = '';\n        const nodes = tempDiv.childNodes;\n        const serializeNode = (node) => {\n            if (node.nodeType === Node.TEXT_NODE) {\n                serialized += node.textContent;\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {\n                    serialized += element.dataset.referenceText;\n                }\n                else if (element.tagName === 'BR') {\n                    serialized += '\\n';\n                }\n                else { // For other elements (like DIVs potentially in fragment), serialize children\n                    const childNodes = element.childNodes;\n                    for (let j = 0; j < childNodes.length; j++) {\n                        serializeNode(childNodes[j]);\n                    }\n                }\n            }\n        };\n        for (let i = 0; i < nodes.length; i++) {\n            serializeNode(nodes[i]);\n        }\n        return serialized;\n    }\n}\nexports.UIManager = UIManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.copyToClipboard = copyToClipboard;\nexports.copyMessageToClipboard = copyMessageToClipboard;\nexports.copyImageToClipboard = copyImageToClipboard;\n/**\n * Helper function to copy text to clipboard.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyToClipboard(text, feedbackCallback) {\n    try {\n        navigator.clipboard.writeText(text).then(() => {\n            console.log('Content copied to clipboard');\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(); // Call optional feedback callback\n        }).catch(err => {\n            console.error('Failed to copy text: ', err);\n        });\n    }\n    catch (error) {\n        console.error('Error copying text to clipboard:', error);\n    }\n}\n/**\n * Copies message content to clipboard.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyMessageToClipboard(text, feedbackCallback) {\n    try {\n        navigator.clipboard.writeText(text).then(() => {\n            console.log('Message content copied to clipboard');\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success\n        }).catch(err => {\n            console.error('Failed to copy message text: ', err);\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n        });\n    }\n    catch (error) {\n        console.error('Error copying message to clipboard:', error);\n        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n    }\n}\n/**\n * Copies an image to the clipboard from a given URL.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyImageToClipboard(imageUrl, feedbackCallback) {\n    try {\n        fetch(imageUrl)\n            .then(response => {\n            if (!response.ok) {\n                throw new Error(`Failed to fetch image: ${response.statusText}`);\n            }\n            return response.blob();\n        })\n            .then(blob => {\n            // Create a ClipboardItem with the image blob\n            // Note: ClipboardItem might not be defined in all environments\n            // You might need to add `\"dom.iterable\"` to tsconfig lib or handle appropriately.\n            const item = new ClipboardItem({ [blob.type]: blob });\n            navigator.clipboard.write([item]).then(() => {\n                console.log('Image copied to clipboard');\n                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success\n            })\n                .catch(err => {\n                console.error('Failed to copy image to clipboard: ', err);\n                alert('Failed to copy image: ' + err.message); // Keep alert for critical user feedback\n                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n            });\n        })\n            .catch(err => {\n            console.error('Failed to fetch or process image: ', err);\n            alert('Failed to fetch image: ' + err.message); // Keep alert for critical user feedback\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n        });\n    }\n    catch (error) {\n        console.error('Error preparing image copy:', error);\n        alert('Error copying image: ' + error); // Keep alert for critical user feedback\n        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCaretPosition = getCaretPosition;\nexports.setCaretPosition = setCaretPosition;\n/**\n * Gets the caret position within a contenteditable element.\n * Returns the linear offset from the start of the element's text content.\n */\nfunction getCaretPosition(element) {\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0 || !element.contains(selection.anchorNode)) {\n        // Check if selection is within the element\n        return 0;\n    }\n    const range = selection.getRangeAt(0);\n    // Create a range that spans from the beginning of the element to the caret\n    const preCaretRange = range.cloneRange();\n    preCaretRange.selectNodeContents(element);\n    preCaretRange.setEnd(range.startContainer, range.startOffset);\n    // The length of the text content within this pre-caret range is the position\n    // Using toString() is generally more reliable than textContent for range length\n    return preCaretRange.toString().length;\n}\n/**\n * Sets the caret position within a contenteditable element.\n * @param element The contenteditable element.\n * @param position The desired linear offset from the start of the text content.\n */\nfunction setCaretPosition(element, position) {\n    var _a;\n    const selection = window.getSelection();\n    if (!selection) {\n        return;\n    }\n    const range = document.createRange();\n    let charCount = 0;\n    let foundNode = false;\n    let nodeStack = [element]; // Use a stack for DFS traversal\n    // Depth-first search to find the correct text node and offset\n    while (nodeStack.length > 0) {\n        const node = nodeStack.pop();\n        if (node.nodeType === Node.TEXT_NODE) {\n            const textLength = ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            if (position >= charCount && position <= charCount + textLength) {\n                range.setStart(node, position - charCount);\n                range.setEnd(node, position - charCount);\n                foundNode = true;\n                break; // Found the node, exit loop\n            }\n            charCount += textLength;\n        }\n        else if (node.nodeType === Node.ELEMENT_NODE) {\n            const elementNode = node;\n            if (elementNode.tagName === 'BR') {\n                if (position === charCount) { // Position is right before BR\n                    range.setStartBefore(node);\n                    range.setEndBefore(node);\n                    foundNode = true;\n                    break;\n                }\n                charCount += 1; // Treat BR as one character\n            }\n            else if (elementNode.getAttribute('contenteditable') === 'false') {\n                // Treat non-editable elements (like our widgets) as single characters\n                if (position === charCount) {\n                    // Position is right before the widget\n                    range.setStartBefore(node);\n                    range.setEndBefore(node);\n                    foundNode = true;\n                    break;\n                }\n                charCount += 1;\n            }\n            else {\n                // Add child nodes to the stack in reverse order for correct DFS\n                const children = node.childNodes;\n                for (let i = children.length - 1; i >= 0; i--) {\n                    nodeStack.push(children[i]);\n                }\n            }\n        }\n    }\n    // If the position is beyond the content or wasn't found, place cursor at the end\n    if (!foundNode) {\n        range.selectNodeContents(element);\n        range.collapse(false); // Collapse to the end\n    }\n    selection.removeAllRanges();\n    selection.addRange(range);\n    // Restore focus only if the element was previously focused or is the target\n    // This avoids stealing focus unnecessarily\n    if (document.activeElement !== element) {\n        element.focus({ preventScroll: true }); // preventScroll helps avoid jumping\n    }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detectLanguage = detectLanguage;\nexports.highlightCode = highlightCode;\nconst highlight_js_1 = __importDefault(require(\"highlight.js\"));\n/**\n * Detects the programming language from code block content using highlight.js\n * and custom pattern matching for common languages.\n */\nfunction detectLanguage(code) {\n    try {\n        // Try auto detection first with a limited set of common languages\n        const result = highlight_js_1.default.highlightAuto(code, [\n            'python', 'javascript', 'typescript', 'java',\n            'html', 'css', 'cpp', 'csharp', 'sql', 'rust',\n            'php', 'bash', 'json', 'xml', 'markdown'\n        ]);\n        // If confidence is reasonably high, use that language\n        if (result.relevance > 5 && result.language) {\n            return result.language;\n        }\n        // Fall back to basic pattern matching for better accuracy on ambiguous cases\n        if (/^(?:\\s*)?(?:import\\s+[^;]+;|package\\s+[^;]+;|public\\s+class)/.test(code)) {\n            return 'java';\n        }\n        else if (/^(?:\\s*)?(import|from|def|class|if __name__)/.test(code)) {\n            return 'python';\n        }\n        else if (/^(?:\\s*)?(?:function|const|let|var|import|export|=>)/.test(code)) {\n            // Broader check for JS/TS\n            if (/^(?:\\s*)?(?:import\\s.+|export\\s.+|interface|type|enum|declare|:|\\s<)/.test(code)) {\n                return 'typescript';\n            }\n            return 'javascript';\n        }\n        else if (/^(?:\\s*)?(?:<!DOCTYPE|<html|<head|<body)/i.test(code)) {\n            return 'html';\n        }\n        else if (/^(?:\\s*)?#include/.test(code)) {\n            return 'cpp';\n        }\n        else if (/^(?:\\s*)?(?:using\\s+System|namespace|public\\s+static\\s+void\\s+Main)/.test(code)) {\n            return 'csharp';\n        }\n        else if (/^(?:\\s*)?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\\s/i.test(code)) {\n            return 'sql';\n        }\n        else if (/^(?:\\s*)?(?:fn|let|struct|enum|trait|impl|mod)\\s/.test(code)) {\n            return 'rust';\n        }\n        else if (/^(?:\\s*)?(?:<\\?php|use\\s+[\\w\\\\]+;)/.test(code)) {\n            return 'php';\n        }\n        else if (/^(?:\\s*)?(?:#\\s*!\\/bin\\/(?:bash|sh|zsh)|\\$)/.test(code)) {\n            return 'bash';\n        }\n        else if (/^\\s*\\{/.test(code) && /\\}\\s*$/.test(code)) {\n            // Simple check for JSON-like structure\n            return 'json';\n        }\n        else if (/^\\s*<\\?xml/.test(code) || /^\\s*<\\w+/.test(code)) {\n            // Simple check for XML/HTML like structure\n            return 'xml';\n        }\n        // If no specific language detected, return empty string for default handling\n        return '';\n    }\n    catch (error) {\n        console.error('Error detecting language:', error);\n        return ''; // Return empty on error\n    }\n}\n/**\n * Highlights code using highlight.js.\n * Falls back to auto-detection if the specified language is not supported.\n */\nfunction highlightCode(code, language) {\n    try {\n        if (language && highlight_js_1.default.getLanguage(language)) {\n            return highlight_js_1.default.highlight(code, { language, ignoreIllegals: true }).value;\n        }\n        else {\n            // Fallback to auto-detection if language is empty or not registered\n            return highlight_js_1.default.highlightAuto(code).value;\n        }\n    }\n    catch (error) {\n        console.error(`Error highlighting code (language: ${language || 'auto'}):`, error);\n        // Return original code escaped for safety on error\n        return code.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.configureMarked = configureMarked;\nexports.preprocessMarkdown = preprocessMarkdown;\nconst marked_1 = require(\"marked\");\n/**\n * Configure marked with better rendering options for code blocks\n */\nfunction configureMarked() {\n    // Configure marked options\n    marked_1.marked.setOptions({\n        gfm: true, // Enable GitHub Flavored Markdown\n        breaks: true, // Add <br> on single line breaks\n        pedantic: false, // Conform to original markdown spec\n        async: false, // Disable async rendering\n        silent: false // Enable error reporting\n    });\n}\n/**\n * Pre-process markdown text to fix common issues with streaming content\n */\nfunction preprocessMarkdown(text) {\n    // Normalize line endings\n    const normalizedText = text.replace(/\\r\\n/g, '\\n');\n    // Handle code blocks first\n    let inCodeBlock = false;\n    const lines = normalizedText.split('\\n');\n    const processedLines = lines.map((line, i) => {\n        // Check for code block markers\n        if (line.trim().startsWith('```')) {\n            inCodeBlock = !inCodeBlock;\n            // Preserve language specification\n            return line.trim();\n        }\n        // If we're in a code block, preserve the line as is\n        if (inCodeBlock) {\n            return line;\n        }\n        // Outside code blocks:\n        // 1. Handle list items with proper spacing\n        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines\n        let processed = line;\n        // Handle dash list items by ensuring they have a space after the dash\n        processed = processed.replace(/(\\s*)-(\\S)/g, '$1- $2');\n        // Handle mixed space/dash issues - ensure proper newlines before list items\n        processed = processed.replace(/([^\\n\\s])-\\s/g, '$1\\n- ');\n        return processed;\n    });\n    // Join lines and ensure code blocks are properly formatted\n    let result = processedLines.join('\\n');\n    // Handle empty code blocks (add a space so they render properly)\n    result = result.replace(/```(.*)\\n```/g, '```$1\\n \\n```');\n    return result;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderMarkdown = renderMarkdown;\n/**\n * Renders markdown text to HTML.\n * @param markdownText The markdown text to render\n * @returns HTML string\n */\nfunction renderMarkdown(markdownText) {\n    // This is a simple implementation. In a real app, you would use a library like marked.js\n    if (!markdownText) {\n        return '';\n    }\n    // Basic markdown conversion\n    let html = markdownText\n        // Handle headers\n        .replace(/^# (.*$)/gm, '<h1>$1</h1>')\n        .replace(/^## (.*$)/gm, '<h2>$1</h2>')\n        .replace(/^### (.*$)/gm, '<h3>$1</h3>')\n        .replace(/^#### (.*$)/gm, '<h4>$1</h4>')\n        .replace(/^##### (.*$)/gm, '<h5>$1</h5>')\n        .replace(/^###### (.*$)/gm, '<h6>$1</h6>')\n        // Handle bold\n        .replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')\n        .replace(/__(.*?)__/g, '<strong>$1</strong>')\n        // Handle italic\n        .replace(/\\*(.*?)\\*/g, '<em>$1</em>')\n        .replace(/_(.*?)_/g, '<em>$1</em>')\n        // Handle links\n        .replace(/\\[(.*?)\\]\\((.*?)\\)/g, '<a href=\"$2\" target=\"_blank\" rel=\"noopener\">$1</a>')\n        // Handle code blocks\n        .replace(/```([\\s\\S]*?)```/g, '<pre><code>$1</code></pre>')\n        // Handle inline code\n        .replace(/`(.*?)`/g, '<code>$1</code>')\n        // Handle horizontal rules\n        .replace(/^---$/gm, '<hr>')\n        // Handle unordered lists\n        .replace(/^\\* (.*$)/gm, '<ul><li>$1</li></ul>')\n        .replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>')\n        // Handle ordered lists\n        .replace(/^\\d+\\. (.*$)/gm, '<ol><li>$1</li></ol>')\n        // Handle blockquotes\n        .replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>')\n        // Handle paragraphs - ensures double newlines create p tags\n        .replace(/\\n\\n/g, '</p><p>');\n    // Wrap in paragraph if not already wrapped\n    if (!html.startsWith('<')) {\n        html = '<p>' + html + '</p>';\n    }\n    // Fix nested list items\n    html = html\n        .replace(/<\\/ul>\\s*<ul>/g, '')\n        .replace(/<\\/ol>\\s*<ol>/g, '');\n    return html;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addMessageToCell = addMessageToCell;\nexports.getSelectedText = getSelectedText;\nexports.isInNotebookCell = isInNotebookCell;\nexports.isInNotebookCellAndEditorFocused = isInNotebookCellAndEditorFocused;\nexports.isCodeCell = isCodeCell;\nexports.isOutputArea = isOutputArea;\nexports.getCurrentCellContent = getCurrentCellContent;\nexports.insertCellContentByIndex = insertCellContentByIndex;\nconst globals_1 = require(\"../core/globals\");\n/**\n * Adds message content to the current cell in the active notebook.\n */\nfunction addMessageToCell(text) {\n    var _a;\n    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (!cell || !cell.editor) {\n        console.warn('Cannot add message: No active cell or editor found.');\n        return;\n    }\n    try {\n        const editor = cell.editor;\n        // Access the underlying CodeMirror editor view (adjust if using a different editor)\n        const view = editor.editor;\n        if (!view) {\n            console.warn('Cannot add message: CodeMirror view not accessible.');\n            return;\n        }\n        // Get current cursor position\n        const state = view.state;\n        const selection = state.selection;\n        const cursorPos = selection.main.head;\n        // Insert newline and message content at cursor position\n        const transaction = state.update({\n            changes: {\n                from: cursorPos,\n                insert: `\\n${text}`\n            },\n            // Optionally move cursor to end of inserted text\n            selection: { anchor: cursorPos + text.length + 1 }\n        });\n        view.dispatch(transaction);\n    }\n    catch (error) {\n        console.error('Error adding message to cell:', error);\n    }\n}\n/**\n * Gets the currently selected text from:\n *  - the active notebook cell\n *  - the text editor\n *  - the output area of a code cell\n */\nfunction getSelectedText() {\n    var _a, _b, _c;\n    // if (isOutputArea()) {\n    //   // TODO: return what's selected in the output area\n    //   return null;\n    // }\n    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (cell === null || cell === void 0 ? void 0 : cell.editor) {\n        const editor = cell.editor;\n        const cmEditor = editor.editor; // Access CodeMirror editor instance\n        if (cmEditor && cmEditor.state) {\n            const state = cmEditor.state;\n            const selection = state.selection.main;\n            return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);\n        }\n        console.warn(\"Could not access CodeMirror state to get selection.\");\n        return null;\n    }\n    else {\n        // Fallback for non-notebook editors (e.g., text editor)\n        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n        if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {\n            const editor = activeWidget.content.editor;\n            const cmEditor = editor.editor;\n            if (cmEditor && cmEditor.state) {\n                const state = cmEditor.state;\n                const selection = state.selection.main;\n                return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);\n            }\n            console.warn(\"Could not access CodeMirror state for non-notebook editor selection.\");\n            return null;\n        }\n    }\n    return null;\n}\n/**\n * Checks whether we are currently in a notebook cell.\n*/\nfunction isInNotebookCell() {\n    var _a;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    return activeCell !== null;\n}\n/**\n * Checks whether we are currently in a notebook cell and the editor is focused:\n * meaning that the cursor is in the editor.\n*/\nfunction isInNotebookCellAndEditorFocused() {\n    var _a;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor) {\n        const editor = activeCell.editor;\n        const cmEditor = editor.editor; // Access CodeMirror editor instance\n        return cmEditor && cmEditor.state;\n    }\n    return false;\n}\n/**\n * Check whether the currently active cell is a code cell.\n*/\nfunction isCodeCell() {\n    var _a, _b;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    return ((_b = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) === null || _b === void 0 ? void 0 : _b.type) === 'code';\n}\n/**\n * Check whether the cursor is in the output area of a code cell.\n * This function specifically checks if we're in a code cell's output area,\n * not just any output area.\n */\nfunction isOutputArea() {\n    var _a;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (!(activeCell === null || activeCell === void 0 ? void 0 : activeCell.model))\n        return false;\n    // First check if it's a code cell\n    if (activeCell.model.type !== 'code')\n        return false;\n    // Then check if we're in the output area\n    const editor = activeCell.editor;\n    if (!editor)\n        return false;\n    const cmEditor = editor.editor;\n    if (!(cmEditor === null || cmEditor === void 0 ? void 0 : cmEditor.state))\n        return false;\n    // Get the editor's DOM element\n    const editorElement = cmEditor.dom;\n    if (!editorElement)\n        return false;\n    // Check if the active element is within the output area\n    const activeElement = document.activeElement;\n    if (!activeElement)\n        return false;\n    // The output area is typically a sibling of the editor element\n    const outputArea = editorElement.nextElementSibling;\n    if (!outputArea)\n        return false;\n    return outputArea.contains(activeElement);\n}\n/**\n * Gets the content of the currently active notebook cell or text editor.\n */\nfunction getCurrentCellContent() {\n    var _a, _b, _c, _d, _e;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {\n        // Try using sharedModel first (more robust)\n        if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {\n            return activeCell.model.sharedModel.getSource();\n        }\n        // Fallback: Try using toJSON().source\n        const cellJson = activeCell.model.toJSON();\n        const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n        if (typeof source === 'string') {\n            return source;\n        }\n        else if (Array.isArray(source)) {\n            return source.join('\\n');\n        }\n        console.warn(\"Could not get cell content via sharedModel or toJSON().source\");\n        return null;\n    }\n    // Fallback for non-notebook editors if needed\n    const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n    if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {\n        // Assuming model.value.text for generic text editors\n        return (_e = (_d = activeWidget.content.model.value) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;\n    }\n    return null;\n}\n/**\n * Gets cell content by index from the current notebook and calls a callback to insert it.\n * NOTE: The original function called `this.appendToInput`. This functionality needs\n *       to be provided via the `insertCallback`.\n */\nfunction insertCellContentByIndex(index, insertCallback) {\n    try {\n        if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {\n            console.error('No active notebook found');\n            return;\n        }\n        const notebookPanel = globals_1.globals.notebookTracker.currentWidget;\n        const model = notebookPanel.content.model;\n        if (!model || !model.cells || index < 0 || index >= model.cells.length) {\n            console.error(`Invalid cell index: ${index}`);\n            return;\n        }\n        const cell = model.cells.get(index);\n        let cellContent = '';\n        // Get cell content - handle different ways content might be stored\n        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {\n            cellContent = cell.sharedModel.getSource();\n        }\n        else {\n            const cellJson = cell.toJSON();\n            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n            if (typeof source === 'string') {\n                cellContent = source;\n            }\n            else if (Array.isArray(source)) {\n                cellContent = source.join('\\n');\n            }\n        }\n        // Insert cell reference with content using the callback\n        insertCallback(`cell ${cellContent}`);\n    }\n    catch (error) {\n        console.error('Error inserting cell by index:', error);\n    }\n}\n"],"names":[],"sourceRoot":""}