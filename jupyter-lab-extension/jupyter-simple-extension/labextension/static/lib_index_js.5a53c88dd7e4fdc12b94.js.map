{"version":3,"file":"lib_index_js.5a53c88dd7e4fdc12b94.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC7Ib;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB,mBAAO,CAAC,4FAA2B,GAAG;AAC9D;AACA,wDAAwD,kCAAkC,GAAG;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACrEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB,IAAI,+BAA+B;AACnC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;;;;;;;;;;ACjBY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,2BAA2B,mBAAO,CAAC,4DAAwB,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,4BAA4B;AACnH;AACA,mBAAmB;AACnB,sFAAsF,4BAA4B;AAClH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,sBAAsB;;;;;;;;;;;AC7GT;AACb,YAAY,wCAAwC,6BAA6B;AACjF,YAAY,YAAY,yBAAyB;AACjD,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,kCAAkC;AAClC;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA,oCAAoC,KAAK;AACzC;AACA;AACA,2EAA2E;AAC3E,8BAA8B;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACnNP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,2BAA2B,mBAAO,CAAC,4DAAwB;AAC3D,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ,eAAe,WAAW;AAC1F;AACA,sDAAsD;AACtD;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,gEAAgE;AAChE,iDAAiD;AACjD,8CAA8C;AAC9C;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,4FAA4F;AAC5F;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,aAAa,WAAW,SAAS,OAAO;AAC9G;AACA;AACA;AACA,+EAA+E,YAAY;AAC3F;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8EAA8E,2BAA2B;AACzG;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA,iFAAiF;AACjF;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,kBAAkB;AACnH,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc;AACjG;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;;;;;;;;;;;AC/JT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE,IAAI,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAyD;AACvE,cAAc,2DAA2D;AACzE,cAAc,0DAA0D;AACxE,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gEAAgE,MAAM,EAAE,SAAS;AACjF;AACA,qBAAqB;AACrB;AACA;AACA,kGAAkG,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wCAAwC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,EAAE,kBAAkB,EAAE,iBAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS,UAAU,KAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kFAAkF;AAC5G,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK,GAAG,yDAAyD;AACzG;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,UAAU,KAAK;AACxE;AACA;AACA,oCAAoC,0DAA0D;AAC9F;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB,UAAU,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,aAAa,oBAAoB;AAC9G;AACA,4BAA4B,SAAS,GAAG,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD,qBAAqB;AACrB;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wCAAwC,mBAAmB,kBAAkB,SAAS;AACtF;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,KAAK,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc,KAAK,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,aAAa,oEAAoE,oBAAoB,4CAA4C;AACtM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,wEAAwE,iCAAiC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,4BAA4B,QAAQ,kBAAkB;AAChI;AACA;AACA;AACA;AACA,4FAA4F,MAAM;AAClG;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA,gGAAgG,MAAM;AACtG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU,KAAK,2BAA2B;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,UAAU,KAAK,2BAA2B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E,wDAAwD,WAAW,oBAAoB,cAAc;AACrG;AACA;AACA,wBAAwB;;;;;;;;;;;ACn7BX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,YAAY,gBAAgB,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,KAAK,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC1GV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY,IAAI;AAC3D;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD,kBAAkB,mBAAO,CAAC,6CAAgB;AAC1C,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,+BAA+B,mBAAO,CAAC,6DAAwB;AAC/D,YAAY,YAAY;AACxB;AACA,mBAAO,CAAC,6CAAoB;AAC5B;AACA,mBAAmB,mBAAO,CAAC,mDAAmB;AAC9C,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACrCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,gBAAgB,mBAAO,CAAC,yCAAc;AACtC,qBAAqB,mBAAO,CAAC,mDAAmB;AAChD,6BAA6B,mBAAO,CAAC,2EAA+B;AACpE,2BAA2B,mBAAO,CAAC,uEAA6B;AAChE,yBAAyB,mBAAO,CAAC,uDAAqB;AACtD,yBAAyB,mBAAO,CAAC,uDAAqB;AACtD,qBAAqB,mBAAO,CAAC,qDAAoB;AACjD,yBAAyB,mBAAO,CAAC,6DAAwB;AACzD,wBAAwB,mBAAO,CAAC,iEAA0B;AAC1D,0BAA0B,mBAAO,CAAC,qEAA4B;AAC9D,0BAA0B,mBAAO,CAAC,qEAA4B;AAC9D,2BAA2B,mBAAO,CAAC,uEAA6B;AAChE,qBAAqB,mBAAO,CAAC,+CAAiB;AAC9C,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA,oBAAoB,mBAAO,CAAC,mDAAmB;AAC/C,+BAA+B,mBAAO,CAAC,yEAA8B;AACrE,0BAA0B,mBAAO,CAAC,yDAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,6DAA6D,KAAK,cAAc,WAAW,IAAI;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ,+FAA+F,KAAK,KAAK;AACrJ,uCAAuC,QAAQ,+FAA+F,QAAQ,KAAK;AAC3J,wCAAwC,QAAQ,+FAA+F,KAAK,KAAK;AACzJ,6CAA6C,QAAQ,8FAA8F,KAAK,KAAK;AAC7J;AACA;AACA,qHAAqH,QAAQ,0FAA0F,QAAQ,KAAK;AACpO;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,qFAAqF;AAC7H,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gCAAgC;AACxF,wDAAwD,kCAAkC;AAC1F,+BAA+B,gCAAgC,GAAG;AAClE;AACA;AACA,aAAa;AACb,mCAAmC,QAAQ,+GAA+G;AAC1J,qCAAqC,QAAQ;AAC7C;AACA;AACA,uCAAuC,QAAQ,2FAA2F;AAC1I,uCAAuC,QAAQ,8FAA8F;AAC7I,gCAAgC;AAChC;AACA,eAAe;AACf,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,2BAA2B;;;;;;;;;;;ACtRd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,uDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,kHAAkH;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB,MAAM,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iBAAiB;;;;;;;;;;;ACtHJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACnER;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,mCAAmC;AACnC,iCAAiC;AACjC,gCAAgC;AAChC,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;;;;;;;;;;;ACrFa;AACb,YAAY,4BAA4B;AACxC,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,oBAAoB;AACpB,kBAAkB;AAClB,sBAAsB;AACtB,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,0DAA0D,yBAAyB,kBAAkB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,6DAA6D,yBAAyB,oBAAoB;AAC1G;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,gEAAgE,yBAAyB,sBAAsB;AAC/G;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;;;;;;;;;;ACvHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA,2DAA2D,uCAAuC;AAClG;AACA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D,yCAAyC;AACtG;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA,+DAA+D,4CAA4C;AAC3G;AACA,wDAAwD,8DAA8D;AACtH,8DAA8D,0CAA0C;AACxG;AACA,4DAA4D,wCAAwC;AACpG;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mEAAmE,gDAAgD;AACnH,wDAAwD,yBAAyB,8CAA8C,iDAAiD;AAChL;AACA;AACA;AACA,4DAA4D,yBAAyB,uBAAuB,iDAAiD;AAC7J;AACA;AACA;AACA,8DAA8D,0BAA0B,mBAAmB,iDAAiD;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2DAA2D;AAChH;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6DAA6D;AACpH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ia;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,yBAAyB;AACzB,wBAAwB;AACxB,sCAAsC;AACtC,uCAAuC;AACvC,6BAA6B;AAC7B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,oCAAoC;AACpC,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,gEAAgE;AAC5E;AACA,YAAY,mBAAmB;AAC/B,uBAAuB,mBAAO,CAAC,0DAAuB;AACtD,0BAA0B,mBAAO,CAAC,gEAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,gBAAgB;AACvG;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB,GAAG;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,qCAAqC;AACrC;AACA,uCAAuC;AACvC;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACxeV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,sCAAsC;AACtC;AACA,sEAAsE;AACtE,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;AClHR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,yCAAyC;AACzC,kDAAkD;AAClD,yCAAyC;AACzC,oCAAoC;AACpC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,KAAK,QAAQ;AACvD;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,4GAA4G,KAAK,GAAG;AACpH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACzXJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG,SAAS;AACT;AACA,yGAAyG;AACzG,SAAS;AACT;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA,4GAA4G;AAC5G,aAAa;AACb;AACA;AACA,+DAA+D;AAC/D,6GAA6G;AAC7G,aAAa;AACb,SAAS;AACT;AACA;AACA,4DAA4D;AAC5D,yGAAyG;AACzG,SAAS;AACT;AACA;AACA;AACA,gDAAgD;AAChD,qGAAqG;AACrG;AACA;;;;;;;;;;;AChFa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,qBAAqB;AACrB,uCAAuC,mBAAO,CAAC,+EAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,GAAG,cAAc,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA,uCAAuC,sBAAsB;AAC7D;AACA;;;;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B;AAC1B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,uBAAuB;AACvB,6BAA6B;AAC7B,gCAAgC;AAChC,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC,aAAa;AACb;AACA,yBAAyB;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA","sources":["webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/core/api-client.js","webpack://jupyter-simple-extension/./lib/core/globals.js","webpack://jupyter-simple-extension/./lib/core/icons.js","webpack://jupyter-simple-extension/./lib/handlers/history-handler.js","webpack://jupyter-simple-extension/./lib/handlers/input-handler.js","webpack://jupyter-simple-extension/./lib/handlers/message-handler.js","webpack://jupyter-simple-extension/./lib/handlers/popup-menu-manager.js","webpack://jupyter-simple-extension/./lib/handlers/settings-handler.js","webpack://jupyter-simple-extension/./lib/handlers/shortcut-handler.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/sidebar-widget.js","webpack://jupyter-simple-extension/./lib/state/chat-state.js","webpack://jupyter-simple-extension/./lib/state/settings-state.js","webpack://jupyter-simple-extension/./lib/ui/code-ref-widget.js","webpack://jupyter-simple-extension/./lib/ui/dom-elements.js","webpack://jupyter-simple-extension/./lib/ui/layout-builder.js","webpack://jupyter-simple-extension/./lib/ui/message-renderer.js","webpack://jupyter-simple-extension/./lib/ui/settings-modal.js","webpack://jupyter-simple-extension/./lib/ui/ui-manager.js","webpack://jupyter-simple-extension/./lib/utils/clipboard.js","webpack://jupyter-simple-extension/./lib/utils/highlighting.js","webpack://jupyter-simple-extension/./lib/utils/markdown-config.js","webpack://jupyter-simple-extension/./lib/utils/notebook-integration.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CellContextTracker = void 0;\n/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nclass CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\nexports.CellContextTracker = CellContextTracker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerCommands = registerCommands;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\"); // Import LabIcon if needed as placeholder\n// Placeholder icon (replace if you have a specific icon)\nconst extensionIcon = ui_components_1.LabIcon.resolve({ icon: 'ui-components:jupyterlab' }); // Use resolve for built-in\n/**\n * Registers commands for the extension\n */\nfunction registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\n/**\n * API client for interacting with the backend LLM service\n */\nclass ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\nexports.ApiClient = ApiClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globals = void 0;\nexports.initGlobals = initGlobals;\n/**\n * Global references to key components in the application\n */\nexports.globals = {};\n/**\n * Initialize global references\n */\nfunction initGlobals(app, notebookTracker) {\n    exports.globals.app = app;\n    exports.globals.notebookTracker = notebookTracker;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extensionIcon = void 0;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexports.extensionIcon = new ui_components_1.LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryHandler = void 0;\nconst message_renderer_1 = require(\"../ui/message-renderer\"); // Assuming renderers are needed\n/**\n * Manages the display and interaction logic for the chat history view.\n */\nclass HistoryHandler {\n    constructor(chatState, uiManager, callbacks, rendererCallbacks) {\n        this.isHistoryViewActive = false;\n        this.chatState = chatState;\n        this.uiManager = uiManager;\n        this.callbacks = callbacks;\n        this.rendererCallbacks = rendererCallbacks;\n        // Get the history container element from UIManager\n        this.historyContainer = this.uiManager.getUIElements().historyContainer;\n    }\n    /**\n     * Toggles between the main chat view and the history view.\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Use UIManager to hide chat, show history\n            this.uiManager.showHistoryView();\n            this.renderChatHistory(); // Populate the history view\n        }\n        else {\n            // Use UIManager to show chat, hide history\n            this.uiManager.showChatView();\n            // Ensure the correct title is displayed when switching back\n            const currentChat = this.chatState.getCurrentChat();\n            if (currentChat) {\n                this.callbacks.updateTitleInput(currentChat.title);\n            }\n        }\n    }\n    /**\n     * Renders the list of past chats in the history container.\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = ''; // Clear previous list\n        const history = this.chatState.getChatHistory();\n        const currentChatId = this.chatState.getCurrentChatId();\n        if (history.length === 0) {\n            this.historyContainer.innerHTML = '<div class=\"jp-llm-ext-history-empty\">No chat history yet.</div>';\n            return;\n        }\n        const list = document.createElement('ul');\n        list.className = 'jp-llm-ext-history-list';\n        history.forEach(chat => {\n            const listItem = document.createElement('li');\n            listItem.className = 'jp-llm-ext-history-item';\n            if (chat.id === currentChatId) {\n                listItem.classList.add('jp-llm-ext-active');\n            }\n            // Simple representation: Title\n            // TODO: Add preview, timestamp, delete button etc.\n            const titleDiv = document.createElement('div');\n            titleDiv.className = 'jp-llm-ext-history-item-title';\n            titleDiv.textContent = chat.title || 'Untitled Chat';\n            listItem.appendChild(titleDiv);\n            // Add click event to load the chat\n            listItem.addEventListener('click', () => this.loadChat(chat.id));\n            list.appendChild(listItem);\n        });\n        this.historyContainer.appendChild(list);\n    }\n    /**\n     * Loads a specific chat session from history into the main view.\n     */\n    loadChat(chatId) {\n        const chat = this.chatState.getChatById(chatId);\n        if (!chat) {\n            console.error(`Chat with ID ${chatId} not found.`);\n            return;\n        }\n        // Set this chat as the active one in the state\n        this.chatState.setCurrentChatId(chatId);\n        // Update the main UI title input\n        this.callbacks.updateTitleInput(chat.title);\n        // Clear the current message display\n        this.callbacks.clearMessageContainer();\n        // Re-populate the message container with messages from the loaded chat\n        // Use the renderer functions via callbacks\n        chat.messages.forEach((msg) => {\n            let messageElement;\n            if (msg.sender === 'user') {\n                messageElement = (0, message_renderer_1.renderUserMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);\n            }\n            else { // 'bot'\n                messageElement = (0, message_renderer_1.renderBotMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);\n            }\n            // Add the rendered element to the message container via callback\n            this.callbacks.addRenderedMessage(messageElement);\n        });\n        // Switch back to the chat view if we were in the history view\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView(); // This will call uiManager.showChatView()\n        }\n        else {\n            // If already in chat view, ensure scrolling is correct\n            this.uiManager.scrollToBottom();\n        }\n        // Optional: Re-render history list to update the active item indicator\n        // Only really needed if not switching views\n        // if (!this.isHistoryViewActive) { this.renderChatHistory(); }\n    }\n}\nexports.HistoryHandler = HistoryHandler;\n","\"use strict\";\n// import { PopupMenuManager, MenuActionCallbacks } from './popup-menu-manager'; // Removed unused import\n// import { UIManager } from '../ui/ui-manager'; // Removed unused import\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputHandler = void 0;\n/**\n * Handles events and logic related to the chat input field.\n */\nclass InputHandler {\n    constructor(chatInput, callbacks\n    // uiManager: UIManager // Removed unused parameter\n    ) {\n        // private uiManager: UIManager; // Removed unused member\n        // --- Code Reference State ---\n        this.codeRefMap = new Map();\n        this.nextRefId = 1;\n        // ---------------------------\n        this.hasAtSymbol = false;\n        this.isMarkdownMode = false; // Internal state, potentially synced with UIManager\n        this.isInputExpanded = false; // Internal state, potentially synced with UIManager\n        // -----------------------------\n        // --- Private Event Handlers ---\n        this._handleKeyPress = (event) => {\n            // Handle Enter key (send message)\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                const rawMessage = this.chatInput.value.trim();\n                if (rawMessage) {\n                    // Resolve code references BEFORE sending\n                    const resolvedMessage = this.resolveCodeReferences(rawMessage);\n                    console.log('Sending resolved message:', resolvedMessage); // Debug log\n                    // Pass markdown state along with the message\n                    this.callbacks.handleSendMessage(resolvedMessage, this.isMarkdownMode);\n                    // Clearing is handled separately (e.g., by MessageHandler calling clearInput)\n                }\n            }\n            // Note: '@' key handling might be better in handleKeyDown if needed globally,\n            // but keeping here for now as it relates directly to input field focus.\n            // Or handled by shortcut-handler listening globally. Let's assume shortcut-handler handles it.\n        };\n        this._handleInput = () => {\n            // Handle @ symbol removal to hide popup\n            const cursorPosition = this.chatInput.selectionStart;\n            if (cursorPosition === null)\n                return; // Type guard\n            const textBeforeCursor = this.chatInput.value.slice(0, cursorPosition);\n            // Check if the character immediately before the cursor is '@'\n            // and if it's preceded by whitespace or is at the start of the input.\n            const isAtSymbolContext = textBeforeCursor.endsWith('@') &&\n                (cursorPosition === 1 ||\n                    /\\s/.test(textBeforeCursor[cursorPosition - 2]));\n            if (this.hasAtSymbol && !isAtSymbolContext) {\n                // @ symbol context was present but now it's gone, hide the popup\n                this.callbacks.hidePopupMenu();\n            }\n            // Update the state *after* checking the previous state\n            this.hasAtSymbol = isAtSymbolContext;\n        };\n        this.chatInput = chatInput;\n        this.callbacks = callbacks;\n        // this.uiManager = uiManager; // Removed unused assignment\n        // Bind event listeners\n        this.chatInput.addEventListener('keypress', this._handleKeyPress);\n        this.chatInput.addEventListener('input', this._handleInput);\n        // Note: Actual markdown toggle and expand buttons are likely managed by UIManager,\n        // which would then call methods like `setMarkdownMode` or `toggleExpansion` on this handler.\n    }\n    /**\n     * Removes event listeners.\n     */\n    dispose() {\n        this.chatInput.removeEventListener('keypress', this._handleKeyPress);\n        this.chatInput.removeEventListener('input', this._handleInput);\n    }\n    /**\n     * Appends text to the input field, potentially replacing a preceding '@' symbol.\n     */\n    appendToInput(text) {\n        try {\n            const currentValue = this.chatInput.value;\n            const start = this.chatInput.selectionStart;\n            const end = this.chatInput.selectionEnd;\n            let newValue = '';\n            let newCursorPos = 0;\n            // Check if the character immediately before the cursor is '@'\n            if (start > 0 && currentValue[start - 1] === '@') {\n                // Replace the '@' and append the new text\n                newValue = currentValue.slice(0, start - 1) + text + currentValue.slice(end);\n                newCursorPos = (start - 1) + text.length;\n            }\n            else {\n                // Standard insertion: Insert text at cursor position\n                newValue = currentValue.slice(0, start) + text + currentValue.slice(end);\n                newCursorPos = start + text.length;\n            }\n            this.chatInput.value = newValue;\n            this.chatInput.focus();\n            this.chatInput.setSelectionRange(newCursorPos, newCursorPos);\n        }\n        catch (error) {\n            console.error('Error appending to input:', error);\n        }\n    }\n    /**\n     * Clears the input field and resets associated state after sending.\n     */\n    clearInput() {\n        this.chatInput.value = '';\n        // Directly reset internal state instead of relying on callback\n        this.resetCodeReferences();\n        this.chatInput.rows = 1;\n        this.chatInput.style.height = ''; // Reset height\n        this.hasAtSymbol = false; // Reset @ state\n        // Reset expand button state if it was expanded\n        if (this.isInputExpanded) {\n            this.toggleInputExpansion(false); // Collapse input\n        }\n    }\n    /**\n     * Sets the markdown mode state and updates the placeholder.\n     */\n    setMarkdownMode(isMarkdown) {\n        this.isMarkdownMode = isMarkdown;\n        this.callbacks.updatePlaceholder(this.isMarkdownMode);\n        // Update placeholder directly (alternative to callback)\n        // this.chatInput.placeholder = this.isMarkdownMode ? \n        //   'Write markdown here...' : \n        //   'Ask me anything...';\n    }\n    /**\n     * Toggles the input expansion state and updates UI.\n     */\n    toggleInputExpansion(forceState) {\n        this.isInputExpanded = forceState !== undefined ? forceState : !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.chatInput.style.height = '200px'; // Example height\n            this.chatInput.style.resize = 'vertical';\n        }\n        else {\n            this.chatInput.style.height = ''; // Reset height\n            this.chatInput.style.resize = 'none';\n            this.chatInput.rows = 1; // Ensure it collapses back to 1 row height\n        }\n        // Notify UIManager/LayoutBuilder to update button appearance\n        this.callbacks.toggleInputExpansionUI(this.isInputExpanded);\n    }\n    // --- Code Reference Methods ---\n    /**\n     * Adds a code reference to the internal map and returns its ID.\n     * @param code The actual code content.\n     * @returns The generated reference ID (e.g., \"ref-1\").\n     */\n    addCodeReference(code) {\n        const refId = `ref-${this.nextRefId++}`;\n        this.codeRefMap.set(refId, code);\n        console.log('Added code reference:', refId, '->', code.substring(0, 50) + '...'); // Debug log\n        return refId;\n    }\n    /**\n     * Returns the current map of code references.\n     */\n    getCodeReferenceMap() {\n        return this.codeRefMap;\n    }\n    /**\n     * Clears the code reference map and resets the ID counter.\n     */\n    resetCodeReferences() {\n        this.codeRefMap.clear();\n        this.nextRefId = 1;\n        console.log('Code references reset.'); // Debug log\n    }\n    /**\n     * Replaces code reference placeholders (e.g., \"[ref-1]\") in a message string\n     * with the actual code from the map.\n     * @param message The message string potentially containing placeholders.\n     * @returns The message string with placeholders resolved.\n     */\n    resolveCodeReferences(message) {\n        if (this.codeRefMap.size === 0) {\n            return message; // No references to resolve\n        }\n        // Regex to find placeholders like [ref-1], [ref-12], etc.\n        const placeholderRegex = /\\[(ref-\\d+)\\]/g;\n        let resolvedMessage = message.replace(placeholderRegex, (match, refId) => {\n            const code = this.codeRefMap.get(refId);\n            if (code !== undefined) {\n                console.log('Resolving code reference:', refId); // Debug log\n                // Add context around the replaced code\n                return `\\n\\`\\`\\`\\n${code}\\n\\`\\`\\`\\n`;\n            }\n            else {\n                console.warn('Could not find code for reference:', refId); // Warn if ref ID not found\n                return match; // Keep the placeholder if not found\n            }\n        });\n        return resolvedMessage;\n    }\n    /**\n     * Explicitly sets the hasAtSymbol flag. Called by shortcut handler.\n     */\n    setHasAtSymbol(value) {\n        this.hasAtSymbol = value;\n    }\n    /**\n     * Gets the current value of the hasAtSymbol flag. Called by shortcut handler.\n     */\n    getHasAtSymbol() {\n        return this.hasAtSymbol;\n    }\n}\nexports.InputHandler = InputHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageHandler = void 0;\nconst message_renderer_1 = require(\"../ui/message-renderer\");\nconst notebook_integration_1 = require(\"../utils/notebook-integration\");\n/**\n * Handles sending messages, interacting with the API,\n * managing streaming responses, and updating the UI and state.\n */\nclass MessageHandler {\n    constructor(apiClient, chatState, uiManager, rendererCallbacks, inputHandler) {\n        this.apiClient = apiClient;\n        this.chatState = chatState;\n        this.uiManager = uiManager;\n        this.rendererCallbacks = rendererCallbacks;\n        this.inputHandler = inputHandler;\n    }\n    /**\n     * Processes and sends a user-initiated message.\n     * Also handles adding the user message to the UI and clearing the input.\n     * Accepts the message text and whether it was entered in Markdown mode.\n     */\n    handleSendMessage(message, isMarkdown) {\n        if (!message.trim())\n            return;\n        console.log(`[MessageHandler] Handling send: \"${message}\", Markdown: ${isMarkdown}`);\n        // Add user message to UI FIRST, using the isMarkdown flag\n        this.addMessage(message, 'user', isMarkdown); // Pass isMarkdown here\n        // Clear input via InputHandler (which uses UIManager)\n        this.inputHandler.clearInput(); // Corrected method name\n        // Send message to backend API and handle streaming response\n        this.streamAndRenderResponse(message);\n    }\n    /**\n     * Sends an automatic message (e.g., 'confirmed', 'rejected')\n     * to the backend and handles the streaming response.\n     * Also adds the user's confirmation/rejection action and a separator to the UI.\n     */\n    handleSendAutoMessage(message) {\n        if (!message.trim())\n            return;\n        // Add the user's action ('Confirmed' or 'Rejected') to the UI immediately\n        const userDisplayMessage = message.charAt(0).toUpperCase() + message.slice(1);\n        // Explicitly false for isMarkdown, true for isAuto\n        this.addMessage(userDisplayMessage, 'user', false, true);\n        // Create and add the separator element\n        console.log('[MessageHandler] Creating action separator element...'); // Debug log\n        const separatorDiv = document.createElement('div');\n        separatorDiv.className = 'jp-llm-ext-action-separator'; // Add a class for potential styling\n        separatorDiv.style.textAlign = 'center'; // Basic styling\n        separatorDiv.style.margin = '10px 0'; // Add some vertical space\n        separatorDiv.style.fontSize = '0.9em';\n        separatorDiv.style.color = 'var(--jp-ui-font-color2, grey)'; // Use JupyterLab theme variable\n        if (message === 'confirmed') {\n            separatorDiv.textContent = '-------- Confirmed--------';\n        }\n        else if (message === 'rejected') {\n            separatorDiv.textContent = '-------- Rejected--------';\n        }\n        else {\n            // Optional: Handle unexpected messages? Or just don't add a separator.\n            separatorDiv.textContent = `--------${userDisplayMessage}--------`;\n        }\n        // Add the separator directly to the UI Manager's container\n        console.log('[MessageHandler] Attempting to add separator element:', separatorDiv); // Debug log\n        this.uiManager.addChatMessageElement(separatorDiv);\n        console.log('[MessageHandler] Separator element should be added.'); // Debug log\n        // Send the technical message ('confirmed' or 'rejected') to the backend\n        // and handle the streaming response from the backend.\n        this.streamAndRenderResponse(message);\n    }\n    /**\n     * Adds a message to the UI via UIManager and saves to ChatState.\n     */\n    addMessage(text, sender, isMarkdown = false, // Default false, overridden below\n    isAuto = false // Flag for auto messages like confirm/reject\n    ) {\n        console.log(`[MessageHandler] Adding message: Sender=${sender}, Markdown=${isMarkdown}, Auto=${isAuto}`);\n        let messageElement;\n        if (sender === 'user') {\n            // Pass the isMarkdown option to the renderer\n            messageElement = (0, message_renderer_1.renderUserMessage)(text, { isMarkdown }, this.rendererCallbacks);\n        }\n        else {\n            // Bot messages usually are markdown unless specified otherwise\n            // Handle auto messages specifically if they shouldn't be parsed as markdown\n            const botIsMarkdown = !isAuto; // Assume auto messages aren't markdown\n            messageElement = (0, message_renderer_1.renderBotMessage)(text, { isMarkdown: botIsMarkdown }, this.rendererCallbacks);\n        }\n        this.uiManager.addChatMessageElement(messageElement);\n        // Don't save internal 'confirmed'/'rejected' messages to history\n        if (!isAuto) {\n            // Add isMarkdown back to the saved message state\n            const chatMessage = { sender, text, isMarkdown };\n            this.chatState.addMessageToCurrentChat(chatMessage);\n        }\n    }\n    /**\n     * Core logic for sending a message to the API, handling the stream,\n     * rendering the response, and saving the final bot message.\n     */\n    streamAndRenderResponse(messageToSend) {\n        // --- Prepare streaming UI elements (managed by UIManager) ---\n        // UIManager should provide a method to create/get these elements\n        const { streamingDiv, contentDiv } = this.uiManager.createBotMessageContainer();\n        let completeResponse = '';\n        const cellContext = (0, notebook_integration_1.getCurrentCellContent)(); // Use utility\n        // Stream response from API\n        this.apiClient.streamChat(messageToSend, { cellContext }, \n        // On chunk received\n        (chunk) => {\n            completeResponse += chunk;\n            // Update the temporary streaming div\n            streamingDiv.textContent = completeResponse;\n            this.uiManager.scrollToBottom();\n        }, \n        // On complete\n        () => {\n            var _a;\n            // Hide streaming div, show final content div\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Render the complete response using the renderer function\n            const renderedContent = (0, message_renderer_1.renderBotMessage)(completeResponse, { isMarkdown: true }, this.rendererCallbacks);\n            contentDiv.innerHTML = ''; // Clear placeholder/previous content\n            // Append rendered nodes, skipping any potential wrapper/indicator added by renderBotMessage itself\n            while (renderedContent.firstChild) {\n                // Check if the node is the specific markdown indicator we might add/remove\n                // Or just append everything if renderBotMessage returns the pure content\n                if (!((_a = renderedContent.firstChild.classList) === null || _a === void 0 ? void 0 : _a.contains('markdown-indicator'))) {\n                    contentDiv.appendChild(renderedContent.firstChild);\n                }\n                else {\n                    // Remove the indicator if it was part of the returned fragment\n                    renderedContent.removeChild(renderedContent.firstChild);\n                }\n            }\n            // Save final bot response to history via ChatState\n            const isImage = completeResponse.trim().startsWith('/images/'); // Simple check\n            const botMessageData = {\n                text: completeResponse,\n                sender: 'bot',\n                isMarkdown: !isImage // Save as markdown unless it's an image URL\n            };\n            this.chatState.addMessageToCurrentChat(botMessageData);\n            this.uiManager.scrollToBottom();\n        }, \n        // On error\n        (error) => {\n            // Hide streaming div, show final content div with error\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Use a dedicated error rendering style/component if available\n            contentDiv.innerHTML = `<div class=\"jp-llm-ext-error-message\">Error: ${error.message}</div>`;\n            console.error('API Error:', error);\n            this.uiManager.scrollToBottom();\n        });\n    }\n}\nexports.MessageHandler = MessageHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopupMenuManager = void 0;\nconst globals_1 = require(\"../core/globals\");\n/**\n * Manages the state and interactions of the multi-level popup menu.\n */\nclass PopupMenuManager {\n    constructor(docManager, widgetNode, callbacks) {\n        this.currentMenuLevel = 'top';\n        this.currentMenuPath = '';\n        this.menuHistory = [];\n        this.currentNotebook = null;\n        this.selectedMenuItemIndex = -1; // Track currently selected menu item\n        this.isRenderingContent = false; // Flag to prevent recursive renders\n        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders\n        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];\n        this.fileCache = new Map();\n        this.docManager = docManager;\n        this.widgetNode = widgetNode;\n        this.callbacks = callbacks;\n        this.popupMenuContainer = document.createElement('div');\n        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';\n        this.popupMenuContainer.style.display = 'none';\n        // Attach to the widget node instead of the body\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Create search input\n        this.searchInput = document.createElement('input');\n        this.searchInput.type = 'text';\n        this.searchInput.placeholder = 'Search...';\n        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling\n        // Use 'input' event instead of directly re-rendering on every keystroke\n        this.searchInput.addEventListener('input', () => {\n            // Only re-render if the search term has actually changed\n            if (this.searchInput.value !== this.lastSearchTerm) {\n                this.lastSearchTerm = this.searchInput.value;\n                this.renderMenuContent();\n            }\n        });\n        // Handle keydown in search input to stop propagation for navigation keys\n        this.searchInput.addEventListener('keydown', (event) => {\n            console.log(`POPUP Search KeyDown: Key='${event.key}'`);\n            // IMPORTANT: Prevent these keys from being captured by the document handler\n            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);\n                if (event.key === 'Escape') {\n                    // Handle Escape directly here\n                    this.hidePopupMenu();\n                }\n                else if (event.key === 'Enter') {\n                    // Maybe select first item on Enter?\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        this.selectedMenuItemIndex = 0;\n                        this.updateSelectionHighlight();\n                        // Optionally activate the item:\n                        // menuItems[0].click(); \n                    }\n                }\n                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                    // Move to first/last menu item\n                    // The blur() will be handled by main key handler\n                }\n                event.stopPropagation();\n            }\n            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys\n            // This allows default behavior to work properly\n        }, true); // Use capture phase\n        document.addEventListener('click', this.handleDocumentClick.bind(this), true);\n        // IMPORTANT: Use a separate bound function for the document keydown\n        // so we can remove the exact same listener later\n        this.boundHandleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener('keydown', this.boundHandleKeyDown, true);\n        if (globals_1.globals.notebookTracker) {\n            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;\n            globals_1.globals.notebookTracker.currentChanged.connect((sender, notebook) => {\n                this.currentNotebook = notebook;\n            });\n        }\n    }\n    dispose() {\n        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);\n        // Remove using the exact same bound function\n        document.removeEventListener('keydown', this.boundHandleKeyDown, true);\n        // Remove from widgetNode if attached\n        if (this.popupMenuContainer.parentNode === this.widgetNode) {\n            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);\n        }\n    }\n    handleDocumentClick(event) {\n        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {\n            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');\n            if (atButton && atButton.contains(event.target)) {\n                console.log('POPUP: Click was on the @ button, not hiding.');\n                return;\n            }\n            console.log('POPUP: Click detected outside the menu.');\n            this.hidePopupMenu();\n        }\n    }\n    async showPopupMenu(x, y) {\n        console.log(`POPUP: Showing menu at (${x}, ${y})`);\n        // Store the initial anchor point for positioning\n        this._anchorX = x;\n        this._anchorY = y;\n        if (this.popupMenuContainer.style.display === 'none') {\n            this.currentMenuLevel = 'top';\n            this.currentMenuPath = '';\n            this.menuHistory = [];\n            this.searchInput.value = ''; // Clear search on show\n            this.lastSearchTerm = ''; // Reset last search term\n            await this.setCurrentDirectoryPath();\n        }\n        await this.renderMenuContent();\n        // Ensure it's attached to the widget node if somehow detached\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Position the popup menu - handled in updatePopupPosition\n        this.updatePopupPosition();\n        // Focus the search input if we are in file/directory view, otherwise focus the first item\n        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n            setTimeout(() => {\n                // Focus after timeout to ensure DOM is ready\n                this.searchInput.focus();\n                console.log('POPUP: Focused search input');\n            }, 50); // Slightly longer timeout\n            this.selectedMenuItemIndex = -1; // Don't select an item if search is focused\n        }\n        else {\n            // Reset and select the first menu item for top level\n            this.selectedMenuItemIndex = -1;\n            setTimeout(() => this.selectNextMenuItem(), 50);\n        }\n    }\n    hidePopupMenu() {\n        if (this.popupMenuContainer.style.display !== 'none') {\n            console.log('POPUP: Hiding menu.');\n            this.popupMenuContainer.style.display = 'none';\n            // No need to explicitly remove from widgetNode unless causing issues\n            // If performance becomes an issue with many menus, consider removing/re-adding\n            // if (this.popupMenuContainer.parentNode === this.widgetNode) {\n            //     this.widgetNode.removeChild(this.popupMenuContainer);\n            // }\n        }\n    }\n    async renderMenuContent() {\n        // Prevent recursive renders\n        if (this.isRenderingContent) {\n            console.log('POPUP: Skipping render - already rendering');\n            return;\n        }\n        this.isRenderingContent = true;\n        try {\n            // Clear existing content\n            while (this.popupMenuContainer.firstChild) {\n                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);\n            }\n            // If not at top level, add a search input for filtering items\n            if (this.currentMenuLevel !== 'top') {\n                // Add search input at the top of the menu\n                this.popupMenuContainer.appendChild(this.searchInput);\n                // Path display and back button removed for cleaner UI\n            }\n            // Render different menu content based on current level\n            switch (this.currentMenuLevel) {\n                case 'top':\n                    this.renderTopLevelItems();\n                    break;\n                case 'files':\n                case 'directories':\n                    await this.renderDirectoryBrowserItems();\n                    break;\n                case 'cells':\n                    await this.renderCellItems();\n                    break;\n            }\n            // Reset selection after rendering\n            this.selectedMenuItemIndex = -1;\n            this.updateSelectionHighlight();\n            // Update the position to maintain the fixed bottom edge\n            if (this.popupMenuContainer.style.display !== 'none' && this._anchorX !== undefined && this._anchorY !== undefined) {\n                this.updatePopupPosition();\n            }\n        }\n        catch (error) {\n            console.error('POPUP: Error rendering menu content', error);\n        }\n        finally {\n            this.isRenderingContent = false;\n        }\n    }\n    renderTopLevelItems() {\n        const topLevelCommands = [\n            { label: 'Code', description: '', actionId: 'insert-code' },\n            { label: 'Cells', description: '', actionId: 'browse-cells' },\n            { label: 'File', description: '', actionId: 'browse-files' },\n            { label: 'Directory', description: '', actionId: 'browse-directories' }\n        ];\n        topLevelCommands.forEach(cmd => {\n            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);\n            this.popupMenuContainer.appendChild(item);\n        });\n    }\n    async renderDirectoryBrowserItems() {\n        var _a;\n        // Get search term\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        // Temporarily add loading item below search/path\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // If contents were already fetched recently and we're just filtering again,\n            // we could potentially cache the results to avoid unnecessary API calls\n            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';\n            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);\n            // Check if still in DOM before trying to remove\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (contents && contents.length > 0) {\n                // Filter based on search term\n                const filteredContents = contents.filter(item => {\n                    return item.name.toLowerCase().includes(searchTerm) ||\n                        item.relativePath.toLowerCase().includes(searchTerm);\n                });\n                if (filteredContents.length > 0) {\n                    filteredContents.forEach(item => {\n                        const itemName = item.name;\n                        const itemType = item.type;\n                        const itemPath = item.path;\n                        const relativePath = item.relativePath;\n                        const icon = itemType === 'directory' ? '' : '';\n                        let actionId;\n                        if (itemType === 'directory') {\n                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';\n                        }\n                        else { // itemType === 'file'\n                            actionId = 'select-file';\n                        }\n                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                }\n                else {\n                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');\n                    emptyItem.style.pointerEvents = 'none';\n                    this.popupMenuContainer.appendChild(emptyItem);\n                }\n            }\n            else {\n                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n            }\n        }\n        catch (error) {\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading/filtering directory contents:', error);\n        }\n    }\n    /**\n     * Renders all cells from the current notebook\n     */\n    async renderCellItems() {\n        var _a, _b;\n        // Get search term for filtering\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        // Create a loading indicator\n        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // Check if we have an active notebook\n            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {\n                // Remove loading item\n                if (this.popupMenuContainer.contains(loadingItem)) {\n                    this.popupMenuContainer.removeChild(loadingItem);\n                }\n                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');\n                errorItem.style.color = 'red';\n                errorItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(errorItem);\n                return;\n            }\n            const notebookModel = this.currentNotebook.content.model;\n            const cells = notebookModel.cells;\n            // Remove loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (!cells || cells.length === 0) {\n                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n                return;\n            }\n            // Process and display each cell\n            let filteredCellCount = 0;\n            for (let i = 0; i < cells.length; i++) {\n                const cell = cells.get(i);\n                const cellType = cell.type;\n                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :\n                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');\n                // Use type casting to avoid TypeScript errors\n                const executionCount = cellType === 'code' ?\n                    (cell.executionCount !== undefined && cell.executionCount !== null ?\n                        cell.executionCount : '*') :\n                    '';\n                // Create a preview of the cell content (truncate if needed)\n                const contentPreview = typeof cellContent === 'string' ?\n                    cellContent :\n                    (Array.isArray(cellContent) ? cellContent.join('\\n') : '');\n                const firstLine = contentPreview.split('\\n')[0] || '';\n                const truncatedContent = firstLine.length > 30 ?\n                    firstLine.substring(0, 30) + '...' :\n                    firstLine;\n                // Create cell label with styled type indicator\n                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';\n                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';\n                // Create menu item for this cell\n                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML\n                'select-cell', i.toString() // Store cell index in path\n                );\n                // Create styled content with HTML elements\n                const typeSpan = document.createElement('span');\n                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;\n                typeSpan.textContent = typeIndicator;\n                const execSpan = document.createElement('span');\n                execSpan.className = 'cell-exec-count';\n                execSpan.textContent = executionDisplay;\n                execSpan.style.marginRight = '8px';\n                const contentSpan = document.createElement('span');\n                contentSpan.className = 'cell-content-preview';\n                contentSpan.textContent = truncatedContent;\n                // Get the label span (first child of the menu item)\n                const labelSpan = cellItem.querySelector('span');\n                if (labelSpan) {\n                    labelSpan.textContent = ''; // Clear existing text\n                    labelSpan.appendChild(typeSpan);\n                    if (executionDisplay) {\n                        labelSpan.appendChild(execSpan);\n                    }\n                    labelSpan.appendChild(contentSpan);\n                }\n                // Construct full searchable text\n                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();\n                // Filter by search term if one is provided\n                if (searchTerm && !searchableText.includes(searchTerm)) {\n                    continue;\n                }\n                this.popupMenuContainer.appendChild(cellItem);\n                filteredCellCount++;\n            }\n            if (filteredCellCount === 0) {\n                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');\n                noMatchItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(noMatchItem);\n            }\n        }\n        catch (error) {\n            // Clean up loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading notebook cells:', error);\n        }\n    }\n    createMenuItem(text, actionId, path = '', description = '') {\n        const item = document.createElement('div');\n        item.className = 'jp-llm-ext-popup-menu-item';\n        item.dataset.actionId = actionId;\n        if (path) {\n            item.dataset.path = path;\n        }\n        item.onclick = (event) => this.handleMenuClick(event);\n        const labelSpan = document.createElement('span');\n        labelSpan.textContent = text;\n        item.appendChild(labelSpan);\n        if (description) {\n            const pathSpan = document.createElement('span');\n            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';\n            pathSpan.textContent = description;\n            pathSpan.style.fontSize = '0.85em';\n            pathSpan.style.color = 'var(--jp-ui-font-color2)';\n            pathSpan.style.marginLeft = '8px';\n            pathSpan.style.opacity = '0.8';\n            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed\n            item.appendChild(pathSpan);\n        }\n        return item;\n    }\n    async handleMenuClick(event) {\n        var _a;\n        const target = event.currentTarget;\n        const actionId = target.dataset.actionId;\n        const path = target.dataset.path || '';\n        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);\n        switch (actionId) {\n            case 'navigate-back':\n                this.navigateBackMenu();\n                break;\n            case 'insert-code': {\n                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;\n                if (selectedText) {\n                    // Show submenu for code insertion options\n                    const submenuItems = [\n                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },\n                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }\n                    ];\n                    // Replace current menu with submenu options\n                    this.popupMenuContainer.innerHTML = '';\n                    submenuItems.forEach(item => {\n                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                    // Add back button\n                    const backButton = this.createMenuItem('Back', 'navigate-back');\n                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';\n                    this.popupMenuContainer.appendChild(backButton);\n                    return; // Don't hide menu, wait for submenu selection\n                }\n                else {\n                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;\n                    if (cellContent) {\n                        this.callbacks.insertCode(cellContent);\n                    }\n                }\n                this.hidePopupMenu();\n                break;\n            }\n            case 'insert-plain-code': {\n                if (path) {\n                    this.callbacks.insertCode(path);\n                    this.hidePopupMenu();\n                }\n                break;\n            }\n            case 'collapse-code-ref': {\n                if (path && this.currentNotebook) {\n                    try {\n                        // Get notebook file name (without extension)\n                        const notebookPath = this.currentNotebook.context.path;\n                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';\n                        // Find current cell index and approximate line number\n                        const currentCell = this.currentNotebook.content.activeCell;\n                        if (!currentCell) {\n                            throw new Error('No active cell found');\n                        }\n                        // Get current cell index\n                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;\n                        // Estimate line number from cursor position\n                        let lineNumber = 1; // Default to line 1\n                        if (currentCell.editor) {\n                            const editor = currentCell.editor;\n                            const cursor = editor.getCursorPosition();\n                            if (cursor) {\n                                lineNumber = cursor.line + 1; // Convert to 1-indexed\n                            }\n                        }\n                        // Invoke the callback with all the information needed\n                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);\n                        this.hidePopupMenu();\n                    }\n                    catch (error) {\n                        console.error('Error creating collapsed code reference:', error);\n                        // Fallback to inserting code directly\n                        this.callbacks.insertCode(path);\n                        this.hidePopupMenu();\n                    }\n                }\n                else {\n                    // If something went wrong or no path provided, just insert as regular code\n                    if (path) {\n                        this.callbacks.insertCode(path);\n                    }\n                    this.hidePopupMenu();\n                }\n                break;\n            }\n            case 'browse-cells':\n                await this.navigateMenu('cells', '');\n                this.searchInput.value = '';\n                break;\n            case 'browse-files':\n                await this.navigateMenu('files', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'browse-directories':\n                await this.navigateMenu('directories', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'select-cell':\n                if (path) {\n                    const cellIndex = parseInt(path);\n                    if (!isNaN(cellIndex) && this.callbacks.insertCellByIndex) {\n                        this.callbacks.insertCellByIndex(cellIndex);\n                        this.hidePopupMenu();\n                    }\n                    else {\n                        console.error('POPUP: Invalid cell index or callback missing.');\n                    }\n                }\n                break;\n            case 'select-file':\n                if (path) {\n                    this.callbacks.insertFilePath(path);\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: File selected but path is missing.');\n                }\n                break;\n            case 'select-directory-navigate': // New action to navigate into dir when in file view\n                if (path) {\n                    // Clear the file cache for the specific directory to force a refresh\n                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;\n                    this.fileCache.delete(cacheKey);\n                    // Make sure we're passing the correct level type\n                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?\n                        this.currentMenuLevel : 'files';\n                    await this.navigateMenu(level, path);\n                    this.searchInput.value = ''; // Clear search on navigation\n                }\n                else {\n                    console.error('POPUP: Directory selected for navigation but path is missing.');\n                }\n                break;\n            case 'select-directory-callback': // New action to select dir when in directory view\n                if (path) {\n                    this.callbacks.insertDirectoryPath(path); // Use the callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: Directory selected for callback but path is missing.');\n                }\n                break;\n            case 'placeholder-action':\n                console.log('Placeholder action triggered.');\n                this.hidePopupMenu();\n                break;\n            case 'loading':\n            case 'empty':\n            case 'error':\n                break;\n            default:\n                console.warn('Unknown menu action:', actionId);\n                this.hidePopupMenu();\n                break;\n        }\n        event.stopPropagation();\n    }\n    async navigateMenu(level, path) {\n        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);\n        // Only push history if we are actually moving to a new state\n        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {\n            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n        }\n        this.currentMenuLevel = level;\n        this.currentMenuPath = path;\n        // Don't clear search on programmatic navigation (like back button)\n        // this.searchInput.value = ''; // Maybe keep search term?\n        await this.renderMenuContent();\n        // Focus search input after navigating to file/dir view\n        if (level === 'files' || level === 'directories') {\n            setTimeout(() => this.searchInput.focus(), 0);\n            this.selectedMenuItemIndex = -1; // Reset selection\n        }\n        else {\n            // Select first item if navigating back to top level\n            this.selectedMenuItemIndex = -1;\n            setTimeout(() => this.selectNextMenuItem(), 0);\n        }\n    }\n    navigateBackMenu() {\n        const previousState = this.menuHistory.pop();\n        if (previousState) {\n            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);\n            this.currentMenuLevel = previousState.level;\n            this.currentMenuPath = previousState.path;\n            // Don't clear search on back navigation\n            this.renderMenuContent().then(() => {\n                // Focus search input if going back to file/dir view\n                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                    setTimeout(() => this.searchInput.focus(), 0);\n                    this.selectedMenuItemIndex = -1; // Reset selection\n                }\n                else {\n                    // Select first item if going back to top level\n                    this.selectedMenuItemIndex = -1;\n                    setTimeout(() => this.selectNextMenuItem(), 0);\n                }\n            });\n        }\n        else {\n            console.log('POPUP: Already at the top level.');\n            this.hidePopupMenu();\n        }\n    }\n    async listCurrentDirectoryContents(basePath, filterType) {\n        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);\n        // Check cache first\n        const cacheKey = `${basePath}:${filterType || 'all'}`;\n        if (this.fileCache.has(cacheKey)) {\n            console.log('POPUP: Using cached directory contents');\n            return this.fileCache.get(cacheKey) || null;\n        }\n        try {\n            const effectivePath = basePath === '/' ? '' : basePath;\n            // Ensure trailing slash removed for consistency unless it's root\n            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;\n            // Result array that will hold all files and directories\n            let allResults = [];\n            // Get the base directory contents (non-recursive)\n            const baseContents = await this.docManager.services.contents.get(pathForApi || '');\n            if (baseContents.type !== 'directory') {\n                console.error('Path is not a directory:', basePath);\n                return null;\n            }\n            // Process base directory items\n            for (const item of baseContents.content) {\n                const itemType = item.type === 'directory' ? 'directory' : 'file';\n                // Add directories if we're listing directories or both\n                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {\n                    allResults.push({\n                        name: item.name,\n                        path: item.path,\n                        type: 'directory',\n                        relativePath: `./${item.name}`\n                    });\n                }\n                // Add files if we're listing files and the extension is allowed\n                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {\n                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();\n                    if (this.allowedExtensions.includes(fileExt)) {\n                        allResults.push({\n                            name: item.name,\n                            path: item.path,\n                            type: 'file',\n                            relativePath: `./${item.name}`\n                        });\n                    }\n                }\n            }\n            // Sort the results appropriately\n            allResults = allResults.sort((a, b) => {\n                // If listing directories only, sort alphabetically\n                if (filterType === 'directory') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing files only, sort alphabetically\n                if (filterType === 'file') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing both, sort directories first, then files alphabetically\n                if (a.type === 'directory' && b.type !== 'directory')\n                    return -1;\n                if (a.type !== 'directory' && b.type === 'directory')\n                    return 1;\n                return a.name.localeCompare(b.name);\n            });\n            // Cache the results for future use\n            this.fileCache.set(cacheKey, allResults);\n            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);\n            return allResults;\n        }\n        catch (error) {\n            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);\n            return null;\n        }\n    }\n    async setCurrentDirectoryPath() {\n        var _a;\n        let dirPath = null;\n        const app = globals_1.globals.app;\n        if (!app) {\n            console.error('POPUP: Application reference not available');\n            this.currentMenuPath = '';\n            return;\n        }\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                dirPath = this.getParentDirectory(path);\n                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {\n            const notebookPath = this.currentNotebook.context.path;\n            if (typeof notebookPath === 'string') {\n                dirPath = this.getParentDirectory(notebookPath);\n                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null) {\n            try {\n                const leftWidgets = Array.from(app.shell.widgets('left'));\n                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');\n                if (fileBrowserWidget && typeof ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path) === 'string') {\n                    dirPath = fileBrowserWidget.model.path;\n                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);\n                }\n                else {\n                    console.log('POPUP: File browser widget path not directly accessible.');\n                }\n            }\n            catch (e) {\n                console.warn('POPUP: Could not get path from file browser.', e);\n            }\n        }\n        if (dirPath === null) {\n            dirPath = '';\n            console.log('POPUP: Falling back to server root path.');\n        }\n        this.currentMenuPath = dirPath;\n        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);\n    }\n    getParentDirectory(path) {\n        if (!path)\n            return '';\n        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\\\\\'));\n        if (lastSlash === -1)\n            return ''; // No directory part, likely root or just a filename\n        return path.substring(0, lastSlash);\n    }\n    /**\n     * Handle keyboard navigation when the popup menu is shown\n     */\n    handleKeyDown(event) {\n        var _a;\n        // Skip if menu not visible\n        if (this.popupMenuContainer.style.display === 'none') {\n            return;\n        }\n        console.log(`POPUP KeyDown: Key='${event.key}', Target='${(_a = event.target) === null || _a === void 0 ? void 0 : _a.tagName}', SearchFocused='${document.activeElement === this.searchInput}'`);\n        // Special handling for when search input is focused\n        if (document.activeElement === this.searchInput) {\n            // The input's own keydown handler will handle most keys\n            // But for certain keys like arrow keys, we may need to move focus\n            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                // Move selection to first/last item\n                event.preventDefault();\n                event.stopPropagation();\n                // Delay before moving focus - this gives time for the search input's\n                // own keydown handler to process the key first\n                setTimeout(() => {\n                    if (event.key === 'ArrowDown') {\n                        this.searchInput.blur();\n                        this.selectNextMenuItem();\n                    }\n                    else { // ArrowUp\n                        this.searchInput.blur();\n                        this.selectPreviousMenuItem();\n                    }\n                }, 0);\n                return;\n            }\n            // IMPORTANT: For Backspace in search input, just return without handling\n            // Let the default behavior happen\n            if (event.key === 'Backspace') {\n                // Just perform default behavior in search input\n                return;\n            }\n            // Let all other keys be handled by the search input's own handler\n            return;\n        }\n        // From here, search input is NOT focused\n        const menuItems = this.getMenuItems();\n        switch (event.key) {\n            case 'ArrowDown':\n                if (menuItems.length > 0) {\n                    console.log('POPUP KeyDown (Menu Focused): ArrowDown');\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.selectNextMenuItem();\n                }\n                break;\n            case 'ArrowUp':\n                if (menuItems.length > 0) {\n                    console.log('POPUP KeyDown (Menu Focused): ArrowUp');\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.selectPreviousMenuItem();\n                }\n                break;\n            case 'Backspace':\n                console.log('POPUP KeyDown (Menu Focused): Backspace');\n                // Only prevent default and navigate back if we have history\n                if (this.menuHistory.length > 0) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.navigateBackMenu();\n                }\n                else {\n                    console.log('POPUP KeyDown (Menu Focused): No history, allowing Backspace default action');\n                    // Allow default - don't prevent or stop propagation\n                }\n                break;\n            case 'Enter':\n                console.log('POPUP KeyDown (Menu Focused): Enter');\n                // Only activate if an item is selected\n                if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    menuItems[this.selectedMenuItemIndex].click();\n                }\n                break;\n            case 'Tab':\n                console.log('POPUP KeyDown (Menu Focused): Tab');\n                // Basic Tab support: move focus between search and first/last item\n                event.preventDefault();\n                event.stopPropagation();\n                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                    this.searchInput.focus();\n                    this.deselectAllMenuItems(); // Deselect items when search gets focus via Tab\n                }\n                else {\n                    // Maybe close menu on Tab from top level? Or do nothing.\n                    this.hidePopupMenu();\n                }\n                break;\n            case 'Escape':\n                console.log('POPUP KeyDown (Menu Focused): Escape');\n                event.preventDefault();\n                event.stopPropagation();\n                this.hidePopupMenu();\n                break;\n            default:\n                console.log(`POPUP KeyDown (Menu Focused): Default key '${event.key}'`);\n                // If typing a character and in file/dir view, focus search\n                if ((this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') &&\n                    event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {\n                    event.preventDefault(); // Prevent character appearing elsewhere\n                    event.stopPropagation();\n                    this.searchInput.focus();\n                    // Manually append the typed character as focus happens after keydown default action\n                    this.searchInput.value += event.key;\n                    // Trigger input event manually to update list\n                    this.searchInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n                }\n                // Allow other keys (e.g., modifiers) to pass through if not handled\n                break;\n        }\n    }\n    updateSelectionHighlight() {\n        const menuItems = this.getMenuItems();\n        console.log(`POPUP updateSelectionHighlight: Highlighting index ${this.selectedMenuItemIndex} among ${menuItems.length} items.`);\n        menuItems.forEach((item, index) => {\n            if (index === this.selectedMenuItemIndex) {\n                if (!item.classList.contains('selected')) {\n                    item.classList.add('selected');\n                    console.log(`POPUP updateSelectionHighlight: Added 'selected' to item ${index}`);\n                    // Ensure item is visible\n                    item.scrollIntoView({ block: 'nearest' });\n                }\n            }\n            else {\n                if (item.classList.contains('selected')) {\n                    item.classList.remove('selected');\n                    console.log(`POPUP updateSelectionHighlight: Removed 'selected' from item ${index}`);\n                }\n            }\n        });\n    }\n    deselectAllMenuItems() {\n        const menuItems = this.getMenuItems();\n        menuItems.forEach(item => item.classList.remove('selected'));\n        this.selectedMenuItemIndex = -1;\n    }\n    selectNextMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (!menuItems.length) {\n            console.log('POPUP selectNext: No items to select.');\n            this.selectedMenuItemIndex = -1; // Ensure index is reset\n            return;\n        }\n        const oldIndex = this.selectedMenuItemIndex;\n        // Deselect current first is handled by updateSelectionHighlight\n        // Move to the next item or loop back to the first\n        this.selectedMenuItemIndex = (this.selectedMenuItemIndex + 1) % menuItems.length;\n        console.log(`POPUP selectNext: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);\n        this.updateSelectionHighlight();\n    }\n    selectPreviousMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (!menuItems.length) {\n            console.log('POPUP selectPrevious: No items to select.');\n            this.selectedMenuItemIndex = -1; // Ensure index is reset\n            return;\n        }\n        const oldIndex = this.selectedMenuItemIndex;\n        // Deselect current first is handled by updateSelectionHighlight\n        // Move to the previous item or loop to the last\n        this.selectedMenuItemIndex = this.selectedMenuItemIndex <= 0 ?\n            menuItems.length - 1 : this.selectedMenuItemIndex - 1;\n        console.log(`POPUP selectPrevious: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);\n        this.updateSelectionHighlight();\n    }\n    /**\n     * Get all interactive menu items\n     */\n    getMenuItems() {\n        const items = Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));\n        // Filter out non-interactive items like loading, empty, error\n        return items.filter(item => {\n            const actionId = item.dataset.actionId;\n            return actionId !== 'loading' && actionId !== 'empty' && actionId !== 'error';\n        });\n    }\n    /**\n     * Update popup position, keeping the bottom edge fixed at the anchor point\n     */\n    updatePopupPosition() {\n        var _a, _b;\n        // Make sure anchor points are defined\n        const anchorX = (_a = this._anchorX) !== null && _a !== void 0 ? _a : 0;\n        const anchorY = (_b = this._anchorY) !== null && _b !== void 0 ? _b : 0;\n        // Position the popup menu\n        this.popupMenuContainer.style.position = 'absolute';\n        this.popupMenuContainer.style.left = `${anchorX}px`;\n        // Show the menu so we can calculate its height\n        this.popupMenuContainer.style.display = 'block';\n        // Get the actual height after rendering\n        const menuHeight = this.popupMenuContainer.offsetHeight;\n        // Add a small gap (10px) between the bottom of the menu and the trigger point\n        const gap = 10;\n        // Position above the cursor/button to keep bottom edge at the anchor point:\n        // y - gap = bottom edge of popup, so popup top = y - gap - menuHeight\n        this.popupMenuContainer.style.top = `${anchorY - gap - menuHeight}px`;\n        console.log(`POPUP: Positioned menu at height ${menuHeight}px with bottom at ${anchorY - gap}px`);\n    }\n}\nexports.PopupMenuManager = PopupMenuManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsHandler = void 0;\n// import { SettingsModal } from '../ui/settings-modal'; // Commented out - unused import\n/**\n * Handles the logic related to the settings modal:\n * displaying, hiding, populating, saving, and showing feedback.\n */\nclass SettingsHandler {\n    constructor(state, \n    // successCallback: (message: string) => void, // Commented out - unused parameter\n    settingsModalContainer, uiManager // Pass UIManager for notifications\n    ) {\n        this.state = state;\n        // this.apiClient = apiClient; // Removed: unused variable\n        // this.successCallback = successCallback; // Commented out - unused assignment\n        this.settingsModalContainer = settingsModalContainer;\n        this.uiManager = uiManager;\n        // Attach internal listeners if the modal has its own save/cancel buttons\n        // This assumes the modal element was created with listeners calling these methods.\n        // If createSettingsModalElement in ui/settings-modal.ts attaches listeners that \n        // call callbacks passed during creation, then this handler doesn't need \n        // to attach listeners directly, just provide the callbacks (e.g., this.saveSettings.bind(this)).\n        // For now, let's assume the callbacks passed to createSettingsModalElement handle this.\n    }\n    /**\n     * Populates the settings form with current values and displays the modal.\n     */\n    showModal() {\n        const currentSettings = this.state.getSettings();\n        if (currentSettings) {\n            try {\n                // Query elements within the modal container\n                this.settingsModalContainer.querySelector('#settings-provider').value = currentSettings.provider;\n                this.settingsModalContainer.querySelector('#settings-api-key').value = currentSettings.apiKey;\n                this.settingsModalContainer.querySelector('#settings-api-url').value = currentSettings.apiUrl;\n                this.settingsModalContainer.querySelector('#settings-rules').value = currentSettings.rules;\n            }\n            catch (error) {\n                console.error('Error populating settings form:', error);\n                // Optionally show an error to the user\n            }\n        }\n        this.settingsModalContainer.style.display = 'flex';\n    }\n    /**\n     * Hides the settings modal.\n     */\n    hideModal() {\n        this.settingsModalContainer.style.display = 'none';\n    }\n    /**\n     * Reads values from the form, saves them using SettingsState,\n     * updates the ApiClient, hides the modal, and shows a success notification.\n     * This method is intended to be called by the modal's save button listener.\n     */\n    saveSettings() {\n        var _a, _b, _c, _d;\n        // Get values from form fields within the modal container\n        const provider = (_a = this.settingsModalContainer.querySelector('#settings-provider')) === null || _a === void 0 ? void 0 : _a.value;\n        const key = (_b = this.settingsModalContainer.querySelector('#settings-api-key')) === null || _b === void 0 ? void 0 : _b.value;\n        const url = (_c = this.settingsModalContainer.querySelector('#settings-api-url')) === null || _c === void 0 ? void 0 : _c.value;\n        const rules = (_d = this.settingsModalContainer.querySelector('#settings-rules')) === null || _d === void 0 ? void 0 : _d.value;\n        // Basic validation\n        if (provider === undefined || key === undefined || url === undefined || rules === undefined) {\n            console.error(\"Could not find all settings input elements.\");\n            this.showNotification('Error: Could not save settings. Input elements missing.', 'error');\n            return;\n        }\n        const settings = { provider, apiKey: key, apiUrl: url, rules };\n        try {\n            // Save settings using SettingsState\n            this.state.saveSettings(settings);\n            console.log('Settings saved via SettingsState:', settings);\n            // Reconfigure ApiClient instance\n            // TODO: The ApiClient should ideally observe the SettingsState \n            // or have a dedicated update method instead of creating a new instance.\n            // For now, we assume the main widget will recreate/update the ApiClient \n            // or pass an update callback.\n            // Example: this.apiClient.updateConfig(settings.apiUrl || undefined);\n            console.log('API Client needs reconfiguration with new settings.');\n            this.hideModal();\n            this.showNotification('Settings saved successfully', 'success');\n        }\n        catch (error) {\n            console.error('Error saving settings:', error);\n            this.showNotification(`Error saving settings: ${error}`, 'error');\n        }\n    }\n    /**\n     * Displays a temporary notification message.\n     * Relies on UIManager to provide the actual notification mechanism.\n     */\n    showNotification(message, type) {\n        // Delegate notification display to UIManager or a dedicated notification service\n        if (this.uiManager && typeof this.uiManager.showNotification === 'function') {\n            this.uiManager.showNotification(message, type);\n        }\n        else {\n            // Fallback or log if UIManager doesn't support notifications yet\n            console.log(`Notification (${type}): ${message}`);\n            // The old popSaveSuccess logic requires direct access to the widget node,\n            // which this handler shouldn't have. This needs to be handled by the UI layer.\n        }\n    }\n}\nexports.SettingsHandler = SettingsHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setupShortcuts = setupShortcuts;\nexports.removeShortcuts = removeShortcuts;\nconst notebook_integration_1 = require(\"../utils/notebook-integration\");\nlet _handleKeyDown = null;\n/**\n * Sets up global keyboard shortcuts for the extension.\n *\n * @param inputHandler Instance of InputHandler to interact with input state/methods.\n * @param popupMenuManager Instance of PopupMenuManager.\n * @param callbacks Object containing callback functions for UI interactions.\n */\nfunction setupShortcuts(inputHandler, // Pass InputHandler instance directly\npopupMenuManager, callbacks) {\n    if (_handleKeyDown) {\n        console.warn('Shortcuts already set up. Removing previous listener.');\n        removeShortcuts();\n    }\n    _handleKeyDown = (event) => {\n        const { showIndicator, appendToInput, showWidget, focusInput } = callbacks;\n        // Check for @ key\n        if (event.key === '@') {\n            // Prevent default browser behavior\n            event.preventDefault();\n            event.stopPropagation();\n            // Check if the input field is the active element\n            // We rely on InputHandler potentially managing focus or assume it is handled elsewhere\n            const inputField = document.activeElement; // A bit fragile\n            if (inputField && inputField.tagName === 'TEXTAREA' && inputField.classList.contains('jp-llm-ext-input-field')) {\n                // Get cursor position\n                const cursorPosition = inputField.selectionStart || 0;\n                const textBeforeCursor = inputField.value.substring(0, cursorPosition);\n                // Calculate position to show menu (simplified example)\n                const inputRect = inputField.getBoundingClientRect();\n                const lineHeight = parseInt(window.getComputedStyle(inputField).lineHeight) || 20;\n                const linesBeforeCursor = (textBeforeCursor.match(/\\n/g) || []).length;\n                const cursorTop = inputRect.top + (linesBeforeCursor * lineHeight);\n                const left = inputRect.left + 10; // Simplified horizontal position\n                // Insert @ symbol at cursor position\n                const newValue = inputField.value.substring(0, cursorPosition) +\n                    '@' +\n                    inputField.value.substring(cursorPosition);\n                inputField.value = newValue;\n                // Update has @ symbol flag via InputHandler\n                inputHandler.setHasAtSymbol(true);\n                // Move cursor after the @ symbol\n                inputField.selectionStart = cursorPosition + 1;\n                inputField.selectionEnd = cursorPosition + 1;\n                // Show the popup menu\n                popupMenuManager.showPopupMenu(left + 60, cursorTop - 20); // Adjust positioning as needed\n                showIndicator('Browse cells, code, files, and more');\n            }\n        }\n        // Check for Ctrl+L (insert selection or cell)\n        else if (event.ctrlKey && event.key.toLowerCase() === 'l') {\n            event.preventDefault();\n            event.stopPropagation();\n            const selected = (0, notebook_integration_1.getSelectedText)();\n            if (selected) {\n                appendToInput(`@code ${selected}`); // Use callback\n                showIndicator('Selected code inserted');\n            }\n            else {\n                const cellContent = (0, notebook_integration_1.getCurrentCellContent)();\n                if (cellContent) {\n                    appendToInput(`@cell ${cellContent}`); // Use callback\n                    showIndicator('Cell content inserted');\n                }\n            }\n            // Ensure the sidebar is visible and input is focused\n            showWidget(); // Use callback\n            focusInput(); // Use callback\n        }\n    };\n    // Add the event listener to the document\n    document.addEventListener('keydown', _handleKeyDown);\n}\n/**\n * Removes the global keyboard shortcut listener.\n */\nfunction removeShortcuts() {\n    if (_handleKeyDown) {\n        document.removeEventListener('keydown', _handleKeyDown);\n        _handleKeyDown = null;\n        console.log('Removed keyboard shortcuts.');\n    }\n    else {\n        console.warn('Attempted to remove shortcuts, but none were active.');\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\nconst launcher_1 = require(\"@jupyterlab/launcher\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst docmanager_1 = require(\"@jupyterlab/docmanager\");\nconst sidebar_widget_1 = require(\"./sidebar-widget\");\nconst globals_1 = require(\"./core/globals\");\nconst commands_1 = require(\"./commands\");\nconst cell_context_tracker_1 = require(\"./cell-context-tracker\");\n// import { ApiClient } from './api-client';\n// Import the main CSS file\nrequire(\"../style/index.css\");\n// Export ApiClient for use by other components\nvar api_client_1 = require(\"./core/api-client\");\nObject.defineProperty(exports, \"ApiClient\", { enumerable: true, get: function () { return api_client_1.ApiClient; } });\n/**\n * Initialization data for the jupyter-simple-extension extension.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references\n        (0, globals_1.initGlobals)(jupyterApp, tracker);\n        // Initialize cell context tracker\n        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget\n        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands\n        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexports.default = plugin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSidebarWidget = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst icons_1 = require(\"./core/icons\");\nconst api_client_1 = require(\"./core/api-client\");\nconst popup_menu_manager_1 = require(\"./handlers/popup-menu-manager\");\nconst shortcut_handler_1 = require(\"./handlers/shortcut-handler\");\nconst layout_builder_1 = require(\"./ui/layout-builder\");\nconst settings_modal_1 = require(\"./ui/settings-modal\");\nconst chat_state_1 = require(\"./state/chat-state\");\nconst settings_state_1 = require(\"./state/settings-state\");\nconst input_handler_1 = require(\"./handlers/input-handler\");\nconst message_handler_1 = require(\"./handlers/message-handler\");\nconst history_handler_1 = require(\"./handlers/history-handler\");\nconst settings_handler_1 = require(\"./handlers/settings-handler\");\nconst ui_manager_1 = require(\"./ui/ui-manager\");\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// --- Import Utility Functions ---\nconst clipboard_1 = require(\"./utils/clipboard\");\nconst notebook_integration_1 = require(\"./utils/notebook-integration\");\nconst code_ref_widget_1 = require(\"./ui/code-ref-widget\");\n/**\n * Main sidebar widget for the AI chat interface - Now acts as an orchestrator.\n */\nclass SimpleSidebarWidget extends widgets_1.Widget {\n    constructor(docManager) {\n        super();\n        // Placeholder for handler methods used in UIManager callbacks\n        this.handleNewChat = () => {\n            var _a;\n            console.log('Handle New Chat clicked');\n            const newChat = this.chatState.createNewChat();\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);\n        };\n        this.handleToggleHistory = () => {\n            console.log('Handle Toggle History clicked');\n            this.historyHandler.toggleHistoryView();\n        };\n        this.handleSendMessage = () => {\n            // 1. Get the current text from the input field via UIManager or LayoutElements\n            const text = this.layoutElements.inputField.value;\n            if (!text.trim())\n                return; // Don't send empty messages\n            // 2. Get the markdown state from UIManager\n            const isMarkdown = this.uiManager.getIsMarkdownMode();\n            console.log(`[Widget] handleSendMessage: Text='${text}', Markdown=${isMarkdown}`); // Debug log\n            // 3. Call the MessageHandler's send method with text and state\n            this.messageHandler.handleSendMessage(text, isMarkdown);\n            // NOTE: No need to dispatch event anymore. \n            // The input clearing is handled inside messageHandler.handleSendMessage now.\n        };\n        this.handleShowSettings = (event) => {\n            console.log('Handle Show Settings clicked');\n            this.settingsHandler.showModal();\n        };\n        this.handleShowPopupMenu = (event, targetButton) => {\n            console.log('Handle Show Popup Menu clicked');\n            const rect = targetButton.getBoundingClientRect();\n            this.popupMenuManager.showPopupMenu(rect.left, rect.bottom + 5);\n        };\n        this.handleUpdateTitle = () => {\n            var _a;\n            const newTitle = ((_a = this.layoutElements.titleInput) === null || _a === void 0 ? void 0 : _a.value) || 'Chat';\n            console.log('Handle Update Title called:', newTitle);\n            this.chatState.updateCurrentChatTitle(newTitle);\n        };\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = icons_1.extensionIcon;\n        this.title.closable = true;\n        this.addClass('jp-llm-ext-sidebar');\n        // --- 1. Initialize Core Components & State ---\n        this.settingsState = new settings_state_1.SettingsState();\n        const initialSettings = this.settingsState.getSettings();\n        this.apiClient = new api_client_1.ApiClient((initialSettings === null || initialSettings === void 0 ? void 0 : initialSettings.apiUrl) || undefined);\n        this.chatState = new chat_state_1.ChatState();\n        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {\n            insertCode: (code) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@code ${code}`); },\n            insertCell: (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@cell ${content}`); },\n            insertFilePath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@file ${path}`); },\n            insertDirectoryPath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@dir ${path}`); },\n            getSelectedText: notebook_integration_1.getSelectedText,\n            getCurrentCellContent: notebook_integration_1.getCurrentCellContent,\n            insertCellByIndex: (index) => (0, notebook_integration_1.insertCellContentByIndex)(index, (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@${content}`); }),\n            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {\n                if (!this.inputHandler)\n                    return;\n                const refId = this.inputHandler.addCodeReference(code);\n                const placeholder = (0, code_ref_widget_1.createCodeRefPlaceholder)(refId, notebookName, lineNumber);\n                this.inputHandler.appendToInput(placeholder);\n            }\n        });\n        // --- 2. Define Callbacks (used by buildLayout and Handlers) ---\n        // Callbacks for UI actions (passed to buildLayout)\n        const createNewChatCallback = () => {\n            var _a;\n            const newChat = this.chatState.createNewChat();\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);\n        };\n        const toggleHistoryCallback = () => {\n            var _a;\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.toggleHistoryView();\n        };\n        const showSettingsCallback = () => {\n            var _a;\n            (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.showModal();\n        };\n        const updateTitleCallback = (newTitle) => {\n            var _a;\n            this.chatState.updateCurrentChatTitle(newTitle);\n            (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showNotification('Chat title updated', 'info');\n        };\n        const showPopupMenuCallback = (event) => {\n            const rect = event.target.getBoundingClientRect();\n            this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);\n            event.preventDefault();\n            event.stopPropagation();\n        };\n        const sendMessageViaButtonCallback = () => {\n            const inputElement = this.layoutElements.inputField;\n            const event = new KeyboardEvent('keypress', { key: 'Enter', bubbles: true });\n            inputElement.dispatchEvent(event);\n        };\n        const toggleMarkdownModeCallback = (isMarkdown) => {\n            var _a;\n            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.setMarkdownMode(isMarkdown);\n        };\n        const toggleExpandInputCallback = (button) => {\n            var _a;\n            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.toggleInputExpansion();\n        };\n        // Callbacks for Message Rendering (passed to MessageHandler -> UIManager -> renderers)\n        const messageRendererCallbacks = {\n            showCopyFeedback: (button, success = true) => {\n                const originalHTML = button.innerHTML;\n                button.innerHTML = success ? 'Copied!' : 'Failed!';\n                button.disabled = true;\n                setTimeout(() => {\n                    button.innerHTML = originalHTML;\n                    button.disabled = false;\n                }, 1000);\n            },\n            addMessageToCell: notebook_integration_1.addMessageToCell,\n            copyToClipboard: (text, feedbackCb) => {\n                navigator.clipboard.writeText(text).then(() => feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb()).catch(err => {\n                    console.error('Failed to copy text: ', err);\n                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();\n                });\n            },\n            copyImageToClipboard: (imageUrl, feedbackCb) => {\n                (0, clipboard_1.copyImageToClipboard)(imageUrl, (success) => {\n                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();\n                });\n            },\n            copyMessageToClipboard: (text, feedbackCb) => {\n                (0, clipboard_1.copyMessageToClipboard)(text, (success) => {\n                    feedbackCb();\n                });\n            },\n            handleConfirmInterrupt: () => {\n                var _a;\n                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('confirmed');\n            },\n            handleRejectInterrupt: () => {\n                var _a;\n                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('rejected');\n            }\n        };\n        const settingsModalCallbacks = {\n            handleSave: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.saveSettings(); },\n            handleCancel: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.hideModal(); }\n        };\n        const historyHandlerCallbacks = {\n            updateTitleInput: (title) => this.uiManager.updateTitleInput(title),\n            clearMessageContainer: () => this.uiManager.clearMessageContainer(),\n            addRenderedMessage: (messageElement) => this.uiManager.addChatMessageElement(messageElement)\n        };\n        const inputHandlerCallbacks = {\n            handleSendMessage: (message, isMarkdown) => {\n                if (this.messageHandler) {\n                    this.messageHandler.handleSendMessage(message, isMarkdown);\n                }\n                else {\n                    console.error('MessageHandler not initialized when trying to send message from InputHandler');\n                }\n            },\n            showPopupMenu: (left, top) => this.popupMenuManager.showPopupMenu(left, top),\n            hidePopupMenu: () => this.popupMenuManager.hidePopupMenu(),\n            updatePlaceholder: (isMarkdown) => {\n                this.layoutElements.inputField.placeholder = isMarkdown ? 'Enter markdown...' : 'Ask anything...';\n            },\n            toggleInputExpansionUI: (isExpanded) => {\n                const button = this.layoutElements.expandButton;\n                // Clear existing content (text or old icon)\n                while (button.firstChild) {\n                    button.removeChild(button.firstChild);\n                }\n                // Add the appropriate icon using LabIcon.resolve\n                const icon = isExpanded\n                    ? ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-up' })\n                    : ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-down' });\n                icon.element({ container: button, tag: 'span' }); // Add icon to button\n                // Update title for accessibility\n                button.title = isExpanded ? 'Collapse input' : 'Expand input';\n            },\n            getCodeRefMap: () => { var _a; return ((_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.getCodeReferenceMap()) || new Map(); },\n            resetCodeRefMap: () => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.resetCodeReferences(); }\n        };\n        const shortcutCallbacks = {\n            showIndicator: (text) => { var _a; return (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showIndicator(text); },\n            appendToInput: (text) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(text); },\n            showWidget: () => { if (this.isHidden) {\n                this.show();\n            } },\n            focusInput: () => { var _a, _b; return (_b = (_a = this.layoutElements) === null || _a === void 0 ? void 0 : _a.inputField) === null || _b === void 0 ? void 0 : _b.focus(); }\n        };\n        // --- 3. Build UI Layout ---\n        this.layoutElements = (0, layout_builder_1.buildLayout)({\n            onNewChatClick: createNewChatCallback,\n            onHistoryToggleClick: toggleHistoryCallback,\n            onSettingsClick: showSettingsCallback,\n            onTitleChange: updateTitleCallback,\n            onAtButtonClick: showPopupMenuCallback,\n            onSendMessageClick: sendMessageViaButtonCallback,\n            onMarkdownToggleChange: toggleMarkdownModeCallback,\n            onExpandToggleClick: toggleExpandInputCallback,\n        });\n        this.settingsModalContainer = (0, settings_modal_1.createSettingsModalElement)(settingsModalCallbacks);\n        // --- Initialize State Managers ---\n        this.chatState = new chat_state_1.ChatState();\n        this.settingsState = new settings_state_1.SettingsState();\n        // --- Initialize Core Components ---\n        this.apiClient = new api_client_1.ApiClient();\n        // --- Initialize UI Manager (needs dependencies) ---\n        const uiManagerCallbacks = {\n            handleNewChat: this.handleNewChat,\n            handleToggleHistory: this.handleToggleHistory,\n            handleSendMessage: this.handleSendMessage,\n            handleShowSettings: this.handleShowSettings,\n            handleShowPopupMenu: this.handleShowPopupMenu,\n            handleUpdateTitle: this.handleUpdateTitle\n        };\n        this.uiManager = new ui_manager_1.UIManager(this.popupMenuManager, uiManagerCallbacks, this.layoutElements);\n        // --- 4. Initialize Handlers (using UI elements and core components) ---\n        this.inputHandler = new input_handler_1.InputHandler(this.layoutElements.inputField, inputHandlerCallbacks);\n        this.messageHandler = new message_handler_1.MessageHandler(this.apiClient, this.chatState, this.uiManager, messageRendererCallbacks, this.inputHandler);\n        this.historyHandler = new history_handler_1.HistoryHandler(this.chatState, this.uiManager, historyHandlerCallbacks, messageRendererCallbacks);\n        this.settingsHandler = new settings_handler_1.SettingsHandler(this.settingsState, this.settingsModalContainer, this.uiManager);\n        // --- 5. Final Setup (Attach event listeners, connect signals, etc.) ---\n        const initialChatId = this.chatState.getCurrentChatId();\n        if (initialChatId) {\n            this.historyHandler.loadChat(initialChatId);\n        }\n        else {\n            const newChat = this.chatState.createNewChat();\n            this.historyHandler.loadChat(newChat.id);\n        }\n        (0, shortcut_handler_1.setupShortcuts)(this.inputHandler, this.popupMenuManager, shortcutCallbacks);\n        this.node.appendChild(this.layoutElements.mainElement);\n        this.node.appendChild(this.settingsModalContainer);\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        var _a, _b;\n        if (this.isDisposed) {\n            return;\n        }\n        (0, shortcut_handler_1.removeShortcuts)();\n        (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this.popupMenuManager) === null || _b === void 0 ? void 0 : _b.dispose();\n        super.dispose();\n    }\n} // End of SimpleSidebarWidget class\nexports.SimpleSidebarWidget = SimpleSidebarWidget;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatState = void 0;\nconst uuid_1 = require(\"uuid\");\n/**\n * Manages the state of chat history and the currently active chat.\n */\nclass ChatState {\n    constructor() {\n        var _a;\n        this.chatHistory = [];\n        this.currentChatId = null;\n        // Potential: Load initial state from storage if persistence is added later\n        if (this.chatHistory.length === 0) {\n            this.createNewChat('Welcome Chat'); // Create an initial chat if none exists\n        }\n        else {\n            this.currentChatId = ((_a = this.chatHistory[0]) === null || _a === void 0 ? void 0 : _a.id) || null; // Set current chat to the first one\n        }\n    }\n    /**\n     * Creates a new chat session and sets it as the current chat.\n     * @param title - The initial title for the new chat.\n     * @returns The newly created chat item.\n     */\n    createNewChat(title = 'New Chat') {\n        const chatId = `chat-${(0, uuid_1.v4)()}`; // Use UUID for better uniqueness\n        const newChat = {\n            id: chatId,\n            title: title,\n            messages: []\n            // createdAt: new Date() \n        };\n        this.chatHistory.push(newChat);\n        this.currentChatId = chatId;\n        console.log('Created new chat:', newChat);\n        return newChat;\n    }\n    /**\n     * Sets the currently active chat ID.\n     * @param chatId - The ID of the chat to set as current.\n     */\n    setCurrentChatId(chatId) {\n        if (this.chatHistory.some(chat => chat.id === chatId)) {\n            this.currentChatId = chatId;\n        }\n        else {\n            console.warn(`Chat ID ${chatId} not found in history.`);\n        }\n    }\n    /**\n     * Gets the ID of the currently active chat.\n     * @returns The current chat ID or null if none is active.\n     */\n    getCurrentChatId() {\n        return this.currentChatId;\n    }\n    /**\n     * Retrieves a specific chat by its ID.\n     * @param chatId - The ID of the chat to retrieve.\n     * @returns The chat item or undefined if not found.\n     */\n    getChatById(chatId) {\n        return this.chatHistory.find(chat => chat.id === chatId);\n    }\n    /**\n     * Retrieves the currently active chat item.\n     * @returns The current chat item or undefined if no chat is active or found.\n     */\n    getCurrentChat() {\n        if (!this.currentChatId) {\n            return undefined;\n        }\n        return this.getChatById(this.currentChatId);\n    }\n    /**\n     * Updates the title of the currently active chat.\n     * @param newTitle - The new title for the chat.\n     */\n    updateCurrentChatTitle(newTitle) {\n        const currentChat = this.getCurrentChat();\n        if (currentChat) {\n            currentChat.title = newTitle;\n            console.log(`Updated title for chat ${this.currentChatId} to \"${newTitle}\"`);\n        }\n        else {\n            console.warn('Cannot update title: No current chat selected.');\n        }\n    }\n    /**\n     * Adds a message to the currently active chat.\n     * @param message - The message object to add.\n     */\n    addMessageToCurrentChat(message) {\n        const currentChat = this.getCurrentChat();\n        if (currentChat) {\n            currentChat.messages.push(message);\n        }\n        else {\n            console.warn('Cannot add message: No current chat selected.');\n        }\n    }\n    /**\n     * Gets all messages from the currently active chat.\n     * @returns An array of messages or an empty array if no chat is active.\n     */\n    getCurrentChatMessages() {\n        const currentChat = this.getCurrentChat();\n        return currentChat ? currentChat.messages : [];\n    }\n    /**\n     * Gets the entire chat history.\n     * @returns An array of all chat history items.\n     */\n    getChatHistory() {\n        return [...this.chatHistory]; // Return a copy to prevent direct modification\n    }\n}\nexports.ChatState = ChatState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsState = void 0;\nconst SETTINGS_STORAGE_KEY = 'jp-llm-ext-settings';\n/**\n * Manages loading and saving application settings to localStorage.\n */\nclass SettingsState {\n    constructor() {\n        this.currentSettings = null;\n        this.currentSettings = this.loadSettings();\n    }\n    /**\n     * Loads settings from localStorage.\n     * @returns The loaded settings or null if none are saved or an error occurs.\n     */\n    loadSettings() {\n        const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);\n        if (savedSettings) {\n            try {\n                const settings = JSON.parse(savedSettings);\n                // Basic validation (can be expanded)\n                if (settings && settings.provider) {\n                    this.currentSettings = settings;\n                    console.log('Loaded settings:', this.currentSettings);\n                    return this.currentSettings;\n                }\n            }\n            catch (error) {\n                console.error('Error loading saved settings:', error);\n                localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear corrupted data\n            }\n        }\n        console.log('No valid settings found in localStorage.');\n        return null;\n    }\n    /**\n     * Saves the provided settings to localStorage.\n     * @param settings - The settings object to save.\n     */\n    saveSettings(settings) {\n        try {\n            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));\n            this.currentSettings = Object.assign({}, settings); // Update internal state\n            console.log('Settings saved:', this.currentSettings);\n        }\n        catch (error) {\n            console.error('Error saving settings:', error);\n            // Optional: Notify user of save failure\n        }\n    }\n    /**\n     * Gets the currently loaded settings.\n     * @returns The current settings object or null if not loaded.\n     */\n    getSettings() {\n        return this.currentSettings ? Object.assign({}, this.currentSettings) : null; // Return a copy\n    }\n    /**\n     * Gets a specific setting value.\n     * @param key - The key of the setting to retrieve.\n     * @returns The value of the setting or undefined if not found.\n     */\n    getSetting(key) {\n        return this.currentSettings ? this.currentSettings[key] : undefined;\n    }\n}\nexports.SettingsState = SettingsState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createCodeRefWidgetHTML = createCodeRefWidgetHTML;\nexports.attachCodeRefEventListeners = attachCodeRefEventListeners;\nexports.defaultCodeRefToggleLogic = defaultCodeRefToggleLogic;\nexports.createCodeRefPlaceholder = createCodeRefPlaceholder;\nconst dom_elements_1 = require(\"./dom-elements\");\n/**\n * Creates the HTML element for a collapsible code reference widget.\n *\n * @param data - The data for the code reference.\n * @returns The HTMLElement representing the code reference widget.\n */\nfunction createCodeRefWidgetHTML(data) {\n    const widget = (0, dom_elements_1.createSpan)({\n        classes: 'jp-llm-ext-code-ref-widget',\n        attributes: {\n            'data-ref-id': data.refId,\n            'data-code': encodeURIComponent(data.code), // Store original code safely\n            'data-ref': data.codeRef\n        }\n    });\n    const label = (0, dom_elements_1.createSpan)({\n        classes: 'jp-llm-ext-code-ref-label',\n        text: data.codeRef\n    });\n    const toggleButton = (0, dom_elements_1.createButton)({\n        classes: 'jp-llm-ext-code-ref-toggle',\n        text: '', // Right-pointing triangle initially\n        attributes: { title: 'Expand/collapse code' }\n    });\n    const content = (0, dom_elements_1.createSpan)({\n        classes: 'jp-llm-ext-code-ref-content',\n        text: data.code, // Display the raw code for now\n        style: { display: 'none' } // Hidden initially\n    });\n    // Assemble the widget\n    widget.appendChild(label);\n    widget.appendChild(toggleButton);\n    widget.appendChild(content);\n    return widget;\n}\n/**\n * Attaches event listeners (specifically click for toggle) to a code ref widget.\n *\n * @param element - The code ref widget HTMLElement.\n * @param toggleCallback - A function to call when the toggle button is clicked.\n */\nfunction attachCodeRefEventListeners(element, toggleCallback) {\n    const toggleButton = element.querySelector('.jp-llm-ext-code-ref-toggle');\n    const contentElement = element.querySelector('.jp-llm-ext-code-ref-content');\n    if (toggleButton && contentElement) {\n        toggleButton.addEventListener('click', (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            toggleCallback(toggleButton, contentElement);\n        });\n    }\n}\n/**\n * Default logic for toggling the visibility of the code ref content.\n * This can be passed as the callback to attachCodeRefEventListeners.\n *\n * @param toggleButton - The button element that was clicked.\n * @param contentElement - The content element to toggle.\n */\nfunction defaultCodeRefToggleLogic(toggleButton, contentElement) {\n    const isVisible = contentElement.style.display !== 'none';\n    contentElement.style.display = isVisible ? 'none' : 'block'; // Or 'inline-block'/'inline' depending on desired layout\n    toggleButton.textContent = isVisible ? '' : ''; // Update triangle direction\n}\n/**\n * Creates a textual placeholder for a code reference.\n *\n * @param refId - The unique identifier for the reference (e.g., \"ref-1\").\n * @param notebookName - The name of the notebook (optional, for future display enhancements).\n * @param lineNumber - The starting line number of the code (optional, for future display enhancements).\n * @returns A string placeholder like \"[ref-1]\".\n */\nfunction createCodeRefPlaceholder(refId, notebookName, // Keep optional for now\nlineNumber // Keep optional for now\n) {\n    // Keep it simple for now, just the ID.\n    // Display details like notebook/line could be added later if needed.\n    return `[${refId}]`;\n}\n","\"use strict\";\n// import { ReadonlyPartialJSONObject } from '@lumino/coreutils';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDiv = createDiv;\nexports.createButton = createButton;\nexports.createSpan = createSpan;\nexports.createTextArea = createTextArea;\nexports.createInputElement = createInputElement;\nexports.createImageElement = createImageElement;\nexports.createAnchorElement = createAnchorElement;\nexports.createLabelElement = createLabelElement;\nexports.createFormElement = createFormElement;\n/**\n * Generic function to create an HTMLElement.\n *\n * @param tagName - The HTML tag name (e.g., 'div', 'button').\n * @param options - Optional configuration for the element.\n * @returns The created HTMLElement.\n */\nfunction createElement(tagName, options = {}) {\n    const element = document.createElement(tagName);\n    if (options.id) {\n        element.id = options.id;\n    }\n    if (options.classes) {\n        const classesToAdd = Array.isArray(options.classes)\n            ? options.classes\n            : options.classes.split(' ').filter(c => c);\n        element.classList.add(...classesToAdd);\n    }\n    if (options.text) {\n        element.textContent = options.text;\n    }\n    else if (options.html) {\n        element.innerHTML = options.html; // Be cautious with HTML injection\n    }\n    if (options.attributes) {\n        for (const key in options.attributes) {\n            if (options.attributes.hasOwnProperty(key)) {\n                element.setAttribute(key, options.attributes[key]);\n            }\n        }\n    }\n    if (options.style) {\n        for (const key in options.style) {\n            if (options.style.hasOwnProperty(key)) {\n                element.style[key] = options.style[key];\n            }\n        }\n    }\n    if (options.children) {\n        options.children.forEach(child => {\n            if (typeof child === 'string') {\n                element.appendChild(document.createTextNode(child));\n            }\n            else {\n                element.appendChild(child);\n            }\n        });\n    }\n    return element;\n}\n/** Creates a <div> element. */\nfunction createDiv(options = {}) {\n    return createElement('div', options);\n}\n/** Creates a <button> element. */\nfunction createButton(options = {}) {\n    return createElement('button', options);\n}\n/** Creates a <span> element. */\nfunction createSpan(options = {}) {\n    return createElement('span', options);\n}\n/** Creates a <textarea> element. */\nfunction createTextArea(options = {}) {\n    return createElement('textarea', options);\n}\n/** Creates an <input> element. */\nfunction createInputElement(options = {}) {\n    var _a;\n    // Ensure type is set if provided in attributes, otherwise default or leave unset\n    if ((_a = options.attributes) === null || _a === void 0 ? void 0 : _a.type) {\n        // Type is already set in attributes, do nothing extra\n    }\n    else if (!options.attributes) {\n        options.attributes = { type: 'text' }; // Default to text if no attributes specified\n    }\n    else if (!options.attributes.type) {\n        options.attributes.type = 'text'; // Default to text if type is not in attributes\n    }\n    return createElement('input', options);\n}\n/** Creates an <img> element. */\nfunction createImageElement(options) {\n    const imgOptions = Object.assign({}, options);\n    imgOptions.attributes = Object.assign(Object.assign({}, options.attributes), { src: options.src });\n    if (options.alt) {\n        imgOptions.attributes.alt = options.alt;\n    }\n    return createElement('img', imgOptions);\n}\n/** Creates an <a> element. */\nfunction createAnchorElement(options) {\n    const anchorOptions = Object.assign({}, options);\n    anchorOptions.attributes = Object.assign(Object.assign({}, options.attributes), { href: options.href });\n    return createElement('a', anchorOptions);\n}\n/** Creates a <label> element. */\nfunction createLabelElement(options) {\n    const labelOptions = Object.assign({}, options);\n    if (options.htmlFor) {\n        labelOptions.attributes = Object.assign(Object.assign({}, options.attributes), { for: options.htmlFor });\n    }\n    return createElement('label', labelOptions);\n}\n/** Creates a <form> element. */\nfunction createFormElement(options = {}) {\n    return createElement('form', options);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildLayout = buildLayout;\nconst dom_elements_1 = require(\"./dom-elements\");\n/**\n * Builds the main HTML structure for the sidebar widget.\n *\n * @param callbacks - An object containing callback functions for various UI interactions.\n * @returns An object containing the main widget HTMLElement and references to key interactive elements.\n */\nfunction buildLayout(callbacks = {}) {\n    // --- Main Content Wrapper ---\n    const mainElement = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-content-wrapper'\n    });\n    // --- Title Bar ---\n    const titleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-title-container' });\n    const titleInput = (0, dom_elements_1.createInputElement)({\n        id: 'chat-title-input',\n        classes: 'chat-title-input',\n        attributes: { type: 'text', placeholder: 'Chat title', value: 'New Chat' }\n    });\n    if (callbacks.onTitleChange) {\n        titleInput.addEventListener('change', () => callbacks.onTitleChange(titleInput.value));\n    }\n    titleContainer.appendChild(titleInput);\n    // --- Message & History Containers ---\n    const messageContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-message-container' });\n    const historyContainer = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-history-container',\n        style: { display: 'none' } // Hidden by default\n    });\n    // --- Bottom Bar Area ---\n    const bottomBarContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-container' });\n    // Row 1: Controls (Markdown Toggle, @, Expand, Settings)\n    const controlsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row' });\n    const controlsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-controls-container' });\n    // Markdown Toggle\n    const toggleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-toggle-container' });\n    const markdownToggleButton = (0, dom_elements_1.createInputElement)({\n        id: 'markdown-toggle',\n        attributes: { type: 'checkbox' }\n    });\n    const toggleLabel = (0, dom_elements_1.createLabelElement)({\n        text: 'Markdown mode',\n        htmlFor: 'markdown-toggle'\n    });\n    if (callbacks.onMarkdownToggleChange) {\n        markdownToggleButton.addEventListener('change', () => {\n            callbacks.onMarkdownToggleChange(markdownToggleButton.checked);\n        });\n    }\n    toggleContainer.appendChild(markdownToggleButton);\n    toggleContainer.appendChild(toggleLabel);\n    // Action Buttons (@, Expand, Settings)\n    const actionButtonsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-action-buttons-container' });\n    const atButton = (0, dom_elements_1.createButton)({ text: '@', attributes: { title: 'Browse cells, code, files, and more' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onAtButtonClick) {\n        atButton.addEventListener('click', callbacks.onAtButtonClick);\n    }\n    const expandButton = (0, dom_elements_1.createButton)({ text: '', attributes: { title: 'Expand input' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onExpandToggleClick) {\n        expandButton.addEventListener('click', () => callbacks.onExpandToggleClick(expandButton));\n    }\n    const settingsButton = (0, dom_elements_1.createButton)({ text: '', attributes: { title: 'Settings' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onSettingsClick) {\n        settingsButton.addEventListener('click', callbacks.onSettingsClick);\n    }\n    actionButtonsContainer.appendChild(atButton);\n    actionButtonsContainer.appendChild(expandButton);\n    actionButtonsContainer.appendChild(settingsButton);\n    controlsContainer.appendChild(toggleContainer);\n    controlsContainer.appendChild(actionButtonsContainer);\n    controlsRow.appendChild(controlsContainer);\n    // Row 2: Input Field\n    const inputRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row' });\n    const inputField = (0, dom_elements_1.createTextArea)({\n        classes: 'jp-llm-ext-input-field',\n        attributes: { placeholder: 'Ask me anything...', rows: '1' }\n    });\n    if (callbacks.onInputFieldKeyPress) {\n        inputField.addEventListener('keypress', callbacks.onInputFieldKeyPress);\n    }\n    if (callbacks.onInputFieldValueChange) {\n        inputField.addEventListener('input', () => callbacks.onInputFieldValueChange(inputField.value));\n    }\n    inputRow.appendChild(inputField);\n    // Row 3: Main Buttons (Send, New Chat, History)\n    const buttonsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row' });\n    const sendButton = (0, dom_elements_1.createButton)({\n        text: 'Send',\n        classes: 'jp-Button jp-llm-ext-send-button'\n    });\n    if (callbacks.onSendMessageClick) {\n        sendButton.addEventListener('click', callbacks.onSendMessageClick);\n    }\n    const newChatButton = (0, dom_elements_1.createButton)({\n        text: '+ New Chat',\n        attributes: { title: 'Start a new chat' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onNewChatClick) {\n        newChatButton.addEventListener('click', callbacks.onNewChatClick);\n    }\n    const historyButton = (0, dom_elements_1.createButton)({\n        text: 'History',\n        attributes: { title: 'View chat history' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onHistoryToggleClick) {\n        historyButton.addEventListener('click', callbacks.onHistoryToggleClick);\n    }\n    buttonsRow.appendChild(sendButton);\n    buttonsRow.appendChild(newChatButton);\n    buttonsRow.appendChild(historyButton);\n    // Assemble Bottom Bar\n    bottomBarContainer.appendChild(controlsRow);\n    bottomBarContainer.appendChild(inputRow);\n    bottomBarContainer.appendChild(buttonsRow);\n    // --- Assemble Main Element ---\n    mainElement.appendChild(titleContainer);\n    mainElement.appendChild(messageContainer);\n    mainElement.appendChild(historyContainer);\n    mainElement.appendChild(bottomBarContainer);\n    return {\n        mainElement,\n        titleInput,\n        messageContainer,\n        historyContainer,\n        inputField,\n        bottomBarContainer,\n        sendButton,\n        newChatButton,\n        historyButton,\n        markdownToggleButton,\n        expandButton,\n        atButton,\n        settingsButton\n    };\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageRenderer = void 0;\nexports.renderUserMessage = renderUserMessage;\nexports.renderBotMessage = renderBotMessage;\nexports.renderBotMessageStreamingStart = renderBotMessageStreamingStart;\nexports.renderBotMessageStreamingUpdate = renderBotMessageStreamingUpdate;\nexports.renderBotMessageFinal = renderBotMessageFinal;\nconst marked_1 = require(\"marked\");\nconst dompurify_1 = __importDefault(require(\"dompurify\"));\n// import hljs from 'highlight.js'; // Removed unused import\nconst dom_elements_1 = require(\"./dom-elements\");\n// Removed unused import block for code-ref-widget\n// import {\n//   CodeRefData,\n//   createCodeRefWidgetHTML,\n//   attachCodeRefEventListeners,\n//   defaultCodeRefToggleLogic\n// } from './code-ref-widget';\n// Removed unused import block for clipboard utils (used via callbacks)\n// import { copyToClipboard, copyImageToClipboard, copyMessageToClipboard } from '../utils/clipboard';\n// Removed unused import (used via callbacks)\n// import { addMessageToCell } from '../utils/notebook-integration';\nconst highlighting_1 = require(\"../utils/highlighting\");\nconst markdown_config_1 = require(\"../utils/markdown-config\");\n/**\n * Base function to create a message container div.\n */\nfunction createMessageDiv(sender) {\n    const messageDiv = document.createElement('div');\n    messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';\n    return messageDiv;\n}\n/**\n * Renders a user message.\n */\nfunction renderUserMessage(text, options = {}, callbacks = {}) {\n    const messageDiv = createMessageDiv('user');\n    if (options.isMarkdown) {\n        // TODO: Integrate Code Reference rendering properly here\n        // For now, render the whole body as Markdown\n        const contentDiv = document.createElement('div');\n        // Use 'markdown-content' class for consistent styling\n        contentDiv.className = 'markdown-content';\n        try {\n            // Preprocess, parse, and sanitize like in bot messages\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // Enhance code blocks if user messages can contain them\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                // Pass only relevant callbacks if needed for user code blocks\n                enhanceCodeBlock(block, {\n                // e.g., showCopyFeedback: callbacks.showCopyFeedback \n                });\n            });\n        }\n        catch (error) {\n            console.error('Failed to render user markdown:', error);\n            // Fallback to plain text if Markdown rendering fails\n            contentDiv.textContent = text;\n        }\n        messageDiv.appendChild(contentDiv);\n    }\n    else {\n        // Non-Markdown user message (plain text)\n        // TODO: Integrate Code Reference rendering for plain text messages here too\n        messageDiv.textContent = text;\n    }\n    // TODO: Add user message specific actions if needed (e.g., copy text)\n    return messageDiv;\n}\n/**\n * Renders a bot message (text, markdown, images, code blocks).\n */\nfunction renderBotMessage(text, options = { isMarkdown: true }, callbacks = {}) {\n    const messageDiv = createMessageDiv('bot');\n    // Check if the message is an image URL\n    const isImageUrl = text.trim().startsWith('/images/') &&\n        (text.trim().endsWith('.png') ||\n            text.trim().endsWith('.jpg') ||\n            text.trim().endsWith('.jpeg') ||\n            text.trim().endsWith('.gif'));\n    if (isImageUrl) {\n        // Construct full URL (TODO: Make base URL configurable)\n        const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;\n        // Call dedicated image rendering function\n        renderImageMessage(messageDiv, fullImageUrl, callbacks);\n    }\n    else if (options.isMarkdown) {\n        // Render as markdown (logic from addMessage)\n        const markdownIndicator = document.createElement('div');\n        markdownIndicator.textContent = \"MD\";\n        markdownIndicator.className = 'markdown-indicator';\n        messageDiv.appendChild(markdownIndicator);\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'markdown-content';\n        try {\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // Enhance code blocks after setting innerHTML\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                enhanceCodeBlock(block, callbacks);\n            });\n            // Check for and render interrupt buttons\n            const isInterrupt = text.startsWith('**[INTERRUPT]**');\n            if (isInterrupt) {\n                renderInterruptButtons(contentDiv, callbacks);\n            }\n        }\n        catch (error) {\n            contentDiv.textContent = text; // Fallback to plain text\n            console.error('Failed to render markdown:', error);\n        }\n        messageDiv.appendChild(contentDiv);\n        // Add overall message action buttons AFTER content is added\n        addBotMessageActions(messageDiv, text, callbacks);\n    }\n    else {\n        // Render as plain text\n        messageDiv.textContent = text;\n        // Add overall message action buttons even for plain text bot messages\n        addBotMessageActions(messageDiv, text, callbacks);\n    }\n    return messageDiv;\n}\n// Define createMessageWrapper based on createMessageDiv\nfunction createMessageWrapper(sender) {\n    return createMessageDiv(sender);\n}\n// --- More specific rendering functions or helpers can be added below ---\n/**\n * Renders an image message with action buttons inside a container.\n *\n * @param container The parent HTML element to append the image message to.\n * @param imageUrl The full URL of the image to render.\n * @param callbacks Callbacks for actions like copy image, add path.\n */\nfunction renderImageMessage(container, imageUrl, callbacks = {}) {\n    // Create a container for the image that allows positioning the buttons\n    const imageContainer = document.createElement('div');\n    imageContainer.className = 'jp-llm-ext-image-container';\n    imageContainer.style.position = 'relative';\n    // Render as an image tag\n    const img = document.createElement('img');\n    img.src = imageUrl;\n    img.alt = 'Image from bot';\n    img.style.maxWidth = '100%'; // Ensure image fits within the container\n    img.style.height = 'auto';\n    imageContainer.appendChild(img);\n    // Add action buttons for the image\n    const imgActionsDiv = document.createElement('div');\n    imgActionsDiv.className = 'jp-llm-ext-image-actions';\n    imgActionsDiv.style.position = 'absolute';\n    imgActionsDiv.style.bottom = '10px';\n    imgActionsDiv.style.right = '10px';\n    imgActionsDiv.style.display = 'flex';\n    imgActionsDiv.style.gap = '8px';\n    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)'; // Added slight background for visibility\n    imgActionsDiv.style.borderRadius = '4px';\n    imgActionsDiv.style.padding = '4px';\n    // Copy image button (using callback)\n    if (callbacks.copyImageToClipboard && callbacks.showCopyFeedback) {\n        const copyImgBtn = document.createElement('button');\n        copyImgBtn.className = 'jp-llm-ext-image-action-button';\n        copyImgBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyImgBtn.title = 'Copy image to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyImgBtn);\n        copyImgBtn.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyImageToClipboard(imageUrl, feedbackCb);\n        });\n        imgActionsDiv.appendChild(copyImgBtn);\n    }\n    // Add file path button (using callback)\n    if (callbacks.addMessageToCell) {\n        const addPathBtn = document.createElement('button');\n        addPathBtn.className = 'jp-llm-ext-image-action-button';\n        addPathBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addPathBtn.title = 'Add image path to current cell';\n        addPathBtn.addEventListener('click', (event) => {\n            event.stopPropagation();\n            // Pass the image URL (which is the message text in this case)\n            callbacks.addMessageToCell(imageUrl);\n        });\n        imgActionsDiv.appendChild(addPathBtn);\n    }\n    // Only add the actions div if it has buttons\n    if (imgActionsDiv.hasChildNodes()) {\n        imageContainer.appendChild(imgActionsDiv);\n    }\n    // Add the image container to the main message div\n    container.appendChild(imageContainer);\n}\n/**\n * Creates the initial structure for a bot message that will receive streaming content.\n *\n * @returns Object containing the wrapper, streaming div, and final content div.\n */\nfunction renderBotMessageStreamingStart() {\n    const wrapper = createMessageWrapper('bot');\n    const markdownIndicator = (0, dom_elements_1.createDiv)({\n        text: 'MD',\n        classes: 'markdown-indicator'\n    });\n    wrapper.appendChild(markdownIndicator);\n    const streamingDiv = (0, dom_elements_1.createDiv)({\n        classes: 'streaming-content',\n        style: {\n            whiteSpace: 'pre-wrap',\n            fontFamily: 'monospace',\n            fontSize: '0.9em'\n        }\n    });\n    wrapper.appendChild(streamingDiv);\n    const contentDiv = (0, dom_elements_1.createDiv)({\n        classes: 'markdown-content',\n        style: { display: 'none' } // Initially hidden\n    });\n    wrapper.appendChild(contentDiv);\n    return { wrapper, streamingDiv, contentDiv };\n}\n/**\n * Updates the streaming div with a new chunk of text.\n *\n * @param streamingDiv - The div displaying streaming content.\n * @param chunk - The new text chunk to append.\n */\nfunction renderBotMessageStreamingUpdate(streamingDiv, chunk) {\n    // Simple append, might need refinement for complex streams\n    streamingDiv.textContent += chunk;\n}\n/**\n * Renders the final content of a bot message after streaming is complete.\n * Handles markdown, images, code blocks, and interrupts.\n *\n * @param contentDiv - The div where the final content should be rendered.\n * @param streamingDiv - The div that was used for streaming (will be hidden).\n * @param completeResponse - The full text content from the bot.\n * @param options - Rendering options including callbacks for actions.\n * @returns The populated contentDiv.\n */\nfunction renderBotMessageFinal(contentDiv, streamingDiv, completeResponse, options = {}, callbacks = {}) {\n    // Hide streaming div, show final content div\n    streamingDiv.style.display = 'none';\n    contentDiv.style.display = 'block';\n    // Consolidate callbacks access\n    const effectiveCallbacks = Object.assign(Object.assign({}, options), callbacks);\n    // --- Image Handling ---\n    const isImageUrl = completeResponse.trim().startsWith('/images/') &&\n        (completeResponse.trim().endsWith('.png') ||\n            completeResponse.trim().endsWith('.jpg') ||\n            completeResponse.trim().endsWith('.jpeg') ||\n            completeResponse.trim().endsWith('.gif'));\n    if (isImageUrl) {\n        const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // TODO: Make base URL configurable\n        renderImageMessage(contentDiv, fullImageUrl, effectiveCallbacks);\n    }\n    else {\n        // --- Markdown & Code Block Handling ---\n        try {\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // --- Interrupt Handling ---\n            const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');\n            if (isInterrupt) {\n                renderInterruptButtons(contentDiv, effectiveCallbacks);\n            }\n            // --- Code Block Enhancements ---\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                enhanceCodeBlock(block, effectiveCallbacks);\n            });\n        }\n        catch (error) {\n            console.error('Error rendering markdown:', error);\n            contentDiv.textContent = completeResponse; // Fallback to plain text\n        }\n    }\n    return contentDiv;\n}\n/**\n * Enhances a code block element with highlighting and action buttons.\n *\n * @param codeBlockElement The <code> element within a <pre>.\n * @param callbacks Callbacks for actions like copy code, add to cell.\n */\nfunction enhanceCodeBlock(codeBlockElement, callbacks = {}) {\n    var _a;\n    const preElement = codeBlockElement.parentElement;\n    if (!preElement || preElement.tagName !== 'PRE') {\n        console.warn('Code block enhancement called on element not within a <pre> tag.');\n        return;\n    }\n    // Add standard JupyterLab classes for consistency\n    codeBlockElement.classList.add('jp-RenderedText');\n    preElement.classList.add('jp-RenderedHTMLCommon');\n    // Get code content\n    const codeContent = codeBlockElement.textContent || '';\n    // Create code block header for buttons and language indicator\n    const codeHeader = document.createElement('div');\n    codeHeader.className = 'jp-llm-ext-code-header';\n    // Add language indicator if detected\n    const language = (0, highlighting_1.detectLanguage)(codeContent); // Use imported util\n    if (language) {\n        const langIndicator = document.createElement('span');\n        langIndicator.className = 'jp-llm-ext-code-language';\n        langIndicator.textContent = language;\n        codeHeader.appendChild(langIndicator);\n        codeBlockElement.classList.add(`language-${language}`);\n    }\n    // Apply syntax highlighting\n    try {\n        // Use imported util (handles auto-detection if language is empty)\n        codeBlockElement.innerHTML = (0, highlighting_1.highlightCode)(codeContent, language);\n    }\n    catch (error) {\n        console.error('Error applying syntax highlighting:', error);\n        // codeBlockElement might contain original text or partially highlighted\n    }\n    // Add action buttons to the code header\n    const actionsDiv = document.createElement('div');\n    actionsDiv.className = 'jp-llm-ext-code-actions';\n    // Copy button\n    if (callbacks.copyToClipboard && callbacks.showCopyFeedback) {\n        const copyButton = document.createElement('button');\n        copyButton.className = 'jp-llm-ext-code-action-button';\n        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyButton.title = 'Copy code to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);\n        copyButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyToClipboard(codeContent, feedbackCb);\n        });\n        actionsDiv.appendChild(copyButton);\n    }\n    // Add to cell button\n    if (callbacks.addMessageToCell) {\n        const addToButton = document.createElement('button');\n        addToButton.className = 'jp-llm-ext-code-action-button';\n        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addToButton.title = 'Add code to current cell';\n        addToButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.addMessageToCell(codeContent);\n        });\n        actionsDiv.appendChild(addToButton);\n    }\n    // Add the actions to the header, and insert header before the <pre>\n    if (actionsDiv.hasChildNodes()) {\n        codeHeader.appendChild(actionsDiv);\n    }\n    if (codeHeader.hasChildNodes()) {\n        (_a = preElement.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(codeHeader, preElement);\n    }\n}\n/**\n * Renders Confirm/Reject buttons for an interrupt message.\n *\n * @param container The parent HTML element (message content div) to append buttons to.\n * @param callbacks Callbacks for confirm and reject actions.\n */\nfunction renderInterruptButtons(container, callbacks = {}) {\n    if (!callbacks.handleConfirmInterrupt || !callbacks.handleRejectInterrupt) {\n        console.warn('Interrupt message needs confirm/reject callbacks.');\n        return;\n    }\n    const buttonsContainer = document.createElement('div');\n    buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';\n    buttonsContainer.style.marginTop = '12px';\n    buttonsContainer.style.display = 'flex';\n    buttonsContainer.style.gap = '8px';\n    // Create confirm button\n    const confirmButton = document.createElement('button');\n    confirmButton.className = 'jp-llm-ext-confirm-button';\n    confirmButton.textContent = 'Confirm';\n    // Apply specific styling (can be moved to CSS)\n    confirmButton.style.padding = '6px 12px';\n    confirmButton.style.background = '#4CAF50';\n    confirmButton.style.color = 'white';\n    confirmButton.style.border = 'none';\n    confirmButton.style.borderRadius = '4px';\n    confirmButton.style.cursor = 'pointer';\n    confirmButton.style.fontWeight = 'bold';\n    // Create reject button\n    const rejectButton = document.createElement('button');\n    rejectButton.className = 'jp-llm-ext-reject-button';\n    rejectButton.textContent = 'Reject';\n    // Apply specific styling (can be moved to CSS)\n    rejectButton.style.padding = '6px 12px';\n    rejectButton.style.background = '#F44336';\n    rejectButton.style.color = 'white';\n    rejectButton.style.border = 'none';\n    rejectButton.style.borderRadius = '4px';\n    rejectButton.style.cursor = 'pointer';\n    rejectButton.style.fontWeight = 'bold';\n    // Add event listeners\n    confirmButton.addEventListener('click', () => {\n        confirmButton.disabled = true;\n        rejectButton.disabled = true;\n        confirmButton.style.opacity = '0.5';\n        rejectButton.style.opacity = '0.5';\n        callbacks.handleConfirmInterrupt();\n    });\n    rejectButton.addEventListener('click', () => {\n        confirmButton.disabled = true;\n        rejectButton.disabled = true;\n        confirmButton.style.opacity = '0.5';\n        rejectButton.style.opacity = '0.5';\n        callbacks.handleRejectInterrupt();\n    });\n    // Add buttons to container and container to message\n    buttonsContainer.appendChild(confirmButton);\n    buttonsContainer.appendChild(rejectButton);\n    container.appendChild(buttonsContainer);\n}\n/**\n * Adds overall action buttons (Copy, Add to Cell) to a bot message container.\n *\n * @param messageDiv The main div container for the bot message.\n * @param messageText The raw text content of the message.\n * @param callbacks Callbacks for actions like copy message, add to cell.\n */\nfunction addBotMessageActions(messageDiv, messageText, callbacks = {}) {\n    // Only add actions if corresponding callbacks are provided\n    if (!callbacks.copyMessageToClipboard && !callbacks.addMessageToCell) {\n        return;\n    }\n    console.log('Adding action buttons to bot message'); // Keep debug log for now\n    const actionsDiv = document.createElement('div');\n    actionsDiv.className = 'jp-llm-ext-message-actions';\n    // actionsDiv.style.display = 'flex'; // Ensure display via CSS if needed\n    // Copy Message button\n    if (callbacks.copyMessageToClipboard && callbacks.showCopyFeedback) {\n        const copyButton = document.createElement('button');\n        copyButton.className = 'jp-llm-ext-message-action-button';\n        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyButton.title = 'Copy message to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);\n        copyButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyMessageToClipboard(messageText, feedbackCb);\n        });\n        actionsDiv.appendChild(copyButton);\n    }\n    // Add to Cell button\n    if (callbacks.addMessageToCell) {\n        const addToButton = document.createElement('button');\n        addToButton.className = 'jp-llm-ext-message-action-button';\n        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addToButton.title = 'Add message to current cell';\n        addToButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.addMessageToCell(messageText);\n        });\n        actionsDiv.appendChild(addToButton);\n    }\n    // Append the actions container if it has any buttons\n    if (actionsDiv.hasChildNodes()) {\n        messageDiv.appendChild(actionsDiv);\n        console.log('Action buttons added to bot message:', actionsDiv); // Keep debug log\n    }\n}\n// Potential future additions:\n// - renderErrorMessage\n// - renderSystemMessage\n// - A main renderMessage function that delegates based on type? \n/**\n * Handles rendering individual messages (user, bot, system) into HTML elements.\n */\nclass MessageRenderer {\n    // private callbacks: MessageRendererCallbacks; // Removed unused member\n    // private uiManager: UIManager; // Might not be needed directly if callbacks handle UI updates\n    constructor( /* callbacks: MessageRendererCallbacks */ /* , uiManager: UIManager */) {\n        // this.callbacks = callbacks; // Removed unused assignment\n        // this.uiManager = uiManager;\n    }\n}\nexports.MessageRenderer = MessageRenderer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsModal = void 0;\nexports.createSettingsModalElement = createSettingsModalElement;\n/**\n * Creates the HTML element for the settings modal.\n * @param callbacks Callbacks for save and cancel actions.\n * @returns The main modal HTMLElement.\n */\nfunction createSettingsModalElement(callbacks) {\n    const modal = document.createElement('div');\n    modal.className = 'jp-llm-ext-settings-modal';\n    modal.style.display = 'none'; // Initially hidden\n    const content = document.createElement('div');\n    content.className = 'jp-llm-ext-settings-content';\n    const title = document.createElement('h2');\n    title.className = 'jp-llm-ext-settings-title';\n    title.textContent = 'Settings';\n    content.appendChild(title);\n    const form = document.createElement('form');\n    form.className = 'jp-llm-ext-settings-form';\n    // Provider selection\n    const providerLabel = document.createElement('label');\n    providerLabel.className = 'jp-llm-ext-settings-label';\n    providerLabel.textContent = 'API Provider:';\n    form.appendChild(providerLabel);\n    const providerSelect = document.createElement('select');\n    providerSelect.className = 'jp-llm-ext-settings-select';\n    providerSelect.id = 'settings-provider'; // Keep ID for retrieval\n    ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {\n        const option = document.createElement('option');\n        option.value = opt;\n        option.textContent = opt;\n        providerSelect.appendChild(option);\n    });\n    form.appendChild(providerSelect);\n    // API Key input\n    const apiKeyLabel = document.createElement('label');\n    apiKeyLabel.className = 'jp-llm-ext-settings-label';\n    apiKeyLabel.textContent = 'API Key:';\n    form.appendChild(apiKeyLabel);\n    const apiKeyInput = document.createElement('input');\n    apiKeyInput.className = 'jp-llm-ext-settings-input';\n    apiKeyInput.type = 'password';\n    apiKeyInput.id = 'settings-api-key'; // Keep ID for retrieval\n    form.appendChild(apiKeyInput);\n    // API URL input\n    const apiUrlLabel = document.createElement('label');\n    apiUrlLabel.className = 'jp-llm-ext-settings-label';\n    apiUrlLabel.textContent = 'API URL (optional):';\n    form.appendChild(apiUrlLabel);\n    const apiUrlInput = document.createElement('input');\n    apiUrlInput.className = 'jp-llm-ext-settings-input';\n    apiUrlInput.type = 'text';\n    apiUrlInput.id = 'settings-api-url'; // Keep ID for retrieval\n    form.appendChild(apiUrlInput);\n    // Rules input\n    const rulesLabel = document.createElement('label');\n    rulesLabel.className = 'jp-llm-ext-settings-label';\n    rulesLabel.textContent = 'Custom Rules (optional):';\n    form.appendChild(rulesLabel);\n    const rulesInput = document.createElement('textarea');\n    rulesInput.className = 'jp-llm-ext-settings-textarea';\n    rulesInput.id = 'settings-rules'; // Keep ID for retrieval\n    form.appendChild(rulesInput);\n    // Buttons container\n    const btnContainer = document.createElement('div');\n    btnContainer.className = 'jp-llm-ext-settings-buttons';\n    const saveBtn = document.createElement('button');\n    saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';\n    saveBtn.textContent = 'Save';\n    saveBtn.type = 'button'; // Prevent default form submission\n    saveBtn.addEventListener('click', (event) => {\n        event.preventDefault();\n        // The callback implementation will handle reading values and saving\n        const settings = {\n            apiKey: apiKeyInput.value,\n            apiUrl: apiUrlInput.value,\n            rules: rulesInput.value,\n            provider: providerSelect.value\n        };\n        callbacks.handleSave(settings);\n    });\n    const cancelBtn = document.createElement('button');\n    cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';\n    cancelBtn.textContent = 'Cancel';\n    cancelBtn.type = 'button'; // Prevent default form submission\n    cancelBtn.addEventListener('click', (event) => {\n        event.preventDefault();\n        callbacks.handleCancel();\n    });\n    btnContainer.appendChild(saveBtn);\n    btnContainer.appendChild(cancelBtn);\n    form.appendChild(btnContainer);\n    content.appendChild(form);\n    modal.appendChild(content);\n    return modal;\n}\n/**\n * Creates and manages the settings modal dialog.\n */\nclass SettingsModal {\n    // private modalElement: HTMLDivElement; // Commented out - unused\n    // private settings: AppSettings; // Commented out - unused\n    constructor(callbacks) {\n        // this.modalElement = createSettingsModalElement(callbacks); // Commented out - unused assignment\n        // this.settings = { // Commented out - unused initialization\n        //     provider: '', \n        //     apiKey: '', \n        //     apiUrl: '', \n        //     rules: '' \n        // }; \n    }\n}\nexports.SettingsModal = SettingsModal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UIManager = void 0;\n/**\n * Manages UI elements and transitions for the chat interface.\n * This acts as a central point for UI manipulations, simplifying dependencies for handlers.\n */\nclass UIManager {\n    // Add this getter method\n    getIsMarkdownMode() {\n        return this.isMarkdownMode;\n    }\n    constructor(\n    // docManager: IDocumentManager, // Commented out - unused parameter\n    popupMenuManager, \n    // widgetNode: HTMLElement, // Commented out - unused parameter\n    callbacks, layoutElements) {\n        this.notificationTimeout = null; // Timeout for the shortcut indicator\n        // Internal UI state\n        this.isInputExpanded = false;\n        this.isMarkdownMode = false;\n        // this.docManager = docManager; // Commented out - unused assignment\n        this.popupMenuManager = popupMenuManager; // Needed for '@' button action\n        // this.widgetNode = widgetNode; // Commented out - unused assignment\n        this.callbacks = callbacks; // Callbacks to trigger widget/handler logic\n        this.layoutElements = layoutElements; // Keep reference if needed elsewhere\n        // --- Assign internal references from provided layoutElements ---\n        if (!layoutElements.messageContainer || !layoutElements.inputField ||\n            !layoutElements.titleInput || !layoutElements.historyContainer ||\n            !layoutElements.bottomBarContainer || !layoutElements.markdownToggleButton ||\n            !layoutElements.expandButton) {\n            console.error('UIManager: Critical layout elements missing during initialization!');\n            // Potentially throw an error or handle gracefully\n            return;\n        }\n        this.messageContainer = layoutElements.messageContainer;\n        this.inputField = layoutElements.inputField;\n        this.titleInput = layoutElements.titleInput;\n        this.historyContainer = layoutElements.historyContainer;\n        this.bottomBarContainer = layoutElements.bottomBarContainer;\n        this.markdownToggle = layoutElements.markdownToggleButton; // Use markdownToggleButton\n        this.expandButton = layoutElements.expandButton;\n        // --------------------------------------------------------------\n        // Initialize elements that are created outside createLayout if any\n        // In this case, all core elements are created within createLayout\n        // Create and append the indicator element\n        this.keyboardShortcutIndicator = document.createElement('div');\n        this.keyboardShortcutIndicator.className = 'jp-llm-ext-keyboard-shortcut-indicator';\n        // Append it to the main element managed by the UIManager\n        // Ensure mainElement exists before appending\n        if (this.layoutElements.mainElement) {\n            this.layoutElements.mainElement.appendChild(this.keyboardShortcutIndicator);\n        }\n        else {\n            console.error('UIManager: Main layout element not found during indicator initialization.');\n        }\n    }\n    /**\n     * Returns the core layout elements.\n     */\n    getUIElements() {\n        return this.layoutElements;\n    }\n    /**\n     * Creates the main layout structure for the sidebar.\n     * @returns References to key DOM elements.\n     */\n    createLayout() {\n        // Create the main container\n        const mainContent = document.createElement('div');\n        mainContent.className = 'jp-llm-ext-content-wrapper';\n        // --- Title Container ---\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'jp-llm-ext-title-container';\n        this.titleInput = document.createElement('input');\n        this.titleInput.className = 'chat-title-input';\n        this.titleInput.type = 'text';\n        this.titleInput.placeholder = 'Chat title';\n        this.titleInput.value = 'New Chat'; // Default value, widget might update later\n        this.titleInput.addEventListener('change', this.callbacks.handleUpdateTitle);\n        titleContainer.appendChild(this.titleInput);\n        // --- Message & History Containers ---\n        this.messageContainer = document.createElement('div');\n        this.messageContainer.className = 'jp-llm-ext-message-container';\n        this.historyContainer = document.createElement('div');\n        this.historyContainer.className = 'jp-llm-ext-history-container';\n        this.historyContainer.style.display = 'none'; // Initially hidden\n        // --- Bottom Bar ---\n        this.bottomBarContainer = document.createElement('div');\n        this.bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';\n        // Controls Row (Markdown Toggle, Action Buttons)\n        const topRow = document.createElement('div');\n        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';\n        const controlsContainer = this.createControlsContainer(); // Creates markdown toggle, @, expand, settings\n        topRow.appendChild(controlsContainer);\n        // Input Row\n        const middleRow = document.createElement('div');\n        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';\n        this.inputField = document.createElement('textarea');\n        this.inputField.placeholder = 'Ask me anything...';\n        this.inputField.rows = 1;\n        this.inputField.className = 'jp-llm-ext-input-field';\n        // Send on Enter (handled by callbacks.handleSendMessage)\n        this.inputField.addEventListener('keypress', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.callbacks.handleSendMessage();\n            }\n        });\n        // Input listener (e.g., for hiding '@' popup - might move to InputHandler later)\n        this.inputField.addEventListener('input', () => {\n            var _a;\n            // Basic logic for hiding popup if @ removed - refine later\n            const cursorPosition = this.inputField.selectionStart;\n            const textBeforeCursor = this.inputField.value.slice(0, cursorPosition);\n            const hasAtNow = textBeforeCursor.endsWith('@') &&\n                (cursorPosition === 1 ||\n                    !!((_a = textBeforeCursor[cursorPosition - 2]) === null || _a === void 0 ? void 0 : _a.match(/\\s/)));\n            // This needs the widget's `hasAtSymbol` state or similar\n            // For now, this logic might be incomplete or moved.\n            if (!hasAtNow) {\n                this.popupMenuManager.hidePopupMenu();\n            }\n        });\n        middleRow.appendChild(this.inputField);\n        // Buttons Row (Send, New Chat, History)\n        const bottomRow = document.createElement('div');\n        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';\n        const sendButton = this.createButton('Send', 'Send message');\n        sendButton.classList.add('jp-llm-ext-send-button'); // Specific class for send\n        sendButton.addEventListener('click', this.callbacks.handleSendMessage);\n        const newChatButton = this.createButton('+ New Chat', 'Start a new chat');\n        newChatButton.addEventListener('click', this.callbacks.handleNewChat);\n        const historyButton = this.createButton('History', 'View chat history');\n        historyButton.addEventListener('click', this.callbacks.handleToggleHistory);\n        bottomRow.appendChild(sendButton);\n        bottomRow.appendChild(newChatButton);\n        bottomRow.appendChild(historyButton);\n        // Assemble Bottom Bar\n        this.bottomBarContainer.appendChild(topRow);\n        this.bottomBarContainer.appendChild(middleRow);\n        this.bottomBarContainer.appendChild(bottomRow);\n        // --- Assemble Main Content ---\n        mainContent.appendChild(titleContainer);\n        mainContent.appendChild(this.messageContainer);\n        mainContent.appendChild(this.historyContainer);\n        mainContent.appendChild(this.bottomBarContainer);\n        // Return references to key elements\n        return {\n            mainLayout: mainContent,\n            messageContainer: this.messageContainer,\n            inputField: this.inputField,\n            titleInput: this.titleInput,\n            historyContainer: this.historyContainer,\n            bottomBarContainer: this.bottomBarContainer,\n        };\n    }\n    /**\n     * Creates the controls container with toggles and action buttons.\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'jp-llm-ext-controls-container';\n        // --- Markdown Toggle ---\n        const toggleContainer = document.createElement('div');\n        toggleContainer.className = 'jp-llm-ext-toggle-container';\n        this.markdownToggle = document.createElement('input');\n        this.markdownToggle.type = 'checkbox';\n        this.markdownToggle.id = 'markdown-toggle'; // Ensure unique ID or handle differently\n        this.markdownToggle.addEventListener('change', (e) => {\n            const target = e.target;\n            this.isMarkdownMode = target.checked;\n            // Update placeholder based on mode\n            this.inputField.placeholder = this.isMarkdownMode\n                ? 'Write markdown here...\\\\n\\\\n# Example heading\\\\n- List item\\\\n\\\\n```code block```'\n                : 'Ask me anything...';\n            // Future: Notify widget/handler if needed: this.callbacks.handleToggleMarkdown(this.isMarkdownMode);\n        });\n        const toggleLabel = document.createElement('label');\n        toggleLabel.htmlFor = 'markdown-toggle';\n        toggleLabel.textContent = 'Markdown mode';\n        toggleContainer.appendChild(this.markdownToggle);\n        toggleContainer.appendChild(toggleLabel);\n        // --- Action Buttons (@, Expand, Settings) ---\n        const actionButtonsContainer = document.createElement('div');\n        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';\n        // '@' Button\n        const atButton = this.createButton('@', 'Browse cells, code, files, and more');\n        atButton.addEventListener('click', (event) => {\n            // Pass event and button to the callback for positioning\n            this.callbacks.handleShowPopupMenu(event, event.currentTarget);\n        });\n        // Expand Button (store reference)\n        this.expandButton = this.createButton('', 'Expand input');\n        this.expandButton.addEventListener('click', () => this.toggleInputExpansion());\n        // Settings Button\n        const settingsButton = this.createButton('', 'Settings');\n        settingsButton.addEventListener('click', this.callbacks.handleShowSettings);\n        // Add buttons to container\n        actionButtonsContainer.appendChild(atButton);\n        actionButtonsContainer.appendChild(this.expandButton);\n        actionButtonsContainer.appendChild(settingsButton);\n        // Assemble Controls Container\n        controlsContainer.appendChild(toggleContainer);\n        controlsContainer.appendChild(actionButtonsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Toggles the expansion state of the input field.\n     */\n    toggleInputExpansion() {\n        if (!this.inputField || !this.expandButton)\n            return; // Ensure elements exist\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.inputField.style.height = '200px'; // Use CSS classes ideally\n            this.inputField.style.resize = 'vertical';\n            this.expandButton.textContent = '';\n            this.expandButton.title = 'Collapse input';\n        }\n        else {\n            this.inputField.style.height = ''; // Reset height\n            this.inputField.style.resize = 'none';\n            this.inputField.rows = 1; // Ensure collapse\n            this.expandButton.textContent = '';\n            this.expandButton.title = 'Expand input';\n        }\n        // Future: Notify widget/handler if needed: this.callbacks.handleToggleExpansion(this.isInputExpanded);\n    }\n    /**\n     * Helper function to create a styled button.\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        // Apply base JupyterLab button class and our specific class\n        button.className = 'jp-Button jp-llm-ext-action-button';\n        return button;\n    }\n    /**\n     * Appends a new chat message element to the message container and scrolls down.\n     * @param element The message element (user or bot) to add.\n     */\n    addChatMessageElement(element) {\n        if (this.messageContainer) {\n            this.messageContainer.appendChild(element);\n            this.scrollToBottom(); // Scroll after adding the new element\n        }\n        else {\n            console.error('Message container not initialized in UIManager.');\n        }\n    }\n    /**\n     * Scrolls the message container to the bottom.\n     */\n    scrollToBottom() {\n        if (this.messageContainer) {\n            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        }\n        else {\n            console.error('Message container not initialized in UIManager.');\n        }\n    }\n    /**\n     * Switches the view to show the chat history.\n     */\n    showHistoryView() {\n        this.layoutElements.messageContainer.style.display = 'none';\n        this.layoutElements.historyContainer.style.display = 'block';\n        this.layoutElements.bottomBarContainer.style.display = 'none';\n        // Optionally update header/title elements if needed\n    }\n    /**\n     * Switches the view to show the main chat interface.\n     */\n    showChatView() {\n        this.layoutElements.historyContainer.style.display = 'none';\n        this.layoutElements.messageContainer.style.display = 'block';\n        this.layoutElements.bottomBarContainer.style.display = 'flex'; // Assuming flex display\n        this.scrollToBottom(); // Scroll down when showing chat\n    }\n    /**\n     * Clears all messages from the message container.\n     */\n    clearMessageContainer() {\n        this.layoutElements.messageContainer.innerHTML = '';\n    }\n    /**\n     * Updates the value of the title input field.\n     */\n    updateTitleInput(title) {\n        if (this.layoutElements.titleInput) {\n            this.layoutElements.titleInput.value = title;\n        }\n    }\n    /**\n     * Creates and returns a container structure for a bot message,\n     * including elements for streaming text and final rendered content.\n     * This helps manage the transition from streaming to final message display.\n     */\n    createBotMessageContainer() {\n        const botMessageDiv = document.createElement('div');\n        botMessageDiv.className = 'jp-llm-ext-bot-message'; // Base class\n        // Div for streaming content (initially visible)\n        const streamingDiv = document.createElement('div');\n        streamingDiv.className = 'jp-llm-ext-streaming-content';\n        streamingDiv.style.display = 'block'; // Show streaming initially\n        // Div for final rendered content (initially hidden)\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'jp-llm-ext-rendered-content';\n        contentDiv.style.display = 'none'; // Hide final content initially\n        botMessageDiv.appendChild(streamingDiv);\n        botMessageDiv.appendChild(contentDiv);\n        // Add the whole container to the message list *before* streaming starts\n        this.addChatMessageElement(botMessageDiv);\n        return { botMessageDiv, streamingDiv, contentDiv };\n    }\n    /**\n     * Displays a temporary notification message.\n     * TODO: Implement a more robust notification system (e.g., toast).\n     */\n    showNotification(message, type, duration = 3000) {\n        console.log(`Notification (${type}): ${message}`);\n        // Basic temporary implementation using the existing indicator element\n        const indicator = this.layoutElements.mainElement.querySelector('.jp-llm-ext-keyboard-shortcut-indicator');\n        if (indicator) {\n            if (this.notificationTimeout) {\n                clearTimeout(this.notificationTimeout); // Clear previous timeout\n            }\n            indicator.textContent = message;\n            indicator.className = `jp-llm-ext-keyboard-shortcut-indicator visible jp-llm-ext-notification-${type}`; // Add type class\n            this.notificationTimeout = window.setTimeout(() => {\n                indicator.classList.remove('visible');\n                this.notificationTimeout = null;\n            }, duration);\n        }\n        else {\n            console.warn('Notification indicator element not found for UIManager.');\n        }\n    }\n    /**\n     * Shows a visual indicator for keyboard shortcuts.\n     * @param text The text to display in the indicator.\n     */\n    showIndicator(text) {\n        if (!this.keyboardShortcutIndicator)\n            return; // Guard\n        this.keyboardShortcutIndicator.textContent = text;\n        this.keyboardShortcutIndicator.classList.add('visible');\n        // Clear any existing timeout to prevent multiple timeouts running\n        if (this.notificationTimeout) {\n            clearTimeout(this.notificationTimeout);\n        }\n        // Set new timeout to hide the indicator\n        this.notificationTimeout = window.setTimeout(() => {\n            if (this.keyboardShortcutIndicator) { // Check if element still exists\n                this.keyboardShortcutIndicator.classList.remove('visible');\n            }\n            this.notificationTimeout = null;\n        }, 1000); // Hide after 1 second\n    }\n    /**\n     * Clears the indicator immediately and cancels any pending hide timeout.\n     * Useful if the widget is hidden while the indicator is shown.\n     */\n    clearIndicator() {\n        if (!this.keyboardShortcutIndicator)\n            return;\n        this.keyboardShortcutIndicator.classList.remove('visible');\n        this.keyboardShortcutIndicator.textContent = '';\n        if (this.notificationTimeout) {\n            clearTimeout(this.notificationTimeout);\n            this.notificationTimeout = null;\n        }\n    }\n}\nexports.UIManager = UIManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.copyToClipboard = copyToClipboard;\nexports.copyMessageToClipboard = copyMessageToClipboard;\nexports.copyImageToClipboard = copyImageToClipboard;\n/**\n * Helper function to copy text to clipboard.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyToClipboard(text, feedbackCallback) {\n    try {\n        navigator.clipboard.writeText(text).then(() => {\n            console.log('Content copied to clipboard');\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(); // Call optional feedback callback\n        }).catch(err => {\n            console.error('Failed to copy text: ', err);\n        });\n    }\n    catch (error) {\n        console.error('Error copying text to clipboard:', error);\n    }\n}\n/**\n * Copies message content to clipboard.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyMessageToClipboard(text, feedbackCallback) {\n    try {\n        navigator.clipboard.writeText(text).then(() => {\n            console.log('Message content copied to clipboard');\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success\n        }).catch(err => {\n            console.error('Failed to copy message text: ', err);\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n        });\n    }\n    catch (error) {\n        console.error('Error copying message to clipboard:', error);\n        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n    }\n}\n/**\n * Copies an image to the clipboard from a given URL.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyImageToClipboard(imageUrl, feedbackCallback) {\n    try {\n        fetch(imageUrl)\n            .then(response => {\n            if (!response.ok) {\n                throw new Error(`Failed to fetch image: ${response.statusText}`);\n            }\n            return response.blob();\n        })\n            .then(blob => {\n            // Create a ClipboardItem with the image blob\n            // Note: ClipboardItem might not be defined in all environments\n            // You might need to add `\"dom.iterable\"` to tsconfig lib or handle appropriately.\n            const item = new ClipboardItem({ [blob.type]: blob });\n            navigator.clipboard.write([item]).then(() => {\n                console.log('Image copied to clipboard');\n                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success\n            })\n                .catch(err => {\n                console.error('Failed to copy image to clipboard: ', err);\n                alert('Failed to copy image: ' + err.message); // Keep alert for critical user feedback\n                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n            });\n        })\n            .catch(err => {\n            console.error('Failed to fetch or process image: ', err);\n            alert('Failed to fetch image: ' + err.message); // Keep alert for critical user feedback\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n        });\n    }\n    catch (error) {\n        console.error('Error preparing image copy:', error);\n        alert('Error copying image: ' + error); // Keep alert for critical user feedback\n        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n    }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detectLanguage = detectLanguage;\nexports.highlightCode = highlightCode;\nconst highlight_js_1 = __importDefault(require(\"highlight.js\"));\n/**\n * Detects the programming language from code block content using highlight.js\n * and custom pattern matching for common languages.\n */\nfunction detectLanguage(code) {\n    try {\n        // Try auto detection first with a limited set of common languages\n        const result = highlight_js_1.default.highlightAuto(code, [\n            'python', 'javascript', 'typescript', 'java',\n            'html', 'css', 'cpp', 'csharp', 'sql', 'rust',\n            'php', 'bash', 'json', 'xml', 'markdown'\n        ]);\n        // If confidence is reasonably high, use that language\n        if (result.relevance > 5 && result.language) {\n            return result.language;\n        }\n        // Fall back to basic pattern matching for better accuracy on ambiguous cases\n        if (/^(?:\\s*)?(?:import\\s+[^;]+;|package\\s+[^;]+;|public\\s+class)/.test(code)) {\n            return 'java';\n        }\n        else if (/^(?:\\s*)?(import|from|def|class|if __name__)/.test(code)) {\n            return 'python';\n        }\n        else if (/^(?:\\s*)?(?:function|const|let|var|import|export|=>)/.test(code)) {\n            // Broader check for JS/TS\n            if (/^(?:\\s*)?(?:import\\s.+|export\\s.+|interface|type|enum|declare|:|\\s<)/.test(code)) {\n                return 'typescript';\n            }\n            return 'javascript';\n        }\n        else if (/^(?:\\s*)?(?:<!DOCTYPE|<html|<head|<body)/i.test(code)) {\n            return 'html';\n        }\n        else if (/^(?:\\s*)?#include/.test(code)) {\n            return 'cpp';\n        }\n        else if (/^(?:\\s*)?(?:using\\s+System|namespace|public\\s+static\\s+void\\s+Main)/.test(code)) {\n            return 'csharp';\n        }\n        else if (/^(?:\\s*)?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\\s/i.test(code)) {\n            return 'sql';\n        }\n        else if (/^(?:\\s*)?(?:fn|let|struct|enum|trait|impl|mod)\\s/.test(code)) {\n            return 'rust';\n        }\n        else if (/^(?:\\s*)?(?:<\\?php|use\\s+[\\w\\\\]+;)/.test(code)) {\n            return 'php';\n        }\n        else if (/^(?:\\s*)?(?:#\\s*!\\/bin\\/(?:bash|sh|zsh)|\\$)/.test(code)) {\n            return 'bash';\n        }\n        else if (/^\\s*\\{/.test(code) && /\\}\\s*$/.test(code)) {\n            // Simple check for JSON-like structure\n            return 'json';\n        }\n        else if (/^\\s*<\\?xml/.test(code) || /^\\s*<\\w+/.test(code)) {\n            // Simple check for XML/HTML like structure\n            return 'xml';\n        }\n        // If no specific language detected, return empty string for default handling\n        return '';\n    }\n    catch (error) {\n        console.error('Error detecting language:', error);\n        return ''; // Return empty on error\n    }\n}\n/**\n * Highlights code using highlight.js.\n * Falls back to auto-detection if the specified language is not supported.\n */\nfunction highlightCode(code, language) {\n    try {\n        if (language && highlight_js_1.default.getLanguage(language)) {\n            return highlight_js_1.default.highlight(code, { language, ignoreIllegals: true }).value;\n        }\n        else {\n            // Fallback to auto-detection if language is empty or not registered\n            return highlight_js_1.default.highlightAuto(code).value;\n        }\n    }\n    catch (error) {\n        console.error(`Error highlighting code (language: ${language || 'auto'}):`, error);\n        // Return original code escaped for safety on error\n        return code.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.configureMarked = configureMarked;\nexports.preprocessMarkdown = preprocessMarkdown;\nconst marked_1 = require(\"marked\");\n/**\n * Configure marked with better rendering options for code blocks\n */\nfunction configureMarked() {\n    // Configure marked options\n    marked_1.marked.setOptions({\n        gfm: true, // Enable GitHub Flavored Markdown\n        breaks: true, // Add <br> on single line breaks\n        pedantic: false, // Conform to original markdown spec\n        async: false, // Disable async rendering\n        silent: false // Enable error reporting\n    });\n}\n/**\n * Pre-process markdown text to fix common issues with streaming content\n */\nfunction preprocessMarkdown(text) {\n    // Normalize line endings\n    const normalizedText = text.replace(/\\r\\n/g, '\\n');\n    // Handle code blocks first\n    let inCodeBlock = false;\n    const lines = normalizedText.split('\\n');\n    const processedLines = lines.map((line, i) => {\n        // Check for code block markers\n        if (line.trim().startsWith('```')) {\n            inCodeBlock = !inCodeBlock;\n            // Preserve language specification\n            return line.trim();\n        }\n        // If we're in a code block, preserve the line as is\n        if (inCodeBlock) {\n            return line;\n        }\n        // Outside code blocks:\n        // 1. Handle list items with proper spacing\n        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines\n        let processed = line;\n        // Handle dash list items by ensuring they have a space after the dash\n        processed = processed.replace(/(\\s*)-(\\S)/g, '$1- $2');\n        // Handle mixed space/dash issues - ensure proper newlines before list items\n        processed = processed.replace(/([^\\n\\s])-\\s/g, '$1\\n- ');\n        return processed;\n    });\n    // Join lines and ensure code blocks are properly formatted\n    let result = processedLines.join('\\n');\n    // Handle empty code blocks (add a space so they render properly)\n    result = result.replace(/```(.*)\\n```/g, '```$1\\n \\n```');\n    return result;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addMessageToCell = addMessageToCell;\nexports.getSelectedText = getSelectedText;\nexports.getCurrentCellContent = getCurrentCellContent;\nexports.insertCellContentByIndex = insertCellContentByIndex;\nconst globals_1 = require(\"../core/globals\");\n/**\n * Adds message content to the current cell in the active notebook.\n */\nfunction addMessageToCell(text) {\n    var _a;\n    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (!cell || !cell.editor) {\n        console.warn('Cannot add message: No active cell or editor found.');\n        return;\n    }\n    try {\n        const editor = cell.editor;\n        // Access the underlying CodeMirror editor view (adjust if using a different editor)\n        const view = editor.editor;\n        if (!view) {\n            console.warn('Cannot add message: CodeMirror view not accessible.');\n            return;\n        }\n        // Get current cursor position\n        const state = view.state;\n        const selection = state.selection;\n        const cursorPos = selection.main.head;\n        // Insert newline and message content at cursor position\n        const transaction = state.update({\n            changes: {\n                from: cursorPos,\n                insert: `\\n${text}`\n            },\n            // Optionally move cursor to end of inserted text\n            selection: { anchor: cursorPos + text.length + 1 }\n        });\n        view.dispatch(transaction);\n    }\n    catch (error) {\n        console.error('Error adding message to cell:', error);\n    }\n}\n/**\n * Gets the currently selected text from the active notebook cell or text editor.\n */\nfunction getSelectedText() {\n    var _a, _b, _c;\n    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (cell === null || cell === void 0 ? void 0 : cell.editor) {\n        const editor = cell.editor;\n        const cmEditor = editor.editor; // Access CodeMirror editor instance\n        if (cmEditor && cmEditor.state) {\n            const state = cmEditor.state;\n            const selection = state.selection.main;\n            return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);\n        }\n        console.warn(\"Could not access CodeMirror state to get selection.\");\n        return null;\n    }\n    else {\n        // Fallback for non-notebook editors (e.g., text editor)\n        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n        if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {\n            const editor = activeWidget.content.editor;\n            const cmEditor = editor.editor;\n            if (cmEditor && cmEditor.state) {\n                const state = cmEditor.state;\n                const selection = state.selection.main;\n                return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);\n            }\n            console.warn(\"Could not access CodeMirror state for non-notebook editor selection.\");\n            return null;\n        }\n    }\n    return null;\n}\n/**\n * Gets the content of the currently active notebook cell or text editor.\n */\nfunction getCurrentCellContent() {\n    var _a, _b, _c, _d, _e;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {\n        // Try using sharedModel first (more robust)\n        if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {\n            return activeCell.model.sharedModel.getSource();\n        }\n        // Fallback: Try using toJSON().source\n        const cellJson = activeCell.model.toJSON();\n        const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n        if (typeof source === 'string') {\n            return source;\n        }\n        else if (Array.isArray(source)) {\n            return source.join('\\n');\n        }\n        console.warn(\"Could not get cell content via sharedModel or toJSON().source\");\n        return null;\n    }\n    // Fallback for non-notebook editors if needed\n    const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n    if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {\n        // Assuming model.value.text for generic text editors\n        return (_e = (_d = activeWidget.content.model.value) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;\n    }\n    return null;\n}\n/**\n * Gets cell content by index from the current notebook and calls a callback to insert it.\n * NOTE: The original function called `this.appendToInput`. This functionality needs\n *       to be provided via the `insertCallback`.\n */\nfunction insertCellContentByIndex(index, insertCallback) {\n    try {\n        if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {\n            console.error('No active notebook found');\n            return;\n        }\n        const notebookPanel = globals_1.globals.notebookTracker.currentWidget;\n        const model = notebookPanel.content.model;\n        if (!model || !model.cells || index < 0 || index >= model.cells.length) {\n            console.error(`Invalid cell index: ${index}`);\n            return;\n        }\n        const cell = model.cells.get(index);\n        let cellContent = '';\n        // Get cell content - handle different ways content might be stored\n        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {\n            cellContent = cell.sharedModel.getSource();\n        }\n        else {\n            const cellJson = cell.toJSON();\n            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n            if (typeof source === 'string') {\n                cellContent = source;\n            }\n            else if (Array.isArray(source)) {\n                cellContent = source.join('\\n');\n            }\n        }\n        // Insert cell reference with content using the callback\n        insertCallback(`cell ${cellContent}`);\n    }\n    catch (error) {\n        console.error('Error inserting cell by index:', error);\n    }\n}\n"],"names":[],"sourceRoot":""}