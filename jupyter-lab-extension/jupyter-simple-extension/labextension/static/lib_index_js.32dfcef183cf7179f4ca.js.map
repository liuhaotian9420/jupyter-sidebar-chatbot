{"version":3,"file":"lib_index_js.32dfcef183cf7179f4ca.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACrEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC7Ib;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC9Fb;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,YAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,eAAe;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA,2CAA2C,UAAU;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB,GAAG,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;ACzIb;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACvHP;AACb;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,0BAA0B,mBAAO,CAAC,oDAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB,GAAG;AACnE;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;;;;;;;;;;;ACzIV;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sDAAsD,wBAAwB;AAC9E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sDAAsD,wBAAwB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gDAAgD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;AC/PX;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACvJV;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,gBAAgB,mBAAO,CAAC,gCAAU;AAClC,kBAAkB,mBAAO,CAAC,oCAAY;AACtC;AACA,+BAA+B,mBAAO,CAAC,kEAAwB;AAC/D,+BAA+B,mBAAO,CAAC,kEAAwB;AAC/D,6BAA6B,mBAAO,CAAC,8DAAsB;AAC3D,2BAA2B,mBAAO,CAAC,0DAAoB;AACvD,2BAA2B,mBAAO,CAAC,0DAAoB;AACvD,wBAAwB,mBAAO,CAAC,oDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA,0CAA0C;AAC1C,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACtgBd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,+BAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB,IAAI,+BAA+B;AACnC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;;;;;;;;;;ACjBY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD;AACA,yBAAyB,mBAAO,CAAC,2DAAuB;AACxD,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,+BAA+B,mBAAO,CAAC,6DAAwB;AAC/D;AACA,mBAAmB,mBAAO,CAAC,yCAAc;AACzC,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACpCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B;AAC1B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA","sources":["webpack://jupyter-simple-extension/./lib/api-client.js","webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/chat/chat-history-manager.js","webpack://jupyter-simple-extension/./lib/chat/file-browser-manager.js","webpack://jupyter-simple-extension/./lib/chat/input-handler.js","webpack://jupyter-simple-extension/./lib/chat/message-renderer.js","webpack://jupyter-simple-extension/./lib/chat/popup-menu-manager.js","webpack://jupyter-simple-extension/./lib/chat/settings-manager.js","webpack://jupyter-simple-extension/./lib/chat/sidebar-widget.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/globals.js","webpack://jupyter-simple-extension/./lib/icons.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/markdown-config.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\n/**\n * API client for interacting with the backend LLM service\n */\nclass ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\nexports.ApiClient = ApiClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CellContextTracker = void 0;\n/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nclass CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\nexports.CellContextTracker = CellContextTracker;\n","\"use strict\";\n/**\n * Manages chat history functionality\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatHistoryManager = void 0;\n/**\n * Manages chat history storage, retrieval, and manipulation\n */\nclass ChatHistoryManager {\n    constructor() {\n        this.chatHistory = [];\n        this.currentChatId = '';\n    }\n    /**\n     * Creates a new chat session\n     * @returns The ID of the newly created chat\n     */\n    createNewChat() {\n        // Generate a unique ID for the chat\n        const chatId = `chat-${Date.now()}`;\n        // Create a new chat item\n        const newChat = {\n            id: chatId,\n            title: `Chat ${this.chatHistory.length + 1}`,\n            messages: []\n        };\n        // Add to history and set as current\n        this.chatHistory.push(newChat);\n        this.currentChatId = chatId;\n        return chatId;\n    }\n    /**\n     * Adds a message to the current chat\n     * @param text Message text\n     * @param sender Message sender\n     * @param isMarkdown Whether the message is in markdown format\n     */\n    addMessage(text, sender, isMarkdown = false) {\n        const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n        if (chat) {\n            const message = {\n                text,\n                sender,\n                isMarkdown\n            };\n            chat.messages.push(message);\n        }\n    }\n    /**\n     * Gets the current chat\n     * @returns The current chat or undefined if none exists\n     */\n    getCurrentChat() {\n        return this.chatHistory.find(c => c.id === this.currentChatId);\n    }\n    /**\n     * Gets all chat history\n     * @returns Array of all chat history items\n     */\n    getAllChats() {\n        return [...this.chatHistory];\n    }\n    /**\n     * Loads a chat by ID\n     * @param chatId The ID of the chat to load\n     * @returns The loaded chat or undefined if not found\n     */\n    loadChat(chatId) {\n        const chat = this.chatHistory.find(c => c.id === chatId);\n        if (chat) {\n            this.currentChatId = chatId;\n            return chat;\n        }\n        return undefined;\n    }\n    /**\n     * Updates the title of the current chat\n     * @param title The new title\n     */\n    updateCurrentChatTitle(title) {\n        const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n        if (chat) {\n            chat.title = title;\n        }\n    }\n    /**\n     * Gets the current chat ID\n     * @returns The current chat ID\n     */\n    getCurrentChatId() {\n        return this.currentChatId;\n    }\n}\nexports.ChatHistoryManager = ChatHistoryManager;\n","\"use strict\";\n/**\n * Manages file and directory browsing functionality\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileBrowserManager = void 0;\n/**\n * Manages file and directory browsing operations\n */\nclass FileBrowserManager {\n    constructor(docManager) {\n        this.currentPath = '';\n        this.docManager = docManager;\n    }\n    /**\n     * Lists the contents of the current directory\n     * @param filterType Optional parameter to filter results by type ('all', 'file', or 'directory')\n     * @returns A promise resolving to an array of item names or null on error\n     */\n    async listCurrentDirectoryContents(filterType = 'all') {\n        console.log('LIST DIR: Starting directory listing process...', { filterType });\n        try {\n            // Ensure we have a current path\n            if (!this.currentPath) {\n                await this.setCurrentDirectoryPath();\n            }\n            console.log('LIST DIR: Current path:', this.currentPath);\n            // Get directory contents using the document manager\n            const dirContents = await this.docManager.services.contents.get(this.currentPath, { content: true });\n            if (!dirContents) {\n                console.error('LIST DIR: Failed to get directory contents');\n                return null;\n            }\n            console.log('LIST DIR: Got directory contents:', dirContents);\n            // Filter contents based on filterType\n            let filteredContents = dirContents.content || [];\n            if (filterType === 'file') {\n                filteredContents = filteredContents.filter((item) => item.type !== 'directory');\n            }\n            else if (filterType === 'directory') {\n                filteredContents = filteredContents.filter((item) => item.type === 'directory');\n            }\n            // Sort directories first, then files\n            filteredContents.sort((a, b) => {\n                if (a.type === 'directory' && b.type !== 'directory') {\n                    return -1;\n                }\n                if (a.type !== 'directory' && b.type === 'directory') {\n                    return 1;\n                }\n                return a.name.localeCompare(b.name);\n            });\n            // Extract names\n            const names = filteredContents.map((item) => {\n                if (item.type === 'directory') {\n                    return `\\ud83d\\udcc1 ${item.name}`;\n                }\n                else {\n                    return `\\ud83d\\udcc4 ${item.name}`;\n                }\n            });\n            console.log('LIST DIR: Filtered and sorted names:', names);\n            return names;\n        }\n        catch (error) {\n            console.error('LIST DIR: Error listing directory contents:', error);\n            return null;\n        }\n    }\n    /**\n     * Sets the current directory path based on context\n     */\n    async setCurrentDirectoryPath() {\n        // If we already have a path, keep using it\n        if (this.currentPath) {\n            return;\n        }\n        try {\n            // Just use empty path for now as a fallback\n            // In a real implementation, we would try to get the current directory from the document manager\n            this.currentPath = '';\n            console.log('DIR PATH: Using empty path as fallback');\n        }\n        catch (error) {\n            console.error('DIR PATH: Error setting directory path:', error);\n            this.currentPath = '';\n        }\n    }\n    /**\n     * Navigates to a subdirectory\n     * @param dirName The name of the subdirectory to navigate to\n     */\n    navigateToSubdirectory(dirName) {\n        // Remove the folder emoji if present\n        const cleanDirName = dirName.replace('\\ud83d\\udcc1 ', '');\n        // Update the current path\n        if (this.currentPath) {\n            this.currentPath = `${this.currentPath}/${cleanDirName}`;\n        }\n        else {\n            this.currentPath = cleanDirName;\n        }\n        // Normalize the path\n        this.currentPath = this.currentPath.replace(/\\/+/g, '/');\n        console.log('DIR NAV: Navigated to:', this.currentPath);\n    }\n    /**\n     * Navigates to the parent directory\n     * @returns True if navigation was successful, false otherwise\n     */\n    navigateToParentDirectory() {\n        // Check if we're already at the root\n        if (!this.currentPath || this.currentPath === '') {\n            return false;\n        }\n        // Get the parent path\n        const parts = this.currentPath.split('/');\n        parts.pop(); // Remove the last part\n        this.currentPath = parts.join('/');\n        console.log('DIR NAV: Navigated to parent:', this.currentPath);\n        return true;\n    }\n    /**\n     * Gets the current directory path\n     * @returns The current directory path\n     */\n    getCurrentPath() {\n        return this.currentPath;\n    }\n    /**\n     * Sets the current directory path\n     * @param path The new path to set\n     */\n    setCurrentPath(path) {\n        this.currentPath = path;\n    }\n}\nexports.FileBrowserManager = FileBrowserManager;\n","\"use strict\";\n/**\n * Handles input field functionality\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputHandler = void 0;\n/**\n * Manages input field behavior and interactions\n */\nclass InputHandler {\n    constructor(inputField, _inputContainer, // Prefix with underscore to indicate it's not used\n    onSendMessage) {\n        this.isInputExpanded = false;\n        this.isMarkdownMode = false;\n        this.inputField = inputField;\n        this.onSendMessage = onSendMessage;\n        // Set up input field event listeners\n        this.setupInputFieldEvents();\n    }\n    /**\n     * Sets up event listeners for the input field\n     */\n    setupInputFieldEvents() {\n        // Handle Enter key to send message\n        this.inputField.addEventListener('keydown', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.onSendMessage();\n            }\n        });\n    }\n    /**\n     * Toggles the expansion state of the input field\n     * @param button The button element that triggered the toggle\n     */\n    toggleInputExpansion(button) {\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.inputField.style.height = '150px';\n            this.inputField.style.resize = 'vertical';\n            button.textContent = '\\u25bc';\n        }\n        else {\n            this.inputField.style.height = '50px';\n            this.inputField.style.resize = 'none';\n            button.textContent = '\\u25b2';\n        }\n    }\n    /**\n     * Toggles markdown mode\n     * @param button The button element that triggered the toggle\n     */\n    toggleMarkdownMode(button) {\n        this.isMarkdownMode = !this.isMarkdownMode;\n        if (this.isMarkdownMode) {\n            button.textContent = 'MD';\n            button.classList.add('active');\n        }\n        else {\n            button.textContent = 'MD';\n            button.classList.remove('active');\n        }\n    }\n    /**\n     * Gets the current input text\n     * @returns The current input text\n     */\n    getInputText() {\n        return this.inputField.value;\n    }\n    /**\n     * Clears the input field\n     */\n    clearInput() {\n        this.inputField.value = '';\n    }\n    /**\n     * Appends text to the input field with proper spacing\n     * @param text The text to append\n     */\n    appendToInput(text) {\n        try {\n            const currentText = this.inputField.value;\n            const cursorPosition = this.inputField.selectionStart;\n            // Check if we need to add a space before the text\n            const needsLeadingSpace = cursorPosition > 0 &&\n                currentText.charAt(cursorPosition - 1) !== ' ' &&\n                currentText.charAt(cursorPosition - 1) !== '\\n';\n            // Check if we need to add a space after the text\n            const needsTrailingSpace = cursorPosition < currentText.length &&\n                currentText.charAt(cursorPosition) !== ' ' &&\n                currentText.charAt(cursorPosition) !== '\\n';\n            // Build the text to insert\n            let insertText = '';\n            if (needsLeadingSpace)\n                insertText += ' ';\n            insertText += text;\n            if (needsTrailingSpace)\n                insertText += ' ';\n            // Insert the text at the cursor position\n            const newText = currentText.substring(0, cursorPosition) +\n                insertText +\n                currentText.substring(cursorPosition);\n            this.inputField.value = newText;\n            // Set focus back to the input field\n            this.inputField.focus();\n        }\n        catch (error) {\n            console.error('Error appending to input:', error);\n        }\n    }\n    /**\n     * Checks if markdown mode is enabled\n     * @returns True if markdown mode is enabled, false otherwise\n     */\n    isMarkdownEnabled() {\n        return this.isMarkdownMode;\n    }\n}\nexports.InputHandler = InputHandler;\n","\"use strict\";\n/**\n * Handles rendering and managing chat messages\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageRenderer = void 0;\nconst marked_1 = require(\"marked\");\nconst dompurify_1 = __importDefault(require(\"dompurify\"));\nconst markdown_config_1 = require(\"../markdown-config\");\n/**\n * Handles rendering and managing chat messages in the UI\n */\nclass MessageRenderer {\n    constructor(messageContainer, onCopyMessage, onAddToCell) {\n        this.messageContainer = messageContainer;\n        this.onCopyMessage = onCopyMessage;\n        this.onAddToCell = onAddToCell;\n    }\n    /**\n     * Renders a message in the UI\n     * @param text The text content of the message\n     * @param sender The sender of the message ('user' or 'bot')\n     * @param isMarkdown Whether the message is in Markdown format\n     * @returns The created message element\n     */\n    renderMessage(text, sender, isMarkdown = false) {\n        console.log('Rendering message:', { sender, isMarkdown }); // Debug log\n        // Create message container\n        const messageElement = document.createElement('div');\n        messageElement.className = `chat-message ${sender}-message`;\n        // Create message header with sender info\n        const messageHeader = document.createElement('div');\n        messageHeader.className = 'message-header';\n        messageHeader.textContent = sender === 'user' ? 'You' : 'AI';\n        messageElement.appendChild(messageHeader);\n        // Create message content\n        const messageContent = document.createElement('div');\n        messageContent.className = 'message-content';\n        // Process and render the message content\n        if (isMarkdown) {\n            try {\n                // Preprocess markdown to handle special syntax\n                const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(text);\n                // Convert markdown to HTML\n                const rawHtml = marked_1.marked.parse(processedMarkdown);\n                // Sanitize HTML (cast to string to fix type issue)\n                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n                // Set the HTML content\n                messageContent.innerHTML = sanitizedHtml;\n                // Add syntax highlighting to code blocks\n                const codeBlocks = messageContent.querySelectorAll('pre code');\n                codeBlocks.forEach((block) => {\n                    var _a, _b;\n                    // Add a class for styling\n                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('highlighted-code');\n                    // Add copy button to code blocks\n                    const copyButton = document.createElement('button');\n                    copyButton.className = 'code-copy-button';\n                    copyButton.textContent = 'Copy';\n                    copyButton.addEventListener('click', () => {\n                        const codeText = block.innerText;\n                        this.onCopyMessage(codeText);\n                        copyButton.textContent = 'Copied!';\n                        setTimeout(() => {\n                            copyButton.textContent = 'Copy';\n                        }, 2000);\n                    });\n                    // Add the copy button to the pre element\n                    (_b = block.parentElement) === null || _b === void 0 ? void 0 : _b.appendChild(copyButton);\n                });\n            }\n            catch (error) {\n                console.error('Error rendering markdown:', error);\n                messageContent.textContent = text;\n            }\n        }\n        else {\n            // Plain text rendering\n            messageContent.textContent = text;\n        }\n        messageElement.appendChild(messageContent);\n        // Create message actions\n        const messageActions = document.createElement('div');\n        messageActions.className = 'message-actions';\n        // Add copy button\n        const copyButton = document.createElement('button');\n        copyButton.className = 'message-action-button';\n        copyButton.textContent = 'Copy';\n        copyButton.title = 'Copy to clipboard';\n        copyButton.addEventListener('click', () => {\n            this.onCopyMessage(text);\n            copyButton.textContent = 'Copied!';\n            setTimeout(() => {\n                copyButton.textContent = 'Copy';\n            }, 2000);\n        });\n        messageActions.appendChild(copyButton);\n        // Add \"Add to Cell\" button\n        const addToCellButton = document.createElement('button');\n        addToCellButton.className = 'message-action-button';\n        addToCellButton.textContent = 'Add to Cell';\n        addToCellButton.title = 'Add to current cell';\n        addToCellButton.addEventListener('click', () => {\n            this.onAddToCell(text);\n            addToCellButton.textContent = 'Added!';\n            setTimeout(() => {\n                addToCellButton.textContent = 'Add to Cell';\n            }, 2000);\n        });\n        messageActions.appendChild(addToCellButton);\n        messageElement.appendChild(messageActions);\n        // Add to message container\n        this.messageContainer.appendChild(messageElement);\n        // Scroll to the bottom\n        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        return messageElement;\n    }\n    /**\n     * Clears all messages from the container\n     */\n    clearMessages() {\n        this.messageContainer.innerHTML = '';\n    }\n    /**\n     * Renders a list of messages\n     * @param messages The messages to render\n     */\n    renderMessages(messages) {\n        this.clearMessages();\n        messages.forEach(message => {\n            this.renderMessage(message.text, message.sender, message.isMarkdown);\n        });\n    }\n}\nexports.MessageRenderer = MessageRenderer;\n","\"use strict\";\n/**\n * Manages popup menu functionality\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopupMenuManager = void 0;\n/**\n * Manages popup menu creation, display, and interaction\n */\nclass PopupMenuManager {\n    constructor(fileBrowserManager, onItemSelected) {\n        /**\n         * Handles document click events to close the menu when clicking outside\n         */\n        this.handleDocumentClick = (event) => {\n            // Check if the click is outside the popup menu container\n            if (this.popupMenuContainer.style.display !== 'none' &&\n                !this.popupMenuContainer.contains(event.target)) {\n                this.hidePopupMenu();\n            }\n        };\n        this.fileBrowserManager = fileBrowserManager;\n        this.onItemSelected = onItemSelected;\n        // Initialize menu state\n        this.menuState = {\n            currentMenuLevel: 'top',\n            currentMenuPath: '',\n            menuHistory: []\n        };\n        // Create popup menu container\n        this.popupMenuContainer = document.createElement('div');\n        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';\n        this.popupMenuContainer.style.display = 'none';\n        document.body.appendChild(this.popupMenuContainer);\n        // Add click event listener to close menu when clicking outside\n        document.addEventListener('click', this.handleDocumentClick);\n    }\n    /**\n     * Shows the popup menu at the specified position\n     * @param x The x-coordinate of the popup menu\n     * @param y The y-coordinate of the popup menu\n     */\n    showPopupMenu(x, y) {\n        // Clear previous menu items\n        this.popupMenuContainer.innerHTML = '';\n        // Reset menu state for top level\n        this.menuState.currentMenuLevel = 'top';\n        this.menuState.menuHistory = [];\n        // Create top-level menu items\n        const commands = [\n            {\n                label: 'Code',\n                description: 'Insert selected code',\n                action: () => {\n                    this.hidePopupMenu();\n                    this.handleCodeCommand();\n                }\n            },\n            {\n                label: 'Cell',\n                description: 'Insert entire cell content',\n                action: () => {\n                    this.hidePopupMenu();\n                    this.handleCellCommand();\n                }\n            },\n            {\n                label: 'Files',\n                description: 'Browse and insert file content',\n                action: () => {\n                    this.menuState.currentMenuLevel = 'files';\n                    this.menuState.menuHistory.push({ level: 'top', path: '' });\n                    this.loadDirectoryContents(x, y);\n                }\n            },\n            {\n                label: 'Directories',\n                description: 'Browse and reference directories',\n                action: () => {\n                    this.menuState.currentMenuLevel = 'directories';\n                    this.menuState.menuHistory.push({ level: 'top', path: '' });\n                    this.loadDirectoryContents(x, y);\n                }\n            }\n        ];\n        this.createMenuItems(commands);\n        // Position and show the menu\n        this.positionMenu(x, y);\n    }\n    /**\n     * Creates menu items from commands and appends them to the popup menu container\n     * @param commands The array of commands to create menu items for\n     */\n    createMenuItems(commands) {\n        commands.forEach(command => {\n            const item = document.createElement('div');\n            item.className = 'jp-llm-ext-popup-menu-item';\n            const label = document.createElement('div');\n            label.className = 'jp-llm-ext-popup-menu-item-label';\n            label.textContent = command.label;\n            const description = document.createElement('div');\n            description.className = 'jp-llm-ext-popup-menu-item-description';\n            description.textContent = command.description;\n            item.appendChild(label);\n            item.appendChild(description);\n            item.addEventListener('click', (e) => {\n                e.stopPropagation();\n                command.action();\n            });\n            this.popupMenuContainer.appendChild(item);\n        });\n    }\n    /**\n     * Loads and displays directory contents in the popup menu\n     * @param x The x-coordinate of the popup menu\n     * @param y The y-coordinate of the popup menu\n     */\n    async loadDirectoryContents(x, y) {\n        // Show loading indicator\n        this.popupMenuContainer.innerHTML = '<div class=\"jp-llm-ext-popup-menu-loading\">Loading...</div>';\n        // Determine filter type based on menu level\n        const filterType = this.menuState.currentMenuLevel === 'files' ? 'file' : 'directory';\n        // Get directory contents\n        const contents = await this.fileBrowserManager.listCurrentDirectoryContents(filterType);\n        // Clear the menu\n        this.popupMenuContainer.innerHTML = '';\n        // Add back button if we have history\n        if (this.menuState.menuHistory.length > 0) {\n            const backCommand = {\n                label: '⬅️ Back',\n                description: 'Go back to previous menu',\n                action: () => {\n                    // Pop the last item from history\n                    const previous = this.menuState.menuHistory.pop();\n                    if (previous) {\n                        // Restore previous state\n                        this.menuState.currentMenuLevel = previous.level;\n                        // If going back to top level\n                        if (previous.level === 'top') {\n                            this.showPopupMenu(x, y);\n                        }\n                        else {\n                            // If going back to a directory level, we need to go up one directory\n                            this.fileBrowserManager.navigateToParentDirectory();\n                            this.loadDirectoryContents(x, y);\n                        }\n                    }\n                }\n            };\n            this.createMenuItems([backCommand]);\n            // Add current path indicator\n            const pathIndicator = document.createElement('div');\n            pathIndicator.className = 'jp-llm-ext-popup-menu-path';\n            pathIndicator.textContent = `Path: ${this.fileBrowserManager.getCurrentPath() || '/'}`;\n            this.popupMenuContainer.appendChild(pathIndicator);\n        }\n        // If no contents or error\n        if (!contents || contents.length === 0) {\n            const emptyMessage = document.createElement('div');\n            emptyMessage.className = 'jp-llm-ext-popup-menu-empty';\n            emptyMessage.textContent = 'No items found';\n            this.popupMenuContainer.appendChild(emptyMessage);\n        }\n        else {\n            // Create commands for each item\n            const commands = contents.map(item => {\n                return {\n                    label: item,\n                    description: '',\n                    action: () => {\n                        // Handle directory navigation\n                        if (item.startsWith('📁') && this.menuState.currentMenuLevel === 'directories') {\n                            // Navigate to subdirectory\n                            this.fileBrowserManager.navigateToSubdirectory(item);\n                            this.menuState.menuHistory.push({\n                                level: this.menuState.currentMenuLevel,\n                                path: this.fileBrowserManager.getCurrentPath()\n                            });\n                            this.loadDirectoryContents(x, y);\n                        }\n                        else {\n                            // Handle file selection\n                            this.hidePopupMenu();\n                            this.onItemSelected(item);\n                        }\n                    }\n                };\n            });\n            this.createMenuItems(commands);\n        }\n        // Reposition the menu\n        this.positionMenu(x, y);\n    }\n    /**\n     * Positions the popup menu at the specified coordinates\n     * @param x The x-coordinate\n     * @param y The y-coordinate\n     */\n    positionMenu(x, y) {\n        // Get viewport dimensions\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        // Get menu dimensions\n        const menuWidth = this.popupMenuContainer.offsetWidth;\n        const menuHeight = this.popupMenuContainer.offsetHeight;\n        // Adjust position to ensure menu stays within viewport\n        let adjustedX = x;\n        let adjustedY = y;\n        if (x + menuWidth > viewportWidth) {\n            adjustedX = viewportWidth - menuWidth - 10;\n        }\n        if (y + menuHeight > viewportHeight) {\n            adjustedY = viewportHeight - menuHeight - 10;\n        }\n        // Set position\n        this.popupMenuContainer.style.left = `${adjustedX}px`;\n        this.popupMenuContainer.style.top = `${adjustedY}px`;\n        this.popupMenuContainer.style.display = 'block';\n    }\n    /**\n     * Hides the popup menu\n     */\n    hidePopupMenu() {\n        // Only act if the menu is currently displayed\n        if (this.popupMenuContainer.style.display !== 'none') {\n            this.popupMenuContainer.style.display = 'none';\n            this.popupMenuContainer.innerHTML = '';\n        }\n    }\n    /**\n     * Handles the code command - inserts selected code\n     * Placeholder for implementation in SimpleSidebarWidget\n     */\n    handleCodeCommand() {\n        // This will be implemented by the SimpleSidebarWidget\n        console.log('Code command selected');\n    }\n    /**\n     * Handles the cell command - inserts entire cell content\n     * Placeholder for implementation in SimpleSidebarWidget\n     */\n    handleCellCommand() {\n        // This will be implemented by the SimpleSidebarWidget\n        console.log('Cell command selected');\n    }\n    /**\n     * Cleans up resources\n     */\n    dispose() {\n        document.removeEventListener('click', this.handleDocumentClick);\n        if (this.popupMenuContainer.parentNode) {\n            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);\n        }\n    }\n}\nexports.PopupMenuManager = PopupMenuManager;\n","\"use strict\";\n/**\n * Manages settings and configuration for the chat interface\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsManager = void 0;\n/**\n * Manages settings and configuration for the chat interface\n */\nclass SettingsManager {\n    constructor() {\n        this.defaultSettings = {\n            provider: 'OpenAI',\n            apiKey: '',\n            apiBaseUrl: '',\n            rules: ''\n        };\n        this.currentSettings = Object.assign({}, this.defaultSettings);\n        this.settingsModalContainer = this.createSettingsModal();\n        document.body.appendChild(this.settingsModalContainer);\n    }\n    /**\n     * Creates the settings modal\n     * @returns The created modal container\n     */\n    createSettingsModal() {\n        const modal = document.createElement('div');\n        modal.style.position = 'fixed';\n        modal.style.top = '0';\n        modal.style.left = '0';\n        modal.style.width = '100%';\n        modal.style.height = '100%';\n        modal.style.display = 'none';\n        modal.style.justifyContent = 'center';\n        modal.style.alignItems = 'center';\n        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n        modal.style.zIndex = '1000';\n        const content = document.createElement('div');\n        content.style.backgroundColor = '#fff';\n        content.style.padding = '20px';\n        content.style.borderRadius = '5px';\n        content.style.width = '400px';\n        const title = document.createElement('h3');\n        title.textContent = 'Settings';\n        content.appendChild(title);\n        const providerLabel = document.createElement('label');\n        providerLabel.htmlFor = 'settings-provider';\n        providerLabel.textContent = 'LLM Provider:';\n        content.appendChild(providerLabel);\n        const providerSelect = document.createElement('select');\n        providerSelect.id = 'settings-provider';\n        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {\n            const option = document.createElement('option');\n            option.value = opt;\n            option.textContent = opt;\n            providerSelect.appendChild(option);\n        });\n        content.appendChild(providerSelect);\n        content.appendChild(document.createElement('br'));\n        const keyLabel = document.createElement('label');\n        keyLabel.htmlFor = 'settings-api-key';\n        keyLabel.textContent = 'API Key:';\n        content.appendChild(keyLabel);\n        const keyInput = document.createElement('input');\n        keyInput.id = 'settings-api-key';\n        keyInput.type = 'text';\n        keyInput.style.width = '100%';\n        content.appendChild(keyInput);\n        content.appendChild(document.createElement('br'));\n        const urlLabel = document.createElement('label');\n        urlLabel.htmlFor = 'settings-api-base-url';\n        urlLabel.textContent = 'API Base URL (optional):';\n        content.appendChild(urlLabel);\n        const urlInput = document.createElement('input');\n        urlInput.id = 'settings-api-base-url';\n        urlInput.type = 'text';\n        urlInput.style.width = '100%';\n        content.appendChild(urlInput);\n        content.appendChild(document.createElement('br'));\n        const rulesLabel = document.createElement('label');\n        rulesLabel.htmlFor = 'settings-rules';\n        rulesLabel.textContent = 'Rules:';\n        content.appendChild(rulesLabel);\n        const rulesTextarea = document.createElement('textarea');\n        rulesTextarea.id = 'settings-rules';\n        rulesTextarea.style.width = '100%';\n        rulesTextarea.style.height = '100px';\n        content.appendChild(rulesTextarea);\n        content.appendChild(document.createElement('br'));\n        const btnContainer = document.createElement('div');\n        btnContainer.style.textAlign = 'right';\n        btnContainer.style.marginTop = '10px';\n        const saveBtn = document.createElement('button');\n        saveBtn.textContent = 'Save';\n        saveBtn.addEventListener('click', () => {\n            const provider = document.getElementById('settings-provider').value;\n            const key = document.getElementById('settings-api-key').value;\n            const url = document.getElementById('settings-api-base-url').value;\n            const rules = document.getElementById('settings-rules').value;\n            this.currentSettings = {\n                provider,\n                apiKey: key,\n                apiBaseUrl: url,\n                rules\n            };\n            console.log('Settings saved:', this.currentSettings);\n            this.hideSettingsModal();\n        });\n        const cancelBtn = document.createElement('button');\n        cancelBtn.textContent = 'Cancel';\n        cancelBtn.style.marginLeft = '10px';\n        cancelBtn.addEventListener('click', () => this.hideSettingsModal());\n        btnContainer.appendChild(saveBtn);\n        btnContainer.appendChild(cancelBtn);\n        content.appendChild(btnContainer);\n        modal.appendChild(content);\n        return modal;\n    }\n    /**\n     * Shows the settings modal\n     */\n    showSettingsModal() {\n        // Update form fields with current settings\n        document.getElementById('settings-provider').value = this.currentSettings.provider;\n        document.getElementById('settings-api-key').value = this.currentSettings.apiKey;\n        document.getElementById('settings-api-base-url').value = this.currentSettings.apiBaseUrl;\n        document.getElementById('settings-rules').value = this.currentSettings.rules;\n        this.settingsModalContainer.style.display = 'flex';\n    }\n    /**\n     * Hides the settings modal\n     */\n    hideSettingsModal() {\n        this.settingsModalContainer.style.display = 'none';\n    }\n    /**\n     * Gets the current settings\n     * @returns The current settings\n     */\n    getSettings() {\n        return Object.assign({}, this.currentSettings);\n    }\n    /**\n     * Cleans up resources\n     */\n    dispose() {\n        if (this.settingsModalContainer.parentNode) {\n            this.settingsModalContainer.parentNode.removeChild(this.settingsModalContainer);\n        }\n    }\n}\nexports.SettingsManager = SettingsManager;\n","\"use strict\";\n/**\n * Main sidebar widget for the AI chat interface in JupyterLab\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSidebarWidget = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst icons_1 = require(\"../icons\");\nconst globals_1 = require(\"../globals\");\n// Import modular components\nconst chat_history_manager_1 = require(\"./chat-history-manager\");\nconst file_browser_manager_1 = require(\"./file-browser-manager\");\nconst popup_menu_manager_1 = require(\"./popup-menu-manager\");\nconst message_renderer_1 = require(\"./message-renderer\");\nconst settings_manager_1 = require(\"./settings-manager\");\nconst input_handler_1 = require(\"./input-handler\");\n/**\n * Main sidebar widget for the AI chat interface in JupyterLab.\n * This widget provides a comprehensive chat-based interface for interacting with AI assistants,\n * supporting text input, Markdown rendering, file and directory browsing through a multi-level\n * pop-up menu, and chat history management. It integrates with JupyterLab's APIs to interact\n * with notebooks and manage document contexts.\n */\nclass SimpleSidebarWidget extends widgets_1.Widget {\n    /**\n     * Constructor for the SimpleSidebarWidget class.\n     * Initializes the widget with the provided document manager and sets up the basic UI components.\n     * @param docManager The document manager instance for interacting with JupyterLab documents.\n     */\n    constructor(docManager) {\n        super();\n        this.isHistoryViewActive = false;\n        /**\n         * Handles keyboard shortcuts for improved user experience.\n         * Currently supports Ctrl+L for inserting selected code or cell content.\n         * @param event The keyboard event triggered by the user.\n         */\n        this.handleKeyDown = (event) => {\n            // Check for Ctrl+L (for selected code)\n            if (event.ctrlKey && event.key === 'l') {\n                event.preventDefault();\n                this.handleCodeCommand();\n                this.showKeyboardShortcutIndicator('Selected code inserted');\n            }\n        };\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = icons_1.extensionIcon;\n        this.title.closable = true;\n        // Initialize container elements before creating layout\n        this.messageContainer = document.createElement('div');\n        this.inputContainer = document.createElement('div');\n        this.inputField = document.createElement('textarea');\n        this.titleInput = document.createElement('input');\n        this.historyContainer = document.createElement('div');\n        // Create keyboard shortcut indicator for user feedback\n        this.keyboardShortcutIndicator = document.createElement('div');\n        this.keyboardShortcutIndicator.className = 'keyboard-shortcut-indicator';\n        document.body.appendChild(this.keyboardShortcutIndicator);\n        // Initialize modular components\n        this.initializeModularComponents();\n        // Create a new chat on start\n        this.chatHistoryManager.createNewChat();\n        this.updateCurrentChatTitle();\n        // Create and add the main layout\n        this.node.appendChild(this.createLayout());\n        // Add keyboard shortcut listener for improved UX\n        document.addEventListener('keydown', this.handleKeyDown);\n    }\n    /**\n     * Initializes all modular components\n     */\n    initializeModularComponents() {\n        // Initialize chat history manager\n        this.chatHistoryManager = new chat_history_manager_1.ChatHistoryManager();\n        // Initialize file browser manager\n        this.fileBrowserManager = new file_browser_manager_1.FileBrowserManager(this.docManager);\n        // Initialize message renderer\n        this.messageRenderer = new message_renderer_1.MessageRenderer(this.messageContainer, this.copyMessageToClipboard.bind(this), this.addMessageToCell.bind(this));\n        // Initialize input handler\n        this.inputHandler = new input_handler_1.InputHandler(this.inputField, this.inputContainer, this.handleSendMessage.bind(this));\n        // Initialize popup menu manager\n        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.fileBrowserManager, this.appendToInput.bind(this));\n        // Initialize settings manager\n        this.settingsManager = new settings_manager_1.SettingsManager();\n    }\n    /**\n     * Shows a visual indicator for keyboard shortcuts.\n     * @param text The text to display in the indicator.\n     */\n    showKeyboardShortcutIndicator(text) {\n        this.keyboardShortcutIndicator.textContent = text;\n        this.keyboardShortcutIndicator.classList.add('visible');\n        // Hide after 1 second\n        setTimeout(() => {\n            this.keyboardShortcutIndicator.classList.remove('visible');\n        }, 1000);\n    }\n    /**\n     * Disposes all resources when the widget is closed.\n     */\n    dispose() {\n        // Remove keyboard shortcut listener\n        document.removeEventListener('keydown', this.handleKeyDown);\n        // Remove keyboard shortcut indicator\n        if (this.keyboardShortcutIndicator.parentNode) {\n            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);\n        }\n        // Dispose modular components\n        this.popupMenuManager.dispose();\n        this.settingsManager.dispose();\n        super.dispose();\n    }\n    /**\n     * Creates the main layout for the sidebar widget.\n     * Includes the title input, message container, history container, input field, and controls.\n     * @returns The main content element of the widget.\n     */\n    createLayout() {\n        // Create the main container\n        const container = document.createElement('div');\n        container.className = 'jp-llm-ext-container';\n        // Create title input container\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'jp-llm-ext-title-container';\n        this.titleInput.className = 'jp-llm-ext-title-input';\n        this.titleInput.placeholder = 'Chat Title';\n        this.titleInput.addEventListener('change', () => {\n            this.chatHistoryManager.updateCurrentChatTitle(this.titleInput.value);\n        });\n        titleContainer.appendChild(this.titleInput);\n        container.appendChild(titleContainer);\n        // Configure message container\n        this.messageContainer.className = 'jp-llm-ext-message-container';\n        container.appendChild(this.messageContainer);\n        // Configure history container\n        this.historyContainer.className = 'jp-llm-ext-history-container';\n        this.historyContainer.style.display = 'none'; // Initially hidden\n        container.appendChild(this.historyContainer);\n        // Create input area\n        const inputArea = document.createElement('div');\n        inputArea.className = 'jp-llm-ext-input-area';\n        // Configure input container and field\n        this.inputContainer.className = 'jp-llm-ext-input-container';\n        this.inputField.className = 'jp-llm-ext-input-field';\n        this.inputField.placeholder = 'Type your message here...';\n        this.inputContainer.appendChild(this.inputField);\n        inputArea.appendChild(this.inputContainer);\n        // Add controls container\n        inputArea.appendChild(this.createControlsContainer());\n        container.appendChild(inputArea);\n        return container;\n    }\n    /**\n     * Creates the controls container with toggles and action buttons.\n     * Includes the Markdown toggle, expand input button, settings button, and popup menu button.\n     * @returns The controls container element.\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'jp-llm-ext-controls-container';\n        // Create toggle buttons container\n        const togglesContainer = document.createElement('div');\n        togglesContainer.className = 'jp-llm-ext-toggles-container';\n        // Add Markdown toggle button\n        const markdownToggle = this.createButton('MD', 'Toggle Markdown mode');\n        markdownToggle.addEventListener('click', () => {\n            this.inputHandler.toggleMarkdownMode(markdownToggle);\n        });\n        togglesContainer.appendChild(markdownToggle);\n        // Add expand input button\n        const expandButton = this.createButton('\\u25b2', 'Expand input field');\n        expandButton.addEventListener('click', () => {\n            this.inputHandler.toggleInputExpansion(expandButton);\n        });\n        togglesContainer.appendChild(expandButton);\n        controlsContainer.appendChild(togglesContainer);\n        // Create action buttons container\n        const actionsContainer = document.createElement('div');\n        actionsContainer.className = 'jp-llm-ext-actions-container';\n        // Add history toggle button\n        const historyButton = this.createButton('\\ud83d\\udcc3', 'Toggle chat history');\n        historyButton.addEventListener('click', () => {\n            this.toggleHistoryView();\n        });\n        actionsContainer.appendChild(historyButton);\n        // Add settings button\n        const settingsButton = this.createButton('\\u2699\\ufe0f', 'Settings');\n        settingsButton.addEventListener('click', () => {\n            this.settingsManager.showSettingsModal();\n        });\n        actionsContainer.appendChild(settingsButton);\n        // Add send button\n        const sendButton = this.createButton('\\u27a4', 'Send message');\n        sendButton.addEventListener('click', this.handleSendMessage.bind(this));\n        actionsContainer.appendChild(sendButton);\n        // Add popup menu button (\"@\" button)\n        const popupMenuButton = this.createButton('@', 'Insert context');\n        popupMenuButton.addEventListener('click', (event) => {\n            // Get button position\n            const rect = popupMenuButton.getBoundingClientRect();\n            // Show popup menu at button position\n            this.popupMenuManager.showPopupMenu(rect.left, rect.bottom);\n        });\n        actionsContainer.appendChild(popupMenuButton);\n        controlsContainer.appendChild(actionsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Helper function to create a button with given text and tooltip.\n     * @param text The text to display on the button.\n     * @param tooltip The tooltip text to display on hover.\n     * @returns The created button element.\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        return button;\n    }\n    /**\n     * Toggles between chat view and history view.\n     * Updates the UI to show either the chat messages or the chat history list.\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Show history view\n            this.messageContainer.style.display = 'none';\n            this.historyContainer.style.display = 'block';\n            this.renderChatHistory();\n        }\n        else {\n            // Show chat view\n            this.messageContainer.style.display = 'block';\n            this.historyContainer.style.display = 'none';\n        }\n    }\n    /**\n     * Renders the chat history in the history container.\n     * Creates a list of chat history items and populates the history container.\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = '';\n        const chats = this.chatHistoryManager.getAllChats();\n        // Create new chat button\n        const newChatButton = document.createElement('div');\n        newChatButton.className = 'jp-llm-ext-history-item jp-llm-ext-new-chat';\n        newChatButton.textContent = '+ New Chat';\n        newChatButton.addEventListener('click', () => {\n            this.createNewChat();\n            this.toggleHistoryView(); // Switch back to chat view\n        });\n        this.historyContainer.appendChild(newChatButton);\n        if (chats.length === 0) {\n            const emptyMessage = document.createElement('div');\n            emptyMessage.className = 'jp-llm-ext-history-empty';\n            emptyMessage.textContent = 'No chat history yet';\n            this.historyContainer.appendChild(emptyMessage);\n            return;\n        }\n        // Create a list item for each chat\n        chats.forEach(chat => {\n            const chatItem = document.createElement('div');\n            chatItem.className = 'jp-llm-ext-history-item';\n            if (chat.id === this.chatHistoryManager.getCurrentChatId()) {\n                chatItem.classList.add('jp-llm-ext-history-item-active');\n            }\n            const chatTitle = document.createElement('div');\n            chatTitle.className = 'jp-llm-ext-history-item-title';\n            chatTitle.textContent = chat.title;\n            chatItem.appendChild(chatTitle);\n            const chatInfo = document.createElement('div');\n            chatInfo.className = 'jp-llm-ext-history-item-info';\n            chatInfo.textContent = `${chat.messages.length} messages`;\n            chatItem.appendChild(chatInfo);\n            chatItem.addEventListener('click', () => {\n                this.loadChat(chat.id);\n                this.toggleHistoryView(); // Switch back to chat view\n            });\n            this.historyContainer.appendChild(chatItem);\n        });\n    }\n    /**\n     * Creates a new chat session.\n     * Generates a unique ID, creates a new chat item, adds it to history, and updates the UI.\n     */\n    createNewChat() {\n        // Create new chat using the manager\n        this.chatHistoryManager.createNewChat();\n        // Update UI\n        this.updateCurrentChatTitle();\n        this.messageRenderer.clearMessages();\n        // Add welcome message\n        this.addMessage('Welcome to the AI Chat Interface. How can I help you today?', 'bot', true, false // Don't save welcome message to history\n        );\n    }\n    /**\n     * Loads a chat from history.\n     * Updates the UI to show the selected chat's messages and title.\n     * @param chatId The ID of the chat to load.\n     */\n    loadChat(chatId) {\n        const chat = this.chatHistoryManager.loadChat(chatId);\n        if (chat) {\n            // Update UI\n            this.updateCurrentChatTitle();\n            this.messageRenderer.renderMessages(chat.messages);\n        }\n    }\n    /**\n     * Updates the title of the current chat.\n     * Updates the title input field with the new title.\n     */\n    updateCurrentChatTitle() {\n        const chat = this.chatHistoryManager.getCurrentChat();\n        if (chat) {\n            this.titleInput.value = chat.title;\n        }\n    }\n    /**\n     * Handles sending a message from the input field.\n     * Sends the message to the API, updates the UI with the response, and saves the message to chat history.\n     */\n    handleSendMessage() {\n        const message = this.inputHandler.getInputText().trim();\n        if (!message)\n            return;\n        // Add user message to UI\n        this.addMessage(message, 'user', false);\n        // Clear input field\n        this.inputHandler.clearInput();\n        // Add temporary \"thinking\" message\n        const thinkingMessage = this.addMessage('Thinking...', 'bot', false, false);\n        // Send message to API (mock implementation for now)\n        this.mockSendMessage(message)\n            .then((response) => {\n            // Remove thinking message\n            if (thinkingMessage && thinkingMessage.parentNode) {\n                thinkingMessage.parentNode.removeChild(thinkingMessage);\n            }\n            // Add bot response\n            this.addMessage(response, 'bot', true);\n        })\n            .catch((error) => {\n            console.error('Error sending message:', error);\n            // Remove thinking message\n            if (thinkingMessage && thinkingMessage.parentNode) {\n                thinkingMessage.parentNode.removeChild(thinkingMessage);\n            }\n            // Add error message\n            this.addMessage('Sorry, there was an error processing your request. Please try again.', 'bot', false);\n        });\n    }\n    /**\n     * Mock implementation of sending a message to the API\n     * @param message The message to send\n     * @returns A promise that resolves to the response\n     */\n    mockSendMessage(message) {\n        return new Promise((resolve) => {\n            // Simulate a delay\n            setTimeout(() => {\n                resolve(`I received your message: \"${message}\". This is a mock response.`);\n            }, 1000);\n        });\n    }\n    /**\n     * Adds a message to the chat interface.\n     * Creates a new message element and appends it to the message container.\n     * @param text The text content of the message.\n     * @param sender The sender of the message ('user' or 'bot').\n     * @param isMarkdown Whether the message is in Markdown format.\n     * @param saveToHistory Whether to save the message to chat history.\n     * @returns The created message element.\n     */\n    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {\n        // Save to chat history if needed\n        if (saveToHistory) {\n            this.chatHistoryManager.addMessage(text, sender, isMarkdown);\n        }\n        // Render the message\n        return this.messageRenderer.renderMessage(text, sender, isMarkdown);\n    }\n    /**\n     * Copies message content to clipboard.\n     * @param text The text content to copy.\n     */\n    copyMessageToClipboard(text) {\n        try {\n            navigator.clipboard.writeText(text)\n                .then(() => {\n                console.log('Text copied to clipboard');\n            })\n                .catch(err => {\n                console.error('Failed to copy text: ', err);\n                this.fallbackCopyToClipboard(text);\n            });\n        }\n        catch (error) {\n            console.error('Copy to clipboard error:', error);\n            this.fallbackCopyToClipboard(text);\n        }\n    }\n    /**\n     * Fallback method for copying to clipboard using a temporary textarea element.\n     * @param text The text to copy.\n     */\n    fallbackCopyToClipboard(text) {\n        try {\n            const textArea = document.createElement('textarea');\n            textArea.value = text;\n            textArea.style.position = 'fixed';\n            document.body.appendChild(textArea);\n            textArea.focus();\n            textArea.select();\n            document.execCommand('copy');\n            document.body.removeChild(textArea);\n            console.log('Fallback: Text copied to clipboard');\n        }\n        catch (error) {\n            console.error('Fallback: Could not copy text: ', error);\n        }\n    }\n    /**\n     * Adds message content to the current cell.\n     * @param text The text content to add.\n     */\n    addMessageToCell(text) {\n        var _a;\n        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (!cell) {\n            console.error('No active cell found');\n            return;\n        }\n        try {\n            // Get current content and cursor position\n            const editor = cell.editor;\n            if (!editor) {\n                console.error('No editor found in cell');\n                return;\n            }\n            const position = editor.getCursorPosition();\n            const currentText = editor.model.sharedModel.getSource();\n            // Insert text at cursor position\n            const beforeCursor = currentText.substring(0, position.column);\n            const afterCursor = currentText.substring(position.column);\n            // Determine if we need to add newlines\n            const needsLeadingNewline = beforeCursor.length > 0 && !beforeCursor.endsWith('\\n');\n            const needsTrailingNewline = afterCursor.length > 0 && !afterCursor.startsWith('\\n');\n            let insertText = '';\n            if (needsLeadingNewline)\n                insertText += '\\n';\n            insertText += text;\n            if (needsTrailingNewline)\n                insertText += '\\n';\n            // Set the new text\n            editor.model.sharedModel.setSource(beforeCursor + insertText + afterCursor);\n        }\n        catch (error) {\n            console.error('Error adding text to cell:', error);\n        }\n    }\n    /**\n     * Appends text to the input field with proper spacing.\n     * @param text The text to append.\n     */\n    appendToInput(text) {\n        this.inputHandler.appendToInput(text);\n    }\n    /**\n     * Gets the selected text from cell context.\n     * @returns The selected text or an empty string if no selection.\n     */\n    getSelectedText() {\n        var _a;\n        // Get the current active cell from the tracker\n        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (!cell)\n            return '';\n        // Get the selected text from the editor\n        const editor = cell.editor;\n        if (!editor)\n            return '';\n        const selection = editor.getSelection();\n        if (!selection)\n            return '';\n        // Extract the selected text\n        const { start, end } = selection;\n        const text = editor.model.sharedModel.getSource();\n        const lines = text.split('\\n');\n        // If selection is within a single line\n        if (start.line === end.line) {\n            return lines[start.line].substring(start.column, end.column);\n        }\n        // If selection spans multiple lines\n        let selectedText = lines[start.line].substring(start.column) + '\\n';\n        for (let i = start.line + 1; i < end.line; i++) {\n            selectedText += lines[i] + '\\n';\n        }\n        selectedText += lines[end.line].substring(0, end.column);\n        return selectedText;\n    }\n    /**\n     * Handles the code command - inserts selected code.\n     */\n    handleCodeCommand() {\n        const selectedText = this.getSelectedText();\n        if (selectedText) {\n            this.appendToInput(selectedText);\n        }\n        else {\n            console.log('No code selected');\n        }\n    }\n}\nexports.SimpleSidebarWidget = SimpleSidebarWidget;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerCommands = registerCommands;\nconst icons_1 = require(\"./icons\");\n/**\n * Registers commands for the extension\n */\nfunction registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: icons_1.extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globals = void 0;\nexports.initGlobals = initGlobals;\n/**\n * Global references to key components in the application\n */\nexports.globals = {};\n/**\n * Initialize global references\n */\nfunction initGlobals(app, notebookTracker) {\n    exports.globals.app = app;\n    exports.globals.notebookTracker = notebookTracker;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extensionIcon = void 0;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexports.extensionIcon = new ui_components_1.LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\nconst launcher_1 = require(\"@jupyterlab/launcher\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst docmanager_1 = require(\"@jupyterlab/docmanager\");\n// Import the modularized SimpleSidebarWidget from the new location\nconst sidebar_widget_1 = require(\"./chat/sidebar-widget\");\nconst globals_1 = require(\"./globals\");\nconst commands_1 = require(\"./commands\");\nconst cell_context_tracker_1 = require(\"./cell-context-tracker\");\n// Export ApiClient for use by other components\nvar api_client_1 = require(\"./api-client\");\nObject.defineProperty(exports, \"ApiClient\", { enumerable: true, get: function () { return api_client_1.ApiClient; } });\n/**\n * Initialization data for the jupyter-simple-extension extension.\n * This plugin integrates a custom sidebar with JupyterLab for enhanced functionality.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references for app and notebook tracking\n        (0, globals_1.initGlobals)(jupyterApp, tracker);\n        // Initialize cell context tracker to monitor active cells and contexts\n        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget for user interaction and context insertion\n        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands for interacting with the extension via command palette and launcher\n        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexports.default = plugin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.configureMarked = configureMarked;\nexports.preprocessMarkdown = preprocessMarkdown;\nconst marked_1 = require(\"marked\");\n/**\n * Configure marked with better rendering options for code blocks\n */\nfunction configureMarked() {\n    // Configure marked options\n    marked_1.marked.setOptions({\n        gfm: true, // Enable GitHub Flavored Markdown\n        breaks: true, // Add <br> on single line breaks\n        pedantic: false, // Conform to original markdown spec\n        async: false, // Disable async rendering\n        silent: false // Enable error reporting\n    });\n}\n/**\n * Pre-process markdown text to fix common issues with streaming content\n */\nfunction preprocessMarkdown(text) {\n    // Handle code blocks first\n    let inCodeBlock = false;\n    const lines = text.split('\\n');\n    const processedLines = lines.map((line, i) => {\n        // Check for code block markers\n        if (line.trim().startsWith('```')) {\n            inCodeBlock = !inCodeBlock;\n            // Preserve language specification\n            return line.trim();\n        }\n        // If we're in a code block, preserve the line as is\n        if (inCodeBlock) {\n            return line;\n        }\n        // Outside code blocks, handle list items\n        return line.replace(/([^\\n\\s])-\\s/g, '$1\\n- ');\n    });\n    return processedLines.join('\\n');\n}\n"],"names":[],"sourceRoot":""}