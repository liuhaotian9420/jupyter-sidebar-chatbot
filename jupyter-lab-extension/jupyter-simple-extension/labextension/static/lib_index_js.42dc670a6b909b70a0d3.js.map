{"version":3,"file":"lib_index_js.42dc670a6b909b70a0d3.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACrEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC7Ib;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,+BAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB,IAAI,+BAA+B;AACnC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;;;;;;;;;;ACjBY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,+BAA+B,mBAAO,CAAC,6DAAwB;AAC/D,YAAY,YAAY;AACxB;AACA,mBAAmB,mBAAO,CAAC,yCAAc;AACzC,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACnCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B;AAC1B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;ACxCa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,gBAAgB,mBAAO,CAAC,+BAAS;AACjC,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C,0BAA0B,mBAAO,CAAC,mDAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC,EAAE,0CAA0C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,+GAA+G;AAC7H,cAAc,oDAAoD,wBAAwB,yBAAyB,6BAA6B;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC,iBAAiB;AACjB,6BAA6B;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,YAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA,qEAAqE,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,cAAc,OAAO;AACtF,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF,8CAA8C,MAAM,EAAE,UAAU,IAAI;AACpE;AACA,qBAAqB;AACrB,iEAAiE,kBAAkB,sBAAsB,WAAW;AACpH,sCAAsC;AACtC;AACA;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,sBAAsB,KAAK,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,0DAA0D;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAA0D;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAA0D;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,gDAAgD,EAAE;AAClD,+CAA+C,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+DAA+D;AAC/D;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,KAAK;AAC3E;AACA,oDAAoD,0DAA0D;AAC9G;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB,GAAG,KAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB,GAAG,KAAK;AAC3E;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,wDAAwD,qBAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,MAAM,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B","sources":["webpack://jupyter-simple-extension/./lib/api-client.js","webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/globals.js","webpack://jupyter-simple-extension/./lib/icons.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/markdown-config.js","webpack://jupyter-simple-extension/./lib/sidebar-widget.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\n/**\n * API client for interacting with the backend LLM service\n */\nclass ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\nexports.ApiClient = ApiClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CellContextTracker = void 0;\n/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nclass CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\nexports.CellContextTracker = CellContextTracker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerCommands = registerCommands;\nconst icons_1 = require(\"./icons\");\n/**\n * Registers commands for the extension\n */\nfunction registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: icons_1.extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globals = void 0;\nexports.initGlobals = initGlobals;\n/**\n * Global references to key components in the application\n */\nexports.globals = {};\n/**\n * Initialize global references\n */\nfunction initGlobals(app, notebookTracker) {\n    exports.globals.app = app;\n    exports.globals.notebookTracker = notebookTracker;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extensionIcon = void 0;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexports.extensionIcon = new ui_components_1.LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\nconst launcher_1 = require(\"@jupyterlab/launcher\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst docmanager_1 = require(\"@jupyterlab/docmanager\");\nconst sidebar_widget_1 = require(\"./sidebar-widget\");\nconst globals_1 = require(\"./globals\");\nconst commands_1 = require(\"./commands\");\nconst cell_context_tracker_1 = require(\"./cell-context-tracker\");\n// import { ApiClient } from './api-client';\n// Export ApiClient for use by other components\nvar api_client_1 = require(\"./api-client\");\nObject.defineProperty(exports, \"ApiClient\", { enumerable: true, get: function () { return api_client_1.ApiClient; } });\n/**\n * Initialization data for the jupyter-simple-extension extension.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references\n        (0, globals_1.initGlobals)(jupyterApp, tracker);\n        // Initialize cell context tracker\n        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget\n        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands\n        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexports.default = plugin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.configureMarked = configureMarked;\nexports.preprocessMarkdown = preprocessMarkdown;\nconst marked_1 = require(\"marked\");\n/**\n * Configure marked with better rendering options for code blocks\n */\nfunction configureMarked() {\n    // Configure marked options\n    marked_1.marked.setOptions({\n        gfm: true, // Enable GitHub Flavored Markdown\n        breaks: true, // Add <br> on single line breaks\n        pedantic: false, // Conform to original markdown spec\n        async: false, // Disable async rendering\n        silent: false // Enable error reporting\n    });\n}\n/**\n * Pre-process markdown text to fix common issues with streaming content\n */\nfunction preprocessMarkdown(text) {\n    // Handle code blocks first\n    let inCodeBlock = false;\n    const lines = text.split('\\n');\n    const processedLines = lines.map((line, i) => {\n        // Check for code block markers\n        if (line.trim().startsWith('```')) {\n            inCodeBlock = !inCodeBlock;\n            // Preserve language specification\n            return line.trim();\n        }\n        // If we're in a code block, preserve the line as is\n        if (inCodeBlock) {\n            return line;\n        }\n        // Outside code blocks, handle list items\n        return line.replace(/([^\\n\\s])-\\s/g, '$1\\n- ');\n    });\n    return processedLines.join('\\n');\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSidebarWidget = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst marked_1 = require(\"marked\");\nconst dompurify_1 = __importDefault(require(\"dompurify\"));\nconst icons_1 = require(\"./icons\");\nconst globals_1 = require(\"./globals\");\nconst api_client_1 = require(\"./api-client\");\nconst markdown_config_1 = require(\"./markdown-config\");\n// Configure marked with our settings\n(0, markdown_config_1.configureMarked)();\n/**\n * Main sidebar widget for the AI chat interface\n */\nclass SimpleSidebarWidget extends widgets_1.Widget {\n    constructor(docManager) {\n        super();\n        this.isMarkdownMode = false;\n        this.isInputExpanded = false;\n        this.chatHistory = [];\n        this.currentChatId = '';\n        this.isHistoryViewActive = false;\n        this.currentNotebook = null;\n        // Menu navigation state\n        this.currentMenuLevel = 'top';\n        this.currentMenuPath = '';\n        this.menuHistory = [];\n        /**\n         * Handles keyboard shortcuts\n         */\n        this.handleKeyDown = (event) => {\n            var _a, _b;\n            // Check for Ctrl+L (for selected code)\n            if (event.ctrlKey && event.key.toLowerCase() === 'l') {\n                // Prevent default browser behavior\n                event.preventDefault();\n                event.stopPropagation();\n                // Get the current active cell\n                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n                if (!cell || !cell.editor) {\n                    return;\n                }\n                try {\n                    // Get the CodeMirror editor instance\n                    const editor = cell.editor;\n                    const view = editor.editor;\n                    if (!view) {\n                        return;\n                    }\n                    // Check if there's a selection\n                    const state = view.state;\n                    const selection = state.selection;\n                    if (!selection.main.empty) {\n                        // If there's a selection, use @code\n                        const from = selection.main.from;\n                        const to = selection.main.to;\n                        const selectedText = state.doc.sliceString(from, to);\n                        this.appendToInput(`@code\\n${selectedText}`);\n                        this.showKeyboardShortcutIndicator('Selected code inserted');\n                    }\n                    else {\n                        // If no selection, use @cell\n                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();\n                        if (cellContext) {\n                            this.appendToInput(`@cell\\n${cellContext.text}`);\n                            this.showKeyboardShortcutIndicator('Cell content inserted');\n                        }\n                    }\n                    // Ensure the sidebar is visible and focused\n                    if (this.isHidden) {\n                        this.show();\n                    }\n                    this.inputField.focus();\n                }\n                catch (error) {\n                    console.error('Error handling keyboard shortcut:', error);\n                }\n            }\n        };\n        /**\n         * Handles clicks outside the popup menu to close it.\n         */\n        this.handleClickOutside = (event) => {\n            // Check if the click is outside the popup menu container\n            if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {\n                console.log('POPUP: Click detected outside popup menu.');\n                this.hidePopupMenu();\n                document.removeEventListener('click', this.handleClickOutside);\n            }\n        };\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = icons_1.extensionIcon;\n        this.title.closable = true;\n        // Initialize API client\n        this.apiClient = new api_client_1.ApiClient();\n        // Track the current notebook\n        if (globals_1.globals.notebookTracker) {\n            // Set initial notebook if one is active\n            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;\n            // Update currentNotebook when the active notebook changes\n            globals_1.globals.notebookTracker.currentChanged.connect((_, notebook) => {\n                this.currentNotebook = notebook;\n            });\n        }\n        // Initialize container elements before creating layout\n        this.messageContainer = document.createElement('div');\n        this.inputContainer = document.createElement('div');\n        this.inputField = document.createElement('textarea');\n        this.titleInput = document.createElement('input');\n        this.historyContainer = document.createElement('div');\n        this.popupMenuContainer = document.createElement('div');\n        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container'; // Renamed class\n        this.popupMenuContainer.style.display = 'none'; // Hidden by default\n        // Create keyboard shortcut indicator\n        this.keyboardShortcutIndicator = document.createElement('div');\n        this.keyboardShortcutIndicator.className = 'keyboard-shortcut-indicator';\n        document.body.appendChild(this.keyboardShortcutIndicator);\n        // Create settings modal\n        this.settingsModalContainer = this.createSettingsModal();\n        this.node.appendChild(this.settingsModalContainer);\n        // Create a new chat on start\n        this.createNewChat();\n        this.node.appendChild(this.createLayout());\n        // Pop-up menu will be attached to document.body when shown\n        // Add keyboard shortcut listener\n        document.addEventListener('keydown', this.handleKeyDown);\n    }\n    /**\n     * Shows a visual indicator for keyboard shortcuts\n     */\n    showKeyboardShortcutIndicator(text) {\n        this.keyboardShortcutIndicator.textContent = text;\n        this.keyboardShortcutIndicator.classList.add('visible');\n        // Hide after 1 second\n        setTimeout(() => {\n            this.keyboardShortcutIndicator.classList.remove('visible');\n        }, 1000);\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        // Remove keyboard shortcut listener\n        document.removeEventListener('keydown', this.handleKeyDown);\n        // Remove keyboard shortcut indicator\n        if (this.keyboardShortcutIndicator.parentNode) {\n            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);\n        }\n        super.dispose();\n    }\n    /**\n     * Creates the main layout for the sidebar\n     */\n    createLayout() {\n        // Create the main container\n        const content = document.createElement('div');\n        content.className = 'simple-sidebar-content';\n        // Create title input container\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'title-container';\n        // Set up title input\n        this.titleInput.className = 'chat-title-input';\n        this.titleInput.type = 'text';\n        this.titleInput.placeholder = 'Chat title';\n        this.titleInput.value = 'New Chat';\n        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());\n        titleContainer.appendChild(this.titleInput);\n        // Configure top action buttons (New Chat & History)\n        const topActionsContainer = document.createElement('div');\n        topActionsContainer.className = 'top-actions-container';\n        const newChatButton = document.createElement('button');\n        newChatButton.className = 'jp-Button action-button';\n        newChatButton.textContent = '+ New Chat';\n        newChatButton.title = 'Start a new chat';\n        newChatButton.addEventListener('click', () => this.createNewChat());\n        const historyButton = document.createElement('button');\n        historyButton.className = 'jp-Button action-button';\n        historyButton.textContent = 'History';\n        historyButton.title = 'View chat history';\n        historyButton.addEventListener('click', () => this.toggleHistoryView());\n        topActionsContainer.appendChild(newChatButton);\n        topActionsContainer.appendChild(historyButton);\n        // Configure message container\n        this.messageContainer.className = 'message-container';\n        // Configure history container\n        this.historyContainer.className = 'history-container';\n        this.historyContainer.style.display = 'none'; // Initially hidden\n        // Configure input container\n        this.inputContainer.className = 'input-container';\n        // Create controls container\n        const controlsContainer = this.createControlsContainer();\n        // Configure input field\n        this.inputField.placeholder = 'Ask me anything...';\n        this.inputField.style.flexGrow = '1';\n        this.inputField.style.padding = '5px';\n        this.inputField.style.border = '1px solid #ccc';\n        this.inputField.style.borderRadius = '3px';\n        this.inputField.style.resize = 'none';\n        this.inputField.rows = 1;\n        this.inputField.style.overflowY = 'auto';\n        // Add keypress listener to input field\n        this.inputField.addEventListener('keypress', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.handleSendMessage();\n            }\n        });\n        // Create send button container\n        const inputActionsContainer = document.createElement('div');\n        inputActionsContainer.className = 'input-actions-container';\n        // Create send button\n        const sendButton = document.createElement('button');\n        sendButton.className = 'jp-Button send-button';\n        sendButton.textContent = 'Send';\n        sendButton.addEventListener('click', () => this.handleSendMessage());\n        // Add button to actions container\n        inputActionsContainer.appendChild(sendButton);\n        // Assemble the input components\n        this.inputContainer.appendChild(controlsContainer);\n        this.inputContainer.appendChild(this.inputField);\n        this.inputContainer.appendChild(inputActionsContainer);\n        // Assemble all components\n        content.appendChild(topActionsContainer);\n        content.appendChild(titleContainer);\n        content.appendChild(this.messageContainer);\n        content.appendChild(this.historyContainer);\n        content.appendChild(this.inputContainer);\n        return content;\n    }\n    /**\n     * Creates a new chat session\n     */\n    createNewChat() {\n        // Generate a unique ID for the chat\n        const chatId = `chat-${Date.now()}`;\n        // Create a new chat item\n        const newChat = {\n            id: chatId,\n            title: 'New Chat',\n            messages: []\n        };\n        // Add to history\n        this.chatHistory.push(newChat);\n        // Set as current chat\n        this.currentChatId = chatId;\n        // Update title input\n        this.titleInput.value = newChat.title;\n        // Clear message container\n        if (this.messageContainer) {\n            this.messageContainer.innerHTML = '';\n        }\n        // Hide history if it's visible\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView();\n        }\n    }\n    /**\n     * Toggles between chat view and history view\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Show history view, hide message view\n            this.messageContainer.style.display = 'none';\n            this.historyContainer.style.display = 'block';\n            this.inputContainer.style.display = 'none';\n            this.titleInput.style.display = 'none';\n            // Populate history\n            this.renderChatHistory();\n        }\n        else {\n            // Show message view, hide history view\n            this.messageContainer.style.display = 'block';\n            this.historyContainer.style.display = 'none';\n            this.inputContainer.style.display = 'flex';\n            this.titleInput.style.display = 'block';\n        }\n    }\n    /**\n     * Renders the chat history in the history container\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = '';\n        if (this.chatHistory.length === 0) {\n            const emptyMessage = document.createElement('div');\n            emptyMessage.className = 'empty-history-message';\n            emptyMessage.textContent = 'No chat history yet';\n            this.historyContainer.appendChild(emptyMessage);\n            return;\n        }\n        // Create a list of chat history items\n        this.chatHistory.forEach(chat => {\n            const historyItem = document.createElement('div');\n            historyItem.className = 'history-item';\n            if (chat.id === this.currentChatId) {\n                historyItem.classList.add('active');\n            }\n            // Add title\n            const title = document.createElement('div');\n            title.className = 'history-title';\n            title.textContent = chat.title;\n            // Add message preview\n            const preview = document.createElement('div');\n            preview.className = 'history-preview';\n            const lastMessage = chat.messages[chat.messages.length - 1];\n            preview.textContent = lastMessage\n                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`\n                : 'Empty chat';\n            // Add click event\n            historyItem.addEventListener('click', () => this.loadChat(chat.id));\n            historyItem.appendChild(title);\n            historyItem.appendChild(preview);\n            this.historyContainer.appendChild(historyItem);\n        });\n    }\n    /**\n     * Loads a chat from history\n     */\n    loadChat(chatId) {\n        const chat = this.chatHistory.find(c => c.id === chatId);\n        if (!chat)\n            return;\n        // Set as current chat\n        this.currentChatId = chatId;\n        // Update title\n        this.titleInput.value = chat.title;\n        // Clear and re-populate message container\n        this.messageContainer.innerHTML = '';\n        chat.messages.forEach(msg => {\n            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);\n        });\n        // Switch back to chat view\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView();\n        }\n    }\n    /**\n     * Updates the title of the current chat\n     */\n    updateCurrentChatTitle() {\n        const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n        if (chat) {\n            chat.title = this.titleInput.value;\n        }\n    }\n    /**\n     * Creates the controls container with toggles and action buttons\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'controls-container';\n        // Create markdown toggle container\n        const toggleContainer = document.createElement('div');\n        toggleContainer.className = 'toggle-container';\n        // Create markdown toggle\n        const markdownToggle = document.createElement('input');\n        markdownToggle.type = 'checkbox';\n        markdownToggle.id = 'markdown-toggle';\n        markdownToggle.style.marginRight = '5px';\n        markdownToggle.addEventListener('change', (e) => {\n            const target = e.target;\n            this.isMarkdownMode = target.checked;\n            this.inputField.placeholder = this.isMarkdownMode ?\n                'Write markdown here...\\n\\n# Example heading\\n- List item\\n\\n```code block```' :\n                'Ask me anything...';\n        });\n        // Create toggle label\n        const toggleLabel = document.createElement('label');\n        toggleLabel.htmlFor = 'markdown-toggle';\n        toggleLabel.textContent = 'Markdown mode';\n        toggleLabel.style.fontSize = '12px';\n        // Add toggle elements to container\n        toggleContainer.appendChild(markdownToggle);\n        toggleContainer.appendChild(toggleLabel);\n        // Create action buttons container\n        const actionButtonsContainer = document.createElement('div');\n        actionButtonsContainer.className = 'action-buttons-container';\n        // Create all action buttons\n        const buttons = [\n            {\n                text: '@',\n                title: 'Command list',\n                action: (event) => {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    const rect = event.currentTarget.getBoundingClientRect();\n                    this.showPopupMenu(rect.left, rect.bottom);\n                }\n            },\n            { text: '⤢', title: 'Expand input', action: () => this.toggleInputExpansion(actionButtonsContainer.children[3]) },\n            { text: '⚙️', title: 'Settings', action: (event) => { event.preventDefault(); event.stopPropagation(); this.showSettingsModal(); } },\n        ];\n        // Add all buttons to the container\n        buttons.forEach(button => {\n            const btn = this.createButton(button.text, button.title);\n            btn.addEventListener('click', (e) => button.action(e));\n            actionButtonsContainer.appendChild(btn);\n        });\n        // Add toggle and action buttons to the controls container\n        controlsContainer.appendChild(toggleContainer);\n        controlsContainer.appendChild(actionButtonsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Toggles the expansion state of the input field\n     */\n    toggleInputExpansion(button) {\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.inputField.style.height = '100px';\n            this.inputField.style.resize = 'vertical';\n            button.textContent = '⤡';\n            button.title = 'Collapse input';\n        }\n        else {\n            this.inputField.style.height = 'auto';\n            this.inputField.style.resize = 'none';\n            button.textContent = '⤢';\n            button.title = 'Expand input';\n        }\n    }\n    /**\n     * Helper function to create a button with given text and tooltip\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        button.className = 'jp-Button action-button';\n        return button;\n    }\n    /**\n     * Handles sending a message from the input field\n     */\n    handleSendMessage() {\n        const message = this.inputField.value.trim();\n        if (message) {\n            // Add user message to UI\n            this.addMessage(message, 'user', this.isMarkdownMode);\n            this.inputField.value = '';\n            // Reset expanded state if needed after sending\n            if (this.isInputExpanded) {\n                this.inputField.style.height = '100px';\n            }\n            else {\n                this.inputField.style.height = 'auto';\n                this.inputField.rows = 1;\n            }\n            // Create a temporary message container for the bot's streaming response\n            const botMessageDiv = document.createElement('div');\n            botMessageDiv.className = 'bot-message';\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            botMessageDiv.appendChild(markdownIndicator);\n            // Create separate divs for streaming text and final markdown\n            const streamingDiv = document.createElement('div');\n            streamingDiv.className = 'streaming-content';\n            streamingDiv.style.whiteSpace = 'pre-wrap';\n            streamingDiv.style.fontFamily = 'monospace';\n            streamingDiv.style.fontSize = '0.9em';\n            botMessageDiv.appendChild(streamingDiv);\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'markdown-content';\n            contentDiv.style.display = 'none'; // Initially hidden\n            botMessageDiv.appendChild(contentDiv);\n            this.messageContainer.appendChild(botMessageDiv);\n            // Variable to collect the complete response\n            let completeResponse = '';\n            // Get cell context if available\n            const cellContext = globals_1.globals.cellContextTracker ?\n                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;\n            // Stream response from API\n            this.apiClient.streamChat(message, { cellContext }, \n            // On each chunk received\n            (chunk) => {\n                completeResponse += chunk;\n                streamingDiv.textContent = completeResponse;\n                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n            }, \n            // On complete\n            () => {\n                // Hide streaming div, show markdown div\n                streamingDiv.style.display = 'none';\n                contentDiv.style.display = 'block';\n                // Pre-process and render markdown\n                try {\n                    // Pre-process the markdown to fix any issues with code blocks\n                    const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(completeResponse);\n                    // Parse and sanitize\n                    const rawHtml = marked_1.marked.parse(processedMarkdown);\n                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n                    // Apply the HTML with proper code block styling\n                    contentDiv.innerHTML = sanitizedHtml;\n                    // Add syntax highlighting classes to code blocks\n                    const codeBlocks = contentDiv.querySelectorAll('pre code');\n                    codeBlocks.forEach(block => {\n                        var _a;\n                        block.classList.add('jp-RenderedText');\n                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');\n                    });\n                    // Add action buttons to the bot message\n                    console.log('Adding action buttons to streamed bot message');\n                    const actionsDiv = document.createElement('div');\n                    actionsDiv.className = 'message-actions';\n                    actionsDiv.style.display = 'flex'; // Ensure display is set\n                    // Copy button with icon\n                    const copyButton = document.createElement('button');\n                    copyButton.className = 'message-action-button';\n                    copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                    copyButton.title = 'Copy message to clipboard';\n                    copyButton.addEventListener('click', (event) => {\n                        event.stopPropagation();\n                        this.copyMessageToClipboard(completeResponse);\n                    });\n                    actionsDiv.appendChild(copyButton);\n                    // Add to button with icon\n                    const addToButton = document.createElement('button');\n                    addToButton.className = 'message-action-button';\n                    addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                    addToButton.title = 'Add message to current cell';\n                    addToButton.addEventListener('click', (event) => {\n                        event.stopPropagation();\n                        this.addMessageToCell(completeResponse);\n                    });\n                    actionsDiv.appendChild(addToButton);\n                    // Add buttons to message\n                    botMessageDiv.appendChild(actionsDiv);\n                    console.log('Action buttons added to bot message:', actionsDiv);\n                }\n                catch (error) {\n                    contentDiv.textContent = completeResponse;\n                    console.error('Failed to render markdown:', error);\n                }\n                // Save to chat history\n                const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n                if (chat) {\n                    chat.messages.push({\n                        text: completeResponse,\n                        sender: 'bot',\n                        isMarkdown: true\n                    });\n                }\n                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n            }, \n            // On error\n            (error) => {\n                streamingDiv.style.display = 'none';\n                contentDiv.style.display = 'block';\n                contentDiv.innerHTML = `<div class=\"error-message\">Error: ${error.message}</div>`;\n                console.error('API Error:', error);\n            });\n        }\n    }\n    /**\n     * Adds a message to the chat interface\n     */\n    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {\n        console.log('Adding message:', { sender, isMarkdown }); // Debug log\n        const messageDiv = document.createElement('div');\n        messageDiv.className = sender === 'user' ? 'user-message' : 'bot-message';\n        // Add message content\n        if (isMarkdown || sender === 'bot') {\n            // Bot messages are always rendered as markdown\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            messageDiv.appendChild(markdownIndicator);\n            // Create a container for the rendered markdown\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'markdown-content';\n            try {\n                // Pre-process the markdown text\n                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n                // Parse and render markdown\n                const rawHtml = marked_1.marked.parse(processedText);\n                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n                contentDiv.innerHTML = sanitizedHtml;\n                // Add syntax highlighting classes to code blocks\n                const codeBlocks = contentDiv.querySelectorAll('pre code');\n                codeBlocks.forEach(block => {\n                    var _a;\n                    block.classList.add('jp-RenderedText');\n                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');\n                });\n            }\n            catch (error) {\n                contentDiv.textContent = text;\n                console.error('Failed to render markdown:', error);\n            }\n            messageDiv.appendChild(contentDiv);\n            // Add action buttons for bot messages\n            if (sender === 'bot') {\n                console.log('Adding action buttons to bot message'); // Debug log\n                const actionsDiv = document.createElement('div');\n                actionsDiv.className = 'message-actions';\n                // Copy button with icon\n                const copyButton = document.createElement('button');\n                copyButton.className = 'message-action-button';\n                copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                copyButton.title = 'Copy message to clipboard';\n                copyButton.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    this.copyMessageToClipboard(text);\n                });\n                actionsDiv.appendChild(copyButton);\n                // Add to button with icon\n                const addToButton = document.createElement('button');\n                addToButton.className = 'message-action-button';\n                addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                addToButton.title = 'Add message to current cell';\n                addToButton.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    this.addMessageToCell(text);\n                });\n                actionsDiv.appendChild(addToButton);\n                // Add buttons to message\n                messageDiv.appendChild(actionsDiv);\n                console.log('Action buttons added to message:', actionsDiv); // Debug log\n            }\n        }\n        else {\n            messageDiv.textContent = text;\n        }\n        this.messageContainer.appendChild(messageDiv);\n        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        // Save to chat history\n        if (saveToHistory) {\n            const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n            if (chat) {\n                chat.messages.push({\n                    text,\n                    sender,\n                    isMarkdown: isMarkdown || sender === 'bot'\n                });\n            }\n        }\n    }\n    /**\n     * Copies message content to clipboard\n     */\n    copyMessageToClipboard(text) {\n        try {\n            navigator.clipboard.writeText(text).then(() => {\n                console.log('Content copied to clipboard');\n                // Find the button element that was clicked\n                const buttons = document.querySelectorAll('.message-action-button');\n                let clickedButton = null;\n                for (let i = 0; i < buttons.length; i++) {\n                    const button = buttons[i];\n                    if (button.title === 'Copy message to clipboard' && button === document.activeElement) {\n                        clickedButton = button;\n                        break;\n                    }\n                }\n                // Show visual feedback if we found the button\n                if (clickedButton) {\n                    const originalHTML = clickedButton.innerHTML;\n                    clickedButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M20 6L9 17l-5-5\"></path></svg>';\n                    setTimeout(() => {\n                        clickedButton.innerHTML = originalHTML;\n                    }, 2000);\n                }\n            }).catch(err => {\n                console.error('Failed to copy text: ', err);\n            });\n        }\n        catch (error) {\n            console.error('Error copying to clipboard:', error);\n        }\n    }\n    /**\n     * Adds message content to the current cell\n     */\n    addMessageToCell(text) {\n        var _a;\n        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (!cell || !cell.editor) {\n            return;\n        }\n        try {\n            const editor = cell.editor;\n            const view = editor.editor;\n            if (!view) {\n                return;\n            }\n            // Get current cursor position\n            const state = view.state;\n            const selection = state.selection;\n            const cursorPos = selection.main.head;\n            // Insert newline and message content at cursor position\n            const transaction = state.update({\n                changes: {\n                    from: cursorPos,\n                    insert: `\\n${text}`\n                },\n                selection: { anchor: cursorPos + text.length + 1 }\n            });\n            view.dispatch(transaction);\n        }\n        catch (error) {\n            console.error('Error adding message to cell:', error);\n        }\n    }\n    /**\n     * Lists the contents of the current directory\n     * @param filterType Optional parameter to filter results by type ('all', 'file', or 'directory')\n     */\n    async listCurrentDirectoryContents(filterType = 'all') {\n        console.log('LIST DIR: Starting directory listing process...', { filterType });\n        let dirPath = null;\n        let source = 'unknown';\n        const app = globals_1.globals.app;\n        if (!app) {\n            console.error('LIST DIR: Application reference not available');\n            this.addMessage('Error: Application reference not available', 'bot', false);\n            return null;\n        }\n        console.log('LIST DIR: App reference found:', app);\n        console.log('LIST DIR: Current shell widget:', app.shell.currentWidget);\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            console.log('LIST DIR: Current shell widget type:', currentShellWidget.constructor.name);\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            console.log('LIST DIR: Widget context:', widgetContext);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                console.log('LIST DIR: Widget path:', path);\n                const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n                dirPath = lastSlash === -1 ? '' : path.substring(0, lastSlash);\n                source = 'widget context';\n                console.log(`LIST DIR: Path from widget context: ${dirPath}`);\n            }\n            else {\n                console.log('LIST DIR: Widget context is undefined.');\n            }\n        }\n        // Fallback 1: Active Notebook Path\n        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {\n            console.log('LIST DIR: Trying notebook fallback');\n            const notebookPath = this.currentNotebook.context.path;\n            console.log(`LIST DIR: Raw notebook path: ${notebookPath}`);\n            if (typeof notebookPath === 'string') {\n                // Handle both forward and backslash path separators\n                const lastSlash = Math.max(notebookPath.lastIndexOf('/'), notebookPath.lastIndexOf('\\\\'));\n                dirPath = lastSlash === -1 ? '' : notebookPath.substring(0, lastSlash);\n                source = 'notebook';\n                console.log(`LIST DIR: Path from notebook context: ${dirPath}`);\n            }\n            else {\n                console.log('LIST DIR: Notebook context path is not a string.');\n            }\n        }\n        // Fallback 2: File Browser Current Path\n        if (dirPath === null) {\n            console.log('LIST DIR: Trying file browser fallback');\n            const leftWidgets = Array.from(app.shell.widgets('left'));\n            const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');\n            const fileBrowserModel = fileBrowserWidget === null || fileBrowserWidget === void 0 ? void 0 : fileBrowserWidget.model;\n            // Check if the model and path exist\n            if (fileBrowserModel && typeof fileBrowserModel.path === 'string') {\n                const fileBrowserPath = fileBrowserModel.path;\n                dirPath = fileBrowserPath;\n                source = 'file browser';\n                console.log(`LIST DIR: Path from file browser model: ${dirPath}`);\n            }\n            else {\n                console.log('LIST DIR: File browser path not found or model inaccessible.');\n            }\n        }\n        // Fallback 3: Server Root\n        if (dirPath === null) {\n            console.log('LIST DIR: Trying server root fallback');\n            // Assuming ContentsManager root is desired. Adjust if needed.\n            dirPath = ''; // Use empty string for server root with ContentsManager\n            source = 'server root';\n        }\n        // Final Check and Logging\n        if (dirPath === null) {\n            // This case should ideally not be reached with the server root fallback\n            console.error('LIST DIR: Critical Error - Could not determine directory path after all fallbacks.');\n            // Indicate failure\n            return null;\n        }\n        console.log(`LIST DIR: Final directory path: \\\"${dirPath}\\\" (Source: ${source})`);\n        let normalizedPath = ''; // Declare outside try block\n        try {\n            console.log('LIST DIR: Attempting to list contents for path:', dirPath);\n            normalizedPath = dirPath.replace(/\\\\/g, '/');\n            console.log('LIST DIR: Normalized path for content manager:', normalizedPath);\n            console.log('LIST DIR: Calling content manager get() with path:', normalizedPath);\n            const contents = await this.docManager.services.contents.get(normalizedPath);\n            console.log('LIST DIR: Contents result:', contents);\n            if (contents.content && Array.isArray(contents.content)) {\n                if (contents.content.length > 0) {\n                    const itemNames = [];\n                    contents.content.forEach(item => {\n                        // Apply filter based on type\n                        if (filterType === 'all' ||\n                            (filterType === 'file' && item.type !== 'directory') ||\n                            (filterType === 'directory' && item.type === 'directory')) {\n                            const icon = item.type === 'directory' ? '📁' : '📄'; // Use icons\n                            itemNames.push(`${icon} ${item.name}`); // Collect names with icons\n                        }\n                    });\n                    console.log(`LIST DIR: Successfully listed ${itemNames.length} items (filtered by: ${filterType})`);\n                    return itemNames; // Return the list of names\n                }\n                else {\n                    console.log('LIST DIR: Directory is empty or not accessible');\n                    this.addMessage(`Directory \"${normalizedPath || '/'}\" is empty or not accessible.`, 'bot', false);\n                    return null;\n                }\n            }\n            else {\n                // Handle case where contents.content is not as expected\n                console.warn('LIST DIR: Contents received, but content format is unexpected or missing.');\n                this.addMessage(`Could not list contents for \"${normalizedPath || '/'}\". Unexpected format.`, 'bot', false);\n                return null;\n            }\n        }\n        catch (error) {\n            console.error('LIST DIR: Error listing directory contents:', error);\n            console.error('LIST DIR: Error details:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n            this.addMessage(`Error listing directory contents for \"${normalizedPath || '/'}\": ${error}`, 'bot', false);\n            return null;\n        }\n    }\n    /**\n     * Shows the popup menu at the specified position\n     */\n    showPopupMenu(x, y) {\n        // Clear previous menu items\n        this.popupMenuContainer.innerHTML = '';\n        // Ensure menu is not already attached\n        if (this.popupMenuContainer.parentElement) {\n            this.popupMenuContainer.parentElement.removeChild(this.popupMenuContainer);\n        }\n        console.log('POPUP: Showing popup menu at:', x, y, { level: this.currentMenuLevel, path: this.currentMenuPath });\n        // Handle different menu levels\n        if (this.currentMenuLevel === 'top') {\n            // Define top-level menu items\n            const topLevelCommands = [\n                {\n                    label: 'Code',\n                    description: 'Insert selected code',\n                    action: () => {\n                        console.log('POPUP: Code action triggered');\n                        this.handleCodeCommand();\n                        this.hidePopupMenu();\n                    }\n                },\n                {\n                    label: 'Cell',\n                    description: 'Insert entire cell content',\n                    action: () => {\n                        console.log('POPUP: Cell action triggered');\n                        this.handleCellCommand();\n                        this.hidePopupMenu();\n                    }\n                },\n                {\n                    label: 'File',\n                    description: 'Browse and select a file',\n                    action: async () => {\n                        console.log('POPUP: File action triggered');\n                        // Set menu state for file browsing\n                        this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n                        this.currentMenuLevel = 'files';\n                        // Try to determine the current path\n                        await this.setCurrentDirectoryPath();\n                        // Refresh the menu with the new level\n                        this.showPopupMenu(x, y);\n                    }\n                },\n                {\n                    label: 'Directory',\n                    description: 'Browse and select a directory',\n                    action: async () => {\n                        console.log('POPUP: Directory action triggered');\n                        // Set menu state for directory browsing\n                        this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n                        this.currentMenuLevel = 'directories';\n                        // Try to determine the current path\n                        await this.setCurrentDirectoryPath();\n                        // Refresh the menu with the new level\n                        this.showPopupMenu(x, y);\n                    }\n                }\n            ];\n            // Create and append menu items\n            this.createMenuItems(topLevelCommands);\n        }\n        else if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n            // Add back button if we're not at the top level\n            const backButton = document.createElement('div');\n            backButton.className = 'jp-llm-ext-popup-menu-item';\n            backButton.innerHTML = '<span style=\"font-weight: bold\">← Back</span>';\n            backButton.onclick = (e) => {\n                e.stopPropagation();\n                // Pop the previous state from history\n                if (this.menuHistory.length > 0) {\n                    const prevState = this.menuHistory.pop();\n                    this.currentMenuLevel = prevState.level;\n                    this.currentMenuPath = prevState.path;\n                    this.showPopupMenu(x, y);\n                }\n                else {\n                    // If no history, go back to top level\n                    this.currentMenuLevel = 'top';\n                    this.currentMenuPath = '';\n                    this.showPopupMenu(x, y);\n                }\n            };\n            this.popupMenuContainer.appendChild(backButton);\n            // Add current path indicator\n            const pathIndicator = document.createElement('div');\n            pathIndicator.className = 'jp-llm-ext-popup-menu-path';\n            pathIndicator.textContent = `Path: ${this.currentMenuPath || '/'}`;\n            this.popupMenuContainer.appendChild(pathIndicator);\n            // Load and display directory contents based on the current level\n            this.loadDirectoryContents(x, y);\n        }\n        // Append to body and set position\n        document.body.appendChild(this.popupMenuContainer);\n        this.popupMenuContainer.style.position = 'absolute'; // Position relative to document body\n        this.popupMenuContainer.style.left = `${x}px`;\n        this.popupMenuContainer.style.top = `${y}px`;\n        this.popupMenuContainer.style.display = 'block';\n        console.log('POPUP: Menu container displayed and attached to body');\n        // Add click outside listener (ensure it's not added multiple times)\n        document.removeEventListener('click', this.handleClickOutside);\n        document.addEventListener('click', this.handleClickOutside);\n    }\n    /**\n     * Creates menu items from commands and appends them to the popup menu container\n     */\n    createMenuItems(commands) {\n        commands.forEach(command => {\n            const item = document.createElement('div');\n            item.className = 'jp-llm-ext-popup-menu-item';\n            const labelSpan = document.createElement('span');\n            labelSpan.textContent = command.label;\n            labelSpan.style.fontWeight = 'bold';\n            const descSpan = document.createElement('span');\n            descSpan.textContent = command.description;\n            descSpan.style.fontSize = '0.8em'; // Smaller font for description\n            descSpan.style.color = 'var(--jp-ui-font-color2)'; // Dimmer color\n            item.appendChild(labelSpan);\n            item.appendChild(descSpan);\n            item.onclick = (e) => {\n                e.stopPropagation(); // Prevent click outside listener\n                command.action();\n            };\n            this.popupMenuContainer.appendChild(item);\n        });\n    }\n    /**\n     * Loads and displays directory contents in the popup menu\n     */\n    async loadDirectoryContents(x, y) {\n        // Show loading indicator\n        const loadingItem = document.createElement('div');\n        loadingItem.className = 'jp-llm-ext-popup-menu-item';\n        loadingItem.textContent = 'Loading...';\n        this.popupMenuContainer.appendChild(loadingItem);\n        try {\n            // Get directory contents with appropriate filter\n            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';\n            const contents = await this.listCurrentDirectoryContents(filterType);\n            // Remove loading indicator\n            this.popupMenuContainer.removeChild(loadingItem);\n            if (contents && contents.length > 0) {\n                // Create items for each content item\n                contents.forEach(item => {\n                    const contentItem = document.createElement('div');\n                    contentItem.className = 'jp-llm-ext-popup-menu-item';\n                    contentItem.textContent = item;\n                    contentItem.onclick = async (e) => {\n                        e.stopPropagation();\n                        // Extract the name without the icon\n                        const name = item.substring(2).trim();\n                        if (this.currentMenuLevel === 'directories') {\n                            // Handle directory navigation\n                            console.log(`POPUP: Selected directory: ${name}`);\n                            // Save current state to history\n                            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n                            // Update path (handle both empty path and paths with trailing slash)\n                            if (!this.currentMenuPath || this.currentMenuPath === '/') {\n                                this.currentMenuPath = name;\n                            }\n                            else {\n                                this.currentMenuPath = `${this.currentMenuPath}/${name}`;\n                            }\n                            // Switch to files view to show files in the selected directory\n                            this.currentMenuLevel = 'files';\n                            // Refresh the menu\n                            this.showPopupMenu(x, y);\n                        }\n                        else if (this.currentMenuLevel === 'files') {\n                            // Handle file selection\n                            console.log(`POPUP: Selected file: ${name}`);\n                            // Construct full path\n                            let fullPath;\n                            if (!this.currentMenuPath || this.currentMenuPath === '/') {\n                                fullPath = name;\n                            }\n                            else {\n                                fullPath = `${this.currentMenuPath}/${name}`;\n                            }\n                            // Insert the file path into the input\n                            this.appendToInput(`@file\\n${fullPath}`);\n                            // Close the menu\n                            this.hidePopupMenu();\n                        }\n                    };\n                    this.popupMenuContainer.appendChild(contentItem);\n                });\n            }\n            else {\n                // Show empty message\n                const emptyItem = document.createElement('div');\n                emptyItem.className = 'jp-llm-ext-popup-menu-item';\n                emptyItem.textContent = `No ${this.currentMenuLevel} found in this directory`;\n                this.popupMenuContainer.appendChild(emptyItem);\n            }\n        }\n        catch (error) {\n            // Remove loading indicator\n            if (loadingItem.parentNode === this.popupMenuContainer) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            // Show error message\n            const errorItem = document.createElement('div');\n            errorItem.className = 'jp-llm-ext-popup-menu-item';\n            errorItem.textContent = `Error loading contents: ${error}`;\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('Error loading directory contents:', error);\n        }\n    }\n    /**\n     * Sets the current directory path based on context\n     */\n    async setCurrentDirectoryPath() {\n        // If we already have a path, keep using it\n        if (this.currentMenuPath) {\n            return;\n        }\n        // Try to determine the current path using the same logic as in listCurrentDirectoryContents\n        let dirPath = null;\n        const app = globals_1.globals.app;\n        if (!app) {\n            console.error('POPUP: Application reference not available');\n            return;\n        }\n        // Try to get path from current widget\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n                dirPath = lastSlash === -1 ? '' : path.substring(0, lastSlash);\n            }\n        }\n        // Fallback 1: Active Notebook Path\n        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {\n            const notebookPath = this.currentNotebook.context.path;\n            console.log(`POPUP: Raw notebook path: ${notebookPath}`);\n            if (typeof notebookPath === 'string') {\n                const lastSlash = Math.max(notebookPath.lastIndexOf('/'), notebookPath.lastIndexOf('\\\\'));\n                dirPath = lastSlash === -1 ? '' : notebookPath.substring(0, lastSlash);\n            }\n        }\n        // Fallback 2: File Browser Current Path\n        if (dirPath === null) {\n            const leftWidgets = Array.from(app.shell.widgets('left'));\n            const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');\n            const fileBrowserModel = fileBrowserWidget === null || fileBrowserWidget === void 0 ? void 0 : fileBrowserWidget.model;\n            if (fileBrowserModel && typeof fileBrowserModel.path === 'string') {\n                dirPath = fileBrowserModel.path;\n            }\n        }\n        // Fallback 3: Server Root\n        if (dirPath === null) {\n            dirPath = ''; // Use empty string for server root\n        }\n        // Set the current menu path\n        this.currentMenuPath = dirPath;\n        console.log(`POPUP: Set current menu path to: ${this.currentMenuPath}`);\n    }\n    /**\n     * Hides the popup menu\n     */\n    hidePopupMenu() {\n        // Only act if the menu is currently displayed\n        if (this.popupMenuContainer.style.display !== 'none') {\n            console.log('POPUP: Hiding popup menu.');\n            this.popupMenuContainer.style.display = 'none';\n            // Remove from body if it's attached\n            if (this.popupMenuContainer.parentElement === document.body) {\n                document.body.removeChild(this.popupMenuContainer);\n                console.log('POPUP: Menu container removed from body');\n            }\n            // Remove listener when menu is hidden\n            document.removeEventListener('click', this.handleClickOutside);\n            // Reset menu state to top level when hiding\n            this.currentMenuLevel = 'top';\n            this.currentMenuPath = '';\n            this.menuHistory = [];\n        }\n    }\n    /**\n     * Handle widget detachment.\n     */\n    onBeforeDetach(msg) {\n        // Ensure the popup menu is hidden and removed from the body if the widget is detached\n        this.hidePopupMenu();\n        super.onBeforeDetach(msg);\n    }\n    /**\n     * Handles the code command - inserts selected code\n     */\n    handleCodeCommand() {\n        var _a;\n        const selectedText = this.getSelectedText();\n        if (selectedText) {\n            this.appendToInput(`@code\\n${selectedText}`);\n        }\n        else {\n            // If no selection, get the entire cell content\n            const cellContext = (_a = globals_1.globals.cellContextTracker) === null || _a === void 0 ? void 0 : _a.getCurrentCellContext();\n            if (cellContext) {\n                this.appendToInput(`@code\\n${cellContext.text}`);\n            }\n        }\n    }\n    /**\n     * Handles the cell command - inserts entire cell content\n     */\n    handleCellCommand() {\n        var _a;\n        const cellContext = (_a = globals_1.globals.cellContextTracker) === null || _a === void 0 ? void 0 : _a.getCurrentCellContext();\n        if (cellContext) {\n            this.appendToInput(`@cell\\n${cellContext.text}`);\n        }\n    }\n    /**\n     * Appends text to the input field with proper spacing\n     */\n    appendToInput(text) {\n        try {\n            const currentValue = this.inputField.value;\n            if (currentValue) {\n                // If there's existing content, add a newline before appending\n                this.inputField.value = `${currentValue}\\n\\n${text}`;\n            }\n            else {\n                this.inputField.value = text;\n            }\n            // Focus the input field and move cursor to end\n            this.inputField.focus();\n            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);\n        }\n        catch (error) {\n            console.error('Error appending to input:', error);\n        }\n    }\n    /**\n     * Gets the selected text from cell context\n     */\n    getSelectedText() {\n        var _a;\n        // Get the current active cell from the tracker\n        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (!cell || !cell.editor) {\n            return '';\n        }\n        // Get the CodeMirror editor instance\n        const editor = cell.editor;\n        const view = editor.editor;\n        if (!view) {\n            return '';\n        }\n        // Get the selection from CodeMirror\n        const state = view.state;\n        const selection = state.selection;\n        // If there's no selection, return empty string\n        if (selection.main.empty) {\n            return '';\n        }\n        // Get the selected text\n        const from = selection.main.from;\n        const to = selection.main.to;\n        return state.doc.sliceString(from, to);\n    }\n    // Settings modal methods\n    createSettingsModal() {\n        const modal = document.createElement('div');\n        modal.style.position = 'fixed';\n        modal.style.top = '0';\n        modal.style.left = '0';\n        modal.style.width = '100%';\n        modal.style.height = '100%';\n        modal.style.display = 'none';\n        modal.style.justifyContent = 'center';\n        modal.style.alignItems = 'center';\n        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n        const content = document.createElement('div');\n        content.style.backgroundColor = '#fff';\n        content.style.padding = '20px';\n        content.style.borderRadius = '5px';\n        content.style.width = '400px';\n        const title = document.createElement('h3');\n        title.textContent = 'Settings';\n        content.appendChild(title);\n        const providerLabel = document.createElement('label');\n        providerLabel.htmlFor = 'settings-provider';\n        providerLabel.textContent = 'LLM Provider:';\n        content.appendChild(providerLabel);\n        const providerSelect = document.createElement('select');\n        providerSelect.id = 'settings-provider';\n        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {\n            const option = document.createElement('option');\n            option.value = opt;\n            option.textContent = opt;\n            providerSelect.appendChild(option);\n        });\n        content.appendChild(providerSelect);\n        content.appendChild(document.createElement('br'));\n        const keyLabel = document.createElement('label');\n        keyLabel.htmlFor = 'settings-api-key';\n        keyLabel.textContent = 'API Key:';\n        content.appendChild(keyLabel);\n        const keyInput = document.createElement('input');\n        keyInput.id = 'settings-api-key';\n        keyInput.type = 'text';\n        keyInput.style.width = '100%';\n        content.appendChild(keyInput);\n        content.appendChild(document.createElement('br'));\n        const urlLabel = document.createElement('label');\n        urlLabel.htmlFor = 'settings-api-base-url';\n        urlLabel.textContent = 'API Base URL (optional):';\n        content.appendChild(urlLabel);\n        const urlInput = document.createElement('input');\n        urlInput.id = 'settings-api-base-url';\n        urlInput.type = 'text';\n        urlInput.style.width = '100%';\n        content.appendChild(urlInput);\n        content.appendChild(document.createElement('br'));\n        const rulesLabel = document.createElement('label');\n        rulesLabel.htmlFor = 'settings-rules';\n        rulesLabel.textContent = 'Rules:';\n        content.appendChild(rulesLabel);\n        const rulesTextarea = document.createElement('textarea');\n        rulesTextarea.id = 'settings-rules';\n        rulesTextarea.style.width = '100%';\n        rulesTextarea.style.height = '100px';\n        content.appendChild(rulesTextarea);\n        content.appendChild(document.createElement('br'));\n        const btnContainer = document.createElement('div');\n        btnContainer.style.textAlign = 'right';\n        btnContainer.style.marginTop = '10px';\n        const saveBtn = document.createElement('button');\n        saveBtn.textContent = 'Save';\n        saveBtn.addEventListener('click', () => {\n            const provider = document.getElementById('settings-provider').value;\n            const key = document.getElementById('settings-api-key').value;\n            const url = document.getElementById('settings-api-base-url').value;\n            const rules = document.getElementById('settings-rules').value;\n            console.log('Settings saved:', { provider, key, url, rules });\n            this.hideSettingsModal();\n        });\n        const cancelBtn = document.createElement('button');\n        cancelBtn.textContent = 'Cancel';\n        cancelBtn.style.marginLeft = '10px';\n        cancelBtn.addEventListener('click', () => this.hideSettingsModal());\n        btnContainer.appendChild(saveBtn);\n        btnContainer.appendChild(cancelBtn);\n        content.appendChild(btnContainer);\n        modal.appendChild(content);\n        return modal;\n    }\n    showSettingsModal() {\n        this.settingsModalContainer.style.display = 'flex';\n    }\n    hideSettingsModal() {\n        this.settingsModalContainer.style.display = 'none';\n    }\n}\nexports.SimpleSidebarWidget = SimpleSidebarWidget;\n"],"names":[],"sourceRoot":""}