{"version":3,"file":"lib_index_js.09415b66c01c9b7528f0.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC7Ib;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB,mBAAO,CAAC,4FAA2B,GAAG;AAC9D;AACA,wDAAwD,kCAAkC,GAAG;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACrEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB,IAAI,+BAA+B;AACnC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;;;;;;;;;;ACjBY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,2BAA2B,mBAAO,CAAC,4DAAwB,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,4BAA4B;AACnH;AACA,mBAAmB;AACnB,sFAAsF,4BAA4B;AAClH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,sBAAsB;;;;;;;;;;;AC7GT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,iCAAiC,mBAAO,CAAC,8EAAiC,GAAG;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,0CAA0C;AAC1C;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,uEAAuE;AACvE,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,kCAAkC;AAClC;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,0DAA0D,iCAAiC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,qDAAqD;AACrD;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,wCAAwC;AACxC,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8DAA8D,aAAa,SAAS,cAAc,SAAS,WAAW,EAAE,wDAAwD;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA,oCAAoC,aAAa,aAAa;AAC9D;AACA;AACA,2EAA2E;AAC3E,8BAA8B;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA,YAAY;AACZ;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC/SP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,2BAA2B,mBAAO,CAAC,4DAAwB;AAC3D,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE,kBAAkB,mBAAO,CAAC,8CAAiB,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,gEAAgE;AAChE,iDAAiD;AACjD,8CAA8C;AAC9C;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,4FAA4F;AAC5F;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO,aAAa,WAAW,SAAS,OAAO;AAC9G;AACA;AACA,gEAAgE,6BAA6B;AAC7F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,eAAe;AACf;AACA;AACA,+EAA+E,YAAY;AAC3F;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,8EAA8E,2BAA2B;AACzG;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA,iFAAiF;AACjF;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,kBAAkB;AACnH,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc;AACjG;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;;;;;;;;;;;AC/KT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE,IAAI,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,mBAAmB;AACnB;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAyD;AACvE,cAAc,2DAA2D;AACzE,cAAc,0DAA0D;AACxE,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gEAAgE,MAAM,EAAE,SAAS;AACjF;AACA,qBAAqB;AACrB;AACA;AACA,kGAAkG,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wCAAwC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,EAAE,kBAAkB,EAAE,iBAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS,UAAU,KAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kFAAkF;AAC5G,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,GAAG;AACrE;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK,GAAG,yDAAyD;AACzG;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,UAAU,KAAK;AACxE;AACA;AACA,oCAAoC,0DAA0D;AAC9F;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB,UAAU,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,aAAa,oBAAoB;AAC9G;AACA,4BAA4B,SAAS,GAAG,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD,qBAAqB;AACrB;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wCAAwC,mBAAmB,kBAAkB,SAAS;AACtF;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,KAAK,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc,KAAK,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,cAAc,IAAI,cAAc;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,sDAAsD,IAAI,YAAY,KAAK;AAC3E,+CAA+C,IAAI;AACnD,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;AC/9BX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,KAAK,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC/FV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,uEAAuE;AACvE;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,2GAA2G,aAAa,SAAS,cAAc;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY,IAAI;AAC3D;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1Ka;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD,kBAAkB,mBAAO,CAAC,6CAAgB;AAC1C,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,+BAA+B,mBAAO,CAAC,6DAAwB;AAC/D,YAAY,YAAY;AACxB;AACA,mBAAO,CAAC,6CAAoB;AAC5B;AACA,mBAAmB,mBAAO,CAAC,mDAAmB;AAC9C,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACrCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,gBAAgB,mBAAO,CAAC,yCAAc;AACtC,qBAAqB,mBAAO,CAAC,mDAAmB;AAChD,6BAA6B,mBAAO,CAAC,2EAA+B;AACpE,2BAA2B,mBAAO,CAAC,uEAA6B;AAChE,yBAAyB,mBAAO,CAAC,uDAAqB;AACtD,yBAAyB,mBAAO,CAAC,uDAAqB;AACtD,qBAAqB,mBAAO,CAAC,qDAAoB;AACjD,yBAAyB,mBAAO,CAAC,6DAAwB;AACzD,wBAAwB,mBAAO,CAAC,iEAA0B;AAC1D,0BAA0B,mBAAO,CAAC,qEAA4B;AAC9D,0BAA0B,mBAAO,CAAC,qEAA4B;AAC9D,2BAA2B,mBAAO,CAAC,uEAA6B;AAChE,qBAAqB,mBAAO,CAAC,+CAAiB;AAC9C,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,kBAAkB,mBAAO,CAAC,6CAAgB;AAC1C;AACA,oBAAoB,mBAAO,CAAC,mDAAmB;AAC/C,+BAA+B,mBAAO,CAAC,yEAA8B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,iDAAiD;AACjD,UAAU;AACV;AACA;AACA,kDAAkD;AAClD,uDAAuD;AACvD,qDAAqD;AACrD,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,wBAAwB;AACxB;AACA;AACA,6DAA6D,QAAQ,KAAK;AAC1E;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,kFAAkF;AAClF,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,WAAW,QAAQ,cAAc;AACzH;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA,aAAa;AACb,uCAAuC,QAAQ,+FAA+F,QAAQ,KAAK;AAC3J,wCAAwC,QAAQ,+FAA+F,KAAK,MAAM;AAC1J,6CAA6C,QAAQ,8FAA8F,KAAK,MAAM;AAC9J;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,6CAA6C,MAAM;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,qFAAqF;AAC7H,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gCAAgC;AACxF,wDAAwD,kCAAkC;AAC1F,+BAA+B,gCAAgC,GAAG;AAClE;AACA;AACA,aAAa;AACb,mCAAmC,QAAQ,+GAA+G;AAC1J,qCAAqC,QAAQ;AAC7C;AACA;AACA,uCAAuC,QAAQ,2FAA2F;AAC1I,uCAAuC,QAAQ,8FAA8F;AAC7I,gCAAgC;AAChC;AACA,eAAe;AACf,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,2BAA2B;;;;;;;;;;;ACtYd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,uDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,kHAAkH;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB,MAAM,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,iBAAiB;;;;;;;;;;;ACvHJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACnER;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,oBAAoB;AACpB,kBAAkB;AAClB,sBAAsB;AACtB,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,0DAA0D,yBAAyB,kBAAkB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,6DAA6D,yBAAyB,oBAAoB;AAC1G;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,gEAAgE,yBAAyB,sBAAsB;AAC/G;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;;;;;;;;;;ACtHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA,2DAA2D,uCAAuC;AAClG;AACA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D,yCAAyC;AACtG;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA,+DAA+D,4CAA4C;AAC3G;AACA,wDAAwD,8DAA8D;AACtH,8DAA8D,0CAA0C;AACxG;AACA,4DAA4D,wCAAwC;AACpG;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mEAAmE,gDAAgD;AACnH,wDAAwD,yBAAyB,8CAA8C,iDAAiD;AAChL;AACA;AACA;AACA,4DAA4D,yBAAyB,uBAAuB,iDAAiD;AAC7J;AACA;AACA;AACA,8DAA8D,0BAA0B,mBAAmB,iDAAiD;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2DAA2D;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6DAA6D;AACpH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjJa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,yBAAyB;AACzB,wBAAwB;AACxB,sCAAsC;AACtC,uCAAuC;AACvC,6BAA6B;AAC7B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,oCAAoC;AACpC,uBAAuB,mBAAO,CAAC,gDAAgB;AAC/C,kBAAkB,mBAAO,CAAC,8CAAiB,GAAG;AAC9C;AACA,YAAY,gEAAgE;AAC5E;AACA,YAAY,mBAAmB;AAC/B,uBAAuB,mBAAO,CAAC,0DAAuB;AACtD,0BAA0B,mBAAO,CAAC,gEAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,oCAAoC;AACpC;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA,8CAA8C;AAC9C;AACA,qCAAqC;AACrC;AACA;AACA,+DAA+D;AAC/D,iCAAiC,MAAM;AACvC;AACA;AACA,sEAAsE;AACtE,sCAAsC,MAAM;AAC5C;AACA;AACA,mDAAmD;AACnD;AACA;AACA,gEAAgE,MAAM,kBAAkB,UAAU;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa,GAAG,aAAa,GAAG,MAAM,GAAG;AACtE,gCAAgC,OAAO,GAAG,2CAA2C,OAAO,aAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU,OAAO,UAAU,GAAG,QAAQ;AAClG,iCAAiC,qBAAqB,GAAG,sBAAsB,GAAG,SAAS;AAC3F;AACA,sEAAsE,UAAU,aAAa,UAAU,GAAG,QAAQ;AAClH,+CAA+C,qBAAqB,SAAS,sBAAsB,IAAI,cAAc;AACrH;AACA;AACA,0CAA0C,MAAM,GAAG;AACnD,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,UAAU;AAClF,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,KAAK;AACL;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,gBAAgB;AACvG;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB,GAAG;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,qCAAqC;AACrC;AACA,uCAAuC;AACvC;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC9oBV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,sCAAsC;AACtC;AACA,sEAAsE;AACtE,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;AClHR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,UAAU,YAAY,eAAe,WAAW,WAAW;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,8CAA8C;AAC9C;AACA,uEAAuE,iCAAiC;AACxG,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oDAAoD;AACpD,uDAAuD;AACvD;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,KAAK,QAAQ;AACvD;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,4GAA4G,KAAK,GAAG;AACpH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,6FAA6F,aAAa,SAAS,cAAc;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,kBAAkB;AACzH,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;AClrBJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG,SAAS;AACT;AACA,yGAAyG;AACzG,SAAS;AACT;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA,4GAA4G;AAC5G,aAAa;AACb;AACA;AACA,+DAA+D;AAC/D,6GAA6G;AAC7G,aAAa;AACb,SAAS;AACT;AACA;AACA,4DAA4D;AAC5D,yGAAyG;AACzG,SAAS;AACT;AACA;AACA;AACA,gDAAgD;AAChD,qGAAqG;AACrG;AACA;;;;;;;;;;;AChFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB,GAAG;AAChD;AACA;;;;;;;;;;;AC9Fa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,qBAAqB;AACrB,uCAAuC,mBAAO,CAAC,+EAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,GAAG,cAAc,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA,uCAAuC,sBAAsB;AAC7D;AACA;;;;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B;AAC1B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,uBAAuB;AACvB,6BAA6B;AAC7B,gCAAgC;AAChC,kBAAkB,mBAAO,CAAC,8CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC,aAAa;AACb;AACA,yBAAyB;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA","sources":["webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/core/api-client.js","webpack://jupyter-simple-extension/./lib/core/globals.js","webpack://jupyter-simple-extension/./lib/core/icons.js","webpack://jupyter-simple-extension/./lib/handlers/history-handler.js","webpack://jupyter-simple-extension/./lib/handlers/input-handler.js","webpack://jupyter-simple-extension/./lib/handlers/message-handler.js","webpack://jupyter-simple-extension/./lib/handlers/popup-menu-manager.js","webpack://jupyter-simple-extension/./lib/handlers/settings-handler.js","webpack://jupyter-simple-extension/./lib/handlers/shortcut-handler.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/sidebar-widget.js","webpack://jupyter-simple-extension/./lib/state/chat-state.js","webpack://jupyter-simple-extension/./lib/state/settings-state.js","webpack://jupyter-simple-extension/./lib/ui/dom-elements.js","webpack://jupyter-simple-extension/./lib/ui/layout-builder.js","webpack://jupyter-simple-extension/./lib/ui/message-renderer.js","webpack://jupyter-simple-extension/./lib/ui/settings-modal.js","webpack://jupyter-simple-extension/./lib/ui/ui-manager.js","webpack://jupyter-simple-extension/./lib/utils/clipboard.js","webpack://jupyter-simple-extension/./lib/utils/content-editable-utils.js","webpack://jupyter-simple-extension/./lib/utils/highlighting.js","webpack://jupyter-simple-extension/./lib/utils/markdown-config.js","webpack://jupyter-simple-extension/./lib/utils/notebook-integration.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CellContextTracker = void 0;\n/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nclass CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\nexports.CellContextTracker = CellContextTracker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerCommands = registerCommands;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\"); // Import LabIcon if needed as placeholder\n// Placeholder icon (replace if you have a specific icon)\nconst extensionIcon = ui_components_1.LabIcon.resolve({ icon: 'ui-components:jupyterlab' }); // Use resolve for built-in\n/**\n * Registers commands for the extension\n */\nfunction registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\n/**\n * API client for interacting with the backend LLM service\n */\nclass ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\nexports.ApiClient = ApiClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globals = void 0;\nexports.initGlobals = initGlobals;\n/**\n * Global references to key components in the application\n */\nexports.globals = {};\n/**\n * Initialize global references\n */\nfunction initGlobals(app, notebookTracker) {\n    exports.globals.app = app;\n    exports.globals.notebookTracker = notebookTracker;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extensionIcon = void 0;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexports.extensionIcon = new ui_components_1.LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryHandler = void 0;\nconst message_renderer_1 = require(\"../ui/message-renderer\"); // Assuming renderers are needed\n/**\n * Manages the display and interaction logic for the chat history view.\n */\nclass HistoryHandler {\n    constructor(chatState, uiManager, callbacks, rendererCallbacks) {\n        this.isHistoryViewActive = false;\n        this.chatState = chatState;\n        this.uiManager = uiManager;\n        this.callbacks = callbacks;\n        this.rendererCallbacks = rendererCallbacks;\n        // Get the history container element from UIManager\n        this.historyContainer = this.uiManager.getUIElements().historyContainer;\n    }\n    /**\n     * Toggles between the main chat view and the history view.\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Use UIManager to hide chat, show history\n            this.uiManager.showHistoryView();\n            this.renderChatHistory(); // Populate the history view\n        }\n        else {\n            // Use UIManager to show chat, hide history\n            this.uiManager.showChatView();\n            // Ensure the correct title is displayed when switching back\n            const currentChat = this.chatState.getCurrentChat();\n            if (currentChat) {\n                this.callbacks.updateTitleInput(currentChat.title);\n            }\n        }\n    }\n    /**\n     * Renders the list of past chats in the history container.\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = ''; // Clear previous list\n        const history = this.chatState.getChatHistory();\n        const currentChatId = this.chatState.getCurrentChatId();\n        if (history.length === 0) {\n            this.historyContainer.innerHTML = '<div class=\"jp-llm-ext-history-empty\">No chat history yet.</div>';\n            return;\n        }\n        const list = document.createElement('ul');\n        list.className = 'jp-llm-ext-history-list';\n        history.forEach(chat => {\n            const listItem = document.createElement('li');\n            listItem.className = 'jp-llm-ext-history-item';\n            if (chat.id === currentChatId) {\n                listItem.classList.add('jp-llm-ext-active');\n            }\n            // Simple representation: Title\n            // TODO: Add preview, timestamp, delete button etc.\n            const titleDiv = document.createElement('div');\n            titleDiv.className = 'jp-llm-ext-history-item-title';\n            titleDiv.textContent = chat.title || 'Untitled Chat';\n            listItem.appendChild(titleDiv);\n            // Add click event to load the chat\n            listItem.addEventListener('click', () => this.loadChat(chat.id));\n            list.appendChild(listItem);\n        });\n        this.historyContainer.appendChild(list);\n    }\n    /**\n     * Loads a specific chat session from history into the main view.\n     */\n    loadChat(chatId) {\n        const chat = this.chatState.getChatById(chatId);\n        if (!chat) {\n            console.error(`Chat with ID ${chatId} not found.`);\n            return;\n        }\n        // Set this chat as the active one in the state\n        this.chatState.setCurrentChatId(chatId);\n        // Update the main UI title input\n        this.callbacks.updateTitleInput(chat.title);\n        // Clear the current message display\n        this.callbacks.clearMessageContainer();\n        // Re-populate the message container with messages from the loaded chat\n        // Use the renderer functions via callbacks\n        chat.messages.forEach((msg) => {\n            let messageElement;\n            if (msg.sender === 'user') {\n                messageElement = (0, message_renderer_1.renderUserMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);\n            }\n            else { // 'bot'\n                messageElement = (0, message_renderer_1.renderBotMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);\n            }\n            // Add the rendered element to the message container via callback\n            this.callbacks.addRenderedMessage(messageElement);\n        });\n        // Switch back to the chat view if we were in the history view\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView(); // This will call uiManager.showChatView()\n        }\n        else {\n            // If already in chat view, ensure scrolling is correct\n            this.uiManager.scrollToBottom();\n        }\n        // Optional: Re-render history list to update the active item indicator\n        // Only really needed if not switching views\n        // if (!this.isHistoryViewActive) { this.renderChatHistory(); }\n    }\n}\nexports.HistoryHandler = HistoryHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputHandler = void 0;\nconst content_editable_utils_1 = require(\"../utils/content-editable-utils\"); // Helper needed\n/**\n * Handles events and logic related to the chat input field.\n */\nclass InputHandler {\n    constructor(chatInput, callbacks\n    // uiManager: UIManager // Removed unused parameter\n    ) {\n        // private uiManager: UIManager; // Removed unused member\n        // --- Code Reference State ---\n        this.codeRefMap = new Map();\n        this.nextRefId = 1;\n        // ---------------------------\n        this.hasAtSymbol = false;\n        this.isMarkdownMode = false; // Internal state, potentially synced with UIManager\n        this.isInputExpanded = false; // Internal state, potentially synced with UIManager\n        // -----------------------------\n        // --- Private Event Handlers ---\n        this._handleKeyPress = (event) => {\n            // Handle Enter key press (send message)\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault(); // Prevent default newline insertion\n                // Use textContent for div\n                let message = this.chatInput.textContent || '';\n                message = message.trim(); // Just trim the raw message\n                if (message) {\n                    this.callbacks.handleSendMessage(message); // Pass raw message with placeholders\n                }\n            }\n            // --- Handle Tab/Escape/Arrows for popup interaction ---\n            // Check if popup is visible (needs a way to know, maybe via callbacks or direct reference?)\n            // Assuming popupMenuManager reference is available or state is tracked\n            // else if (this.popupMenuManager.isPopupMenuVisible()) { // Pseudo-code\n            //    if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n            //        // Prevent default input field behavior\n            //        event.preventDefault();\n            //        // Let the PopupMenuManager's document handler manage the event\n            //    }\n            // }\n            // --- End Popup Interaction Handling ---\n        };\n        this._handleInput = () => {\n            // Use textContent for div\n            const currentText = this.chatInput.textContent || '';\n            // --- Update Code Ref Placeholders --- \n            // Optional: If we want visual placeholders to update live\n            // This could involve complex DOM manipulation or using a library.\n            // For now, we resolve refs only on send.\n            // --- At Symbol Detection for Popup --- \n            // This logic was moved to UIManager.handleInputForReference\n            // because UIManager needs to coordinate showing the popup.\n            // InputHandler might still need to know *if* an @ was typed recently\n            // to adjust behavior (e.g., how Enter works), but UIManager handles the popup trigger.\n            // Simple check if text contains '@' for potential state management\n            this.hasAtSymbol = currentText.includes('@');\n            // Adjust input height dynamically based on content?\n            // Can be complex with contenteditable divs. Requires careful calculation.\n            // this.adjustInputHeight(); \n        };\n        this.chatInput = chatInput;\n        this.callbacks = callbacks;\n        // this.uiManager = uiManager; // Removed unused assignment\n        // Bind event listeners\n        this.chatInput.addEventListener('keypress', this._handleKeyPress);\n        this.chatInput.addEventListener('input', this._handleInput);\n        // Note: Actual markdown toggle and expand buttons are likely managed by UIManager,\n        // which would then call methods like `setMarkdownMode` or `toggleExpansion` on this handler.\n    }\n    /**\n     * Removes event listeners.\n     */\n    dispose() {\n        this.chatInput.removeEventListener('keypress', this._handleKeyPress);\n        this.chatInput.removeEventListener('input', this._handleInput);\n    }\n    /**\n     * Appends text to the input field, potentially replacing a preceding '@' symbol.\n     */\n    appendToInput(text) {\n        try {\n            this.chatInput.focus(); // Ensure focus first\n            const selection = window.getSelection();\n            if (!selection || selection.rangeCount === 0) {\n                console.error('Cannot append to input: No selection found.');\n                // Fallback: append to end\n                this.chatInput.textContent = (this.chatInput.textContent || '') + text;\n                return;\n            }\n            const range = selection.getRangeAt(0);\n            const { startContainer, startOffset } = range;\n            let currentTextContent = this.chatInput.textContent || ''; // Use textContent\n            let insertPos = (0, content_editable_utils_1.getCaretPosition)(this.chatInput); // Get linear position\n            // Simple check: if the character before the linear caret position is '@'\n            if (insertPos > 0 && currentTextContent[insertPos - 1] === '@') {\n                // Replace the '@' - more complex with DOM manipulation,\n                // For simplicity, we'll replace in textContent and reset\n                const before = currentTextContent.slice(0, insertPos - 1);\n                const after = currentTextContent.slice(insertPos);\n                this.chatInput.textContent = before + text + after;\n                // Set cursor position after the inserted text\n                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, (insertPos - 1) + text.length);\n            }\n            else {\n                // Standard insertion - more complex with DOM manipulation\n                // For simplicity, we'll insert in textContent and reset\n                const before = currentTextContent.slice(0, insertPos);\n                const after = currentTextContent.slice(insertPos);\n                this.chatInput.textContent = before + text + after;\n                // Set cursor position after the inserted text\n                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, insertPos + text.length);\n            }\n            // Trigger input event manually since we're changing textContent directly\n            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n        }\n        catch (error) {\n            console.error('Error appending to input:', error);\n        }\n    }\n    /**\n     * Clears the input field and resets associated state after sending.\n     */\n    clearInput() {\n        // Use textContent for div\n        this.chatInput.textContent = '';\n        // Directly reset internal state instead of relying on callback\n        this.resetCodeReferences();\n        // Remove rows manipulation\n        // this.chatInput.rows = 1;\n        this.chatInput.style.height = ''; // Reset height\n        this.hasAtSymbol = false; // Reset @ state\n        // Reset expand button state if it was expanded\n        if (this.isInputExpanded) {\n            this.toggleInputExpansion(false); // Collapse input\n        }\n        // Trigger input event manually after clearing\n        this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n    }\n    /**\n     * Sets the markdown mode state and updates the placeholder.\n     */\n    setMarkdownMode(isMarkdown) {\n        this.isMarkdownMode = isMarkdown;\n        this.callbacks.updatePlaceholder(this.isMarkdownMode);\n        // Update placeholder directly (alternative to callback)\n        // this.chatInput.placeholder = this.isMarkdownMode ? \n        //   'Write markdown here...' : \n        //   'Ask me anything...';\n    }\n    /**\n     * Toggles the input expansion state and updates UI.\n     */\n    toggleInputExpansion(forceState) {\n        this.isInputExpanded = forceState !== undefined ? forceState : !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            // Use max-height or height for div\n            this.chatInput.style.height = '200px'; // Example height\n            // Allow vertical resizing if desired, or keep as 'none'\n            this.chatInput.style.resize = 'vertical';\n            this.chatInput.style.overflowY = 'auto'; // Ensure scrollbar appears if needed\n        }\n        else {\n            this.chatInput.style.height = ''; // Reset height\n            this.chatInput.style.resize = 'none';\n            // Remove rows manipulation\n            // this.chatInput.rows = 1; // Ensure it collapses back to 1 row height\n            this.chatInput.style.overflowY = 'hidden'; // Hide scrollbar when collapsed\n        }\n        // Notify UIManager/LayoutBuilder to update button appearance\n        this.callbacks.toggleInputExpansionUI(this.isInputExpanded);\n    }\n    // --- Code Reference Methods ---\n    /**\n     * Adds a code reference to the internal map and returns its ID.\n     * @param code The actual code content.\n     * @param notebookName The name of the notebook the code is from.\n     * @param cellIndex The index of the cell the code is from (0-based).\n     * @param lineNumber The starting line number of the code within the cell (1-based).\n     * @param lineEndNumber The ending line number of the code within the cell (1-based).\n     * @returns The generated reference ID (e.g., \"ref-1\").\n     */\n    addCodeReference(code, notebookName, cellIndex, lineNumber, // Start line\n    lineEndNumber // End line\n    ) {\n        const refId = `ref-${this.nextRefId++}`;\n        // Store both start and end line numbers\n        const refData = { code, notebookName, cellIndex, lineNumber, lineEndNumber };\n        // Store the ACTUAL CodeRefData object in the map\n        this.codeRefMap.set(refId, refData);\n        // Log the details separately\n        console.log('Added code reference:', refId, '->', `(${notebookName}, Cell ${cellIndex + 1}, Line ${lineNumber}${lineNumber !== lineEndNumber ? '_' + lineEndNumber : ''}) ` +\n            code.substring(0, 30) + '...' // Log metadata too\n        );\n        return refId;\n    }\n    /**\n     * Returns the current map of code references.\n     */\n    getCodeReferenceMap() {\n        return this.codeRefMap;\n    }\n    /**\n     * Clears the code reference map and resets the ID counter.\n     */\n    resetCodeReferences() {\n        // --- DEBUG LOG --- \n        console.log('[InputHandler] resetCodeReferences called!', new Error().stack); // Log call stack\n        // --- END DEBUG LOG --- \n        this.codeRefMap.clear();\n        this.nextRefId = 1;\n        console.log('Code references reset.'); // Debug log\n    }\n    /**\n     * Replaces code reference placeholders (e.g., \"[ref-1]\") in a message string\n     * with the actual code from the map.\n     * @param message The message string potentially containing placeholders.\n     * @returns The message string with placeholders resolved.\n     */\n    resolveCodeReferences(message) {\n        if (this.codeRefMap.size === 0) {\n            return message; // No references to resolve\n        }\n        // Regex to find placeholders like [ref-1], [ref-12], etc.\n        const placeholderRegex = /\\[(ref-\\d+)\\]/g;\n        let resolvedMessage = message.replace(placeholderRegex, (match, refId) => {\n            // Access the .code property from the stored object\n            const refData = this.codeRefMap.get(refId);\n            if (refData) {\n                console.log('Resolving code reference:', refId); // Debug log\n                // Add context around the replaced code\n                return `\\n\\`\\`\\`\\n${refData.code}\\n\\`\\`\\`\\n`; // Use refData.code\n            }\n            else {\n                console.warn('Could not find code for reference:', refId); // Warn if ref ID not found\n                return match; // Keep the placeholder if not found\n            }\n        });\n        return resolvedMessage;\n    }\n    /**\n      // Handle @ symbol removal to hide popup using selection API\n      const selection = window.getSelection();\n      if (!selection || !selection.rangeCount) return;\n  \n      const range = selection.getRangeAt(0);\n      // Check if the input field contains the start of the range\n      if (!this.chatInput.contains(range.startContainer)) return;\n  \n      const cursorPosition = getCaretPosition(this.chatInput); // Use helper\n      if (cursorPosition === null) return;\n  \n      const textContent = this.chatInput.textContent || '';\n      const textBeforeCursor = textContent.slice(0, cursorPosition);\n  \n      // Check if the character immediately before the cursor is '@'\n      // and if it's preceded by whitespace or is at the start of the input.\n      const isAtSymbolContext = textBeforeCursor.endsWith('@') &&\n                             (cursorPosition === 1 ||\n                              cursorPosition > 1 && /\\s/.test(textBeforeCursor[cursorPosition - 2]));\n  \n      if (this.hasAtSymbol && !isAtSymbolContext) {\n        // @ symbol context was present but now it's gone, hide the popup\n        this.callbacks.hidePopupMenu();\n      }\n      // Update the state *after* checking the previous state\n      this.hasAtSymbol = isAtSymbolContext;\n  \n      // --- Auto-resize logic (optional) ---\n      // Simple auto-resize based on scroll height (might need refinement)\n      if (!this.isInputExpanded) { // Only auto-resize if not manually expanded\n          this.chatInput.style.height = 'auto'; // Temporarily shrink to content\n          const scrollHeight = this.chatInput.scrollHeight;\n          // Set a max height to prevent infinite growth, e.g., 150px\n          const maxHeight = 150;\n          const newHeight = Math.min(scrollHeight, maxHeight);\n           // Only update height if it actually changes to avoid flicker\n          if (this.chatInput.offsetHeight < newHeight) {\n               this.chatInput.style.height = `${newHeight}px`;\n               this.chatInput.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';\n          } else if (scrollHeight <= this.chatInput.clientHeight) {\n              // Shrink if content height is less than current height\n              this.chatInput.style.height = `${scrollHeight}px`;\n              this.chatInput.style.overflowY = 'hidden';\n          }\n      }\n      // -----------------------------------\n    };\n    \n    /**\n     * Explicitly sets the hasAtSymbol flag. Called by shortcut handler.\n     */\n    setHasAtSymbol(value) {\n        this.hasAtSymbol = value;\n    }\n    /**\n     * Gets the current value of the hasAtSymbol flag. Called by shortcut handler.\n     */\n    getHasAtSymbol() {\n        return this.hasAtSymbol;\n    }\n}\nexports.InputHandler = InputHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageHandler = void 0;\nconst message_renderer_1 = require(\"../ui/message-renderer\");\nconst notebook_integration_1 = require(\"../utils/notebook-integration\");\nconst globals_1 = require(\"../core/globals\"); // Import globals for notebook tracker\n/**\n * Handles sending messages, interacting with the API,\n * managing streaming responses, and updating the UI and state.\n */\nclass MessageHandler {\n    constructor(apiClient, chatState, uiManager, rendererCallbacks, inputHandler) {\n        this.apiClient = apiClient;\n        this.chatState = chatState;\n        this.uiManager = uiManager;\n        this.rendererCallbacks = rendererCallbacks;\n        this.inputHandler = inputHandler;\n    }\n    /**\n     * Processes and sends a user-initiated message.\n     * Also handles adding the user message to the UI and clearing the input.\n     * Accepts the message text.\n     */\n    handleSendMessage(message) {\n        if (!message.trim())\n            return;\n        console.log(`[MessageHandler] Handling send: \"${message}\"`);\n        // Add user message to UI FIRST\n        // Assume user messages aren't markdown unless specific toggle is used elsewhere\n        this.addMessage(message, 'user');\n        // Clear input via InputHandler (which uses UIManager)\n        // REMOVED: this.inputHandler.clearInput(); // Input clearing is now handled by UIManager after the callback\n        // Send message to backend API and handle streaming response\n        this.streamAndRenderResponse(message);\n    }\n    /**\n     * Sends an automatic message (e.g., 'confirmed', 'rejected')\n     * to the backend and handles the streaming response.\n     * Also adds the user's confirmation/rejection action and a separator to the UI.\n     */\n    handleSendAutoMessage(message) {\n        if (!message.trim())\n            return;\n        // Add the user's action ('Confirmed' or 'Rejected') to the UI immediately\n        const userDisplayMessage = message.charAt(0).toUpperCase() + message.slice(1);\n        // Explicitly false for isMarkdown, true for isAuto\n        this.addMessage(userDisplayMessage, 'user', false, true);\n        // Create and add the separator element\n        console.log('[MessageHandler] Creating action separator element...'); // Debug log\n        const separatorDiv = document.createElement('div');\n        separatorDiv.className = 'jp-llm-ext-action-separator'; // Add a class for potential styling\n        separatorDiv.style.textAlign = 'center'; // Basic styling\n        separatorDiv.style.margin = '10px 0'; // Add some vertical space\n        separatorDiv.style.fontSize = '0.9em';\n        separatorDiv.style.color = 'var(--jp-ui-font-color2, grey)'; // Use JupyterLab theme variable\n        if (message === 'confirmed') {\n            separatorDiv.textContent = '-------- Confirmed--------';\n        }\n        else if (message === 'rejected') {\n            separatorDiv.textContent = '-------- Rejected--------';\n        }\n        else {\n            // Optional: Handle unexpected messages? Or just don't add a separator.\n            separatorDiv.textContent = `--------${userDisplayMessage}--------`;\n        }\n        // Add the separator directly to the UI Manager's container\n        console.log('[MessageHandler] Attempting to add separator element:', separatorDiv); // Debug log\n        this.uiManager.addChatMessageElement(separatorDiv);\n        console.log('[MessageHandler] Separator element should be added.'); // Debug log\n        // Send the technical message ('confirmed' or 'rejected') to the backend\n        // and handle the streaming response from the backend.\n        this.streamAndRenderResponse(message);\n    }\n    /**\n     * Adds a message to the UI via UIManager and saves to ChatState.\n     */\n    addMessage(text, sender, isMarkdown = false, // Default false, overridden below\n    isAuto = false // Flag for auto messages like confirm/reject\n    ) {\n        console.log(`[MessageHandler] Adding message: Sender=${sender}, Markdown=${isMarkdown}, Auto=${isAuto}`);\n        let messageElement;\n        // Prepare extended callbacks for the renderer\n        const extendedCallbacks = Object.assign(Object.assign({}, this.rendererCallbacks), { getCodeRefData: (refId) => {\n                return this.inputHandler.getCodeReferenceMap().get(refId);\n            }, getCurrentNotebookContext: () => {\n                var _a, _b;\n                const currentNotebook = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;\n                if (currentNotebook === null || currentNotebook === void 0 ? void 0 : currentNotebook.context) {\n                    const path = currentNotebook.context.path;\n                    const name = ((_b = path.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';\n                    return { name, path };\n                }\n                return undefined;\n            } });\n        if (sender === 'user') {\n            // Pass the isMarkdown option and extended callbacks to the renderer\n            messageElement = (0, message_renderer_1.renderUserMessage)(text, { isMarkdown }, extendedCallbacks);\n        }\n        else {\n            // Bot messages usually are markdown unless specified otherwise\n            // Handle auto messages specifically if they shouldn't be parsed as markdown\n            const botIsMarkdown = !isAuto; // Assume auto messages aren't markdown\n            // Pass extended callbacks to bot message renderer too, in case it needs them later\n            messageElement = (0, message_renderer_1.renderBotMessage)(text, { isMarkdown: botIsMarkdown }, extendedCallbacks);\n        }\n        this.uiManager.addChatMessageElement(messageElement);\n        // Don't save internal 'confirmed'/'rejected' messages to history\n        if (!isAuto) {\n            // Add isMarkdown back to the saved message state\n            const chatMessage = { sender, text, isMarkdown };\n            this.chatState.addMessageToCurrentChat(chatMessage);\n        }\n    }\n    /**\n     * Core logic for sending a message to the API, handling the stream,\n     * rendering the response, and saving the final bot message.\n     */\n    streamAndRenderResponse(messageToSend) {\n        // --- Prepare streaming UI elements (managed by UIManager) ---\n        // UIManager should provide a method to create/get these elements\n        const { streamingDiv, contentDiv } = this.uiManager.createBotMessageContainer();\n        let completeResponse = '';\n        const cellContext = (0, notebook_integration_1.getCurrentCellContent)(); // Use utility\n        // Stream response from API\n        this.apiClient.streamChat(messageToSend, { cellContext }, \n        // On chunk received\n        (chunk) => {\n            completeResponse += chunk;\n            // Update the temporary streaming div\n            streamingDiv.textContent = completeResponse;\n            this.uiManager.scrollToBottom();\n        }, \n        // On complete\n        () => {\n            var _a;\n            // Hide streaming div, show final content div\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Render the complete response using the renderer function\n            const renderedContent = (0, message_renderer_1.renderBotMessage)(completeResponse, { isMarkdown: true }, this.rendererCallbacks);\n            contentDiv.innerHTML = ''; // Clear placeholder/previous content\n            // Append rendered nodes, skipping any potential wrapper/indicator added by renderBotMessage itself\n            while (renderedContent.firstChild) {\n                // Check if the node is the specific markdown indicator we might add/remove\n                // Or just append everything if renderBotMessage returns the pure content\n                if (!((_a = renderedContent.firstChild.classList) === null || _a === void 0 ? void 0 : _a.contains('markdown-indicator'))) {\n                    contentDiv.appendChild(renderedContent.firstChild);\n                }\n                else {\n                    // Remove the indicator if it was part of the returned fragment\n                    renderedContent.removeChild(renderedContent.firstChild);\n                }\n            }\n            // Save final bot response to history via ChatState\n            const isImage = completeResponse.trim().startsWith('/images/'); // Simple check\n            const botMessageData = {\n                text: completeResponse,\n                sender: 'bot',\n                isMarkdown: !isImage // Save as markdown unless it's an image URL\n            };\n            this.chatState.addMessageToCurrentChat(botMessageData);\n            this.uiManager.scrollToBottom();\n        }, \n        // On error\n        (error) => {\n            // Hide streaming div, show final content div with error\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Use a dedicated error rendering style/component if available\n            contentDiv.innerHTML = `<div class=\"jp-llm-ext-error-message\">Error: ${error.message}</div>`;\n            console.error('API Error:', error);\n            this.uiManager.scrollToBottom();\n        });\n    }\n}\nexports.MessageHandler = MessageHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopupMenuManager = void 0;\nconst globals_1 = require(\"../core/globals\");\n/**\n * Manages the state and interactions of the multi-level popup menu.\n */\nclass PopupMenuManager {\n    constructor(docManager, widgetNode, callbacks) {\n        this.currentMenuLevel = 'top';\n        this.currentMenuPath = '';\n        this.menuHistory = [];\n        this.currentNotebook = null;\n        this.selectedMenuItemIndex = -1; // Track currently selected menu item\n        this.isRenderingContent = false; // Flag to prevent recursive renders\n        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders\n        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];\n        this.fileCache = new Map();\n        this.docManager = docManager;\n        this.widgetNode = widgetNode;\n        this.callbacks = callbacks;\n        this.popupMenuContainer = document.createElement('div');\n        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';\n        this.popupMenuContainer.style.display = 'none';\n        // Attach to the widget node instead of the body\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Create search input\n        this.searchInput = document.createElement('input');\n        this.searchInput.type = 'text';\n        this.searchInput.placeholder = 'Search...';\n        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling\n        // Use 'input' event instead of directly re-rendering on every keystroke\n        this.searchInput.addEventListener('input', () => {\n            // Only re-render if the search term has actually changed\n            if (this.searchInput.value !== this.lastSearchTerm) {\n                this.lastSearchTerm = this.searchInput.value;\n                this.renderMenuContent();\n            }\n        });\n        // Handle keydown in search input to stop propagation for navigation keys\n        this.searchInput.addEventListener('keydown', (event) => {\n            console.log(`POPUP Search KeyDown: Key='${event.key}'`);\n            // IMPORTANT: Prevent these keys from being captured by the document handler\n            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);\n                if (event.key === 'Escape') {\n                    // Handle Escape directly here\n                    this.hidePopupMenu();\n                }\n                else if (event.key === 'Enter') {\n                    // Maybe select first item on Enter?\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        this.selectedMenuItemIndex = 0;\n                        this.updateSelectionHighlight();\n                        // Optionally activate the item:\n                        // menuItems[0].click(); \n                    }\n                }\n                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                    // Move to first/last menu item\n                    // The blur() will be handled by main key handler\n                }\n                event.stopPropagation();\n            }\n            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys\n            // This allows default behavior to work properly\n        }, true); // Use capture phase\n        document.addEventListener('click', this.handleDocumentClick.bind(this), true);\n        // IMPORTANT: Use a separate bound function for the document keydown\n        // so we can remove the exact same listener later\n        this.boundHandleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener('keydown', this.boundHandleKeyDown, true);\n        if (globals_1.globals.notebookTracker) {\n            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;\n            globals_1.globals.notebookTracker.currentChanged.connect((sender, notebook) => {\n                this.currentNotebook = notebook;\n            });\n        }\n    }\n    dispose() {\n        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);\n        // Remove using the exact same bound function\n        document.removeEventListener('keydown', this.boundHandleKeyDown, true);\n        // Remove from widgetNode if attached\n        if (this.popupMenuContainer.parentNode === this.widgetNode) {\n            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);\n        }\n    }\n    handleDocumentClick(event) {\n        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {\n            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');\n            if (atButton && atButton.contains(event.target)) {\n                console.log('POPUP: Click was on the @ button, not hiding.');\n                return;\n            }\n            console.log('POPUP: Click detected outside the menu.');\n            this.hidePopupMenu();\n        }\n    }\n    async showPopupMenu(x, y) {\n        console.log(`POPUP: Showing menu at (${x}, ${y})`);\n        // Store the initial anchor point for positioning\n        this._anchorX = x;\n        this._anchorY = y;\n        if (this.popupMenuContainer.style.display === 'none') {\n            this.currentMenuLevel = 'top';\n            this.currentMenuPath = '';\n            this.menuHistory = [];\n            this.searchInput.value = ''; // Clear search on show\n            this.lastSearchTerm = ''; // Reset last search term\n            await this.setCurrentDirectoryPath();\n        }\n        await this.renderMenuContent();\n        // Ensure it's attached to the widget node if somehow detached\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Position the popup menu - DEFER calculation slightly\n        setTimeout(() => {\n            console.log(\"POPUP: Deferred updatePopupPosition call.\");\n            try {\n                this.updatePopupPosition();\n            }\n            catch (error) {\n                console.error(\"POPUP: Error during deferred updatePopupPosition:\", error);\n            }\n            // Focus the search input *after* positioning if in file/dir view\n            // Otherwise, focus first menu item\n            if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                this.searchInput.focus();\n                console.log('POPUP: Focused search input after deferred positioning.');\n                this.selectedMenuItemIndex = -1; // Don't select an item if search is focused\n            }\n            else { // Top level or cells\n                this.selectedMenuItemIndex = -1;\n                this.selectNextMenuItem(); // Select first item\n                // Optionally focus the first item for immediate keyboard nav\n                // const menuItems = this.getMenuItems();\n                // if (menuItems.length > 0) menuItems[0].focus(); \n            }\n        }, 0); // 0ms delay is usually sufficient\n    }\n    hidePopupMenu() {\n        if (this.popupMenuContainer.style.display !== 'none') {\n            console.log('POPUP: Hiding menu. Called from:', new Error().stack);\n            this.popupMenuContainer.style.display = 'none';\n            this.currentMenuLevel = 'top'; // Reset level\n        }\n    }\n    async renderMenuContent() {\n        // Prevent recursive renders\n        if (this.isRenderingContent) {\n            console.log('POPUP: Skipping render - already rendering');\n            return;\n        }\n        this.isRenderingContent = true;\n        try {\n            // Clear existing content\n            while (this.popupMenuContainer.firstChild) {\n                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);\n            }\n            // Only add search input if NOT at top level\n            if (this.currentMenuLevel !== 'top') {\n                // Add search input at the top of the menu\n                this.popupMenuContainer.appendChild(this.searchInput);\n                this.searchInput.value = ''; // Clear for file/dir/cell levels\n                this.lastSearchTerm = '';\n            }\n            // Render different menu content based on current level\n            switch (this.currentMenuLevel) {\n                case 'top':\n                    this.renderTopLevelItems();\n                    break;\n                case 'files':\n                case 'directories':\n                    await this.renderDirectoryBrowserItems();\n                    break;\n                case 'cells':\n                    await this.renderCellItems();\n                    break;\n            }\n            // Reset selection after rendering\n            this.selectedMenuItemIndex = -1;\n            this.updateSelectionHighlight();\n            // Update the position (might have changed due to content rendering)\n            console.log(\"POPUP: ===> About to call updatePopupPosition after renderMenuContent\");\n            try {\n                this.updatePopupPosition();\n            }\n            catch (err) {\n                console.error(\"POPUP: Error calling updatePopupPosition after render:\", err);\n            }\n        }\n        catch (error) {\n            console.error('POPUP: Error rendering menu content', error);\n        }\n        finally {\n            this.isRenderingContent = false;\n        }\n    }\n    renderTopLevelItems() {\n        const topLevelCommands = [\n            { label: 'Code', description: '', actionId: 'insert-code' },\n            { label: 'Cells', description: '', actionId: 'browse-cells' },\n            { label: 'File', description: '', actionId: 'browse-files' },\n            { label: 'Directory', description: '', actionId: 'browse-directories' }\n        ];\n        topLevelCommands.forEach(cmd => {\n            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);\n            this.popupMenuContainer.appendChild(item);\n        });\n    }\n    async renderDirectoryBrowserItems() {\n        var _a;\n        // Get search term\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        // Temporarily add loading item below search/path\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // If contents were already fetched recently and we're just filtering again,\n            // we could potentially cache the results to avoid unnecessary API calls\n            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';\n            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);\n            // Check if still in DOM before trying to remove\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (contents && contents.length > 0) {\n                // Filter based on search term\n                const filteredContents = contents.filter(item => {\n                    return item.name.toLowerCase().includes(searchTerm) ||\n                        item.relativePath.toLowerCase().includes(searchTerm);\n                });\n                if (filteredContents.length > 0) {\n                    filteredContents.forEach(item => {\n                        const itemName = item.name;\n                        const itemType = item.type;\n                        const itemPath = item.path;\n                        const relativePath = item.relativePath;\n                        const icon = itemType === 'directory' ? '' : '';\n                        let actionId;\n                        if (itemType === 'directory') {\n                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';\n                        }\n                        else { // itemType === 'file'\n                            actionId = 'select-file';\n                        }\n                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                }\n                else {\n                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');\n                    emptyItem.style.pointerEvents = 'none';\n                    this.popupMenuContainer.appendChild(emptyItem);\n                }\n            }\n            else {\n                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n            }\n        }\n        catch (error) {\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading/filtering directory contents:', error);\n        }\n    }\n    /**\n     * Renders all cells from the current notebook\n     */\n    async renderCellItems() {\n        var _a, _b;\n        // Get search term for filtering\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        // Create a loading indicator\n        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // Check if we have an active notebook\n            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {\n                // Remove loading item\n                if (this.popupMenuContainer.contains(loadingItem)) {\n                    this.popupMenuContainer.removeChild(loadingItem);\n                }\n                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');\n                errorItem.style.color = 'red';\n                errorItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(errorItem);\n                return;\n            }\n            const notebookModel = this.currentNotebook.content.model;\n            const cells = notebookModel.cells;\n            // Remove loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (!cells || cells.length === 0) {\n                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n                return;\n            }\n            // Process and display each cell\n            let filteredCellCount = 0;\n            for (let i = 0; i < cells.length; i++) {\n                const cell = cells.get(i);\n                const cellType = cell.type;\n                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :\n                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');\n                // Use type casting to avoid TypeScript errors\n                const executionCount = cellType === 'code' ?\n                    (cell.executionCount !== undefined && cell.executionCount !== null ?\n                        cell.executionCount : '*') :\n                    '';\n                // Create a preview of the cell content (truncate if needed)\n                const contentPreview = typeof cellContent === 'string' ?\n                    cellContent :\n                    (Array.isArray(cellContent) ? cellContent.join('\\n') : '');\n                const firstLine = contentPreview.split('\\n')[0] || '';\n                const truncatedContent = firstLine.length > 30 ?\n                    firstLine.substring(0, 30) + '...' :\n                    firstLine;\n                // Create cell label with styled type indicator\n                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';\n                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';\n                // Create menu item for this cell\n                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML\n                'select-cell', i.toString() // Store cell index in path\n                );\n                // Create styled content with HTML elements\n                const typeSpan = document.createElement('span');\n                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;\n                typeSpan.textContent = typeIndicator;\n                const execSpan = document.createElement('span');\n                execSpan.className = 'cell-exec-count';\n                execSpan.textContent = executionDisplay;\n                execSpan.style.marginRight = '8px';\n                const contentSpan = document.createElement('span');\n                contentSpan.className = 'cell-content-preview';\n                contentSpan.textContent = truncatedContent;\n                // Get the label span (first child of the menu item)\n                const labelSpan = cellItem.querySelector('span');\n                if (labelSpan) {\n                    labelSpan.textContent = ''; // Clear existing text\n                    labelSpan.appendChild(typeSpan);\n                    if (executionDisplay) {\n                        labelSpan.appendChild(execSpan);\n                    }\n                    labelSpan.appendChild(contentSpan);\n                }\n                // Construct full searchable text\n                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();\n                // Filter by search term if one is provided\n                if (searchTerm && !searchableText.includes(searchTerm)) {\n                    continue;\n                }\n                this.popupMenuContainer.appendChild(cellItem);\n                filteredCellCount++;\n            }\n            if (filteredCellCount === 0) {\n                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');\n                noMatchItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(noMatchItem);\n            }\n        }\n        catch (error) {\n            // Clean up loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading notebook cells:', error);\n        }\n    }\n    createMenuItem(text, actionId, path = '', description = '') {\n        const item = document.createElement('div');\n        item.className = 'jp-llm-ext-popup-menu-item';\n        item.dataset.actionId = actionId;\n        if (path) {\n            item.dataset.path = path;\n        }\n        item.onclick = (event) => this.handleMenuClick(event);\n        const labelSpan = document.createElement('span');\n        labelSpan.textContent = text;\n        item.appendChild(labelSpan);\n        if (description) {\n            const pathSpan = document.createElement('span');\n            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';\n            pathSpan.textContent = description;\n            pathSpan.style.fontSize = '0.85em';\n            pathSpan.style.color = 'var(--jp-ui-font-color2)';\n            pathSpan.style.marginLeft = '8px';\n            pathSpan.style.opacity = '0.8';\n            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed\n            item.appendChild(pathSpan);\n        }\n        return item;\n    }\n    async handleMenuClick(event) {\n        var _a;\n        const target = event.currentTarget;\n        const actionId = target.dataset.actionId;\n        const path = target.dataset.path || '';\n        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);\n        switch (actionId) {\n            case 'navigate-back':\n                this.navigateBackMenu();\n                break;\n            case 'insert-code': {\n                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;\n                if (selectedText) {\n                    // Show submenu for code insertion options\n                    const submenuItems = [\n                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },\n                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }\n                    ];\n                    // Replace current menu with submenu options\n                    this.popupMenuContainer.innerHTML = '';\n                    submenuItems.forEach(item => {\n                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                    // Add back button\n                    const backButton = this.createMenuItem('Back', 'navigate-back');\n                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';\n                    this.popupMenuContainer.appendChild(backButton);\n                    return; // Don't hide menu, wait for submenu selection\n                }\n                else {\n                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;\n                    if (cellContent) {\n                        this.callbacks.insertCode(cellContent);\n                    }\n                }\n                this.hidePopupMenu();\n                break;\n            }\n            case 'insert-plain-code': {\n                if (path) {\n                    this.callbacks.insertCode(path);\n                    this.hidePopupMenu();\n                }\n                break;\n            }\n            case 'collapse-code-ref': {\n                if (path && this.currentNotebook) {\n                    try {\n                        // Get notebook file name (without extension)\n                        const notebookPath = this.currentNotebook.context.path;\n                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';\n                        // Find current cell index and approximate line number\n                        const currentCell = this.currentNotebook.content.activeCell;\n                        if (!currentCell) {\n                            throw new Error('No active cell found');\n                        }\n                        // Get current cell index\n                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;\n                        // Estimate line number from cursor position\n                        let lineNumber = 1; // Default to line 1\n                        if (currentCell.editor) {\n                            const editor = currentCell.editor;\n                            const cursor = editor.getCursorPosition();\n                            if (cursor) {\n                                lineNumber = cursor.line + 1; // Convert to 1-indexed\n                            }\n                        }\n                        // Invoke the callback with all the information needed\n                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);\n                        this.hidePopupMenu();\n                    }\n                    catch (error) {\n                        console.error('Error creating collapsed code reference:', error);\n                        // Fallback to inserting code directly\n                        this.callbacks.insertCode(path);\n                        this.hidePopupMenu();\n                    }\n                }\n                else {\n                    // If something went wrong or no path provided, just insert as regular code\n                    if (path) {\n                        this.callbacks.insertCode(path);\n                    }\n                    this.hidePopupMenu();\n                }\n                break;\n            }\n            case 'browse-cells':\n                await this.navigateMenu('cells', '');\n                this.searchInput.value = '';\n                break;\n            case 'browse-files':\n                await this.navigateMenu('files', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'browse-directories':\n                await this.navigateMenu('directories', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'select-cell':\n                if (path) {\n                    const cellIndex = parseInt(path);\n                    if (!isNaN(cellIndex)) {\n                        // Construct the reference text (e.g., \"@Cell 3\")\n                        // const refText = `@Cell ${cellIndex + 1}`; // Use 1-based index for display\n                        // console.log(\"TODO: Implement cell reference insertion: \", refText);\n                        this.callbacks.insertCellByIndex(cellIndex); // Call the appropriate callback\n                        this.hidePopupMenu();\n                    }\n                    else {\n                        console.error('POPUP: Invalid cell index.');\n                    }\n                }\n                else {\n                    console.error('POPUP: Cell selected but index (path) is missing.');\n                }\n                break;\n            case 'select-file':\n                if (path) {\n                    // Construct the reference text (e.g., \"@file path/to/file.py\")\n                    // const refText = `@file ${path}`;\n                    // console.log(\"TODO: Implement file reference insertion: \", refText);\n                    this.callbacks.insertFilePath(path); // Call the appropriate callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: File selected but path is missing.');\n                }\n                break;\n            case 'select-directory-navigate': // New action to navigate into dir when in file view\n                if (path) {\n                    // Clear the file cache for the specific directory to force a refresh\n                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;\n                    this.fileCache.delete(cacheKey);\n                    // Make sure we're passing the correct level type\n                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?\n                        this.currentMenuLevel : 'files';\n                    await this.navigateMenu(level, path);\n                    this.searchInput.value = ''; // Clear search on navigation\n                }\n                else {\n                    console.error('POPUP: Directory selected for navigation but path is missing.');\n                }\n                break;\n            case 'select-directory-callback': // New action to select dir when in directory view\n                if (path) {\n                    // Construct the reference text (e.g., \"@dir path/to/directory\")\n                    // const refText = `@dir ${path}`;\n                    // console.log(\"TODO: Implement directory reference insertion: \", refText);\n                    this.callbacks.insertDirectoryPath(path); // Call the appropriate callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: Directory selected for callback but path is missing.');\n                }\n                break;\n            case 'placeholder-action':\n                console.log('Placeholder action triggered.');\n                this.hidePopupMenu();\n                break;\n            case 'loading':\n            case 'empty':\n            case 'error':\n                break;\n            default:\n                console.warn('Unknown menu action:', actionId);\n                this.hidePopupMenu();\n                break;\n        }\n        event.stopPropagation();\n    }\n    async navigateMenu(level, path) {\n        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);\n        // Only push history if we are actually moving to a new state\n        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {\n            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n        }\n        this.currentMenuLevel = level;\n        this.currentMenuPath = path;\n        // Don't clear search on programmatic navigation (like back button)\n        // this.searchInput.value = ''; // Maybe keep search term?\n        await this.renderMenuContent();\n        // Focus search input after navigating to file/dir view\n        if (level === 'files' || level === 'directories') {\n            setTimeout(() => this.searchInput.focus(), 0);\n            this.selectedMenuItemIndex = -1; // Reset selection\n        }\n        else {\n            // Select first item if navigating back to top level\n            this.selectedMenuItemIndex = -1;\n            setTimeout(() => this.selectNextMenuItem(), 0);\n        }\n    }\n    navigateBackMenu() {\n        const previousState = this.menuHistory.pop();\n        if (previousState) {\n            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);\n            this.currentMenuLevel = previousState.level;\n            this.currentMenuPath = previousState.path;\n            // Don't clear search on back navigation\n            this.renderMenuContent().then(() => {\n                // Focus search input if going back to file/dir view\n                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                    setTimeout(() => this.searchInput.focus(), 0);\n                    this.selectedMenuItemIndex = -1; // Reset selection\n                }\n                else {\n                    // Select first item if going back to top level\n                    this.selectedMenuItemIndex = -1;\n                    setTimeout(() => this.selectNextMenuItem(), 0);\n                }\n            });\n        }\n        else {\n            console.log('POPUP: Already at the top level.');\n            this.hidePopupMenu();\n        }\n    }\n    async listCurrentDirectoryContents(basePath, filterType) {\n        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);\n        // Check cache first\n        const cacheKey = `${basePath}:${filterType || 'all'}`;\n        if (this.fileCache.has(cacheKey)) {\n            console.log('POPUP: Using cached directory contents');\n            return this.fileCache.get(cacheKey) || null;\n        }\n        try {\n            const effectivePath = basePath === '/' ? '' : basePath;\n            // Ensure trailing slash removed for consistency unless it's root\n            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;\n            // Result array that will hold all files and directories\n            let allResults = [];\n            // Get the base directory contents (non-recursive)\n            const baseContents = await this.docManager.services.contents.get(pathForApi || '');\n            if (baseContents.type !== 'directory') {\n                console.error('Path is not a directory:', basePath);\n                return null;\n            }\n            // Process base directory items\n            for (const item of baseContents.content) {\n                const itemType = item.type === 'directory' ? 'directory' : 'file';\n                // Add directories if we're listing directories or both\n                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {\n                    allResults.push({\n                        name: item.name,\n                        path: item.path,\n                        type: 'directory',\n                        relativePath: `./${item.name}`\n                    });\n                }\n                // Add files if we're listing files and the extension is allowed\n                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {\n                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();\n                    if (this.allowedExtensions.includes(fileExt)) {\n                        allResults.push({\n                            name: item.name,\n                            path: item.path,\n                            type: 'file',\n                            relativePath: `./${item.name}`\n                        });\n                    }\n                }\n            }\n            // Sort the results appropriately\n            allResults = allResults.sort((a, b) => {\n                // If listing directories only, sort alphabetically\n                if (filterType === 'directory') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing files only, sort alphabetically\n                if (filterType === 'file') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing both, sort directories first, then files alphabetically\n                if (a.type === 'directory' && b.type !== 'directory')\n                    return -1;\n                if (a.type !== 'directory' && b.type === 'directory')\n                    return 1;\n                return a.name.localeCompare(b.name);\n            });\n            // Cache the results for future use\n            this.fileCache.set(cacheKey, allResults);\n            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);\n            return allResults;\n        }\n        catch (error) {\n            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);\n            return null;\n        }\n    }\n    async setCurrentDirectoryPath() {\n        var _a;\n        let dirPath = null;\n        const app = globals_1.globals.app;\n        if (!app) {\n            console.error('POPUP: Application reference not available');\n            this.currentMenuPath = '';\n            return;\n        }\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                dirPath = this.getParentDirectory(path);\n                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {\n            const notebookPath = this.currentNotebook.context.path;\n            if (typeof notebookPath === 'string') {\n                dirPath = this.getParentDirectory(notebookPath);\n                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null) {\n            try {\n                const leftWidgets = Array.from(app.shell.widgets('left'));\n                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');\n                if (fileBrowserWidget && typeof ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path) === 'string') {\n                    dirPath = fileBrowserWidget.model.path;\n                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);\n                }\n                else {\n                    console.log('POPUP: File browser widget path not directly accessible.');\n                }\n            }\n            catch (e) {\n                console.warn('POPUP: Could not get path from file browser.', e);\n            }\n        }\n        if (dirPath === null) {\n            dirPath = '';\n            console.log('POPUP: Falling back to server root path.');\n        }\n        this.currentMenuPath = dirPath;\n        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);\n    }\n    getParentDirectory(path) {\n        if (!path)\n            return '';\n        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n        if (lastSlash === -1)\n            return ''; // No directory part, likely root or just a filename\n        return path.substring(0, lastSlash);\n    }\n    /**\n     * Handle keyboard navigation when the popup menu is shown\n     */\n    handleKeyDown(event) {\n        // Only handle keys if the popup is visible\n        if (!this.isPopupMenuVisible()) {\n            return;\n        }\n        console.log(`POPUP Document KeyDown: Key='${event.key}', Target=`, event.target);\n        // Allow default browser search behavior (e.g., Cmd+F)\n        if (event.metaKey || event.ctrlKey) {\n            return;\n        }\n        // If focus is inside the search input, let its handler manage navigation keys\n        if (event.target === this.searchInput) {\n            console.log('POPUP (Document): Key event target is search input, skipping document handler.');\n            // Allow Backspace etc. to work naturally in search input\n            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n                // Let the search input's keydown handle Escape, stop propagation\n                // But let the main handler process Up/Down/Enter/Tab by blurring\n                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n                    // Trigger blur to shift focus to menu items\n                    this.searchInput.blur();\n                    // Prevent default scrolling behavior\n                    event.preventDefault();\n                    // Process the key event now in the menu context\n                    this.processMenuNavigation(event.key);\n                }\n                else if (event.key === 'Enter') {\n                    this.searchInput.blur();\n                    event.preventDefault();\n                    this.processMenuNavigation(event.key);\n                }\n                else if (event.key === 'Tab') {\n                    // Allow tabbing away (or maybe cycle focus?)\n                    this.searchInput.blur();\n                    // Don't prevent default - allow tabbing\n                }\n                else if (event.key === 'Escape') {\n                    // Already handled by searchInput's listener, just stop propagation\n                    event.stopPropagation();\n                }\n            }\n            else {\n                // Allow other keys (typing) in the search input\n                return;\n            }\n        }\n        else {\n            // Focus is NOT in the search input, process normally\n            this.processMenuNavigation(event.key);\n            // Prevent default browser actions for these keys when menu is active\n            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        }\n    }\n    processMenuNavigation(key) {\n        switch (key) {\n            case 'ArrowDown':\n                console.log('POPUP: Arrow Down pressed');\n                this.selectNextMenuItem();\n                break;\n            case 'ArrowUp':\n                console.log('POPUP: Arrow Up pressed');\n                this.selectPreviousMenuItem();\n                break;\n            case 'Enter':\n            case 'Tab': // Treat Tab like Enter for selection\n                console.log(`POPUP: ${key} pressed`);\n                if (this.selectedMenuItemIndex >= 0) {\n                    const menuItems = this.getMenuItems();\n                    if (menuItems[this.selectedMenuItemIndex]) {\n                        console.log('POPUP: Simulating click on selected item:', menuItems[this.selectedMenuItemIndex].textContent);\n                        // Simulate click to trigger handleMenuClick\n                        menuItems[this.selectedMenuItemIndex].click();\n                    }\n                    else {\n                        console.log('POPUP: Selected index out of bounds?');\n                    }\n                }\n                else {\n                    console.log('POPUP: Enter/Tab pressed but no item selected');\n                    // If no item is selected, maybe select the first one and activate?\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        menuItems[0].click(); // Activate first item\n                    }\n                }\n                break;\n            case 'Escape':\n                console.log('POPUP: Escape pressed');\n                // If in a submenu, navigate back; otherwise, hide.\n                if (this.menuHistory.length > 0) {\n                    this.navigateBackMenu();\n                }\n                else {\n                    this.hidePopupMenu();\n                }\n                break;\n        }\n    }\n    updateSelectionHighlight() {\n        const menuItems = this.getMenuItems();\n        menuItems.forEach((item, index) => {\n            if (index === this.selectedMenuItemIndex) {\n                item.classList.add('jp-llm-ext-popup-menu-item-selected');\n                // Scroll into view if necessary\n                item.scrollIntoView({ block: 'nearest' });\n            }\n            else {\n                item.classList.remove('jp-llm-ext-popup-menu-item-selected');\n            }\n        });\n    }\n    deselectAllMenuItems() {\n        const menuItems = this.getMenuItems();\n        menuItems.forEach(item => {\n            item.classList.remove('jp-llm-ext-popup-menu-item-selected');\n        });\n        this.selectedMenuItemIndex = -1;\n    }\n    selectNextMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (menuItems.length === 0)\n            return;\n        this.selectedMenuItemIndex++;\n        if (this.selectedMenuItemIndex >= menuItems.length) {\n            this.selectedMenuItemIndex = 0; // Wrap around\n        }\n        this.updateSelectionHighlight();\n        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);\n    }\n    selectPreviousMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (menuItems.length === 0)\n            return;\n        this.selectedMenuItemIndex--;\n        if (this.selectedMenuItemIndex < 0) {\n            this.selectedMenuItemIndex = menuItems.length - 1; // Wrap around\n        }\n        this.updateSelectionHighlight();\n        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);\n    }\n    /**\n     * Get all interactive menu items currently displayed\n     */\n    getMenuItems() {\n        return Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));\n    }\n    /**\n     * Updates the position of the popup menu based on the active reference range\n     * or the initial anchor point. Tries to position the BOTTOM of the menu\n     * just ABOVE the range/anchor.\n     */\n    updatePopupPosition() {\n        if (!this.widgetNode)\n            return;\n        const widgetRect = this.widgetNode.getBoundingClientRect();\n        let targetTop;\n        let targetLeft;\n        // Use the anchor coordinates provided (now from the reliable temp span)\n        if (this._anchorX !== undefined && this._anchorY !== undefined) {\n            console.log(`POPUP: Positioning based on anchor point: (${this._anchorX}, ${this._anchorY})`);\n            // Target position relative to viewport\n            targetTop = this._anchorY;\n            targetLeft = this._anchorX;\n        }\n        else {\n            console.warn(\"POPUP: Cannot update position - no anchor point provided.\");\n            return;\n        }\n        // Make sure the popup is visible and rendered to get its height\n        this.popupMenuContainer.style.visibility = 'hidden'; // Keep it hidden while calculating\n        this.popupMenuContainer.style.display = 'block';\n        const popupHeight = this.popupMenuContainer.offsetHeight;\n        const popupWidth = this.popupMenuContainer.offsetWidth;\n        // Calculate desired 'top' style relative to the widgetNode\n        // Position the bottom of the popup just above the target's top\n        let top = (targetTop - widgetRect.top) - popupHeight;\n        // Calculate desired 'left' style relative to the widgetNode\n        let left = targetLeft - widgetRect.left;\n        // --- Boundary checks (relative to widget) ---\n        const widgetClientWidth = this.widgetNode.clientWidth; // Use clientWidth for inner width\n        const widgetClientHeight = this.widgetNode.clientHeight;\n        // Prevent going off the left edge of the widget\n        if (left < 0) {\n            left = 5; // Small padding\n            console.log(\"POPUP Adjust: Corrected left edge\");\n        }\n        // Prevent going off the right edge of the widget\n        if (left + popupWidth > widgetClientWidth) {\n            left = widgetClientWidth - popupWidth - 5; // Adjust left, add padding\n            console.log(\"POPUP Adjust: Corrected right edge\");\n        }\n        // Prevent going off the top edge of the widget\n        if (top < 0) {\n            // If it goes off the top, try positioning it *below* the target instead\n            const spaceBelow = widgetClientHeight - (targetTop - widgetRect.top + 10); // Space below target\n            if (spaceBelow >= popupHeight) {\n                top = (targetTop - widgetRect.top) + 10; // Position below target with padding\n                console.log(\"POPUP Adjust: Flipping below target (was off top)\");\n            }\n            else {\n                // Not enough space below either, clamp to top\n                top = 5; // Small padding from top\n                console.log(\"POPUP Adjust: Clamped to top edge (no space below)\");\n            }\n        }\n        console.log(`POPUP: Setting position - Top: ${top}px, Left: ${left}px (Relative to Widget)`);\n        this.popupMenuContainer.style.top = `${top}px`;\n        this.popupMenuContainer.style.left = `${left}px`;\n        // Make it visible again\n        this.popupMenuContainer.style.display = 'block';\n        this.popupMenuContainer.style.visibility = 'visible';\n    }\n    /**\n     * Checks if the popup menu is currently visible.\n     */\n    isPopupMenuVisible() {\n        return this.popupMenuContainer.style.display !== 'none';\n    }\n    /**\n     * Gets the current level of the popup menu.\n     */\n    getCurrentMenuLevel() {\n        return this.currentMenuLevel;\n    }\n}\nexports.PopupMenuManager = PopupMenuManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsHandler = void 0;\n/**\n * Handles the logic related to the settings modal:\n * displaying, hiding, populating, saving, and showing feedback.\n */\nclass SettingsHandler {\n    constructor(state, settingsModalContainer, uiManager // Pass UIManager for notifications\n    ) {\n        this.state = state;\n        this.settingsModalContainer = settingsModalContainer;\n        this.uiManager = uiManager;\n    }\n    /**\n     * Populates the settings form with current values and displays the modal.\n     */\n    showModal() {\n        const currentSettings = this.state.getSettings();\n        if (currentSettings) {\n            try {\n                // Query elements within the modal container\n                this.settingsModalContainer.querySelector('#settings-provider').value = currentSettings.provider;\n                this.settingsModalContainer.querySelector('#settings-api-key').value = currentSettings.apiKey;\n                this.settingsModalContainer.querySelector('#settings-api-url').value = currentSettings.apiUrl;\n                this.settingsModalContainer.querySelector('#settings-rules').value = currentSettings.rules;\n            }\n            catch (error) {\n                console.error('Error populating settings form:', error);\n                // Optionally show an error to the user\n            }\n        }\n        this.settingsModalContainer.style.display = 'flex';\n    }\n    /**\n     * Hides the settings modal.\n     */\n    hideModal() {\n        this.settingsModalContainer.style.display = 'none';\n    }\n    /**\n     * Reads values from the form, saves them using SettingsState,\n     * updates the ApiClient, hides the modal, and shows a success notification.\n     * This method is intended to be called by the modal's save button listener.\n     */\n    saveSettings() {\n        var _a, _b, _c, _d;\n        // Get values from form fields within the modal container\n        const provider = (_a = this.settingsModalContainer.querySelector('#settings-provider')) === null || _a === void 0 ? void 0 : _a.value;\n        const key = (_b = this.settingsModalContainer.querySelector('#settings-api-key')) === null || _b === void 0 ? void 0 : _b.value;\n        const url = (_c = this.settingsModalContainer.querySelector('#settings-api-url')) === null || _c === void 0 ? void 0 : _c.value;\n        const rules = (_d = this.settingsModalContainer.querySelector('#settings-rules')) === null || _d === void 0 ? void 0 : _d.value;\n        // Basic validation\n        if (provider === undefined || key === undefined || url === undefined || rules === undefined) {\n            console.error(\"Could not find all settings input elements.\");\n            this.showNotification('Error: Could not save settings. Input elements missing.', 'error');\n            return;\n        }\n        const settings = { provider, apiKey: key, apiUrl: url, rules };\n        try {\n            // Save settings using SettingsState\n            this.state.saveSettings(settings);\n            console.log('Settings saved via SettingsState:', settings);\n            // Reconfigure ApiClient instance\n            // TODO: The ApiClient should ideally observe the SettingsState \n            // or have a dedicated update method instead of creating a new instance.\n            // For now, we assume the main widget will recreate/update the ApiClient \n            // or pass an update callback.\n            // Example: this.apiClient.updateConfig(settings.apiUrl || undefined);\n            console.log('API Client needs reconfiguration with new settings.');\n            this.hideModal();\n            this.showNotification('Settings saved successfully', 'success');\n        }\n        catch (error) {\n            console.error('Error saving settings:', error);\n            this.showNotification(`Error saving settings: ${error}`, 'error');\n        }\n    }\n    /**\n     * Displays a temporary notification message.\n     * Relies on UIManager to provide the actual notification mechanism.\n     */\n    showNotification(message, type) {\n        // Delegate notification display to UIManager or a dedicated notification service\n        if (this.uiManager && typeof this.uiManager.showNotification === 'function') {\n            this.uiManager.showNotification(message, type);\n        }\n        else {\n            // Fallback or log if UIManager doesn't support notifications yet\n            console.log(`Notification (${type}): ${message}`);\n            // The old popSaveSuccess logic requires direct access to the widget node,\n            // which this handler shouldn't have. This needs to be handled by the UI layer.\n        }\n    }\n}\nexports.SettingsHandler = SettingsHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setupShortcuts = setupShortcuts;\nexports.removeShortcuts = removeShortcuts;\nconst notebook_integration_1 = require(\"../utils/notebook-integration\");\nlet _handleKeyDown = null;\n/**\n * Sets up global keyboard shortcuts for the extension.\n *\n * @param inputHandler Instance of InputHandler to interact with input state/methods.\n * @param popupMenuManager Instance of PopupMenuManager.\n * @param callbacks Object containing callback functions for UI interactions.\n */\nfunction setupShortcuts(inputHandler, // Pass InputHandler instance directly\npopupMenuManager, callbacks) {\n    if (_handleKeyDown) {\n        console.warn('Shortcuts already set up. Removing previous listener.');\n        removeShortcuts();\n    }\n    _handleKeyDown = (event) => {\n        const { showIndicator, appendToInput, showWidget, focusInput } = callbacks;\n        // Check for @ key - event.key should correctly report '@' even with Shift\n        // Also check for SHIFT+2 as an alternative way to trigger '@'\n        if (event.key === '@' || (event.shiftKey && event.key === '2')) {\n            console.log(\"SHORTCUT HANDLER: '@' key or SHIFT+2 detected\");\n            const inputField = document.activeElement;\n            const isContentEditableInput = inputField &&\n                inputField.getAttribute('contenteditable') === 'true' &&\n                inputField.classList.contains('jp-llm-ext-input-field');\n            // Handle the case where the input field is NOT the active element first\n            if (isContentEditableInput) {\n                console.log(\"SHORTCUT HANDLER: Input field IS active element. Letting default behavior proceed.\");\n                // If not in our input field, prevent default, show widget, focus, insert '@', and show popup.\n                event.preventDefault();\n                event.stopPropagation();\n                showWidget();\n                focusInput();\n                // After focus, show popup via window.setTimeout to ensure input is ready\n                window.setTimeout(() => {\n                    const inputElement = document.querySelector('.jp-llm-ext-input-field');\n                    if (inputElement) {\n                        const selection = window.getSelection();\n                        if (selection) { // Check if selection exists (even if rangeCount is 0 initially)\n                            // Ensure the input field has focus *before* manipulating the range\n                            if (document.activeElement !== inputElement) {\n                                inputElement.focus(); // Re-focus just in case\n                            }\n                            // Create or get the range\n                            let range;\n                            if (selection.rangeCount > 0) {\n                                range = selection.getRangeAt(0);\n                                // Double-check if the focus is now correctly inside the input element\n                                if (!inputElement.contains(range.commonAncestorContainer)) {\n                                    console.log(\"SHORTCUT HANDLER: Range is not inside the input field after focus. Creating new range.\");\n                                    // If range is not inside, create a new one collapsed at the end\n                                    range = document.createRange();\n                                    range.selectNodeContents(inputElement);\n                                    range.collapse(false); // Collapse to the end\n                                    selection.removeAllRanges();\n                                    selection.addRange(range);\n                                }\n                            }\n                            else {\n                                // If no range exists, create one collapsed at the end\n                                console.log(\"SHORTCUT HANDLER: No range found after focus. Creating new range.\");\n                                range = document.createRange();\n                                range.selectNodeContents(inputElement);\n                                range.collapse(false); // Collapse to the end\n                                selection.removeAllRanges();\n                                selection.addRange(range);\n                            }\n                            // Manually insert '@' since we prevented default\n                            const atNode = document.createTextNode('@');\n                            range.deleteContents(); // Clear any selection just in case\n                            range.insertNode(atNode);\n                            // Move cursor after the inserted '@'\n                            range.setStartAfter(atNode);\n                            range.setEndAfter(atNode);\n                            selection.removeAllRanges(); // Update selection to the new cursor position\n                            selection.addRange(range);\n                            // **NESTED TIMEOUT:** Give browser time to render before getting range position\n                            window.setTimeout(() => {\n                                console.log(\"SHORTCUT HANDLER: Showing popup after focusing, inserting '@', and nested timeout.\");\n                                // Ensure we get the most up-to-date range reference\n                                const currentSelection = window.getSelection();\n                                if (currentSelection && currentSelection.rangeCount > 0) {\n                                    const currentRange = currentSelection.getRangeAt(0);\n                                    // --- Insert temporary span to get reliable coords --- \n                                    const tempAnchorId = 'jp-llm-shortcut-popup-anchor';\n                                    let tempSpan = document.getElementById(tempAnchorId);\n                                    if (tempSpan)\n                                        tempSpan.remove(); // Clean up previous\n                                    tempSpan = document.createElement('span');\n                                    tempSpan.id = tempAnchorId;\n                                    tempSpan.style.visibility = 'hidden';\n                                    tempSpan.style.width = '0';\n                                    tempSpan.style.overflow = 'hidden';\n                                    tempSpan.textContent = '\\u200B'; // Zero-width space\n                                    currentRange.insertNode(tempSpan); // Insert at cursor\n                                    const spanRect = tempSpan.getBoundingClientRect();\n                                    tempSpan.remove(); // Remove immediately\n                                    // --- End temporary span logic ---\n                                    if (spanRect.top === 0 && spanRect.left === 0) {\n                                        console.error(\"SHORTCUT HANDLER: Failed to get valid coordinates from temp anchor span.\");\n                                    }\n                                    else {\n                                        console.log(`SHORTCUT HANDLER: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);\n                                        popupMenuManager.showPopupMenu(spanRect.left, spanRect.top);\n                                        showIndicator('Browsing references...');\n                                    }\n                                }\n                                else {\n                                    console.error(\"SHORTCUT HANDLER: Could not get range immediately before showing popup.\");\n                                }\n                            }, 0); // 0ms delay is often sufficient\n                        }\n                        else {\n                            console.log(\"SHORTCUT HANDLER: No selection object after focus, cannot insert '@' or show popup reliably.\");\n                        }\n                    }\n                    else {\n                        console.log(\"SHORTCUT HANDLER: Could not find input element after timeout.\");\n                    }\n                }, 50); // Outer timeout remains 50ms\n            }\n            else {\n                console.log(\"SHORTCUT HANDLER: Input field is NOT active element. Handling '@' globally.\");\n                // If the input field is already focused, DO NOTHING here.\n                // The default browser behavior will insert the '@'.\n                // The 'input' event listener in UIManager will then detect the '@'\n                // and trigger the popup via handleInputForReference.\n                // We do NOT preventDefault or stopPropagation.\n            }\n        }\n        // Check for Ctrl+L (insert selection or cell)\n        else if (event.ctrlKey && event.key.toLowerCase() === 'l') {\n            event.preventDefault();\n            event.stopPropagation();\n            const selected = (0, notebook_integration_1.getSelectedText)();\n            if (selected) {\n                appendToInput(`@code ${selected}`); // Use callback\n                showIndicator('Selected code inserted');\n            }\n            else {\n                const cellContent = (0, notebook_integration_1.getCurrentCellContent)();\n                if (cellContent) {\n                    appendToInput(`@cell ${cellContent}`); // Use callback\n                    showIndicator('Cell content inserted');\n                }\n            }\n            // Ensure the sidebar is visible and input is focused\n            showWidget(); // Use callback\n            focusInput(); // Use callback\n        }\n    };\n    // Add the event listener to the document\n    document.addEventListener('keydown', _handleKeyDown);\n}\n/**\n * Removes the global keyboard shortcut listener.\n */\nfunction removeShortcuts() {\n    if (_handleKeyDown) {\n        document.removeEventListener('keydown', _handleKeyDown);\n        _handleKeyDown = null;\n        console.log('Removed keyboard shortcuts.');\n    }\n    else {\n        console.warn('Attempted to remove shortcuts, but none were active.');\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\nconst launcher_1 = require(\"@jupyterlab/launcher\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst docmanager_1 = require(\"@jupyterlab/docmanager\");\nconst sidebar_widget_1 = require(\"./sidebar-widget\");\nconst globals_1 = require(\"./core/globals\");\nconst commands_1 = require(\"./commands\");\nconst cell_context_tracker_1 = require(\"./cell-context-tracker\");\n// import { ApiClient } from './api-client';\n// Import the main CSS file\nrequire(\"../style/index.css\");\n// Export ApiClient for use by other components\nvar api_client_1 = require(\"./core/api-client\");\nObject.defineProperty(exports, \"ApiClient\", { enumerable: true, get: function () { return api_client_1.ApiClient; } });\n/**\n * Initialization data for the jupyter-simple-extension extension.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references\n        (0, globals_1.initGlobals)(jupyterApp, tracker);\n        // Initialize cell context tracker\n        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget\n        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands\n        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexports.default = plugin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSidebarWidget = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst icons_1 = require(\"./core/icons\");\nconst api_client_1 = require(\"./core/api-client\");\nconst popup_menu_manager_1 = require(\"./handlers/popup-menu-manager\");\nconst shortcut_handler_1 = require(\"./handlers/shortcut-handler\");\nconst layout_builder_1 = require(\"./ui/layout-builder\");\nconst settings_modal_1 = require(\"./ui/settings-modal\");\nconst chat_state_1 = require(\"./state/chat-state\");\nconst settings_state_1 = require(\"./state/settings-state\");\nconst input_handler_1 = require(\"./handlers/input-handler\");\nconst message_handler_1 = require(\"./handlers/message-handler\");\nconst history_handler_1 = require(\"./handlers/history-handler\");\nconst settings_handler_1 = require(\"./handlers/settings-handler\");\nconst ui_manager_1 = require(\"./ui/ui-manager\");\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\nconst globals_1 = require(\"./core/globals\");\n// --- Import Utility Functions ---\nconst clipboard_1 = require(\"./utils/clipboard\");\nconst notebook_integration_1 = require(\"./utils/notebook-integration\");\n/**\n * Main sidebar widget for the AI chat interface - Now acts as an orchestrator.\n */\nclass SimpleSidebarWidget extends widgets_1.Widget {\n    /**\n     * Helper function to replace a text range with a non-editable widget span.\n     */\n    createWidgetSpan(range, refText) {\n        if (!range)\n            return;\n        // Extract a display-friendly version (e.g., filename from path)\n        let displayLabel = refText;\n        if (refText.startsWith('@file ') || refText.startsWith('@dir ')) {\n            const parts = refText.split(' ');\n            if (parts.length > 1) {\n                const pathParts = parts[1].split(/[\\\\/]/);\n                displayLabel = pathParts[pathParts.length - 1] || parts[1]; // Use last part of path or full path\n            }\n        }\n        else if (refText.startsWith('@Cell ')) {\n            displayLabel = refText.substring(1); // Remove leading '@'\n        } // Add more conditions for other types if needed\n        // Create the widget span\n        const span = document.createElement('span');\n        span.className = 'jp-llm-ext-ref-widget'; // Class for styling\n        span.setAttribute('contenteditable', 'false'); // Make it non-editable\n        span.setAttribute('data-ref-text', refText); // Store original text for serialization\n        span.textContent = displayLabel; // Set visible text\n        // Replace the range content with the span\n        range.deleteContents();\n        range.insertNode(span);\n        // Move cursor after the inserted span\n        const selection = window.getSelection();\n        if (selection) {\n            const newRange = document.createRange();\n            newRange.setStartAfter(span);\n            newRange.setEndAfter(span);\n            selection.removeAllRanges();\n            selection.addRange(newRange);\n        }\n    }\n    constructor(docManager) {\n        super();\n        // Placeholder for handler methods used in UIManager callbacks\n        this.handleNewChat = () => {\n            var _a;\n            console.log('Handle New Chat clicked');\n            const newChat = this.chatState.createNewChat();\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);\n        };\n        this.handleToggleHistory = () => {\n            console.log('Handle Toggle History clicked');\n            this.historyHandler.toggleHistoryView();\n        };\n        this.handleSendMessage = (message) => {\n            // 1. Get the current text from the input field via UIManager or LayoutElements\n            // const text = this.layoutElements.inputField.value; // No longer needed, text is passed in\n            if (!message.trim())\n                return; // Don't send empty messages (check the passed message)\n            // 2. Get the markdown state from UIManager - REMOVED\n            // const isMarkdown = this.uiManager.getIsMarkdownMode(); \n            console.log(`[Widget] handleSendMessage: Text='${message}'`); // Debug log using passed message\n            // 3. Call the MessageHandler's send method with text and state\n            this.messageHandler.handleSendMessage(message); // Pass the received message - REMOVED isMarkdown\n            // NOTE: Input clearing is now handled by UIManager after this callback returns.\n            // Do NOT clear input here or in MessageHandler.\n        };\n        this.handleShowSettings = (event) => {\n            console.log('Handle Show Settings clicked');\n            this.settingsHandler.showModal();\n        };\n        this.handleShowPopupMenu = (event, targetButton) => {\n            console.log('Handle Show Popup Menu clicked');\n            const rect = targetButton.getBoundingClientRect();\n            this.popupMenuManager.showPopupMenu(rect.left, rect.bottom + 5);\n        };\n        this.handleUpdateTitle = () => {\n            var _a;\n            const newTitle = ((_a = this.layoutElements.titleInput) === null || _a === void 0 ? void 0 : _a.value) || 'Chat';\n            console.log('Handle Update Title called:', newTitle);\n            this.chatState.updateCurrentChatTitle(newTitle);\n        };\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = icons_1.extensionIcon;\n        this.title.closable = true;\n        this.addClass('jp-llm-ext-sidebar');\n        // --- 1. Initialize Core Components & State ---\n        this.settingsState = new settings_state_1.SettingsState();\n        const initialSettings = this.settingsState.getSettings();\n        this.apiClient = new api_client_1.ApiClient((initialSettings === null || initialSettings === void 0 ? void 0 : initialSettings.apiUrl) || undefined);\n        this.chatState = new chat_state_1.ChatState();\n        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {\n            insertCode: (code) => {\n                var _a, _b, _c;\n                if (!this.inputHandler || !globals_1.globals.notebookTracker)\n                    return;\n                const currentNotebookPanel = globals_1.globals.notebookTracker.currentWidget;\n                if (!currentNotebookPanel || !currentNotebookPanel.context || !currentNotebookPanel.content) {\n                    console.warn('Could not get notebook context for code reference, inserting raw code as fallback.');\n                    (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(code);\n                    return;\n                }\n                const notebookPath = currentNotebookPanel.context.path;\n                const notebookName = ((_b = notebookPath.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';\n                const currentCell = currentNotebookPanel.content.activeCell;\n                if (!currentCell) {\n                    console.warn('Could not get active cell for code reference, inserting raw code as fallback.');\n                    (_c = this.inputHandler) === null || _c === void 0 ? void 0 : _c.appendToInput(code);\n                    return;\n                }\n                const cellIndex = currentNotebookPanel.content.activeCellIndex;\n                let lineNumber = 1; // Default line number\n                let lineEndNumber = 1; // Default end line number\n                // --- DEBUG LOG --- \n                console.log('Are we currently in a code cell?');\n                // check if currentCell is in editor \n                console.log(currentCell.editor);\n                // --- END DEBUG LOG ---\n                if (currentCell.editor) {\n                    const editor = currentCell.editor;\n                    const cmEditor = editor.editor; // Access CodeMirror editor instance (EditorView)\n                    if (cmEditor && cmEditor.state) {\n                        const state = cmEditor.state;\n                        const selection = state.selection.main;\n                        if (!selection.empty) {\n                            lineNumber = state.doc.lineAt(selection.from).number; // 1-based start line\n                            lineEndNumber = state.doc.lineAt(selection.to).number; // 1-based end line\n                        }\n                        else {\n                            // Fallback for cursor position if no selection\n                            const cursor = editor.getCursorPosition();\n                            if (cursor) {\n                                lineNumber = cursor.line + 1; // 1-based line number\n                                lineEndNumber = lineNumber; // Start and end are the same for cursor\n                            }\n                        }\n                    }\n                    else {\n                        // Fallback if cmEditor or state is not available (should not happen often)\n                        console.warn('Could not access CodeMirror state for line numbers.');\n                        const cursor = editor.getCursorPosition();\n                        if (cursor) {\n                            lineNumber = cursor.line + 1;\n                            lineEndNumber = lineNumber;\n                        }\n                    }\n                }\n                else {\n                    console.warn('Could not access cell editor for line numbers.');\n                    // Keep default line numbers 1, 1 if editor is not available\n                }\n                // --- DEBUG LOG --- \n                console.log(`[SimpleSidebarWidget.insertCode] Determined lines: Start=${lineNumber}, End=${lineEndNumber}`);\n                // --- END DEBUG LOG ---\n                // Pass both start and end line numbers\n                const refId = this.inputHandler.addCodeReference(code, notebookName, cellIndex, lineNumber, lineEndNumber);\n                const placeholder = `@code[${refId}]`;\n                this.inputHandler.appendToInput(placeholder);\n            },\n            insertCell: (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@cell ${content}`); },\n            insertFilePath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@file[${path}]`); },\n            insertDirectoryPath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@dir[${path}]`); },\n            getSelectedText: notebook_integration_1.getSelectedText,\n            getCurrentCellContent: notebook_integration_1.getCurrentCellContent,\n            insertCellByIndex: (index) => {\n                var _a;\n                const oneBasedIndex = index + 1;\n                const refText = `@Cell[${oneBasedIndex}]`;\n                (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(refText);\n            },\n            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {\n                // Handle reference from cursor position (assume start/end line are the same)\n                if (!this.inputHandler)\n                    return;\n                const lineEndNumber = lineNumber; // Start and end are the same for a single line reference\n                const refId = this.inputHandler.addCodeReference(code, notebookName, cellIndex, lineNumber, lineEndNumber);\n                const placeholder = `@code[${refId}]`;\n                this.inputHandler.appendToInput(placeholder);\n            }\n        });\n        // --- 2. Define Callbacks (used by buildLayout and Handlers) ---\n        // Callbacks for UI actions (passed to buildLayout)\n        const createNewChatCallback = () => {\n            var _a;\n            const newChat = this.chatState.createNewChat();\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);\n        };\n        const toggleHistoryCallback = () => {\n            var _a;\n            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.toggleHistoryView();\n        };\n        const showSettingsCallback = () => {\n            var _a;\n            (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.showModal();\n        };\n        const updateTitleCallback = (newTitle) => {\n            var _a;\n            this.chatState.updateCurrentChatTitle(newTitle);\n            (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showNotification('Chat title updated', 'info');\n        };\n        const showPopupMenuCallback = (event) => {\n            const rect = event.target.getBoundingClientRect();\n            this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);\n            event.preventDefault();\n            event.stopPropagation();\n        };\n        const sendMessageViaButtonCallback = () => {\n            const inputElement = this.layoutElements.inputField;\n            const event = new KeyboardEvent('keypress', { key: 'Enter', bubbles: true });\n            inputElement.dispatchEvent(event);\n        };\n        const toggleMarkdownModeCallback = (isMarkdown) => {\n            var _a;\n            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.setMarkdownMode(isMarkdown);\n        };\n        const toggleExpandInputCallback = (button) => {\n            var _a;\n            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.toggleInputExpansion();\n        };\n        // Callbacks for Message Rendering (passed to MessageHandler -> UIManager -> renderers)\n        const messageRendererCallbacks = {\n            showCopyFeedback: (button, success = true) => {\n                const originalHTML = button.innerHTML;\n                button.innerHTML = success ? 'Copied!' : 'Failed!';\n                button.disabled = true;\n                setTimeout(() => {\n                    button.innerHTML = originalHTML;\n                    button.disabled = false;\n                }, 1000);\n            },\n            addMessageToCell: notebook_integration_1.addMessageToCell,\n            copyToClipboard: (text, feedbackCb) => {\n                navigator.clipboard.writeText(text).then(() => feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb()).catch(err => {\n                    console.error('Failed to copy text: ', err);\n                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();\n                });\n            },\n            copyImageToClipboard: (imageUrl, feedbackCb) => {\n                (0, clipboard_1.copyImageToClipboard)(imageUrl, (success) => {\n                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();\n                });\n            },\n            copyMessageToClipboard: (text, feedbackCb) => {\n                (0, clipboard_1.copyMessageToClipboard)(text, (success) => {\n                    feedbackCb();\n                });\n            },\n            handleConfirmInterrupt: () => {\n                var _a;\n                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('confirmed');\n            },\n            handleRejectInterrupt: () => {\n                var _a;\n                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('rejected');\n            }\n        };\n        const settingsModalCallbacks = {\n            handleSave: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.saveSettings(); },\n            handleCancel: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.hideModal(); }\n        };\n        const historyHandlerCallbacks = {\n            updateTitleInput: (title) => this.uiManager.updateTitleInput(title),\n            clearMessageContainer: () => this.uiManager.clearMessageContainer(),\n            addRenderedMessage: (messageElement) => this.uiManager.addChatMessageElement(messageElement)\n        };\n        const inputHandlerCallbacks = {\n            handleSendMessage: (message) => {\n                if (this.messageHandler) {\n                    this.messageHandler.handleSendMessage(message);\n                }\n                else {\n                    console.error('MessageHandler not initialized when trying to send message from InputHandler');\n                }\n            },\n            showPopupMenu: (left, top) => this.popupMenuManager.showPopupMenu(left, top),\n            hidePopupMenu: () => this.popupMenuManager.hidePopupMenu(),\n            updatePlaceholder: (isMarkdown) => {\n                // Use dataset for data-placeholder attribute\n                this.layoutElements.inputField.dataset.placeholder = isMarkdown ? 'Enter markdown...' : 'Ask anything...';\n            },\n            toggleInputExpansionUI: (isExpanded) => {\n                const button = this.layoutElements.expandButton;\n                // Clear existing content (text or old icon)\n                while (button.firstChild) {\n                    button.removeChild(button.firstChild);\n                }\n                // Add the appropriate icon using LabIcon.resolve\n                const icon = isExpanded\n                    ? ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-up' })\n                    : ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-down' });\n                icon.element({ container: button, tag: 'span' }); // Add icon to button\n                // Update title for accessibility\n                button.title = isExpanded ? 'Collapse input' : 'Expand input';\n            },\n            getCodeRefMap: () => { var _a; return ((_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.getCodeReferenceMap()) || new Map(); },\n            resetCodeRefMap: () => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.resetCodeReferences(); }\n        };\n        const shortcutCallbacks = {\n            showIndicator: (text) => { var _a; return (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showIndicator(text); },\n            appendToInput: (text) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(text); },\n            showWidget: () => { if (this.isHidden) {\n                this.show();\n            } },\n            focusInput: () => { var _a, _b; return (_b = (_a = this.layoutElements) === null || _a === void 0 ? void 0 : _a.inputField) === null || _b === void 0 ? void 0 : _b.focus(); }\n        };\n        // --- 3. Build UI Layout ---\n        this.layoutElements = (0, layout_builder_1.buildLayout)({\n            onNewChatClick: createNewChatCallback,\n            onHistoryToggleClick: toggleHistoryCallback,\n            onSettingsClick: showSettingsCallback,\n            onTitleChange: updateTitleCallback,\n            onAtButtonClick: showPopupMenuCallback,\n            onSendMessageClick: sendMessageViaButtonCallback,\n            onMarkdownToggleChange: toggleMarkdownModeCallback,\n            onExpandToggleClick: toggleExpandInputCallback,\n        });\n        this.settingsModalContainer = (0, settings_modal_1.createSettingsModalElement)(settingsModalCallbacks);\n        // --- Initialize State Managers ---\n        this.chatState = new chat_state_1.ChatState();\n        this.settingsState = new settings_state_1.SettingsState();\n        // --- Initialize Core Components ---\n        this.apiClient = new api_client_1.ApiClient();\n        // --- Initialize UI Manager (needs dependencies) ---\n        const uiManagerCallbacks = {\n            handleNewChat: this.handleNewChat,\n            handleToggleHistory: this.handleToggleHistory,\n            handleSendMessage: this.handleSendMessage,\n            handleShowSettings: this.handleShowSettings,\n            handleShowPopupMenu: this.handleShowPopupMenu,\n            handleUpdateTitle: this.handleUpdateTitle\n        };\n        this.uiManager = new ui_manager_1.UIManager(this.popupMenuManager, uiManagerCallbacks, this.layoutElements);\n        // --- 4. Initialize Handlers (using UI elements and core components) ---\n        this.inputHandler = new input_handler_1.InputHandler(this.layoutElements.inputField, inputHandlerCallbacks);\n        this.messageHandler = new message_handler_1.MessageHandler(this.apiClient, this.chatState, this.uiManager, messageRendererCallbacks, this.inputHandler);\n        this.historyHandler = new history_handler_1.HistoryHandler(this.chatState, this.uiManager, historyHandlerCallbacks, messageRendererCallbacks);\n        this.settingsHandler = new settings_handler_1.SettingsHandler(this.settingsState, this.settingsModalContainer, this.uiManager);\n        // --- 5. Final Setup (Attach event listeners, connect signals, etc.) ---\n        const initialChatId = this.chatState.getCurrentChatId();\n        if (initialChatId) {\n            this.historyHandler.loadChat(initialChatId);\n        }\n        else {\n            const newChat = this.chatState.createNewChat();\n            this.historyHandler.loadChat(newChat.id);\n        }\n        // Setup global keyboard shortcuts with the UIManager for proper @ key handling\n        (0, shortcut_handler_1.setupShortcuts)(this.inputHandler, this.popupMenuManager, shortcutCallbacks);\n        this.node.appendChild(this.layoutElements.mainElement);\n        this.node.appendChild(this.settingsModalContainer);\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        var _a, _b;\n        if (this.isDisposed) {\n            return;\n        }\n        (0, shortcut_handler_1.removeShortcuts)();\n        (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this.popupMenuManager) === null || _b === void 0 ? void 0 : _b.dispose();\n        super.dispose();\n    }\n} // End of SimpleSidebarWidget class\nexports.SimpleSidebarWidget = SimpleSidebarWidget;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatState = void 0;\nconst uuid_1 = require(\"uuid\");\n/**\n * Manages the state of chat history and the currently active chat.\n */\nclass ChatState {\n    constructor() {\n        var _a;\n        this.chatHistory = [];\n        this.currentChatId = null;\n        // Potential: Load initial state from storage if persistence is added later\n        if (this.chatHistory.length === 0) {\n            this.createNewChat('Welcome Chat'); // Create an initial chat if none exists\n        }\n        else {\n            this.currentChatId = ((_a = this.chatHistory[0]) === null || _a === void 0 ? void 0 : _a.id) || null; // Set current chat to the first one\n        }\n    }\n    /**\n     * Creates a new chat session and sets it as the current chat.\n     * @param title - The initial title for the new chat.\n     * @returns The newly created chat item.\n     */\n    createNewChat(title = 'New Chat') {\n        const chatId = `chat-${(0, uuid_1.v4)()}`; // Use UUID for better uniqueness\n        const newChat = {\n            id: chatId,\n            title: title,\n            messages: [],\n            // Optional: Add timestamp or other metadata if needed later\n            // createdAt: Date; \n        };\n        this.chatHistory.push(newChat);\n        this.currentChatId = chatId;\n        console.log('Created new chat:', newChat);\n        return newChat;\n    }\n    /**\n     * Sets the currently active chat ID.\n     * @param chatId - The ID of the chat to set as current.\n     */\n    setCurrentChatId(chatId) {\n        if (this.chatHistory.some(chat => chat.id === chatId)) {\n            this.currentChatId = chatId;\n        }\n        else {\n            console.warn(`Chat ID ${chatId} not found in history.`);\n        }\n    }\n    /**\n     * Gets the ID of the currently active chat.\n     * @returns The current chat ID or null if none is active.\n     */\n    getCurrentChatId() {\n        return this.currentChatId;\n    }\n    /**\n     * Retrieves a specific chat by its ID.\n     * @param chatId - The ID of the chat to retrieve.\n     * @returns The chat item or undefined if not found.\n     */\n    getChatById(chatId) {\n        return this.chatHistory.find(chat => chat.id === chatId);\n    }\n    /**\n     * Retrieves the currently active chat item.\n     * @returns The current chat item or undefined if no chat is active or found.\n     */\n    getCurrentChat() {\n        if (!this.currentChatId) {\n            return undefined;\n        }\n        return this.getChatById(this.currentChatId);\n    }\n    /**\n     * Updates the title of the currently active chat.\n     * @param newTitle - The new title for the chat.\n     */\n    updateCurrentChatTitle(newTitle) {\n        const currentChat = this.getCurrentChat();\n        if (currentChat) {\n            currentChat.title = newTitle;\n            console.log(`Updated title for chat ${this.currentChatId} to \"${newTitle}\"`);\n        }\n        else {\n            console.warn('Cannot update title: No current chat selected.');\n        }\n    }\n    /**\n     * Adds a message to the currently active chat.\n     * @param message - The message object to add.\n     */\n    addMessageToCurrentChat(message) {\n        const currentChat = this.getCurrentChat();\n        if (currentChat) {\n            currentChat.messages.push(message);\n        }\n        else {\n            console.warn('Cannot add message: No current chat selected.');\n        }\n    }\n    /**\n     * Gets all messages from the currently active chat.\n     * @returns An array of messages or an empty array if no chat is active.\n     */\n    getCurrentChatMessages() {\n        const currentChat = this.getCurrentChat();\n        return currentChat ? currentChat.messages : [];\n    }\n    /**\n     * Gets the entire chat history.\n     * @returns An array of all chat history items.\n     */\n    getChatHistory() {\n        return [...this.chatHistory]; // Return a copy to prevent direct modification\n    }\n}\nexports.ChatState = ChatState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsState = void 0;\nconst SETTINGS_STORAGE_KEY = 'jp-llm-ext-settings';\n/**\n * Manages loading and saving application settings to localStorage.\n */\nclass SettingsState {\n    constructor() {\n        this.currentSettings = null;\n        this.currentSettings = this.loadSettings();\n    }\n    /**\n     * Loads settings from localStorage.\n     * @returns The loaded settings or null if none are saved or an error occurs.\n     */\n    loadSettings() {\n        const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);\n        if (savedSettings) {\n            try {\n                const settings = JSON.parse(savedSettings);\n                // Basic validation (can be expanded)\n                if (settings && settings.provider) {\n                    this.currentSettings = settings;\n                    console.log('Loaded settings:', this.currentSettings);\n                    return this.currentSettings;\n                }\n            }\n            catch (error) {\n                console.error('Error loading saved settings:', error);\n                localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear corrupted data\n            }\n        }\n        console.log('No valid settings found in localStorage.');\n        return null;\n    }\n    /**\n     * Saves the provided settings to localStorage.\n     * @param settings - The settings object to save.\n     */\n    saveSettings(settings) {\n        try {\n            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));\n            this.currentSettings = Object.assign({}, settings); // Update internal state\n            console.log('Settings saved:', this.currentSettings);\n        }\n        catch (error) {\n            console.error('Error saving settings:', error);\n            // Optional: Notify user of save failure\n        }\n    }\n    /**\n     * Gets the currently loaded settings.\n     * @returns The current settings object or null if not loaded.\n     */\n    getSettings() {\n        return this.currentSettings ? Object.assign({}, this.currentSettings) : null; // Return a copy\n    }\n    /**\n     * Gets a specific setting value.\n     * @param key - The key of the setting to retrieve.\n     * @returns The value of the setting or undefined if not found.\n     */\n    getSetting(key) {\n        return this.currentSettings ? this.currentSettings[key] : undefined;\n    }\n}\nexports.SettingsState = SettingsState;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDiv = createDiv;\nexports.createButton = createButton;\nexports.createSpan = createSpan;\nexports.createTextArea = createTextArea;\nexports.createInputElement = createInputElement;\nexports.createImageElement = createImageElement;\nexports.createAnchorElement = createAnchorElement;\nexports.createLabelElement = createLabelElement;\nexports.createFormElement = createFormElement;\n/**\n * Generic function to create an HTMLElement.\n *\n * @param tagName - The HTML tag name (e.g., 'div', 'button').\n * @param options - Optional configuration for the element.\n * @returns The created HTMLElement.\n */\nfunction createElement(tagName, options = {}) {\n    const element = document.createElement(tagName);\n    if (options.id) {\n        element.id = options.id;\n    }\n    if (options.classes) {\n        const classesToAdd = Array.isArray(options.classes)\n            ? options.classes\n            : options.classes.split(' ').filter(c => c);\n        element.classList.add(...classesToAdd);\n    }\n    if (options.text) {\n        element.textContent = options.text;\n    }\n    else if (options.html) {\n        element.innerHTML = options.html; // Be cautious with HTML injection\n    }\n    if (options.attributes) {\n        for (const key in options.attributes) {\n            if (options.attributes.hasOwnProperty(key)) {\n                element.setAttribute(key, options.attributes[key]);\n            }\n        }\n    }\n    if (options.style) {\n        for (const key in options.style) {\n            if (options.style.hasOwnProperty(key)) {\n                element.style[key] = options.style[key];\n            }\n        }\n    }\n    if (options.children) {\n        options.children.forEach(child => {\n            if (typeof child === 'string') {\n                element.appendChild(document.createTextNode(child));\n            }\n            else {\n                element.appendChild(child);\n            }\n        });\n    }\n    return element;\n}\n/** Creates a <div> element. */\nfunction createDiv(options = {}) {\n    return createElement('div', options);\n}\n/** Creates a <button> element. */\nfunction createButton(options = {}) {\n    return createElement('button', options);\n}\n/** Creates a <span> element. */\nfunction createSpan(options = {}) {\n    return createElement('span', options);\n}\n/** Creates a <textarea> element. */\nfunction createTextArea(options = {}) {\n    return createElement('textarea', options);\n}\n/** Creates an <input> element. */\nfunction createInputElement(options = {}) {\n    var _a;\n    // Ensure type is set if provided in attributes, otherwise default or leave unset\n    if ((_a = options.attributes) === null || _a === void 0 ? void 0 : _a.type) {\n        // Type is already set in attributes, do nothing extra\n    }\n    else if (!options.attributes) {\n        options.attributes = { type: 'text' }; // Default to text if no attributes specified\n    }\n    else if (!options.attributes.type) {\n        options.attributes.type = 'text'; // Default to text if type is not in attributes\n    }\n    return createElement('input', options);\n}\n/** Creates an <img> element. */\nfunction createImageElement(options) {\n    const imgOptions = Object.assign({}, options);\n    imgOptions.attributes = Object.assign(Object.assign({}, options.attributes), { src: options.src });\n    if (options.alt) {\n        imgOptions.attributes.alt = options.alt;\n    }\n    return createElement('img', imgOptions);\n}\n/** Creates an <a> element. */\nfunction createAnchorElement(options) {\n    const anchorOptions = Object.assign({}, options);\n    anchorOptions.attributes = Object.assign(Object.assign({}, options.attributes), { href: options.href });\n    return createElement('a', anchorOptions);\n}\n/** Creates a <label> element. */\nfunction createLabelElement(options) {\n    const labelOptions = Object.assign({}, options);\n    if (options.htmlFor) {\n        labelOptions.attributes = Object.assign(Object.assign({}, options.attributes), { for: options.htmlFor });\n    }\n    return createElement('label', labelOptions);\n}\n/** Creates a <form> element. */\nfunction createFormElement(options = {}) {\n    return createElement('form', options);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildLayout = buildLayout;\nconst dom_elements_1 = require(\"./dom-elements\");\n/**\n * Builds the main HTML structure for the sidebar widget.\n *\n * @param callbacks - An object containing callback functions for various UI interactions.\n * @returns An object containing the main widget HTMLElement and references to key interactive elements.\n */\nfunction buildLayout(callbacks = {}) {\n    // --- Main Content Wrapper ---\n    const mainElement = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-content-wrapper'\n    });\n    // --- Title Bar ---\n    const titleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-title-container' });\n    const titleInput = (0, dom_elements_1.createInputElement)({\n        id: 'chat-title-input',\n        classes: 'chat-title-input',\n        attributes: { type: 'text', placeholder: 'Chat title', value: 'New Chat' }\n    });\n    if (callbacks.onTitleChange) {\n        titleInput.addEventListener('change', () => callbacks.onTitleChange(titleInput.value));\n    }\n    titleContainer.appendChild(titleInput);\n    // --- Message & History Containers ---\n    const messageContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-message-container' });\n    const historyContainer = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-history-container',\n        style: { display: 'none' } // Hidden by default\n    });\n    // --- Bottom Bar Area ---\n    const bottomBarContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-container' });\n    // Row 1: Controls (Markdown Toggle, @, Expand, Settings)\n    const controlsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row' });\n    const controlsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-controls-container' });\n    // Markdown Toggle\n    const toggleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-toggle-container' });\n    const markdownToggleButton = (0, dom_elements_1.createInputElement)({\n        id: 'markdown-toggle',\n        attributes: { type: 'checkbox' }\n    });\n    const toggleLabel = (0, dom_elements_1.createLabelElement)({\n        text: 'Markdown mode',\n        htmlFor: 'markdown-toggle'\n    });\n    if (callbacks.onMarkdownToggleChange) {\n        markdownToggleButton.addEventListener('change', () => {\n            callbacks.onMarkdownToggleChange(markdownToggleButton.checked);\n        });\n    }\n    toggleContainer.appendChild(markdownToggleButton);\n    toggleContainer.appendChild(toggleLabel);\n    // Action Buttons (@, Expand, Settings)\n    const actionButtonsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-action-buttons-container' });\n    const atButton = (0, dom_elements_1.createButton)({ text: '@', attributes: { title: 'Browse cells, code, files, and more' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onAtButtonClick) {\n        atButton.addEventListener('click', callbacks.onAtButtonClick);\n    }\n    const expandButton = (0, dom_elements_1.createButton)({ text: '', attributes: { title: 'Expand input' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onExpandToggleClick) {\n        expandButton.addEventListener('click', () => callbacks.onExpandToggleClick(expandButton));\n    }\n    const settingsButton = (0, dom_elements_1.createButton)({ text: '', attributes: { title: 'Settings' }, classes: 'jp-Button jp-llm-ext-action-button' });\n    if (callbacks.onSettingsClick) {\n        settingsButton.addEventListener('click', callbacks.onSettingsClick);\n    }\n    actionButtonsContainer.appendChild(atButton);\n    actionButtonsContainer.appendChild(expandButton);\n    actionButtonsContainer.appendChild(settingsButton);\n    controlsContainer.appendChild(toggleContainer);\n    controlsContainer.appendChild(actionButtonsContainer);\n    controlsRow.appendChild(controlsContainer);\n    // Row 2: Input Field\n    const inputRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row' });\n    const inputField = (0, dom_elements_1.createDiv)({\n        classes: 'jp-llm-ext-input-field',\n        attributes: {\n            contenteditable: 'true',\n            role: 'textbox',\n            'aria-multiline': 'true',\n            'data-placeholder': 'Ask me anything...'\n        },\n        style: { minHeight: '20px', overflowY: 'hidden' }\n    });\n    if (callbacks.onInputFieldKeyPress) {\n        inputField.addEventListener('keypress', callbacks.onInputFieldKeyPress);\n    }\n    if (callbacks.onInputFieldValueChange) {\n        inputField.addEventListener('input', () => callbacks.onInputFieldValueChange(inputField.textContent || ''));\n    }\n    inputRow.appendChild(inputField);\n    // Row 3: Main Buttons (Send, New Chat, History)\n    const buttonsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row' });\n    const sendButton = (0, dom_elements_1.createButton)({\n        text: 'Send',\n        classes: 'jp-Button jp-llm-ext-send-button'\n    });\n    if (callbacks.onSendMessageClick) {\n        sendButton.addEventListener('click', callbacks.onSendMessageClick);\n    }\n    const newChatButton = (0, dom_elements_1.createButton)({\n        text: '+ New Chat',\n        attributes: { title: 'Start a new chat' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onNewChatClick) {\n        newChatButton.addEventListener('click', callbacks.onNewChatClick);\n    }\n    const historyButton = (0, dom_elements_1.createButton)({\n        text: 'History',\n        attributes: { title: 'View chat history' },\n        classes: 'jp-Button jp-llm-ext-action-button'\n    });\n    if (callbacks.onHistoryToggleClick) {\n        historyButton.addEventListener('click', callbacks.onHistoryToggleClick);\n    }\n    buttonsRow.appendChild(sendButton);\n    buttonsRow.appendChild(newChatButton);\n    buttonsRow.appendChild(historyButton);\n    // Assemble Bottom Bar\n    bottomBarContainer.appendChild(controlsRow);\n    bottomBarContainer.appendChild(inputRow);\n    bottomBarContainer.appendChild(buttonsRow);\n    // --- Assemble Main Element ---\n    mainElement.appendChild(titleContainer);\n    mainElement.appendChild(messageContainer);\n    mainElement.appendChild(historyContainer);\n    mainElement.appendChild(bottomBarContainer);\n    return {\n        mainElement,\n        titleInput,\n        messageContainer,\n        historyContainer,\n        inputField,\n        bottomBarContainer,\n        sendButton,\n        newChatButton,\n        historyButton,\n        markdownToggleButton,\n        expandButton,\n        atButton,\n        settingsButton\n    };\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageRenderer = void 0;\nexports.renderUserMessage = renderUserMessage;\nexports.renderBotMessage = renderBotMessage;\nexports.renderBotMessageStreamingStart = renderBotMessageStreamingStart;\nexports.renderBotMessageStreamingUpdate = renderBotMessageStreamingUpdate;\nexports.renderBotMessageFinal = renderBotMessageFinal;\nconst marked_1 = require(\"marked\");\nconst dompurify_1 = __importDefault(require(\"dompurify\"));\n// import hljs from 'highlight.js'; // Removed unused import\nconst dom_elements_1 = require(\"./dom-elements\");\nconst globals_1 = require(\"../core/globals\"); // Import globals\n// Removed unused import block for clipboard utils (used via callbacks)\n// import { copyToClipboard, copyImageToClipboard, copyMessageToClipboard } from '../utils/clipboard';\n// Removed unused import (used via callbacks)\n// import { addMessageToCell } from '../utils/notebook-integration';\nconst highlighting_1 = require(\"../utils/highlighting\");\nconst markdown_config_1 = require(\"../utils/markdown-config\");\n/**\n * Base function to create a message container div.\n */\nfunction createMessageDiv(sender) {\n    const messageDiv = document.createElement('div');\n    messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';\n    return messageDiv;\n}\n/**\n * Renders a user message.\n */\nfunction renderUserMessage(text, options = {}, callbacks = {}) {\n    const messageDiv = createMessageDiv('user');\n    if (options.isMarkdown) {\n        // TODO: Integrate Code Reference rendering properly here\n        // For now, render the whole body as Markdown\n        const contentDiv = document.createElement('div');\n        // Use 'markdown-content' class for consistent styling\n        contentDiv.className = 'markdown-content';\n        try {\n            // Preprocess, parse, and sanitize like in bot messages\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // Enhance code blocks if user messages can contain them\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                // Pass only relevant callbacks if needed for user code blocks\n                enhanceCodeBlock(block, {\n                // e.g., showCopyFeedback: callbacks.showCopyFeedback \n                });\n            });\n        }\n        catch (error) {\n            console.error('Failed to render user markdown:', error);\n            // Fallback to plain text if Markdown rendering fails\n            contentDiv.textContent = text;\n        }\n        messageDiv.appendChild(contentDiv);\n    }\n    else {\n        // Non-Markdown user message (plain text)\n        // Replace simple textContent assignment with ref-aware rendering\n        // messageDiv.textContent = text;\n        renderMessageContentWithRefs(messageDiv, text, callbacks);\n    }\n    // TODO: Add user message specific actions if needed (e.g., copy text)\n    return messageDiv;\n}\n/**\n * NEW: Renders message content, replacing @references with widgets.\n */\nfunction renderMessageContentWithRefs(container, text, callbacks) {\n    // --- DEBUG LOG --- \n    console.log('[renderMessageContentWithRefs] Processing text:', JSON.stringify(text)); // Log exact text\n    // --- END DEBUG LOG ---\n    // Regex to find @file, @dir, @Cell, @code references (with optional surrounding whitespace)\n    const refRegex = /\\s*(@(file|dir|Cell|code)\\[([^\\]]+?)\\])\\s*/g;\n    let lastIndex = 0;\n    let match;\n    // Reset regex state just in case\n    refRegex.lastIndex = 0;\n    while ((match = refRegex.exec(text)) !== null) {\n        // Append text before the match\n        if (match.index > lastIndex) {\n            container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));\n        }\n        // Process the matched reference\n        const fullMatchWithWhitespace = match[0]; // Includes potential whitespace\n        const fullMatch = match[1]; // The actual @type[value] part\n        const type = match[2];\n        const value = match[3];\n        try {\n            const widget = createRefWidget(type, value, fullMatch, callbacks); // Pass the clean match\n            container.appendChild(widget);\n        }\n        catch (error) {\n            console.error(`Failed to create widget for reference: ${fullMatch}`, error);\n            // Fallback: append the original reference text (with potential whitespace)\n            container.appendChild(document.createTextNode(fullMatchWithWhitespace));\n        }\n        lastIndex = refRegex.lastIndex;\n    }\n    // Append any remaining text after the last match\n    if (lastIndex < text.length) {\n        container.appendChild(document.createTextNode(text.substring(lastIndex)));\n    }\n}\n/**\n * NEW: Creates a reference widget span.\n */\nfunction createRefWidget(type, value, originalRefText, // The full @type[value] string\ncallbacks) {\n    const widget = document.createElement('span');\n    widget.className = `jp-llm-ext-ref-widget ref-${type.toLowerCase()}`;\n    widget.setAttribute('contenteditable', 'false');\n    widget.dataset.refText = originalRefText; // Store the original reference\n    let displayText = '';\n    let titleText = originalRefText; // Default tooltip\n    switch (type) {\n        case 'file':\n            displayText = value.split(/[\\\\/]/).pop() || value; // Extract filename\n            titleText = `File: ${value}`;\n            break;\n        case 'dir':\n            displayText = value.split(/[\\\\/]/).pop() || value || '/'; // Extract dirname, handle root\n            titleText = `Directory: ${value}`;\n            break;\n        case 'Cell': {\n            const cellIndex = parseInt(value) - 1; // Convert back to 0-based index\n            const notebookContext = callbacks.getCurrentNotebookContext ? callbacks.getCurrentNotebookContext() : undefined;\n            // --- DEBUG LOG --- \n            console.log(`[createRefWidget @Cell] Input Value: ${value}, Parsed Index: ${cellIndex}, Notebook Context:`, notebookContext);\n            // --- END DEBUG LOG --- \n            const notebookName = (notebookContext === null || notebookContext === void 0 ? void 0 : notebookContext.name) || 'notebook';\n            let cellTypeChar = '?';\n            if (notebookContext && globals_1.globals.notebookTracker) {\n                const currentNotebookPanel = globals_1.globals.notebookTracker.find(widget => widget.context.path === notebookContext.path);\n                if (currentNotebookPanel && currentNotebookPanel.model) {\n                    const cellModel = currentNotebookPanel.model.cells.get(cellIndex);\n                    if (cellModel) {\n                        cellTypeChar = cellModel.type === 'markdown' ? 'M' : 'C';\n                    }\n                }\n            }\n            displayText = `${notebookName}-${cellTypeChar}-${value}`; // value is 1-based index\n            titleText = `Cell ${value} (${cellTypeChar === 'M' ? 'Markdown' : 'Code'}) in ${notebookName}`;\n            break;\n        }\n        case 'code': {\n            const refId = value;\n            const refData = callbacks.getCodeRefData ? callbacks.getCodeRefData(refId) : undefined;\n            // --- DEBUG LOG --- \n            console.log(`[createRefWidget @code] Input Value (refId): ${refId}, Ref Data Found:`, refData);\n            // --- END DEBUG LOG --- \n            if (refData) {\n                // Construct display text using start and end lines\n                const startLine = refData.lineNumber;\n                const endLine = refData.lineEndNumber;\n                const linePart = startLine === endLine ? `${startLine}` : `${startLine}_${endLine}`;\n                displayText = `${refData.notebookName}-${refData.cellIndex + 1}-${linePart}`;\n                // Update title text as well\n                const titleLinePart = startLine === endLine ? `Line ${startLine}` : `Lines ${startLine}-${endLine}`;\n                titleText = `Code Reference: ${refData.notebookName}, Cell ${refData.cellIndex + 1}, ${titleLinePart}`;\n            }\n            else {\n                displayText = `code-ref-${refId}`; // Fallback display\n                titleText = `Code Reference ID: ${refId} (Data not found)`;\n            }\n            break;\n        }\n    }\n    widget.textContent = displayText;\n    widget.title = titleText; // Add tooltip\n    return widget;\n}\n/**\n * NEW: Recursively finds and replaces @references within text nodes of an element.\n */\nfunction renderRefsInElement(element, callbacks) {\n    // Use the same updated regex here\n    const refRegex = /\\s*(@(file|dir|Cell|code)\\[([^\\]]+?)\\])\\s*/g;\n    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);\n    let node;\n    const nodesToProcess = [];\n    while ((node = walker.nextNode())) {\n        if (node instanceof Text &&\n            node.textContent &&\n            !(node.parentElement && node.parentElement.closest('.jp-llm-ext-ref-widget'))) {\n            // Test with the specific regex before adding\n            refRegex.lastIndex = 0; // Reset before test\n            if (refRegex.test(node.textContent)) {\n                nodesToProcess.push(node);\n            }\n        }\n    }\n    // Now, process the collected text nodes\n    nodesToProcess.forEach(textNode => {\n        const parent = textNode.parentNode;\n        if (!parent)\n            return;\n        const text = textNode.textContent || '';\n        const fragment = document.createDocumentFragment();\n        let lastIndex = 0;\n        let match;\n        refRegex.lastIndex = 0; // Reset regex state for each node\n        while ((match = refRegex.exec(text)) !== null) {\n            // Append text before the match\n            if (match.index > lastIndex) {\n                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));\n            }\n            // Process the matched reference\n            const fullMatchWithWhitespace = match[0];\n            const fullMatch = match[1];\n            const type = match[2];\n            const value = match[3];\n            try {\n                const widget = createRefWidget(type, value, fullMatch, callbacks);\n                fragment.appendChild(widget);\n            }\n            catch (error) {\n                console.error(`Failed to create widget for reference: ${fullMatch}`, error);\n                fragment.appendChild(document.createTextNode(fullMatchWithWhitespace)); // Fallback\n            }\n            lastIndex = refRegex.lastIndex;\n        }\n        // Append any remaining text after the last match\n        if (lastIndex < text.length) {\n            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));\n        }\n        // Replace the original text node with the fragment\n        parent.replaceChild(fragment, textNode);\n    });\n}\n/**\n * Renders a bot message (text, markdown, images, code blocks).\n */\nfunction renderBotMessage(text, options = { isMarkdown: true }, callbacks = {}) {\n    const messageDiv = createMessageDiv('bot');\n    // Check if the message is an image URL\n    const isImageUrl = text.trim().startsWith('/images/') &&\n        (text.trim().endsWith('.png') ||\n            text.trim().endsWith('.jpg') ||\n            text.trim().endsWith('.jpeg') ||\n            text.trim().endsWith('.gif'));\n    if (isImageUrl) {\n        // Construct full URL (TODO: Make base URL configurable)\n        const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;\n        // Call dedicated image rendering function\n        renderImageMessage(messageDiv, fullImageUrl, callbacks);\n    }\n    else if (options.isMarkdown) {\n        // Render as markdown (logic from addMessage)\n        const markdownIndicator = document.createElement('div');\n        markdownIndicator.textContent = \"MD\";\n        markdownIndicator.className = 'markdown-indicator';\n        messageDiv.appendChild(markdownIndicator);\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'markdown-content';\n        try {\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // --- NEW: Render references within the sanitized HTML --- \n            renderRefsInElement(contentDiv, callbacks);\n            // --- End NEW ---\n            // Enhance code blocks after setting innerHTML and rendering refs\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                enhanceCodeBlock(block, callbacks);\n            });\n            // Check for and render interrupt buttons\n            const isInterrupt = text.startsWith('**[INTERRUPT]**');\n            if (isInterrupt) {\n                renderInterruptButtons(contentDiv, callbacks);\n            }\n        }\n        catch (error) {\n            contentDiv.textContent = text; // Fallback to plain text\n            console.error('Failed to render markdown:', error);\n        }\n        messageDiv.appendChild(contentDiv);\n        // Add overall message action buttons AFTER content is added\n        addBotMessageActions(messageDiv, text, callbacks);\n    }\n    else {\n        // Render as plain text\n        messageDiv.textContent = text;\n        // Add overall message action buttons even for plain text bot messages\n        addBotMessageActions(messageDiv, text, callbacks);\n    }\n    return messageDiv;\n}\n// Define createMessageWrapper based on createMessageDiv\nfunction createMessageWrapper(sender) {\n    return createMessageDiv(sender);\n}\n// --- More specific rendering functions or helpers can be added below ---\n/**\n * Renders an image message with action buttons inside a container.\n *\n * @param container The parent HTML element to append the image message to.\n * @param imageUrl The full URL of the image to render.\n * @param callbacks Callbacks for actions like copy image, add path.\n */\nfunction renderImageMessage(container, imageUrl, callbacks = {}) {\n    // Create a container for the image that allows positioning the buttons\n    const imageContainer = document.createElement('div');\n    imageContainer.className = 'jp-llm-ext-image-container';\n    imageContainer.style.position = 'relative';\n    // Render as an image tag\n    const img = document.createElement('img');\n    img.src = imageUrl;\n    img.alt = 'Image from bot';\n    img.style.maxWidth = '100%'; // Ensure image fits within the container\n    img.style.height = 'auto';\n    imageContainer.appendChild(img);\n    // Add action buttons for the image\n    const imgActionsDiv = document.createElement('div');\n    imgActionsDiv.className = 'jp-llm-ext-image-actions';\n    imgActionsDiv.style.position = 'absolute';\n    imgActionsDiv.style.bottom = '10px';\n    imgActionsDiv.style.right = '10px';\n    imgActionsDiv.style.display = 'flex';\n    imgActionsDiv.style.gap = '8px';\n    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)'; // Added slight background for visibility\n    imgActionsDiv.style.borderRadius = '4px';\n    imgActionsDiv.style.padding = '4px';\n    // Copy image button (using callback)\n    if (callbacks.copyImageToClipboard && callbacks.showCopyFeedback) {\n        const copyImgBtn = document.createElement('button');\n        copyImgBtn.className = 'jp-llm-ext-image-action-button';\n        copyImgBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyImgBtn.title = 'Copy image to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyImgBtn);\n        copyImgBtn.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyImageToClipboard(imageUrl, feedbackCb);\n        });\n        imgActionsDiv.appendChild(copyImgBtn);\n    }\n    // Add file path button (using callback)\n    if (callbacks.addMessageToCell) {\n        const addPathBtn = document.createElement('button');\n        addPathBtn.className = 'jp-llm-ext-image-action-button';\n        addPathBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addPathBtn.title = 'Add image path to current cell';\n        addPathBtn.addEventListener('click', (event) => {\n            event.stopPropagation();\n            // Pass the image URL (which is the message text in this case)\n            callbacks.addMessageToCell(imageUrl);\n        });\n        imgActionsDiv.appendChild(addPathBtn);\n    }\n    // Only add the actions div if it has buttons\n    if (imgActionsDiv.hasChildNodes()) {\n        imageContainer.appendChild(imgActionsDiv);\n    }\n    // Add the image container to the main message div\n    container.appendChild(imageContainer);\n}\n/**\n * Creates the initial structure for a bot message that will receive streaming content.\n *\n * @returns Object containing the wrapper, streaming div, and final content div.\n */\nfunction renderBotMessageStreamingStart() {\n    const wrapper = createMessageWrapper('bot');\n    const markdownIndicator = (0, dom_elements_1.createDiv)({\n        text: 'MD',\n        classes: 'markdown-indicator'\n    });\n    wrapper.appendChild(markdownIndicator);\n    const streamingDiv = (0, dom_elements_1.createDiv)({\n        classes: 'streaming-content',\n        style: {\n            whiteSpace: 'pre-wrap',\n            fontFamily: 'monospace',\n            fontSize: '0.9em'\n        }\n    });\n    wrapper.appendChild(streamingDiv);\n    const contentDiv = (0, dom_elements_1.createDiv)({\n        classes: 'markdown-content',\n        style: { display: 'none' } // Initially hidden\n    });\n    wrapper.appendChild(contentDiv);\n    return { wrapper, streamingDiv, contentDiv };\n}\n/**\n * Updates the streaming div with a new chunk of text.\n *\n * @param streamingDiv - The div displaying streaming content.\n * @param chunk - The new text chunk to append.\n */\nfunction renderBotMessageStreamingUpdate(streamingDiv, chunk) {\n    // Simple append, might need refinement for complex streams\n    streamingDiv.textContent += chunk;\n}\n/**\n * Renders the final content of a bot message after streaming is complete.\n * Handles markdown, images, code blocks, and interrupts.\n *\n * @param contentDiv - The div where the final content should be rendered.\n * @param streamingDiv - The div that was used for streaming (will be hidden).\n * @param completeResponse - The full text content from the bot.\n * @param options - Rendering options including callbacks for actions.\n * @returns The populated contentDiv.\n */\nfunction renderBotMessageFinal(contentDiv, streamingDiv, completeResponse, options = {}, callbacks = {}) {\n    // Hide streaming div, show final content div\n    streamingDiv.style.display = 'none';\n    contentDiv.style.display = 'block';\n    // Consolidate callbacks access\n    const effectiveCallbacks = Object.assign(Object.assign({}, options), callbacks);\n    // --- Image Handling ---\n    const isImageUrl = completeResponse.trim().startsWith('/images/') &&\n        (completeResponse.trim().endsWith('.png') ||\n            completeResponse.trim().endsWith('.jpg') ||\n            completeResponse.trim().endsWith('.jpeg') ||\n            completeResponse.trim().endsWith('.gif'));\n    if (isImageUrl) {\n        const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // TODO: Make base URL configurable\n        renderImageMessage(contentDiv, fullImageUrl, effectiveCallbacks);\n    }\n    else {\n        // --- Markdown & Code Block Handling ---\n        try {\n            const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);\n            const rawHtml = marked_1.marked.parse(processedText);\n            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n            contentDiv.innerHTML = sanitizedHtml;\n            // --- NEW: Render references within the sanitized HTML --- \n            renderRefsInElement(contentDiv, effectiveCallbacks);\n            // --- End NEW ---\n            // --- Interrupt Handling ---\n            const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');\n            if (isInterrupt) {\n                renderInterruptButtons(contentDiv, effectiveCallbacks);\n            }\n            // --- Code Block Enhancements ---\n            const codeBlocks = contentDiv.querySelectorAll('pre code');\n            codeBlocks.forEach(block => {\n                enhanceCodeBlock(block, effectiveCallbacks);\n            });\n        }\n        catch (error) {\n            console.error('Error rendering markdown:', error);\n            contentDiv.textContent = completeResponse; // Fallback to plain text\n        }\n    }\n    return contentDiv;\n}\n/**\n * Enhances a code block element with highlighting and action buttons.\n *\n * @param codeBlockElement The <code> element within a <pre>.\n * @param callbacks Callbacks for actions like copy code, add to cell.\n */\nfunction enhanceCodeBlock(codeBlockElement, callbacks = {}) {\n    var _a;\n    const preElement = codeBlockElement.parentElement;\n    if (!preElement || preElement.tagName !== 'PRE') {\n        console.warn('Code block enhancement called on element not within a <pre> tag.');\n        return;\n    }\n    // Add standard JupyterLab classes for consistency\n    codeBlockElement.classList.add('jp-RenderedText');\n    preElement.classList.add('jp-RenderedHTMLCommon');\n    // Get code content\n    const codeContent = codeBlockElement.textContent || '';\n    // Create code block header for buttons and language indicator\n    const codeHeader = document.createElement('div');\n    codeHeader.className = 'jp-llm-ext-code-header';\n    // Add language indicator if detected\n    const language = (0, highlighting_1.detectLanguage)(codeContent); // Use imported util\n    if (language) {\n        const langIndicator = document.createElement('span');\n        langIndicator.className = 'jp-llm-ext-code-language';\n        langIndicator.textContent = language;\n        codeHeader.appendChild(langIndicator);\n        codeBlockElement.classList.add(`language-${language}`);\n    }\n    // Apply syntax highlighting\n    try {\n        // Use imported util (handles auto-detection if language is empty)\n        codeBlockElement.innerHTML = (0, highlighting_1.highlightCode)(codeContent, language);\n    }\n    catch (error) {\n        console.error('Error applying syntax highlighting:', error);\n        // codeBlockElement might contain original text or partially highlighted\n    }\n    // Add action buttons to the code header\n    const actionsDiv = document.createElement('div');\n    actionsDiv.className = 'jp-llm-ext-code-actions';\n    // Copy button\n    if (callbacks.copyToClipboard && callbacks.showCopyFeedback) {\n        const copyButton = document.createElement('button');\n        copyButton.className = 'jp-llm-ext-code-action-button';\n        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyButton.title = 'Copy code to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);\n        copyButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyToClipboard(codeContent, feedbackCb);\n        });\n        actionsDiv.appendChild(copyButton);\n    }\n    // Add to cell button\n    if (callbacks.addMessageToCell) {\n        const addToButton = document.createElement('button');\n        addToButton.className = 'jp-llm-ext-code-action-button';\n        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addToButton.title = 'Add code to current cell';\n        addToButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.addMessageToCell(codeContent);\n        });\n        actionsDiv.appendChild(addToButton);\n    }\n    // Add the actions to the header, and insert header before the <pre>\n    if (actionsDiv.hasChildNodes()) {\n        codeHeader.appendChild(actionsDiv);\n    }\n    if (codeHeader.hasChildNodes()) {\n        (_a = preElement.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(codeHeader, preElement);\n    }\n}\n/**\n * Renders Confirm/Reject buttons for an interrupt message.\n *\n * @param container The parent HTML element (message content div) to append buttons to.\n * @param callbacks Callbacks for confirm and reject actions.\n */\nfunction renderInterruptButtons(container, callbacks = {}) {\n    if (!callbacks.handleConfirmInterrupt || !callbacks.handleRejectInterrupt) {\n        console.warn('Interrupt message needs confirm/reject callbacks.');\n        return;\n    }\n    const buttonsContainer = document.createElement('div');\n    buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';\n    buttonsContainer.style.marginTop = '12px';\n    buttonsContainer.style.display = 'flex';\n    buttonsContainer.style.gap = '8px';\n    // Create confirm button\n    const confirmButton = document.createElement('button');\n    confirmButton.className = 'jp-llm-ext-confirm-button';\n    confirmButton.textContent = 'Confirm';\n    // Apply specific styling (can be moved to CSS)\n    confirmButton.style.padding = '6px 12px';\n    confirmButton.style.background = '#4CAF50';\n    confirmButton.style.color = 'white';\n    confirmButton.style.border = 'none';\n    confirmButton.style.borderRadius = '4px';\n    confirmButton.style.cursor = 'pointer';\n    confirmButton.style.fontWeight = 'bold';\n    // Create reject button\n    const rejectButton = document.createElement('button');\n    rejectButton.className = 'jp-llm-ext-reject-button';\n    rejectButton.textContent = 'Reject';\n    // Apply specific styling (can be moved to CSS)\n    rejectButton.style.padding = '6px 12px';\n    rejectButton.style.background = '#F44336';\n    rejectButton.style.color = 'white';\n    rejectButton.style.border = 'none';\n    rejectButton.style.borderRadius = '4px';\n    rejectButton.style.cursor = 'pointer';\n    rejectButton.style.fontWeight = 'bold';\n    // Add event listeners\n    confirmButton.addEventListener('click', () => {\n        confirmButton.disabled = true;\n        rejectButton.disabled = true;\n        confirmButton.style.opacity = '0.5';\n        rejectButton.style.opacity = '0.5';\n        callbacks.handleConfirmInterrupt();\n    });\n    rejectButton.addEventListener('click', () => {\n        confirmButton.disabled = true;\n        rejectButton.disabled = true;\n        confirmButton.style.opacity = '0.5';\n        rejectButton.style.opacity = '0.5';\n        callbacks.handleRejectInterrupt();\n    });\n    // Add buttons to container and container to message\n    buttonsContainer.appendChild(confirmButton);\n    buttonsContainer.appendChild(rejectButton);\n    container.appendChild(buttonsContainer);\n}\n/**\n * Adds overall action buttons (Copy, Add to Cell) to a bot message container.\n *\n * @param messageDiv The main div container for the bot message.\n * @param messageText The raw text content of the message.\n * @param callbacks Callbacks for actions like copy message, add to cell.\n */\nfunction addBotMessageActions(messageDiv, messageText, callbacks = {}) {\n    // Only add actions if corresponding callbacks are provided\n    if (!callbacks.copyMessageToClipboard && !callbacks.addMessageToCell) {\n        return;\n    }\n    console.log('Adding action buttons to bot message'); // Keep debug log for now\n    const actionsDiv = document.createElement('div');\n    actionsDiv.className = 'jp-llm-ext-message-actions';\n    // actionsDiv.style.display = 'flex'; // Ensure display via CSS if needed\n    // Copy Message button\n    if (callbacks.copyMessageToClipboard && callbacks.showCopyFeedback) {\n        const copyButton = document.createElement('button');\n        copyButton.className = 'jp-llm-ext-message-action-button';\n        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n        copyButton.title = 'Copy message to clipboard';\n        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);\n        copyButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.copyMessageToClipboard(messageText, feedbackCb);\n        });\n        actionsDiv.appendChild(copyButton);\n    }\n    // Add to Cell button\n    if (callbacks.addMessageToCell) {\n        const addToButton = document.createElement('button');\n        addToButton.className = 'jp-llm-ext-message-action-button';\n        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n        addToButton.title = 'Add message to current cell';\n        addToButton.addEventListener('click', (event) => {\n            event.stopPropagation();\n            callbacks.addMessageToCell(messageText);\n        });\n        actionsDiv.appendChild(addToButton);\n    }\n    // Append the actions container if it has any buttons\n    if (actionsDiv.hasChildNodes()) {\n        messageDiv.appendChild(actionsDiv);\n        console.log('Action buttons added to bot message:', actionsDiv); // Keep debug log\n    }\n}\n// Potential future additions:\n// - renderErrorMessage\n// - renderSystemMessage\n// - A main renderMessage function that delegates based on type? \n/**\n * Handles rendering individual messages (user, bot, system) into HTML elements.\n */\nclass MessageRenderer {\n    // private callbacks: MessageRendererCallbacks; // Removed unused member\n    // private uiManager: UIManager; // Might not be needed directly if callbacks handle UI updates\n    constructor( /* callbacks: MessageRendererCallbacks */ /* , uiManager: UIManager */) {\n        // this.callbacks = callbacks; // Removed unused assignment\n        // this.uiManager = uiManager;\n    }\n}\nexports.MessageRenderer = MessageRenderer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsModal = void 0;\nexports.createSettingsModalElement = createSettingsModalElement;\n/**\n * Creates the HTML element for the settings modal.\n * @param callbacks Callbacks for save and cancel actions.\n * @returns The main modal HTMLElement.\n */\nfunction createSettingsModalElement(callbacks) {\n    const modal = document.createElement('div');\n    modal.className = 'jp-llm-ext-settings-modal';\n    modal.style.display = 'none'; // Initially hidden\n    const content = document.createElement('div');\n    content.className = 'jp-llm-ext-settings-content';\n    const title = document.createElement('h2');\n    title.className = 'jp-llm-ext-settings-title';\n    title.textContent = 'Settings';\n    content.appendChild(title);\n    const form = document.createElement('form');\n    form.className = 'jp-llm-ext-settings-form';\n    // Provider selection\n    const providerLabel = document.createElement('label');\n    providerLabel.className = 'jp-llm-ext-settings-label';\n    providerLabel.textContent = 'API Provider:';\n    form.appendChild(providerLabel);\n    const providerSelect = document.createElement('select');\n    providerSelect.className = 'jp-llm-ext-settings-select';\n    providerSelect.id = 'settings-provider'; // Keep ID for retrieval\n    ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {\n        const option = document.createElement('option');\n        option.value = opt;\n        option.textContent = opt;\n        providerSelect.appendChild(option);\n    });\n    form.appendChild(providerSelect);\n    // API Key input\n    const apiKeyLabel = document.createElement('label');\n    apiKeyLabel.className = 'jp-llm-ext-settings-label';\n    apiKeyLabel.textContent = 'API Key:';\n    form.appendChild(apiKeyLabel);\n    const apiKeyInput = document.createElement('input');\n    apiKeyInput.className = 'jp-llm-ext-settings-input';\n    apiKeyInput.type = 'password';\n    apiKeyInput.id = 'settings-api-key'; // Keep ID for retrieval\n    form.appendChild(apiKeyInput);\n    // API URL input\n    const apiUrlLabel = document.createElement('label');\n    apiUrlLabel.className = 'jp-llm-ext-settings-label';\n    apiUrlLabel.textContent = 'API URL (optional):';\n    form.appendChild(apiUrlLabel);\n    const apiUrlInput = document.createElement('input');\n    apiUrlInput.className = 'jp-llm-ext-settings-input';\n    apiUrlInput.type = 'text';\n    apiUrlInput.id = 'settings-api-url'; // Keep ID for retrieval\n    form.appendChild(apiUrlInput);\n    // Rules input\n    const rulesLabel = document.createElement('label');\n    rulesLabel.className = 'jp-llm-ext-settings-label';\n    rulesLabel.textContent = 'Custom Rules (optional):';\n    form.appendChild(rulesLabel);\n    const rulesInput = document.createElement('textarea');\n    rulesInput.className = 'jp-llm-ext-settings-textarea';\n    rulesInput.id = 'settings-rules'; // Keep ID for retrieval\n    form.appendChild(rulesInput);\n    // Buttons container\n    const btnContainer = document.createElement('div');\n    btnContainer.className = 'jp-llm-ext-settings-buttons';\n    const saveBtn = document.createElement('button');\n    saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';\n    saveBtn.textContent = 'Save';\n    saveBtn.type = 'button'; // Prevent default form submission\n    saveBtn.addEventListener('click', (event) => {\n        event.preventDefault();\n        // The callback implementation will handle reading values and saving\n        const settings = {\n            apiKey: apiKeyInput.value,\n            apiUrl: apiUrlInput.value,\n            rules: rulesInput.value,\n            provider: providerSelect.value\n        };\n        callbacks.handleSave(settings);\n    });\n    const cancelBtn = document.createElement('button');\n    cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';\n    cancelBtn.textContent = 'Cancel';\n    cancelBtn.type = 'button'; // Prevent default form submission\n    cancelBtn.addEventListener('click', (event) => {\n        event.preventDefault();\n        callbacks.handleCancel();\n    });\n    btnContainer.appendChild(saveBtn);\n    btnContainer.appendChild(cancelBtn);\n    form.appendChild(btnContainer);\n    content.appendChild(form);\n    modal.appendChild(content);\n    return modal;\n}\n/**\n * Creates and manages the settings modal dialog.\n */\nclass SettingsModal {\n    // private modalElement: HTMLDivElement; // Commented out - unused\n    // private settings: AppSettings; // Commented out - unused\n    constructor(callbacks) {\n        // this.modalElement = createSettingsModalElement(callbacks); // Commented out - unused assignment\n        // this.settings = { // Commented out - unused initialization\n        //     provider: '', \n        //     apiKey: '', \n        //     apiUrl: '', \n        //     rules: '' \n        // }; \n    }\n}\nexports.SettingsModal = SettingsModal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UIManager = void 0;\n/**\n * Manages UI elements and transitions for the chat interface.\n * This acts as a central point for UI manipulations, simplifying dependencies for handlers.\n */\nclass UIManager {\n    constructor(popupMenuManager, callbacks, layoutElements) {\n        this.notificationTimeout = null; // Timeout for the shortcut indicator\n        // Internal UI state\n        this.isInputExpanded = false;\n        this.isMarkdownMode = false;\n        this.popupMenuManager = popupMenuManager;\n        this.callbacks = callbacks;\n        this.layoutElements = layoutElements; // Store the layout elements passed in\n        // Assign class properties directly from the passed layoutElements\n        this.inputField = layoutElements.inputField; // Use provided input field\n        this.messageContainer = layoutElements.messageContainer;\n        this.historyContainer = layoutElements.historyContainer;\n        this.titleInput = layoutElements.titleInput;\n        this.bottomBarContainer = layoutElements.bottomBarContainer;\n        // Initialize and append the keyboard shortcut indicator\n        this.keyboardShortcutIndicator = document.createElement('div');\n        this.keyboardShortcutIndicator.className = 'jp-llm-ext-shortcut-indicator';\n        this.keyboardShortcutIndicator.style.display = 'none'; // Hidden by default\n        // Append the indicator to the main layout or another appropriate place\n        // Ensure the necessary element (e.g., bottomBarContainer) exists before appending\n        if (this.bottomBarContainer) { // Check if bottomBarContainer exists from layoutElements\n            // Prepend within the main content wrapper, before other elements\n            // Or append to bottom bar, depending on desired position\n            // Appending after bottomBarContainer seems reasonable\n            this.bottomBarContainer.insertAdjacentElement('afterend', this.keyboardShortcutIndicator);\n        }\n        else {\n            // If bottomBarContainer is not available, maybe append to mainElement? \n            // Or log an error if it's essential.\n            console.error('UIManager: bottomBarContainer element not found during indicator initialization.');\n        }\n    }\n    /**\n     * Returns the core layout elements.\n     */\n    getUIElements() {\n        return this.layoutElements;\n    }\n    /**\n     * Creates the main layout structure for the sidebar.\n     * @returns References to key DOM elements.\n     */\n    createLayout() {\n        // Create the main container\n        const mainContent = document.createElement('div');\n        mainContent.className = 'jp-llm-ext-content-wrapper';\n        // --- Title Container ---\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'jp-llm-ext-title-container';\n        this.titleInput = document.createElement('input');\n        this.titleInput.className = 'chat-title-input';\n        this.titleInput.type = 'text';\n        this.titleInput.placeholder = 'Chat title';\n        this.titleInput.value = 'New Chat'; // Default value, widget might update later\n        this.titleInput.addEventListener('change', this.callbacks.handleUpdateTitle);\n        titleContainer.appendChild(this.titleInput);\n        // --- Message & History Containers ---\n        this.messageContainer = document.createElement('div');\n        this.messageContainer.className = 'jp-llm-ext-message-container';\n        this.historyContainer = document.createElement('div');\n        this.historyContainer.className = 'jp-llm-ext-history-container';\n        this.historyContainer.style.display = 'none'; // Initially hidden\n        // --- Bottom Bar ---\n        this.bottomBarContainer = document.createElement('div');\n        this.bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';\n        // Controls Row (Markdown Toggle, Action Buttons)\n        const topRow = document.createElement('div');\n        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';\n        const controlsContainer = this.createControlsContainer(); // Creates markdown toggle, @, expand, settings\n        topRow.appendChild(controlsContainer);\n        // Input Row\n        const middleRow = document.createElement('div');\n        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';\n        this.inputField = document.createElement('div');\n        this.inputField.setAttribute('contenteditable', 'true');\n        this.inputField.setAttribute('role', 'textbox');\n        this.inputField.setAttribute('aria-multiline', 'true');\n        this.inputField.setAttribute('data-placeholder', 'Ask me anything...');\n        this.inputField.className = 'jp-llm-ext-input-field';\n        // --- Input Event Listener for @ detection ---\n        this.inputField.addEventListener('input', (event) => {\n            this.handleInputForReference();\n        });\n        // --- End Input Event Listener ---\n        this.inputField.addEventListener('keydown', (event) => {\n            console.log(`UI_MANAGER KeyDown: Key='${event.key}', Shift='${event.shiftKey}', Code='${event.code}'`);\n            const selection = window.getSelection();\n            // --- Backspace handling for widgets ---\n            if (event.key === 'Backspace' && selection && selection.isCollapsed) {\n                const range = selection.getRangeAt(0);\n                const nodeBefore = range.startContainer.childNodes[range.startOffset - 1] || range.startContainer.previousSibling;\n                // Check nodeBefore more carefully\n                let potentialWidget = null;\n                if (range.startOffset > 0 && range.startContainer.childNodes.length >= range.startOffset) {\n                    potentialWidget = range.startContainer.childNodes[range.startOffset - 1];\n                }\n                else if (range.startOffset === 0 && range.startContainer.previousSibling) {\n                    potentialWidget = range.startContainer.previousSibling;\n                }\n                else if (range.startContainer !== this.inputField && range.startContainer.parentNode === this.inputField && range.startOffset === 0) {\n                    // Cursor might be at the start of a text node following a widget\n                    potentialWidget = range.startContainer.previousSibling;\n                }\n                if (potentialWidget &&\n                    potentialWidget.nodeType === Node.ELEMENT_NODE &&\n                    potentialWidget.classList.contains('jp-llm-ext-ref-widget')) {\n                    event.preventDefault(); // Stop default backspace\n                    potentialWidget.remove(); // Remove the entire widget node\n                    // Manually trigger input event for consistency?\n                    this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n                    return; // Stop further processing for this keydown\n                }\n            }\n            // --- End Backspace handling ---\n            // --- @ Key Direct Handling ---\n            // REMOVED: This logic is now centralized in shortcut-handler.ts\n            // --- End @ Key Direct Handling ---\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault(); // Prevent default newline insertion\n                const message = this.getSerializedInput();\n                if (message.trim()) {\n                    this.callbacks.handleSendMessage(message);\n                    this.clearInputField();\n                }\n            }\n            // --- New: Handle Tab/Escape for popup interaction ---\n            else if (this.popupMenuManager.isPopupMenuVisible()) {\n                if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'Enter') {\n                    // Let the PopupMenuManager's document keydown handler manage these\n                    // We just need to prevent the default input field behavior\n                    if (event.key !== 'Enter') { // Allow Enter to potentially work if menu doesn't handle it\n                        event.preventDefault();\n                        // We don't stop propagation here; let the document handler in PopupMenuManager receive it.\n                    }\n                }\n            }\n            // --- End New ---\n        });\n        // --- Copy/Paste Event Listeners ---\n        this.inputField.addEventListener('copy', (event) => {\n            this.handleCopy(event);\n        });\n        this.inputField.addEventListener('paste', (event) => {\n            this.handlePaste(event);\n        });\n        // --- End Copy/Paste ---\n        middleRow.appendChild(this.inputField);\n        // Buttons Row (Send, New Chat, History)\n        const bottomRow = document.createElement('div');\n        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';\n        const sendButton = this.createButton('Send', 'Send message');\n        sendButton.classList.add('jp-llm-ext-send-button'); // Specific class for send\n        sendButton.addEventListener('click', () => {\n            const message = this.getSerializedInput();\n            if (message.trim()) {\n                this.callbacks.handleSendMessage(message);\n                this.clearInputField();\n            }\n        });\n        const newChatButton = this.createButton('+ New Chat', 'Start a new chat');\n        newChatButton.addEventListener('click', this.callbacks.handleNewChat);\n        const historyButton = this.createButton('History', 'View chat history');\n        historyButton.addEventListener('click', this.callbacks.handleToggleHistory);\n        bottomRow.appendChild(sendButton);\n        bottomRow.appendChild(newChatButton);\n        bottomRow.appendChild(historyButton);\n        // Assemble Bottom Bar\n        this.bottomBarContainer.appendChild(topRow);\n        this.bottomBarContainer.appendChild(middleRow);\n        this.bottomBarContainer.appendChild(bottomRow);\n        // --- Assemble Main Content ---\n        mainContent.appendChild(titleContainer);\n        mainContent.appendChild(this.messageContainer);\n        mainContent.appendChild(this.historyContainer);\n        mainContent.appendChild(this.bottomBarContainer);\n        // Return references to key elements\n        return {\n            mainLayout: mainContent,\n            messageContainer: this.messageContainer,\n            inputField: this.inputField,\n            titleInput: this.titleInput,\n            historyContainer: this.historyContainer,\n            bottomBarContainer: this.bottomBarContainer,\n        };\n    }\n    /**\n     * Creates the controls container with toggles and action buttons.\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'jp-llm-ext-controls-container';\n        // --- Markdown Toggle ---\n        const toggleContainer = document.createElement('div');\n        toggleContainer.className = 'jp-llm-ext-toggle-container';\n        this.markdownToggle = document.createElement('input');\n        this.markdownToggle.type = 'checkbox';\n        this.markdownToggle.id = 'markdown-toggle'; // Ensure unique ID or handle differently\n        this.markdownToggle.addEventListener('change', (e) => {\n            const target = e.target;\n            this.isMarkdownMode = target.checked;\n            const placeholderText = this.isMarkdownMode\n                ? 'Write markdown here...\\\\n\\\\n# Example heading\\\\n- List item\\\\n\\\\n```code block```'\n                : 'Ask me anything...';\n            this.inputField.setAttribute('data-placeholder', placeholderText);\n            this.inputField.blur();\n            this.inputField.focus();\n        });\n        const toggleLabel = document.createElement('label');\n        toggleLabel.htmlFor = 'markdown-toggle';\n        toggleLabel.textContent = 'Markdown mode';\n        toggleContainer.appendChild(this.markdownToggle);\n        toggleContainer.appendChild(toggleLabel);\n        // --- Action Buttons (@, Expand, Settings) ---\n        const actionButtonsContainer = document.createElement('div');\n        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';\n        // '@' Button\n        const atButton = this.createButton('@', 'Browse cells, code, files, and more');\n        atButton.addEventListener('click', (event) => {\n            this.callbacks.handleShowPopupMenu(event, event.currentTarget);\n        });\n        // Expand Button (store reference)\n        this.expandButton = this.createButton('', 'Expand input');\n        this.expandButton.addEventListener('click', () => this.toggleInputExpansion());\n        // Settings Button\n        const settingsButton = this.createButton('', 'Settings');\n        settingsButton.addEventListener('click', this.callbacks.handleShowSettings);\n        // Add buttons to container\n        actionButtonsContainer.appendChild(atButton);\n        actionButtonsContainer.appendChild(this.expandButton);\n        actionButtonsContainer.appendChild(settingsButton);\n        // Assemble Controls Container\n        controlsContainer.appendChild(toggleContainer);\n        controlsContainer.appendChild(actionButtonsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Toggles the expansion state of the input field.\n     */\n    toggleInputExpansion() {\n        if (!this.inputField || !this.expandButton)\n            return; // Ensure elements exist\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.inputField.style.height = '200px'; // Keep for now, consider CSS classes\n            this.inputField.style.resize = 'vertical'; // Works on divs too (if overflow visible/auto)\n            this.expandButton.textContent = '';\n            this.expandButton.title = 'Collapse input';\n        }\n        else {\n            this.inputField.style.height = ''; // Reset height\n            this.inputField.style.resize = 'none';\n            this.expandButton.textContent = '';\n            this.expandButton.title = 'Expand input';\n        }\n        // Future: Notify widget/handler if needed: this.callbacks.handleToggleExpansion(this.isInputExpanded);\n    }\n    /**\n     * Helper function to create a styled button.\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        // Apply base JupyterLab button class and our specific class\n        button.className = 'jp-Button jp-llm-ext-action-button';\n        return button;\n    }\n    /**\n     * Appends a new chat message element to the message container and scrolls down.\n     * @param element The message element (user or bot) to add.\n     */\n    addChatMessageElement(element) {\n        if (this.messageContainer) {\n            this.messageContainer.appendChild(element);\n            this.scrollToBottom(); // Scroll after adding the new element\n        }\n        else {\n            console.error('Message container not initialized in UIManager.');\n        }\n    }\n    /**\n     * Scrolls the message container to the bottom.\n     */\n    scrollToBottom() {\n        if (this.messageContainer) {\n            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        }\n        else {\n            console.error('Message container not initialized in UIManager.');\n        }\n    }\n    /**\n     * Switches the view to show the chat history.\n     */\n    showHistoryView() {\n        this.layoutElements.messageContainer.style.display = 'none';\n        this.layoutElements.historyContainer.style.display = 'block';\n        this.layoutElements.bottomBarContainer.style.display = 'none';\n        // Optionally update header/title elements if needed\n    }\n    /**\n     * Switches the view to show the main chat interface.\n     */\n    showChatView() {\n        this.layoutElements.historyContainer.style.display = 'none';\n        this.layoutElements.messageContainer.style.display = 'block';\n        this.layoutElements.bottomBarContainer.style.display = 'flex'; // Assuming flex display\n        this.scrollToBottom(); // Scroll down when showing chat\n    }\n    /**\n     * Clears all messages from the message container.\n     */\n    clearMessageContainer() {\n        this.layoutElements.messageContainer.innerHTML = '';\n    }\n    /**\n     * Updates the value of the title input field.\n     */\n    updateTitleInput(title) {\n        if (this.layoutElements.titleInput) {\n            this.layoutElements.titleInput.value = title;\n        }\n    }\n    /**\n     * Creates and returns a container structure for a bot message,\n     * including elements for streaming text and final rendered content.\n     * This helps manage the transition from streaming to final message display.\n     */\n    createBotMessageContainer() {\n        const botMessageDiv = document.createElement('div');\n        botMessageDiv.className = 'jp-llm-ext-bot-message'; // Base class\n        // Div for streaming content (initially visible)\n        const streamingDiv = document.createElement('div');\n        streamingDiv.className = 'jp-llm-ext-streaming-content';\n        streamingDiv.style.display = 'block'; // Show streaming initially\n        // Div for final rendered content (initially hidden)\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'jp-llm-ext-rendered-content';\n        contentDiv.style.display = 'none'; // Hide final content initially\n        botMessageDiv.appendChild(streamingDiv);\n        botMessageDiv.appendChild(contentDiv);\n        // Add the whole container to the message list *before* streaming starts\n        this.addChatMessageElement(botMessageDiv);\n        return { botMessageDiv, streamingDiv, contentDiv };\n    }\n    /**\n     * Displays a temporary notification message.\n     * TODO: Implement a more robust notification system (e.g., toast).\n     */\n    showNotification(message, type, duration = 3000) {\n        console.log(`Notification (${type}): ${message}`);\n        // Basic temporary implementation using the existing indicator element\n        const indicator = this.layoutElements.mainElement.querySelector('.jp-llm-ext-keyboard-shortcut-indicator');\n        if (indicator) {\n            if (this.notificationTimeout) {\n                clearTimeout(this.notificationTimeout); // Clear previous timeout\n            }\n            indicator.textContent = message;\n            indicator.className = `jp-llm-ext-keyboard-shortcut-indicator visible jp-llm-ext-notification-${type}`; // Add type class\n            this.notificationTimeout = window.setTimeout(() => {\n                indicator.classList.remove('visible');\n                this.notificationTimeout = null;\n            }, duration);\n        }\n        else {\n            console.warn('Notification indicator element not found for UIManager.');\n        }\n    }\n    /**\n     * Shows a visual indicator for keyboard shortcuts.\n     * @param text The text to display in the indicator.\n     */\n    showIndicator(text) {\n        if (!this.keyboardShortcutIndicator)\n            return; // Guard\n        this.keyboardShortcutIndicator.textContent = text;\n        this.keyboardShortcutIndicator.classList.add('visible');\n        // Clear any existing timeout to prevent multiple timeouts running\n        if (this.notificationTimeout) {\n            clearTimeout(this.notificationTimeout);\n        }\n        // Set new timeout to hide the indicator\n        this.notificationTimeout = window.setTimeout(() => {\n            if (this.keyboardShortcutIndicator) { // Check if element still exists\n                this.keyboardShortcutIndicator.classList.remove('visible');\n            }\n            this.notificationTimeout = null;\n        }, 1000); // Hide after 1 second\n    }\n    /**\n     * Clears the indicator immediately and cancels any pending hide timeout.\n     * Useful if the widget is hidden while the indicator is shown.\n     */\n    clearIndicator() {\n        if (!this.keyboardShortcutIndicator)\n            return;\n        this.keyboardShortcutIndicator.classList.remove('visible');\n        this.keyboardShortcutIndicator.textContent = '';\n        if (this.notificationTimeout) {\n            clearTimeout(this.notificationTimeout);\n            this.notificationTimeout = null;\n        }\n    }\n    /**\n     * Checks the input field content and cursor position to determine if\n     * the reference suggestion popup should be shown or hidden.\n     * Triggered on 'input' events.\n     */\n    handleInputForReference() {\n        var _a, _b;\n        const selection = window.getSelection();\n        if (!selection || !selection.rangeCount || !selection.isCollapsed) {\n            // Need a collapsed selection (cursor) inside the input field\n            this.popupMenuManager.hidePopupMenu();\n            return;\n        }\n        const range = selection.getRangeAt(0);\n        const container = range.startContainer;\n        const offset = range.startOffset;\n        // Ensure the cursor is within the input field itself\n        if (!this.inputField.contains(container)) {\n            this.popupMenuManager.hidePopupMenu();\n            return;\n        }\n        // Combine text content from preceding siblings if cursor is at the start of a text node\n        let textBeforeCursor = '';\n        let currentContainer = container;\n        let currentOffset = offset;\n        while (currentContainer) {\n            if (currentContainer.nodeType === Node.TEXT_NODE) {\n                textBeforeCursor = ((_a = currentContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, currentOffset)) + textBeforeCursor;\n            }\n            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.classList.contains('jp-llm-ext-ref-widget')) {\n                // If we encounter a widget before the cursor, we can't be right after '@'\n                textBeforeCursor = '[widget]' + textBeforeCursor; // Add placeholder to break '@' sequence\n            }\n            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.tagName === 'BR') {\n                textBeforeCursor = '\\n' + textBeforeCursor; // Treat BR as newline\n            }\n            // Move to the previous sibling or parent's previous sibling\n            if (currentContainer.previousSibling) {\n                currentContainer = currentContainer.previousSibling;\n                // If moving to a new node, take its full content\n                currentOffset = (currentContainer.textContent || '').length;\n            }\n            else {\n                // Move up to parent, continue search from before the parent\n                currentContainer = currentContainer.parentNode;\n                if (currentContainer === this.inputField || !currentContainer) {\n                    break; // Stop if we reached the input field or top\n                }\n                currentOffset = Array.prototype.indexOf.call(((_b = currentContainer.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes) || [], currentContainer);\n            }\n        }\n        console.log(`UI_MANAGER handleInput: Text before cursor: \"${textBeforeCursor}\"`);\n        // --- Check for trigger conditions --- \n        const endsWithAt = textBeforeCursor.endsWith('@');\n        const endsWithAtSpace = textBeforeCursor.endsWith('@ ');\n        if (endsWithAt || endsWithAtSpace) {\n            if (this.popupMenuManager.isPopupMenuVisible()) {\n                // TODO: If visible, maybe just update the query in the popup?\n                console.log('UI_MANAGER handleInput: Popup already visible, skipping show.');\n            }\n            else {\n                // Find the start of the query (after '@' or '@ ')\n                const atIndex = textBeforeCursor.lastIndexOf('@');\n                let queryStartIndex = atIndex + 1;\n                if (endsWithAtSpace) {\n                    queryStartIndex = atIndex + 2;\n                }\n                const query = textBeforeCursor.substring(queryStartIndex);\n                // --- Insert temporary span to get reliable coordinates --- \n                const tempAnchorId = 'jp-llm-temp-popup-anchor';\n                let tempSpan = document.getElementById(tempAnchorId);\n                if (tempSpan)\n                    tempSpan.remove(); // Clean up previous if any\n                tempSpan = document.createElement('span');\n                tempSpan.id = tempAnchorId;\n                // Style to be invisible and take no space\n                tempSpan.style.visibility = 'hidden';\n                tempSpan.style.width = '0';\n                tempSpan.style.height = '0';\n                tempSpan.style.overflow = 'hidden';\n                tempSpan.textContent = '\\u200B'; // Zero-width space might help rendering\n                // Insert the span at the current cursor position\n                range.insertNode(tempSpan);\n                const spanRect = tempSpan.getBoundingClientRect();\n                tempSpan.remove(); // Remove immediately after getting coords\n                // --- End temporary span logic ---\n                if (spanRect.top === 0 && spanRect.left === 0) {\n                    console.error(\"UI_MANAGER handleInput: Failed to get valid coordinates from temp anchor span.\");\n                    // Fallback or alternative positioning might be needed here\n                    // Maybe position relative to input field bottom-left?\n                    this.popupMenuManager.hidePopupMenu(); // Don't show if coords are bad\n                }\n                else {\n                    console.log(`UI_MANAGER handleInput: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);\n                    // Show the TOP LEVEL suggestions using the reliable coordinates\n                    // Pass the coordinates directly to showPopupMenu\n                    this.popupMenuManager.showPopupMenu(spanRect.top, spanRect.left);\n                }\n            }\n        }\n        else {\n            // If text doesn't end with @ or @-space, hide the popup\n            // Only hide if it was previously showing the 'top' or 'references' menu triggered by '@'\n            // Avoid hiding menus triggered by the button click unnecessarily\n            if (this.popupMenuManager.isPopupMenuVisible()) { // && (this.popupMenuManager.getCurrentMenuLevel() === 'references' || /* Need way to know if triggered by @ */ )) {\n                console.log('UI_MANAGER handleInput: Hiding popup, trigger condition no longer met.');\n                this.popupMenuManager.hidePopupMenu();\n            }\n        }\n        // TODO: Update popup query if it's already visible and the text after @ changes\n        // (Need more robust logic here, considering backspace, etc.)\n    }\n    /**\n     * Serializes the content of the input field, converting known widgets\n     * back to their reference strings (e.g., @file:path/to/file.txt).\n     *\n     * NOTE: This currently uses a simple text serialization. For full fidelity\n     * preserving structure (like multiple paragraphs), a more complex approach\n     * (e.g., HTML processing or a dedicated editor model) would be needed.\n     *\n     * @returns {string} The serialized plain text content of the input field.\n     */\n    getSerializedInput() {\n        let serialized = '';\n        const nodes = this.inputField.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (node.nodeType === Node.TEXT_NODE) {\n                serialized += node.textContent;\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {\n                    // Append the reference text stored in the data attribute\n                    serialized += element.dataset.referenceText;\n                }\n                else if (element.tagName === 'BR') {\n                    // Convert BR tags back to newlines\n                    serialized += '\\n';\n                }\n                else if (element.tagName === 'DIV') {\n                    // Handle DIV elements (might be inserted by browser on paste/enter)\n                    // Add newline before if needed, then serialize children recursively?\n                    if (i > 0) { // Add newline only if not the first element\n                        serialized += '\\n';\n                    }\n                    serialized += this.serializeNodeChildren(element); // Recursively serialize children\n                }\n                else {\n                    // Include text content of other unexpected elements, but log a warning\n                    console.warn('UIManager getSerializedInput: Encountered unexpected element:', element.tagName);\n                    serialized += element.textContent;\n                }\n            } // Ignore other node types (comments, etc.)\n        }\n        return serialized.trim(); // Trim leading/trailing whitespace\n    }\n    // Helper to serialize children of a node (e.g., for DIVs)\n    serializeNodeChildren(parentNode) {\n        let content = '';\n        const nodes = parentNode.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (node.nodeType === Node.TEXT_NODE) {\n                content += node.textContent;\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {\n                    content += element.dataset.referenceText;\n                }\n                else if (element.tagName === 'BR') {\n                    content += '\\n';\n                }\n                else {\n                    // Recursively handle nested elements if necessary, or just get text content\n                    content += this.serializeNodeChildren(element);\n                }\n            }\n        }\n        return content;\n    }\n    clearInputField() {\n        this.inputField.innerHTML = ''; // Clear all content\n        // Reset expansion state if needed\n        if (this.isInputExpanded) {\n            this.toggleInputExpansion();\n        }\n        // Ensure placeholder reappears if using CSS for it\n        this.inputField.dispatchEvent(new Event('input')); // Trigger event to update UI state if necessary\n    }\n    /**\n     * Handles the 'copy' event to put serialized plain text onto the clipboard.\n     */\n    handleCopy(event) {\n        const selection = window.getSelection();\n        if (!selection || selection.isCollapsed || !event.clipboardData) {\n            return; // Nothing selected or no clipboard data object\n        }\n        const range = selection.getRangeAt(0);\n        // Ensure the selection is within our input field\n        if (!this.inputField.contains(range.commonAncestorContainer)) {\n            return;\n        }\n        const selectedText = this.serializeRangeContent(range);\n        event.preventDefault(); // Prevent default copy behavior\n        event.clipboardData.setData('text/plain', selectedText);\n        console.log('UIManager handleCopy: Copied serialized text:', selectedText);\n    }\n    /**\n     * Handles the 'paste' event to insert plain text content.\n     */\n    handlePaste(event) {\n        var _a;\n        if (!event.clipboardData) {\n            return;\n        }\n        const text = event.clipboardData.getData('text/plain');\n        if (text) {\n            event.preventDefault(); // Prevent default paste behavior\n            // Insert the plain text at the current cursor position\n            const selection = window.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                const range = selection.getRangeAt(0);\n                range.deleteContents(); // Delete selected content if any\n                const textNode = document.createTextNode(text);\n                range.insertNode(textNode);\n                // Move cursor after inserted text\n                range.setStartAfter(textNode);\n                range.setEndAfter(textNode);\n                selection.removeAllRanges();\n                selection.addRange(range);\n                // Ensure scroll into view and trigger input event for potential updates\n                this.inputField.focus();\n                (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'nearest' });\n                this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n            }\n            console.log('UIManager handlePaste: Pasted text:', text);\n        }\n    }\n    // --- Methods for updating UI elements will be added later ---\n    // e.g., updateMessageContainer(html: string), showHistoryView(), showChatView()\n    // --- Potentially add methods to get element references if needed externally ---\n    // public getInputField(): HTMLTextAreaElement { return this.inputField; }\n    // etc.\n    // Helper to serialize a range (needed for copy)\n    serializeRangeContent(range) {\n        const fragment = range.cloneContents();\n        let tempDiv = document.createElement('div');\n        tempDiv.appendChild(fragment);\n        // Now, serialize tempDiv's content like we do for getSerializedInput\n        let serialized = '';\n        const nodes = tempDiv.childNodes;\n        const serializeNode = (node) => {\n            if (node.nodeType === Node.TEXT_NODE) {\n                serialized += node.textContent;\n            }\n            else if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {\n                    serialized += element.dataset.referenceText;\n                }\n                else if (element.tagName === 'BR') {\n                    serialized += '\\n';\n                }\n                else { // For other elements (like DIVs potentially in fragment), serialize children\n                    const childNodes = element.childNodes;\n                    for (let j = 0; j < childNodes.length; j++) {\n                        serializeNode(childNodes[j]);\n                    }\n                }\n            }\n        };\n        for (let i = 0; i < nodes.length; i++) {\n            serializeNode(nodes[i]);\n        }\n        return serialized;\n    }\n}\nexports.UIManager = UIManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.copyToClipboard = copyToClipboard;\nexports.copyMessageToClipboard = copyMessageToClipboard;\nexports.copyImageToClipboard = copyImageToClipboard;\n/**\n * Helper function to copy text to clipboard.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyToClipboard(text, feedbackCallback) {\n    try {\n        navigator.clipboard.writeText(text).then(() => {\n            console.log('Content copied to clipboard');\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(); // Call optional feedback callback\n        }).catch(err => {\n            console.error('Failed to copy text: ', err);\n        });\n    }\n    catch (error) {\n        console.error('Error copying text to clipboard:', error);\n    }\n}\n/**\n * Copies message content to clipboard.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyMessageToClipboard(text, feedbackCallback) {\n    try {\n        navigator.clipboard.writeText(text).then(() => {\n            console.log('Message content copied to clipboard');\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success\n        }).catch(err => {\n            console.error('Failed to copy message text: ', err);\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n        });\n    }\n    catch (error) {\n        console.error('Error copying message to clipboard:', error);\n        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n    }\n}\n/**\n * Copies an image to the clipboard from a given URL.\n * Provides visual feedback via console logs and optionally a callback.\n */\nfunction copyImageToClipboard(imageUrl, feedbackCallback) {\n    try {\n        fetch(imageUrl)\n            .then(response => {\n            if (!response.ok) {\n                throw new Error(`Failed to fetch image: ${response.statusText}`);\n            }\n            return response.blob();\n        })\n            .then(blob => {\n            // Create a ClipboardItem with the image blob\n            // Note: ClipboardItem might not be defined in all environments\n            // You might need to add `\"dom.iterable\"` to tsconfig lib or handle appropriately.\n            const item = new ClipboardItem({ [blob.type]: blob });\n            navigator.clipboard.write([item]).then(() => {\n                console.log('Image copied to clipboard');\n                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success\n            })\n                .catch(err => {\n                console.error('Failed to copy image to clipboard: ', err);\n                alert('Failed to copy image: ' + err.message); // Keep alert for critical user feedback\n                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n            });\n        })\n            .catch(err => {\n            console.error('Failed to fetch or process image: ', err);\n            alert('Failed to fetch image: ' + err.message); // Keep alert for critical user feedback\n            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n        });\n    }\n    catch (error) {\n        console.error('Error preparing image copy:', error);\n        alert('Error copying image: ' + error); // Keep alert for critical user feedback\n        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCaretPosition = getCaretPosition;\nexports.setCaretPosition = setCaretPosition;\n/**\n * Gets the caret position within a contenteditable element.\n * Returns the linear offset from the start of the element's text content.\n */\nfunction getCaretPosition(element) {\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0 || !element.contains(selection.anchorNode)) {\n        // Check if selection is within the element\n        return 0;\n    }\n    const range = selection.getRangeAt(0);\n    // Create a range that spans from the beginning of the element to the caret\n    const preCaretRange = range.cloneRange();\n    preCaretRange.selectNodeContents(element);\n    preCaretRange.setEnd(range.startContainer, range.startOffset);\n    // The length of the text content within this pre-caret range is the position\n    // Using toString() is generally more reliable than textContent for range length\n    return preCaretRange.toString().length;\n}\n/**\n * Sets the caret position within a contenteditable element.\n * @param element The contenteditable element.\n * @param position The desired linear offset from the start of the text content.\n */\nfunction setCaretPosition(element, position) {\n    var _a;\n    const selection = window.getSelection();\n    if (!selection) {\n        return;\n    }\n    const range = document.createRange();\n    let charCount = 0;\n    let foundNode = false;\n    let nodeStack = [element]; // Use a stack for DFS traversal\n    // Depth-first search to find the correct text node and offset\n    while (nodeStack.length > 0) {\n        const node = nodeStack.pop();\n        if (node.nodeType === Node.TEXT_NODE) {\n            const textLength = ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            if (position >= charCount && position <= charCount + textLength) {\n                range.setStart(node, position - charCount);\n                range.setEnd(node, position - charCount);\n                foundNode = true;\n                break; // Found the node, exit loop\n            }\n            charCount += textLength;\n        }\n        else if (node.nodeType === Node.ELEMENT_NODE) {\n            const elementNode = node;\n            if (elementNode.tagName === 'BR') {\n                if (position === charCount) { // Position is right before BR\n                    range.setStartBefore(node);\n                    range.setEndBefore(node);\n                    foundNode = true;\n                    break;\n                }\n                charCount += 1; // Treat BR as one character\n            }\n            else if (elementNode.getAttribute('contenteditable') === 'false') {\n                // Treat non-editable elements (like our widgets) as single characters\n                if (position === charCount) {\n                    // Position is right before the widget\n                    range.setStartBefore(node);\n                    range.setEndBefore(node);\n                    foundNode = true;\n                    break;\n                }\n                charCount += 1;\n            }\n            else {\n                // Add child nodes to the stack in reverse order for correct DFS\n                const children = node.childNodes;\n                for (let i = children.length - 1; i >= 0; i--) {\n                    nodeStack.push(children[i]);\n                }\n            }\n        }\n    }\n    // If the position is beyond the content or wasn't found, place cursor at the end\n    if (!foundNode) {\n        range.selectNodeContents(element);\n        range.collapse(false); // Collapse to the end\n    }\n    selection.removeAllRanges();\n    selection.addRange(range);\n    // Restore focus only if the element was previously focused or is the target\n    // This avoids stealing focus unnecessarily\n    if (document.activeElement !== element) {\n        element.focus({ preventScroll: true }); // preventScroll helps avoid jumping\n    }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detectLanguage = detectLanguage;\nexports.highlightCode = highlightCode;\nconst highlight_js_1 = __importDefault(require(\"highlight.js\"));\n/**\n * Detects the programming language from code block content using highlight.js\n * and custom pattern matching for common languages.\n */\nfunction detectLanguage(code) {\n    try {\n        // Try auto detection first with a limited set of common languages\n        const result = highlight_js_1.default.highlightAuto(code, [\n            'python', 'javascript', 'typescript', 'java',\n            'html', 'css', 'cpp', 'csharp', 'sql', 'rust',\n            'php', 'bash', 'json', 'xml', 'markdown'\n        ]);\n        // If confidence is reasonably high, use that language\n        if (result.relevance > 5 && result.language) {\n            return result.language;\n        }\n        // Fall back to basic pattern matching for better accuracy on ambiguous cases\n        if (/^(?:\\s*)?(?:import\\s+[^;]+;|package\\s+[^;]+;|public\\s+class)/.test(code)) {\n            return 'java';\n        }\n        else if (/^(?:\\s*)?(import|from|def|class|if __name__)/.test(code)) {\n            return 'python';\n        }\n        else if (/^(?:\\s*)?(?:function|const|let|var|import|export|=>)/.test(code)) {\n            // Broader check for JS/TS\n            if (/^(?:\\s*)?(?:import\\s.+|export\\s.+|interface|type|enum|declare|:|\\s<)/.test(code)) {\n                return 'typescript';\n            }\n            return 'javascript';\n        }\n        else if (/^(?:\\s*)?(?:<!DOCTYPE|<html|<head|<body)/i.test(code)) {\n            return 'html';\n        }\n        else if (/^(?:\\s*)?#include/.test(code)) {\n            return 'cpp';\n        }\n        else if (/^(?:\\s*)?(?:using\\s+System|namespace|public\\s+static\\s+void\\s+Main)/.test(code)) {\n            return 'csharp';\n        }\n        else if (/^(?:\\s*)?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\\s/i.test(code)) {\n            return 'sql';\n        }\n        else if (/^(?:\\s*)?(?:fn|let|struct|enum|trait|impl|mod)\\s/.test(code)) {\n            return 'rust';\n        }\n        else if (/^(?:\\s*)?(?:<\\?php|use\\s+[\\w\\\\]+;)/.test(code)) {\n            return 'php';\n        }\n        else if (/^(?:\\s*)?(?:#\\s*!\\/bin\\/(?:bash|sh|zsh)|\\$)/.test(code)) {\n            return 'bash';\n        }\n        else if (/^\\s*\\{/.test(code) && /\\}\\s*$/.test(code)) {\n            // Simple check for JSON-like structure\n            return 'json';\n        }\n        else if (/^\\s*<\\?xml/.test(code) || /^\\s*<\\w+/.test(code)) {\n            // Simple check for XML/HTML like structure\n            return 'xml';\n        }\n        // If no specific language detected, return empty string for default handling\n        return '';\n    }\n    catch (error) {\n        console.error('Error detecting language:', error);\n        return ''; // Return empty on error\n    }\n}\n/**\n * Highlights code using highlight.js.\n * Falls back to auto-detection if the specified language is not supported.\n */\nfunction highlightCode(code, language) {\n    try {\n        if (language && highlight_js_1.default.getLanguage(language)) {\n            return highlight_js_1.default.highlight(code, { language, ignoreIllegals: true }).value;\n        }\n        else {\n            // Fallback to auto-detection if language is empty or not registered\n            return highlight_js_1.default.highlightAuto(code).value;\n        }\n    }\n    catch (error) {\n        console.error(`Error highlighting code (language: ${language || 'auto'}):`, error);\n        // Return original code escaped for safety on error\n        return code.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.configureMarked = configureMarked;\nexports.preprocessMarkdown = preprocessMarkdown;\nconst marked_1 = require(\"marked\");\n/**\n * Configure marked with better rendering options for code blocks\n */\nfunction configureMarked() {\n    // Configure marked options\n    marked_1.marked.setOptions({\n        gfm: true, // Enable GitHub Flavored Markdown\n        breaks: true, // Add <br> on single line breaks\n        pedantic: false, // Conform to original markdown spec\n        async: false, // Disable async rendering\n        silent: false // Enable error reporting\n    });\n}\n/**\n * Pre-process markdown text to fix common issues with streaming content\n */\nfunction preprocessMarkdown(text) {\n    // Normalize line endings\n    const normalizedText = text.replace(/\\r\\n/g, '\\n');\n    // Handle code blocks first\n    let inCodeBlock = false;\n    const lines = normalizedText.split('\\n');\n    const processedLines = lines.map((line, i) => {\n        // Check for code block markers\n        if (line.trim().startsWith('```')) {\n            inCodeBlock = !inCodeBlock;\n            // Preserve language specification\n            return line.trim();\n        }\n        // If we're in a code block, preserve the line as is\n        if (inCodeBlock) {\n            return line;\n        }\n        // Outside code blocks:\n        // 1. Handle list items with proper spacing\n        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines\n        let processed = line;\n        // Handle dash list items by ensuring they have a space after the dash\n        processed = processed.replace(/(\\s*)-(\\S)/g, '$1- $2');\n        // Handle mixed space/dash issues - ensure proper newlines before list items\n        processed = processed.replace(/([^\\n\\s])-\\s/g, '$1\\n- ');\n        return processed;\n    });\n    // Join lines and ensure code blocks are properly formatted\n    let result = processedLines.join('\\n');\n    // Handle empty code blocks (add a space so they render properly)\n    result = result.replace(/```(.*)\\n```/g, '```$1\\n \\n```');\n    return result;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addMessageToCell = addMessageToCell;\nexports.getSelectedText = getSelectedText;\nexports.getCurrentCellContent = getCurrentCellContent;\nexports.insertCellContentByIndex = insertCellContentByIndex;\nconst globals_1 = require(\"../core/globals\");\n/**\n * Adds message content to the current cell in the active notebook.\n */\nfunction addMessageToCell(text) {\n    var _a;\n    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (!cell || !cell.editor) {\n        console.warn('Cannot add message: No active cell or editor found.');\n        return;\n    }\n    try {\n        const editor = cell.editor;\n        // Access the underlying CodeMirror editor view (adjust if using a different editor)\n        const view = editor.editor;\n        if (!view) {\n            console.warn('Cannot add message: CodeMirror view not accessible.');\n            return;\n        }\n        // Get current cursor position\n        const state = view.state;\n        const selection = state.selection;\n        const cursorPos = selection.main.head;\n        // Insert newline and message content at cursor position\n        const transaction = state.update({\n            changes: {\n                from: cursorPos,\n                insert: `\\n${text}`\n            },\n            // Optionally move cursor to end of inserted text\n            selection: { anchor: cursorPos + text.length + 1 }\n        });\n        view.dispatch(transaction);\n    }\n    catch (error) {\n        console.error('Error adding message to cell:', error);\n    }\n}\n/**\n * Gets the currently selected text from the active notebook cell or text editor.\n */\nfunction getSelectedText() {\n    var _a, _b, _c;\n    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (cell === null || cell === void 0 ? void 0 : cell.editor) {\n        const editor = cell.editor;\n        const cmEditor = editor.editor; // Access CodeMirror editor instance\n        if (cmEditor && cmEditor.state) {\n            const state = cmEditor.state;\n            const selection = state.selection.main;\n            return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);\n        }\n        console.warn(\"Could not access CodeMirror state to get selection.\");\n        return null;\n    }\n    else {\n        // Fallback for non-notebook editors (e.g., text editor)\n        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n        if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {\n            const editor = activeWidget.content.editor;\n            const cmEditor = editor.editor;\n            if (cmEditor && cmEditor.state) {\n                const state = cmEditor.state;\n                const selection = state.selection.main;\n                return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);\n            }\n            console.warn(\"Could not access CodeMirror state for non-notebook editor selection.\");\n            return null;\n        }\n    }\n    return null;\n}\n/**\n * Gets the content of the currently active notebook cell or text editor.\n */\nfunction getCurrentCellContent() {\n    var _a, _b, _c, _d, _e;\n    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {\n        // Try using sharedModel first (more robust)\n        if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {\n            return activeCell.model.sharedModel.getSource();\n        }\n        // Fallback: Try using toJSON().source\n        const cellJson = activeCell.model.toJSON();\n        const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n        if (typeof source === 'string') {\n            return source;\n        }\n        else if (Array.isArray(source)) {\n            return source.join('\\n');\n        }\n        console.warn(\"Could not get cell content via sharedModel or toJSON().source\");\n        return null;\n    }\n    // Fallback for non-notebook editors if needed\n    const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n    if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {\n        // Assuming model.value.text for generic text editors\n        return (_e = (_d = activeWidget.content.model.value) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;\n    }\n    return null;\n}\n/**\n * Gets cell content by index from the current notebook and calls a callback to insert it.\n * NOTE: The original function called `this.appendToInput`. This functionality needs\n *       to be provided via the `insertCallback`.\n */\nfunction insertCellContentByIndex(index, insertCallback) {\n    try {\n        if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {\n            console.error('No active notebook found');\n            return;\n        }\n        const notebookPanel = globals_1.globals.notebookTracker.currentWidget;\n        const model = notebookPanel.content.model;\n        if (!model || !model.cells || index < 0 || index >= model.cells.length) {\n            console.error(`Invalid cell index: ${index}`);\n            return;\n        }\n        const cell = model.cells.get(index);\n        let cellContent = '';\n        // Get cell content - handle different ways content might be stored\n        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {\n            cellContent = cell.sharedModel.getSource();\n        }\n        else {\n            const cellJson = cell.toJSON();\n            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;\n            if (typeof source === 'string') {\n                cellContent = source;\n            }\n            else if (Array.isArray(source)) {\n                cellContent = source.join('\\n');\n            }\n        }\n        // Insert cell reference with content using the callback\n        insertCallback(`cell ${cellContent}`);\n    }\n    catch (error) {\n        console.error('Error inserting cell by index:', error);\n    }\n}\n"],"names":[],"sourceRoot":""}