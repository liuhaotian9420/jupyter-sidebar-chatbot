{"version":3,"file":"lib_index_js.f58df042c221c94d3a64.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACrEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC7Ib;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,+BAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,mBAAmB;AACnB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB,IAAI,+BAA+B;AACnC;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;;;;;;;;;;;ACjBY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,mBAAmB,mBAAO,CAAC,qCAAY;AACvC,+BAA+B,mBAAO,CAAC,6DAAwB;AAC/D,YAAY,YAAY;AACxB;AACA,mBAAO,CAAC,6CAAoB;AAC5B;AACA,mBAAmB,mBAAO,CAAC,yCAAc;AACzC,6CAA4C,EAAE,qCAAqC,kCAAkC,EAAC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACrCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B;AAC1B,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,kBAAkB,mBAAO,CAAC,mCAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE,IAAI,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAyD;AACvE,cAAc,2DAA2D;AACzE,cAAc,0DAA0D;AACxE,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gEAAgE,MAAM,EAAE,SAAS;AACjF;AACA,qBAAqB;AACrB;AACA;AACA,kGAAkG,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wCAAwC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,EAAE,kBAAkB,EAAE,iBAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS,UAAU,KAAK;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK,GAAG,yDAAyD;AACzG;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,UAAU,KAAK;AACxE;AACA;AACA,oCAAoC,0DAA0D;AAC9F;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB,UAAU,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,aAAa,oBAAoB;AAC9G;AACA,4BAA4B,SAAS,GAAG,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD,qBAAqB;AACrB;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wCAAwC,mBAAmB,kBAAkB,SAAS;AACtF;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,KAAK,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc,KAAK,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,aAAa,oEAAoE,oBAAoB,4CAA4C;AACtM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,wEAAwE,iCAAiC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,4BAA4B,QAAQ,kBAAkB;AAChI;AACA;AACA;AACA;AACA,4FAA4F,MAAM;AAClG;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA,gGAAgG,MAAM;AACtG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU,KAAK,2BAA2B;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,UAAU,KAAK,2BAA2B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E,wDAAwD,WAAW,oBAAoB,cAAc;AACrG;AACA;AACA,wBAAwB;;;;;;;;;;;ACl3BX;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,iBAAiB,mBAAO,CAAC,6DAAQ;AACjC,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,gBAAgB,mBAAO,CAAC,+BAAS;AACjC,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C,0BAA0B,mBAAO,CAAC,mDAAmB;AACrD,6BAA6B,mBAAO,CAAC,yDAAsB;AAC3D,uCAAuC,mBAAO,CAAC,+EAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,sEAAsE,KAAK,IAAI,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iBAAiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE,gEAAgE,QAAQ;AACxE,iEAAiE,KAAK;AACtE,2EAA2E,KAAK;AAChF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC,EAAE,0CAA0C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,+GAA+G;AAC7H,cAAc,oDAAoD,wBAAwB,yBAAyB,6BAA6B;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iBAAiB,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,wBAAwB,GAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC,iBAAiB;AACjB,6BAA6B;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,EAAE,KAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG,cAAc,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B","sources":["webpack://jupyter-simple-extension/./lib/api-client.js","webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/globals.js","webpack://jupyter-simple-extension/./lib/icons.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/markdown-config.js","webpack://jupyter-simple-extension/./lib/popup-menu-manager.js","webpack://jupyter-simple-extension/./lib/sidebar-widget.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\n/**\n * API client for interacting with the backend LLM service\n */\nclass ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\nexports.ApiClient = ApiClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CellContextTracker = void 0;\n/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nclass CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\nexports.CellContextTracker = CellContextTracker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerCommands = registerCommands;\nconst icons_1 = require(\"./icons\");\n/**\n * Registers commands for the extension\n */\nfunction registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: icons_1.extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globals = void 0;\nexports.initGlobals = initGlobals;\n/**\n * Global references to key components in the application\n */\nexports.globals = {};\n/**\n * Initialize global references\n */\nfunction initGlobals(app, notebookTracker) {\n    exports.globals.app = app;\n    exports.globals.notebookTracker = notebookTracker;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extensionIcon = void 0;\nconst ui_components_1 = require(\"@jupyterlab/ui-components\");\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexports.extensionIcon = new ui_components_1.LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ApiClient = void 0;\nconst launcher_1 = require(\"@jupyterlab/launcher\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst docmanager_1 = require(\"@jupyterlab/docmanager\");\nconst sidebar_widget_1 = require(\"./sidebar-widget\");\nconst globals_1 = require(\"./globals\");\nconst commands_1 = require(\"./commands\");\nconst cell_context_tracker_1 = require(\"./cell-context-tracker\");\n// import { ApiClient } from './api-client';\n// Import the main CSS file\nrequire(\"../style/index.css\");\n// Export ApiClient for use by other components\nvar api_client_1 = require(\"./api-client\");\nObject.defineProperty(exports, \"ApiClient\", { enumerable: true, get: function () { return api_client_1.ApiClient; } });\n/**\n * Initialization data for the jupyter-simple-extension extension.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references\n        (0, globals_1.initGlobals)(jupyterApp, tracker);\n        // Initialize cell context tracker\n        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget\n        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands\n        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexports.default = plugin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.configureMarked = configureMarked;\nexports.preprocessMarkdown = preprocessMarkdown;\nconst marked_1 = require(\"marked\");\n/**\n * Configure marked with better rendering options for code blocks\n */\nfunction configureMarked() {\n    // Configure marked options\n    marked_1.marked.setOptions({\n        gfm: true, // Enable GitHub Flavored Markdown\n        breaks: true, // Add <br> on single line breaks\n        pedantic: false, // Conform to original markdown spec\n        async: false, // Disable async rendering\n        silent: false // Enable error reporting\n    });\n}\n/**\n * Pre-process markdown text to fix common issues with streaming content\n */\nfunction preprocessMarkdown(text) {\n    // Normalize line endings\n    const normalizedText = text.replace(/\\r\\n/g, '\\n');\n    // Handle code blocks first\n    let inCodeBlock = false;\n    const lines = normalizedText.split('\\n');\n    const processedLines = lines.map((line, i) => {\n        // Check for code block markers\n        if (line.trim().startsWith('```')) {\n            inCodeBlock = !inCodeBlock;\n            // Preserve language specification\n            return line.trim();\n        }\n        // If we're in a code block, preserve the line as is\n        if (inCodeBlock) {\n            return line;\n        }\n        // Outside code blocks:\n        // 1. Handle list items with proper spacing\n        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines\n        let processed = line;\n        // Handle dash list items by ensuring they have a space after the dash\n        processed = processed.replace(/(\\s*)-(\\S)/g, '$1- $2');\n        // Handle mixed space/dash issues - ensure proper newlines before list items\n        processed = processed.replace(/([^\\n\\s])-\\s/g, '$1\\n- ');\n        return processed;\n    });\n    // Join lines and ensure code blocks are properly formatted\n    let result = processedLines.join('\\n');\n    // Handle empty code blocks (add a space so they render properly)\n    result = result.replace(/```(.*)\\n```/g, '```$1\\n \\n```');\n    return result;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopupMenuManager = void 0;\nconst globals_1 = require(\"./globals\");\n/**\n * Manages the state and interactions of the multi-level popup menu.\n */\nclass PopupMenuManager {\n    constructor(docManager, widgetNode, callbacks) {\n        this.currentMenuLevel = 'top';\n        this.currentMenuPath = '';\n        this.menuHistory = [];\n        this.currentNotebook = null;\n        this.selectedMenuItemIndex = -1; // Track currently selected menu item\n        this.isRenderingContent = false; // Flag to prevent recursive renders\n        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders\n        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];\n        this.fileCache = new Map();\n        this.docManager = docManager;\n        this.widgetNode = widgetNode;\n        this.callbacks = callbacks;\n        this.popupMenuContainer = document.createElement('div');\n        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';\n        this.popupMenuContainer.style.display = 'none';\n        // Attach to the widget node instead of the body\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Create search input\n        this.searchInput = document.createElement('input');\n        this.searchInput.type = 'text';\n        this.searchInput.placeholder = 'Search...';\n        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling\n        // Use 'input' event instead of directly re-rendering on every keystroke\n        this.searchInput.addEventListener('input', () => {\n            // Only re-render if the search term has actually changed\n            if (this.searchInput.value !== this.lastSearchTerm) {\n                this.lastSearchTerm = this.searchInput.value;\n                this.renderMenuContent();\n            }\n        });\n        // Handle keydown in search input to stop propagation for navigation keys\n        this.searchInput.addEventListener('keydown', (event) => {\n            console.log(`POPUP Search KeyDown: Key='${event.key}'`);\n            // IMPORTANT: Prevent these keys from being captured by the document handler\n            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {\n                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);\n                if (event.key === 'Escape') {\n                    // Handle Escape directly here\n                    this.hidePopupMenu();\n                }\n                else if (event.key === 'Enter') {\n                    // Maybe select first item on Enter?\n                    const menuItems = this.getMenuItems();\n                    if (menuItems.length > 0) {\n                        this.selectedMenuItemIndex = 0;\n                        this.updateSelectionHighlight();\n                        // Optionally activate the item:\n                        // menuItems[0].click(); \n                    }\n                }\n                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                    // Move to first/last menu item\n                    // The blur() will be handled by main key handler\n                }\n                event.stopPropagation();\n            }\n            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys\n            // This allows default behavior to work properly\n        }, true); // Use capture phase\n        document.addEventListener('click', this.handleDocumentClick.bind(this), true);\n        // IMPORTANT: Use a separate bound function for the document keydown\n        // so we can remove the exact same listener later\n        this.boundHandleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener('keydown', this.boundHandleKeyDown, true);\n        if (globals_1.globals.notebookTracker) {\n            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;\n            globals_1.globals.notebookTracker.currentChanged.connect((_, notebook) => {\n                this.currentNotebook = notebook;\n            });\n        }\n    }\n    dispose() {\n        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);\n        // Remove using the exact same bound function\n        document.removeEventListener('keydown', this.boundHandleKeyDown, true);\n        // Remove from widgetNode if attached\n        if (this.popupMenuContainer.parentNode === this.widgetNode) {\n            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);\n        }\n    }\n    handleDocumentClick(event) {\n        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {\n            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');\n            if (atButton && atButton.contains(event.target)) {\n                console.log('POPUP: Click was on the @ button, not hiding.');\n                return;\n            }\n            console.log('POPUP: Click detected outside the menu.');\n            this.hidePopupMenu();\n        }\n    }\n    async showPopupMenu(x, y) {\n        console.log(`POPUP: Showing menu at (${x}, ${y})`);\n        // Store the initial anchor point for positioning\n        this._anchorX = x;\n        this._anchorY = y;\n        if (this.popupMenuContainer.style.display === 'none') {\n            this.currentMenuLevel = 'top';\n            this.currentMenuPath = '';\n            this.menuHistory = [];\n            this.searchInput.value = ''; // Clear search on show\n            this.lastSearchTerm = ''; // Reset last search term\n            await this.setCurrentDirectoryPath();\n        }\n        await this.renderMenuContent();\n        // Ensure it's attached to the widget node if somehow detached\n        this.widgetNode.appendChild(this.popupMenuContainer);\n        // Position the popup menu - handled in updatePopupPosition\n        this.updatePopupPosition();\n        // Focus the search input if we are in file/directory view, otherwise focus the first item\n        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n            setTimeout(() => {\n                // Focus after timeout to ensure DOM is ready\n                this.searchInput.focus();\n                console.log('POPUP: Focused search input');\n            }, 50); // Slightly longer timeout\n            this.selectedMenuItemIndex = -1; // Don't select an item if search is focused\n        }\n        else {\n            // Reset and select the first menu item for top level\n            this.selectedMenuItemIndex = -1;\n            setTimeout(() => this.selectNextMenuItem(), 50);\n        }\n    }\n    hidePopupMenu() {\n        if (this.popupMenuContainer.style.display !== 'none') {\n            console.log('POPUP: Hiding menu.');\n            this.popupMenuContainer.style.display = 'none';\n            // No need to explicitly remove from widgetNode unless causing issues\n            // If performance becomes an issue with many menus, consider removing/re-adding\n            // if (this.popupMenuContainer.parentNode === this.widgetNode) {\n            //     this.widgetNode.removeChild(this.popupMenuContainer);\n            // }\n        }\n    }\n    async renderMenuContent() {\n        // Prevent recursive renders\n        if (this.isRenderingContent) {\n            console.log('POPUP: Skipping render - already rendering');\n            return;\n        }\n        this.isRenderingContent = true;\n        try {\n            // Clear existing content\n            while (this.popupMenuContainer.firstChild) {\n                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);\n            }\n            // If not at top level, add a search input for filtering items\n            if (this.currentMenuLevel !== 'top') {\n                // Add search input at the top of the menu\n                this.popupMenuContainer.appendChild(this.searchInput);\n                // Path display and back button removed for cleaner UI\n            }\n            // Render different menu content based on current level\n            switch (this.currentMenuLevel) {\n                case 'top':\n                    this.renderTopLevelItems();\n                    break;\n                case 'files':\n                case 'directories':\n                    await this.renderDirectoryBrowserItems();\n                    break;\n                case 'cells':\n                    await this.renderCellItems();\n                    break;\n            }\n            // Reset selection after rendering\n            this.selectedMenuItemIndex = -1;\n            this.updateSelectionHighlight();\n            // Update the position to maintain the fixed bottom edge\n            if (this.popupMenuContainer.style.display !== 'none' && this._anchorX !== undefined && this._anchorY !== undefined) {\n                this.updatePopupPosition();\n            }\n        }\n        catch (error) {\n            console.error('POPUP: Error rendering menu content', error);\n        }\n        finally {\n            this.isRenderingContent = false;\n        }\n    }\n    renderTopLevelItems() {\n        const topLevelCommands = [\n            { label: 'Code', description: '', actionId: 'insert-code' },\n            { label: 'Cells', description: '', actionId: 'browse-cells' },\n            { label: 'File', description: '', actionId: 'browse-files' },\n            { label: 'Directory', description: '', actionId: 'browse-directories' }\n        ];\n        topLevelCommands.forEach(cmd => {\n            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);\n            this.popupMenuContainer.appendChild(item);\n        });\n    }\n    async renderDirectoryBrowserItems() {\n        var _a;\n        // Get search term\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        // Temporarily add loading item below search/path\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // If contents were already fetched recently and we're just filtering again,\n            // we could potentially cache the results to avoid unnecessary API calls\n            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';\n            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);\n            // Check if still in DOM before trying to remove\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (contents && contents.length > 0) {\n                // Filter based on search term\n                const filteredContents = contents.filter(item => {\n                    return item.name.toLowerCase().includes(searchTerm) ||\n                        item.relativePath.toLowerCase().includes(searchTerm);\n                });\n                if (filteredContents.length > 0) {\n                    filteredContents.forEach(item => {\n                        const itemName = item.name;\n                        const itemType = item.type;\n                        const itemPath = item.path;\n                        const relativePath = item.relativePath;\n                        const icon = itemType === 'directory' ? '📁' : '📄';\n                        let actionId;\n                        if (itemType === 'directory') {\n                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';\n                        }\n                        else { // itemType === 'file'\n                            actionId = 'select-file';\n                        }\n                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');\n                        this.popupMenuContainer.appendChild(menuItem);\n                    });\n                }\n                else {\n                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');\n                    emptyItem.style.pointerEvents = 'none';\n                    this.popupMenuContainer.appendChild(emptyItem);\n                }\n            }\n            else {\n                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n            }\n        }\n        catch (error) {\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading/filtering directory contents:', error);\n        }\n    }\n    /**\n     * Renders all cells from the current notebook\n     */\n    async renderCellItems() {\n        var _a, _b;\n        // Get search term for filtering\n        const searchTerm = this.searchInput.value.toLowerCase().trim();\n        // Create a loading indicator\n        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');\n        loadingItem.style.pointerEvents = 'none';\n        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;\n        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);\n        try {\n            // Check if we have an active notebook\n            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {\n                // Remove loading item\n                if (this.popupMenuContainer.contains(loadingItem)) {\n                    this.popupMenuContainer.removeChild(loadingItem);\n                }\n                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');\n                errorItem.style.color = 'red';\n                errorItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(errorItem);\n                return;\n            }\n            const notebookModel = this.currentNotebook.content.model;\n            const cells = notebookModel.cells;\n            // Remove loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            if (!cells || cells.length === 0) {\n                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');\n                emptyItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(emptyItem);\n                return;\n            }\n            // Process and display each cell\n            let filteredCellCount = 0;\n            for (let i = 0; i < cells.length; i++) {\n                const cell = cells.get(i);\n                const cellType = cell.type;\n                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :\n                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');\n                // Use type casting to avoid TypeScript errors\n                const executionCount = cellType === 'code' ?\n                    (cell.executionCount !== undefined && cell.executionCount !== null ?\n                        cell.executionCount : '*') :\n                    '';\n                // Create a preview of the cell content (truncate if needed)\n                const contentPreview = typeof cellContent === 'string' ?\n                    cellContent :\n                    (Array.isArray(cellContent) ? cellContent.join('\\n') : '');\n                const firstLine = contentPreview.split('\\n')[0] || '';\n                const truncatedContent = firstLine.length > 30 ?\n                    firstLine.substring(0, 30) + '...' :\n                    firstLine;\n                // Create cell label with styled type indicator\n                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';\n                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';\n                // Create menu item for this cell\n                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML\n                'select-cell', i.toString() // Store cell index in path\n                );\n                // Create styled content with HTML elements\n                const typeSpan = document.createElement('span');\n                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;\n                typeSpan.textContent = typeIndicator;\n                const execSpan = document.createElement('span');\n                execSpan.className = 'cell-exec-count';\n                execSpan.textContent = executionDisplay;\n                execSpan.style.marginRight = '8px';\n                const contentSpan = document.createElement('span');\n                contentSpan.className = 'cell-content-preview';\n                contentSpan.textContent = truncatedContent;\n                // Get the label span (first child of the menu item)\n                const labelSpan = cellItem.querySelector('span');\n                if (labelSpan) {\n                    labelSpan.textContent = ''; // Clear existing text\n                    labelSpan.appendChild(typeSpan);\n                    if (executionDisplay) {\n                        labelSpan.appendChild(execSpan);\n                    }\n                    labelSpan.appendChild(contentSpan);\n                }\n                // Construct full searchable text\n                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();\n                // Filter by search term if one is provided\n                if (searchTerm && !searchableText.includes(searchTerm)) {\n                    continue;\n                }\n                this.popupMenuContainer.appendChild(cellItem);\n                filteredCellCount++;\n            }\n            if (filteredCellCount === 0) {\n                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');\n                noMatchItem.style.pointerEvents = 'none';\n                this.popupMenuContainer.appendChild(noMatchItem);\n            }\n        }\n        catch (error) {\n            // Clean up loading indicator\n            if (this.popupMenuContainer.contains(loadingItem)) {\n                this.popupMenuContainer.removeChild(loadingItem);\n            }\n            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');\n            errorItem.style.color = 'red';\n            errorItem.style.pointerEvents = 'none';\n            this.popupMenuContainer.appendChild(errorItem);\n            console.error('POPUP: Error loading notebook cells:', error);\n        }\n    }\n    createMenuItem(text, actionId, path = '', description = '') {\n        const item = document.createElement('div');\n        item.className = 'jp-llm-ext-popup-menu-item';\n        item.dataset.actionId = actionId;\n        if (path) {\n            item.dataset.path = path;\n        }\n        item.onclick = (event) => this.handleMenuClick(event);\n        const labelSpan = document.createElement('span');\n        labelSpan.textContent = text;\n        item.appendChild(labelSpan);\n        if (description) {\n            const pathSpan = document.createElement('span');\n            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';\n            pathSpan.textContent = description;\n            pathSpan.style.fontSize = '0.85em';\n            pathSpan.style.color = 'var(--jp-ui-font-color2)';\n            pathSpan.style.marginLeft = '8px';\n            pathSpan.style.opacity = '0.8';\n            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed\n            item.appendChild(pathSpan);\n        }\n        return item;\n    }\n    async handleMenuClick(event) {\n        const target = event.currentTarget;\n        const actionId = target.dataset.actionId;\n        const path = target.dataset.path || '';\n        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);\n        switch (actionId) {\n            case 'navigate-back':\n                this.navigateBackMenu();\n                break;\n            case 'insert-code': {\n                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;\n                if (selectedText) {\n                    this.callbacks.insertCode(selectedText);\n                }\n                else {\n                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;\n                    if (cellContent) {\n                        this.callbacks.insertCode(cellContent);\n                    }\n                }\n                this.hidePopupMenu();\n                break;\n            }\n            case 'browse-cells':\n                await this.navigateMenu('cells', '');\n                this.searchInput.value = '';\n                break;\n            case 'browse-files':\n                await this.navigateMenu('files', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'browse-directories':\n                await this.navigateMenu('directories', this.currentMenuPath || '');\n                // Clear search when changing view type\n                this.searchInput.value = '';\n                break;\n            case 'select-cell':\n                if (path) {\n                    const cellIndex = parseInt(path);\n                    if (!isNaN(cellIndex) && this.callbacks.insertCellByIndex) {\n                        this.callbacks.insertCellByIndex(cellIndex);\n                        this.hidePopupMenu();\n                    }\n                    else {\n                        console.error('POPUP: Invalid cell index or callback missing.');\n                    }\n                }\n                break;\n            case 'select-file':\n                if (path) {\n                    this.callbacks.insertFilePath(path);\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: File selected but path is missing.');\n                }\n                break;\n            case 'select-directory-navigate': // New action to navigate into dir when in file view\n                if (path) {\n                    // Clear the file cache for the specific directory to force a refresh\n                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;\n                    this.fileCache.delete(cacheKey);\n                    // Make sure we're passing the correct level type\n                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?\n                        this.currentMenuLevel : 'files';\n                    await this.navigateMenu(level, path);\n                    this.searchInput.value = ''; // Clear search on navigation\n                }\n                else {\n                    console.error('POPUP: Directory selected for navigation but path is missing.');\n                }\n                break;\n            case 'select-directory-callback': // New action to select dir when in directory view\n                if (path) {\n                    this.callbacks.insertDirectoryPath(path); // Use the callback\n                    this.hidePopupMenu();\n                }\n                else {\n                    console.error('POPUP: Directory selected for callback but path is missing.');\n                }\n                break;\n            case 'placeholder-action':\n                console.log('Placeholder action triggered.');\n                this.hidePopupMenu();\n                break;\n            case 'loading':\n            case 'empty':\n            case 'error':\n                break;\n            default:\n                console.warn('Unknown menu action:', actionId);\n                this.hidePopupMenu();\n                break;\n        }\n        event.stopPropagation();\n    }\n    async navigateMenu(level, path) {\n        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);\n        // Only push history if we are actually moving to a new state\n        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {\n            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });\n        }\n        this.currentMenuLevel = level;\n        this.currentMenuPath = path;\n        // Don't clear search on programmatic navigation (like back button)\n        // this.searchInput.value = ''; // Maybe keep search term?\n        await this.renderMenuContent();\n        // Focus search input after navigating to file/dir view\n        if (level === 'files' || level === 'directories') {\n            setTimeout(() => this.searchInput.focus(), 0);\n            this.selectedMenuItemIndex = -1; // Reset selection\n        }\n        else {\n            // Select first item if navigating back to top level\n            this.selectedMenuItemIndex = -1;\n            setTimeout(() => this.selectNextMenuItem(), 0);\n        }\n    }\n    navigateBackMenu() {\n        const previousState = this.menuHistory.pop();\n        if (previousState) {\n            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);\n            this.currentMenuLevel = previousState.level;\n            this.currentMenuPath = previousState.path;\n            // Don't clear search on back navigation\n            this.renderMenuContent().then(() => {\n                // Focus search input if going back to file/dir view\n                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                    setTimeout(() => this.searchInput.focus(), 0);\n                    this.selectedMenuItemIndex = -1; // Reset selection\n                }\n                else {\n                    // Select first item if going back to top level\n                    this.selectedMenuItemIndex = -1;\n                    setTimeout(() => this.selectNextMenuItem(), 0);\n                }\n            });\n        }\n        else {\n            console.log('POPUP: Already at the top level.');\n            this.hidePopupMenu();\n        }\n    }\n    async listCurrentDirectoryContents(basePath, filterType) {\n        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);\n        // Check cache first\n        const cacheKey = `${basePath}:${filterType || 'all'}`;\n        if (this.fileCache.has(cacheKey)) {\n            console.log('POPUP: Using cached directory contents');\n            return this.fileCache.get(cacheKey) || null;\n        }\n        try {\n            const effectivePath = basePath === '/' ? '' : basePath;\n            // Ensure trailing slash removed for consistency unless it's root\n            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;\n            // Result array that will hold all files and directories\n            let allResults = [];\n            // Get the base directory contents (non-recursive)\n            const baseContents = await this.docManager.services.contents.get(pathForApi || '');\n            if (baseContents.type !== 'directory') {\n                console.error('Path is not a directory:', basePath);\n                return null;\n            }\n            // Process base directory items\n            for (const item of baseContents.content) {\n                const itemType = item.type === 'directory' ? 'directory' : 'file';\n                // Add directories if we're listing directories or both\n                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {\n                    allResults.push({\n                        name: item.name,\n                        path: item.path,\n                        type: 'directory',\n                        relativePath: `./${item.name}`\n                    });\n                }\n                // Add files if we're listing files and the extension is allowed\n                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {\n                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();\n                    if (this.allowedExtensions.includes(fileExt)) {\n                        allResults.push({\n                            name: item.name,\n                            path: item.path,\n                            type: 'file',\n                            relativePath: `./${item.name}`\n                        });\n                    }\n                }\n            }\n            // Sort the results appropriately\n            allResults = allResults.sort((a, b) => {\n                // If listing directories only, sort alphabetically\n                if (filterType === 'directory') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing files only, sort alphabetically\n                if (filterType === 'file') {\n                    return a.name.localeCompare(b.name);\n                }\n                // If listing both, sort directories first, then files alphabetically\n                if (a.type === 'directory' && b.type !== 'directory')\n                    return -1;\n                if (a.type !== 'directory' && b.type === 'directory')\n                    return 1;\n                return a.name.localeCompare(b.name);\n            });\n            // Cache the results for future use\n            this.fileCache.set(cacheKey, allResults);\n            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);\n            return allResults;\n        }\n        catch (error) {\n            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);\n            return null;\n        }\n    }\n    async setCurrentDirectoryPath() {\n        var _a;\n        let dirPath = null;\n        const app = globals_1.globals.app;\n        if (!app) {\n            console.error('POPUP: Application reference not available');\n            this.currentMenuPath = '';\n            return;\n        }\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                dirPath = this.getParentDirectory(path);\n                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {\n            const notebookPath = this.currentNotebook.context.path;\n            if (typeof notebookPath === 'string') {\n                dirPath = this.getParentDirectory(notebookPath);\n                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);\n            }\n        }\n        if (dirPath === null) {\n            try {\n                const leftWidgets = Array.from(app.shell.widgets('left'));\n                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');\n                if (fileBrowserWidget && ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path)) {\n                    dirPath = fileBrowserWidget.model.path;\n                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);\n                }\n                else {\n                    console.log('POPUP: File browser widget path not directly accessible.');\n                }\n            }\n            catch (e) {\n                console.warn('POPUP: Could not get path from file browser.', e);\n            }\n        }\n        if (dirPath === null) {\n            dirPath = '';\n            console.log('POPUP: Falling back to server root path.');\n        }\n        this.currentMenuPath = dirPath;\n        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);\n    }\n    getParentDirectory(path) {\n        if (!path)\n            return '';\n        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\\\\\'));\n        if (lastSlash === -1)\n            return ''; // No directory part, likely root or just a filename\n        return path.substring(0, lastSlash);\n    }\n    /**\n     * Handle keyboard navigation when the popup menu is shown\n     */\n    handleKeyDown(event) {\n        var _a;\n        // Skip if menu not visible\n        if (this.popupMenuContainer.style.display === 'none') {\n            return;\n        }\n        console.log(`POPUP KeyDown: Key='${event.key}', Target='${(_a = event.target) === null || _a === void 0 ? void 0 : _a.tagName}', SearchFocused='${document.activeElement === this.searchInput}'`);\n        // Special handling for when search input is focused\n        if (document.activeElement === this.searchInput) {\n            // The input's own keydown handler will handle most keys\n            // But for certain keys like arrow keys, we may need to move focus\n            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n                // Move selection to first/last item\n                event.preventDefault();\n                event.stopPropagation();\n                // Delay before moving focus - this gives time for the search input's\n                // own keydown handler to process the key first\n                setTimeout(() => {\n                    if (event.key === 'ArrowDown') {\n                        this.searchInput.blur();\n                        this.selectNextMenuItem();\n                    }\n                    else { // ArrowUp\n                        this.searchInput.blur();\n                        this.selectPreviousMenuItem();\n                    }\n                }, 0);\n                return;\n            }\n            // IMPORTANT: For Backspace in search input, just return without handling\n            // Let the default behavior happen\n            if (event.key === 'Backspace') {\n                // Just perform default behavior in search input\n                return;\n            }\n            // Let all other keys be handled by the search input's own handler\n            return;\n        }\n        // From here, search input is NOT focused\n        const menuItems = this.getMenuItems();\n        switch (event.key) {\n            case 'ArrowDown':\n                if (menuItems.length > 0) {\n                    console.log('POPUP KeyDown (Menu Focused): ArrowDown');\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.selectNextMenuItem();\n                }\n                break;\n            case 'ArrowUp':\n                if (menuItems.length > 0) {\n                    console.log('POPUP KeyDown (Menu Focused): ArrowUp');\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.selectPreviousMenuItem();\n                }\n                break;\n            case 'Backspace':\n                console.log('POPUP KeyDown (Menu Focused): Backspace');\n                // Only prevent default and navigate back if we have history\n                if (this.menuHistory.length > 0) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.navigateBackMenu();\n                }\n                else {\n                    console.log('POPUP KeyDown (Menu Focused): No history, allowing Backspace default action');\n                    // Allow default - don't prevent or stop propagation\n                }\n                break;\n            case 'Enter':\n                console.log('POPUP KeyDown (Menu Focused): Enter');\n                // Only activate if an item is selected\n                if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    menuItems[this.selectedMenuItemIndex].click();\n                }\n                break;\n            case 'Tab':\n                console.log('POPUP KeyDown (Menu Focused): Tab');\n                // Basic Tab support: move focus between search and first/last item\n                event.preventDefault();\n                event.stopPropagation();\n                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {\n                    this.searchInput.focus();\n                    this.deselectAllMenuItems(); // Deselect items when search gets focus via Tab\n                }\n                else {\n                    // Maybe close menu on Tab from top level? Or do nothing.\n                    this.hidePopupMenu();\n                }\n                break;\n            case 'Escape':\n                console.log('POPUP KeyDown (Menu Focused): Escape');\n                event.preventDefault();\n                event.stopPropagation();\n                this.hidePopupMenu();\n                break;\n            default:\n                console.log(`POPUP KeyDown (Menu Focused): Default key '${event.key}'`);\n                // If typing a character and in file/dir view, focus search\n                if ((this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') &&\n                    event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {\n                    event.preventDefault(); // Prevent character appearing elsewhere\n                    event.stopPropagation();\n                    this.searchInput.focus();\n                    // Manually append the typed character as focus happens after keydown default action\n                    this.searchInput.value += event.key;\n                    // Trigger input event manually to update list\n                    this.searchInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));\n                }\n                // Allow other keys (e.g., modifiers) to pass through if not handled\n                break;\n        }\n    }\n    updateSelectionHighlight() {\n        const menuItems = this.getMenuItems();\n        console.log(`POPUP updateSelectionHighlight: Highlighting index ${this.selectedMenuItemIndex} among ${menuItems.length} items.`);\n        menuItems.forEach((item, index) => {\n            if (index === this.selectedMenuItemIndex) {\n                if (!item.classList.contains('selected')) {\n                    item.classList.add('selected');\n                    console.log(`POPUP updateSelectionHighlight: Added 'selected' to item ${index}`);\n                    // Ensure item is visible\n                    item.scrollIntoView({ block: 'nearest' });\n                }\n            }\n            else {\n                if (item.classList.contains('selected')) {\n                    item.classList.remove('selected');\n                    console.log(`POPUP updateSelectionHighlight: Removed 'selected' from item ${index}`);\n                }\n            }\n        });\n    }\n    deselectAllMenuItems() {\n        const menuItems = this.getMenuItems();\n        menuItems.forEach(item => item.classList.remove('selected'));\n        this.selectedMenuItemIndex = -1;\n    }\n    selectNextMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (!menuItems.length) {\n            console.log('POPUP selectNext: No items to select.');\n            this.selectedMenuItemIndex = -1; // Ensure index is reset\n            return;\n        }\n        const oldIndex = this.selectedMenuItemIndex;\n        // Deselect current first is handled by updateSelectionHighlight\n        // Move to the next item or loop back to the first\n        this.selectedMenuItemIndex = (this.selectedMenuItemIndex + 1) % menuItems.length;\n        console.log(`POPUP selectNext: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);\n        this.updateSelectionHighlight();\n    }\n    selectPreviousMenuItem() {\n        const menuItems = this.getMenuItems();\n        if (!menuItems.length) {\n            console.log('POPUP selectPrevious: No items to select.');\n            this.selectedMenuItemIndex = -1; // Ensure index is reset\n            return;\n        }\n        const oldIndex = this.selectedMenuItemIndex;\n        // Deselect current first is handled by updateSelectionHighlight\n        // Move to the previous item or loop to the last\n        this.selectedMenuItemIndex = this.selectedMenuItemIndex <= 0 ?\n            menuItems.length - 1 : this.selectedMenuItemIndex - 1;\n        console.log(`POPUP selectPrevious: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);\n        this.updateSelectionHighlight();\n    }\n    /**\n     * Get all interactive menu items\n     */\n    getMenuItems() {\n        const items = Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));\n        // Filter out non-interactive items like loading, empty, error\n        return items.filter(item => {\n            const actionId = item.dataset.actionId;\n            return actionId !== 'loading' && actionId !== 'empty' && actionId !== 'error';\n        });\n    }\n    /**\n     * Update popup position, keeping the bottom edge fixed at the anchor point\n     */\n    updatePopupPosition() {\n        var _a, _b;\n        // Make sure anchor points are defined\n        const anchorX = (_a = this._anchorX) !== null && _a !== void 0 ? _a : 0;\n        const anchorY = (_b = this._anchorY) !== null && _b !== void 0 ? _b : 0;\n        // Position the popup menu\n        this.popupMenuContainer.style.position = 'absolute';\n        this.popupMenuContainer.style.left = `${anchorX}px`;\n        // Show the menu so we can calculate its height\n        this.popupMenuContainer.style.display = 'block';\n        // Get the actual height after rendering\n        const menuHeight = this.popupMenuContainer.offsetHeight;\n        // Add a small gap (10px) between the bottom of the menu and the trigger point\n        const gap = 10;\n        // Position above the cursor/button to keep bottom edge at the anchor point:\n        // y - gap = bottom edge of popup, so popup top = y - gap - menuHeight\n        this.popupMenuContainer.style.top = `${anchorY - gap - menuHeight}px`;\n        console.log(`POPUP: Positioned menu at height ${menuHeight}px with bottom at ${anchorY - gap}px`);\n    }\n}\nexports.PopupMenuManager = PopupMenuManager;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSidebarWidget = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst marked_1 = require(\"marked\");\nconst dompurify_1 = __importDefault(require(\"dompurify\"));\nconst icons_1 = require(\"./icons\");\nconst globals_1 = require(\"./globals\");\nconst api_client_1 = require(\"./api-client\");\nconst markdown_config_1 = require(\"./markdown-config\");\nconst popup_menu_manager_1 = require(\"./popup-menu-manager\");\nconst highlight_js_1 = __importDefault(require(\"highlight.js\"));\n// Add image cache object for base64 images - COMMENTED OUT, no longer needed for URL method\n// const imageCache: Record<string, string> = {};\n// Configure marked with our settings\n(0, markdown_config_1.configureMarked)();\n/**\n * Main sidebar widget for the AI chat interface\n */\nclass SimpleSidebarWidget extends widgets_1.Widget {\n    constructor(docManager) {\n        super();\n        this.isMarkdownMode = false;\n        this.isInputExpanded = false;\n        this.chatHistory = [];\n        this.currentChatId = '';\n        this.isHistoryViewActive = false;\n        this.hasAtSymbol = false; // Track whether @ symbol is present in input\n        /**\n         * Handles keyboard shortcuts\n         */\n        this.handleKeyDown = (event) => {\n            var _a, _b;\n            // Check for @ key (for context menu) - changed from Ctrl+@\n            if (event.key === '@') {\n                // Prevent default browser behavior\n                event.preventDefault();\n                event.stopPropagation();\n                // Only show menu if input field is focused\n                if (document.activeElement === this.inputField) {\n                    // Get cursor position in input field\n                    const cursorPosition = this.inputField.selectionStart || 0;\n                    const textBeforeCursor = this.inputField.value.substring(0, cursorPosition);\n                    // Calculate position to show menu\n                    const inputRect = this.inputField.getBoundingClientRect();\n                    const lineHeight = parseInt(window.getComputedStyle(this.inputField).lineHeight) || 20;\n                    // Count newlines before cursor to determine vertical position\n                    const linesBeforeCursor = (textBeforeCursor.match(/\\n/g) || []).length;\n                    // Calculate cursor position within current line\n                    const lastNewline = textBeforeCursor.lastIndexOf('\\n');\n                    const charsInCurrentLine = lastNewline === -1 ? cursorPosition : cursorPosition - lastNewline - 1;\n                    // Estimate horizontal position (using average character width)\n                    const charWidth = 8; // Approximate width of a character in pixels\n                    const horizontalOffset = charsInCurrentLine * charWidth;\n                    // Calculate positions\n                    const left = inputRect.left + horizontalOffset;\n                    // Calculate the cursor's vertical position\n                    const cursorTop = inputRect.top + (linesBeforeCursor * lineHeight);\n                    console.log(`Showing popup at cursor position: (${left}, ${cursorTop})`);\n                    // Insert @ symbol at cursor position\n                    const newValue = this.inputField.value.substring(0, cursorPosition) +\n                        '@' +\n                        this.inputField.value.substring(cursorPosition);\n                    this.inputField.value = newValue;\n                    // Update has @ symbol flag\n                    this.hasAtSymbol = true;\n                    // Move cursor after the @ symbol\n                    this.inputField.selectionStart = cursorPosition + 1;\n                    this.inputField.selectionEnd = cursorPosition + 1;\n                    // Show the popup menu above the cursor position\n                    this.popupMenuManager.showPopupMenu(left + 60, cursorTop - 20);\n                    this.showKeyboardShortcutIndicator('Browse cells, code, files, and more');\n                }\n            }\n            // Check for Ctrl+L (for selected code)\n            else if (event.ctrlKey && event.key.toLowerCase() === 'l') {\n                // Prevent default browser behavior\n                event.preventDefault();\n                event.stopPropagation();\n                // Get the current active cell\n                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n                if (!cell || !cell.editor) {\n                    return;\n                }\n                try {\n                    // Get the CodeMirror editor instance\n                    const editor = cell.editor;\n                    const view = editor.editor;\n                    if (!view) {\n                        return;\n                    }\n                    // Check if there's a selection\n                    const state = view.state;\n                    const selection = state.selection;\n                    if (!selection.main.empty) {\n                        // If there's a selection, use @code\n                        const from = selection.main.from;\n                        const to = selection.main.to;\n                        const selectedText = state.doc.sliceString(from, to);\n                        this.appendToInput(`@code ${selectedText}`);\n                        this.showKeyboardShortcutIndicator('Selected code inserted');\n                    }\n                    else {\n                        // If no selection, use @cell\n                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();\n                        if (cellContext) {\n                            this.appendToInput(`@cell ${cellContext.text}`);\n                            this.showKeyboardShortcutIndicator('Cell content inserted');\n                        }\n                    }\n                    // Ensure the sidebar is visible and focused\n                    if (this.isHidden) {\n                        this.show();\n                    }\n                    this.inputField.focus();\n                }\n                catch (error) {\n                    console.error('Error handling keyboard shortcut:', error);\n                }\n            }\n        };\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = icons_1.extensionIcon;\n        this.title.closable = true;\n        // Add the main CSS class for styling\n        this.addClass('jp-llm-ext-sidebar');\n        // Initialize API client\n        this.apiClient = new api_client_1.ApiClient();\n        // Initialize container elements before creating layout\n        this.messageContainer = document.createElement('div');\n        this.inputField = document.createElement('textarea');\n        this.titleInput = document.createElement('input');\n        this.historyContainer = document.createElement('div');\n        this.keyboardShortcutIndicator = document.createElement('div');\n        this.keyboardShortcutIndicator.className = 'jp-llm-ext-keyboard-shortcut-indicator';\n        this.node.appendChild(this.keyboardShortcutIndicator);\n        // Create settings modal\n        this.settingsModalContainer = this.createSettingsModal();\n        this.node.appendChild(this.settingsModalContainer);\n        // Instantiate the PopupMenuManager with callbacks\n        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {\n            insertCode: (code) => this.appendToInput(`code ${code}`),\n            insertCell: (content) => this.appendToInput(`cell ${content}`),\n            insertFilePath: (path) => this.appendToInput(`file ${path}`),\n            insertDirectoryPath: (path) => this.appendToInput(`directory ${path}`), // If needed\n            getSelectedText: () => this.getSelectedText(),\n            getCurrentCellContent: () => this.getCurrentCellContent(),\n            insertCellByIndex: (index) => this.insertCellByIndex(index)\n        });\n        // Create a new chat on start\n        this.createNewChat();\n        this.node.appendChild(this.createLayout());\n        // Pop-up menu will be attached to document.body when shown\n        // Add keyboard shortcut listener\n        document.addEventListener('keydown', this.handleKeyDown);\n    }\n    /**\n     * Shows a visual indicator for keyboard shortcuts\n     */\n    showKeyboardShortcutIndicator(text) {\n        this.keyboardShortcutIndicator.textContent = text;\n        this.keyboardShortcutIndicator.classList.add('visible');\n        // Hide after 1 second\n        setTimeout(() => {\n            this.keyboardShortcutIndicator.classList.remove('visible');\n        }, 1000);\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        // Remove keyboard shortcut listener\n        document.removeEventListener('keydown', this.handleKeyDown);\n        // Remove keyboard shortcut indicator\n        if (this.keyboardShortcutIndicator.parentNode) {\n            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);\n        }\n        // Dispose the popup menu manager\n        if (this.popupMenuManager) {\n            this.popupMenuManager.dispose();\n        }\n        super.dispose();\n    }\n    /**\n     * Creates the main layout for the sidebar\n     */\n    createLayout() {\n        // Create the main container\n        const mainContent = document.createElement('div');\n        // The main class 'jp-llm-ext-sidebar' is added to this.node in the constructor\n        // This container can have its own class if needed for further nesting/styling\n        mainContent.className = 'jp-llm-ext-content-wrapper';\n        // Create title input container\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'jp-llm-ext-title-container';\n        // Set up title input\n        this.titleInput.className = 'chat-title-input'; // Assuming this is styled correctly in CSS\n        this.titleInput.type = 'text';\n        this.titleInput.placeholder = 'Chat title';\n        this.titleInput.value = 'New Chat';\n        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());\n        titleContainer.appendChild(this.titleInput);\n        // Create New Chat & History buttons\n        const newChatButton = document.createElement('button');\n        newChatButton.className = 'jp-Button jp-llm-ext-action-button';\n        newChatButton.textContent = '+ New Chat';\n        newChatButton.title = 'Start a new chat';\n        newChatButton.addEventListener('click', () => this.createNewChat());\n        const historyButton = document.createElement('button');\n        historyButton.className = 'jp-Button jp-llm-ext-action-button';\n        historyButton.textContent = 'History';\n        historyButton.title = 'View chat history';\n        historyButton.addEventListener('click', () => this.toggleHistoryView());\n        // Configure message container\n        this.messageContainer.className = 'jp-llm-ext-message-container';\n        // Configure history container\n        this.historyContainer.className = 'jp-llm-ext-history-container';\n        this.historyContainer.style.display = 'none';\n        // Configure input field (directly used later)\n        this.inputField.placeholder = 'Ask me anything...';\n        this.inputField.rows = 1;\n        this.inputField.className = 'jp-llm-ext-input-field'; // Add class for styling\n        // Add keypress listener to input field\n        this.inputField.addEventListener('keypress', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.handleSendMessage();\n            }\n        });\n        // Add input event listener to detect changes to the input field\n        this.inputField.addEventListener('input', () => {\n            // Check if the @ symbol has been removed\n            const cursorPosition = this.inputField.selectionStart;\n            const textBeforeCursor = this.inputField.value.slice(0, cursorPosition);\n            const hasAtNow = textBeforeCursor.endsWith('@') &&\n                (cursorPosition === 1 || // @ is at start of input\n                    !!textBeforeCursor[cursorPosition - 2].match(/\\s/)); // @ follows whitespace\n            if (this.hasAtSymbol && !hasAtNow) {\n                // @ symbol was present but now it's gone, hide the popup\n                this.popupMenuManager.hidePopupMenu();\n            }\n            this.hasAtSymbol = hasAtNow;\n        });\n        // Create send button container (directly used later)\n        const inputActionsContainer = document.createElement('div');\n        inputActionsContainer.className = 'jp-llm-ext-input-actions-container';\n        // Create send button\n        const sendButton = document.createElement('button');\n        sendButton.className = 'jp-Button jp-llm-ext-send-button';\n        sendButton.textContent = 'Send';\n        sendButton.addEventListener('click', () => this.handleSendMessage());\n        inputActionsContainer.appendChild(sendButton);\n        // Create controls container (Markdown toggle, @, etc.) (directly used later)\n        const controlsContainer = this.createControlsContainer();\n        // Create the new bottom bar container with three rows\n        const bottomBarContainer = document.createElement('div');\n        bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';\n        this.bottomBarContainer = bottomBarContainer;\n        // First row: Controls (Markdown toggle and action buttons)\n        const topRow = document.createElement('div');\n        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';\n        topRow.appendChild(controlsContainer);\n        // Second row: Input field\n        const middleRow = document.createElement('div');\n        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';\n        middleRow.appendChild(this.inputField);\n        // Third row: Action buttons (Send, New Chat, History)\n        const bottomRow = document.createElement('div');\n        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';\n        // Add all buttons to bottom row\n        bottomRow.appendChild(sendButton);\n        bottomRow.appendChild(newChatButton);\n        bottomRow.appendChild(historyButton);\n        // Add all rows to the bottom bar container\n        bottomBarContainer.appendChild(topRow);\n        bottomBarContainer.appendChild(middleRow);\n        bottomBarContainer.appendChild(bottomRow);\n        // Assemble all main components\n        mainContent.appendChild(titleContainer);\n        mainContent.appendChild(this.messageContainer);\n        mainContent.appendChild(this.historyContainer);\n        mainContent.appendChild(bottomBarContainer);\n        return mainContent;\n    }\n    /**\n     * Creates a new chat session\n     */\n    createNewChat() {\n        // Generate a unique ID for the chat\n        const chatId = `chat-${Date.now()}`;\n        // Create a new chat item\n        const newChat = {\n            id: chatId,\n            title: 'New Chat',\n            messages: []\n        };\n        // Add to history\n        this.chatHistory.push(newChat);\n        // Set as current chat\n        this.currentChatId = chatId;\n        // Update title input\n        this.titleInput.value = newChat.title;\n        // Clear message container\n        if (this.messageContainer) {\n            this.messageContainer.innerHTML = '';\n        }\n        // Hide history if it's visible\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView();\n        }\n    }\n    /**\n     * Toggles between chat view and history view\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Show history view, hide message view and bottom bar\n            this.messageContainer.style.display = 'none';\n            this.historyContainer.style.display = 'block';\n            this.bottomBarContainer.style.display = 'none'; // Use class property directly\n            this.titleInput.style.display = 'none';\n            // Populate history\n            this.renderChatHistory();\n        }\n        else {\n            // Show message view and bottom bar, hide history view\n            this.messageContainer.style.display = 'block';\n            this.historyContainer.style.display = 'none';\n            this.bottomBarContainer.style.display = 'flex'; // Use class property directly\n            this.titleInput.style.display = 'block';\n        }\n    }\n    /**\n     * Renders the chat history in the history container\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = '';\n        if (this.chatHistory.length === 0) {\n            const emptyMessage = document.createElement('div');\n            emptyMessage.className = 'jp-llm-ext-empty-history-message';\n            emptyMessage.textContent = 'No chat history yet';\n            this.historyContainer.appendChild(emptyMessage);\n            return;\n        }\n        // Create a list of chat history items\n        this.chatHistory.forEach(chat => {\n            const historyItem = document.createElement('div');\n            historyItem.className = 'jp-llm-ext-history-item';\n            if (chat.id === this.currentChatId) {\n                historyItem.classList.add('jp-llm-ext-active');\n            }\n            // Add title\n            const title = document.createElement('div');\n            title.className = 'jp-llm-ext-history-title';\n            title.textContent = chat.title;\n            // Add message preview\n            const preview = document.createElement('div');\n            preview.className = 'jp-llm-ext-history-preview';\n            const lastMessage = chat.messages[chat.messages.length - 1];\n            preview.textContent = lastMessage\n                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`\n                : 'Empty chat';\n            // Add click event\n            historyItem.addEventListener('click', () => this.loadChat(chat.id));\n            historyItem.appendChild(title);\n            historyItem.appendChild(preview);\n            this.historyContainer.appendChild(historyItem);\n        });\n    }\n    /**\n     * Loads a chat from history\n     */\n    loadChat(chatId) {\n        const chat = this.chatHistory.find(c => c.id === chatId);\n        if (!chat)\n            return;\n        // Set as current chat\n        this.currentChatId = chatId;\n        // Update title\n        this.titleInput.value = chat.title;\n        // Clear and re-populate message container\n        this.messageContainer.innerHTML = '';\n        chat.messages.forEach(msg => {\n            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);\n        });\n        // Switch back to chat view\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView();\n        }\n    }\n    /**\n     * Updates the title of the current chat\n     */\n    updateCurrentChatTitle() {\n        const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n        if (chat) {\n            chat.title = this.titleInput.value;\n            // Add notification that title has been set\n            const notification = document.createElement('div');\n            notification.className = 'jp-llm-ext-toast-notification jp-llm-ext-title-updated';\n            notification.textContent = 'Chat title updated';\n            // Add to the main widget\n            this.node.appendChild(notification);\n            // Animate in\n            setTimeout(() => {\n                notification.classList.add('visible');\n            }, 10);\n            // Remove after delay\n            setTimeout(() => {\n                notification.classList.remove('visible');\n                // Wait for fade out animation to complete before removing\n                setTimeout(() => {\n                    notification.remove();\n                }, 300);\n            }, 2000);\n        }\n    }\n    /**\n     * Creates the controls container with toggles and action buttons\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'jp-llm-ext-controls-container';\n        // Create markdown toggle container\n        const toggleContainer = document.createElement('div');\n        toggleContainer.className = 'jp-llm-ext-toggle-container';\n        // Create markdown toggle\n        const markdownToggle = document.createElement('input');\n        markdownToggle.type = 'checkbox';\n        markdownToggle.id = 'markdown-toggle';\n        // markdownToggle.style.marginRight = '5px'; // Style via CSS\n        markdownToggle.addEventListener('change', (e) => {\n            const target = e.target;\n            this.isMarkdownMode = target.checked;\n            this.inputField.placeholder = this.isMarkdownMode ?\n                'Write markdown here...\\n\\n# Example heading\\n- List item\\n\\n```code block```' :\n                'Ask me anything...';\n        });\n        // Create toggle label\n        const toggleLabel = document.createElement('label');\n        toggleLabel.htmlFor = 'markdown-toggle';\n        toggleLabel.textContent = 'Markdown mode';\n        // toggleLabel.style.fontSize = '12px'; // Style via CSS\n        // Add toggle elements to container\n        toggleContainer.appendChild(markdownToggle);\n        toggleContainer.appendChild(toggleLabel);\n        // Create action buttons container (@, expand, settings)\n        const actionButtonsContainer = document.createElement('div');\n        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';\n        // Create all action buttons\n        const buttons = [\n            {\n                text: '@',\n                title: 'Browse cells, code, files, and more',\n                action: (event) => {\n                    // Get the button's position\n                    const targetButton = event.currentTarget;\n                    const rect = targetButton.getBoundingClientRect();\n                    // Show the popup menu above the button's top edge\n                    this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);\n                    event.preventDefault();\n                    event.stopPropagation();\n                }\n            },\n            { text: '⤢', title: 'Expand input', action: () => this.toggleInputExpansion(actionButtonsContainer.children[3]) },\n            { text: '⚙️', title: 'Settings', action: (event) => { event.preventDefault(); event.stopPropagation(); this.showSettingsModal(); } },\n        ];\n        // Add all buttons to the container\n        buttons.forEach(button => {\n            const btn = this.createButton(button.text, button.title);\n            btn.addEventListener('click', (e) => button.action(e));\n            actionButtonsContainer.appendChild(btn);\n        });\n        // Add toggle and action buttons to the controls container\n        // controlsContainer is now just for these inline controls, above the input field\n        controlsContainer.appendChild(toggleContainer);\n        controlsContainer.appendChild(actionButtonsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Toggles the expansion state of the input field\n     */\n    toggleInputExpansion(button) {\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            // Adjust height based on a class or CSS variable instead of fixed pixels if possible\n            this.inputField.style.height = '200px';\n            this.inputField.style.resize = 'vertical';\n            button.textContent = '⤡';\n            button.title = 'Collapse input';\n        }\n        else {\n            this.inputField.style.height = ''; // Reset height\n            this.inputField.style.resize = 'none';\n            this.inputField.rows = 1; // Ensure it collapses back to 1 row height\n            button.textContent = '⤢';\n            button.title = 'Expand input';\n        }\n    }\n    /**\n     * Helper function to create a button with given text and tooltip\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        button.className = 'jp-Button jp-llm-ext-action-button';\n        return button;\n    }\n    /**\n     * Handles sending a message from the input field\n     */\n    handleSendMessage() {\n        const message = this.inputField.value.trim();\n        if (message) {\n            // Add user message to UI (send as text, not markdown by default for user)\n            this.addMessage(message, 'user', false);\n            this.inputField.value = '';\n            this.inputField.rows = 1; // Reset rows after sending\n            this.inputField.style.height = ''; // Reset height after sending\n            // Reset expanded state if needed after sending\n            if (this.isInputExpanded) {\n                // Find the expand button to reset its state if needed (this might need adjustment based on final structure)\n                const expandButton = this.node.querySelector('.jp-llm-ext-action-buttons-container button[title*=\"Collapse\"]');\n                if (expandButton) {\n                    this.toggleInputExpansion(expandButton); // Collapse after sending\n                }\n                else {\n                    this.inputField.style.height = ''; // Fallback reset\n                    this.inputField.rows = 1;\n                }\n            }\n            // Create a temporary message container for the bot's streaming response\n            const botMessageDiv = document.createElement('div');\n            botMessageDiv.className = 'jp-llm-ext-bot-message';\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            botMessageDiv.appendChild(markdownIndicator);\n            // Create separate divs for streaming text and final markdown\n            const streamingDiv = document.createElement('div');\n            streamingDiv.className = 'streaming-content';\n            streamingDiv.style.whiteSpace = 'pre-wrap';\n            streamingDiv.style.fontFamily = 'monospace';\n            streamingDiv.style.fontSize = '0.9em';\n            botMessageDiv.appendChild(streamingDiv);\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'markdown-content';\n            contentDiv.style.display = 'none'; // Initially hidden\n            botMessageDiv.appendChild(contentDiv);\n            this.messageContainer.appendChild(botMessageDiv);\n            // Variable to collect the complete response\n            let completeResponse = '';\n            // Get cell context if available\n            const cellContext = globals_1.globals.cellContextTracker ?\n                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;\n            // Stream response from API\n            this.apiClient.streamChat(message, { cellContext }, \n            // On each chunk received\n            (chunk) => {\n                completeResponse += chunk;\n                streamingDiv.textContent = completeResponse;\n                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n            }, \n            // On complete\n            () => {\n                // Hide streaming div, show final content div\n                streamingDiv.style.display = 'none';\n                contentDiv.style.display = 'block';\n                // Check if the complete response is an image URL\n                const isImageUrl = completeResponse.startsWith('/images/') && completeResponse.endsWith('.png');\n                if (isImageUrl) {\n                    // Create a container for the image that allows positioning the buttons\n                    const imageContainer = document.createElement('div');\n                    imageContainer.className = 'jp-llm-ext-image-container';\n                    imageContainer.style.position = 'relative';\n                    // Render as an image tag\n                    const img = document.createElement('img');\n                    const fullImageUrl = `http://127.0.0.1:8000${completeResponse}`; // Construct full URL\n                    img.src = fullImageUrl;\n                    img.alt = 'Image from bot';\n                    img.style.maxWidth = '100%';\n                    img.style.height = 'auto';\n                    imageContainer.appendChild(img);\n                    // Add action buttons for the image\n                    const imgActionsDiv = document.createElement('div');\n                    imgActionsDiv.className = 'jp-llm-ext-image-actions';\n                    imgActionsDiv.style.position = 'absolute';\n                    imgActionsDiv.style.bottom = '10px';\n                    imgActionsDiv.style.right = '10px';\n                    imgActionsDiv.style.display = 'flex';\n                    imgActionsDiv.style.gap = '8px';\n                    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';\n                    imgActionsDiv.style.borderRadius = '4px';\n                    imgActionsDiv.style.padding = '4px';\n                    // Copy image button\n                    const copyImgBtn = document.createElement('button');\n                    copyImgBtn.className = 'jp-llm-ext-image-action-button';\n                    copyImgBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                    copyImgBtn.title = 'Copy image to clipboard';\n                    copyImgBtn.addEventListener('click', (event) => {\n                        event.stopPropagation();\n                        this.copyImageToClipboard(fullImageUrl);\n                    });\n                    imgActionsDiv.appendChild(copyImgBtn);\n                    // Add file path button\n                    const addPathBtn = document.createElement('button');\n                    addPathBtn.className = 'jp-llm-ext-image-action-button';\n                    addPathBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                    addPathBtn.title = 'Add image path to current cell';\n                    addPathBtn.addEventListener('click', (event) => {\n                        event.stopPropagation();\n                        this.addMessageToCell(completeResponse); // Adds just the image path to the cell\n                    });\n                    imgActionsDiv.appendChild(addPathBtn);\n                    // Add the buttons to the image container\n                    imageContainer.appendChild(imgActionsDiv);\n                    // Add the image container to the content div\n                    contentDiv.appendChild(imageContainer);\n                    // Save image URL to history (as text)\n                    const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n                    if (chat) {\n                        chat.messages.push({\n                            text: completeResponse, // Store the URL\n                            sender: 'bot',\n                            isMarkdown: false // Treat it as non-markdown for history\n                        });\n                    }\n                }\n                else {\n                    // Try to render markdown\n                    try {\n                        const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);\n                        const rawHtml = marked_1.marked.parse(processedText);\n                        const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n                        contentDiv.innerHTML = sanitizedHtml;\n                        // Check if this is an interrupt message\n                        const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');\n                        if (isInterrupt) {\n                            // Create buttons container\n                            const buttonsContainer = document.createElement('div');\n                            buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';\n                            buttonsContainer.style.marginTop = '12px';\n                            buttonsContainer.style.display = 'flex';\n                            buttonsContainer.style.gap = '8px';\n                            // Create confirm button\n                            const confirmButton = document.createElement('button');\n                            confirmButton.className = 'jp-llm-ext-confirm-button';\n                            confirmButton.textContent = 'Confirm';\n                            confirmButton.style.padding = '6px 12px';\n                            confirmButton.style.background = '#4CAF50';\n                            confirmButton.style.color = 'white';\n                            confirmButton.style.border = 'none';\n                            confirmButton.style.borderRadius = '4px';\n                            confirmButton.style.cursor = 'pointer';\n                            confirmButton.style.fontWeight = 'bold';\n                            confirmButton.addEventListener('click', () => {\n                                // Disable buttons after click\n                                confirmButton.disabled = true;\n                                rejectButton.disabled = true;\n                                confirmButton.style.opacity = '0.5';\n                                rejectButton.style.opacity = '0.5';\n                                // Add \"confirmed\" message as user \n                                this.addMessage('confirmed', 'user', false);\n                                // Add status indicator\n                                const statusIndicator = document.createElement('div');\n                                statusIndicator.className = 'jp-llm-ext-status-indicator';\n                                statusIndicator.innerHTML = `<span class=\"status-icon confirm-icon\">✅</span><span class=\"status-line\"></span><span class=\"status-text\">User confirmed</span><span class=\"status-line\"></span>`;\n                                this.messageContainer.appendChild(statusIndicator);\n                                // Send auto message to API without adding a new user message\n                                this.handleSendAutoMessage('confirmed');\n                            });\n                            // Create reject button\n                            const rejectButton = document.createElement('button');\n                            rejectButton.className = 'jp-llm-ext-reject-button';\n                            rejectButton.textContent = 'Reject';\n                            rejectButton.style.padding = '6px 12px';\n                            rejectButton.style.background = '#F44336';\n                            rejectButton.style.color = 'white';\n                            rejectButton.style.border = 'none';\n                            rejectButton.style.borderRadius = '4px';\n                            rejectButton.style.cursor = 'pointer';\n                            rejectButton.style.fontWeight = 'bold';\n                            rejectButton.addEventListener('click', () => {\n                                // Disable buttons after click\n                                confirmButton.disabled = true;\n                                rejectButton.disabled = true;\n                                confirmButton.style.opacity = '0.5';\n                                rejectButton.style.opacity = '0.5';\n                                // Add \"rejected\" message as user\n                                this.addMessage('rejected', 'user', false);\n                                // Add status indicator\n                                const statusIndicator = document.createElement('div');\n                                statusIndicator.className = 'jp-llm-ext-status-indicator';\n                                statusIndicator.innerHTML = `<span class=\"status-icon reject-icon\">❌</span><span class=\"status-line\"></span><span class=\"status-text\">User rejected</span><span class=\"status-line\"></span>`;\n                                this.messageContainer.appendChild(statusIndicator);\n                                // Send auto message to API without adding a new user message\n                                this.handleSendAutoMessage('rejected');\n                            });\n                            // Add buttons to container\n                            buttonsContainer.appendChild(confirmButton);\n                            buttonsContainer.appendChild(rejectButton);\n                            // Add container below the message\n                            contentDiv.appendChild(buttonsContainer);\n                        }\n                        // Enhance code blocks with language detection and action buttons\n                        const codeBlocks = contentDiv.querySelectorAll('pre code');\n                        codeBlocks.forEach(block => {\n                            var _a;\n                            // Add standard JupyterLab classes for consistency\n                            block.classList.add('jp-RenderedText');\n                            (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');\n                            // Get code content to detect language\n                            const codeContent = block.textContent || '';\n                            // Create code block header for buttons\n                            const codeHeader = document.createElement('div');\n                            codeHeader.className = 'jp-llm-ext-code-header';\n                            // Add language indicator if detected\n                            const language = this.detectLanguage(codeContent);\n                            if (language) {\n                                const langIndicator = document.createElement('span');\n                                langIndicator.className = 'jp-llm-ext-code-language';\n                                langIndicator.textContent = language;\n                                codeHeader.appendChild(langIndicator);\n                                // Add language class for syntax highlighting\n                                block.classList.add(`language-${language}`);\n                                // Apply syntax highlighting\n                                try {\n                                    block.innerHTML = this.highlightCode(codeContent, language);\n                                }\n                                catch (error) {\n                                    console.error('Error applying syntax highlighting:', error);\n                                    // Keep original content if highlighting fails\n                                }\n                            }\n                            else {\n                                // Try auto-detection if no specific language detected\n                                try {\n                                    block.innerHTML = this.highlightCode(codeContent, '');\n                                }\n                                catch (error) {\n                                    console.error('Error applying auto syntax highlighting:', error);\n                                    // Keep original content if highlighting fails\n                                }\n                            }\n                            // Add action buttons to the code header\n                            const actionsDiv = document.createElement('div');\n                            actionsDiv.className = 'jp-llm-ext-code-actions';\n                            // Copy button with icon\n                            const copyButton = document.createElement('button');\n                            copyButton.className = 'jp-llm-ext-code-action-button';\n                            copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                            copyButton.title = 'Copy code to clipboard';\n                            copyButton.addEventListener('click', (event) => {\n                                event.stopPropagation();\n                                this.copyToClipboard(codeContent);\n                            });\n                            actionsDiv.appendChild(copyButton);\n                            // Add to button with icon\n                            const addToButton = document.createElement('button');\n                            addToButton.className = 'jp-llm-ext-code-action-button';\n                            addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                            addToButton.title = 'Add code to current cell';\n                            addToButton.addEventListener('click', (event) => {\n                                event.stopPropagation();\n                                this.addMessageToCell(codeContent);\n                            });\n                            actionsDiv.appendChild(addToButton);\n                            // Add the actions to the header\n                            codeHeader.appendChild(actionsDiv);\n                            // Insert the header before the code block\n                            if (block.parentElement) {\n                                block.parentElement.insertBefore(codeHeader, block);\n                            }\n                        });\n                        // Add action buttons for the bot message (Copy, Add to Cell)\n                        console.log('Adding action buttons to streamed bot message');\n                        const actionsDiv = document.createElement('div');\n                        actionsDiv.className = 'jp-llm-ext-message-actions';\n                        actionsDiv.style.display = 'flex'; // Ensure display is set\n                        // Copy button\n                        const copyButton = document.createElement('button');\n                        copyButton.className = 'jp-llm-ext-message-action-button';\n                        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                        copyButton.title = 'Copy message to clipboard';\n                        copyButton.addEventListener('click', (event) => {\n                            event.stopPropagation();\n                            this.copyMessageToClipboard(completeResponse); // Copy the original markdown\n                        });\n                        actionsDiv.appendChild(copyButton);\n                        // Add to Cell button\n                        const addToButton = document.createElement('button');\n                        addToButton.className = 'jp-llm-ext-message-action-button';\n                        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                        addToButton.title = 'Add message to current cell';\n                        addToButton.addEventListener('click', (event) => {\n                            event.stopPropagation();\n                            this.addMessageToCell(completeResponse); // Add the original markdown\n                        });\n                        actionsDiv.appendChild(addToButton);\n                        botMessageDiv.appendChild(actionsDiv);\n                        console.log('Action buttons added to bot message:', actionsDiv);\n                    }\n                    catch (error) {\n                        contentDiv.textContent = completeResponse;\n                        console.error('Failed to render markdown:', error);\n                    }\n                    // Save markdown to chat history\n                    const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n                    if (chat) {\n                        chat.messages.push({\n                            text: completeResponse,\n                            sender: 'bot',\n                            isMarkdown: true // It's markdown\n                        });\n                    }\n                }\n                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n            }, \n            // On error\n            (error) => {\n                streamingDiv.style.display = 'none';\n                contentDiv.style.display = 'block';\n                contentDiv.innerHTML = `<div class=\"error-message\">Error: ${error.message}</div>`;\n                console.error('API Error:', error);\n            });\n        }\n    }\n    /**\n     * Handles sending an automatic message (like confirmed/rejected) from the UI\n     */\n    handleSendAutoMessage(message) {\n        if (!message.trim())\n            return;\n        // Skip adding user message - the calling function will handle this\n        // Prevent duplication of messages when called from confirm/reject buttons\n        // Add a confirmation/rejection status indicator line only if not already added\n        // by the calling function (checking if this is a direct call)\n        const statusIndicator = document.createElement('div');\n        statusIndicator.className = 'jp-llm-ext-status-indicator';\n        // Set the appropriate icon and text based on the message\n        if (message.toLowerCase() === 'confirmed') {\n            statusIndicator.innerHTML = `<span class=\"status-icon confirm-icon\">✅</span><span class=\"status-line\"></span><span class=\"status-text\">User confirmed</span><span class=\"status-line\"></span>`;\n        }\n        else if (message.toLowerCase() === 'rejected') {\n            statusIndicator.innerHTML = `<span class=\"status-icon reject-icon\">❌</span><span class=\"status-line\"></span><span class=\"status-text\">User rejected</span><span class=\"status-line\"></span>`;\n        }\n        // Create a temporary message container for the bot's streaming response\n        const botMessageDiv = document.createElement('div');\n        botMessageDiv.className = 'jp-llm-ext-bot-message';\n        const markdownIndicator = document.createElement('div');\n        markdownIndicator.textContent = \"MD\";\n        markdownIndicator.className = 'markdown-indicator';\n        botMessageDiv.appendChild(markdownIndicator);\n        // Create separate divs for streaming text and final markdown\n        const streamingDiv = document.createElement('div');\n        streamingDiv.className = 'streaming-content';\n        streamingDiv.style.whiteSpace = 'pre-wrap';\n        streamingDiv.style.fontFamily = 'monospace';\n        streamingDiv.style.fontSize = '0.9em';\n        botMessageDiv.appendChild(streamingDiv);\n        const contentDiv = document.createElement('div');\n        contentDiv.className = 'markdown-content';\n        contentDiv.style.display = 'none'; // Initially hidden\n        botMessageDiv.appendChild(contentDiv);\n        this.messageContainer.appendChild(botMessageDiv);\n        // Variable to collect the complete response\n        let completeResponse = '';\n        // Get cell context if available\n        const cellContext = globals_1.globals.cellContextTracker ?\n            globals_1.globals.cellContextTracker.getCurrentCellContext() : null;\n        // Stream response from API\n        this.apiClient.streamChat(message, // This will be 'confirmed' or 'rejected'\n        { cellContext }, \n        // On each chunk received\n        (chunk) => {\n            completeResponse += chunk;\n            streamingDiv.textContent = completeResponse;\n            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        }, \n        // On complete\n        () => {\n            // Hide streaming div, show final content div\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            // Check if the complete response is an image URL\n            const isImageUrl = completeResponse.trim().startsWith('/images/') &&\n                (completeResponse.trim().endsWith('.png') ||\n                    completeResponse.trim().endsWith('.jpg') ||\n                    completeResponse.trim().endsWith('.jpeg') ||\n                    completeResponse.trim().endsWith('.gif'));\n            if (isImageUrl) {\n                // Create a container for the image\n                const imageContainer = document.createElement('div');\n                imageContainer.className = 'jp-llm-ext-image-container';\n                imageContainer.style.position = 'relative';\n                // Render as an image tag\n                const img = document.createElement('img');\n                const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // Construct full URL\n                img.src = fullImageUrl;\n                img.alt = 'Image from bot';\n                img.style.maxWidth = '100%';\n                img.style.height = 'auto';\n                imageContainer.appendChild(img);\n                // Add action buttons for the image\n                const imgActionsDiv = document.createElement('div');\n                imgActionsDiv.className = 'jp-llm-ext-image-actions';\n                imgActionsDiv.style.position = 'absolute';\n                imgActionsDiv.style.bottom = '10px';\n                imgActionsDiv.style.right = '10px';\n                imgActionsDiv.style.display = 'flex';\n                imgActionsDiv.style.gap = '8px';\n                imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';\n                imgActionsDiv.style.borderRadius = '4px';\n                imgActionsDiv.style.padding = '4px';\n                // Copy image button\n                const copyImgBtn = document.createElement('button');\n                copyImgBtn.className = 'jp-llm-ext-image-action-button';\n                copyImgBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                copyImgBtn.title = 'Copy image to clipboard';\n                copyImgBtn.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    this.copyImageToClipboard(fullImageUrl);\n                });\n                imgActionsDiv.appendChild(copyImgBtn);\n                // Add file path button\n                const addPathBtn = document.createElement('button');\n                addPathBtn.className = 'jp-llm-ext-image-action-button';\n                addPathBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                addPathBtn.title = 'Add image path to current cell';\n                addPathBtn.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    this.addMessageToCell(completeResponse.trim()); // Adds just the image path to the cell\n                });\n                imgActionsDiv.appendChild(addPathBtn);\n                // Add the buttons to the image container\n                imageContainer.appendChild(imgActionsDiv);\n                // Add the image container to the content div\n                contentDiv.appendChild(imageContainer);\n                // Save image URL to history (as text)\n                const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n                if (chat) {\n                    chat.messages.push({\n                        text: completeResponse.trim(), // Store the URL\n                        sender: 'bot',\n                        isMarkdown: false // Treat it as non-markdown for history\n                    });\n                }\n            }\n            else {\n                // Try to render markdown\n                try {\n                    const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);\n                    const rawHtml = marked_1.marked.parse(processedText);\n                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n                    contentDiv.innerHTML = sanitizedHtml;\n                    // Check if this is an interrupt message\n                    const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');\n                    if (isInterrupt) {\n                        // Add confirm/reject buttons (same as in addMessage method)\n                        // Create buttons container\n                        const buttonsContainer = document.createElement('div');\n                        buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';\n                        buttonsContainer.style.marginTop = '12px';\n                        buttonsContainer.style.display = 'flex';\n                        buttonsContainer.style.gap = '8px';\n                        // Create confirm button\n                        const confirmButton = document.createElement('button');\n                        confirmButton.className = 'jp-llm-ext-confirm-button';\n                        confirmButton.textContent = 'Confirm';\n                        confirmButton.style.padding = '6px 12px';\n                        confirmButton.style.background = '#4CAF50';\n                        confirmButton.style.color = 'white';\n                        confirmButton.style.border = 'none';\n                        confirmButton.style.borderRadius = '4px';\n                        confirmButton.style.cursor = 'pointer';\n                        confirmButton.style.fontWeight = 'bold';\n                        confirmButton.addEventListener('click', () => {\n                            // Disable buttons after click\n                            confirmButton.disabled = true;\n                            rejectButton.disabled = true;\n                            confirmButton.style.opacity = '0.5';\n                            rejectButton.style.opacity = '0.5';\n                            // Add \"confirmed\" message as user \n                            this.addMessage('confirmed', 'user', false);\n                            // Add status indicator\n                            const statusIndicator = document.createElement('div');\n                            statusIndicator.className = 'jp-llm-ext-status-indicator';\n                            statusIndicator.innerHTML = `<span class=\"status-icon confirm-icon\">✅</span><span class=\"status-line\"></span><span class=\"status-text\">User confirmed</span><span class=\"status-line\"></span>`;\n                            this.messageContainer.appendChild(statusIndicator);\n                            // Send auto message to API without adding a new user message\n                            this.handleSendAutoMessage('confirmed');\n                        });\n                        // Create reject button\n                        const rejectButton = document.createElement('button');\n                        rejectButton.className = 'jp-llm-ext-reject-button';\n                        rejectButton.textContent = 'Reject';\n                        rejectButton.style.padding = '6px 12px';\n                        rejectButton.style.background = '#F44336';\n                        rejectButton.style.color = 'white';\n                        rejectButton.style.border = 'none';\n                        rejectButton.style.borderRadius = '4px';\n                        rejectButton.style.cursor = 'pointer';\n                        rejectButton.style.fontWeight = 'bold';\n                        rejectButton.addEventListener('click', () => {\n                            // Disable buttons after click\n                            confirmButton.disabled = true;\n                            rejectButton.disabled = true;\n                            confirmButton.style.opacity = '0.5';\n                            rejectButton.style.opacity = '0.5';\n                            // Add \"rejected\" message as user\n                            this.addMessage('rejected', 'user', false);\n                            // Add status indicator\n                            const statusIndicator = document.createElement('div');\n                            statusIndicator.className = 'jp-llm-ext-status-indicator';\n                            statusIndicator.innerHTML = `<span class=\"status-icon reject-icon\">❌</span><span class=\"status-line\"></span><span class=\"status-text\">User rejected</span><span class=\"status-line\"></span>`;\n                            this.messageContainer.appendChild(statusIndicator);\n                            // Send auto message to API without adding a new user message\n                            this.handleSendAutoMessage('rejected');\n                        });\n                        // Add buttons to container\n                        buttonsContainer.appendChild(confirmButton);\n                        buttonsContainer.appendChild(rejectButton);\n                        // Add container below the message\n                        contentDiv.appendChild(buttonsContainer);\n                    }\n                    // Enhance code blocks (existing code)\n                    const codeBlocks = contentDiv.querySelectorAll('pre code');\n                    codeBlocks.forEach(block => {\n                        var _a;\n                        // Add standard JupyterLab classes for consistency\n                        block.classList.add('jp-RenderedText');\n                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');\n                        // Get code content to detect language\n                        const codeContent = block.textContent || '';\n                        // Create code block header for buttons\n                        const codeHeader = document.createElement('div');\n                        codeHeader.className = 'jp-llm-ext-code-header';\n                        // Add language indicator if detected\n                        const language = this.detectLanguage(codeContent);\n                        if (language) {\n                            const langIndicator = document.createElement('span');\n                            langIndicator.className = 'jp-llm-ext-code-language';\n                            langIndicator.textContent = language;\n                            codeHeader.appendChild(langIndicator);\n                            // Add language class for syntax highlighting\n                            block.classList.add(`language-${language}`);\n                            // Apply syntax highlighting\n                            try {\n                                block.innerHTML = this.highlightCode(codeContent, language);\n                            }\n                            catch (error) {\n                                console.error('Error applying syntax highlighting:', error);\n                                // Keep original content if highlighting fails\n                            }\n                        }\n                        else {\n                            // Try auto-detection if no specific language detected\n                            try {\n                                block.innerHTML = this.highlightCode(codeContent, '');\n                            }\n                            catch (error) {\n                                console.error('Error applying auto syntax highlighting:', error);\n                                // Keep original content if highlighting fails\n                            }\n                        }\n                        // Add action buttons to the code header\n                        const actionsDiv = document.createElement('div');\n                        actionsDiv.className = 'jp-llm-ext-code-actions';\n                        // Copy button with icon\n                        const copyButton = document.createElement('button');\n                        copyButton.className = 'jp-llm-ext-code-action-button';\n                        copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                        copyButton.title = 'Copy code to clipboard';\n                        copyButton.addEventListener('click', (event) => {\n                            event.stopPropagation();\n                            this.copyToClipboard(codeContent);\n                        });\n                        actionsDiv.appendChild(copyButton);\n                        // Add to button with icon\n                        const addToButton = document.createElement('button');\n                        addToButton.className = 'jp-llm-ext-code-action-button';\n                        addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                        addToButton.title = 'Add code to current cell';\n                        addToButton.addEventListener('click', (event) => {\n                            event.stopPropagation();\n                            this.addMessageToCell(codeContent);\n                        });\n                        actionsDiv.appendChild(addToButton);\n                        // Add the actions to the header\n                        codeHeader.appendChild(actionsDiv);\n                        // Insert the header before the code block\n                        if (block.parentElement) {\n                            block.parentElement.insertBefore(codeHeader, block);\n                        }\n                    });\n                }\n                catch (error) {\n                    contentDiv.textContent = completeResponse;\n                    console.error('Failed to render markdown:', error);\n                }\n                // Save markdown to chat history\n                const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n                if (chat) {\n                    chat.messages.push({\n                        text: completeResponse,\n                        sender: 'bot',\n                        isMarkdown: true // It's markdown\n                    });\n                }\n            }\n            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        }, \n        // On error\n        (error) => {\n            streamingDiv.style.display = 'none';\n            contentDiv.style.display = 'block';\n            contentDiv.innerHTML = `<div class=\"error-message\">Error: ${error.message}</div>`;\n            console.error('API Error:', error);\n        });\n    }\n    /**\n     * Adds a message to the chat interface\n     */\n    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {\n        console.log('Adding message:', { sender, isMarkdown });\n        const messageDiv = document.createElement('div');\n        messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';\n        // Check if the message is an image URL from our backend\n        const isImageUrl = sender === 'bot' && text.trim().startsWith('/images/') &&\n            (text.trim().endsWith('.png') ||\n                text.trim().endsWith('.jpg') ||\n                text.trim().endsWith('.jpeg') ||\n                text.trim().endsWith('.gif'));\n        if (isImageUrl) {\n            // Create a container for the image that allows positioning the buttons\n            const imageContainer = document.createElement('div');\n            imageContainer.className = 'jp-llm-ext-image-container';\n            imageContainer.style.position = 'relative';\n            // Render as an image tag\n            const img = document.createElement('img');\n            // Construct full URL assuming backend is at http://127.0.0.1:8000\n            // TODO: Make backend URL configurable\n            const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;\n            img.src = fullImageUrl;\n            img.alt = 'Image from bot';\n            img.style.maxWidth = '100%'; // Ensure image fits within the container\n            img.style.height = 'auto';\n            imageContainer.appendChild(img);\n            // Add action buttons for the image\n            const imgActionsDiv = document.createElement('div');\n            imgActionsDiv.className = 'jp-llm-ext-image-actions';\n            imgActionsDiv.style.position = 'absolute';\n            imgActionsDiv.style.bottom = '10px';\n            imgActionsDiv.style.right = '10px';\n            imgActionsDiv.style.display = 'flex';\n            imgActionsDiv.style.gap = '8px';\n            imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';\n            imgActionsDiv.style.borderRadius = '4px';\n            imgActionsDiv.style.padding = '4px';\n            // Copy image button\n            const copyImgBtn = document.createElement('button');\n            copyImgBtn.className = 'jp-llm-ext-image-action-button';\n            copyImgBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n            copyImgBtn.title = 'Copy image to clipboard';\n            copyImgBtn.addEventListener('click', (event) => {\n                event.stopPropagation();\n                this.copyImageToClipboard(fullImageUrl);\n            });\n            imgActionsDiv.appendChild(copyImgBtn);\n            // Add file path button\n            const addPathBtn = document.createElement('button');\n            addPathBtn.className = 'jp-llm-ext-image-action-button';\n            addPathBtn.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n            addPathBtn.title = 'Add image path to current cell';\n            addPathBtn.addEventListener('click', (event) => {\n                event.stopPropagation();\n                this.addMessageToCell(text.trim()); // Adds just the image path to the cell\n            });\n            imgActionsDiv.appendChild(addPathBtn);\n            // Add the buttons to the image container\n            imageContainer.appendChild(imgActionsDiv);\n            // Add the image container to the message div\n            messageDiv.appendChild(imageContainer);\n        }\n        else if (isMarkdown || sender === 'bot') {\n            // Render as markdown (existing logic)\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            messageDiv.appendChild(markdownIndicator);\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'markdown-content';\n            try {\n                // Process the text to handle common markdown issues\n                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);\n                // Parse markdown to HTML\n                const rawHtml = marked_1.marked.parse(processedText);\n                // Sanitize HTML to prevent XSS\n                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);\n                // Set content\n                contentDiv.innerHTML = sanitizedHtml;\n                // Enhance code blocks with language detection and action buttons\n                const codeBlocks = contentDiv.querySelectorAll('pre code');\n                codeBlocks.forEach(block => {\n                    var _a;\n                    // Add standard JupyterLab classes for consistency\n                    block.classList.add('jp-RenderedText');\n                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');\n                    // Get code content to detect language\n                    const codeContent = block.textContent || '';\n                    // Create code block header for buttons\n                    const codeHeader = document.createElement('div');\n                    codeHeader.className = 'jp-llm-ext-code-header';\n                    // Add language indicator if detected\n                    const language = this.detectLanguage(codeContent);\n                    if (language) {\n                        const langIndicator = document.createElement('span');\n                        langIndicator.className = 'jp-llm-ext-code-language';\n                        langIndicator.textContent = language;\n                        codeHeader.appendChild(langIndicator);\n                        // Add language class for syntax highlighting\n                        block.classList.add(`language-${language}`);\n                        // Apply syntax highlighting\n                        try {\n                            block.innerHTML = this.highlightCode(codeContent, language);\n                        }\n                        catch (error) {\n                            console.error('Error applying syntax highlighting:', error);\n                            // Keep original content if highlighting fails\n                        }\n                    }\n                    else {\n                        // Try auto-detection if no specific language detected\n                        try {\n                            block.innerHTML = this.highlightCode(codeContent, '');\n                        }\n                        catch (error) {\n                            console.error('Error applying auto syntax highlighting:', error);\n                            // Keep original content if highlighting fails\n                        }\n                    }\n                    // Add action buttons to the code header\n                    const actionsDiv = document.createElement('div');\n                    actionsDiv.className = 'jp-llm-ext-code-actions';\n                    // Copy button with icon\n                    const copyButton = document.createElement('button');\n                    copyButton.className = 'jp-llm-ext-code-action-button';\n                    copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                    copyButton.title = 'Copy code to clipboard';\n                    copyButton.addEventListener('click', (event) => {\n                        event.stopPropagation();\n                        this.copyToClipboard(codeContent);\n                    });\n                    actionsDiv.appendChild(copyButton);\n                    // Add to button with icon\n                    const addToButton = document.createElement('button');\n                    addToButton.className = 'jp-llm-ext-code-action-button';\n                    addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                    addToButton.title = 'Add code to current cell';\n                    addToButton.addEventListener('click', (event) => {\n                        event.stopPropagation();\n                        this.addMessageToCell(codeContent);\n                    });\n                    actionsDiv.appendChild(addToButton);\n                    // Add the actions to the header\n                    codeHeader.appendChild(actionsDiv);\n                    // Insert the header before the code block\n                    if (block.parentElement) {\n                        block.parentElement.insertBefore(codeHeader, block);\n                    }\n                });\n            }\n            catch (error) {\n                contentDiv.textContent = text;\n                console.error('Failed to render markdown:', error);\n            }\n            messageDiv.appendChild(contentDiv);\n            // Add action buttons for bot messages (only for the whole message, not code blocks)\n            if (sender === 'bot') {\n                console.log('Adding action buttons to bot message'); // Debug log\n                const actionsDiv = document.createElement('div');\n                actionsDiv.className = 'jp-llm-ext-message-actions';\n                // Copy button with icon\n                const copyButton = document.createElement('button');\n                copyButton.className = 'jp-llm-ext-message-action-button';\n                copyButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>';\n                copyButton.title = 'Copy message to clipboard';\n                copyButton.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    this.copyMessageToClipboard(text);\n                });\n                actionsDiv.appendChild(copyButton);\n                // Add to button with icon\n                const addToButton = document.createElement('button');\n                addToButton.className = 'jp-llm-ext-message-action-button';\n                addToButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect><path d=\"M12 11v6\"></path><path d=\"M9 14h6\"></path></svg>';\n                addToButton.title = 'Add message to current cell';\n                addToButton.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    this.addMessageToCell(text);\n                });\n                actionsDiv.appendChild(addToButton);\n                // Add buttons to message\n                messageDiv.appendChild(actionsDiv);\n                console.log('Action buttons added to message:', actionsDiv); // Debug log\n            }\n        }\n        else {\n            messageDiv.textContent = text;\n        }\n        this.messageContainer.appendChild(messageDiv);\n        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        // Save to chat history\n        if (saveToHistory) {\n            const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n            if (chat) {\n                chat.messages.push({\n                    text,\n                    sender,\n                    isMarkdown: isMarkdown || sender === 'bot'\n                });\n            }\n        }\n    }\n    /**\n     * Copies message content to clipboard\n     */\n    copyMessageToClipboard(text) {\n        try {\n            navigator.clipboard.writeText(text).then(() => {\n                console.log('Content copied to clipboard');\n                // Find the button element that was clicked\n                const buttons = document.querySelectorAll('.jp-llm-ext-message-action-button');\n                let clickedButton = null;\n                for (let i = 0; i < buttons.length; i++) {\n                    const button = buttons[i];\n                    if (button.title === 'Copy message to clipboard' && button === document.activeElement) {\n                        clickedButton = button;\n                        break;\n                    }\n                }\n                // Show visual feedback if we found the button\n                if (clickedButton) {\n                    const originalHTML = clickedButton.innerHTML;\n                    clickedButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M20 6L9 17l-5-5\"></path></svg>';\n                    setTimeout(() => {\n                        clickedButton.innerHTML = originalHTML;\n                    }, 2000);\n                }\n            }).catch(err => {\n                console.error('Failed to copy text: ', err);\n            });\n        }\n        catch (error) {\n            console.error('Error copying to clipboard:', error);\n        }\n    }\n    /**\n     * Adds message content to the current cell\n     */\n    addMessageToCell(text) {\n        var _a;\n        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (!cell || !cell.editor) {\n            return;\n        }\n        try {\n            const editor = cell.editor;\n            const view = editor.editor;\n            if (!view) {\n                return;\n            }\n            // Get current cursor position\n            const state = view.state;\n            const selection = state.selection;\n            const cursorPos = selection.main.head;\n            // Insert newline and message content at cursor position\n            const transaction = state.update({\n                changes: {\n                    from: cursorPos,\n                    insert: `\\n${text}`\n                },\n                selection: { anchor: cursorPos + text.length + 1 }\n            });\n            view.dispatch(transaction);\n        }\n        catch (error) {\n            console.error('Error adding message to cell:', error);\n        }\n    }\n    /**\n     * Gets the currently selected text from the active notebook cell.\n     * (Helper for PopupMenuManager callback)\n     */\n    getSelectedText() {\n        var _a, _b, _c;\n        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (cell === null || cell === void 0 ? void 0 : cell.editor) {\n            const editor = cell.editor; // IEditor\n            // Access CodeMirror editor instance if possible\n            const cmEditor = editor.editor;\n            if (cmEditor && cmEditor.state) {\n                const state = cmEditor.state;\n                const selection = state.selection.main; // Get the main selection\n                if (selection.empty) {\n                    return null; // No text selected\n                }\n                return state.doc.sliceString(selection.from, selection.to);\n            }\n            console.warn(\"Could not access CodeMirror state to get selection.\");\n            // Avoid using getRange as it's confirmed not to exist on IEditor\n            return null;\n        }\n        else {\n            // Attempt to get selection from document if no notebook active (e.g., text editor)\n            const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n            if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {\n                const editor = activeWidget.content.editor;\n                const cmEditor = editor.editor;\n                if (cmEditor && cmEditor.state) {\n                    const state = cmEditor.state;\n                    const selection = state.selection.main;\n                    if (selection.empty) {\n                        return null;\n                    }\n                    return state.doc.sliceString(selection.from, selection.to);\n                }\n                console.warn(\"Could not access CodeMirror state for non-notebook editor selection.\");\n                return null; // Avoid getRange\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the content of the currently active notebook cell.\n     * (Helper for PopupMenuManager callback)\n     */\n    getCurrentCellContent() {\n        var _a, _b, _c;\n        const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;\n        if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {\n            // Try using sharedModel first (more robust)\n            if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {\n                return activeCell.model.sharedModel.getSource();\n            }\n            // Fallback: Try using toJSON().source\n            const cellJson = activeCell.model.toJSON();\n            if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {\n                return cellJson.source;\n            }\n            else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {\n                // If source is an array of strings, join them\n                return cellJson.source.join('\\n');\n            }\n            console.warn(\"Could not get cell content via model.value.text or toJSON().source\");\n            return null;\n        }\n        // Fallback for non-notebook editors if needed\n        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;\n        if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {\n            return activeWidget.content.model.value.text;\n        }\n        return null;\n    }\n    /**\n     * Appends text to the input field with proper spacing\n     */\n    appendToInput(text) {\n        try {\n            const currentValue = this.inputField.value;\n            if (currentValue) {\n                // add a space between the current value and the new text\n                this.inputField.value = `${currentValue}${text}`;\n            }\n            else {\n                this.inputField.value = text;\n            }\n            // Focus the input field and move cursor to end\n            this.inputField.focus();\n            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);\n        }\n        catch (error) {\n            console.error('Error appending to input:', error);\n        }\n    }\n    // Settings modal methods\n    createSettingsModal() {\n        const modal = document.createElement('div');\n        modal.className = 'jp-llm-ext-settings-modal';\n        modal.style.display = 'none'; // Keep this inline style for toggling visibility\n        const content = document.createElement('div');\n        content.className = 'jp-llm-ext-settings-content';\n        const title = document.createElement('h2');\n        title.className = 'jp-llm-ext-settings-title';\n        title.textContent = 'Settings';\n        content.appendChild(title);\n        const form = document.createElement('form');\n        form.className = 'jp-llm-ext-settings-form';\n        // Provider selection\n        const providerLabel = document.createElement('label');\n        providerLabel.className = 'jp-llm-ext-settings-label';\n        providerLabel.textContent = 'API Provider:';\n        form.appendChild(providerLabel);\n        const providerSelect = document.createElement('select');\n        providerSelect.className = 'jp-llm-ext-settings-select';\n        providerSelect.id = 'settings-provider';\n        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {\n            const option = document.createElement('option');\n            option.value = opt;\n            option.textContent = opt;\n            providerSelect.appendChild(option);\n        });\n        form.appendChild(providerSelect);\n        // API Key input\n        const apiKeyLabel = document.createElement('label');\n        apiKeyLabel.className = 'jp-llm-ext-settings-label';\n        apiKeyLabel.textContent = 'API Key:';\n        form.appendChild(apiKeyLabel);\n        const apiKeyInput = document.createElement('input');\n        apiKeyInput.className = 'jp-llm-ext-settings-input';\n        apiKeyInput.type = 'password';\n        apiKeyInput.id = 'settings-api-key';\n        form.appendChild(apiKeyInput);\n        // API URL input\n        const apiUrlLabel = document.createElement('label');\n        apiUrlLabel.className = 'jp-llm-ext-settings-label';\n        apiUrlLabel.textContent = 'API URL (optional):';\n        form.appendChild(apiUrlLabel);\n        const apiUrlInput = document.createElement('input');\n        apiUrlInput.className = 'jp-llm-ext-settings-input';\n        apiUrlInput.type = 'text';\n        apiUrlInput.id = 'settings-api-url';\n        form.appendChild(apiUrlInput);\n        // Rules input\n        const rulesLabel = document.createElement('label');\n        rulesLabel.className = 'jp-llm-ext-settings-label';\n        rulesLabel.textContent = 'Custom Rules (optional):';\n        form.appendChild(rulesLabel);\n        const rulesInput = document.createElement('textarea');\n        rulesInput.className = 'jp-llm-ext-settings-textarea';\n        rulesInput.id = 'settings-rules';\n        form.appendChild(rulesInput);\n        // Buttons container\n        const btnContainer = document.createElement('div');\n        btnContainer.className = 'jp-llm-ext-settings-buttons';\n        const saveBtn = document.createElement('button');\n        saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';\n        saveBtn.textContent = 'Save';\n        saveBtn.addEventListener('click', (event) => {\n            event.preventDefault(); // Add this line\n            const provider = document.getElementById('settings-provider').value;\n            const key = document.getElementById('settings-api-key').value;\n            const url = document.getElementById('settings-api-url').value;\n            const rules = document.getElementById('settings-rules').value;\n            // Save settings to localStorage for persistence\n            const settings = { provider, key, url, rules };\n            localStorage.setItem('jp-llm-ext-settings', JSON.stringify(settings));\n            console.log('Settings saved:', settings);\n            this.hideSettingsModal();\n            this.popSaveSuccess();\n            // Update API client with new settings if needed\n            if (url) {\n                this.apiClient = new api_client_1.ApiClient(url);\n            }\n        });\n        const cancelBtn = document.createElement('button');\n        cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';\n        cancelBtn.textContent = 'Cancel';\n        cancelBtn.addEventListener('click', (event) => {\n            event.preventDefault(); // Add this line\n            this.hideSettingsModal();\n        });\n        btnContainer.appendChild(saveBtn);\n        btnContainer.appendChild(cancelBtn);\n        form.appendChild(btnContainer);\n        content.appendChild(form);\n        modal.appendChild(content);\n        return modal;\n    }\n    showSettingsModal() {\n        // Load saved settings from localStorage\n        this.loadSavedSettings();\n        this.settingsModalContainer.style.display = 'flex';\n    }\n    loadSavedSettings() {\n        const savedSettings = localStorage.getItem('jp-llm-ext-settings');\n        if (savedSettings) {\n            try {\n                const settings = JSON.parse(savedSettings);\n                // Update UI with saved settings\n                if (settings.provider) {\n                    document.getElementById('settings-provider').value = settings.provider;\n                }\n                if (settings.key) {\n                    document.getElementById('settings-api-key').value = settings.key;\n                }\n                if (settings.url) {\n                    document.getElementById('settings-api-url').value = settings.url;\n                }\n                if (settings.rules) {\n                    document.getElementById('settings-rules').value = settings.rules;\n                }\n            }\n            catch (error) {\n                console.error('Error loading saved settings:', error);\n            }\n        }\n    }\n    hideSettingsModal() {\n        this.settingsModalContainer.style.display = 'none';\n    }\n    popSaveSuccess() {\n        // Create a toast notification container\n        const toast = document.createElement('div');\n        toast.className = 'jp-llm-ext-toast-notification jp-llm-ext-settings-success';\n        toast.textContent = 'Settings saved successfully';\n        // Add to the main widget (not the modal which is hidden)\n        this.node.appendChild(toast);\n        // Animate in\n        setTimeout(() => {\n            toast.classList.add('visible');\n        }, 10);\n        // Remove after delay\n        setTimeout(() => {\n            toast.classList.remove('visible');\n            // Wait for fade out animation to complete before removing\n            setTimeout(() => {\n                toast.remove();\n            }, 300);\n        }, 3000);\n    }\n    /**\n     * Gets cell content by index from the current notebook and inserts it into the input field\n     */\n    insertCellByIndex(index) {\n        try {\n            if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {\n                console.error('No active notebook found');\n                return;\n            }\n            const notebookPanel = globals_1.globals.notebookTracker.currentWidget;\n            const model = notebookPanel.content.model;\n            if (!model || !model.cells || index >= model.cells.length) {\n                console.error(`Invalid cell index: ${index}`);\n                return;\n            }\n            const cell = model.cells.get(index);\n            let cellContent = '';\n            // Get cell content - handle different ways content might be stored\n            if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {\n                cellContent = cell.sharedModel.getSource();\n            }\n            else {\n                const cellJson = cell.toJSON();\n                if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {\n                    cellContent = cellJson.source;\n                }\n                else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {\n                    cellContent = cellJson.source.join('\\n');\n                }\n            }\n            // Insert cell reference with content, without type indicator or execution count\n            this.appendToInput(`cell ${cellContent}`);\n        }\n        catch (error) {\n            console.error('Error inserting cell by index:', error);\n        }\n    }\n    /**\n     * Detects the programming language from code block content\n     */\n    detectLanguage(code) {\n        try {\n            // Try auto detection first\n            const result = highlight_js_1.default.highlightAuto(code, [\n                'python', 'javascript', 'typescript', 'java',\n                'html', 'css', 'cpp', 'csharp', 'sql', 'rust',\n                'php', 'bash', 'json', 'xml', 'markdown'\n            ]);\n            // If confidence is high enough, use that language\n            if (result.relevance > 5) {\n                return result.language || '';\n            }\n            // Fall back to pattern matching for better accuracy\n            if (/^(?:\\s*)?(?:import\\s+[^;]+;|package\\s+[^;]+;|public\\s+class)/.test(code)) {\n                return 'java';\n            }\n            else if (/^(?:\\s*)?(import|from|def|class|if __name__)\\s/.test(code)) {\n                return 'python';\n            }\n            else if (/^(?:\\s*)?(?:function|const|let|var|import)\\s/.test(code)) {\n                return 'javascript';\n            }\n            else if (/^(?:\\s*)?(?:<!DOCTYPE|<html|<head|<body)/.test(code)) {\n                return 'html';\n            }\n            else if (/^(?:\\s*)?#include/.test(code)) {\n                return 'cpp';\n            }\n            else if (/^(?:\\s*)?(?:using\\s+System|namespace|public\\s+static\\s+void\\s+Main)/.test(code)) {\n                return 'csharp';\n            }\n            else if (/^(?:\\s*)?(?:\\$|SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\\s/i.test(code)) {\n                return 'sql';\n            }\n            else if (/^(?:\\s*)?(?:module|fn|let|struct|enum|trait|impl)\\s/.test(code)) {\n                return 'rust';\n            }\n            else if (/^(?:\\s*)?(?:<?php|use\\s+[\\w\\\\]+;)/.test(code)) {\n                return 'php';\n            }\n            else if (/^(?:\\s*)?(?:#\\s*!\\/usr\\/bin\\/env|require|module\\.exports|console\\.)/.test(code)) {\n                return 'bash';\n            }\n            return '';\n        }\n        catch (error) {\n            console.error('Error detecting language:', error);\n            return '';\n        }\n    }\n    /**\n     * Highlights code with appropriate syntax highlighting\n     */\n    highlightCode(code, language) {\n        try {\n            if (!language) {\n                // Try to auto-detect if no language specified\n                return highlight_js_1.default.highlightAuto(code).value;\n            }\n            if (highlight_js_1.default.getLanguage(language)) {\n                return highlight_js_1.default.highlight(code, { language }).value;\n            }\n            else {\n                // Fallback to auto-detection if specified language isn't available\n                return highlight_js_1.default.highlightAuto(code).value;\n            }\n        }\n        catch (error) {\n            console.error('Error highlighting code:', error);\n            return code; // Return original code on error\n        }\n    }\n    // Helper function to copy text to clipboard with visual feedback\n    copyToClipboard(text) {\n        try {\n            navigator.clipboard.writeText(text).then(() => {\n                console.log('Content copied to clipboard');\n                // Show a temporary notification\n                const notification = document.createElement('div');\n                notification.className = 'jp-llm-ext-toast-notification jp-llm-ext-copy-success';\n                notification.textContent = 'Copied to clipboard';\n                // Add to the main widget\n                this.node.appendChild(notification);\n                // Animate in\n                setTimeout(() => {\n                    notification.classList.add('visible');\n                }, 10);\n                // Remove after delay\n                setTimeout(() => {\n                    notification.classList.remove('visible');\n                    // Wait for fade out animation to complete before removing\n                    setTimeout(() => {\n                        notification.remove();\n                    }, 300);\n                }, 1500);\n            }).catch(err => {\n                console.error('Failed to copy text: ', err);\n            });\n        }\n        catch (error) {\n            console.error('Error copying to clipboard:', error);\n        }\n    }\n    /**\n     * Copies an image to the clipboard\n     */\n    copyImageToClipboard(imageUrl) {\n        try {\n            // Fetch the image\n            fetch(imageUrl)\n                .then(response => response.blob())\n                .then(blob => {\n                // Create a ClipboardItem with the image blob\n                const item = new ClipboardItem({\n                    [blob.type]: blob\n                });\n                // Copy the image to clipboard\n                navigator.clipboard.write([item]).then(() => {\n                    console.log('Image copied to clipboard');\n                    // Show visual feedback\n                    const notification = document.createElement('div');\n                    notification.className = 'jp-llm-ext-toast-notification jp-llm-ext-copy-success';\n                    notification.textContent = 'Image copied to clipboard';\n                    // Add to the main widget\n                    this.node.appendChild(notification);\n                    // Animate in\n                    setTimeout(() => {\n                        notification.classList.add('visible');\n                    }, 10);\n                    // Remove after delay\n                    setTimeout(() => {\n                        notification.classList.remove('visible');\n                        // Wait for fade out animation to complete before removing\n                        setTimeout(() => {\n                            notification.remove();\n                        }, 300);\n                    }, 1500);\n                })\n                    .catch(err => {\n                    console.error('Failed to copy image: ', err);\n                    alert('Failed to copy image: ' + err.message);\n                });\n            })\n                .catch(err => {\n                console.error('Failed to fetch image: ', err);\n                alert('Failed to fetch image: ' + err.message);\n            });\n        }\n        catch (error) {\n            console.error('Error copying image to clipboard:', error);\n            alert('Error copying image to clipboard: ' + error);\n        }\n    }\n}\nexports.SimpleSidebarWidget = SimpleSidebarWidget;\n"],"names":[],"sourceRoot":""}