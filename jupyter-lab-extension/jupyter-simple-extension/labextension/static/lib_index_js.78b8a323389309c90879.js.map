{"version":3,"file":"lib_index_js.78b8a323389309c90879.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzIwC;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc,iDAAa;AAC3B;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACVoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,8DAAO;AACxC;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdgD;AACM;AACC;AACE;AACH;AACN;AACH;AACc;AAC5D,YAAY,YAAY;AACxB;AACyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAS,EAAE,iEAAe,EAAE,kEAAgB,EAAE,oEAAgB;AAC7E;AACA;AACA;AACA,QAAQ,qDAAW;AACnB;AACA,QAAQ,6CAAO,0BAA0B,qEAAkB;AAC3D;AACA,kCAAkC,gEAAmB;AACrD,sDAAsD,YAAY;AAClE;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BmB;AACY;AACrB;AACE;AACM;AACJ;AACK;AACzC;AACA;AACA;AACO,kCAAkC,mDAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAa;AACvC;AACA;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC,EAAE,0CAA0C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAqD;AACnE,cAAc,qDAAqD;AACnE,cAAc,sDAAsD;AACpE;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,kDAAkD;AAChE,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC,gBAAgB,6CAAO;AACvB;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oCAAoC,0CAAM;AAC1C,0CAA0C,yDAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA,4EAA4E,cAAc;AAC1F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAM;AACtC,sCAAsC,yDAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC,yCAAyC,6CAAO;AAChD,gDAAgD,+DAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO,MAAM,oCAAoC,WAAW,GAAG,UAAU,eAAe;AAC1J;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA;AACA,yEAAyE,QAAQ,KAAK,MAAM;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyter-simple-extension/./lib/api-client.js","webpack://jupyter-simple-extension/./lib/cell-context-tracker.js","webpack://jupyter-simple-extension/./lib/commands.js","webpack://jupyter-simple-extension/./lib/globals.js","webpack://jupyter-simple-extension/./lib/icons.js","webpack://jupyter-simple-extension/./lib/index.js","webpack://jupyter-simple-extension/./lib/sidebar-widget.js"],"sourcesContent":["/**\n * API client for interacting with the backend LLM service\n */\nexport class ApiClient {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Stream a chat response from the mock LLM\n     * @param message The user message to send\n     * @param context Optional context information\n     * @param onChunk Callback for each text chunk received\n     * @param onComplete Callback when streaming is complete\n     * @param onError Callback for errors\n     */\n    async streamChat(message, context = null, onChunk, onComplete, onError) {\n        try {\n            const response = await fetch(`${this.baseUrl}/chat`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    message,\n                    context\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`API error: ${response.statusText}`);\n            }\n            if (!response.body) {\n                throw new Error('ReadableStream not supported in this browser.');\n            }\n            // Set up stream reading\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let done = false;\n            while (!done) {\n                const { value, done: readerDone } = await reader.read();\n                done = readerDone;\n                if (value) {\n                    const chunk = decoder.decode(value, { stream: !done });\n                    onChunk(chunk);\n                }\n            }\n            onComplete();\n        }\n        catch (error) {\n            onError(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n    /**\n     * Simple health check for the API\n     * @returns A promise that resolves to true if the API is healthy\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/health`);\n            return response.ok;\n        }\n        catch (error) {\n            console.error('API health check failed:', error);\n            return false;\n        }\n    }\n}\n","/**\n * Tracks cell context and cursor position within Jupyter notebooks\n */\nexport class CellContextTracker {\n    constructor(app, notebookTracker) {\n        this.activeCellEditorNode = null;\n        this.lastCellContext = null;\n        this._isDisposed = false;\n        /**\n         * Handles editor events (keydown, mouseup)\n         */\n        this.handleEditorEvent = (event) => {\n            try {\n                // Get the current active cell from the tracker\n                const cell = this.notebookTracker.activeCell;\n                if (!cell || !cell.editor)\n                    return;\n                // Find the inner EditorView instance\n                const editor = cell.editor;\n                const view = editor.editor;\n                if (!view)\n                    return;\n                // Get and store the cursor context\n                this.lastCellContext = this.getCmContext(view);\n            }\n            catch (error) {\n                console.error(\"Error in editor event handler:\", error);\n            }\n        };\n        this.notebookTracker = notebookTracker;\n        this.setupTrackers();\n    }\n    /**\n     * Whether this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Sets up all the necessary event trackers\n     */\n    setupTrackers() {\n        // Handle active cell changes\n        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);\n        // Handle notebook changes\n        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);\n    }\n    /**\n     * Handles notebook changes\n     */\n    handleNotebookChange(tracker, panel) {\n        this.cleanupPreviousListeners();\n        if (panel && panel.content) {\n            const cell = panel.content.activeCell;\n            this.setupCellListeners(tracker, cell);\n        }\n    }\n    /**\n     * Sets up event listeners on the active cell\n     */\n    setupCellListeners(_tracker, cell) {\n        if (!cell)\n            return;\n        this.cleanupPreviousListeners();\n        if (cell.editor) {\n            try {\n                const cellNode = cell.node;\n                const editorNode = cellNode.querySelector('.jp-Editor') ||\n                    cellNode.querySelector('.jp-InputArea-editor');\n                if (editorNode) {\n                    this.activeCellEditorNode = editorNode;\n                    // Add event listeners for key and mouse events\n                    editorNode.addEventListener('keydown', this.handleEditorEvent);\n                    editorNode.addEventListener('mouseup', this.handleEditorEvent);\n                    // Try to capture immediate context if EditorView available\n                    const view = cell.editor.editor;\n                    if (view) {\n                        this.lastCellContext = this.getCmContext(view);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Error setting up cell listeners:\", error);\n            }\n        }\n    }\n    /**\n     * Cleans up event listeners from the previous active cell\n     */\n    cleanupPreviousListeners() {\n        if (this.activeCellEditorNode) {\n            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);\n            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);\n            this.activeCellEditorNode = null;\n        }\n    }\n    /**\n     * Gets context information from CodeMirror EditorView\n     */\n    getCmContext(view) {\n        const state = view.state;\n        const offset = state.selection.main.head;\n        const fullText = state.doc.toString();\n        const line = state.doc.lineAt(offset);\n        const position = {\n            line: line.number - 1,\n            column: offset - line.from,\n            offset: offset\n        };\n        const contextRadius = 100;\n        const start = Math.max(0, offset - contextRadius);\n        const end = Math.min(fullText.length, offset + contextRadius);\n        return {\n            text: fullText,\n            position: position,\n            contextBefore: fullText.substring(start, offset),\n            contextAfter: fullText.substring(offset, end)\n        };\n    }\n    /**\n     * Gets the current cell context\n     */\n    getCurrentCellContext() {\n        return this.lastCellContext;\n    }\n    /**\n     * Disposes all resources\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.cleanupPreviousListeners();\n        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);\n        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);\n    }\n}\n","import { extensionIcon } from './icons';\n/**\n * Registers commands for the extension\n */\nexport function registerCommands(app, palette, launcher, sidebarWidget) {\n    // Add command to toggle the sidebar\n    app.commands.addCommand('simple-extension:toggle-sidebar', {\n        label: 'Toggle AI Assistant Sidebar',\n        icon: extensionIcon,\n        execute: () => {\n            if (sidebarWidget.isAttached) {\n                sidebarWidget.parent = null;\n            }\n            else {\n                app.shell.add(sidebarWidget, 'left', { rank: 9999 });\n            }\n        }\n    });\n    // Add the command to the command palette\n    palette.addItem({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Extension'\n    });\n    // Add a launcher item\n    launcher.add({\n        command: 'simple-extension:toggle-sidebar',\n        category: 'Other',\n        rank: 9999\n    });\n}\n","/**\n * Global references to key components in the application\n */\nexport const globals = {};\n/**\n * Initialize global references\n */\nexport function initGlobals(app, notebookTracker) {\n    globals.app = app;\n    globals.notebookTracker = notebookTracker;\n}\n","import { LabIcon } from '@jupyterlab/ui-components';\n// ===============================\n// Icon Definition\n// ===============================\nconst iconSvgStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-chat-left-text\" viewBox=\"0 0 16 16\">' +\n    '<path d=\"M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z\"/>' +\n    '<path d=\"M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z\"/>' +\n    '</svg>';\n/**\n * Icon for the AI Assistant extension\n */\nexport const extensionIcon = new LabIcon({\n    name: 'simple:icon',\n    svgstr: iconSvgStr\n});\n","import { ILauncher } from '@jupyterlab/launcher';\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IDocumentManager } from '@jupyterlab/docmanager';\nimport { SimpleSidebarWidget } from './sidebar-widget';\nimport { initGlobals, globals } from './globals';\nimport { registerCommands } from './commands';\nimport { CellContextTracker } from './cell-context-tracker';\n// import { ApiClient } from './api-client';\n// Export ApiClient for use by other components\nexport { ApiClient } from './api-client';\n/**\n * Initialization data for the jupyter-simple-extension extension.\n */\nconst plugin = {\n    id: 'jupyter-simple-extension:plugin',\n    autoStart: true,\n    requires: [ILauncher, ICommandPalette, INotebookTracker, IDocumentManager],\n    activate: (jupyterApp, launcher, palette, tracker, docManager) => {\n        console.log('JupyterLab extension jupyter-simple-extension is activated!');\n        // Initialize global references\n        initGlobals(jupyterApp, tracker);\n        // Initialize cell context tracker\n        globals.cellContextTracker = new CellContextTracker(jupyterApp, tracker);\n        // Create and add sidebar widget\n        const sidebarWidget = new SimpleSidebarWidget(docManager);\n        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });\n        // Register commands\n        registerCommands(jupyterApp, palette, launcher, sidebarWidget);\n    }\n};\nexport default plugin;\n","import { Widget } from '@lumino/widgets';\nimport { NotebookPanel } from '@jupyterlab/notebook';\nimport { marked } from 'marked';\nimport DOMPurify from 'dompurify';\nimport { extensionIcon } from './icons';\nimport { globals } from './globals';\nimport { ApiClient } from './api-client';\n/**\n * Main sidebar widget for the AI chat interface\n */\nexport class SimpleSidebarWidget extends Widget {\n    constructor(docManager) {\n        super();\n        this.isMarkdownMode = false;\n        this.isInputExpanded = false;\n        this.chatHistory = [];\n        this.currentChatId = '';\n        this.isHistoryViewActive = false;\n        this.docManager = docManager;\n        this.id = 'simple-sidebar';\n        this.title.label = '';\n        this.title.caption = 'AI Chat Interface';\n        this.title.icon = extensionIcon;\n        this.title.closable = true;\n        // Initialize API client\n        this.apiClient = new ApiClient();\n        // Initialize container elements before creating layout\n        this.messageContainer = document.createElement('div');\n        this.inputContainer = document.createElement('div');\n        this.inputField = document.createElement('textarea');\n        this.titleInput = document.createElement('input');\n        this.historyContainer = document.createElement('div');\n        // Create a new chat on start\n        this.createNewChat();\n        this.node.appendChild(this.createLayout());\n    }\n    /**\n     * Creates the main layout for the sidebar\n     */\n    createLayout() {\n        // Create the main container\n        const content = document.createElement('div');\n        content.className = 'simple-sidebar-content';\n        // Create title input container\n        const titleContainer = document.createElement('div');\n        titleContainer.className = 'title-container';\n        // Set up title input\n        this.titleInput.className = 'chat-title-input';\n        this.titleInput.type = 'text';\n        this.titleInput.placeholder = 'Chat title';\n        this.titleInput.value = 'New Chat';\n        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());\n        titleContainer.appendChild(this.titleInput);\n        // Configure top action buttons (New Chat & History)\n        const topActionsContainer = document.createElement('div');\n        topActionsContainer.className = 'top-actions-container';\n        const newChatButton = document.createElement('button');\n        newChatButton.className = 'jp-Button action-button';\n        newChatButton.textContent = '+ New Chat';\n        newChatButton.title = 'Start a new chat';\n        newChatButton.addEventListener('click', () => this.createNewChat());\n        const historyButton = document.createElement('button');\n        historyButton.className = 'jp-Button action-button';\n        historyButton.textContent = 'History';\n        historyButton.title = 'View chat history';\n        historyButton.addEventListener('click', () => this.toggleHistoryView());\n        topActionsContainer.appendChild(newChatButton);\n        topActionsContainer.appendChild(historyButton);\n        // Configure message container\n        this.messageContainer.className = 'message-container';\n        // Configure history container\n        this.historyContainer.className = 'history-container';\n        this.historyContainer.style.display = 'none'; // Initially hidden\n        // Configure input container\n        this.inputContainer.className = 'input-container';\n        // Create controls container\n        const controlsContainer = this.createControlsContainer();\n        // Configure input field\n        this.inputField.placeholder = 'Ask me anything...';\n        this.inputField.style.flexGrow = '1';\n        this.inputField.style.padding = '5px';\n        this.inputField.style.border = '1px solid #ccc';\n        this.inputField.style.borderRadius = '3px';\n        this.inputField.style.resize = 'none';\n        this.inputField.rows = 1;\n        this.inputField.style.overflowY = 'auto';\n        // Add keypress listener to input field\n        this.inputField.addEventListener('keypress', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.handleSendMessage();\n            }\n        });\n        // Create send button container\n        const inputActionsContainer = document.createElement('div');\n        inputActionsContainer.className = 'input-actions-container';\n        // Create send button\n        const sendButton = document.createElement('button');\n        sendButton.className = 'jp-Button send-button';\n        sendButton.textContent = 'Send';\n        sendButton.addEventListener('click', () => this.handleSendMessage());\n        // Add button to actions container\n        inputActionsContainer.appendChild(sendButton);\n        // Assemble the input components\n        this.inputContainer.appendChild(controlsContainer);\n        this.inputContainer.appendChild(this.inputField);\n        this.inputContainer.appendChild(inputActionsContainer);\n        // Assemble all components\n        content.appendChild(topActionsContainer);\n        content.appendChild(titleContainer);\n        content.appendChild(this.messageContainer);\n        content.appendChild(this.historyContainer);\n        content.appendChild(this.inputContainer);\n        return content;\n    }\n    /**\n     * Creates a new chat session\n     */\n    createNewChat() {\n        // Generate a unique ID for the chat\n        const chatId = `chat-${Date.now()}`;\n        // Create a new chat item\n        const newChat = {\n            id: chatId,\n            title: 'New Chat',\n            messages: []\n        };\n        // Add to history\n        this.chatHistory.push(newChat);\n        // Set as current chat\n        this.currentChatId = chatId;\n        // Update title input\n        this.titleInput.value = newChat.title;\n        // Clear message container\n        if (this.messageContainer) {\n            this.messageContainer.innerHTML = '';\n        }\n        // Hide history if it's visible\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView();\n        }\n    }\n    /**\n     * Toggles between chat view and history view\n     */\n    toggleHistoryView() {\n        this.isHistoryViewActive = !this.isHistoryViewActive;\n        if (this.isHistoryViewActive) {\n            // Show history view, hide message view\n            this.messageContainer.style.display = 'none';\n            this.historyContainer.style.display = 'block';\n            this.inputContainer.style.display = 'none';\n            this.titleInput.style.display = 'none';\n            // Populate history\n            this.renderChatHistory();\n        }\n        else {\n            // Show message view, hide history view\n            this.messageContainer.style.display = 'block';\n            this.historyContainer.style.display = 'none';\n            this.inputContainer.style.display = 'flex';\n            this.titleInput.style.display = 'block';\n        }\n    }\n    /**\n     * Renders the chat history in the history container\n     */\n    renderChatHistory() {\n        this.historyContainer.innerHTML = '';\n        if (this.chatHistory.length === 0) {\n            const emptyMessage = document.createElement('div');\n            emptyMessage.className = 'empty-history-message';\n            emptyMessage.textContent = 'No chat history yet';\n            this.historyContainer.appendChild(emptyMessage);\n            return;\n        }\n        // Create a list of chat history items\n        this.chatHistory.forEach(chat => {\n            const historyItem = document.createElement('div');\n            historyItem.className = 'history-item';\n            if (chat.id === this.currentChatId) {\n                historyItem.classList.add('active');\n            }\n            // Add title\n            const title = document.createElement('div');\n            title.className = 'history-title';\n            title.textContent = chat.title;\n            // Add message preview\n            const preview = document.createElement('div');\n            preview.className = 'history-preview';\n            const lastMessage = chat.messages[chat.messages.length - 1];\n            preview.textContent = lastMessage\n                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`\n                : 'Empty chat';\n            // Add click event\n            historyItem.addEventListener('click', () => this.loadChat(chat.id));\n            historyItem.appendChild(title);\n            historyItem.appendChild(preview);\n            this.historyContainer.appendChild(historyItem);\n        });\n    }\n    /**\n     * Loads a chat from history\n     */\n    loadChat(chatId) {\n        const chat = this.chatHistory.find(c => c.id === chatId);\n        if (!chat)\n            return;\n        // Set as current chat\n        this.currentChatId = chatId;\n        // Update title\n        this.titleInput.value = chat.title;\n        // Clear and re-populate message container\n        this.messageContainer.innerHTML = '';\n        chat.messages.forEach(msg => {\n            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);\n        });\n        // Switch back to chat view\n        if (this.isHistoryViewActive) {\n            this.toggleHistoryView();\n        }\n    }\n    /**\n     * Updates the title of the current chat\n     */\n    updateCurrentChatTitle() {\n        const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n        if (chat) {\n            chat.title = this.titleInput.value;\n        }\n    }\n    /**\n     * Creates the controls container with toggles and action buttons\n     */\n    createControlsContainer() {\n        const controlsContainer = document.createElement('div');\n        controlsContainer.className = 'controls-container';\n        // Create markdown toggle container\n        const toggleContainer = document.createElement('div');\n        toggleContainer.className = 'toggle-container';\n        // Create markdown toggle\n        const markdownToggle = document.createElement('input');\n        markdownToggle.type = 'checkbox';\n        markdownToggle.id = 'markdown-toggle';\n        markdownToggle.style.marginRight = '5px';\n        markdownToggle.addEventListener('change', (e) => {\n            const target = e.target;\n            this.isMarkdownMode = target.checked;\n            this.inputField.placeholder = this.isMarkdownMode ?\n                'Write markdown here...\\n\\n# Example heading\\n- List item\\n\\n```code block```' :\n                'Ask me anything...';\n        });\n        // Create toggle label\n        const toggleLabel = document.createElement('label');\n        toggleLabel.htmlFor = 'markdown-toggle';\n        toggleLabel.textContent = 'Markdown mode';\n        toggleLabel.style.fontSize = '12px';\n        // Add toggle elements to container\n        toggleContainer.appendChild(markdownToggle);\n        toggleContainer.appendChild(toggleLabel);\n        // Create action buttons container\n        const actionButtonsContainer = document.createElement('div');\n        actionButtonsContainer.className = 'action-buttons-container';\n        // Create all action buttons\n        const buttons = [\n            { text: '@', title: 'Command list', action: () => { } },\n            { text: '📎', title: 'Upload file', action: () => { } },\n            { text: '🔍', title: 'Browse files', action: () => { } },\n            {\n                text: '⤢',\n                title: 'Expand input',\n                action: () => this.toggleInputExpansion(actionButtonsContainer.children[3])\n            },\n            { text: '⚙️', title: 'Settings', action: () => { } },\n            { text: '📁', title: 'List Directory Contents', action: () => this.listCurrentDirectoryContents() }\n        ];\n        // Add all buttons to the container\n        buttons.forEach(button => {\n            const btn = this.createButton(button.text, button.title);\n            btn.addEventListener('click', button.action);\n            actionButtonsContainer.appendChild(btn);\n        });\n        // Add toggle and action buttons to the controls container\n        controlsContainer.appendChild(toggleContainer);\n        controlsContainer.appendChild(actionButtonsContainer);\n        return controlsContainer;\n    }\n    /**\n     * Toggles the expansion state of the input field\n     */\n    toggleInputExpansion(button) {\n        this.isInputExpanded = !this.isInputExpanded;\n        if (this.isInputExpanded) {\n            this.inputField.style.height = '100px';\n            this.inputField.style.resize = 'vertical';\n            button.textContent = '⤡';\n            button.title = 'Collapse input';\n        }\n        else {\n            this.inputField.style.height = 'auto';\n            this.inputField.style.resize = 'none';\n            button.textContent = '⤢';\n            button.title = 'Expand input';\n        }\n    }\n    /**\n     * Helper function to create a button with given text and tooltip\n     */\n    createButton(text, tooltip) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.title = tooltip;\n        button.className = 'jp-Button action-button';\n        return button;\n    }\n    /**\n     * Handles sending a message from the input field\n     */\n    handleSendMessage() {\n        const message = this.inputField.value.trim();\n        if (message) {\n            // Add user message to UI\n            this.addMessage(message, 'user', this.isMarkdownMode);\n            this.inputField.value = '';\n            // Reset expanded state if needed after sending\n            if (this.isInputExpanded) {\n                this.inputField.style.height = '100px';\n            }\n            else {\n                this.inputField.style.height = 'auto';\n                this.inputField.rows = 1;\n            }\n            // Create a temporary message container for the bot's streaming response\n            const botMessageDiv = document.createElement('div');\n            botMessageDiv.className = 'bot-message';\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            botMessageDiv.appendChild(markdownIndicator);\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'markdown-content';\n            contentDiv.textContent = ''; // Start empty\n            botMessageDiv.appendChild(contentDiv);\n            this.messageContainer.appendChild(botMessageDiv);\n            // Variable to collect the complete response\n            let completeResponse = '';\n            // Get cell context if available\n            const cellContext = globals.cellContextTracker ?\n                globals.cellContextTracker.getCurrentCellContext() : null;\n            // Stream response from API\n            this.apiClient.streamChat(message, { cellContext }, \n            // On each chunk received\n            (chunk) => {\n                completeResponse += chunk;\n                contentDiv.textContent = completeResponse;\n                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n            }, \n            // On complete\n            () => {\n                // Replace plain text with rendered markdown\n                try {\n                    const rawHtml = marked.parse(completeResponse);\n                    const sanitizedHtml = DOMPurify.sanitize(rawHtml);\n                    contentDiv.innerHTML = sanitizedHtml;\n                }\n                catch (error) {\n                    console.error('Failed to render markdown:', error);\n                }\n                // Save to chat history\n                const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n                if (chat) {\n                    chat.messages.push({\n                        text: completeResponse,\n                        sender: 'bot',\n                        isMarkdown: true\n                    });\n                }\n                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n            }, \n            // On error\n            (error) => {\n                contentDiv.innerHTML = `<div class=\"error-message\">Error: ${error.message}</div>`;\n                console.error('API Error:', error);\n            });\n        }\n    }\n    /**\n     * Adds a message to the chat interface\n     */\n    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {\n        const messageDiv = document.createElement('div');\n        messageDiv.className = sender === 'user' ? 'user-message' : 'bot-message';\n        // Add message content\n        if (isMarkdown || sender === 'bot') {\n            // Bot messages are always rendered as markdown\n            const markdownIndicator = document.createElement('div');\n            markdownIndicator.textContent = \"MD\";\n            markdownIndicator.className = 'markdown-indicator';\n            messageDiv.appendChild(markdownIndicator);\n            // Create a container for the rendered markdown\n            const contentDiv = document.createElement('div');\n            contentDiv.className = 'markdown-content';\n            try {\n                const rawHtml = marked.parse(text);\n                const sanitizedHtml = DOMPurify.sanitize(rawHtml);\n                contentDiv.innerHTML = sanitizedHtml;\n            }\n            catch (error) {\n                contentDiv.textContent = text;\n                console.error('Failed to render markdown:', error);\n            }\n            messageDiv.appendChild(contentDiv);\n        }\n        else {\n            messageDiv.textContent = text;\n        }\n        this.messageContainer.appendChild(messageDiv);\n        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;\n        // Save to chat history\n        if (saveToHistory) {\n            const chat = this.chatHistory.find(c => c.id === this.currentChatId);\n            if (chat) {\n                chat.messages.push({\n                    text,\n                    sender,\n                    isMarkdown: isMarkdown || sender === 'bot'\n                });\n            }\n        }\n    }\n    /**\n     * Lists the contents of the current directory\n     */\n    async listCurrentDirectoryContents() {\n        let dirPath = null;\n        let source = null;\n        // Try to get directory path from current widget\n        const app = globals.app;\n        if (!app) {\n            this.addMessage('Error: Application reference not available', 'bot', false);\n            return;\n        }\n        const currentShellWidget = app.shell.currentWidget;\n        if (currentShellWidget) {\n            const widgetContext = this.docManager.contextForWidget(currentShellWidget);\n            if (widgetContext) {\n                const path = widgetContext.path;\n                const lastSlash = path.lastIndexOf('/');\n                dirPath = lastSlash === -1 ? '' : path.substring(0, lastSlash);\n                source = 'widget context';\n            }\n        }\n        // Fallback to notebook tracker if no context from widget\n        if (dirPath === null && globals.notebookTracker) {\n            const currentNotebookPanel = globals.notebookTracker.currentWidget;\n            if (currentNotebookPanel instanceof NotebookPanel) {\n                const nbPath = currentNotebookPanel.context.path;\n                const lastSlash = nbPath.lastIndexOf('/');\n                dirPath = lastSlash === -1 ? '' : nbPath.substring(0, lastSlash);\n                source = 'active notebook';\n            }\n        }\n        // List contents if path was found\n        if (dirPath !== null) {\n            try {\n                const contents = await this.docManager.services.contents.get(dirPath);\n                if (contents.content && contents.content.length > 0) {\n                    const messageContent = `Directory contents (${source}):\\n${contents.content.map((item) => `- ${item.name} (${item.type})`).join('\\n')}`;\n                    this.addMessage(messageContent, 'bot', true);\n                }\n                else {\n                    this.addMessage(`Directory \"${dirPath || '/'}\" is empty.`, 'bot', true);\n                }\n            }\n            catch (error) {\n                this.addMessage(`Error listing directory contents for \"${dirPath}\": ${error}`, 'bot', true);\n            }\n        }\n        else {\n            this.addMessage('Could not determine current directory context.', 'bot', true);\n        }\n    }\n}\n"],"names":[],"sourceRoot":""}