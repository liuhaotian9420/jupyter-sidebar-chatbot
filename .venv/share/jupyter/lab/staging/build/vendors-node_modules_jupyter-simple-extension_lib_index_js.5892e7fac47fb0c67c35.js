"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/api-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/api-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: icons_1.extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/globals.js":
/*!**************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/globals.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/icons.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/icons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/markdown-config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/markdown-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = text.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks, handle list items
        return line.replace(/([^\n\s])-\s/g, '$1\n- ');
    });
    return processedLines.join('\n');
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
const markdown_config_1 = __webpack_require__(/*! ./markdown-config */ "./node_modules/jupyter-simple-extension/lib/markdown-config.js");
// import { ICellContext } from './types';
// import { ICellContext } from './types';
// Configure marked with our settings
(0, markdown_config_1.configureMarked)();
/**
 * Main sidebar widget for the AI chat interface
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    constructor(docManager) {
        super();
        this.isMarkdownMode = false;
        this.isInputExpanded = false;
        this.chatHistory = [];
        this.currentChatId = '';
        this.isHistoryViewActive = false;
        /**
         * Handles keyboard shortcuts
         */
        this.handleKeyDown = (event) => {
            var _a, _b;
            // Check for Ctrl+L (for selected code)
            if (event.ctrlKey && event.key.toLowerCase() === 'l') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Get the current active cell
                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
                if (!cell || !cell.editor) {
                    return;
                }
                try {
                    // Get the CodeMirror editor instance
                    const editor = cell.editor;
                    const view = editor.editor;
                    if (!view) {
                        return;
                    }
                    // Check if there's a selection
                    const state = view.state;
                    const selection = state.selection;
                    if (!selection.main.empty) {
                        // If there's a selection, use @code
                        const from = selection.main.from;
                        const to = selection.main.to;
                        const selectedText = state.doc.sliceString(from, to);
                        this.appendToInput(`@code\n${selectedText}`);
                        this.showKeyboardShortcutIndicator('Selected code inserted');
                    }
                    else {
                        // If no selection, use @cell
                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();
                        if (cellContext) {
                            this.appendToInput(`@cell\n${cellContext.text}`);
                            this.showKeyboardShortcutIndicator('Cell content inserted');
                        }
                    }
                    // Ensure the sidebar is visible and focused
                    if (this.isHidden) {
                        this.show();
                    }
                    this.inputField.focus();
                }
                catch (error) {
                    console.error('Error handling keyboard shortcut:', error);
                }
            }
        };
        /**
         * Handles clicks outside the command menu
         */
        this.handleClickOutside = (event) => {
            if (!this.commandMenuContainer.contains(event.target)) {
                this.hideCommandMenu();
            }
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        // Initialize API client
        this.apiClient = new api_client_1.ApiClient();
        // Initialize container elements before creating layout
        this.messageContainer = document.createElement('div');
        this.inputContainer = document.createElement('div');
        this.inputField = document.createElement('textarea');
        this.titleInput = document.createElement('input');
        this.historyContainer = document.createElement('div');
        this.commandMenuContainer = document.createElement('div');
        this.commandMenuContainer.className = 'command-menu-container';
        this.commandMenuContainer.style.display = 'none';
        // Create keyboard shortcut indicator
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'keyboard-shortcut-indicator';
        document.body.appendChild(this.keyboardShortcutIndicator);
        // Create a new chat on start
        this.createNewChat();
        this.node.appendChild(this.createLayout());
        this.node.appendChild(this.commandMenuContainer);
        // Add keyboard shortcut listener
        document.addEventListener('keydown', this.handleKeyDown);
    }
    /**
     * Shows a visual indicator for keyboard shortcuts
     */
    showKeyboardShortcutIndicator(text) {
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Hide after 1 second
        setTimeout(() => {
            this.keyboardShortcutIndicator.classList.remove('visible');
        }, 1000);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        // Remove keyboard shortcut listener
        document.removeEventListener('keydown', this.handleKeyDown);
        // Remove keyboard shortcut indicator
        if (this.keyboardShortcutIndicator.parentNode) {
            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);
        }
        super.dispose();
    }
    /**
     * Creates the main layout for the sidebar
     */
    createLayout() {
        // Create the main container
        const content = document.createElement('div');
        content.className = 'simple-sidebar-content';
        // Create title input container
        const titleContainer = document.createElement('div');
        titleContainer.className = 'title-container';
        // Set up title input
        this.titleInput.className = 'chat-title-input';
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat';
        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());
        titleContainer.appendChild(this.titleInput);
        // Configure top action buttons (New Chat & History)
        const topActionsContainer = document.createElement('div');
        topActionsContainer.className = 'top-actions-container';
        const newChatButton = document.createElement('button');
        newChatButton.className = 'jp-Button action-button';
        newChatButton.textContent = '+ New Chat';
        newChatButton.title = 'Start a new chat';
        newChatButton.addEventListener('click', () => this.createNewChat());
        const historyButton = document.createElement('button');
        historyButton.className = 'jp-Button action-button';
        historyButton.textContent = 'History';
        historyButton.title = 'View chat history';
        historyButton.addEventListener('click', () => this.toggleHistoryView());
        topActionsContainer.appendChild(newChatButton);
        topActionsContainer.appendChild(historyButton);
        // Configure message container
        this.messageContainer.className = 'message-container';
        // Configure history container
        this.historyContainer.className = 'history-container';
        this.historyContainer.style.display = 'none'; // Initially hidden
        // Configure input container
        this.inputContainer.className = 'input-container';
        // Create controls container
        const controlsContainer = this.createControlsContainer();
        // Configure input field
        this.inputField.placeholder = 'Ask me anything...';
        this.inputField.style.flexGrow = '1';
        this.inputField.style.padding = '5px';
        this.inputField.style.border = '1px solid #ccc';
        this.inputField.style.borderRadius = '3px';
        this.inputField.style.resize = 'none';
        this.inputField.rows = 1;
        this.inputField.style.overflowY = 'auto';
        // Add keypress listener to input field
        this.inputField.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.handleSendMessage();
            }
        });
        // Create send button container
        const inputActionsContainer = document.createElement('div');
        inputActionsContainer.className = 'input-actions-container';
        // Create send button
        const sendButton = document.createElement('button');
        sendButton.className = 'jp-Button send-button';
        sendButton.textContent = 'Send';
        sendButton.addEventListener('click', () => this.handleSendMessage());
        // Add button to actions container
        inputActionsContainer.appendChild(sendButton);
        // Assemble the input components
        this.inputContainer.appendChild(controlsContainer);
        this.inputContainer.appendChild(this.inputField);
        this.inputContainer.appendChild(inputActionsContainer);
        // Assemble all components
        content.appendChild(topActionsContainer);
        content.appendChild(titleContainer);
        content.appendChild(this.messageContainer);
        content.appendChild(this.historyContainer);
        content.appendChild(this.inputContainer);
        return content;
    }
    /**
     * Creates a new chat session
     */
    createNewChat() {
        // Generate a unique ID for the chat
        const chatId = `chat-${Date.now()}`;
        // Create a new chat item
        const newChat = {
            id: chatId,
            title: 'New Chat',
            messages: []
        };
        // Add to history
        this.chatHistory.push(newChat);
        // Set as current chat
        this.currentChatId = chatId;
        // Update title input
        this.titleInput.value = newChat.title;
        // Clear message container
        if (this.messageContainer) {
            this.messageContainer.innerHTML = '';
        }
        // Hide history if it's visible
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Toggles between chat view and history view
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Show history view, hide message view
            this.messageContainer.style.display = 'none';
            this.historyContainer.style.display = 'block';
            this.inputContainer.style.display = 'none';
            this.titleInput.style.display = 'none';
            // Populate history
            this.renderChatHistory();
        }
        else {
            // Show message view, hide history view
            this.messageContainer.style.display = 'block';
            this.historyContainer.style.display = 'none';
            this.inputContainer.style.display = 'flex';
            this.titleInput.style.display = 'block';
        }
    }
    /**
     * Renders the chat history in the history container
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = '';
        if (this.chatHistory.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-history-message';
            emptyMessage.textContent = 'No chat history yet';
            this.historyContainer.appendChild(emptyMessage);
            return;
        }
        // Create a list of chat history items
        this.chatHistory.forEach(chat => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            if (chat.id === this.currentChatId) {
                historyItem.classList.add('active');
            }
            // Add title
            const title = document.createElement('div');
            title.className = 'history-title';
            title.textContent = chat.title;
            // Add message preview
            const preview = document.createElement('div');
            preview.className = 'history-preview';
            const lastMessage = chat.messages[chat.messages.length - 1];
            preview.textContent = lastMessage
                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`
                : 'Empty chat';
            // Add click event
            historyItem.addEventListener('click', () => this.loadChat(chat.id));
            historyItem.appendChild(title);
            historyItem.appendChild(preview);
            this.historyContainer.appendChild(historyItem);
        });
    }
    /**
     * Loads a chat from history
     */
    loadChat(chatId) {
        const chat = this.chatHistory.find(c => c.id === chatId);
        if (!chat)
            return;
        // Set as current chat
        this.currentChatId = chatId;
        // Update title
        this.titleInput.value = chat.title;
        // Clear and re-populate message container
        this.messageContainer.innerHTML = '';
        chat.messages.forEach(msg => {
            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);
        });
        // Switch back to chat view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Updates the title of the current chat
     */
    updateCurrentChatTitle() {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            chat.title = this.titleInput.value;
        }
    }
    /**
     * Creates the controls container with toggles and action buttons
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'controls-container';
        // Create markdown toggle container
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'toggle-container';
        // Create markdown toggle
        const markdownToggle = document.createElement('input');
        markdownToggle.type = 'checkbox';
        markdownToggle.id = 'markdown-toggle';
        markdownToggle.style.marginRight = '5px';
        markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            this.inputField.placeholder = this.isMarkdownMode ?
                'Write markdown here...\n\n# Example heading\n- List item\n\n```code block```' :
                'Ask me anything...';
        });
        // Create toggle label
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        toggleLabel.style.fontSize = '12px';
        // Add toggle elements to container
        toggleContainer.appendChild(markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // Create action buttons container
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'action-buttons-container';
        // Create all action buttons
        const buttons = [
            {
                text: '@',
                title: 'Command list',
                action: (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    const rect = event.currentTarget.getBoundingClientRect();
                    this.showCommandMenu(rect.left, rect.bottom);
                }
            },
            { text: '📎', title: 'Upload file', action: () => { } },
            { text: '🔍', title: 'Browse files', action: () => { } },
            {
                text: '⤢',
                title: 'Expand input',
                action: () => this.toggleInputExpansion(actionButtonsContainer.children[3])
            },
            { text: '⚙️', title: 'Settings', action: () => { } },
            { text: '📁', title: 'List Directory Contents', action: () => this.listCurrentDirectoryContents() }
        ];
        // Add all buttons to the container
        buttons.forEach(button => {
            const btn = this.createButton(button.text, button.title);
            btn.addEventListener('click', (e) => button.action(e));
            actionButtonsContainer.appendChild(btn);
        });
        // Add toggle and action buttons to the controls container
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field
     */
    toggleInputExpansion(button) {
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            this.inputField.style.height = '100px';
            this.inputField.style.resize = 'vertical';
            button.textContent = '⤡';
            button.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = 'auto';
            this.inputField.style.resize = 'none';
            button.textContent = '⤢';
            button.title = 'Expand input';
        }
    }
    /**
     * Helper function to create a button with given text and tooltip
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        button.className = 'jp-Button action-button';
        return button;
    }
    /**
     * Handles sending a message from the input field
     */
    handleSendMessage() {
        const message = this.inputField.value.trim();
        if (message) {
            // Add user message to UI
            this.addMessage(message, 'user', this.isMarkdownMode);
            this.inputField.value = '';
            // Reset expanded state if needed after sending
            if (this.isInputExpanded) {
                this.inputField.style.height = '100px';
            }
            else {
                this.inputField.style.height = 'auto';
                this.inputField.rows = 1;
            }
            // Create a temporary message container for the bot's streaming response
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'bot-message';
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            botMessageDiv.appendChild(markdownIndicator);
            // Create separate divs for streaming text and final markdown
            const streamingDiv = document.createElement('div');
            streamingDiv.className = 'streaming-content';
            streamingDiv.style.whiteSpace = 'pre-wrap';
            streamingDiv.style.fontFamily = 'monospace';
            streamingDiv.style.fontSize = '0.9em';
            botMessageDiv.appendChild(streamingDiv);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            contentDiv.style.display = 'none'; // Initially hidden
            botMessageDiv.appendChild(contentDiv);
            this.messageContainer.appendChild(botMessageDiv);
            // Variable to collect the complete response
            let completeResponse = '';
            // Get cell context if available
            const cellContext = globals_1.globals.cellContextTracker ?
                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;
            // Stream response from API
            this.apiClient.streamChat(message, { cellContext }, 
            // On each chunk received
            (chunk) => {
                completeResponse += chunk;
                streamingDiv.textContent = completeResponse;
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On complete
            () => {
                // Hide streaming div, show markdown div
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                // Pre-process and render markdown
                try {
                    // Pre-process the markdown to fix any issues with code blocks
                    const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
                    // Parse and sanitize
                    const rawHtml = marked_1.marked.parse(processedMarkdown);
                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                    // Apply the HTML with proper code block styling
                    contentDiv.innerHTML = sanitizedHtml;
                    // Add syntax highlighting classes to code blocks
                    const codeBlocks = contentDiv.querySelectorAll('pre code');
                    codeBlocks.forEach(block => {
                        var _a;
                        block.classList.add('jp-RenderedText');
                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                    });
                }
                catch (error) {
                    contentDiv.textContent = completeResponse;
                    console.error('Failed to render markdown:', error);
                }
                // Save to chat history
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages.push({
                        text: completeResponse,
                        sender: 'bot',
                        isMarkdown: true
                    });
                }
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On error
            (error) => {
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                contentDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                console.error('API Error:', error);
            });
        }
    }
    /**
     * Adds a message to the chat interface
     */
    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {
        const messageDiv = document.createElement('div');
        messageDiv.className = sender === 'user' ? 'user-message' : 'bot-message';
        // Add message content
        if (isMarkdown || sender === 'bot') {
            // Bot messages are always rendered as markdown
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            messageDiv.appendChild(markdownIndicator);
            // Create a container for the rendered markdown
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            try {
                // Pre-process the markdown text
                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
                // Parse and render markdown
                const rawHtml = marked_1.marked.parse(processedText);
                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                contentDiv.innerHTML = sanitizedHtml;
                // Add syntax highlighting classes to code blocks
                const codeBlocks = contentDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    var _a;
                    block.classList.add('jp-RenderedText');
                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                });
            }
            catch (error) {
                contentDiv.textContent = text;
                console.error('Failed to render markdown:', error);
            }
            messageDiv.appendChild(contentDiv);
        }
        else {
            messageDiv.textContent = text;
        }
        this.messageContainer.appendChild(messageDiv);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        // Save to chat history
        if (saveToHistory) {
            const chat = this.chatHistory.find(c => c.id === this.currentChatId);
            if (chat) {
                chat.messages.push({
                    text,
                    sender,
                    isMarkdown: isMarkdown || sender === 'bot'
                });
            }
        }
    }
    /**
     * Lists the contents of the current directory
     */
    async listCurrentDirectoryContents() {
        let dirPath = null;
        let source = null;
        // Try to get directory path from current widget
        const app = globals_1.globals.app;
        if (!app) {
            this.addMessage('Error: Application reference not available', 'bot', false);
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                const lastSlash = path.lastIndexOf('/');
                dirPath = lastSlash === -1 ? '' : path.substring(0, lastSlash);
                source = 'widget context';
            }
        }
        // Fallback to notebook tracker if no context from widget
        if (dirPath === null && globals_1.globals.notebookTracker) {
            const currentNotebookPanel = globals_1.globals.notebookTracker.currentWidget;
            if (currentNotebookPanel instanceof notebook_1.NotebookPanel) {
                const nbPath = currentNotebookPanel.context.path;
                const lastSlash = nbPath.lastIndexOf('/');
                dirPath = lastSlash === -1 ? '' : nbPath.substring(0, lastSlash);
                source = 'active notebook';
            }
        }
        // List contents if path was found
        if (dirPath !== null) {
            try {
                const contents = await this.docManager.services.contents.get(dirPath);
                if (contents.content && contents.content.length > 0) {
                    const messageContent = `Directory contents (${source}):\n${contents.content.map((item) => `- ${item.name} (${item.type})`).join('\n')}`;
                    this.addMessage(messageContent, 'bot', true);
                }
                else {
                    this.addMessage(`Directory "${dirPath || '/'}" is empty.`, 'bot', true);
                }
            }
            catch (error) {
                this.addMessage(`Error listing directory contents for "${dirPath}": ${error}`, 'bot', true);
            }
        }
        else {
            this.addMessage('Could not determine current directory context.', 'bot', true);
        }
    }
    /**
     * Shows the command menu at the specified position
     */
    showCommandMenu(x, y) {
        const commands = [
            {
                label: 'code',
                description: 'Insert selected code',
                action: () => this.handleCodeCommand()
            },
            {
                label: 'cell',
                description: 'Insert entire cell content',
                action: () => this.handleCellCommand()
            }
        ];
        // Clear existing content
        this.commandMenuContainer.innerHTML = '';
        // Create menu items
        commands.forEach(cmd => {
            const item = document.createElement('div');
            item.className = 'command-menu-item';
            const label = document.createElement('div');
            label.className = 'command-label';
            label.textContent = cmd.label;
            const desc = document.createElement('div');
            desc.className = 'command-description';
            desc.textContent = cmd.description;
            item.appendChild(label);
            item.appendChild(desc);
            item.addEventListener('click', () => {
                cmd.action();
                this.hideCommandMenu();
            });
            this.commandMenuContainer.appendChild(item);
        });
        // Position and show menu
        this.commandMenuContainer.style.position = 'absolute';
        this.commandMenuContainer.style.left = `${x}px`;
        this.commandMenuContainer.style.top = `${y}px`;
        this.commandMenuContainer.style.display = 'block';
        // Add click outside listener
        document.addEventListener('click', this.handleClickOutside);
    }
    /**
     * Hides the command menu
     */
    hideCommandMenu() {
        this.commandMenuContainer.style.display = 'none';
        document.removeEventListener('click', this.handleClickOutside);
    }
    /**
     * Handles the code command - inserts selected code
     */
    handleCodeCommand() {
        var _a;
        const selectedText = this.getSelectedText();
        if (selectedText) {
            this.appendToInput(`@code\n${selectedText}`);
        }
        else {
            // If no selection, get the entire cell content
            const cellContext = (_a = globals_1.globals.cellContextTracker) === null || _a === void 0 ? void 0 : _a.getCurrentCellContext();
            if (cellContext) {
                this.appendToInput(`@code\n${cellContext.text}`);
            }
        }
    }
    /**
     * Handles the cell command - inserts entire cell content
     */
    handleCellCommand() {
        var _a;
        const cellContext = (_a = globals_1.globals.cellContextTracker) === null || _a === void 0 ? void 0 : _a.getCurrentCellContext();
        if (cellContext) {
            this.appendToInput(`@cell\n${cellContext.text}`);
        }
    }
    /**
     * Appends text to the input field with proper spacing
     */
    appendToInput(text) {
        try {
            const currentValue = this.inputField.value;
            if (currentValue) {
                // If there's existing content, add a newline before appending
                this.inputField.value = `${currentValue}\n\n${text}`;
            }
            else {
                this.inputField.value = text;
            }
            // Focus the input field and move cursor to end
            this.inputField.focus();
            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    /**
     * Gets the selected text from cell context
     */
    getSelectedText() {
        var _a;
        // Get the current active cell from the tracker
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell || !cell.editor) {
            return '';
        }
        // Get the CodeMirror editor instance
        const editor = cell.editor;
        const view = editor.editor;
        if (!view) {
            return '';
        }
        // Get the selection from CodeMirror
        const state = view.state;
        const selection = state.selection;
        // If there's no selection, return empty string
        if (selection.main.empty) {
            return '';
        }
        // Get the selected text
        const from = selection.main.from;
        const to = selection.main.to;
        return state.doc.sliceString(from, to);
    }
}
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy41ODkyZTdmYWM0N2ZiMGM2N2MzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7OztBQ3JFSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQ0FBa0MsRUFBRSwwQ0FBMEM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMscURBQXFEO0FBQ25FLGNBQWMsc0RBQXNEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsa0RBQWtEO0FBQ2hFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvYXBpLWNsaWVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jZWxsLWNvbnRleHQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9nbG9iYWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2ljb25zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL21hcmtkb3duLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9zaWRlYmFyLXdpZGdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBpQ2xpZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBBUEkgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kIExMTSBzZXJ2aWNlXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYmFzZVVybCA9ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnKSB7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBhIGNoYXQgcmVzcG9uc2UgZnJvbSB0aGUgbW9jayBMTE1cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgdXNlciBtZXNzYWdlIHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIG9uQ2h1bmsgQ2FsbGJhY2sgZm9yIGVhY2ggdGV4dCBjaHVuayByZWNlaXZlZFxuICAgICAqIEBwYXJhbSBvbkNvbXBsZXRlIENhbGxiYWNrIHdoZW4gc3RyZWFtaW5nIGlzIGNvbXBsZXRlXG4gICAgICogQHBhcmFtIG9uRXJyb3IgQ2FsbGJhY2sgZm9yIGVycm9yc1xuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbUNoYXQobWVzc2FnZSwgY29udGV4dCA9IG51bGwsIG9uQ2h1bmssIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9jaGF0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZVN0cmVhbSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB1cCBzdHJlYW0gcmVhZGluZ1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lOiByZWFkZXJEb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGRvbmUgPSByZWFkZXJEb25lO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogIWRvbmUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgaGVhbHRoIGNoZWNrIGZvciB0aGUgQVBJXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgQVBJIGlzIGhlYWx0aHlcbiAgICAgKi9cbiAgICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9oZWFsdGhgKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBoZWFsdGggY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXBpQ2xpZW50ID0gQXBpQ2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNlbGxDb250ZXh0VHJhY2tlciA9IHZvaWQgMDtcbi8qKlxuICogVHJhY2tzIGNlbGwgY29udGV4dCBhbmQgY3Vyc29yIHBvc2l0aW9uIHdpdGhpbiBKdXB5dGVyIG5vdGVib29rc1xuICovXG5jbGFzcyBDZWxsQ29udGV4dFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgbm90ZWJvb2tUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgZWRpdG9yIGV2ZW50cyAoa2V5ZG93biwgbW91c2V1cClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjZWxsIGZyb20gdGhlIHRyYWNrZXJcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwgfHwgIWNlbGwuZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5uZXIgRWRpdG9yVmlldyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEdldCBhbmQgc3RvcmUgdGhlIGN1cnNvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlZGl0b3IgZXZlbnQgaGFuZGxlcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlciA9IG5vdGVib29rVHJhY2tlcjtcbiAgICAgICAgdGhpcy5zZXR1cFRyYWNrZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBvYmplY3QgaGFzIGJlZW4gZGlzcG9zZWRcbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgdHJhY2tlcnNcbiAgICAgKi9cbiAgICBzZXR1cFRyYWNrZXJzKCkge1xuICAgICAgICAvLyBIYW5kbGUgYWN0aXZlIGNlbGwgY2hhbmdlc1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsQ2hhbmdlZC5jb25uZWN0KHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgLy8gSGFuZGxlIG5vdGVib29rIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuY29ubmVjdCh0aGlzLmhhbmRsZU5vdGVib29rQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBub3RlYm9vayBjaGFuZ2VzXG4gICAgICovXG4gICAgaGFuZGxlTm90ZWJvb2tDaGFuZ2UodHJhY2tlciwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHBhbmVsICYmIHBhbmVsLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBwYW5lbC5jb250ZW50LmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ2VsbExpc3RlbmVycyh0cmFja2VyLCBjZWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgYWN0aXZlIGNlbGxcbiAgICAgKi9cbiAgICBzZXR1cENlbGxMaXN0ZW5lcnMoX3RyYWNrZXIsIGNlbGwpIHtcbiAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICBpZiAoY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbE5vZGUgPSBjZWxsLm5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yTm9kZSA9IGNlbGxOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1FZGl0b3InKSB8fFxuICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtSW5wdXRBcmVhLWVkaXRvcicpO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBlZGl0b3JOb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIGZvciBrZXkgYW5kIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjYXB0dXJlIGltbWVkaWF0ZSBjb250ZXh0IGlmIEVkaXRvclZpZXcgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjZWxsLmVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IHRoaXMuZ2V0Q21Db250ZXh0KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdXAgY2VsbCBsaXN0ZW5lcnM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIHByZXZpb3VzIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY29udGV4dCBpbmZvcm1hdGlvbiBmcm9tIENvZGVNaXJyb3IgRWRpdG9yVmlld1xuICAgICAqL1xuICAgIGdldENtQ29udGV4dCh2aWV3KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgY29uc3QgZnVsbFRleHQgPSBzdGF0ZS5kb2MudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLm51bWJlciAtIDEsXG4gICAgICAgICAgICBjb2x1bW46IG9mZnNldCAtIGxpbmUuZnJvbSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHRSYWRpdXMgPSAxMDA7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgb2Zmc2V0IC0gY29udGV4dFJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGZ1bGxUZXh0Lmxlbmd0aCwgb2Zmc2V0ICsgY29udGV4dFJhZGl1cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBmdWxsVGV4dCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIGNvbnRleHRCZWZvcmU6IGZ1bGxUZXh0LnN1YnN0cmluZyhzdGFydCwgb2Zmc2V0KSxcbiAgICAgICAgICAgIGNvbnRleHRBZnRlcjogZnVsbFRleHQuc3Vic3RyaW5nKG9mZnNldCwgZW5kKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGNlbGwgY29udGV4dFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDZWxsQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENlbGxDb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuZGlzY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSBDZWxsQ29udGV4dFRyYWNrZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnaXN0ZXJDb21tYW5kcyA9IHJlZ2lzdGVyQ29tbWFuZHM7XG5jb25zdCBpY29uc18xID0gcmVxdWlyZShcIi4vaWNvbnNcIik7XG4vKipcbiAqIFJlZ2lzdGVycyBjb21tYW5kcyBmb3IgdGhlIGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiByZWdpc3RlckNvbW1hbmRzKGFwcCwgcGFsZXR0ZSwgbGF1bmNoZXIsIHNpZGViYXJXaWRnZXQpIHtcbiAgICAvLyBBZGQgY29tbWFuZCB0byB0b2dnbGUgdGhlIHNpZGViYXJcbiAgICBhcHAuY29tbWFuZHMuYWRkQ29tbWFuZCgnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsIHtcbiAgICAgICAgbGFiZWw6ICdUb2dnbGUgQUkgQXNzaXN0YW50IFNpZGViYXInLFxuICAgICAgICBpY29uOiBpY29uc18xLmV4dGVuc2lvbkljb24sXG4gICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzaWRlYmFyV2lkZ2V0LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBzaWRlYmFyV2lkZ2V0LnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHAuc2hlbGwuYWRkKHNpZGViYXJXaWRnZXQsICdsZWZ0JywgeyByYW5rOiA5OTk5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIHRoZSBjb21tYW5kIHRvIHRoZSBjb21tYW5kIHBhbGV0dGVcbiAgICBwYWxldHRlLmFkZEl0ZW0oe1xuICAgICAgICBjb21tYW5kOiAnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsXG4gICAgICAgIGNhdGVnb3J5OiAnRXh0ZW5zaW9uJ1xuICAgIH0pO1xuICAgIC8vIEFkZCBhIGxhdW5jaGVyIGl0ZW1cbiAgICBsYXVuY2hlci5hZGQoe1xuICAgICAgICBjb21tYW5kOiAnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsXG4gICAgICAgIGNhdGVnb3J5OiAnT3RoZXInLFxuICAgICAgICByYW5rOiA5OTk5XG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2xvYmFscyA9IHZvaWQgMDtcbmV4cG9ydHMuaW5pdEdsb2JhbHMgPSBpbml0R2xvYmFscztcbi8qKlxuICogR2xvYmFsIHJlZmVyZW5jZXMgdG8ga2V5IGNvbXBvbmVudHMgaW4gdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZ2xvYmFscyA9IHt9O1xuLyoqXG4gKiBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzXG4gKi9cbmZ1bmN0aW9uIGluaXRHbG9iYWxzKGFwcCwgbm90ZWJvb2tUcmFja2VyKSB7XG4gICAgZXhwb3J0cy5nbG9iYWxzLmFwcCA9IGFwcDtcbiAgICBleHBvcnRzLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyID0gbm90ZWJvb2tUcmFja2VyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuc2lvbkljb24gPSB2b2lkIDA7XG5jb25zdCB1aV9jb21wb25lbnRzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50c1wiKTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEljb24gRGVmaW5pdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgaWNvblN2Z1N0ciA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJiaSBiaS1jaGF0LWxlZnQtdGV4dFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj4nICtcbiAgICAnPHBhdGggZD1cIk0xNCAxYTEgMSAwIDAgMSAxIDF2OGExIDEgMCAwIDEtMSAxSDQuNDE0QTIgMiAwIDAgMCAzIDExLjU4NmwtMiAyVjJhMSAxIDAgMCAxIDEtMWgxMnpNMiAwYTIgMiAwIDAgMC0yIDJ2MTIuNzkzYS41LjUgMCAwIDAgLjg1NC4zNTNsMi44NTMtMi44NTNBMSAxIDAgMCAxIDQuNDE0IDEySDE0YTIgMiAwIDAgMCAyLTJWMmEyIDIgMCAwIDAtMi0ySDJ6XCIvPicgK1xuICAgICc8cGF0aCBkPVwiTTMgMy41YS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOWEuNS41IDAgMCAxLS41LS41ek0zIDZhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05QS41LjUgMCAwIDEgMyA2em0wIDIuNWEuNS41IDAgMCAxIC41LS41aDVhLjUuNSAwIDAgMSAwIDFoLTVhLjUuNSAwIDAgMS0uNS0uNXpcIi8+JyArXG4gICAgJzwvc3ZnPic7XG4vKipcbiAqIEljb24gZm9yIHRoZSBBSSBBc3Npc3RhbnQgZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydHMuZXh0ZW5zaW9uSWNvbiA9IG5ldyB1aV9jb21wb25lbnRzXzEuTGFiSWNvbih7XG4gICAgbmFtZTogJ3NpbXBsZTppY29uJyxcbiAgICBzdmdzdHI6IGljb25TdmdTdHJcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGxhdW5jaGVyXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbGF1bmNoZXJcIik7XG5jb25zdCBhcHB1dGlsc18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2FwcHV0aWxzXCIpO1xuY29uc3Qgbm90ZWJvb2tfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9ub3RlYm9va1wiKTtcbmNvbnN0IGRvY21hbmFnZXJfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9kb2NtYW5hZ2VyXCIpO1xuY29uc3Qgc2lkZWJhcl93aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3NpZGViYXItd2lkZ2V0XCIpO1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kc1wiKTtcbmNvbnN0IGNlbGxfY29udGV4dF90cmFja2VyXzEgPSByZXF1aXJlKFwiLi9jZWxsLWNvbnRleHQtdHJhY2tlclwiKTtcbi8vIGltcG9ydCB7IEFwaUNsaWVudCB9IGZyb20gJy4vYXBpLWNsaWVudCc7XG4vLyBFeHBvcnQgQXBpQ2xpZW50IGZvciB1c2UgYnkgb3RoZXIgY29tcG9uZW50c1xudmFyIGFwaV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2FwaS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcGlDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwaV9jbGllbnRfMS5BcGlDbGllbnQ7IH0gfSk7XG4vKipcbiAqIEluaXRpYWxpemF0aW9uIGRhdGEgZm9yIHRoZSBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gZXh0ZW5zaW9uLlxuICovXG5jb25zdCBwbHVnaW4gPSB7XG4gICAgaWQ6ICdqdXB5dGVyLXNpbXBsZS1leHRlbnNpb246cGx1Z2luJyxcbiAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgcmVxdWlyZXM6IFtsYXVuY2hlcl8xLklMYXVuY2hlciwgYXBwdXRpbHNfMS5JQ29tbWFuZFBhbGV0dGUsIG5vdGVib29rXzEuSU5vdGVib29rVHJhY2tlciwgZG9jbWFuYWdlcl8xLklEb2N1bWVudE1hbmFnZXJdLFxuICAgIGFjdGl2YXRlOiAoanVweXRlckFwcCwgbGF1bmNoZXIsIHBhbGV0dGUsIHRyYWNrZXIsIGRvY01hbmFnZXIpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0p1cHl0ZXJMYWIgZXh0ZW5zaW9uIGp1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbiBpcyBhY3RpdmF0ZWQhJyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsIHJlZmVyZW5jZXNcbiAgICAgICAgKDAsIGdsb2JhbHNfMS5pbml0R2xvYmFscykoanVweXRlckFwcCwgdHJhY2tlcik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2VsbCBjb250ZXh0IHRyYWNrZXJcbiAgICAgICAgZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyID0gbmV3IGNlbGxfY29udGV4dF90cmFja2VyXzEuQ2VsbENvbnRleHRUcmFja2VyKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBzaWRlYmFyIHdpZGdldFxuICAgICAgICBjb25zdCBzaWRlYmFyV2lkZ2V0ID0gbmV3IHNpZGViYXJfd2lkZ2V0XzEuU2ltcGxlU2lkZWJhcldpZGdldChkb2NNYW5hZ2VyKTtcbiAgICAgICAganVweXRlckFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGNvbW1hbmRzXG4gICAgICAgICgwLCBjb21tYW5kc18xLnJlZ2lzdGVyQ29tbWFuZHMpKGp1cHl0ZXJBcHAsIHBhbGV0dGUsIGxhdW5jaGVyLCBzaWRlYmFyV2lkZ2V0KTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcGx1Z2luO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbmZpZ3VyZU1hcmtlZCA9IGNvbmZpZ3VyZU1hcmtlZDtcbmV4cG9ydHMucHJlcHJvY2Vzc01hcmtkb3duID0gcHJlcHJvY2Vzc01hcmtkb3duO1xuY29uc3QgbWFya2VkXzEgPSByZXF1aXJlKFwibWFya2VkXCIpO1xuLyoqXG4gKiBDb25maWd1cmUgbWFya2VkIHdpdGggYmV0dGVyIHJlbmRlcmluZyBvcHRpb25zIGZvciBjb2RlIGJsb2Nrc1xuICovXG5mdW5jdGlvbiBjb25maWd1cmVNYXJrZWQoKSB7XG4gICAgLy8gQ29uZmlndXJlIG1hcmtlZCBvcHRpb25zXG4gICAgbWFya2VkXzEubWFya2VkLnNldE9wdGlvbnMoe1xuICAgICAgICBnZm06IHRydWUsIC8vIEVuYWJsZSBHaXRIdWIgRmxhdm9yZWQgTWFya2Rvd25cbiAgICAgICAgYnJlYWtzOiB0cnVlLCAvLyBBZGQgPGJyPiBvbiBzaW5nbGUgbGluZSBicmVha3NcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLCAvLyBDb25mb3JtIHRvIG9yaWdpbmFsIG1hcmtkb3duIHNwZWNcbiAgICAgICAgYXN5bmM6IGZhbHNlLCAvLyBEaXNhYmxlIGFzeW5jIHJlbmRlcmluZ1xuICAgICAgICBzaWxlbnQ6IGZhbHNlIC8vIEVuYWJsZSBlcnJvciByZXBvcnRpbmdcbiAgICB9KTtcbn1cbi8qKlxuICogUHJlLXByb2Nlc3MgbWFya2Rvd24gdGV4dCB0byBmaXggY29tbW9uIGlzc3VlcyB3aXRoIHN0cmVhbWluZyBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIHByZXByb2Nlc3NNYXJrZG93bih0ZXh0KSB7XG4gICAgLy8gSGFuZGxlIGNvZGUgYmxvY2tzIGZpcnN0XG4gICAgbGV0IGluQ29kZUJsb2NrID0gZmFsc2U7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBwcm9jZXNzZWRMaW5lcyA9IGxpbmVzLm1hcCgobGluZSwgaSkgPT4ge1xuICAgICAgICAvLyBDaGVjayBmb3IgY29kZSBibG9jayBtYXJrZXJzXG4gICAgICAgIGlmIChsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdgYGAnKSkge1xuICAgICAgICAgICAgaW5Db2RlQmxvY2sgPSAhaW5Db2RlQmxvY2s7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBsYW5ndWFnZSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICByZXR1cm4gbGluZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgaW4gYSBjb2RlIGJsb2NrLCBwcmVzZXJ2ZSB0aGUgbGluZSBhcyBpc1xuICAgICAgICBpZiAoaW5Db2RlQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE91dHNpZGUgY29kZSBibG9ja3MsIGhhbmRsZSBsaXN0IGl0ZW1zXG4gICAgICAgIHJldHVybiBsaW5lLnJlcGxhY2UoLyhbXlxcblxcc10pLVxccy9nLCAnJDFcXG4tICcpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9jZXNzZWRMaW5lcy5qb2luKCdcXG4nKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW1wbGVTaWRlYmFyV2lkZ2V0ID0gdm9pZCAwO1xuY29uc3Qgd2lkZ2V0c18xID0gcmVxdWlyZShcIkBsdW1pbm8vd2lkZ2V0c1wiKTtcbmNvbnN0IG5vdGVib29rXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbm90ZWJvb2tcIik7XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG5jb25zdCBkb21wdXJpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tcHVyaWZ5XCIpKTtcbmNvbnN0IGljb25zXzEgPSByZXF1aXJlKFwiLi9pY29uc1wiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5jb25zdCBhcGlfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hcGktY2xpZW50XCIpO1xuY29uc3QgbWFya2Rvd25fY29uZmlnXzEgPSByZXF1aXJlKFwiLi9tYXJrZG93bi1jb25maWdcIik7XG4vLyBpbXBvcnQgeyBJQ2VsbENvbnRleHQgfSBmcm9tICcuL3R5cGVzJztcbi8vIGltcG9ydCB7IElDZWxsQ29udGV4dCB9IGZyb20gJy4vdHlwZXMnO1xuLy8gQ29uZmlndXJlIG1hcmtlZCB3aXRoIG91ciBzZXR0aW5nc1xuKDAsIG1hcmtkb3duX2NvbmZpZ18xLmNvbmZpZ3VyZU1hcmtlZCkoKTtcbi8qKlxuICogTWFpbiBzaWRlYmFyIHdpZGdldCBmb3IgdGhlIEFJIGNoYXQgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFNpbXBsZVNpZGViYXJXaWRnZXQgZXh0ZW5kcyB3aWRnZXRzXzEuV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NNYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSAnJztcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN0cmwrTCAoZm9yIHNlbGVjdGVkIGNvZGUpXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24ubWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHNlbGVjdGlvbiwgdXNlIEBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gc2VsZWN0aW9uLm1haW4uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gc2VsZWN0aW9uLm1haW4udG87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY29kZVxcbiR7c2VsZWN0ZWRUZXh0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignU2VsZWN0ZWQgY29kZSBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gc2VsZWN0aW9uLCB1c2UgQGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Q3VycmVudENlbGxDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjZWxsXFxuJHtjZWxsQ29udGV4dC50ZXh0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IoJ0NlbGwgY29udGVudCBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc2lkZWJhciBpcyB2aXNpYmxlIGFuZCBmb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIGtleWJvYXJkIHNob3J0Y3V0OicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGNsaWNrcyBvdXRzaWRlIHRoZSBjb21tYW5kIG1lbnVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tbWFuZE1lbnVDb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbW1hbmRNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZG9jTWFuYWdlciA9IGRvY01hbmFnZXI7XG4gICAgICAgIHRoaXMuaWQgPSAnc2ltcGxlLXNpZGViYXInO1xuICAgICAgICB0aGlzLnRpdGxlLmxhYmVsID0gJyc7XG4gICAgICAgIHRoaXMudGl0bGUuY2FwdGlvbiA9ICdBSSBDaGF0IEludGVyZmFjZSc7XG4gICAgICAgIHRoaXMudGl0bGUuaWNvbiA9IGljb25zXzEuZXh0ZW5zaW9uSWNvbjtcbiAgICAgICAgdGhpcy50aXRsZS5jbG9zYWJsZSA9IHRydWU7XG4gICAgICAgIC8vIEluaXRpYWxpemUgQVBJIGNsaWVudFxuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBhcGlfY2xpZW50XzEuQXBpQ2xpZW50KCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY29udGFpbmVyIGVsZW1lbnRzIGJlZm9yZSBjcmVhdGluZyBsYXlvdXRcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGhpcy50aXRsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuY29tbWFuZE1lbnVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5jb21tYW5kTWVudUNvbnRhaW5lci5jbGFzc05hbWUgPSAnY29tbWFuZC1tZW51LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMuY29tbWFuZE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gQ3JlYXRlIGtleWJvYXJkIHNob3J0Y3V0IGluZGljYXRvclxuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdrZXlib2FyZC1zaG9ydGN1dC1pbmRpY2F0b3InO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcik7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjaGF0IG9uIHN0YXJ0XG4gICAgICAgIHRoaXMuY3JlYXRlTmV3Q2hhdCgpO1xuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVMYXlvdXQoKSk7XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNvbW1hbmRNZW51Q29udGFpbmVyKTtcbiAgICAgICAgLy8gQWRkIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHZpc3VhbCBpbmRpY2F0b3IgZm9yIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIHNob3dLZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKHRleHQpIHtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gSGlkZSBhZnRlciAxIHNlY29uZFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgICAgICAvLyBSZW1vdmUga2V5Ym9hcmQgc2hvcnRjdXQgaW5kaWNhdG9yXG4gICAgICAgIGlmICh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1haW4gbGF5b3V0IGZvciB0aGUgc2lkZWJhclxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gJ3NpbXBsZS1zaWRlYmFyLWNvbnRlbnQnO1xuICAgICAgICAvLyBDcmVhdGUgdGl0bGUgaW5wdXQgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRpdGxlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICd0aXRsZS1jb250YWluZXInO1xuICAgICAgICAvLyBTZXQgdXAgdGl0bGUgaW5wdXRcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmNsYXNzTmFtZSA9ICdjaGF0LXRpdGxlLWlucHV0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5wbGFjZWhvbGRlciA9ICdDaGF0IHRpdGxlJztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnZhbHVlID0gJ05ldyBDaGF0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHRoaXMudXBkYXRlQ3VycmVudENoYXRUaXRsZSgpKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZUlucHV0KTtcbiAgICAgICAgLy8gQ29uZmlndXJlIHRvcCBhY3Rpb24gYnV0dG9ucyAoTmV3IENoYXQgJiBIaXN0b3J5KVxuICAgICAgICBjb25zdCB0b3BBY3Rpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvcEFjdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3RvcC1hY3Rpb25zLWNvbnRhaW5lcic7XG4gICAgICAgIGNvbnN0IG5ld0NoYXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGFjdGlvbi1idXR0b24nO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLnRleHRDb250ZW50ID0gJysgTmV3IENoYXQnO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLnRpdGxlID0gJ1N0YXJ0IGEgbmV3IGNoYXQnO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jcmVhdGVOZXdDaGF0KCkpO1xuICAgICAgICBjb25zdCBoaXN0b3J5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBhY3Rpb24tYnV0dG9uJztcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi50ZXh0Q29udGVudCA9ICdIaXN0b3J5JztcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi50aXRsZSA9ICdWaWV3IGNoYXQgaGlzdG9yeSc7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCkpO1xuICAgICAgICB0b3BBY3Rpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKG5ld0NoYXRCdXR0b24pO1xuICAgICAgICB0b3BBY3Rpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGhpc3RvcnlCdXR0b24pO1xuICAgICAgICAvLyBDb25maWd1cmUgbWVzc2FnZSBjb250YWluZXJcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdtZXNzYWdlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuY2xhc3NOYW1lID0gJ2hpc3RvcnktY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICAgICAgLy8gQ29uZmlndXJlIGlucHV0IGNvbnRhaW5lclxuICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdpbnB1dC1jb250YWluZXInO1xuICAgICAgICAvLyBDcmVhdGUgY29udHJvbHMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpO1xuICAgICAgICAvLyBDb25maWd1cmUgaW5wdXQgZmllbGRcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gJ0FzayBtZSBhbnl0aGluZy4uLic7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5mbGV4R3JvdyA9ICcxJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnBhZGRpbmcgPSAnNXB4JztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgI2NjYyc7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnM3B4JztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJvd3MgPSAxO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICAgICAgICAvLyBBZGQga2V5cHJlc3MgbGlzdGVuZXIgdG8gaW5wdXQgZmllbGRcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInICYmICFldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIHNlbmQgYnV0dG9uIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBpbnB1dEFjdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaW5wdXRBY3Rpb25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdpbnB1dC1hY3Rpb25zLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBzZW5kIGJ1dHRvblxuICAgICAgICBjb25zdCBzZW5kQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNlbmRCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBzZW5kLWJ1dHRvbic7XG4gICAgICAgIHNlbmRCdXR0b24udGV4dENvbnRlbnQgPSAnU2VuZCc7XG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKCkpO1xuICAgICAgICAvLyBBZGQgYnV0dG9uIHRvIGFjdGlvbnMgY29udGFpbmVyXG4gICAgICAgIGlucHV0QWN0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZW5kQnV0dG9uKTtcbiAgICAgICAgLy8gQXNzZW1ibGUgdGhlIGlucHV0IGNvbXBvbmVudHNcbiAgICAgICAgdGhpcy5pbnB1dENvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuaW5wdXRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dEZpZWxkKTtcbiAgICAgICAgdGhpcy5pbnB1dENvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dEFjdGlvbnNDb250YWluZXIpO1xuICAgICAgICAvLyBBc3NlbWJsZSBhbGwgY29tcG9uZW50c1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRvcEFjdGlvbnNDb250YWluZXIpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VDb250YWluZXIpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuaGlzdG9yeUNvbnRhaW5lcik7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvblxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQoKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgY2hhdFxuICAgICAgICBjb25zdCBjaGF0SWQgPSBgY2hhdC0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgaXRlbVxuICAgICAgICBjb25zdCBuZXdDaGF0ID0ge1xuICAgICAgICAgICAgaWQ6IGNoYXRJZCxcbiAgICAgICAgICAgIHRpdGxlOiAnTmV3IENoYXQnLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgLy8gU2V0IGFzIGN1cnJlbnQgY2hhdFxuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aXRsZSBpbnB1dFxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBuZXdDaGF0LnRpdGxlO1xuICAgICAgICAvLyBDbGVhciBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlkZSBoaXN0b3J5IGlmIGl0J3MgdmlzaWJsZVxuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBiZXR3ZWVuIGNoYXQgdmlldyBhbmQgaGlzdG9yeSB2aWV3XG4gICAgICovXG4gICAgdG9nZ2xlSGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9ICF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmU7XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFNob3cgaGlzdG9yeSB2aWV3LCBoaWRlIG1lc3NhZ2Ugdmlld1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hhdEhpc3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNob3cgbWVzc2FnZSB2aWV3LCBoaWRlIGhpc3Rvcnkgdmlld1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2hhdCBoaXN0b3J5IGluIHRoZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAqL1xuICAgIHJlbmRlckNoYXRIaXN0b3J5KCkge1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmNoYXRIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UuY2xhc3NOYW1lID0gJ2VtcHR5LWhpc3RvcnktbWVzc2FnZSc7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UudGV4dENvbnRlbnQgPSAnTm8gY2hhdCBoaXN0b3J5IHlldCc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGNoYXQgaGlzdG9yeSBpdGVtc1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5LmZvckVhY2goY2hhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY2xhc3NOYW1lID0gJ2hpc3RvcnktaXRlbSc7XG4gICAgICAgICAgICBpZiAoY2hhdC5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGl0bGVcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aXRsZS5jbGFzc05hbWUgPSAnaGlzdG9yeS10aXRsZSc7XG4gICAgICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IGNoYXQudGl0bGU7XG4gICAgICAgICAgICAvLyBBZGQgbWVzc2FnZSBwcmV2aWV3XG4gICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdoaXN0b3J5LXByZXZpZXcnO1xuICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBjaGF0Lm1lc3NhZ2VzW2NoYXQubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2aWV3LnRleHRDb250ZW50ID0gbGFzdE1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IGAke2xhc3RNZXNzYWdlLnRleHQuc3Vic3RyaW5nKDAsIDQwKX0ke2xhc3RNZXNzYWdlLnRleHQubGVuZ3RoID4gNDAgPyAnLi4uJyA6ICcnfWBcbiAgICAgICAgICAgICAgICA6ICdFbXB0eSBjaGF0JztcbiAgICAgICAgICAgIC8vIEFkZCBjbGljayBldmVudFxuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmxvYWRDaGF0KGNoYXQuaWQpKTtcbiAgICAgICAgICAgIGhpc3RvcnlJdGVtLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgICAgIGhpc3RvcnlJdGVtLmFwcGVuZENoaWxkKHByZXZpZXcpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmFwcGVuZENoaWxkKGhpc3RvcnlJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgY2hhdCBmcm9tIGhpc3RvcnlcbiAgICAgKi9cbiAgICBsb2FkQ2hhdChjaGF0SWQpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IGNoYXRJZCk7XG4gICAgICAgIGlmICghY2hhdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2V0IGFzIGN1cnJlbnQgY2hhdFxuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aXRsZVxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBjaGF0LnRpdGxlO1xuICAgICAgICAvLyBDbGVhciBhbmQgcmUtcG9wdWxhdGUgbWVzc2FnZSBjb250YWluZXJcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBjaGF0Lm1lc3NhZ2VzLmZvckVhY2gobXNnID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZShtc2cudGV4dCwgbXNnLnNlbmRlciwgbXNnLmlzTWFya2Rvd24sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN3aXRjaCBiYWNrIHRvIGNoYXQgdmlld1xuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgY2hhdFxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUoKSB7XG4gICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgY2hhdC50aXRsZSA9IHRoaXMudGl0bGVJbnB1dC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjb250cm9scyBjb250YWluZXIgd2l0aCB0b2dnbGVzIGFuZCBhY3Rpb24gYnV0dG9uc1xuICAgICAqL1xuICAgIGNyZWF0ZUNvbnRyb2xzQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBjb250cm9sc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY29udHJvbHMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtkb3duIHRvZ2dsZSBjb250YWluZXJcbiAgICAgICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAndG9nZ2xlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZG93biB0b2dnbGVcbiAgICAgICAgY29uc3QgbWFya2Rvd25Ub2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBtYXJrZG93blRvZ2dsZS50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuaWQgPSAnbWFya2Rvd24tdG9nZ2xlJztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuc3R5bGUubWFyZ2luUmlnaHQgPSAnNXB4JztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pc01hcmtkb3duTW9kZSA9IHRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gdGhpcy5pc01hcmtkb3duTW9kZSA/XG4gICAgICAgICAgICAgICAgJ1dyaXRlIG1hcmtkb3duIGhlcmUuLi5cXG5cXG4jIEV4YW1wbGUgaGVhZGluZ1xcbi0gTGlzdCBpdGVtXFxuXFxuYGBgY29kZSBibG9ja2BgYCcgOlxuICAgICAgICAgICAgICAgICdBc2sgbWUgYW55dGhpbmcuLi4nO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIHRvZ2dsZSBsYWJlbFxuICAgICAgICBjb25zdCB0b2dnbGVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHRvZ2dsZUxhYmVsLmh0bWxGb3IgPSAnbWFya2Rvd24tdG9nZ2xlJztcbiAgICAgICAgdG9nZ2xlTGFiZWwudGV4dENvbnRlbnQgPSAnTWFya2Rvd24gbW9kZSc7XG4gICAgICAgIHRvZ2dsZUxhYmVsLnN0eWxlLmZvbnRTaXplID0gJzEycHgnO1xuICAgICAgICAvLyBBZGQgdG9nZ2xlIGVsZW1lbnRzIHRvIGNvbnRhaW5lclxuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQobWFya2Rvd25Ub2dnbGUpO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlTGFiZWwpO1xuICAgICAgICAvLyBDcmVhdGUgYWN0aW9uIGJ1dHRvbnMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGFjdGlvbkJ1dHRvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnYWN0aW9uLWJ1dHRvbnMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBhY3Rpb24gYnV0dG9uc1xuICAgICAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdAJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbW1hbmQgbGlzdCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dDb21tYW5kTWVudShyZWN0LmxlZnQsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0ZXh0OiAn8J+TjicsIHRpdGxlOiAnVXBsb2FkIGZpbGUnLCBhY3Rpb246ICgpID0+IHsgfSB9LFxuICAgICAgICAgICAgeyB0ZXh0OiAn8J+UjScsIHRpdGxlOiAnQnJvd3NlIGZpbGVzJywgYWN0aW9uOiAoKSA9PiB7IH0gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAn4qSiJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0V4cGFuZCBpbnB1dCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKGFjdGlvbkJ1dHRvbnNDb250YWluZXIuY2hpbGRyZW5bM10pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0ZXh0OiAn4pqZ77iPJywgdGl0bGU6ICdTZXR0aW5ncycsIGFjdGlvbjogKCkgPT4geyB9IH0sXG4gICAgICAgICAgICB7IHRleHQ6ICfwn5OBJywgdGl0bGU6ICdMaXN0IERpcmVjdG9yeSBDb250ZW50cycsIGFjdGlvbjogKCkgPT4gdGhpcy5saXN0Q3VycmVudERpcmVjdG9yeUNvbnRlbnRzKCkgfVxuICAgICAgICBdO1xuICAgICAgICAvLyBBZGQgYWxsIGJ1dHRvbnMgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ0biA9IHRoaXMuY3JlYXRlQnV0dG9uKGJ1dHRvbi50ZXh0LCBidXR0b24udGl0bGUpO1xuICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IGJ1dHRvbi5hY3Rpb24oZSkpO1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRvZ2dsZSBhbmQgYWN0aW9uIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2xzIGNvbnRhaW5lclxuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0b2dnbGVDb250YWluZXIpO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b25zQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzQ29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgdG9nZ2xlSW5wdXRFeHBhbnNpb24oYnV0dG9uKSB7XG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gIXRoaXMuaXNJbnB1dEV4cGFuZGVkO1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0RXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSAn4qShJztcbiAgICAgICAgICAgIGJ1dHRvbi50aXRsZSA9ICdDb2xsYXBzZSBpbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKInO1xuICAgICAgICAgICAgYnV0dG9uLnRpdGxlID0gJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGJ1dHRvbiB3aXRoIGdpdmVuIHRleHQgYW5kIHRvb2x0aXBcbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b24odGV4dCwgdG9vbHRpcCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24gYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2VuZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kTWVzc2FnZSgpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZS50cmltKCk7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIFVJXG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZSwgJ3VzZXInLCB0aGlzLmlzTWFya2Rvd25Nb2RlKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgLy8gUmVzZXQgZXhwYW5kZWQgc3RhdGUgaWYgbmVlZGVkIGFmdGVyIHNlbmRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucm93cyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgbWVzc2FnZSBjb250YWluZXIgZm9yIHRoZSBib3QncyBzdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGJvdE1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gJ2JvdC1tZXNzYWdlJztcbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci50ZXh0Q29udGVudCA9IFwiTURcIjtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdtYXJrZG93bi1pbmRpY2F0b3InO1xuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChtYXJrZG93bkluZGljYXRvcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc2VwYXJhdGUgZGl2cyBmb3Igc3RyZWFtaW5nIHRleHQgYW5kIGZpbmFsIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBzdHJlYW1pbmdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5jbGFzc05hbWUgPSAnc3RyZWFtaW5nLWNvbnRlbnQnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnbW9ub3NwYWNlJztcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5mb250U2l6ZSA9ICcwLjllbSc7XG4gICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pdGlhbGx5IGhpZGRlblxuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RNZXNzYWdlRGl2KTtcbiAgICAgICAgICAgIC8vIFZhcmlhYmxlIHRvIGNvbGxlY3QgdGhlIGNvbXBsZXRlIHJlc3BvbnNlXG4gICAgICAgICAgICBsZXQgY29tcGxldGVSZXNwb25zZSA9ICcnO1xuICAgICAgICAgICAgLy8gR2V0IGNlbGwgY29udGV4dCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyID9cbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIuZ2V0Q3VycmVudENlbGxDb250ZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgLy8gU3RyZWFtIHJlc3BvbnNlIGZyb20gQVBJXG4gICAgICAgICAgICB0aGlzLmFwaUNsaWVudC5zdHJlYW1DaGF0KG1lc3NhZ2UsIHsgY2VsbENvbnRleHQgfSwgXG4gICAgICAgICAgICAvLyBPbiBlYWNoIGNodW5rIHJlY2VpdmVkXG4gICAgICAgICAgICAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi50ZXh0Q29udGVudCA9IGNvbXBsZXRlUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIE9uIGNvbXBsZXRlXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IG1hcmtkb3duIGRpdlxuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgLy8gUHJlLXByb2Nlc3MgYW5kIHJlbmRlciBtYXJrZG93blxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBtYXJrZG93biB0byBmaXggYW55IGlzc3VlcyB3aXRoIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZE1hcmtkb3duID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCBzYW5pdGl6ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdIdG1sID0gbWFya2VkXzEubWFya2VkLnBhcnNlKHByb2Nlc3NlZE1hcmtkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBIVE1MIHdpdGggcHJvcGVyIGNvZGUgYmxvY2sgc3R5bGluZ1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IHNhbml0aXplZEh0bWw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzeW50YXggaGlnaGxpZ2h0aW5nIGNsYXNzZXMgdG8gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkVGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYmxvY2sucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSBjb21wbGV0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVuZGVyIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0byBjaGF0IGhpc3RvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgICAgICBjaGF0Lm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29tcGxldGVSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogJ2JvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01hcmtkb3duOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gT24gZXJyb3JcbiAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImVycm9yLW1lc3NhZ2VcIj5FcnJvcjogJHtlcnJvci5tZXNzYWdlfTwvZGl2PmA7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQVBJIEVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBjaGF0IGludGVyZmFjZVxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2UodGV4dCwgc2VuZGVyLCBpc01hcmtkb3duID0gZmFsc2UsIHNhdmVUb0hpc3RvcnkgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWVzc2FnZURpdi5jbGFzc05hbWUgPSBzZW5kZXIgPT09ICd1c2VyJyA/ICd1c2VyLW1lc3NhZ2UnIDogJ2JvdC1tZXNzYWdlJztcbiAgICAgICAgLy8gQWRkIG1lc3NhZ2UgY29udGVudFxuICAgICAgICBpZiAoaXNNYXJrZG93biB8fCBzZW5kZXIgPT09ICdib3QnKSB7XG4gICAgICAgICAgICAvLyBCb3QgbWVzc2FnZXMgYXJlIGFsd2F5cyByZW5kZXJlZCBhcyBtYXJrZG93blxuICAgICAgICAgICAgY29uc3QgbWFya2Rvd25JbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLnRleHRDb250ZW50ID0gXCJNRFwiO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IuY2xhc3NOYW1lID0gJ21hcmtkb3duLWluZGljYXRvcic7XG4gICAgICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKG1hcmtkb3duSW5kaWNhdG9yKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhlIHJlbmRlcmVkIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlLXByb2Nlc3MgdGhlIG1hcmtkb3duIHRleHRcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRUZXh0ID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikodGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHJlbmRlciBtYXJrZG93blxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBzeW50YXggaGlnaGxpZ2h0aW5nIGNsYXNzZXMgdG8gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgICAgIGNvZGVCbG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suY2xhc3NMaXN0LmFkZCgnanAtUmVuZGVyZWRUZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGJsb2NrLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZEhUTUxDb21tb24nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VEaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChtZXNzYWdlRGl2KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIC8vIFNhdmUgdG8gY2hhdCBoaXN0b3J5XG4gICAgICAgIGlmIChzYXZlVG9IaXN0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICAgICAgY2hhdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICBpc01hcmtkb3duOiBpc01hcmtkb3duIHx8IHNlbmRlciA9PT0gJ2JvdCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgY29udGVudHMgb2YgdGhlIGN1cnJlbnQgZGlyZWN0b3J5XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cygpIHtcbiAgICAgICAgbGV0IGRpclBhdGggPSBudWxsO1xuICAgICAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBkaXJlY3RvcnkgcGF0aCBmcm9tIGN1cnJlbnQgd2lkZ2V0XG4gICAgICAgIGNvbnN0IGFwcCA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcDtcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSgnRXJyb3I6IEFwcGxpY2F0aW9uIHJlZmVyZW5jZSBub3QgYXZhaWxhYmxlJywgJ2JvdCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2hlbGxXaWRnZXQgPSBhcHAuc2hlbGwuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRTaGVsbFdpZGdldCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGV4dCA9IHRoaXMuZG9jTWFuYWdlci5jb250ZXh0Rm9yV2lkZ2V0KGN1cnJlbnRTaGVsbFdpZGdldCk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aWRnZXRDb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSBsYXN0U2xhc2ggPT09IC0xID8gJycgOiBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9ICd3aWRnZXQgY29udGV4dCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gbm90ZWJvb2sgdHJhY2tlciBpZiBubyBjb250ZXh0IGZyb20gd2lkZ2V0XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsICYmIGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vdGVib29rUGFuZWwgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm90ZWJvb2tQYW5lbCBpbnN0YW5jZW9mIG5vdGVib29rXzEuTm90ZWJvb2tQYW5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5iUGF0aCA9IGN1cnJlbnROb3RlYm9va1BhbmVsLmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBuYlBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgICBkaXJQYXRoID0gbGFzdFNsYXNoID09PSAtMSA/ICcnIDogbmJQYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdhY3RpdmUgbm90ZWJvb2snO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExpc3QgY29udGVudHMgaWYgcGF0aCB3YXMgZm91bmRcbiAgICAgICAgaWYgKGRpclBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSBhd2FpdCB0aGlzLmRvY01hbmFnZXIuc2VydmljZXMuY29udGVudHMuZ2V0KGRpclBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5jb250ZW50ICYmIGNvbnRlbnRzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlQ29udGVudCA9IGBEaXJlY3RvcnkgY29udGVudHMgKCR7c291cmNlfSk6XFxuJHtjb250ZW50cy5jb250ZW50Lm1hcCgoaXRlbSkgPT4gYC0gJHtpdGVtLm5hbWV9ICgke2l0ZW0udHlwZX0pYCkuam9pbignXFxuJyl9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2VDb250ZW50LCAnYm90JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoYERpcmVjdG9yeSBcIiR7ZGlyUGF0aCB8fCAnLyd9XCIgaXMgZW1wdHkuYCwgJ2JvdCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZShgRXJyb3IgbGlzdGluZyBkaXJlY3RvcnkgY29udGVudHMgZm9yIFwiJHtkaXJQYXRofVwiOiAke2Vycm9yfWAsICdib3QnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSgnQ291bGQgbm90IGRldGVybWluZSBjdXJyZW50IGRpcmVjdG9yeSBjb250ZXh0LicsICdib3QnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgY29tbWFuZCBtZW51IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzaG93Q29tbWFuZE1lbnUoeCwgeSkge1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5zZXJ0IHNlbGVjdGVkIGNvZGUnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gdGhpcy5oYW5kbGVDb2RlQ29tbWFuZCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnY2VsbCcsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdJbnNlcnQgZW50aXJlIGNlbGwgY29udGVudCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiB0aGlzLmhhbmRsZUNlbGxDb21tYW5kKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgY29udGVudFxuICAgICAgICB0aGlzLmNvbW1hbmRNZW51Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAvLyBDcmVhdGUgbWVudSBpdGVtc1xuICAgICAgICBjb21tYW5kcy5mb3JFYWNoKGNtZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICdjb21tYW5kLW1lbnUtaXRlbSc7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ2NvbW1hbmQtbGFiZWwnO1xuICAgICAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBjbWQubGFiZWw7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkZXNjLmNsYXNzTmFtZSA9ICdjb21tYW5kLWRlc2NyaXB0aW9uJztcbiAgICAgICAgICAgIGRlc2MudGV4dENvbnRlbnQgPSBjbWQuZGVzY3JpcHRpb247XG4gICAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZGVzYyk7XG4gICAgICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNtZC5hY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb21tYW5kTWVudSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUG9zaXRpb24gYW5kIHNob3cgbWVudVxuICAgICAgICB0aGlzLmNvbW1hbmRNZW51Q29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5jb21tYW5kTWVudUNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgICAgIHRoaXMuY29tbWFuZE1lbnVDb250YWluZXIuc3R5bGUudG9wID0gYCR7eX1weGA7XG4gICAgICAgIHRoaXMuY29tbWFuZE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIC8vIEFkZCBjbGljayBvdXRzaWRlIGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgY29tbWFuZCBtZW51XG4gICAgICovXG4gICAgaGlkZUNvbW1hbmRNZW51KCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBjb2RlIGNvbW1hbmQgLSBpbnNlcnRzIHNlbGVjdGVkIGNvZGVcbiAgICAgKi9cbiAgICBoYW5kbGVDb2RlQ29tbWFuZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjb2RlXFxuJHtzZWxlY3RlZFRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBzZWxlY3Rpb24sIGdldCB0aGUgZW50aXJlIGNlbGwgY29udGVudFxuICAgICAgICAgICAgY29uc3QgY2VsbENvbnRleHQgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDdXJyZW50Q2VsbENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChjZWxsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9JbnB1dChgQGNvZGVcXG4ke2NlbGxDb250ZXh0LnRleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY2VsbCBjb21tYW5kIC0gaW5zZXJ0cyBlbnRpcmUgY2VsbCBjb250ZW50XG4gICAgICovXG4gICAgaGFuZGxlQ2VsbENvbW1hbmQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2VsbENvbnRleHQgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDdXJyZW50Q2VsbENvbnRleHQoKTtcbiAgICAgICAgaWYgKGNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjZWxsXFxuJHtjZWxsQ29udGV4dC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGV4dCB0byB0aGUgaW5wdXQgZmllbGQgd2l0aCBwcm9wZXIgc3BhY2luZ1xuICAgICAqL1xuICAgIGFwcGVuZFRvSW5wdXQodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgZXhpc3RpbmcgY29udGVudCwgYWRkIGEgbmV3bGluZSBiZWZvcmUgYXBwZW5kaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gYCR7Y3VycmVudFZhbHVlfVxcblxcbiR7dGV4dH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvY3VzIHRoZSBpbnB1dCBmaWVsZCBhbmQgbW92ZSBjdXJzb3IgdG8gZW5kXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmlucHV0RmllbGQudmFsdWUubGVuZ3RoLCB0aGlzLmlucHV0RmllbGQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGVuZGluZyB0byBpbnB1dDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VsZWN0ZWQgdGV4dCBmcm9tIGNlbGwgY29udGV4dFxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkVGV4dCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYWN0aXZlIGNlbGwgZnJvbSB0aGUgdHJhY2tlclxuICAgICAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgQ29kZU1pcnJvciBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHNlbGVjdGlvbiBmcm9tIENvZGVNaXJyb3JcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gc2VsZWN0aW9uLCByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmIChzZWxlY3Rpb24ubWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgICAgICBjb25zdCBmcm9tID0gc2VsZWN0aW9uLm1haW4uZnJvbTtcbiAgICAgICAgY29uc3QgdG8gPSBzZWxlY3Rpb24ubWFpbi50bztcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVTaWRlYmFyV2lkZ2V0ID0gU2ltcGxlU2lkZWJhcldpZGdldDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==