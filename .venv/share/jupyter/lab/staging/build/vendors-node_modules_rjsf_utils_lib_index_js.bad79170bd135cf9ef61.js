(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_rjsf_utils_lib_index_js"],{

/***/ "./node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js":
/*!************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ErrorSchemaBuilder)
/* harmony export */ });
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/set */ "./node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");




/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is
 * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error
 * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can
 * get the result and/or reset all the errors back to an initial set and start again.
 */
class ErrorSchemaBuilder {
    /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     */
    constructor(initialSchema) {
        /** The error schema being built
         *
         * @private
         */
        this.errorSchema = {};
        this.resetAllErrors(initialSchema);
    }
    /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
     */
    get ErrorSchema() {
        return this.errorSchema;
    }
    /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The error block for the given `pathOfError` or the root if not provided
     * @private
     */
    getOrCreateErrorBlock(pathOfError) {
        const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';
        let errorBlock = hasPath ? lodash_get__WEBPACK_IMPORTED_MODULE_1___default()(this.errorSchema, pathOfError) : this.errorSchema;
        if (!errorBlock && pathOfError) {
            errorBlock = {};
            lodash_set__WEBPACK_IMPORTED_MODULE_2___default()(this.errorSchema, pathOfError, errorBlock);
        }
        return errorBlock;
    }
    /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    resetAllErrors(initialSchema) {
        this.errorSchema = initialSchema ? lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(initialSchema) : {};
        return this;
    }
    /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
     * the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    addErrors(errorOrList, pathOfError) {
        const errorBlock = this.getOrCreateErrorBlock(pathOfError);
        let errorsList = lodash_get__WEBPACK_IMPORTED_MODULE_1___default()(errorBlock, _constants__WEBPACK_IMPORTED_MODULE_3__.ERRORS_KEY);
        if (!Array.isArray(errorsList)) {
            errorsList = [];
            errorBlock[_constants__WEBPACK_IMPORTED_MODULE_3__.ERRORS_KEY] = errorsList;
        }
        if (Array.isArray(errorOrList)) {
            errorsList.push(...errorOrList);
        }
        else {
            errorsList.push(errorOrList);
        }
        return this;
    }
    /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
     * within the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    setErrors(errorOrList, pathOfError) {
        const errorBlock = this.getOrCreateErrorBlock(pathOfError);
        // Effectively clone the array being given to prevent accidental outside manipulation of the given list
        const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];
        lodash_set__WEBPACK_IMPORTED_MODULE_2___default()(errorBlock, _constants__WEBPACK_IMPORTED_MODULE_3__.ERRORS_KEY, listToAdd);
        return this;
    }
    /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
     * the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    clearErrors(pathOfError) {
        const errorBlock = this.getOrCreateErrorBlock(pathOfError);
        lodash_set__WEBPACK_IMPORTED_MODULE_2___default()(errorBlock, _constants__WEBPACK_IMPORTED_MODULE_3__.ERRORS_KEY, []);
        return this;
    }
}
//# sourceMappingURL=ErrorSchemaBuilder.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/allowAdditionalItems.js":
/*!**************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/allowAdditionalItems.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ allowAdditionalItems)
/* harmony export */ });
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");

/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an
 * object. The user is warned in the console if `schema.additionalItems` has the value `true`.
 *
 * @param schema - The schema object to check
 * @returns - True if additional items is allowed, otherwise false
 */
function allowAdditionalItems(schema) {
    if (schema.additionalItems === true) {
        console.warn('additionalItems=true is currently not supported');
    }
    return (0,_isObject__WEBPACK_IMPORTED_MODULE_0__["default"])(schema.additionalItems);
}
//# sourceMappingURL=allowAdditionalItems.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/asNumber.js":
/*!**************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/asNumber.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ asNumber)
/* harmony export */ });
/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a
 * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be
 * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned
 * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by
 * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.
 *
 * @param value - The string or null value to convert to a number
 * @returns - The `value` converted to a number when appropriate, otherwise the `value`
 */
function asNumber(value) {
    if (value === '') {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    if (/\.$/.test(value)) {
        // '3.' can't really be considered a number even if it parses in js. The
        // user is most likely entering a float.
        return value;
    }
    if (/\.0$/.test(value)) {
        // we need to return this as a string here, to allow for input like 3.07
        return value;
    }
    if (/\.\d*0$/.test(value)) {
        // It's a number, that's cool - but we need it as a string so it doesn't screw
        // with the user when entering dollar amounts or other values (such as those with
        // specific precision or number of significant digits)
        return value;
    }
    const n = Number(value);
    const valid = typeof n === 'number' && !Number.isNaN(n);
    return valid ? n : value;
}
//# sourceMappingURL=asNumber.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/canExpand.js":
/*!***************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/canExpand.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ canExpand)
/* harmony export */ });
/* harmony import */ var _getUiOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getUiOptions */ "./node_modules/@rjsf/utils/lib/getUiOptions.js");

/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for
 * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the
 * `formData` object doesn't already have `schema.maxProperties` elements.
 *
 * @param schema - The schema for the field that is being checked
 * @param [uiSchema={}] - The uiSchema for the field
 * @param [formData] - The formData for the field
 * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit
 */
function canExpand(schema, uiSchema = {}, formData) {
    if (!schema.additionalProperties) {
        return false;
    }
    const { expandable = true } = (0,_getUiOptions__WEBPACK_IMPORTED_MODULE_0__["default"])(uiSchema);
    if (expandable === false) {
        return expandable;
    }
    // if ui:options.expandable was not explicitly set to false, we can add
    // another property if we have not exceeded maxProperties yet
    if (schema.maxProperties !== undefined && formData) {
        return Object.keys(formData).length < schema.maxProperties;
    }
    return true;
}
//# sourceMappingURL=canExpand.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ADDITIONAL_PROPERTIES_KEY: () => (/* binding */ ADDITIONAL_PROPERTIES_KEY),
/* harmony export */   ADDITIONAL_PROPERTY_FLAG: () => (/* binding */ ADDITIONAL_PROPERTY_FLAG),
/* harmony export */   ALL_OF_KEY: () => (/* binding */ ALL_OF_KEY),
/* harmony export */   ANY_OF_KEY: () => (/* binding */ ANY_OF_KEY),
/* harmony export */   CONST_KEY: () => (/* binding */ CONST_KEY),
/* harmony export */   DEFAULT_KEY: () => (/* binding */ DEFAULT_KEY),
/* harmony export */   DEFINITIONS_KEY: () => (/* binding */ DEFINITIONS_KEY),
/* harmony export */   DEPENDENCIES_KEY: () => (/* binding */ DEPENDENCIES_KEY),
/* harmony export */   ENUM_KEY: () => (/* binding */ ENUM_KEY),
/* harmony export */   ERRORS_KEY: () => (/* binding */ ERRORS_KEY),
/* harmony export */   ID_KEY: () => (/* binding */ ID_KEY),
/* harmony export */   IF_KEY: () => (/* binding */ IF_KEY),
/* harmony export */   ITEMS_KEY: () => (/* binding */ ITEMS_KEY),
/* harmony export */   JUNK_OPTION_ID: () => (/* binding */ JUNK_OPTION_ID),
/* harmony export */   NAME_KEY: () => (/* binding */ NAME_KEY),
/* harmony export */   ONE_OF_KEY: () => (/* binding */ ONE_OF_KEY),
/* harmony export */   PROPERTIES_KEY: () => (/* binding */ PROPERTIES_KEY),
/* harmony export */   REF_KEY: () => (/* binding */ REF_KEY),
/* harmony export */   REQUIRED_KEY: () => (/* binding */ REQUIRED_KEY),
/* harmony export */   RJSF_ADDITONAL_PROPERTIES_FLAG: () => (/* binding */ RJSF_ADDITONAL_PROPERTIES_FLAG),
/* harmony export */   ROOT_SCHEMA_PREFIX: () => (/* binding */ ROOT_SCHEMA_PREFIX),
/* harmony export */   SUBMIT_BTN_OPTIONS_KEY: () => (/* binding */ SUBMIT_BTN_OPTIONS_KEY),
/* harmony export */   UI_FIELD_KEY: () => (/* binding */ UI_FIELD_KEY),
/* harmony export */   UI_GLOBAL_OPTIONS_KEY: () => (/* binding */ UI_GLOBAL_OPTIONS_KEY),
/* harmony export */   UI_OPTIONS_KEY: () => (/* binding */ UI_OPTIONS_KEY),
/* harmony export */   UI_WIDGET_KEY: () => (/* binding */ UI_WIDGET_KEY)
/* harmony export */ });
/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various
 * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and
 * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`
 * utility.
 */
const ADDITIONAL_PROPERTY_FLAG = '__additional_property';
const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';
const ALL_OF_KEY = 'allOf';
const ANY_OF_KEY = 'anyOf';
const CONST_KEY = 'const';
const DEFAULT_KEY = 'default';
const DEFINITIONS_KEY = 'definitions';
const DEPENDENCIES_KEY = 'dependencies';
const ENUM_KEY = 'enum';
const ERRORS_KEY = '__errors';
const ID_KEY = '$id';
const IF_KEY = 'if';
const ITEMS_KEY = 'items';
const JUNK_OPTION_ID = '_$junk_option_schema_id$_';
const NAME_KEY = '$name';
const ONE_OF_KEY = 'oneOf';
const PROPERTIES_KEY = 'properties';
const REQUIRED_KEY = 'required';
const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';
const REF_KEY = '$ref';
const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';
const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';
const UI_FIELD_KEY = 'ui:field';
const UI_WIDGET_KEY = 'ui:widget';
const UI_OPTIONS_KEY = 'ui:options';
const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/createErrorHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/createErrorHandler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createErrorHandler)
/* harmony export */ });
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js");
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");


/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it
 *
 * @param formData - The form data around which the error handler is created
 * @returns - A `FormValidation` object based on the `formData` structure
 */
function createErrorHandler(formData) {
    const handler = {
        // We store the list of errors for this node in a property named __errors
        // to avoid name collision with a possible sub schema field named
        // 'errors' (see `utils.toErrorSchema`).
        [_constants__WEBPACK_IMPORTED_MODULE_1__.ERRORS_KEY]: [],
        addError(message) {
            this[_constants__WEBPACK_IMPORTED_MODULE_1__.ERRORS_KEY].push(message);
        },
    };
    if (Array.isArray(formData)) {
        return formData.reduce((acc, value, key) => {
            return { ...acc, [key]: createErrorHandler(value) };
        }, handler);
    }
    if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(formData)) {
        const formObject = formData;
        return Object.keys(formObject).reduce((acc, key) => {
            return { ...acc, [key]: createErrorHandler(formObject[key]) };
        }, handler);
    }
    return handler;
}
//# sourceMappingURL=createErrorHandler.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/createSchemaUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/createSchemaUtils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createSchemaUtils)
/* harmony export */ });
/* harmony import */ var _deepEquals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deepEquals */ "./node_modules/@rjsf/utils/lib/deepEquals.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema */ "./node_modules/@rjsf/utils/lib/schema/index.js");


/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such
 * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.
 * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the
 * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.
 */
class SchemaUtils {
    /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
     * @param rootSchema - The root schema that will be forwarded to all the APIs
     * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
     */
    constructor(validator, rootSchema, experimental_defaultFormStateBehavior) {
        this.rootSchema = rootSchema;
        this.validator = validator;
        this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;
    }
    /** Returns the `ValidatorType` in the `SchemaUtilsType`
     *
     * @returns - The `ValidatorType`
     */
    getValidator() {
        return this.validator;
    }
    /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
     * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
     * of a new `SchemaUtilsType` with incomplete properties.
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
     * @param rootSchema - The root schema that will be compared against the current one
     * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
     * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
     */
    doesSchemaUtilsDiffer(validator, rootSchema, experimental_defaultFormStateBehavior = {}) {
        if (!validator || !rootSchema) {
            return false;
        }
        return (this.validator !== validator ||
            !(0,_deepEquals__WEBPACK_IMPORTED_MODULE_0__["default"])(this.rootSchema, rootSchema) ||
            !(0,_deepEquals__WEBPACK_IMPORTED_MODULE_0__["default"])(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior));
    }
    /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
     * computed to have defaults provided in the `schema`.
     *
     * @param schema - The schema for which the default state is desired
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
     *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
     *          object properties.
     * @returns - The resulting `formData` with all the defaults provided
     */
    getDefaultFormState(schema, formData, includeUndefinedValues = false) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.getDefaultFormState)(this.validator, schema, formData, this.rootSchema, includeUndefinedValues, this.experimental_defaultFormStateBehavior);
    }
    /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
     * should be displayed in a UI.
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [uiSchema] - The UI schema from which to derive potentially displayable information
     * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
     * @returns - True if the label should be displayed or false if it should not
     */
    getDisplayLabel(schema, uiSchema, globalOptions) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.getDisplayLabel)(this.validator, schema, uiSchema, this.rootSchema, globalOptions);
    }
    /** Determines which of the given `options` provided most closely matches the `formData`.
     * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
     *
     * The closest match is determined using the number of matching properties, and more heavily favors options with
     * matching readOnly, default, or const values.
     *
     * @param formData - The form data associated with the schema
     * @param options - The list of options that can be selected from
     * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
     */
    getClosestMatchingOption(formData, options, selectedOption, discriminatorField) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.getClosestMatchingOption)(this.validator, this.rootSchema, formData, options, selectedOption, discriminatorField);
    }
    /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
     * Always returns the first option if there is nothing that matches.
     *
     * @param formData - The current formData, if any, used to figure out a match
     * @param options - The list of options to find a matching options from
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The firstindex of the matched option or 0 if none is available
     */
    getFirstMatchingOption(formData, options, discriminatorField) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.getFirstMatchingOption)(this.validator, formData, options, this.rootSchema, discriminatorField);
    }
    /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.
     * Deprecated, use `getFirstMatchingOption()` instead.
     *
     * @param formData - The current formData, if any, onto which to provide any missing defaults
     * @param options - The list of options to find a matching options from
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The index of the matched option or 0 if none is available
     * @deprecated
     */
    getMatchingOption(formData, options, discriminatorField) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.getMatchingOption)(this.validator, formData, options, this.rootSchema, discriminatorField);
    }
    /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
     *
     * @param schema - The schema for which check for array of files flag is desired
     * @param [uiSchema] - The UI schema from which to check the widget
     * @returns - True if schema/uiSchema contains an array of files, otherwise false
     */
    isFilesArray(schema, uiSchema) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.isFilesArray)(this.validator, schema, uiSchema, this.rootSchema);
    }
    /** Checks to see if the `schema` combination represents a multi-select
     *
     * @param schema - The schema for which check for a multi-select flag is desired
     * @returns - True if schema contains a multi-select, otherwise false
     */
    isMultiSelect(schema) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.isMultiSelect)(this.validator, schema, this.rootSchema);
    }
    /** Checks to see if the `schema` combination represents a select
     *
     * @param schema - The schema for which check for a select flag is desired
     * @returns - True if schema contains a select, otherwise false
     */
    isSelect(schema) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.isSelect)(this.validator, schema, this.rootSchema);
    }
    /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in
     * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling
     * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,
     * then `validationData` is returned.
     *
     * @param validationData - The current `ValidationData` into which to merge the additional errors
     * @param [additionalErrorSchema] - The additional set of errors
     * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.
     * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be
     *        removed in the next major release.
     */
    mergeValidationData(validationData, additionalErrorSchema) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.mergeValidationData)(this.validator, validationData, additionalErrorSchema);
    }
    /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
     * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
     * recursive resolution.
     *
     * @param schema - The schema for which retrieving a schema is desired
     * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
     * @returns - The schema having its conditions, additional properties, references and dependencies resolved
     */
    retrieveSchema(schema, rawFormData) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.retrieveSchema)(this.validator, schema, this.rootSchema, rawFormData);
    }
    /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
     * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
     * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
     * old schemas that are non-existent in the new schema are set to `undefined`.
     *
     * @param [newSchema] - The new schema for which the data is being sanitized
     * @param [oldSchema] - The old schema from which the data originated
     * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
     * @returns - The new form data, with all the fields uniquely associated with the old schema set
     *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
     */
    sanitizeDataForNewSchema(newSchema, oldSchema, data) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.sanitizeDataForNewSchema)(this.validator, this.rootSchema, newSchema, oldSchema, data);
    }
    /** Generates an `IdSchema` object for the `schema`, recursively
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [id] - The base id for the schema
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @param [idPrefix='root'] - The prefix to use for the id
     * @param [idSeparator='_'] - The separator to use for the path segments in the id
     * @returns - The `IdSchema` object for the `schema`
     */
    toIdSchema(schema, id, formData, idPrefix = 'root', idSeparator = '_') {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.toIdSchema)(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);
    }
    /** Generates an `PathSchema` object for the `schema`, recursively
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [name] - The base name for the schema
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @returns - The `PathSchema` object for the `schema`
     */
    toPathSchema(schema, name, formData) {
        return (0,_schema__WEBPACK_IMPORTED_MODULE_1__.toPathSchema)(this.validator, schema, name, this.rootSchema, formData);
    }
}
/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The
 * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
 * @returns - An implementation of a `SchemaUtilsType` interface
 */
function createSchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior = {}) {
    return new SchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior);
}
//# sourceMappingURL=createSchemaUtils.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/dataURItoBlob.js":
/*!*******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/dataURItoBlob.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dataURItoBlob)
/* harmony export */ });
/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name
 * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.
 *
 * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob
 * @returns - an object containing a Blob and its name, extracted from the URI
 */
function dataURItoBlob(dataURI) {
    // Split metadata from data
    const splitted = dataURI.split(',');
    // Split params
    const params = splitted[0].split(';');
    // Get mime-type from params
    const type = params[0].replace('data:', '');
    // Filter the name property from params
    const properties = params.filter((param) => {
        return param.split('=')[0] === 'name';
    });
    // Look for the name and use unknown if no name property.
    let name;
    if (properties.length !== 1) {
        name = 'unknown';
    }
    else {
        // Because we filtered out the other property,
        // we only have the name case here, which we decode to make it human-readable
        name = decodeURI(properties[0].split('=')[1]);
    }
    // Built the Uint8Array Blob parameter from the base64 string.
    try {
        const binary = atob(splitted[1]);
        const array = [];
        for (let i = 0; i < binary.length; i++) {
            array.push(binary.charCodeAt(i));
        }
        // Create the blob object
        const blob = new window.Blob([new Uint8Array(array)], { type });
        return { blob, name };
    }
    catch (error) {
        return { blob: { size: 0, type: error.message }, name: dataURI };
    }
}
//# sourceMappingURL=dataURItoBlob.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/deepEquals.js":
/*!****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/deepEquals.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deepEquals)
/* harmony export */ });
/* harmony import */ var lodash_isEqualWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEqualWith */ "./node_modules/lodash/isEqualWith.js");
/* harmony import */ var lodash_isEqualWith__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqualWith__WEBPACK_IMPORTED_MODULE_0__);

/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that
 * assumes all functions are equivalent.
 *
 * @param a - The first element to compare
 * @param b - The second element to compare
 * @returns - True if the `a` and `b` are deeply equal, false otherwise
 */
function deepEquals(a, b) {
    return lodash_isEqualWith__WEBPACK_IMPORTED_MODULE_0___default()(a, b, (obj, other) => {
        if (typeof obj === 'function' && typeof other === 'function') {
            // Assume all functions are equivalent
            // see https://github.com/rjsf-team/react-jsonschema-form/issues/255
            return true;
        }
        return undefined; // fallback to default isEquals behavior
    });
}
//# sourceMappingURL=deepEquals.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/englishStringTranslator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/englishStringTranslator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ englishStringTranslator)
/* harmony export */ });
/* harmony import */ var _replaceStringParameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./replaceStringParameters */ "./node_modules/@rjsf/utils/lib/replaceStringParameters.js");

/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each
 * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,
 * `%2`, etc. replacement specifiers.
 *
 * @param stringToTranslate - The `TranslatableString` value to convert to english
 * @param params - The optional list of replaceable parameter values to substitute into the english string
 * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted
 */
function englishStringTranslator(stringToTranslate, params) {
    return (0,_replaceStringParameters__WEBPACK_IMPORTED_MODULE_0__["default"])(stringToTranslate, params);
}
//# sourceMappingURL=englishStringTranslator.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ enumOptionsDeselectValue)
/* harmony export */ });
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _enumOptionsValueForIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enumOptionsValueForIndex */ "./node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js");


/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is
 * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is
 * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined
 * is returned, otherwise the `selected` value is returned.
 *
 * @param valueIndex - The index of the value to be removed from the selected list or single value
 * @param selected - The current (list of) selected value(s)
 * @param [allEnumOptions=[]] - The list of all the known enumOptions
 * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,
 *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns
 *        undefined, otherwise `selected`.
 */
function enumOptionsDeselectValue(valueIndex, selected, allEnumOptions = []) {
    const value = (0,_enumOptionsValueForIndex__WEBPACK_IMPORTED_MODULE_1__["default"])(valueIndex, allEnumOptions);
    if (Array.isArray(selected)) {
        return selected.filter((v) => !lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(v, value));
    }
    return lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(value, selected) ? undefined : selected;
}
//# sourceMappingURL=enumOptionsDeselectValue.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ enumOptionsIndexForValue)
/* harmony export */ });
/* harmony import */ var _enumOptionsIsSelected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enumOptionsIsSelected */ "./node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js");

/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the
 * `enumOptions` are filtered based on whether they are a "selected" `value` and the index of each selected one is then
 * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is
 * returned.
 *
 * @param value - The single value or list of values for which indexes are desired
 * @param [allEnumOptions=[]] - The list of all the known enumOptions
 * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one
 * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list
 *        of indexes for (each of) the value(s) in `value`.
 */
function enumOptionsIndexForValue(value, allEnumOptions = [], multiple = false) {
    const selectedIndexes = allEnumOptions
        .map((opt, index) => ((0,_enumOptionsIsSelected__WEBPACK_IMPORTED_MODULE_0__["default"])(opt.value, value) ? String(index) : undefined))
        .filter((opt) => typeof opt !== 'undefined');
    if (!multiple) {
        return selectedIndexes[0];
    }
    return selectedIndexes;
}
//# sourceMappingURL=enumOptionsIndexForValue.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js":
/*!***************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ enumOptionsIsSelected)
/* harmony export */ });
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__);

/** Determines whether the given `value` is (one of) the `selected` value(s).
 *
 * @param value - The value being checked to see if it is selected
 * @param selected - The current selected value or list of values
 * @returns - true if the `value` is one of the `selected` ones, false otherwise
 */
function enumOptionsIsSelected(value, selected) {
    if (Array.isArray(selected)) {
        return selected.some((sel) => lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(sel, value));
    }
    return lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(selected, value);
}
//# sourceMappingURL=enumOptionsIsSelected.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ enumOptionsSelectValue)
/* harmony export */ });
/* harmony import */ var _enumOptionsValueForIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enumOptionsValueForIndex */ "./node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js");
/* harmony import */ var lodash_isNil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isNil */ "./node_modules/lodash/isNil.js");
/* harmony import */ var lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isNil__WEBPACK_IMPORTED_MODULE_1__);


/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by
 * `allEnumOptions`
 *
 * @param valueIndex - The index of the value that should be selected
 * @param selected - The current list of selected values
 * @param [allEnumOptions=[]] - The list of all the known enumOptions
 * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it
 */
function enumOptionsSelectValue(valueIndex, selected, allEnumOptions = []) {
    const value = (0,_enumOptionsValueForIndex__WEBPACK_IMPORTED_MODULE_0__["default"])(valueIndex, allEnumOptions);
    if (!lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default()(value)) {
        const index = allEnumOptions.findIndex((opt) => value === opt.value);
        const all = allEnumOptions.map(({ value: val }) => val);
        const updated = selected.slice(0, index).concat(value, selected.slice(index));
        // As inserting values at predefined index positions doesn't work with empty
        // arrays, we need to reorder the updated selection to match the initial order
        return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));
    }
    return selected;
}
//# sourceMappingURL=enumOptionsSelectValue.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js":
/*!******************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ enumOptionsValueForIndex)
/* harmony export */ });
/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an
 * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it
 * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only
 * valid values or in the worst case, an empty array.
 *
 * @param valueIndex - The index(es) of the value(s) that should be returned
 * @param [allEnumOptions=[]] - The list of all the known enumOptions
 * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option
 * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,
 *        `emptyValue` or an empty list.
 */
function enumOptionsValueForIndex(valueIndex, allEnumOptions = [], emptyValue) {
    if (Array.isArray(valueIndex)) {
        return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);
    }
    // So Number(null) and Number('') both return 0, so use emptyValue for those two values
    const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);
    const option = allEnumOptions[index];
    return option ? option.value : emptyValue;
}
//# sourceMappingURL=enumOptionsValueForIndex.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/enums.js":
/*!***********************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/enums.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TranslatableString: () => (/* binding */ TranslatableString)
/* harmony export */ });
/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the
 * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values
 * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of
 * parameters is important because some languages may choose to put the second parameter before the first in its
 * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.
 */
var TranslatableString;
(function (TranslatableString) {
    /** Fallback title of an array item, used by ArrayField */
    TranslatableString["ArrayItemTitle"] = "Item";
    /** Missing items reason, used by ArrayField */
    TranslatableString["MissingItems"] = "Missing items definition";
    /** Yes label, used by BooleanField */
    TranslatableString["YesLabel"] = "Yes";
    /** No label, used by BooleanField */
    TranslatableString["NoLabel"] = "No";
    /** Close label, used by ErrorList */
    TranslatableString["CloseLabel"] = "Close";
    /** Errors label, used by ErrorList */
    TranslatableString["ErrorsLabel"] = "Errors";
    /** New additionalProperties string default value, used by ObjectField */
    TranslatableString["NewStringDefault"] = "New Value";
    /** Add button title, used by AddButton */
    TranslatableString["AddButton"] = "Add";
    /** Add button title, used by AddButton */
    TranslatableString["AddItemButton"] = "Add Item";
    /** Copy button title, used by IconButton */
    TranslatableString["CopyButton"] = "Copy";
    /** Move down button title, used by IconButton */
    TranslatableString["MoveDownButton"] = "Move down";
    /** Move up button title, used by IconButton */
    TranslatableString["MoveUpButton"] = "Move up";
    /** Remove button title, used by IconButton */
    TranslatableString["RemoveButton"] = "Remove";
    /** Now label, used by AltDateWidget */
    TranslatableString["NowLabel"] = "Now";
    /** Clear label, used by AltDateWidget */
    TranslatableString["ClearLabel"] = "Clear";
    /** Aria date label, used by DateWidget */
    TranslatableString["AriaDateLabel"] = "Select a date";
    /** File preview label, used by FileWidget */
    TranslatableString["PreviewLabel"] = "Preview";
    /** Decrement button aria label, used by UpDownWidget */
    TranslatableString["DecrementAriaLabel"] = "Decrease value by 1";
    /** Increment button aria label, used by UpDownWidget */
    TranslatableString["IncrementAriaLabel"] = "Increase value by 1";
    // Strings with replaceable parameters
    /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */
    TranslatableString["UnknownFieldType"] = "Unknown field type %1";
    /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */
    TranslatableString["OptionPrefix"] = "Option %1";
    /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by
     * MultiSchemaField
     */
    TranslatableString["TitleOptionPrefix"] = "%1 option %2";
    /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */
    TranslatableString["KeyLabel"] = "%1 Key";
    // Strings with replaceable parameters AND/OR that support markdown and html
    /** Invalid object field configuration as provided by the ObjectField */
    TranslatableString["InvalidObjectField"] = "Invalid \"%1\" object field configuration: <em>%2</em>.";
    /** Unsupported field schema, used by UnsupportedField */
    TranslatableString["UnsupportedField"] = "Unsupported field schema.";
    /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */
    TranslatableString["UnsupportedFieldWithId"] = "Unsupported field schema for field <code>%1</code>.";
    /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */
    TranslatableString["UnsupportedFieldWithReason"] = "Unsupported field schema: <em>%1</em>.";
    /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,
     * as provided by UnsupportedField
     */
    TranslatableString["UnsupportedFieldWithIdAndReason"] = "Unsupported field schema for field <code>%1</code>: <em>%2</em>.";
    /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as
     * provided by FileWidget
     */
    TranslatableString["FilesInfo"] = "<strong>%1</strong> (%2, %3 bytes)";
})(TranslatableString || (TranslatableString = {}));
//# sourceMappingURL=enums.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/findSchemaDefinition.js":
/*!**************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/findSchemaDefinition.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findSchemaDefinition),
/* harmony export */   splitKeyElementFromObject: () => (/* binding */ splitKeyElementFromObject)
/* harmony export */ });
/* harmony import */ var jsonpointer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonpointer */ "./node_modules/jsonpointer/jsonpointer.js");
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/omit */ "./node_modules/lodash/omit.js");
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");



/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first
 * location, the `object` minus the `key: value` and in the second location the `value`.
 *
 * @param key - The key from the object to extract
 * @param object - The object from which to extract the element
 * @returns - An array with the first value being the object minus the `key` element and the second element being the
 *      value from `object[key]`
 */
function splitKeyElementFromObject(key, object) {
    const value = object[key];
    const remaining = lodash_omit__WEBPACK_IMPORTED_MODULE_1___default()(object, [key]);
    return [remaining, value];
}
/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the
 * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in
 * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.
 *
 * @param $ref - The ref string for which the schema definition is desired
 * @param [rootSchema={}] - The root schema in which to search for the definition
 * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists
 * @throws - Error indicating that no schema for that reference exists
 */
function findSchemaDefinition($ref, rootSchema = {}) {
    let ref = $ref || '';
    if (ref.startsWith('#')) {
        // Decode URI fragment representation.
        ref = decodeURIComponent(ref.substring(1));
    }
    else {
        throw new Error(`Could not find a definition for ${$ref}.`);
    }
    const current = jsonpointer__WEBPACK_IMPORTED_MODULE_0__.get(rootSchema, ref);
    if (current === undefined) {
        throw new Error(`Could not find a definition for ${$ref}.`);
    }
    if (current[_constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY]) {
        const [remaining, theRef] = splitKeyElementFromObject(_constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY, current);
        const subSchema = findSchemaDefinition(theRef, rootSchema);
        if (Object.keys(remaining).length > 0) {
            return { ...remaining, ...subSchema };
        }
        return subSchema;
    }
    return current;
}
//# sourceMappingURL=findSchemaDefinition.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDiscriminatorFieldFromSchema)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_1__);


/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when
 * it is not a string. Returns `undefined` when a valid discriminator is not present.
 *
 * @param schema - The schema from which the discriminator is potentially obtained
 * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`
 */
function getDiscriminatorFieldFromSchema(schema) {
    let discriminator;
    const maybeString = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, 'discriminator.propertyName', undefined);
    if (lodash_isString__WEBPACK_IMPORTED_MODULE_1___default()(maybeString)) {
        discriminator = maybeString;
    }
    else if (maybeString !== undefined) {
        console.warn(`Expecting discriminator to be a string, got "${typeof maybeString}" instead`);
    }
    return discriminator;
}
//# sourceMappingURL=getDiscriminatorFieldFromSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getInputProps.js":
/*!*******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getInputProps.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getInputProps)
/* harmony export */ });
/* harmony import */ var _rangeSpec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rangeSpec */ "./node_modules/@rjsf/utils/lib/rangeSpec.js");

/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.
 *
 * @param schema - The schema for the field provided by the widget
 * @param [defaultType] - The default type, if any, for the field provided by the widget
 * @param [options={}] - The UI Options for the field provided by the widget
 * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step
 * @returns - The extracted `InputPropsType` object
 */
function getInputProps(schema, defaultType, options = {}, autoDefaultStepAny = true) {
    const inputProps = {
        type: defaultType || 'text',
        ...(0,_rangeSpec__WEBPACK_IMPORTED_MODULE_0__["default"])(schema),
    };
    // If options.inputType is set use that as the input type
    if (options.inputType) {
        inputProps.type = options.inputType;
    }
    else if (!defaultType) {
        // If the schema is of type number or integer, set the input type to number
        if (schema.type === 'number') {
            inputProps.type = 'number';
            // Only add step if one isn't already defined and we are auto-defaulting the "any" step
            if (autoDefaultStepAny && inputProps.step === undefined) {
                // Setting step to 'any' fixes a bug in Safari where decimals are not
                // allowed in number inputs
                inputProps.step = 'any';
            }
        }
        else if (schema.type === 'integer') {
            inputProps.type = 'number';
            // Only add step if one isn't already defined
            if (inputProps.step === undefined) {
                // Since this is integer, you always want to step up or down in multiples of 1
                inputProps.step = 1;
            }
        }
    }
    if (options.autocomplete) {
        inputProps.autoComplete = options.autocomplete;
    }
    return inputProps;
}
//# sourceMappingURL=getInputProps.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOptionMatchingSimpleDiscriminator)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");


/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.
 * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.
 * This function does not work with discriminators of `"type": "object"` and `"type": "array"`
 *
 * @param formData - The current formData, if any, used to figure out a match
 * @param options - The list of options to find a matching options from
 * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
 *          determine which option is selected
 * @returns - The index of the matched option or undefined if there is no match
 */
function getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField) {
    var _a;
    if (formData && discriminatorField) {
        const value = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, discriminatorField);
        if (value === undefined) {
            return;
        }
        for (let i = 0; i < options.length; i++) {
            const option = options[i];
            const discriminator = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(option, [_constants__WEBPACK_IMPORTED_MODULE_1__.PROPERTIES_KEY, discriminatorField], {});
            if (discriminator.type === 'object' || discriminator.type === 'array') {
                continue;
            }
            if (discriminator.const === value) {
                return i;
            }
            if ((_a = discriminator.enum) === null || _a === void 0 ? void 0 : _a.includes(value)) {
                return i;
            }
        }
    }
    return;
}
//# sourceMappingURL=getOptionMatchingSimpleDiscriminator.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getSchemaType.js":
/*!*******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getSchemaType.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getSchemaType)
/* harmony export */ });
/* harmony import */ var _guessType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./guessType */ "./node_modules/@rjsf/utils/lib/guessType.js");

/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from
 * other elements of the schema as follows:
 * - schema.const: Returns the `guessType()` of that value
 * - schema.enum: Returns `string`
 * - schema.properties: Returns `object`
 * - schema.additionalProperties: Returns `object`
 * - type is an array with a length of 2 and one type is 'null': Returns the other type
 *
 * @param schema - The schema for which to get the type
 * @returns - The type of the schema
 */
function getSchemaType(schema) {
    let { type } = schema;
    if (!type && schema.const) {
        return (0,_guessType__WEBPACK_IMPORTED_MODULE_0__["default"])(schema.const);
    }
    if (!type && schema.enum) {
        return 'string';
    }
    if (!type && (schema.properties || schema.additionalProperties)) {
        return 'object';
    }
    if (Array.isArray(type)) {
        if (type.length === 2 && type.includes('null')) {
            type = type.find((type) => type !== 'null');
        }
        else {
            type = type[0];
        }
    }
    return type;
}
//# sourceMappingURL=getSchemaType.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_OPTIONS: () => (/* binding */ DEFAULT_OPTIONS),
/* harmony export */   "default": () => (/* binding */ getSubmitButtonOptions)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _getUiOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getUiOptions */ "./node_modules/@rjsf/utils/lib/getUiOptions.js");


/** The default submit button options, exported for testing purposes
 */
const DEFAULT_OPTIONS = {
    props: {
        disabled: false,
    },
    submitText: 'Submit',
    norender: false,
};
/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`
 *
 * @param [uiSchema={}] - the UI Schema from which to extract submit button props
 * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones
 */
function getSubmitButtonOptions(uiSchema = {}) {
    const uiOptions = (0,_getUiOptions__WEBPACK_IMPORTED_MODULE_1__["default"])(uiSchema);
    if (uiOptions && uiOptions[_constants__WEBPACK_IMPORTED_MODULE_0__.SUBMIT_BTN_OPTIONS_KEY]) {
        const options = uiOptions[_constants__WEBPACK_IMPORTED_MODULE_0__.SUBMIT_BTN_OPTIONS_KEY];
        return { ...DEFAULT_OPTIONS, ...options };
    }
    return DEFAULT_OPTIONS;
}
//# sourceMappingURL=getSubmitButtonOptions.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getTemplate.js":
/*!*****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getTemplate.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTemplate)
/* harmony export */ });
/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`
 * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.
 *
 * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`
 * @param registry - The `Registry` from which to read the template
 * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template
 * @returns - The template from either the `uiSchema` or `registry` for the `name`
 */
function getTemplate(name, registry, uiOptions = {}) {
    const { templates } = registry;
    if (name === 'ButtonTemplates') {
        return templates[name];
    }
    return (
    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
    // To avoid that, we cast uiOptions to `any` before accessing the name field
    uiOptions[name] || templates[name]);
}
//# sourceMappingURL=getTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getUiOptions.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getUiOptions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUiOptions)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");


/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`
 * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.
 *
 * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options
 * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
 * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`
 */
function getUiOptions(uiSchema = {}, globalOptions = {}) {
    return Object.keys(uiSchema)
        .filter((key) => key.indexOf('ui:') === 0)
        .reduce((options, key) => {
        const value = uiSchema[key];
        if (key === _constants__WEBPACK_IMPORTED_MODULE_0__.UI_WIDGET_KEY && (0,_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
            console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');
            return options;
        }
        if (key === _constants__WEBPACK_IMPORTED_MODULE_0__.UI_OPTIONS_KEY && (0,_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
            return { ...options, ...value };
        }
        return { ...options, [key.substring(3)]: value };
    }, { ...globalOptions });
}
//# sourceMappingURL=getUiOptions.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/getWidget.js":
/*!***************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/getWidget.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/set */ "./node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _getSchemaType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getSchemaType */ "./node_modules/@rjsf/utils/lib/getSchemaType.js");






/** The map of schema types to widget type to widget name
 */
const widgetMap = {
    boolean: {
        checkbox: 'CheckboxWidget',
        radio: 'RadioWidget',
        select: 'SelectWidget',
        hidden: 'HiddenWidget',
    },
    string: {
        text: 'TextWidget',
        password: 'PasswordWidget',
        email: 'EmailWidget',
        hostname: 'TextWidget',
        ipv4: 'TextWidget',
        ipv6: 'TextWidget',
        uri: 'URLWidget',
        'data-url': 'FileWidget',
        radio: 'RadioWidget',
        select: 'SelectWidget',
        textarea: 'TextareaWidget',
        hidden: 'HiddenWidget',
        date: 'DateWidget',
        datetime: 'DateTimeWidget',
        'date-time': 'DateTimeWidget',
        'alt-date': 'AltDateWidget',
        'alt-datetime': 'AltDateTimeWidget',
        time: 'TimeWidget',
        color: 'ColorWidget',
        file: 'FileWidget',
    },
    number: {
        text: 'TextWidget',
        select: 'SelectWidget',
        updown: 'UpDownWidget',
        range: 'RangeWidget',
        radio: 'RadioWidget',
        hidden: 'HiddenWidget',
    },
    integer: {
        text: 'TextWidget',
        select: 'SelectWidget',
        updown: 'UpDownWidget',
        range: 'RangeWidget',
        radio: 'RadioWidget',
        hidden: 'HiddenWidget',
    },
    array: {
        select: 'SelectWidget',
        checkboxes: 'CheckboxesWidget',
        files: 'FileWidget',
        hidden: 'HiddenWidget',
    },
};
/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the
 * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the
 * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.
 *
 * @param AWidget - A widget that will be wrapped or one that is already wrapped
 * @returns - The wrapper widget
 */
function mergeWidgetOptions(AWidget) {
    let MergedWidget = lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(AWidget, 'MergedWidget');
    // cache return value as property of widget for proper react reconciliation
    if (!MergedWidget) {
        const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};
        MergedWidget = ({ options, ...props }) => {
            return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AWidget, { options: { ...defaultOptions, ...options }, ...props });
        };
        lodash_set__WEBPACK_IMPORTED_MODULE_4___default()(AWidget, 'MergedWidget', MergedWidget);
    }
    return MergedWidget;
}
/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the
 * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped
 * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based
 * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.
 *
 * @param schema - The schema for the field
 * @param [widget] - Either the name of the widget OR a `Widget` implementation to use
 * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation
 * @returns - The `Widget` component to use
 * @throws - An error if there is no `Widget` component that can be returned
 */
function getWidget(schema, widget, registeredWidgets = {}) {
    const type = (0,_getSchemaType__WEBPACK_IMPORTED_MODULE_5__["default"])(schema);
    if (typeof widget === 'function' ||
        (widget && react_is__WEBPACK_IMPORTED_MODULE_2__.isForwardRef((0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(widget))) ||
        react_is__WEBPACK_IMPORTED_MODULE_2__.isMemo(widget)) {
        return mergeWidgetOptions(widget);
    }
    if (typeof widget !== 'string') {
        throw new Error(`Unsupported widget definition: ${typeof widget}`);
    }
    if (widget in registeredWidgets) {
        const registeredWidget = registeredWidgets[widget];
        return getWidget(schema, registeredWidget, registeredWidgets);
    }
    if (typeof type === 'string') {
        if (!(type in widgetMap)) {
            throw new Error(`No widget for type '${type}'`);
        }
        if (widget in widgetMap[type]) {
            const registeredWidget = registeredWidgets[widgetMap[type][widget]];
            return getWidget(schema, registeredWidget, registeredWidgets);
        }
    }
    throw new Error(`No widget '${widget}' for type '${type}'`);
}
//# sourceMappingURL=getWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/guessType.js":
/*!***************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/guessType.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ guessType)
/* harmony export */ });
/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly
 *  create a schema, it is useful to know what type to use based on the data we are defining.
 *
 * @param value - The value from which to guess the type
 * @returns - The best guess for the object type
 */
function guessType(value) {
    if (Array.isArray(value)) {
        return 'array';
    }
    if (typeof value === 'string') {
        return 'string';
    }
    if (value == null) {
        return 'null';
    }
    if (typeof value === 'boolean') {
        return 'boolean';
    }
    if (!isNaN(value)) {
        return 'number';
    }
    if (typeof value === 'object') {
        return 'object';
    }
    // Default to string if we can't figure it out
    return 'string';
}
//# sourceMappingURL=guessType.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/hasWidget.js":
/*!***************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/hasWidget.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hasWidget)
/* harmony export */ });
/* harmony import */ var _getWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWidget */ "./node_modules/@rjsf/utils/lib/getWidget.js");

/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it
 * does, or false if it doesn't.
 *
 * @param schema - The schema for the field
 * @param widget - Either the name of the widget OR a `Widget` implementation to use
 * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation
 * @returns - True if the widget exists, false otherwise
 */
function hasWidget(schema, widget, registeredWidgets = {}) {
    try {
        (0,_getWidget__WEBPACK_IMPORTED_MODULE_0__["default"])(schema, widget, registeredWidgets);
        return true;
    }
    catch (e) {
        const err = e;
        if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {
            return false;
        }
        throw e;
    }
}
//# sourceMappingURL=hasWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/hashForSchema.js":
/*!*******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/hashForSchema.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hashForSchema)
/* harmony export */ });
/** JS has no built-in hashing function, so rolling our own
 *  based on Java's hashing fn:
 *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html
 *
 * @param string - The string for which to get the hash
 * @returns - The resulting hash of the string in hex format
 */
function hashString(string) {
    let hash = 0;
    for (let i = 0; i < string.length; i += 1) {
        const chr = string.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(16);
}
/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields
 * in consistent order before stringify to prevent different hash ids for the same schema.
 *
 * @param schema - The schema for which the hash is desired
 * @returns - The string obtained from the hash of the stringified schema
 */
function hashForSchema(schema) {
    const allKeys = new Set();
    // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328
    JSON.stringify(schema, (key, value) => (allKeys.add(key), value));
    return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));
}
//# sourceMappingURL=hashForSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/idGenerators.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/idGenerators.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ariaDescribedByIds: () => (/* binding */ ariaDescribedByIds),
/* harmony export */   descriptionId: () => (/* binding */ descriptionId),
/* harmony export */   errorId: () => (/* binding */ errorId),
/* harmony export */   examplesId: () => (/* binding */ examplesId),
/* harmony export */   helpId: () => (/* binding */ helpId),
/* harmony export */   optionId: () => (/* binding */ optionId),
/* harmony export */   titleId: () => (/* binding */ titleId)
/* harmony export */ });
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");


/** Generates a consistent `id` pattern for a given `id` and a `suffix`
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @param suffix - The suffix to append to the id
 */
function idGenerator(id, suffix) {
    const theId = lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(id) ? id : id[_constants__WEBPACK_IMPORTED_MODULE_1__.ID_KEY];
    return `${theId}__${suffix}`;
}
/** Return a consistent `id` for the field description element
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @returns - The consistent id for the field description element from the given `id`
 */
function descriptionId(id) {
    return idGenerator(id, 'description');
}
/** Return a consistent `id` for the field error element
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @returns - The consistent id for the field error element from the given `id`
 */
function errorId(id) {
    return idGenerator(id, 'error');
}
/** Return a consistent `id` for the field examples element
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @returns - The consistent id for the field examples element from the given `id`
 */
function examplesId(id) {
    return idGenerator(id, 'examples');
}
/** Return a consistent `id` for the field help element
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @returns - The consistent id for the field help element from the given `id`
 */
function helpId(id) {
    return idGenerator(id, 'help');
}
/** Return a consistent `id` for the field title element
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @returns - The consistent id for the field title element from the given `id`
 */
function titleId(id) {
    return idGenerator(id, 'title');
}
/** Return a list of element ids that contain additional information about the field that can be used to as the aria
 * description of the field. This is correctly omitting `titleId` which would be "labeling" rather than "describing" the
 * element.
 *
 * @param id - Either simple string id or an IdSchema from which to extract it
 * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list
 * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute
 */
function ariaDescribedByIds(id, includeExamples = false) {
    const examples = includeExamples ? ` ${examplesId(id)}` : '';
    return `${errorId(id)} ${descriptionId(id)} ${helpId(id)}${examples}`;
}
/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget
 *
 * @param id - The id of the parent component for the option
 * @param optionIndex - The index of the option for which the id is desired
 * @returns - An id for the option index based on the parent `id`
 */
function optionId(id, optionIndex) {
    return `${id}-${optionIndex}`;
}
//# sourceMappingURL=idGenerators.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ADDITIONAL_PROPERTIES_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ADDITIONAL_PROPERTIES_KEY),
/* harmony export */   ADDITIONAL_PROPERTY_FLAG: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ADDITIONAL_PROPERTY_FLAG),
/* harmony export */   ALL_OF_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ALL_OF_KEY),
/* harmony export */   ANY_OF_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ANY_OF_KEY),
/* harmony export */   CONST_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.CONST_KEY),
/* harmony export */   DEFAULT_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.DEFAULT_KEY),
/* harmony export */   DEFINITIONS_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.DEFINITIONS_KEY),
/* harmony export */   DEPENDENCIES_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.DEPENDENCIES_KEY),
/* harmony export */   ENUM_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ENUM_KEY),
/* harmony export */   ERRORS_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ERRORS_KEY),
/* harmony export */   ErrorSchemaBuilder: () => (/* reexport safe */ _ErrorSchemaBuilder__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   ID_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ID_KEY),
/* harmony export */   IF_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.IF_KEY),
/* harmony export */   ITEMS_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ITEMS_KEY),
/* harmony export */   JUNK_OPTION_ID: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.JUNK_OPTION_ID),
/* harmony export */   NAME_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.NAME_KEY),
/* harmony export */   ONE_OF_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ONE_OF_KEY),
/* harmony export */   PROPERTIES_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.PROPERTIES_KEY),
/* harmony export */   REF_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.REF_KEY),
/* harmony export */   REQUIRED_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.REQUIRED_KEY),
/* harmony export */   RJSF_ADDITONAL_PROPERTIES_FLAG: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.RJSF_ADDITONAL_PROPERTIES_FLAG),
/* harmony export */   ROOT_SCHEMA_PREFIX: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.ROOT_SCHEMA_PREFIX),
/* harmony export */   SUBMIT_BTN_OPTIONS_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.SUBMIT_BTN_OPTIONS_KEY),
/* harmony export */   TranslatableString: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_53__.TranslatableString),
/* harmony export */   UI_FIELD_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.UI_FIELD_KEY),
/* harmony export */   UI_GLOBAL_OPTIONS_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.UI_GLOBAL_OPTIONS_KEY),
/* harmony export */   UI_OPTIONS_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.UI_OPTIONS_KEY),
/* harmony export */   UI_WIDGET_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_54__.UI_WIDGET_KEY),
/* harmony export */   allowAdditionalItems: () => (/* reexport safe */ _allowAdditionalItems__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   ariaDescribedByIds: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.ariaDescribedByIds),
/* harmony export */   asNumber: () => (/* reexport safe */ _asNumber__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   canExpand: () => (/* reexport safe */ _canExpand__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   createErrorHandler: () => (/* reexport safe */ _createErrorHandler__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   createSchemaUtils: () => (/* reexport safe */ _createSchemaUtils__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   dataURItoBlob: () => (/* reexport safe */ _dataURItoBlob__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   deepEquals: () => (/* reexport safe */ _deepEquals__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   descriptionId: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.descriptionId),
/* harmony export */   englishStringTranslator: () => (/* reexport safe */ _englishStringTranslator__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   enumOptionsDeselectValue: () => (/* reexport safe */ _enumOptionsDeselectValue__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   enumOptionsIndexForValue: () => (/* reexport safe */ _enumOptionsIndexForValue__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   enumOptionsIsSelected: () => (/* reexport safe */ _enumOptionsIsSelected__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   enumOptionsSelectValue: () => (/* reexport safe */ _enumOptionsSelectValue__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   enumOptionsValueForIndex: () => (/* reexport safe */ _enumOptionsValueForIndex__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   errorId: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.errorId),
/* harmony export */   examplesId: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.examplesId),
/* harmony export */   findSchemaDefinition: () => (/* reexport safe */ _findSchemaDefinition__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   getClosestMatchingOption: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.getClosestMatchingOption),
/* harmony export */   getDefaultFormState: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.getDefaultFormState),
/* harmony export */   getDiscriminatorFieldFromSchema: () => (/* reexport safe */ _getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   getDisplayLabel: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.getDisplayLabel),
/* harmony export */   getFirstMatchingOption: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.getFirstMatchingOption),
/* harmony export */   getInputProps: () => (/* reexport safe */ _getInputProps__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   getMatchingOption: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.getMatchingOption),
/* harmony export */   getOptionMatchingSimpleDiscriminator: () => (/* reexport safe */ _getOptionMatchingSimpleDiscriminator__WEBPACK_IMPORTED_MODULE_51__["default"]),
/* harmony export */   getSchemaType: () => (/* reexport safe */ _getSchemaType__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   getSubmitButtonOptions: () => (/* reexport safe */ _getSubmitButtonOptions__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   getTemplate: () => (/* reexport safe */ _getTemplate__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   getUiOptions: () => (/* reexport safe */ _getUiOptions__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   getWidget: () => (/* reexport safe */ _getWidget__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   guessType: () => (/* reexport safe */ _guessType__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   hasWidget: () => (/* reexport safe */ _hasWidget__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   hashForSchema: () => (/* reexport safe */ _hashForSchema__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   helpId: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.helpId),
/* harmony export */   isConstant: () => (/* reexport safe */ _isConstant__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   isCustomWidget: () => (/* reexport safe */ _isCustomWidget__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   isFilesArray: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.isFilesArray),
/* harmony export */   isFixedItems: () => (/* reexport safe */ _isFixedItems__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   isMultiSelect: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.isMultiSelect),
/* harmony export */   isObject: () => (/* reexport safe */ _isObject__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   isSelect: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.isSelect),
/* harmony export */   labelValue: () => (/* reexport safe */ _labelValue__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   localToUTC: () => (/* reexport safe */ _localToUTC__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   mergeDefaultsWithFormData: () => (/* reexport safe */ _mergeDefaultsWithFormData__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   mergeObjects: () => (/* reexport safe */ _mergeObjects__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   mergeSchemas: () => (/* reexport safe */ _mergeSchemas__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   mergeValidationData: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.mergeValidationData),
/* harmony export */   optionId: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.optionId),
/* harmony export */   optionsList: () => (/* reexport safe */ _optionsList__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   orderProperties: () => (/* reexport safe */ _orderProperties__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   pad: () => (/* reexport safe */ _pad__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   parseDateString: () => (/* reexport safe */ _parseDateString__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   rangeSpec: () => (/* reexport safe */ _rangeSpec__WEBPACK_IMPORTED_MODULE_39__["default"]),
/* harmony export */   replaceStringParameters: () => (/* reexport safe */ _replaceStringParameters__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   retrieveSchema: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.retrieveSchema),
/* harmony export */   sanitizeDataForNewSchema: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.sanitizeDataForNewSchema),
/* harmony export */   schemaParser: () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_55__.schemaParser),
/* harmony export */   schemaRequiresTrueValue: () => (/* reexport safe */ _schemaRequiresTrueValue__WEBPACK_IMPORTED_MODULE_41__["default"]),
/* harmony export */   shouldRender: () => (/* reexport safe */ _shouldRender__WEBPACK_IMPORTED_MODULE_42__["default"]),
/* harmony export */   titleId: () => (/* reexport safe */ _idGenerators__WEBPACK_IMPORTED_MODULE_25__.titleId),
/* harmony export */   toConstant: () => (/* reexport safe */ _toConstant__WEBPACK_IMPORTED_MODULE_43__["default"]),
/* harmony export */   toDateString: () => (/* reexport safe */ _toDateString__WEBPACK_IMPORTED_MODULE_44__["default"]),
/* harmony export */   toErrorList: () => (/* reexport safe */ _toErrorList__WEBPACK_IMPORTED_MODULE_45__["default"]),
/* harmony export */   toErrorSchema: () => (/* reexport safe */ _toErrorSchema__WEBPACK_IMPORTED_MODULE_46__["default"]),
/* harmony export */   toIdSchema: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.toIdSchema),
/* harmony export */   toPathSchema: () => (/* reexport safe */ _schema__WEBPACK_IMPORTED_MODULE_56__.toPathSchema),
/* harmony export */   unwrapErrorHandler: () => (/* reexport safe */ _unwrapErrorHandler__WEBPACK_IMPORTED_MODULE_47__["default"]),
/* harmony export */   utcToLocal: () => (/* reexport safe */ _utcToLocal__WEBPACK_IMPORTED_MODULE_48__["default"]),
/* harmony export */   validationDataMerge: () => (/* reexport safe */ _validationDataMerge__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   withIdRefPrefix: () => (/* reexport safe */ _withIdRefPrefix__WEBPACK_IMPORTED_MODULE_50__["default"])
/* harmony export */ });
/* harmony import */ var _allowAdditionalItems__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./allowAdditionalItems */ "./node_modules/@rjsf/utils/lib/allowAdditionalItems.js");
/* harmony import */ var _asNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asNumber */ "./node_modules/@rjsf/utils/lib/asNumber.js");
/* harmony import */ var _canExpand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canExpand */ "./node_modules/@rjsf/utils/lib/canExpand.js");
/* harmony import */ var _createErrorHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createErrorHandler */ "./node_modules/@rjsf/utils/lib/createErrorHandler.js");
/* harmony import */ var _createSchemaUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createSchemaUtils */ "./node_modules/@rjsf/utils/lib/createSchemaUtils.js");
/* harmony import */ var _dataURItoBlob__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataURItoBlob */ "./node_modules/@rjsf/utils/lib/dataURItoBlob.js");
/* harmony import */ var _deepEquals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./deepEquals */ "./node_modules/@rjsf/utils/lib/deepEquals.js");
/* harmony import */ var _englishStringTranslator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./englishStringTranslator */ "./node_modules/@rjsf/utils/lib/englishStringTranslator.js");
/* harmony import */ var _enumOptionsDeselectValue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./enumOptionsDeselectValue */ "./node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js");
/* harmony import */ var _enumOptionsIndexForValue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./enumOptionsIndexForValue */ "./node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js");
/* harmony import */ var _enumOptionsIsSelected__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./enumOptionsIsSelected */ "./node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js");
/* harmony import */ var _enumOptionsSelectValue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./enumOptionsSelectValue */ "./node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js");
/* harmony import */ var _enumOptionsValueForIndex__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./enumOptionsValueForIndex */ "./node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js");
/* harmony import */ var _ErrorSchemaBuilder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ErrorSchemaBuilder */ "./node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js");
/* harmony import */ var _findSchemaDefinition__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./findSchemaDefinition */ "./node_modules/@rjsf/utils/lib/findSchemaDefinition.js");
/* harmony import */ var _getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./getDiscriminatorFieldFromSchema */ "./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js");
/* harmony import */ var _getInputProps__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./getInputProps */ "./node_modules/@rjsf/utils/lib/getInputProps.js");
/* harmony import */ var _getSchemaType__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./getSchemaType */ "./node_modules/@rjsf/utils/lib/getSchemaType.js");
/* harmony import */ var _getSubmitButtonOptions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./getSubmitButtonOptions */ "./node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js");
/* harmony import */ var _getTemplate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./getTemplate */ "./node_modules/@rjsf/utils/lib/getTemplate.js");
/* harmony import */ var _getUiOptions__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./getUiOptions */ "./node_modules/@rjsf/utils/lib/getUiOptions.js");
/* harmony import */ var _getWidget__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./getWidget */ "./node_modules/@rjsf/utils/lib/getWidget.js");
/* harmony import */ var _guessType__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./guessType */ "./node_modules/@rjsf/utils/lib/guessType.js");
/* harmony import */ var _hashForSchema__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./hashForSchema */ "./node_modules/@rjsf/utils/lib/hashForSchema.js");
/* harmony import */ var _hasWidget__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./hasWidget */ "./node_modules/@rjsf/utils/lib/hasWidget.js");
/* harmony import */ var _idGenerators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./idGenerators */ "./node_modules/@rjsf/utils/lib/idGenerators.js");
/* harmony import */ var _isConstant__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./isConstant */ "./node_modules/@rjsf/utils/lib/isConstant.js");
/* harmony import */ var _isCustomWidget__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./isCustomWidget */ "./node_modules/@rjsf/utils/lib/isCustomWidget.js");
/* harmony import */ var _isFixedItems__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./isFixedItems */ "./node_modules/@rjsf/utils/lib/isFixedItems.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");
/* harmony import */ var _labelValue__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./labelValue */ "./node_modules/@rjsf/utils/lib/labelValue.js");
/* harmony import */ var _localToUTC__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./localToUTC */ "./node_modules/@rjsf/utils/lib/localToUTC.js");
/* harmony import */ var _mergeDefaultsWithFormData__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./mergeDefaultsWithFormData */ "./node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js");
/* harmony import */ var _mergeObjects__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./mergeObjects */ "./node_modules/@rjsf/utils/lib/mergeObjects.js");
/* harmony import */ var _mergeSchemas__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./mergeSchemas */ "./node_modules/@rjsf/utils/lib/mergeSchemas.js");
/* harmony import */ var _optionsList__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./optionsList */ "./node_modules/@rjsf/utils/lib/optionsList.js");
/* harmony import */ var _orderProperties__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./orderProperties */ "./node_modules/@rjsf/utils/lib/orderProperties.js");
/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./pad */ "./node_modules/@rjsf/utils/lib/pad.js");
/* harmony import */ var _parseDateString__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./parseDateString */ "./node_modules/@rjsf/utils/lib/parseDateString.js");
/* harmony import */ var _rangeSpec__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./rangeSpec */ "./node_modules/@rjsf/utils/lib/rangeSpec.js");
/* harmony import */ var _replaceStringParameters__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./replaceStringParameters */ "./node_modules/@rjsf/utils/lib/replaceStringParameters.js");
/* harmony import */ var _schemaRequiresTrueValue__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./schemaRequiresTrueValue */ "./node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js");
/* harmony import */ var _shouldRender__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./shouldRender */ "./node_modules/@rjsf/utils/lib/shouldRender.js");
/* harmony import */ var _toConstant__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./toConstant */ "./node_modules/@rjsf/utils/lib/toConstant.js");
/* harmony import */ var _toDateString__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./toDateString */ "./node_modules/@rjsf/utils/lib/toDateString.js");
/* harmony import */ var _toErrorList__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./toErrorList */ "./node_modules/@rjsf/utils/lib/toErrorList.js");
/* harmony import */ var _toErrorSchema__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./toErrorSchema */ "./node_modules/@rjsf/utils/lib/toErrorSchema.js");
/* harmony import */ var _unwrapErrorHandler__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./unwrapErrorHandler */ "./node_modules/@rjsf/utils/lib/unwrapErrorHandler.js");
/* harmony import */ var _utcToLocal__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./utcToLocal */ "./node_modules/@rjsf/utils/lib/utcToLocal.js");
/* harmony import */ var _validationDataMerge__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./validationDataMerge */ "./node_modules/@rjsf/utils/lib/validationDataMerge.js");
/* harmony import */ var _withIdRefPrefix__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./withIdRefPrefix */ "./node_modules/@rjsf/utils/lib/withIdRefPrefix.js");
/* harmony import */ var _getOptionMatchingSimpleDiscriminator__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./getOptionMatchingSimpleDiscriminator */ "./node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./types */ "./node_modules/@rjsf/utils/lib/types.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./enums */ "./node_modules/@rjsf/utils/lib/enums.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./parser */ "./node_modules/@rjsf/utils/lib/parser/index.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./schema */ "./node_modules/@rjsf/utils/lib/schema/index.js");


























































//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/isConstant.js":
/*!****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/isConstant.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isConstant)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");

/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has
 * an `enum` array with a single value or there is a `const` defined.
 *
 * @param schema - The schema for a field
 * @returns - True if the `schema` has a single constant value, false otherwise
 */
function isConstant(schema) {
    return (Array.isArray(schema.enum) && schema.enum.length === 1) || _constants__WEBPACK_IMPORTED_MODULE_0__.CONST_KEY in schema;
}
//# sourceMappingURL=isConstant.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/isCustomWidget.js":
/*!********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/isCustomWidget.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isCustomWidget)
/* harmony export */ });
/* harmony import */ var _getUiOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getUiOptions */ "./node_modules/@rjsf/utils/lib/getUiOptions.js");

/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`
 *
 * @param uiSchema - The UI Schema from which to detect if it is customized
 * @returns - True if the `uiSchema` describes a custom widget, false otherwise
 */
function isCustomWidget(uiSchema = {}) {
    return (
    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
    'widget' in (0,_getUiOptions__WEBPACK_IMPORTED_MODULE_0__["default"])(uiSchema) && (0,_getUiOptions__WEBPACK_IMPORTED_MODULE_0__["default"])(uiSchema)['widget'] !== 'hidden');
}
//# sourceMappingURL=isCustomWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/isFixedItems.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/isFixedItems.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isFixedItems)
/* harmony export */ });
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");

/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array
 * that only contains objects.
 *
 * @param schema - The schema in which to check for fixed items
 * @returns - True if there are fixed items in the schema, false otherwise
 */
function isFixedItems(schema) {
    return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => (0,_isObject__WEBPACK_IMPORTED_MODULE_0__["default"])(item));
}
//# sourceMappingURL=isFixedItems.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/isObject.js":
/*!**************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/isObject.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isObject)
/* harmony export */ });
/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has
 * the type `object` but is NOT null, an array or a File.
 *
 * @param thing - The thing to check to see whether it is an object
 * @returns - True if it is a non-null, non-array, non-File object
 */
function isObject(thing) {
    if (typeof File !== 'undefined' && thing instanceof File) {
        return false;
    }
    if (typeof Date !== 'undefined' && thing instanceof Date) {
        return false;
    }
    return typeof thing === 'object' && thing !== null && !Array.isArray(thing);
}
//# sourceMappingURL=isObject.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/labelValue.js":
/*!****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/labelValue.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ labelValue)
/* harmony export */ });
function labelValue(label, hideLabel, fallback) {
    return hideLabel ? fallback : label;
}
//# sourceMappingURL=labelValue.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/localToUTC.js":
/*!****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/localToUTC.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ localToUTC)
/* harmony export */ });
/** Converts a local Date string into a UTC date string
 *
 * @param dateString - The string representation of a date as accepted by the `Date()` constructor
 * @returns - A UTC date string if `dateString` is truthy, otherwise undefined
 */
function localToUTC(dateString) {
    return dateString ? new Date(dateString).toJSON() : undefined;
}
//# sourceMappingURL=localToUTC.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeDefaultsWithFormData)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");


/** Merges the `defaults` object of type `T` into the `formData` of type `T`
 *
 * When merging defaults and form data, we want to merge in this specific way:
 * - objects are deeply merged
 * - arrays are merged in such a way that:
 *   - when the array is set in form data, only array entries set in form data
 *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in
 *     which case the extras are appended onto the end of the form data
 *   - when the array is not set in form data, the default is copied over
 * - scalars are overwritten/set by form data
 *
 * @param [defaults] - The defaults to merge
 * @param [formData] - The form data into which the defaults will be merged
 * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData
 * @returns - The resulting merged form data with defaults
 */
function mergeDefaultsWithFormData(defaults, formData, mergeExtraArrayDefaults = false) {
    if (Array.isArray(formData)) {
        const defaultsArray = Array.isArray(defaults) ? defaults : [];
        const mapped = formData.map((value, idx) => {
            if (defaultsArray[idx]) {
                return mergeDefaultsWithFormData(defaultsArray[idx], value, mergeExtraArrayDefaults);
            }
            return value;
        });
        // Merge any extra defaults when mergeExtraArrayDefaults is true
        if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {
            mapped.push(...defaultsArray.slice(mapped.length));
        }
        return mapped;
    }
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(formData)) {
        const acc = Object.assign({}, defaults); // Prevent mutation of source object.
        return Object.keys(formData).reduce((acc, key) => {
            acc[key] = mergeDefaultsWithFormData(defaults ? lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(defaults, key) : {}, lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, key), mergeExtraArrayDefaults);
            return acc;
        }, acc);
    }
    return formData;
}
//# sourceMappingURL=mergeDefaultsWithFormData.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/mergeObjects.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/mergeObjects.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeObjects)
/* harmony export */ });
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");

/** Recursively merge deeply nested objects.
 *
 * @param obj1 - The first object to merge
 * @param obj2 - The second object to merge
 * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use
 *          "preventDuplicates" to merge arrays in a manner that prevents any duplicate entries from being merged.
 *          NOTE: Uses shallow comparison for the duplicate checking.
 * @returns - A new object that is the merge of the two given objects
 */
function mergeObjects(obj1, obj2, concatArrays = false) {
    return Object.keys(obj2).reduce((acc, key) => {
        const left = obj1 ? obj1[key] : {}, right = obj2[key];
        if (obj1 && key in obj1 && (0,_isObject__WEBPACK_IMPORTED_MODULE_0__["default"])(right)) {
            acc[key] = mergeObjects(left, right, concatArrays);
        }
        else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
            let toMerge = right;
            if (concatArrays === 'preventDuplicates') {
                toMerge = right.reduce((result, value) => {
                    if (!left.includes(value)) {
                        result.push(value);
                    }
                    return result;
                }, []);
            }
            acc[key] = left.concat(toMerge);
        }
        else {
            acc[key] = right;
        }
        return acc;
    }, Object.assign({}, obj1)); // Prevent mutation of source object.
}
//# sourceMappingURL=mergeObjects.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/mergeSchemas.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/mergeSchemas.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeSchemas)
/* harmony export */ });
/* harmony import */ var lodash_union__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js");
/* harmony import */ var lodash_union__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_union__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _getSchemaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getSchemaType */ "./node_modules/@rjsf/utils/lib/getSchemaType.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");




/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that
 * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include
 * duplicate values.
 *
 * @param obj1 - The first schema object to merge
 * @param obj2 - The second schema object to merge
 * @returns - The merged schema object
 */
function mergeSchemas(obj1, obj2) {
    const acc = Object.assign({}, obj1); // Prevent mutation of source object.
    return Object.keys(obj2).reduce((acc, key) => {
        const left = obj1 ? obj1[key] : {}, right = obj2[key];
        if (obj1 && key in obj1 && (0,_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(right)) {
            acc[key] = mergeSchemas(left, right);
        }
        else if (obj1 &&
            obj2 &&
            ((0,_getSchemaType__WEBPACK_IMPORTED_MODULE_2__["default"])(obj1) === 'object' || (0,_getSchemaType__WEBPACK_IMPORTED_MODULE_2__["default"])(obj2) === 'object') &&
            key === _constants__WEBPACK_IMPORTED_MODULE_1__.REQUIRED_KEY &&
            Array.isArray(left) &&
            Array.isArray(right)) {
            // Don't include duplicate values when merging 'required' fields.
            acc[key] = lodash_union__WEBPACK_IMPORTED_MODULE_0___default()(left, right);
        }
        else {
            acc[key] = right;
        }
        return acc;
    }, acc);
}
//# sourceMappingURL=mergeSchemas.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/optionsList.js":
/*!*****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/optionsList.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ optionsList)
/* harmony export */ });
/* harmony import */ var _toConstant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toConstant */ "./node_modules/@rjsf/utils/lib/toConstant.js");

/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The
 * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise
 * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of
 * `const` values from the schema and the label is either the `schema.title` or the value.
 *
 * @param schema - The schema from which to extract the options list
 * @returns - The list of options from the schema
 */
function optionsList(schema) {
    // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.
    // Cast the type to include enumNames so the feature still works.
    const schemaWithEnumNames = schema;
    if (schemaWithEnumNames.enumNames && "development" !== 'production') {
        console.warn('The enumNames property is deprecated and may be removed in a future major release.');
    }
    if (schema.enum) {
        return schema.enum.map((value, i) => {
            const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);
            return { label, value };
        });
    }
    const altSchemas = schema.oneOf || schema.anyOf;
    return (altSchemas &&
        altSchemas.map((aSchemaDef) => {
            const aSchema = aSchemaDef;
            const value = (0,_toConstant__WEBPACK_IMPORTED_MODULE_0__["default"])(aSchema);
            const label = aSchema.title || String(value);
            return {
                schema: aSchema,
                label,
                value,
            };
        }));
}
//# sourceMappingURL=optionsList.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/orderProperties.js":
/*!*********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/orderProperties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderProperties)
/* harmony export */ });
/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.
 * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per
 * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be
 * places in the location of the `*`.
 *
 * @param properties - The list of property keys to be ordered
 * @param order - An array of property keys to be ordered first, with an optional '*' property
 * @returns - A list with the `properties` ordered
 * @throws - Error when the properties cannot be ordered correctly
 */
function orderProperties(properties, order) {
    if (!Array.isArray(order)) {
        return properties;
    }
    const arrayToHash = (arr) => arr.reduce((prev, curr) => {
        prev[curr] = true;
        return prev;
    }, {});
    const errorPropList = (arr) => arr.length > 1 ? `properties '${arr.join("', '")}'` : `property '${arr[0]}'`;
    const propertyHash = arrayToHash(properties);
    const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);
    const orderHash = arrayToHash(orderFiltered);
    const rest = properties.filter((prop) => !orderHash[prop]);
    const restIndex = orderFiltered.indexOf('*');
    if (restIndex === -1) {
        if (rest.length) {
            throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);
        }
        return orderFiltered;
    }
    if (restIndex !== orderFiltered.lastIndexOf('*')) {
        throw new Error('uiSchema order list contains more than one wildcard item');
    }
    const complete = [...orderFiltered];
    complete.splice(restIndex, 1, ...rest);
    return complete;
}
//# sourceMappingURL=orderProperties.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/pad.js":
/*!*********************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/pad.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pad)
/* harmony export */ });
/** Returns a string representation of the `num` that is padded with leading "0"s if necessary
 *
 * @param num - The number to pad
 * @param width - The width of the string at which no lead padding is necessary
 * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`
 */
function pad(num, width) {
    let s = String(num);
    while (s.length < width) {
        s = '0' + s;
    }
    return s;
}
//# sourceMappingURL=pad.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/parseDateString.js":
/*!*********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/parseDateString.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseDateString)
/* harmony export */ });
/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true
 *
 * @param dateString - The date string to parse into a DateObject
 * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object
 * @returns - The date string converted to a `DateObject`
 * @throws - Error when the date cannot be parsed from the string
 */
function parseDateString(dateString, includeTime = true) {
    if (!dateString) {
        return {
            year: -1,
            month: -1,
            day: -1,
            hour: includeTime ? -1 : 0,
            minute: includeTime ? -1 : 0,
            second: includeTime ? -1 : 0,
        };
    }
    const date = new Date(dateString);
    if (Number.isNaN(date.getTime())) {
        throw new Error('Unable to parse date ' + dateString);
    }
    return {
        year: date.getUTCFullYear(),
        month: date.getUTCMonth() + 1,
        day: date.getUTCDate(),
        hour: includeTime ? date.getUTCHours() : 0,
        minute: includeTime ? date.getUTCMinutes() : 0,
        second: includeTime ? date.getUTCSeconds() : 0,
    };
}
//# sourceMappingURL=parseDateString.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/parser/ParserValidator.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/parser/ParserValidator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ParserValidator)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _hashForSchema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hashForSchema */ "./node_modules/@rjsf/utils/lib/hashForSchema.js");




/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the
 * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.
 * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These
 * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by
 * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the
 * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.
 */
class ParserValidator {
    /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`
     * first.
     *
     * @param rootSchema - The root schema against which this validator will be executed
     */
    constructor(rootSchema) {
        /** The map of schemas encountered by the ParserValidator */
        this.schemaMap = {};
        this.rootSchema = rootSchema;
        this.addSchema(rootSchema, (0,_hashForSchema__WEBPACK_IMPORTED_MODULE_3__["default"])(rootSchema));
    }
    /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the
     * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be
     * associated with it's `hash` for future use (by a schema compiler).
     *
     * @param schema - The schema which is to be added to the map
     * @param hash - The hash value at which to map the schema
     */
    addSchema(schema, hash) {
        const key = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, _constants__WEBPACK_IMPORTED_MODULE_2__.ID_KEY, hash);
        const identifiedSchema = { ...schema, [_constants__WEBPACK_IMPORTED_MODULE_2__.ID_KEY]: key };
        const existing = this.schemaMap[key];
        if (!existing) {
            this.schemaMap[key] = identifiedSchema;
        }
        else if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(existing, identifiedSchema)) {
            console.error('existing schema:', JSON.stringify(existing, null, 2));
            console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));
            throw new Error(`Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`);
        }
    }
    /** Returns the current `schemaMap` to the caller
     */
    getSchemaMap() {
        return this.schemaMap;
    }
    /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when
     * the `rootSchema` is not the same as the root schema provided during construction.
     *
     * @param schema - The schema to record in the `schemaMap`
     * @param _formData - The formData parameter that is ignored
     * @param rootSchema - The root schema associated with the schema
     * @throws - Error when the given `rootSchema` differs from the root schema provided during construction
     */
    isValid(schema, _formData, rootSchema) {
        if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(rootSchema, this.rootSchema)) {
            throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');
        }
        this.addSchema(schema, (0,_hashForSchema__WEBPACK_IMPORTED_MODULE_3__["default"])(schema));
        return false;
    }
    /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called
     *
     * @param _schema - The schema parameter that is ignored
     * @param _formData - The formData parameter that is ignored
     */
    rawValidation(_schema, _formData) {
        throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');
    }
    /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called
     *
     * @param _errorSchema - The error schema parameter that is ignored
     * @param _fieldPath - The field path parameter that is ignored
     */
    toErrorList(_errorSchema, _fieldPath) {
        throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');
    }
    /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be
     * called
     *
     * @param _formData - The formData parameter that is ignored
     * @param _schema - The schema parameter that is ignored
     * @param _customValidate - The customValidate parameter that is ignored
     * @param _transformErrors - The transformErrors parameter that is ignored
     * @param _uiSchema - The uiSchema parameter that is ignored
     */
    validateFormData(_formData, _schema, _customValidate, _transformErrors, _uiSchema) {
        throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');
    }
}
//# sourceMappingURL=ParserValidator.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/parser/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/parser/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   schemaParser: () => (/* reexport safe */ _schemaParser__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _schemaParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schemaParser */ "./node_modules/@rjsf/utils/lib/parser/schemaParser.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/parser/schemaParser.js":
/*!*************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/parser/schemaParser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ schemaParser)
/* harmony export */ });
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js");
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _ParserValidator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ParserValidator */ "./node_modules/@rjsf/utils/lib/parser/ParserValidator.js");
/* harmony import */ var _schema_retrieveSchema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../schema/retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");





/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to
 * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the
 * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned
 * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.
 *
 * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing
 * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion
 * @param rootSchema - The root schema from which the schema parsing began
 * @param schema - The current schema element being parsed
 */
function parseSchema(validator, recurseList, rootSchema, schema) {
    const schemas = (0,_schema_retrieveSchema__WEBPACK_IMPORTED_MODULE_4__.retrieveSchemaInternal)(validator, schema, rootSchema, undefined, true);
    schemas.forEach((schema) => {
        const sameSchemaIndex = recurseList.findIndex((item) => lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(item, schema));
        if (sameSchemaIndex === -1) {
            recurseList.push(schema);
            const allOptions = (0,_schema_retrieveSchema__WEBPACK_IMPORTED_MODULE_4__.resolveAnyOrOneOfSchemas)(validator, schema, rootSchema, true);
            allOptions.forEach((s) => {
                if (_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY in s && s[_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY]) {
                    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(schema[_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY], (value) => {
                        parseSchema(validator, recurseList, rootSchema, value);
                    });
                }
            });
            if (_constants__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {
                parseSchema(validator, recurseList, rootSchema, schema.items);
            }
        }
    });
}
/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of
 * the hash of the schema to schema/sub-schema.
 *
 * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls
 * @returns - The `SchemaMap` of all schemas that were parsed
 */
function schemaParser(rootSchema) {
    const validator = new _ParserValidator__WEBPACK_IMPORTED_MODULE_3__["default"](rootSchema);
    const recurseList = [];
    parseSchema(validator, recurseList, rootSchema, rootSchema);
    return validator.getSchemaMap();
}
//# sourceMappingURL=schemaParser.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/rangeSpec.js":
/*!***************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/rangeSpec.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rangeSpec)
/* harmony export */ });
/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML
 * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.
 *
 * @param schema - The schema from which to extract the range spec
 * @returns - A range specification from the schema
 */
function rangeSpec(schema) {
    const spec = {};
    if (schema.multipleOf) {
        spec.step = schema.multipleOf;
    }
    if (schema.minimum || schema.minimum === 0) {
        spec.min = schema.minimum;
    }
    if (schema.maximum || schema.maximum === 0) {
        spec.max = schema.maximum;
    }
    return spec;
}
//# sourceMappingURL=rangeSpec.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/replaceStringParameters.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/replaceStringParameters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ replaceStringParameters)
/* harmony export */ });
/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When
 * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the
 * `inputString` using the `%1`, `%2`, etc. replacement specifiers.
 *
 * @param inputString - The string which will be potentially updated with replacement parameters
 * @param params - The optional list of replaceable parameter values to substitute into the english string
 * @returns - The updated string with any replacement specifiers replaced
 */
function replaceStringParameters(inputString, params) {
    let output = inputString;
    if (Array.isArray(params)) {
        const parts = output.split(/(%\d)/);
        params.forEach((param, index) => {
            const partIndex = parts.findIndex((part) => part === `%${index + 1}`);
            if (partIndex >= 0) {
                parts[partIndex] = param;
            }
        });
        output = parts.join('');
    }
    return output;
}
//# sourceMappingURL=replaceStringParameters.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ schemaRequiresTrueValue)
/* harmony export */ });
/** Check to see if a `schema` specifies that a value must be true. This happens when:
 * - `schema.const` is truthy
 * - `schema.enum` == `[true]`
 * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true
 * - `schema.allOf` has at least one value which recursively returns true
 *
 * @param schema - The schema to check
 * @returns - True if the schema specifies a value that must be true, false otherwise
 */
function schemaRequiresTrueValue(schema) {
    // Check if const is a truthy value
    if (schema.const) {
        return true;
    }
    // Check if an enum has a single value of true
    if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {
        return true;
    }
    // If anyOf has a single value, evaluate the subschema
    if (schema.anyOf && schema.anyOf.length === 1) {
        return schemaRequiresTrueValue(schema.anyOf[0]);
    }
    // If oneOf has a single value, evaluate the subschema
    if (schema.oneOf && schema.oneOf.length === 1) {
        return schemaRequiresTrueValue(schema.oneOf[0]);
    }
    // Evaluate each subschema in allOf, to see if one of them requires a true value
    if (schema.allOf) {
        const schemaSome = (subSchema) => schemaRequiresTrueValue(subSchema);
        return schema.allOf.some(schemaSome);
    }
    return false;
}
//# sourceMappingURL=schemaRequiresTrueValue.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JUNK_OPTION: () => (/* binding */ JUNK_OPTION),
/* harmony export */   calculateIndexScore: () => (/* binding */ calculateIndexScore),
/* harmony export */   "default": () => (/* binding */ getClosestMatchingOption)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js");
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_has__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isString */ "./node_modules/lodash/isString.js");
/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js");
/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_reduce__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/times */ "./node_modules/lodash/times.js");
/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_times__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _getFirstMatchingOption__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getFirstMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _guessType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../guessType */ "./node_modules/@rjsf/utils/lib/guessType.js");
/* harmony import */ var _getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../getDiscriminatorFieldFromSchema */ "./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js");
/* harmony import */ var _getOptionMatchingSimpleDiscriminator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../getOptionMatchingSimpleDiscriminator */ "./node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js");













/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning
 * the first item
 */
const JUNK_OPTION = {
    type: 'object',
    $id: _constants__WEBPACK_IMPORTED_MODULE_9__.JUNK_OPTION_ID,
    properties: {
        __not_really_there__: {
            type: 'number',
        },
    },
};
/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly
 * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within
 * the object are processed as follows after obtaining the formValue from `formData` using the `key`:
 * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new
 *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to
 *   the total.
 * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling
 *   `getClosestMatchingOption()` of that oneOf.
 * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the
 *   `value` itself as the sub-schema, and the score is added to the total.
 * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the
 *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score
 *   is incremented by another 1 otherwise it is decremented by 1.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param rootSchema - The root JSON schema of the entire form
 * @param schema - The schema for which the score is being calculated
 * @param formData - The form data associated with the schema, used to calculate the score
 * @returns - The score a schema against the formData
 */
function calculateIndexScore(validator, rootSchema, schema, formData = {}) {
    let totalScore = 0;
    if (schema) {
        if (lodash_isObject__WEBPACK_IMPORTED_MODULE_3___default()(schema.properties)) {
            totalScore += lodash_reduce__WEBPACK_IMPORTED_MODULE_5___default()(schema.properties, (score, value, key) => {
                const formValue = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, key);
                if (typeof value === 'boolean') {
                    return score;
                }
                if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(value, _constants__WEBPACK_IMPORTED_MODULE_9__.REF_KEY)) {
                    const newSchema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_8__["default"])(validator, value, rootSchema, formValue);
                    return score + calculateIndexScore(validator, rootSchema, newSchema, formValue || {});
                }
                if ((lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(value, _constants__WEBPACK_IMPORTED_MODULE_9__.ONE_OF_KEY) || lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(value, _constants__WEBPACK_IMPORTED_MODULE_9__.ANY_OF_KEY)) && formValue) {
                    const key = lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(value, _constants__WEBPACK_IMPORTED_MODULE_9__.ONE_OF_KEY) ? _constants__WEBPACK_IMPORTED_MODULE_9__.ONE_OF_KEY : _constants__WEBPACK_IMPORTED_MODULE_9__.ANY_OF_KEY;
                    const discriminator = (0,_getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_11__["default"])(value);
                    return (score +
                        getClosestMatchingOption(validator, rootSchema, formValue, lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(value, key), -1, discriminator));
                }
                if (value.type === 'object') {
                    return score + calculateIndexScore(validator, rootSchema, value, formValue || {});
                }
                if (value.type === (0,_guessType__WEBPACK_IMPORTED_MODULE_10__["default"])(formValue)) {
                    // If the types match, then we bump the score by one
                    let newScore = score + 1;
                    if (value.default) {
                        // If the schema contains a readonly default value score the value that matches the default higher and
                        // any non-matching value lower
                        newScore += formValue === value.default ? 1 : -1;
                    }
                    else if (value.const) {
                        // If the schema contains a const value score the value that matches the default higher and
                        // any non-matching value lower
                        newScore += formValue === value.const ? 1 : -1;
                    }
                    // TODO eventually, deal with enums/arrays
                    return newScore;
                }
                return score;
            }, 0);
        }
        else if (lodash_isString__WEBPACK_IMPORTED_MODULE_4___default()(schema.type) && schema.type === (0,_guessType__WEBPACK_IMPORTED_MODULE_10__["default"])(formData)) {
            totalScore += 1;
        }
    }
    return totalScore;
}
/** Determines which of the given `options` provided most closely matches the `formData`. Using
 * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field
 * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to
 * this utility, instead an array of valid option indexes is created by iterating over the list of options, call
 * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered
 * matched.
 *
 * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are
 * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the
 * option with the highest score is determined by iterating over the list of valid options, calling
 * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that
 * eventually has the best score.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param rootSchema - The root JSON schema of the entire form
 * @param formData - The form data associated with the schema
 * @param options - The list of options that can be selected from
 * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified
 * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
 *          determine which option is selected
 * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
 */
function getClosestMatchingOption(validator, rootSchema, formData, options, selectedOption = -1, discriminatorField) {
    // First resolve any refs in the options
    const resolvedOptions = options.map((option) => {
        return (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_8__.resolveAllReferences)(option, rootSchema, []);
    });
    const simpleDiscriminatorMatch = (0,_getOptionMatchingSimpleDiscriminator__WEBPACK_IMPORTED_MODULE_12__["default"])(formData, options, discriminatorField);
    if (lodash_isNumber__WEBPACK_IMPORTED_MODULE_2___default()(simpleDiscriminatorMatch)) {
        return simpleDiscriminatorMatch;
    }
    // Reduce the array of options down to a list of the indexes that are considered matching options
    const allValidIndexes = resolvedOptions.reduce((validList, option, index) => {
        const testOptions = [JUNK_OPTION, option];
        const match = (0,_getFirstMatchingOption__WEBPACK_IMPORTED_MODULE_7__["default"])(validator, formData, testOptions, rootSchema, discriminatorField);
        // The match is the real option, so add its index to list of valid indexes
        if (match === 1) {
            validList.push(index);
        }
        return validList;
    }, []);
    // There is only one valid index, so return it!
    if (allValidIndexes.length === 1) {
        return allValidIndexes[0];
    }
    if (!allValidIndexes.length) {
        // No indexes were valid, so we'll score all the options, add all the indexes
        lodash_times__WEBPACK_IMPORTED_MODULE_6___default()(resolvedOptions.length, (i) => allValidIndexes.push(i));
    }
    const scoreCount = new Set();
    // Score all the options in the list of valid indexes and return the index with the best score
    const { bestIndex } = allValidIndexes.reduce((scoreData, index) => {
        const { bestScore } = scoreData;
        const option = resolvedOptions[index];
        const score = calculateIndexScore(validator, rootSchema, option, formData);
        scoreCount.add(score);
        if (score > bestScore) {
            return { bestIndex: index, bestScore: score };
        }
        return scoreData;
    }, { bestIndex: selectedOption, bestScore: 0 });
    // if all scores are the same go with selectedOption
    if (scoreCount.size === 1 && selectedOption >= 0) {
        return selectedOption;
    }
    return bestIndex;
}
//# sourceMappingURL=getClosestMatchingOption.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js":
/*!********************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdditionalItemsHandling: () => (/* binding */ AdditionalItemsHandling),
/* harmony export */   computeDefaults: () => (/* binding */ computeDefaults),
/* harmony export */   "default": () => (/* binding */ getDefaultFormState),
/* harmony export */   getInnerSchemaForArrayItem: () => (/* binding */ getInnerSchemaForArrayItem)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _findSchemaDefinition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../findSchemaDefinition */ "./node_modules/@rjsf/utils/lib/findSchemaDefinition.js");
/* harmony import */ var _getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getClosestMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js");
/* harmony import */ var _getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../getDiscriminatorFieldFromSchema */ "./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js");
/* harmony import */ var _getSchemaType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../getSchemaType */ "./node_modules/@rjsf/utils/lib/getSchemaType.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");
/* harmony import */ var _isFixedItems__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../isFixedItems */ "./node_modules/@rjsf/utils/lib/isFixedItems.js");
/* harmony import */ var _mergeDefaultsWithFormData__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../mergeDefaultsWithFormData */ "./node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js");
/* harmony import */ var _mergeObjects__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../mergeObjects */ "./node_modules/@rjsf/utils/lib/mergeObjects.js");
/* harmony import */ var _mergeSchemas__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../mergeSchemas */ "./node_modules/@rjsf/utils/lib/mergeSchemas.js");
/* harmony import */ var _isMultiSelect__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isMultiSelect */ "./node_modules/@rjsf/utils/lib/schema/isMultiSelect.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");














/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.
 */
var AdditionalItemsHandling;
(function (AdditionalItemsHandling) {
    AdditionalItemsHandling[AdditionalItemsHandling["Ignore"] = 0] = "Ignore";
    AdditionalItemsHandling[AdditionalItemsHandling["Invert"] = 1] = "Invert";
    AdditionalItemsHandling[AdditionalItemsHandling["Fallback"] = 2] = "Fallback";
})(AdditionalItemsHandling || (AdditionalItemsHandling = {}));
/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the
 * `additionalItems` enum and the value of `idx`. There are four possible returns:
 * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid
 *    index and not a boolean, otherwise it falls through to 3.
 * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually
 *    is a schema, otherwise it falls through to 3.
 * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then
 *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.
 * 4. {} is returned representing an empty schema
 *
 * @param schema - The schema from which to get the particular item
 * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?
 * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array
 * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers
 */
function getInnerSchemaForArrayItem(schema, additionalItems = AdditionalItemsHandling.Ignore, idx = -1) {
    if (idx >= 0) {
        if (Array.isArray(schema.items) && idx < schema.items.length) {
            const item = schema.items[idx];
            if (typeof item !== 'boolean') {
                return item;
            }
        }
    }
    else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {
        return schema.items;
    }
    if (additionalItems !== AdditionalItemsHandling.Ignore && (0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(schema.additionalItems)) {
        return schema.additionalItems;
    }
    return {};
}
/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of
 * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined
 * `computedDefault` values are added only when `includeUndefinedValues` is either true/"excludeObjectChildren". If `
 * includeUndefinedValues` is false and `emptyObjectFields` is not "skipDefaults", then non-undefined and non-empty-object
 * values will be added based on certain conditions.
 *
 * @param obj - The object into which the computed default may be added
 * @param key - The key into the object at which the computed default may be added
 * @param computedDefault - The computed default value that maybe should be added to the obj
 * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.
 *          If "excludeObjectChildren", cause undefined values for this object and pass `includeUndefinedValues` as
 *          false when computing defaults for any nested object properties. If "allowEmptyObject", prevents undefined
 *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as
 *          false when computing defaults for any nested object properties.
 * @param isParentRequired - The optional boolean that indicates whether the parent field is required
 * @param requiredFields - The list of fields that are required
 * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override
 *        default form state behavior
 */
function maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValues, isParentRequired, requiredFields = [], experimental_defaultFormStateBehavior = {}) {
    const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;
    if (includeUndefinedValues) {
        obj[key] = computedDefault;
    }
    else if (emptyObjectFields !== 'skipDefaults') {
        if ((0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(computedDefault)) {
            // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of
            // the field key itself in the `requiredField` list
            const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;
            // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions
            // Condition 1: If computedDefault is not empty or if the key is a required field
            // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'
            if ((!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(computedDefault) || requiredFields.includes(key)) &&
                (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')) {
                obj[key] = computedDefault;
            }
        }
        else if (
        // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
        // Condition 1: computedDefault is not undefined
        // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field
        computedDefault !== undefined &&
            (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))) {
            obj[key] = computedDefault;
        }
    }
}
/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into
 * each level of the schema, recursively, to fill out every level of defaults provided by the schema.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary
 * @param rawSchema - The schema for which the default state is desired
 * @param [props] - Optional props for this function
 * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema
 * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s
 * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults
 * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
 *          If "excludeObjectChildren", cause undefined values for this object and pass `includeUndefinedValues` as
 *          false when computing defaults for any nested object properties.
 * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion
 * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
 * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.
 * @returns - The resulting `formData` with all the defaults provided
 */
function computeDefaults(validator, rawSchema, { parentDefaults, rawFormData, rootSchema = {}, includeUndefinedValues = false, _recurseList = [], experimental_defaultFormStateBehavior = undefined, required, } = {}) {
    var _a, _b;
    const formData = ((0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(rawFormData) ? rawFormData : {});
    const schema = (0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(rawSchema) ? rawSchema : {};
    // Compute the defaults recursively: give highest priority to deepest nodes.
    let defaults = parentDefaults;
    // If we get a new schema, then we need to recompute defaults again for the new schema found.
    let schemaToCompute = null;
    let updatedRecurseList = _recurseList;
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(defaults) && (0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(schema.default)) {
        // For object defaults, only override parent defaults that are defined in
        // schema.default.
        defaults = (0,_mergeObjects__WEBPACK_IMPORTED_MODULE_10__["default"])(defaults, schema.default);
    }
    else if (_constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_KEY in schema) {
        defaults = schema.default;
    }
    else if (_constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY in schema) {
        const refName = schema[_constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY];
        // Use referenced schema defaults for this node.
        if (!_recurseList.includes(refName)) {
            updatedRecurseList = _recurseList.concat(refName);
            schemaToCompute = (0,_findSchemaDefinition__WEBPACK_IMPORTED_MODULE_3__["default"])(refName, rootSchema);
        }
    }
    else if (_constants__WEBPACK_IMPORTED_MODULE_2__.DEPENDENCIES_KEY in schema) {
        const resolvedSchema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_13__.resolveDependencies)(validator, schema, rootSchema, false, [], formData);
        schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies
    }
    else if ((0,_isFixedItems__WEBPACK_IMPORTED_MODULE_8__["default"])(schema)) {
        defaults = schema.items.map((itemSchema, idx) => computeDefaults(validator, itemSchema, {
            rootSchema,
            includeUndefinedValues,
            _recurseList,
            experimental_defaultFormStateBehavior,
            parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,
            rawFormData: formData,
            required,
        }));
    }
    else if (_constants__WEBPACK_IMPORTED_MODULE_2__.ONE_OF_KEY in schema) {
        const { oneOf, ...remaining } = schema;
        if (oneOf.length === 0) {
            return undefined;
        }
        const discriminator = (0,_getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_5__["default"])(schema);
        schemaToCompute = oneOf[(0,_getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_4__["default"])(validator, rootSchema, lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(formData) ? undefined : formData, oneOf, 0, discriminator)];
        schemaToCompute = (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(remaining, schemaToCompute);
    }
    else if (_constants__WEBPACK_IMPORTED_MODULE_2__.ANY_OF_KEY in schema) {
        const { anyOf, ...remaining } = schema;
        if (anyOf.length === 0) {
            return undefined;
        }
        const discriminator = (0,_getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_5__["default"])(schema);
        schemaToCompute = anyOf[(0,_getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_4__["default"])(validator, rootSchema, lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(formData) ? undefined : formData, anyOf, 0, discriminator)];
        schemaToCompute = (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(remaining, schemaToCompute);
    }
    if (schemaToCompute) {
        return computeDefaults(validator, schemaToCompute, {
            rootSchema,
            includeUndefinedValues,
            _recurseList: updatedRecurseList,
            experimental_defaultFormStateBehavior,
            parentDefaults: defaults,
            rawFormData: formData,
            required,
        });
    }
    // No defaults defined for this node, fallback to generic typed ones.
    if (defaults === undefined) {
        defaults = schema.default;
    }
    switch ((0,_getSchemaType__WEBPACK_IMPORTED_MODULE_6__["default"])(schema)) {
        // We need to recurse for object schema inner default values.
        case 'object': {
            const objectDefaults = Object.keys(schema.properties || {}).reduce((acc, key) => {
                var _a;
                // Compute the defaults for this node, with the parent defaults we might
                // have from a previous run: defaults[key].
                const computedDefault = computeDefaults(validator, lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, [_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, key]), {
                    rootSchema,
                    _recurseList,
                    experimental_defaultFormStateBehavior,
                    includeUndefinedValues: includeUndefinedValues === true,
                    parentDefaults: lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(defaults, [key]),
                    rawFormData: lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [key]),
                    required: (_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(key),
                });
                maybeAddDefaultToObject(acc, key, computedDefault, includeUndefinedValues, required, schema.required, experimental_defaultFormStateBehavior);
                return acc;
            }, {});
            if (schema.additionalProperties) {
                // as per spec additionalProperties may be either schema or boolean
                const additionalPropertiesSchema = (0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(schema.additionalProperties) ? schema.additionalProperties : {};
                const keys = new Set();
                if ((0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(defaults)) {
                    Object.keys(defaults)
                        .filter((key) => !schema.properties || !schema.properties[key])
                        .forEach((key) => keys.add(key));
                }
                const formDataRequired = [];
                Object.keys(formData)
                    .filter((key) => !schema.properties || !schema.properties[key])
                    .forEach((key) => {
                    keys.add(key);
                    formDataRequired.push(key);
                });
                keys.forEach((key) => {
                    var _a;
                    const computedDefault = computeDefaults(validator, additionalPropertiesSchema, {
                        rootSchema,
                        _recurseList,
                        experimental_defaultFormStateBehavior,
                        includeUndefinedValues: includeUndefinedValues === true,
                        parentDefaults: lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(defaults, [key]),
                        rawFormData: lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [key]),
                        required: (_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(key),
                    });
                    // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop
                    maybeAddDefaultToObject(objectDefaults, key, computedDefault, includeUndefinedValues, required, formDataRequired);
                });
            }
            return objectDefaults;
        }
        case 'array': {
            const neverPopulate = ((_a = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _a === void 0 ? void 0 : _a.populate) === 'never';
            const ignoreMinItemsFlagSet = ((_b = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _b === void 0 ? void 0 : _b.populate) === 'requiredOnly';
            // Inject defaults into existing array defaults
            if (Array.isArray(defaults)) {
                defaults = defaults.map((item, idx) => {
                    const schemaItem = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Fallback, idx);
                    return computeDefaults(validator, schemaItem, {
                        rootSchema,
                        _recurseList,
                        experimental_defaultFormStateBehavior,
                        parentDefaults: item,
                        required,
                    });
                });
            }
            // Deeply inject defaults into already existing form data
            if (Array.isArray(rawFormData)) {
                const schemaItem = getInnerSchemaForArrayItem(schema);
                if (neverPopulate) {
                    defaults = rawFormData;
                }
                else {
                    defaults = rawFormData.map((item, idx) => {
                        return computeDefaults(validator, schemaItem, {
                            rootSchema,
                            _recurseList,
                            experimental_defaultFormStateBehavior,
                            rawFormData: item,
                            parentDefaults: lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(defaults, [idx]),
                            required,
                        });
                    });
                }
            }
            if (neverPopulate) {
                return defaults !== null && defaults !== void 0 ? defaults : [];
            }
            if (ignoreMinItemsFlagSet && !required) {
                // If no form data exists or defaults are set leave the field empty/non-existent, otherwise
                // return form data/defaults
                return defaults ? defaults : undefined;
            }
            const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;
            if (!schema.minItems ||
                (0,_isMultiSelect__WEBPACK_IMPORTED_MODULE_12__["default"])(validator, schema, rootSchema) ||
                schema.minItems <= defaultsLength) {
                return defaults ? defaults : [];
            }
            const defaultEntries = (defaults || []);
            const fillerSchema = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Invert);
            const fillerDefault = fillerSchema.default;
            // Calculate filler entries for remaining items (minItems - existing raw data/defaults)
            const fillerEntries = new Array(schema.minItems - defaultsLength).fill(computeDefaults(validator, fillerSchema, {
                parentDefaults: fillerDefault,
                rootSchema,
                _recurseList,
                experimental_defaultFormStateBehavior,
                required,
            }));
            // then fill up the rest with either the item default or empty, up to minItems
            return defaultEntries.concat(fillerEntries);
        }
    }
    return defaults;
}
/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
 * computed to have defaults provided in the `schema`.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param theSchema - The schema for which the default state is desired
 * @param [formData] - The current formData, if any, onto which to provide any missing defaults
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
 *          If "excludeObjectChildren", cause undefined values for this object and pass `includeUndefinedValues` as
 *          false when computing defaults for any nested object properties.
 * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
 * @returns - The resulting `formData` with all the defaults provided
 */
function getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues = false, experimental_defaultFormStateBehavior) {
    if (!(0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(theSchema)) {
        throw new Error('Invalid schema: ' + theSchema);
    }
    const schema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_13__["default"])(validator, theSchema, rootSchema, formData);
    const defaults = computeDefaults(validator, schema, {
        rootSchema,
        includeUndefinedValues,
        experimental_defaultFormStateBehavior,
        rawFormData: formData,
    });
    if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {
        // No form data? Use schema defaults.
        return defaults;
    }
    const { mergeExtraDefaults } = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) || {};
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_7__["default"])(formData)) {
        return (0,_mergeDefaultsWithFormData__WEBPACK_IMPORTED_MODULE_9__["default"])(defaults, formData, mergeExtraDefaults);
    }
    if (Array.isArray(formData)) {
        return (0,_mergeDefaultsWithFormData__WEBPACK_IMPORTED_MODULE_9__["default"])(defaults, formData, mergeExtraDefaults);
    }
    return formData;
}
//# sourceMappingURL=getDefaultFormState.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDisplayLabel)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _getSchemaType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getSchemaType */ "./node_modules/@rjsf/utils/lib/getSchemaType.js");
/* harmony import */ var _getUiOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getUiOptions */ "./node_modules/@rjsf/utils/lib/getUiOptions.js");
/* harmony import */ var _isCustomWidget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../isCustomWidget */ "./node_modules/@rjsf/utils/lib/isCustomWidget.js");
/* harmony import */ var _isFilesArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isFilesArray */ "./node_modules/@rjsf/utils/lib/schema/isFilesArray.js");
/* harmony import */ var _isMultiSelect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isMultiSelect */ "./node_modules/@rjsf/utils/lib/schema/isMultiSelect.js");






/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
 * should be displayed in a UI.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which the display label flag is desired
 * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
 * @returns - True if the label should be displayed or false if it should not
 */
function getDisplayLabel(validator, schema, uiSchema = {}, rootSchema, globalOptions) {
    const uiOptions = (0,_getUiOptions__WEBPACK_IMPORTED_MODULE_2__["default"])(uiSchema, globalOptions);
    const { label = true } = uiOptions;
    let displayLabel = !!label;
    const schemaType = (0,_getSchemaType__WEBPACK_IMPORTED_MODULE_1__["default"])(schema);
    if (schemaType === 'array') {
        displayLabel =
            (0,_isMultiSelect__WEBPACK_IMPORTED_MODULE_5__["default"])(validator, schema, rootSchema) ||
                (0,_isFilesArray__WEBPACK_IMPORTED_MODULE_4__["default"])(validator, schema, uiSchema, rootSchema) ||
                (0,_isCustomWidget__WEBPACK_IMPORTED_MODULE_3__["default"])(uiSchema);
    }
    if (schemaType === 'object') {
        displayLabel = false;
    }
    if (schemaType === 'boolean' && !uiSchema[_constants__WEBPACK_IMPORTED_MODULE_0__.UI_WIDGET_KEY]) {
        displayLabel = false;
    }
    if (uiSchema[_constants__WEBPACK_IMPORTED_MODULE_0__.UI_FIELD_KEY]) {
        displayLabel = false;
    }
    return displayLabel;
}
//# sourceMappingURL=getDisplayLabel.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFirstMatchingOption)
/* harmony export */ });
/* harmony import */ var _getMatchingOption__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getMatchingOption.js");

/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
 * Always returns the first option if there is nothing that matches.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param formData - The current formData, if any, used to figure out a match
 * @param options - The list of options to find a matching options from
 * @param rootSchema - The root schema, used to primarily to look up `$ref`s
 * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
 *          determine which option is selected
 * @returns - The index of the first matched option or 0 if none is available
 */
function getFirstMatchingOption(validator, formData, options, rootSchema, discriminatorField) {
    return (0,_getMatchingOption__WEBPACK_IMPORTED_MODULE_0__["default"])(validator, formData, options, rootSchema, discriminatorField);
}
//# sourceMappingURL=getFirstMatchingOption.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/getMatchingOption.js":
/*!******************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/getMatchingOption.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMatchingOption)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js");
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_has__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _getOptionMatchingSimpleDiscriminator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../getOptionMatchingSimpleDiscriminator */ "./node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js");





/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.
 * Deprecated, use `getFirstMatchingOption()` instead.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param formData - The current formData, if any, used to figure out a match
 * @param options - The list of options to find a matching options from
 * @param rootSchema - The root schema, used to primarily to look up `$ref`s
 * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
 *          determine which option is selected
 * @returns - The index of the matched option or 0 if none is available
 * @deprecated
 */
function getMatchingOption(validator, formData, options, rootSchema, discriminatorField) {
    // For performance, skip validating subschemas if formData is undefined. We just
    // want to get the first option in that case.
    if (formData === undefined) {
        return 0;
    }
    const simpleDiscriminatorMatch = (0,_getOptionMatchingSimpleDiscriminator__WEBPACK_IMPORTED_MODULE_4__["default"])(formData, options, discriminatorField);
    if (lodash_isNumber__WEBPACK_IMPORTED_MODULE_2___default()(simpleDiscriminatorMatch)) {
        return simpleDiscriminatorMatch;
    }
    for (let i = 0; i < options.length; i++) {
        const option = options[i];
        // If we have a discriminator field, then we will use this to make the determination
        if (discriminatorField && lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(option, [_constants__WEBPACK_IMPORTED_MODULE_3__.PROPERTIES_KEY, discriminatorField])) {
            const value = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, discriminatorField);
            const discriminator = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(option, [_constants__WEBPACK_IMPORTED_MODULE_3__.PROPERTIES_KEY, discriminatorField], {});
            if (validator.isValid(discriminator, value, rootSchema)) {
                return i;
            }
        }
        else if (option[_constants__WEBPACK_IMPORTED_MODULE_3__.PROPERTIES_KEY]) {
            // If the schema describes an object then we need to add slightly more
            // strict matching to the schema, because unless the schema uses the
            // "requires" keyword, an object will match the schema as long as it
            // doesn't have matching keys with a conflicting type. To do this we use an
            // "anyOf" with an array of requires. This augmentation expresses that the
            // schema should match if any of the keys in the schema are present on the
            // object and pass validation.
            //
            // Create an "anyOf" schema that requires at least one of the keys in the
            // "properties" object
            const requiresAnyOf = {
                anyOf: Object.keys(option[_constants__WEBPACK_IMPORTED_MODULE_3__.PROPERTIES_KEY]).map((key) => ({
                    required: [key],
                })),
            };
            let augmentedSchema;
            // If the "anyOf" keyword already exists, wrap the augmentation in an "allOf"
            if (option.anyOf) {
                // Create a shallow clone of the option
                const { ...shallowClone } = option;
                if (!shallowClone.allOf) {
                    shallowClone.allOf = [];
                }
                else {
                    // If "allOf" already exists, shallow clone the array
                    shallowClone.allOf = shallowClone.allOf.slice();
                }
                shallowClone.allOf.push(requiresAnyOf);
                augmentedSchema = shallowClone;
            }
            else {
                augmentedSchema = Object.assign({}, option, requiresAnyOf);
            }
            // Remove the "required" field as it's likely that not all fields have
            // been filled in yet, which will mean that the schema is not valid
            delete augmentedSchema.required;
            if (validator.isValid(augmentedSchema, formData, rootSchema)) {
                return i;
            }
        }
        else if (validator.isValid(option, formData, rootSchema)) {
            return i;
        }
    }
    return 0;
}
//# sourceMappingURL=getMatchingOption.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClosestMatchingOption: () => (/* reexport safe */ _getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   getDefaultFormState: () => (/* reexport safe */ _getDefaultFormState__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   getDisplayLabel: () => (/* reexport safe */ _getDisplayLabel__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getFirstMatchingOption: () => (/* reexport safe */ _getFirstMatchingOption__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   getMatchingOption: () => (/* reexport safe */ _getMatchingOption__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   isFilesArray: () => (/* reexport safe */ _isFilesArray__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   isMultiSelect: () => (/* reexport safe */ _isMultiSelect__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   isSelect: () => (/* reexport safe */ _isSelect__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   mergeValidationData: () => (/* reexport safe */ _mergeValidationData__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   retrieveSchema: () => (/* reexport safe */ _retrieveSchema__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   sanitizeDataForNewSchema: () => (/* reexport safe */ _sanitizeDataForNewSchema__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   toIdSchema: () => (/* reexport safe */ _toIdSchema__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   toPathSchema: () => (/* reexport safe */ _toPathSchema__WEBPACK_IMPORTED_MODULE_12__["default"])
/* harmony export */ });
/* harmony import */ var _getDefaultFormState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDefaultFormState */ "./node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js");
/* harmony import */ var _getDisplayLabel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDisplayLabel */ "./node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js");
/* harmony import */ var _getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getClosestMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js");
/* harmony import */ var _getFirstMatchingOption__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getFirstMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js");
/* harmony import */ var _getMatchingOption__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getMatchingOption.js");
/* harmony import */ var _isFilesArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isFilesArray */ "./node_modules/@rjsf/utils/lib/schema/isFilesArray.js");
/* harmony import */ var _isMultiSelect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isMultiSelect */ "./node_modules/@rjsf/utils/lib/schema/isMultiSelect.js");
/* harmony import */ var _isSelect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isSelect */ "./node_modules/@rjsf/utils/lib/schema/isSelect.js");
/* harmony import */ var _mergeValidationData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mergeValidationData */ "./node_modules/@rjsf/utils/lib/schema/mergeValidationData.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");
/* harmony import */ var _sanitizeDataForNewSchema__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sanitizeDataForNewSchema */ "./node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js");
/* harmony import */ var _toIdSchema__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./toIdSchema */ "./node_modules/@rjsf/utils/lib/schema/toIdSchema.js");
/* harmony import */ var _toPathSchema__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./toPathSchema */ "./node_modules/@rjsf/utils/lib/schema/toPathSchema.js");














//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/isFilesArray.js":
/*!*************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/isFilesArray.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isFilesArray)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");


/** Checks to see if the `schema` and `uiSchema` combination represents an array of files
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which check for array of files flag is desired
 * @param [uiSchema={}] - The UI schema from which to check the widget
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @returns - True if schema/uiSchema contains an array of files, otherwise false
 */
function isFilesArray(validator, schema, uiSchema = {}, rootSchema) {
    if (uiSchema[_constants__WEBPACK_IMPORTED_MODULE_0__.UI_WIDGET_KEY] === 'files') {
        return true;
    }
    if (schema.items) {
        const itemsSchema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_1__["default"])(validator, schema.items, rootSchema);
        return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';
    }
    return false;
}
//# sourceMappingURL=isFilesArray.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/isMultiSelect.js":
/*!**************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/isMultiSelect.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isMultiSelect)
/* harmony export */ });
/* harmony import */ var _isSelect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSelect */ "./node_modules/@rjsf/utils/lib/schema/isSelect.js");

/** Checks to see if the `schema` combination represents a multi-select
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which check for a multi-select flag is desired
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @returns - True if schema contains a multi-select, otherwise false
 */
function isMultiSelect(validator, schema, rootSchema) {
    if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {
        return false;
    }
    return (0,_isSelect__WEBPACK_IMPORTED_MODULE_0__["default"])(validator, schema.items, rootSchema);
}
//# sourceMappingURL=isMultiSelect.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/isSelect.js":
/*!*********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/isSelect.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isSelect)
/* harmony export */ });
/* harmony import */ var _isConstant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../isConstant */ "./node_modules/@rjsf/utils/lib/isConstant.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");


/** Checks to see if the `schema` combination represents a select
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param theSchema - The schema for which check for a select flag is desired
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @returns - True if schema contains a select, otherwise false
 */
function isSelect(validator, theSchema, rootSchema = {}) {
    const schema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_1__["default"])(validator, theSchema, rootSchema, undefined);
    const altSchemas = schema.oneOf || schema.anyOf;
    if (Array.isArray(schema.enum)) {
        return true;
    }
    if (Array.isArray(altSchemas)) {
        return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && (0,_isConstant__WEBPACK_IMPORTED_MODULE_0__["default"])(altSchemas));
    }
    return false;
}
//# sourceMappingURL=isSelect.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/mergeValidationData.js":
/*!********************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/mergeValidationData.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeValidationData)
/* harmony export */ });
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mergeObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mergeObjects */ "./node_modules/@rjsf/utils/lib/mergeObjects.js");


/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the
 * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling
 * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then
 * `validationData` is returned.
 *
 * @param validator - The validator used to convert an ErrorSchema to a list of errors
 * @param validationData - The current `ValidationData` into which to merge the additional errors
 * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`
 * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.
 * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be
 *        removed in the next major release.
 */
function mergeValidationData(validator, validationData, additionalErrorSchema) {
    if (!additionalErrorSchema) {
        return validationData;
    }
    const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;
    let errors = validator.toErrorList(additionalErrorSchema);
    let errorSchema = additionalErrorSchema;
    if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(oldErrorSchema)) {
        errorSchema = (0,_mergeObjects__WEBPACK_IMPORTED_MODULE_1__["default"])(oldErrorSchema, additionalErrorSchema, true);
        errors = [...oldErrors].concat(errors);
    }
    return { errorSchema, errors };
}
//# sourceMappingURL=mergeValidationData.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js":
/*!***************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ retrieveSchema),
/* harmony export */   getAllPermutationsOfXxxOf: () => (/* binding */ getAllPermutationsOfXxxOf),
/* harmony export */   processDependencies: () => (/* binding */ processDependencies),
/* harmony export */   resolveAllReferences: () => (/* binding */ resolveAllReferences),
/* harmony export */   resolveAnyOrOneOfSchemas: () => (/* binding */ resolveAnyOrOneOfSchemas),
/* harmony export */   resolveCondition: () => (/* binding */ resolveCondition),
/* harmony export */   resolveDependencies: () => (/* binding */ resolveDependencies),
/* harmony export */   resolveReference: () => (/* binding */ resolveReference),
/* harmony export */   resolveSchema: () => (/* binding */ resolveSchema),
/* harmony export */   retrieveSchemaInternal: () => (/* binding */ retrieveSchemaInternal),
/* harmony export */   stubExistingAdditionalProperties: () => (/* binding */ stubExistingAdditionalProperties),
/* harmony export */   withDependentProperties: () => (/* binding */ withDependentProperties),
/* harmony export */   withDependentSchema: () => (/* binding */ withDependentSchema),
/* harmony export */   withExactlyOneSubschema: () => (/* binding */ withExactlyOneSubschema)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/set */ "./node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/times */ "./node_modules/lodash/times.js");
/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_times__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js");
/* harmony import */ var lodash_transform__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_transform__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var json_schema_merge_allof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! json-schema-merge-allof */ "./node_modules/json-schema-merge-allof/src/index.js");
/* harmony import */ var json_schema_merge_allof__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(json_schema_merge_allof__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _findSchemaDefinition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../findSchemaDefinition */ "./node_modules/@rjsf/utils/lib/findSchemaDefinition.js");
/* harmony import */ var _getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../getDiscriminatorFieldFromSchema */ "./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js");
/* harmony import */ var _guessType__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../guessType */ "./node_modules/@rjsf/utils/lib/guessType.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");
/* harmony import */ var _mergeSchemas__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../mergeSchemas */ "./node_modules/@rjsf/utils/lib/mergeSchemas.js");
/* harmony import */ var _getFirstMatchingOption__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getFirstMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js");













/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies
 * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the
 * potentially recursive resolution.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which retrieving a schema is desired
 * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs
 * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
 * @returns - The schema having its conditions, additional properties, references and dependencies resolved
 */
function retrieveSchema(validator, schema, rootSchema = {}, rawFormData) {
    return retrieveSchemaInternal(validator, schema, rootSchema, rawFormData)[0];
}
/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch
 * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both
 * conditions will be returned.
 *
 * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions
 * @param schema - The schema for which resolving a condition is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and
 *          dependencies as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData] - The current formData to assist retrieving a schema
 * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded
 */
function resolveCondition(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {
    const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;
    const conditionValue = validator.isValid(expression, formData || {}, rootSchema);
    let resolvedSchemas = [resolvedSchemaLessConditional];
    let schemas = [];
    if (expandAllBranches) {
        if (then && typeof then !== 'boolean') {
            schemas = schemas.concat(retrieveSchemaInternal(validator, then, rootSchema, formData, expandAllBranches, recurseList));
        }
        if (otherwise && typeof otherwise !== 'boolean') {
            schemas = schemas.concat(retrieveSchemaInternal(validator, otherwise, rootSchema, formData, expandAllBranches, recurseList));
        }
    }
    else {
        const conditionalSchema = conditionValue ? then : otherwise;
        if (conditionalSchema && typeof conditionalSchema !== 'boolean') {
            schemas = schemas.concat(retrieveSchemaInternal(validator, conditionalSchema, rootSchema, formData, expandAllBranches, recurseList));
        }
    }
    if (schemas.length) {
        resolvedSchemas = schemas.map((s) => (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(resolvedSchemaLessConditional, s));
    }
    return resolvedSchemas.flatMap((s) => retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList));
}
/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The
 * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.
 * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.
 *
 * For example:
 * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three
 *   C schemas then:
 *   - The permutation for the first row is `[[A]]`
 *   - The permutations for the second row are `[[A,B1], [A,B2]]`
 *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`
 *
 * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order
 * @returns - The list of all permutations of schemas for a set of `xxxOf`s
 */
function getAllPermutationsOfXxxOf(listOfLists) {
    const allPermutations = listOfLists.reduce((permutations, list) => {
        // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values
        if (list.length > 1) {
            return list.flatMap((element) => lodash_times__WEBPACK_IMPORTED_MODULE_3___default()(permutations.length, (i) => [...permutations[i]].concat(element)));
        }
        // Otherwise just push in the single value into the current set of permutations
        permutations.forEach((permutation) => permutation.push(list[0]));
        return permutations;
    }, [[]] // Start with an empty list
    );
    return allPermutations;
}
/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag
 * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If
 * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which resolving a schema is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @returns - The list of schemas having its references, dependencies and allOf schemas resolved
 */
function resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {
    const updatedSchemas = resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData);
    if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {
        // return the updatedSchemas array if it has either multiple schemas within it
        // OR the first schema is not the same as the original schema
        return updatedSchemas;
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_6__.DEPENDENCIES_KEY in schema) {
        const resolvedSchemas = resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData);
        return resolvedSchemas.flatMap((s) => {
            return retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList);
        });
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_6__.ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {
        const allOfSchemaElements = schema.allOf.map((allOfSubschema) => retrieveSchemaInternal(validator, allOfSubschema, rootSchema, formData, expandAllBranches, recurseList));
        const allPermutations = getAllPermutationsOfXxxOf(allOfSchemaElements);
        return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));
    }
    // No $ref or dependencies or allOf attribute was found, returning the original schema.
    return [schema];
}
/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is
 * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`
 * helper call.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which resolving a reference is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @returns - The list schemas retrieved after having all references resolved
 */
function resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {
    const updatedSchema = resolveAllReferences(schema, rootSchema, recurseList);
    if (updatedSchema !== schema) {
        // Only call this if the schema was actually changed by the `resolveAllReferences()` function
        return retrieveSchemaInternal(validator, updatedSchema, rootSchema, formData, expandAllBranches, recurseList);
    }
    return [schema];
}
/** Resolves all references within the schema itself as well as any of its properties and array items.
 *
 * @param schema - The schema for which resolving all references is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param recurseList - List of $refs already resolved to prevent recursion
 * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved
 */
function resolveAllReferences(schema, rootSchema, recurseList) {
    if (!(0,_isObject__WEBPACK_IMPORTED_MODULE_10__["default"])(schema)) {
        return schema;
    }
    let resolvedSchema = schema;
    // resolve top level ref
    if (_constants__WEBPACK_IMPORTED_MODULE_6__.REF_KEY in resolvedSchema) {
        const { $ref, ...localSchema } = resolvedSchema;
        // Check for a recursive reference and stop the loop
        if (recurseList.includes($ref)) {
            return resolvedSchema;
        }
        recurseList.push($ref);
        // Retrieve the referenced schema definition.
        const refSchema = (0,_findSchemaDefinition__WEBPACK_IMPORTED_MODULE_7__["default"])($ref, rootSchema);
        resolvedSchema = { ...refSchema, ...localSchema };
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_6__.PROPERTIES_KEY in resolvedSchema) {
        const updatedProps = lodash_transform__WEBPACK_IMPORTED_MODULE_4___default()(resolvedSchema[_constants__WEBPACK_IMPORTED_MODULE_6__.PROPERTIES_KEY], (result, value, key) => {
            result[key] = resolveAllReferences(value, rootSchema, recurseList);
        }, {});
        resolvedSchema = { ...resolvedSchema, [_constants__WEBPACK_IMPORTED_MODULE_6__.PROPERTIES_KEY]: updatedProps };
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_6__.ITEMS_KEY in resolvedSchema &&
        !Array.isArray(resolvedSchema.items) &&
        typeof resolvedSchema.items !== 'boolean') {
        resolvedSchema = {
            ...resolvedSchema,
            items: resolveAllReferences(resolvedSchema.items, rootSchema, recurseList),
        };
    }
    return lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(schema, resolvedSchema) ? schema : resolvedSchema;
}
/** Creates new 'properties' items for each key in the `formData`
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param theSchema - The schema for which the existing additional properties is desired
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator
 * @param [aFormData] - The current formData, if any, to assist retrieving a schema
 * @returns - The updated schema with additional properties stubbed
 */
function stubExistingAdditionalProperties(validator, theSchema, rootSchema, aFormData) {
    // Clone the schema so that we don't ruin the consumer's original
    const schema = {
        ...theSchema,
        properties: { ...theSchema.properties },
    };
    // make sure formData is an object
    const formData = aFormData && (0,_isObject__WEBPACK_IMPORTED_MODULE_10__["default"])(aFormData) ? aFormData : {};
    Object.keys(formData).forEach((key) => {
        if (key in schema.properties) {
            // No need to stub, our schema already has the property
            return;
        }
        let additionalProperties = {};
        if (typeof schema.additionalProperties !== 'boolean') {
            if (_constants__WEBPACK_IMPORTED_MODULE_6__.REF_KEY in schema.additionalProperties) {
                additionalProperties = retrieveSchema(validator, { $ref: lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema.additionalProperties, [_constants__WEBPACK_IMPORTED_MODULE_6__.REF_KEY]) }, rootSchema, formData);
            }
            else if ('type' in schema.additionalProperties) {
                additionalProperties = { ...schema.additionalProperties };
            }
            else if (_constants__WEBPACK_IMPORTED_MODULE_6__.ANY_OF_KEY in schema.additionalProperties || _constants__WEBPACK_IMPORTED_MODULE_6__.ONE_OF_KEY in schema.additionalProperties) {
                additionalProperties = {
                    type: 'object',
                    ...schema.additionalProperties,
                };
            }
            else {
                additionalProperties = { type: (0,_guessType__WEBPACK_IMPORTED_MODULE_9__["default"])(lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [key])) };
            }
        }
        else {
            additionalProperties = { type: (0,_guessType__WEBPACK_IMPORTED_MODULE_9__["default"])(lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [key])) };
        }
        // The type of our new key should match the additionalProperties value;
        schema.properties[key] = additionalProperties;
        // Set our additional property flag so we know it was dynamically added
        lodash_set__WEBPACK_IMPORTED_MODULE_2___default()(schema.properties, [key, _constants__WEBPACK_IMPORTED_MODULE_6__.ADDITIONAL_PROPERTY_FLAG], true);
    });
    return schema;
}
/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,
 * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`
 * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches
 * of the schema and its references, conditions and dependencies are returned.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which retrieving a schema is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
 * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and
 *          dependencies as a list of schemas
 * @param [recurseList=[]] - The optional, list of recursive references already processed
 * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies
 *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.
 */
function retrieveSchemaInternal(validator, schema, rootSchema, rawFormData, expandAllBranches = false, recurseList = []) {
    if (!(0,_isObject__WEBPACK_IMPORTED_MODULE_10__["default"])(schema)) {
        return [{}];
    }
    const resolvedSchemas = resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, rawFormData);
    return resolvedSchemas.flatMap((s) => {
        let resolvedSchema = s;
        if (_constants__WEBPACK_IMPORTED_MODULE_6__.IF_KEY in resolvedSchema) {
            return resolveCondition(validator, resolvedSchema, rootSchema, expandAllBranches, recurseList, rawFormData);
        }
        if (_constants__WEBPACK_IMPORTED_MODULE_6__.ALL_OF_KEY in resolvedSchema) {
            // resolve allOf schemas
            if (expandAllBranches) {
                const { allOf, ...restOfSchema } = resolvedSchema;
                return [...allOf, restOfSchema];
            }
            try {
                resolvedSchema = json_schema_merge_allof__WEBPACK_IMPORTED_MODULE_5___default()(resolvedSchema, {
                    deep: false,
                });
            }
            catch (e) {
                console.warn('could not merge subschemas in allOf:\n', e);
                const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;
                return resolvedSchemaWithoutAllOf;
            }
        }
        const hasAdditionalProperties = _constants__WEBPACK_IMPORTED_MODULE_6__.ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;
        if (hasAdditionalProperties) {
            return stubExistingAdditionalProperties(validator, resolvedSchema, rootSchema, rawFormData);
        }
        return resolvedSchema;
    });
}
/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from
 * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL
 * options are retrieved and returned.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which retrieving a schema is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object
 * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true
 */
function resolveAnyOrOneOfSchemas(validator, schema, rootSchema, expandAllBranches, rawFormData) {
    let anyOrOneOf;
    const { oneOf, anyOf, ...remaining } = schema;
    if (Array.isArray(oneOf)) {
        anyOrOneOf = oneOf;
    }
    else if (Array.isArray(anyOf)) {
        anyOrOneOf = anyOf;
    }
    if (anyOrOneOf) {
        // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated
        const formData = rawFormData === undefined && expandAllBranches ? {} : rawFormData;
        const discriminator = (0,_getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_8__["default"])(schema);
        anyOrOneOf = anyOrOneOf.map((s) => {
            // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option
            // can resolve recursive references independently
            return resolveAllReferences(s, rootSchema, []);
        });
        // Call this to trigger the set of isValid() calls that the schema parser will need
        const option = (0,_getFirstMatchingOption__WEBPACK_IMPORTED_MODULE_12__["default"])(validator, formData, anyOrOneOf, rootSchema, discriminator);
        if (expandAllBranches) {
            return anyOrOneOf.map((item) => (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(remaining, item));
        }
        schema = (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(remaining, anyOrOneOf[option]);
    }
    return [schema];
}
/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to
 * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which resolving a dependency is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @returns - The list of schemas with their dependencies resolved
 */
function resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {
    // Drop the dependencies from the source schema.
    const { dependencies, ...remainingSchema } = schema;
    const resolvedSchemas = resolveAnyOrOneOfSchemas(validator, remainingSchema, rootSchema, expandAllBranches, formData);
    return resolvedSchemas.flatMap((resolvedSchema) => processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData));
}
/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the
 * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param dependencies - The set of dependencies that needs to be processed
 * @param resolvedSchema - The schema for which processing dependencies is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @returns - The schema with the `dependencies` resolved into it
 */
function processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData) {
    let schemas = [resolvedSchema];
    // Process dependencies updating the local schema properties as appropriate.
    for (const dependencyKey in dependencies) {
        // Skip this dependency if its trigger property is not present.
        if (!expandAllBranches && lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [dependencyKey]) === undefined) {
            continue;
        }
        // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)
        if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
            continue;
        }
        const [remainingDependencies, dependencyValue] = (0,_findSchemaDefinition__WEBPACK_IMPORTED_MODULE_7__.splitKeyElementFromObject)(dependencyKey, dependencies);
        if (Array.isArray(dependencyValue)) {
            schemas[0] = withDependentProperties(resolvedSchema, dependencyValue);
        }
        else if ((0,_isObject__WEBPACK_IMPORTED_MODULE_10__["default"])(dependencyValue)) {
            schemas = withDependentSchema(validator, resolvedSchema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData);
        }
        return schemas.flatMap((schema) => processDependencies(validator, remainingDependencies, schema, rootSchema, expandAllBranches, recurseList, formData));
    }
    return schemas;
}
/** Updates a schema with additionally required properties added
 *
 * @param schema - The schema for which resolving a dependent properties is desired
 * @param [additionallyRequired] - An optional array of additionally required names
 * @returns - The schema with the additional required values merged in
 */
function withDependentProperties(schema, additionallyRequired) {
    if (!additionallyRequired) {
        return schema;
    }
    const required = Array.isArray(schema.required)
        ? Array.from(new Set([...schema.required, ...additionallyRequired]))
        : additionallyRequired;
    return { ...schema, required: required };
}
/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag
 * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
 * @param schema - The schema for which resolving a dependent schema is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param dependencyKey - The key name of the dependency
 * @param dependencyValue - The potentially dependent schema
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData]- The current formData to assist retrieving a schema
 * @returns - The list of schemas with the dependent schema resolved into them
 */
function withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData) {
    const dependentSchemas = retrieveSchemaInternal(validator, dependencyValue, rootSchema, formData, expandAllBranches, recurseList);
    return dependentSchemas.flatMap((dependent) => {
        const { oneOf, ...dependentSchema } = dependent;
        schema = (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(schema, dependentSchema);
        // Since it does not contain oneOf, we return the original schema.
        if (oneOf === undefined) {
            return schema;
        }
        // Resolve $refs inside oneOf.
        const resolvedOneOfs = oneOf.map((subschema) => {
            if (typeof subschema === 'boolean' || !(_constants__WEBPACK_IMPORTED_MODULE_6__.REF_KEY in subschema)) {
                return [subschema];
            }
            return resolveReference(validator, subschema, rootSchema, expandAllBranches, recurseList, formData);
        });
        const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);
        return allPermutations.flatMap((resolvedOneOf) => withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, resolvedOneOf, expandAllBranches, recurseList, formData));
    });
}
/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is
 * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to
 * the `retrieveSchemaInternal()` helper call.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options
 * @param schema - The schema for which resolving a oneOf subschema is desired
 * @param rootSchema - The root schema that will be forwarded to all the APIs
 * @param dependencyKey - The key name of the oneOf dependency
 * @param oneOf - The list of schemas representing the oneOf options
 * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies
 *          as a list of schemas
 * @param recurseList - The list of recursive references already processed
 * @param [formData] - The current formData to assist retrieving a schema
 * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true
 */
function withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, oneOf, expandAllBranches, recurseList, formData) {
    const validSubschemas = oneOf.filter((subschema) => {
        if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {
            return false;
        }
        const { [dependencyKey]: conditionPropertySchema } = subschema.properties;
        if (conditionPropertySchema) {
            const conditionSchema = {
                type: 'object',
                properties: {
                    [dependencyKey]: conditionPropertySchema,
                },
            };
            return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;
        }
        return false;
    });
    if (!expandAllBranches && validSubschemas.length !== 1) {
        console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
        return [schema];
    }
    return validSubschemas.flatMap((s) => {
        const subschema = s;
        const [dependentSubschema] = (0,_findSchemaDefinition__WEBPACK_IMPORTED_MODULE_7__.splitKeyElementFromObject)(dependencyKey, subschema.properties);
        const dependentSchema = { ...subschema, properties: dependentSubschema };
        const schemas = retrieveSchemaInternal(validator, dependentSchema, rootSchema, formData, expandAllBranches, recurseList);
        return schemas.map((s) => (0,_mergeSchemas__WEBPACK_IMPORTED_MODULE_11__["default"])(schema, s));
    });
}
//# sourceMappingURL=retrieveSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sanitizeDataForNewSchema)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js");
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_has__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");




const NO_VALUE = Symbol('no Value');
/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new
 * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature
 * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema
 * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:
 *
 * - If the new schema is an object that contains a `properties` object then:
 *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined
 *   - Create an empty `nestedData` object for use in the key filtering below:
 *   - Iterate over each key in the `newSchema.properties` as follows:
 *     - Get the `formValue` of the key from the `data`
 *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist
 *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`
 *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:
 *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property
 *       - If type of the key in the new schema is `object`:
 *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`
 *       - Otherwise, check for default or const values:
 *         - Get the old and new `default` values from the schema and check:
 *           - If the new `default` value does not match the form value:
 *             - If the old `default` value DOES match the form value, then:
 *               - Replace `removeOldSchemaData[key]` with the new `default`
 *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined
 *         - Get the old and new `const` values from the schema and check:
 *           - If the new `const` value does not match the form value:
 *           - If the old `const` value DOES match the form value, then:
 *             - Replace `removeOldSchemaData[key]` with the new `const`
 *             - Otherwise, replace `removeOldSchemaData[key]` with undefined
 *   - Once all keys have been processed, return an object built as follows:
 *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`
 * - If the new and old schema types are array and the `data` is an array then:
 *   - If the type of the old and new schema `items` are a non-array objects:
 *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`
 *     - If the `type`s of both items are the same (or the old does not have a type):
 *       - If the type is "object", then:
 *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified
 *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set
 *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is
 * - Otherwise return `undefined`
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param rootSchema - The root JSON schema of the entire form
 * @param [newSchema] - The new schema for which the data is being sanitized
 * @param [oldSchema] - The old schema from which the data originated
 * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
 * @returns - The new form data, with all the fields uniquely associated with the old schema set
 *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
 */
function sanitizeDataForNewSchema(validator, rootSchema, newSchema, oldSchema, data = {}) {
    // By default, we will clear the form data
    let newFormData;
    // If the new schema is of type object and that object contains a list of properties
    if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(newSchema, _constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY)) {
        // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data
        const removeOldSchemaData = {};
        if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(oldSchema, _constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY)) {
            const properties = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldSchema, _constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, {});
            Object.keys(properties).forEach((key) => {
                if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(data, key)) {
                    removeOldSchemaData[key] = undefined;
                }
            });
        }
        const keys = Object.keys(lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newSchema, _constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, {}));
        // Create a place to store nested data that will be a side-effect of the filter
        const nestedData = {};
        keys.forEach((key) => {
            const formValue = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(data, key);
            let oldKeyedSchema = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldSchema, [_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, key], {});
            let newKeyedSchema = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newSchema, [_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, key], {});
            // Resolve the refs if they exist
            if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(oldKeyedSchema, _constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY)) {
                oldKeyedSchema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_3__["default"])(validator, oldKeyedSchema, rootSchema, formValue);
            }
            if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(newKeyedSchema, _constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY)) {
                newKeyedSchema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_3__["default"])(validator, newKeyedSchema, rootSchema, formValue);
            }
            // Now get types and see if they are the same
            const oldSchemaTypeForKey = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldKeyedSchema, 'type');
            const newSchemaTypeForKey = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newKeyedSchema, 'type');
            // Check if the old option has the same key with the same type
            if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {
                if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(removeOldSchemaData, key)) {
                    // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas
                    delete removeOldSchemaData[key];
                }
                // If it is an object, we'll recurse and store the resulting sanitized data for the key
                if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {
                    // SIDE-EFFECT: process the new schema type of object recursively to save iterations
                    const itemData = sanitizeDataForNewSchema(validator, rootSchema, newKeyedSchema, oldKeyedSchema, formValue);
                    if (itemData !== undefined || newSchemaTypeForKey === 'array') {
                        // only put undefined values for the array type and not the object type
                        nestedData[key] = itemData;
                    }
                }
                else {
                    // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced
                    // with the new default or const. This allows the case where two schemas differ that only by the default/const
                    // value to be properly selected
                    const newOptionDefault = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newKeyedSchema, 'default', NO_VALUE);
                    const oldOptionDefault = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldKeyedSchema, 'default', NO_VALUE);
                    if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {
                        if (oldOptionDefault === formValue) {
                            // If the old default matches the formValue, we'll update the new value to match the new default
                            removeOldSchemaData[key] = newOptionDefault;
                        }
                        else if (lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newKeyedSchema, 'readOnly') === true) {
                            // If the new schema has the default set to read-only, treat it like a const and remove the value
                            removeOldSchemaData[key] = undefined;
                        }
                    }
                    const newOptionConst = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newKeyedSchema, 'const', NO_VALUE);
                    const oldOptionConst = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldKeyedSchema, 'const', NO_VALUE);
                    if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {
                        // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it
                        removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;
                    }
                }
            }
        });
        newFormData = {
            ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),
            ...removeOldSchemaData,
            ...nestedData,
        };
        // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep
    }
    else if (lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldSchema, 'type') === 'array' && lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newSchema, 'type') === 'array' && Array.isArray(data)) {
        let oldSchemaItems = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldSchema, 'items');
        let newSchemaItems = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newSchema, 'items');
        // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data
        // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations
        if (typeof oldSchemaItems === 'object' &&
            typeof newSchemaItems === 'object' &&
            !Array.isArray(oldSchemaItems) &&
            !Array.isArray(newSchemaItems)) {
            if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(oldSchemaItems, _constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY)) {
                oldSchemaItems = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_3__["default"])(validator, oldSchemaItems, rootSchema, data);
            }
            if (lodash_has__WEBPACK_IMPORTED_MODULE_1___default()(newSchemaItems, _constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY)) {
                newSchemaItems = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_3__["default"])(validator, newSchemaItems, rootSchema, data);
            }
            // Now get types and see if they are the same
            const oldSchemaType = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(oldSchemaItems, 'type');
            const newSchemaType = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newSchemaItems, 'type');
            // Check if the old option has the same key with the same type
            if (!oldSchemaType || oldSchemaType === newSchemaType) {
                const maxItems = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(newSchema, 'maxItems', -1);
                if (newSchemaType === 'object') {
                    newFormData = data.reduce((newValue, aValue) => {
                        const itemValue = sanitizeDataForNewSchema(validator, rootSchema, newSchemaItems, oldSchemaItems, aValue);
                        if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {
                            newValue.push(itemValue);
                        }
                        return newValue;
                    }, []);
                }
                else {
                    newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;
                }
            }
        }
        else if (typeof oldSchemaItems === 'boolean' &&
            typeof newSchemaItems === 'boolean' &&
            oldSchemaItems === newSchemaItems) {
            // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined
            newFormData = data;
        }
        // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft
    }
    return newFormData;
}
//# sourceMappingURL=sanitizeDataForNewSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/toIdSchema.js":
/*!***********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/toIdSchema.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toIdSchema)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../isObject */ "./node_modules/@rjsf/utils/lib/isObject.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");
/* harmony import */ var _getSchemaType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../getSchemaType */ "./node_modules/@rjsf/utils/lib/getSchemaType.js");






/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against
 * infinite recursion
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which the `IdSchema` is desired
 * @param idPrefix - The prefix to use for the id
 * @param idSeparator - The separator to use for the path segments in the id
 * @param [id] - The base id for the schema
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion
 * @returns - The `IdSchema` object for the `schema`
 */
function toIdSchemaInternal(validator, schema, idPrefix, idSeparator, id, rootSchema, formData, _recurseList = []) {
    if (_constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY in schema || _constants__WEBPACK_IMPORTED_MODULE_2__.DEPENDENCIES_KEY in schema || _constants__WEBPACK_IMPORTED_MODULE_2__.ALL_OF_KEY in schema) {
        const _schema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_4__["default"])(validator, schema, rootSchema, formData);
        const sameSchemaIndex = _recurseList.findIndex((item) => lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(item, _schema));
        if (sameSchemaIndex === -1) {
            return toIdSchemaInternal(validator, _schema, idPrefix, idSeparator, id, rootSchema, formData, _recurseList.concat(_schema));
        }
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY in schema && !lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, [_constants__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY, _constants__WEBPACK_IMPORTED_MODULE_2__.REF_KEY])) {
        return toIdSchemaInternal(validator, lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, _constants__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY), idPrefix, idSeparator, id, rootSchema, formData, _recurseList);
    }
    const $id = id || idPrefix;
    const idSchema = { $id };
    if ((0,_getSchemaType__WEBPACK_IMPORTED_MODULE_5__["default"])(schema) === 'object' && _constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY in schema) {
        for (const name in schema.properties) {
            const field = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, [_constants__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, name]);
            const fieldId = idSchema[_constants__WEBPACK_IMPORTED_MODULE_2__.ID_KEY] + idSeparator + name;
            idSchema[name] = toIdSchemaInternal(validator, (0,_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(field) ? field : {}, idPrefix, idSeparator, fieldId, rootSchema, 
            // It's possible that formData is not an object -- this can happen if an
            // array item has just been added, but not populated with data yet
            lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [name]), _recurseList);
        }
    }
    return idSchema;
}
/** Generates an `IdSchema` object for the `schema`, recursively
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which the `IdSchema` is desired
 * @param [id] - The base id for the schema
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @param [idPrefix='root'] - The prefix to use for the id
 * @param [idSeparator='_'] - The separator to use for the path segments in the id
 * @returns - The `IdSchema` object for the `schema`
 */
function toIdSchema(validator, schema, id, rootSchema, formData, idPrefix = 'root', idSeparator = '_') {
    return toIdSchemaInternal(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);
}
//# sourceMappingURL=toIdSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/schema/toPathSchema.js":
/*!*************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/schema/toPathSchema.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPathSchema)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/set */ "./node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var _getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../getDiscriminatorFieldFromSchema */ "./node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js");
/* harmony import */ var _getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getClosestMatchingOption */ "./node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js");
/* harmony import */ var _retrieveSchema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./retrieveSchema */ "./node_modules/@rjsf/utils/lib/schema/retrieveSchema.js");







/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against
 * infinite recursion
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which the `PathSchema` is desired
 * @param [name=''] - The base name for the schema
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion
 * @returns - The `PathSchema` object for the `schema`
 */
function toPathSchemaInternal(validator, schema, name, rootSchema, formData, _recurseList = []) {
    if (_constants__WEBPACK_IMPORTED_MODULE_3__.REF_KEY in schema || _constants__WEBPACK_IMPORTED_MODULE_3__.DEPENDENCIES_KEY in schema || _constants__WEBPACK_IMPORTED_MODULE_3__.ALL_OF_KEY in schema) {
        const _schema = (0,_retrieveSchema__WEBPACK_IMPORTED_MODULE_6__["default"])(validator, schema, rootSchema, formData);
        const sameSchemaIndex = _recurseList.findIndex((item) => lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(item, _schema));
        if (sameSchemaIndex === -1) {
            return toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList.concat(_schema));
        }
    }
    let pathSchema = {
        [_constants__WEBPACK_IMPORTED_MODULE_3__.NAME_KEY]: name.replace(/^\./, ''),
    };
    if (_constants__WEBPACK_IMPORTED_MODULE_3__.ONE_OF_KEY in schema || _constants__WEBPACK_IMPORTED_MODULE_3__.ANY_OF_KEY in schema) {
        const xxxOf = _constants__WEBPACK_IMPORTED_MODULE_3__.ONE_OF_KEY in schema ? schema.oneOf : schema.anyOf;
        const discriminator = (0,_getDiscriminatorFieldFromSchema__WEBPACK_IMPORTED_MODULE_4__["default"])(schema);
        const index = (0,_getClosestMatchingOption__WEBPACK_IMPORTED_MODULE_5__["default"])(validator, rootSchema, formData, xxxOf, 0, discriminator);
        const _schema = xxxOf[index];
        pathSchema = {
            ...pathSchema,
            ...toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList),
        };
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_3__.ADDITIONAL_PROPERTIES_KEY in schema && schema[_constants__WEBPACK_IMPORTED_MODULE_3__.ADDITIONAL_PROPERTIES_KEY] !== false) {
        lodash_set__WEBPACK_IMPORTED_MODULE_2___default()(pathSchema, _constants__WEBPACK_IMPORTED_MODULE_3__.RJSF_ADDITONAL_PROPERTIES_FLAG, true);
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_3__.ITEMS_KEY in schema && Array.isArray(formData)) {
        const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;
        if (Array.isArray(schemaItems)) {
            formData.forEach((element, i) => {
                if (schemaItems[i]) {
                    pathSchema[i] = toPathSchemaInternal(validator, schemaItems[i], `${name}.${i}`, rootSchema, element, _recurseList);
                }
                else if (schemaAdditionalItems) {
                    pathSchema[i] = toPathSchemaInternal(validator, schemaAdditionalItems, `${name}.${i}`, rootSchema, element, _recurseList);
                }
                else {
                    console.warn(`Unable to generate path schema for "${name}.${i}". No schema defined for it`);
                }
            });
        }
        else {
            formData.forEach((element, i) => {
                pathSchema[i] = toPathSchemaInternal(validator, schemaItems, `${name}.${i}`, rootSchema, element, _recurseList);
            });
        }
    }
    else if (_constants__WEBPACK_IMPORTED_MODULE_3__.PROPERTIES_KEY in schema) {
        for (const property in schema.properties) {
            const field = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, [_constants__WEBPACK_IMPORTED_MODULE_3__.PROPERTIES_KEY, property]);
            pathSchema[property] = toPathSchemaInternal(validator, field, `${name}.${property}`, rootSchema, 
            // It's possible that formData is not an object -- this can happen if an
            // array item has just been added, but not populated with data yet
            lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(formData, [property]), _recurseList);
        }
    }
    return pathSchema;
}
/** Generates an `PathSchema` object for the `schema`, recursively
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which the `PathSchema` is desired
 * @param [name=''] - The base name for the schema
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [formData] - The current formData, if any, to assist retrieving a schema
 * @returns - The `PathSchema` object for the `schema`
 */
function toPathSchema(validator, schema, name = '', rootSchema, formData) {
    return toPathSchemaInternal(validator, schema, name, rootSchema, formData);
}
//# sourceMappingURL=toPathSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/shouldRender.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/shouldRender.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ shouldRender)
/* harmony export */ });
/* harmony import */ var _deepEquals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deepEquals */ "./node_modules/@rjsf/utils/lib/deepEquals.js");

/** Determines whether the given `component` should be rerendered by comparing its current set of props and state
 * against the next set. If either of those two sets are not the same, then the component should be rerendered.
 *
 * @param component - A React component being checked
 * @param nextProps - The next set of props against which to check
 * @param nextState - The next set of state against which to check
 * @returns - True if the component should be re-rendered, false otherwise
 */
function shouldRender(component, nextProps, nextState) {
    const { props, state } = component;
    return !(0,_deepEquals__WEBPACK_IMPORTED_MODULE_0__["default"])(props, nextProps) || !(0,_deepEquals__WEBPACK_IMPORTED_MODULE_0__["default"])(state, nextState);
}
//# sourceMappingURL=shouldRender.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/toConstant.js":
/*!****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/toConstant.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toConstant)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");

/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise
 * throws an error.
 *
 * @param schema - The schema from which to obtain the constant value
 * @returns - The constant value for the schema
 * @throws - Error when the schema does not have a constant value
 */
function toConstant(schema) {
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {
        return schema.enum[0];
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.CONST_KEY in schema) {
        return schema.const;
    }
    throw new Error('schema cannot be inferred as a constant');
}
//# sourceMappingURL=toConstant.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/toDateString.js":
/*!******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/toDateString.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDateString)
/* harmony export */ });
/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is
 * removed.
 *
 * @param dateObject - The `DateObject` to convert to a date string
 * @param [time=true] - Optional flag used to remove the time portion of the date string if false
 * @returns - The UTC date string
 */
function toDateString(dateObject, time = true) {
    const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;
    const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);
    const datetime = new Date(utcTime).toJSON();
    return time ? datetime : datetime.slice(0, 10);
}
//# sourceMappingURL=toDateString.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/toErrorList.js":
/*!*****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/toErrorList.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toErrorList)
/* harmony export */ });
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js");
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");


/** Converts an `errorSchema` into a list of `RJSFValidationErrors`
 *
 * @param errorSchema - The `ErrorSchema` instance to convert
 * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
 * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`
 */
function toErrorList(errorSchema, fieldPath = []) {
    if (!errorSchema) {
        return [];
    }
    let errorList = [];
    if (_constants__WEBPACK_IMPORTED_MODULE_1__.ERRORS_KEY in errorSchema) {
        errorList = errorList.concat(errorSchema[_constants__WEBPACK_IMPORTED_MODULE_1__.ERRORS_KEY].map((message) => {
            const property = `.${fieldPath.join('.')}`;
            return {
                property,
                message,
                stack: `${property} ${message}`,
            };
        }));
    }
    return Object.keys(errorSchema).reduce((acc, key) => {
        if (key !== _constants__WEBPACK_IMPORTED_MODULE_1__.ERRORS_KEY) {
            const childSchema = errorSchema[key];
            if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(childSchema)) {
                acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));
            }
        }
        return acc;
    }, errorList);
}
//# sourceMappingURL=toErrorList.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/toErrorSchema.js":
/*!*******************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/toErrorSchema.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toErrorSchema)
/* harmony export */ });
/* harmony import */ var lodash_toPath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/toPath */ "./node_modules/lodash/toPath.js");
/* harmony import */ var lodash_toPath__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_toPath__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ErrorSchemaBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ErrorSchemaBuilder */ "./node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js");


/** Transforms a rjsf validation errors list:
 * [
 *   {property: '.level1.level2[2].level3', message: 'err a'},
 *   {property: '.level1.level2[2].level3', message: 'err b'},
 *   {property: '.level1.level2[4].level3', message: 'err b'},
 * ]
 * Into an error tree:
 * {
 *   level1: {
 *     level2: {
 *       2: {level3: {errors: ['err a', 'err b']}},
 *       4: {level3: {errors: ['err b']}},
 *     }
 *   }
 * };
 *
 * @param errors - The list of RJSFValidationError objects
 * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`
 */
function toErrorSchema(errors) {
    const builder = new _ErrorSchemaBuilder__WEBPACK_IMPORTED_MODULE_1__["default"]();
    if (errors.length) {
        errors.forEach((error) => {
            const { property, message } = error;
            // When the property is the root element, just use an empty array for the path
            const path = property === '.' ? [] : lodash_toPath__WEBPACK_IMPORTED_MODULE_0___default()(property);
            // If the property is at the root (.level1) then toPath creates
            // an empty array element at the first index. Remove it.
            if (path.length > 0 && path[0] === '') {
                path.splice(0, 1);
            }
            if (message) {
                builder.addErrors(message, path);
            }
        });
    }
    return builder.ErrorSchema;
}
//# sourceMappingURL=toErrorSchema.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/types.js":
/*!***********************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/unwrapErrorHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/unwrapErrorHandler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unwrapErrorHandler)
/* harmony export */ });
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js");
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);

/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it
 *
 * @param errorHandler - The `FormValidation` error handling structure
 * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function
 */
function unwrapErrorHandler(errorHandler) {
    return Object.keys(errorHandler).reduce((acc, key) => {
        if (key === 'addError') {
            return acc;
        }
        else {
            const childSchema = errorHandler[key];
            if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(childSchema)) {
                return {
                    ...acc,
                    [key]: unwrapErrorHandler(childSchema),
                };
            }
            return { ...acc, [key]: childSchema };
        }
    }, {});
}
//# sourceMappingURL=unwrapErrorHandler.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/utcToLocal.js":
/*!****************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/utcToLocal.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ utcToLocal)
/* harmony export */ });
/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pad */ "./node_modules/@rjsf/utils/lib/pad.js");

/** Converts a UTC date string into a local Date format
 *
 * @param jsonDate - A UTC date string
 * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format
 */
function utcToLocal(jsonDate) {
    if (!jsonDate) {
        return '';
    }
    // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'
    // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)
    // > should be a _valid local date and time string_ (not GMT)
    // Note - date constructor passed local ISO-8601 does not correctly
    // change time to UTC in node pre-8
    const date = new Date(jsonDate);
    const yyyy = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getFullYear(), 4);
    const MM = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getMonth() + 1, 2);
    const dd = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getDate(), 2);
    const hh = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getHours(), 2);
    const mm = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getMinutes(), 2);
    const ss = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getSeconds(), 2);
    const SSS = (0,_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getMilliseconds(), 3);
    return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;
}
//# sourceMappingURL=utcToLocal.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/validationDataMerge.js":
/*!*************************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/validationDataMerge.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ validationDataMerge)
/* harmony export */ });
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mergeObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeObjects */ "./node_modules/@rjsf/utils/lib/mergeObjects.js");
/* harmony import */ var _toErrorList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toErrorList */ "./node_modules/@rjsf/utils/lib/toErrorList.js");



/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the
 * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling
 * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then
 * `validationData` is returned.
 *
 * @param validationData - The current `ValidationData` into which to merge the additional errors
 * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`
 * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.
 */
function validationDataMerge(validationData, additionalErrorSchema) {
    if (!additionalErrorSchema) {
        return validationData;
    }
    const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;
    let errors = (0,_toErrorList__WEBPACK_IMPORTED_MODULE_2__["default"])(additionalErrorSchema);
    let errorSchema = additionalErrorSchema;
    if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(oldErrorSchema)) {
        errorSchema = (0,_mergeObjects__WEBPACK_IMPORTED_MODULE_1__["default"])(oldErrorSchema, additionalErrorSchema, true);
        errors = [...oldErrors].concat(errors);
    }
    return { errorSchema, errors };
}
//# sourceMappingURL=validationDataMerge.js.map

/***/ }),

/***/ "./node_modules/@rjsf/utils/lib/withIdRefPrefix.js":
/*!*********************************************************!*\
  !*** ./node_modules/@rjsf/utils/lib/withIdRefPrefix.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ withIdRefPrefix)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@rjsf/utils/lib/constants.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_1__);


/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling
 * `withIdRefPrefix` for any other elements.
 *
 * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
 */
function withIdRefPrefixObject(node) {
    for (const key in node) {
        const realObj = node;
        const value = realObj[key];
        if (key === _constants__WEBPACK_IMPORTED_MODULE_0__.REF_KEY && typeof value === 'string' && value.startsWith('#')) {
            realObj[key] = _constants__WEBPACK_IMPORTED_MODULE_0__.ROOT_SCHEMA_PREFIX + value;
        }
        else {
            realObj[key] = withIdRefPrefix(value);
        }
    }
    return node;
}
/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling
 * `withIdRefPrefix` for any other elements.
 *
 * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
 */
function withIdRefPrefixArray(node) {
    for (let i = 0; i < node.length; i++) {
        node[i] = withIdRefPrefix(node[i]);
    }
    return node;
}
/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.
 * This is used in isValid to make references to the rootSchema
 *
 * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
 * @returns - A copy of the `schemaNode` with updated `$ref`s
 */
function withIdRefPrefix(schemaNode) {
    if (Array.isArray(schemaNode)) {
        return withIdRefPrefixArray([...schemaNode]);
    }
    if (lodash_isObject__WEBPACK_IMPORTED_MODULE_1___default()(schemaNode)) {
        return withIdRefPrefixObject({ ...schemaNode });
    }
    return schemaNode;
}
//# sourceMappingURL=withIdRefPrefix.js.map

/***/ }),

/***/ "./node_modules/compute-gcd/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/compute-gcd/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// MODULES //

var isArray = __webpack_require__( /*! validate.io-array */ "./node_modules/validate.io-array/lib/index.js" ),
	isIntegerArray = __webpack_require__( /*! validate.io-integer-array */ "./node_modules/validate.io-integer-array/lib/index.js" ),
	isFunction = __webpack_require__( /*! validate.io-function */ "./node_modules/validate.io-function/lib/index.js" );


// VARIABLES //

var MAXINT = Math.pow( 2, 31 ) - 1;


// FUNCTIONS //

/**
* FUNCTION: gcd( a, b )
*	Computes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.
*
* @param {Number} a - integer
* @param {Number} b - integer
* @returns {Number} greatest common divisor
*/
function gcd( a, b ) {
	var k = 1,
		t;
	// Simple cases:
	if ( a === 0 ) {
		return b;
	}
	if ( b === 0 ) {
		return a;
	}
	// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...
	while ( a%2 === 0 && b%2 === 0 ) {
		a = a / 2; // right shift
		b = b / 2; // right shift
		k = k * 2; // left shift
	}
	// Reduce `a` to an odd number...
	while ( a%2 === 0 ) {
		a = a / 2; // right shift
	}
	// Henceforth, `a` is always odd...
	while ( b ) {
		// Remove all factors of 2 in `b`, as they are not common...
		while ( b%2 === 0 ) {
			b = b / 2; // right shift
		}
		// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...
		if ( a > b ) {
			t = b;
			b = a;
			a = t;
		}
		b = b - a; // b=0 iff b=a
	}
	// Restore common factors of 2...
	return k * a;
} // end FUNCTION gcd()

/**
* FUNCTION: bitwise( a, b )
*	Computes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.
*
* @param {Number} a - safe integer
* @param {Number} b - safe integer
* @returns {Number} greatest common divisor
*/
function bitwise( a, b ) {
	var k = 0,
		t;
	// Simple cases:
	if ( a === 0 ) {
		return b;
	}
	if ( b === 0 ) {
		return a;
	}
	// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...
	while ( (a & 1) === 0 && (b & 1) === 0 ) {
		a >>>= 1; // right shift
		b >>>= 1; // right shift
		k++;
	}
	// Reduce `a` to an odd number...
	while ( (a & 1) === 0 ) {
		a >>>= 1; // right shift
	}
	// Henceforth, `a` is always odd...
	while ( b ) {
		// Remove all factors of 2 in `b`, as they are not common...
		while ( (b & 1) === 0 ) {
			b >>>= 1; // right shift
		}
		// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...
		if ( a > b ) {
			t = b;
			b = a;
			a = t;
		}
		b = b - a; // b=0 iff b=a
	}
	// Restore common factors of 2...
	return a << k;
} // end FUNCTION bitwise()


// GREATEST COMMON DIVISOR //

/**
* FUNCTION: compute( arr[, clbk] )
*	Computes the greatest common divisor.
*
* @param {Number[]|Number} arr - input array of integers
* @param {Function|Number} [clbk] - accessor function for accessing array values
* @returns {Number|Null} greatest common divisor or null
*/
function compute() {
	var nargs = arguments.length,
		args,
		clbk,
		arr,
		len,
		a, b,
		i;

	// Copy the input arguments to an array...
	args = new Array( nargs );
	for ( i = 0; i < nargs; i++ ) {
		args[ i ] = arguments[ i ];
	}
	// Have we been provided with integer arguments?
	if ( isIntegerArray( args ) ) {
		if ( nargs === 2 ) {
			a = args[ 0 ];
			b = args[ 1 ];
			if ( a < 0 ) {
				a = -a;
			}
			if ( b < 0 ) {
				b = -b;
			}
			if ( a <= MAXINT && b <= MAXINT ) {
				return bitwise( a, b );
			} else {
				return gcd( a, b );
			}
		}
		arr = args;
	}
	// If not integers, ensure the first argument is an array...
	else if ( !isArray( args[ 0 ] ) ) {
		throw new TypeError( 'gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );
	}
	// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...
	else if ( nargs > 1 ) {
		arr = args[ 0 ];
		clbk = args[ 1 ];
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	// We have been provided an array...
	else {
		arr = args[ 0 ];
	}
	len = arr.length;

	// Check if a sufficient number of values have been provided...
	if ( len < 2 ) {
		return null;
	}
	// If an accessor is provided, extract the array values...
	if ( clbk ) {
		a = new Array( len );
		for ( i = 0; i < len; i++ ) {
			a[ i ] = clbk( arr[ i ], i );
		}
		arr = a;
	}
	// Given an input array, ensure all array values are integers...
	if ( nargs < 3 ) {
		if ( !isIntegerArray( arr ) ) {
			throw new TypeError( 'gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );
		}
	}
	// Convert any negative integers to positive integers...
	for ( i = 0; i < len; i++ ) {
		a = arr[ i ];
		if ( a < 0 ) {
			arr[ i ] = -a;
		}
	}
	// Exploit the fact that the gcd is an associative function...
	a = arr[ 0 ];
	for ( i = 1; i < len; i++ ) {
		b = arr[ i ];
		if ( b <= MAXINT && a <= MAXINT ) {
			a = bitwise( a, b );
		} else {
			a = gcd( a, b );
		}
	}
	return a;
} // end FUNCTION compute()


// EXPORTS //

module.exports = compute;


/***/ }),

/***/ "./node_modules/compute-lcm/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/compute-lcm/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// MODULES //

var gcd = __webpack_require__( /*! compute-gcd */ "./node_modules/compute-gcd/lib/index.js" ),
	isArray = __webpack_require__( /*! validate.io-array */ "./node_modules/validate.io-array/lib/index.js" ),
	isIntegerArray = __webpack_require__( /*! validate.io-integer-array */ "./node_modules/validate.io-integer-array/lib/index.js" ),
	isFunction = __webpack_require__( /*! validate.io-function */ "./node_modules/validate.io-function/lib/index.js" );


// LEAST COMMON MULTIPLE //

/**
* FUNCTION: lcm( arr[, clbk] )
*	Computes the least common multiple (lcm).
*
* @param {Number[]|Number} arr - input array of integers
* @param {Function|Number} [accessor] - accessor function for accessing array values
* @returns {Number|Null} least common multiple or null
*/
function lcm() {
	var nargs = arguments.length,
		args,
		clbk,
		arr,
		len,
		a, b,
		i;

	// Copy the input arguments to an array...
	args = new Array( nargs );
	for ( i = 0; i < nargs; i++ ) {
		args[ i ] = arguments[ i ];
	}
	// Have we been provided with integer arguments?
	if ( isIntegerArray( args ) ) {
		if ( nargs === 2 ) {
			a = args[ 0 ];
			b = args[ 1 ];
			if ( a < 0 ) {
				a = -a;
			}
			if ( b < 0 ) {
				b = -b;
			}
			if ( a === 0 || b === 0 ) {
				return 0;
			}
			return ( a/gcd(a,b) ) * b;
		}
		arr = args;
	}
	// If not integers, ensure that the first argument is an array...
	else if ( !isArray( args[ 0 ] ) ) {
		throw new TypeError( 'lcm()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );
	}
	// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...
	else if ( nargs > 1 ) {
		arr = args[ 0 ];
		clbk = args[ 1 ];
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'lcm()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );
		}
	}
	// We have been provided an array...
	else {
		arr = args[ 0 ];
	}
	len = arr.length;

	// Check if a sufficient number of values have been provided...
	if ( len < 2 ) {
		return null;
	}
	// If an accessor is provided, extract the array values...
	if ( clbk ) {
		a = new Array( len );
		for ( i = 0; i < len; i++ ) {
			a[ i ] = clbk( arr[ i ], i );
		}
		arr = a;
	}
	// Given an input array, ensure all array values are integers...
	if ( nargs < 3 ) {
		if ( !isIntegerArray( arr ) ) {
			throw new TypeError( 'lcm()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );
		}
	}
	// Convert any negative integers to positive integers...
	for ( i = 0; i < len; i++ ) {
		a = arr[ i ];
		if ( a < 0 ) {
			arr[ i ] = -a;
		}
	}
	// Exploit the fact that the lcm is an associative function...
	a = arr[ 0 ];
	for ( i = 1; i < len; i++ ) {
		b = arr[ i ];
		if ( a === 0 || b === 0 ) {
			return 0;
		}
		a = ( a/gcd(a,b) ) * b;
	}
	return a;
} // end FUNCTION lcm()


// EXPORTS //

module.exports = lcm;


/***/ }),

/***/ "./node_modules/json-schema-compare/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/json-schema-compare/src/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isEqual = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js")
var sortBy = __webpack_require__(/*! lodash/sortBy */ "./node_modules/lodash/sortBy.js")
var uniq = __webpack_require__(/*! lodash/uniq */ "./node_modules/lodash/uniq.js")
var uniqWith = __webpack_require__(/*! lodash/uniqWith */ "./node_modules/lodash/uniqWith.js")
var defaults = __webpack_require__(/*! lodash/defaults */ "./node_modules/lodash/defaults.js")
var intersectionWith = __webpack_require__(/*! lodash/intersectionWith */ "./node_modules/lodash/intersectionWith.js")
var isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js")
var isBoolean = __webpack_require__(/*! lodash/isBoolean */ "./node_modules/lodash/isBoolean.js")

var normalizeArray = val => Array.isArray(val)
  ? val : [val]
var undef = val => val === undefined
var keys = obj => isPlainObject(obj) || Array.isArray(obj) ? Object.keys(obj) : []
var has = (obj, key) => obj.hasOwnProperty(key)
var stringArray = arr => sortBy(uniq(arr))
var undefEmpty = val => undef(val) || (Array.isArray(val) && val.length === 0)
var keyValEqual = (a, b, key, compare) => b && has(b, key) && a && has(a, key) && compare(a[key], b[key])
var undefAndZero = (a, b) => (undef(a) && b === 0) || (undef(b) && a === 0) || isEqual(a, b)
var falseUndefined = (a, b) => (undef(a) && b === false) || (undef(b) && a === false) || isEqual(a, b)
var emptySchema = schema => undef(schema) || isEqual(schema, {}) || schema === true
var emptyObjUndef = schema => undef(schema) || isEqual(schema, {})
var isSchema = val => undef(val) || isPlainObject(val) || val === true || val === false

function undefArrayEqual(a, b) {
  if (undefEmpty(a) && undefEmpty(b)) {
    return true
  } else {
    return isEqual(stringArray(a), stringArray(b))
  }
}

function unsortedNormalizedArray(a, b) {
  a = normalizeArray(a)
  b = normalizeArray(b)
  return isEqual(stringArray(a), stringArray(b))
}

function schemaGroup(a, b, key, compare) {
  var allProps = uniq(keys(a).concat(keys(b)))
  if (emptyObjUndef(a) && emptyObjUndef(b)) {
    return true
  } else if (emptyObjUndef(a) && keys(b).length) {
    return false
  } else if (emptyObjUndef(b) && keys(a).length) {
    return false
  }

  return allProps.every(function(key) {
    var aVal = a[key]
    var bVal = b[key]
    if (Array.isArray(aVal) && Array.isArray(bVal)) {
      return isEqual(stringArray(a), stringArray(b))
    } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {
      return false
    } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {
      return false
    }
    return keyValEqual(a, b, key, compare)
  })
}

function items(a, b, key, compare) {
  if (isPlainObject(a) && isPlainObject(b)) {
    return compare(a, b)
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return schemaGroup(a, b, key, compare)
  } else {
    return isEqual(a, b)
  }
}

function unsortedArray(a, b, key, compare) {
  var uniqueA = uniqWith(a, compare)
  var uniqueB = uniqWith(b, compare)
  var inter = intersectionWith(uniqueA, uniqueB, compare)
  return inter.length === Math.max(uniqueA.length, uniqueB.length)
}

var comparers = {
  title: isEqual,
  uniqueItems: falseUndefined,
  minLength: undefAndZero,
  minItems: undefAndZero,
  minProperties: undefAndZero,
  required: undefArrayEqual,
  enum: undefArrayEqual,
  type: unsortedNormalizedArray,
  items: items,
  anyOf: unsortedArray,
  allOf: unsortedArray,
  oneOf: unsortedArray,
  properties: schemaGroup,
  patternProperties: schemaGroup,
  dependencies: schemaGroup
}

var acceptsUndefined = [
  'properties',
  'patternProperties',
  'dependencies',
  'uniqueItems',
  'minLength',
  'minItems',
  'minProperties',
  'required'
]

var schemaProps = ['additionalProperties', 'additionalItems', 'contains', 'propertyNames', 'not']

function compare(a, b, options) {
  options = defaults(options, {
    ignore: []
  })

  if (emptySchema(a) && emptySchema(b)) {
    return true
  }

  if (!isSchema(a) || !isSchema(b)) {
    throw new Error('Either of the values are not a JSON schema.')
  }
  if (a === b) {
    return true
  }

  if (isBoolean(a) && isBoolean(b)) {
    return a === b
  }

  if ((a === undefined && b === false) || (b === undefined && a === false)) {
    return false
  }

  if ((undef(a) && !undef(b)) || (!undef(a) && undef(b))) {
    return false
  }

  var allKeys = uniq(Object.keys(a).concat(Object.keys(b)))

  if (options.ignore.length) {
    allKeys = allKeys.filter(k => options.ignore.indexOf(k) === -1)
  }

  if (!allKeys.length) {
    return true
  }

  function innerCompare(a, b) {
    return compare(a, b, options)
  }

  return allKeys.every(function(key) {
    var aValue = a[key]
    var bValue = b[key]

    if (schemaProps.indexOf(key) !== -1) {
      return compare(aValue, bValue, options)
    }

    var comparer = comparers[key]
    if (!comparer) {
      comparer = isEqual
    }

    // do simple lodash check first
    if (isEqual(aValue, bValue)) {
      return true
    }

    if (acceptsUndefined.indexOf(key) === -1) {
      if ((!has(a, key) && has(b, key)) || (has(a, key) && !has(b, key))) {
        return aValue === bValue
      }
    }

    var result = comparer(aValue, bValue, key, innerCompare)
    if (!isBoolean(result)) {
      throw new Error('Comparer must return true or false')
    }
    return result
  })
}

module.exports = compare


/***/ }),

/***/ "./node_modules/json-schema-merge-allof/src/common.js":
/*!************************************************************!*\
  !*** ./node_modules/json-schema-merge-allof/src/common.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flatten = __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js")
const flattenDeep = __webpack_require__(/*! lodash/flattenDeep */ "./node_modules/lodash/flattenDeep.js")
const isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js")
const uniq = __webpack_require__(/*! lodash/uniq */ "./node_modules/lodash/uniq.js")
const uniqWith = __webpack_require__(/*! lodash/uniqWith */ "./node_modules/lodash/uniqWith.js")
const without = __webpack_require__(/*! lodash/without */ "./node_modules/lodash/without.js")

function deleteUndefinedProps(returnObject) {
  // cleanup empty
  for (const prop in returnObject) {
    if (has(returnObject, prop) && isEmptySchema(returnObject[prop])) {
      delete returnObject[prop]
    }
  }
  return returnObject
}

const allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))
const getValues = (schemas, key) => schemas.map(schema => schema && schema[key])
const has = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName)
const keys = obj => {
  if (isPlainObject(obj) || Array.isArray(obj)) {
    return Object.keys(obj)
  } else {
    return []
  }
}

const notUndefined = (val) => val !== undefined
const isSchema = (val) => isPlainObject(val) || val === true || val === false
const isEmptySchema = (obj) => (!keys(obj).length) && obj !== false && obj !== true
const withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)))

module.exports = {
  allUniqueKeys,
  deleteUndefinedProps,
  getValues,
  has,
  isEmptySchema,
  isSchema,
  keys,
  notUndefined,
  uniqWith,
  withoutArr
}


/***/ }),

/***/ "./node_modules/json-schema-merge-allof/src/complex-resolvers/items.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/json-schema-merge-allof/src/complex-resolvers/items.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


const compare = __webpack_require__(/*! json-schema-compare */ "./node_modules/json-schema-compare/src/index.js")
const forEach = __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js")
const {
  allUniqueKeys,
  deleteUndefinedProps,
  has,
  isSchema,
  notUndefined,
  uniqWith
} = __webpack_require__(/*! ../common */ "./node_modules/json-schema-merge-allof/src/common.js")

function removeFalseSchemasFromArray(target) {
  forEach(target, function(schema, index) {
    if (schema === false) {
      target.splice(index, 1)
    }
  })
}

function getItemSchemas(subSchemas, key) {
  return subSchemas.map(function(sub) {
    if (!sub) {
      return undefined
    }

    if (Array.isArray(sub.items)) {
      const schemaAtPos = sub.items[key]
      if (isSchema(schemaAtPos)) {
        return schemaAtPos
      } else if (has(sub, 'additionalItems')) {
        return sub.additionalItems
      }
    } else {
      return sub.items
    }

    return undefined
  })
}

function getAdditionalSchemas(subSchemas) {
  return subSchemas.map(function(sub) {
    if (!sub) {
      return undefined
    }
    if (Array.isArray(sub.items)) {
      return sub.additionalItems
    }
    return sub.items
  })
}

// Provide source when array
function mergeItems(group, mergeSchemas, items) {
  const allKeys = allUniqueKeys(items)
  return allKeys.reduce(function(all, key) {
    const schemas = getItemSchemas(group, key)
    const compacted = uniqWith(schemas.filter(notUndefined), compare)
    all[key] = mergeSchemas(compacted, key)
    return all
  }, [])
}

module.exports = {
  keywords: ['items', 'additionalItems'],
  resolver(values, parents, mergers) {
    // const createSubMerger = groupKey => (schemas, key) => mergeSchemas(schemas, parents.concat(groupKey, key))
    const items = values.map(s => s.items)
    const itemsCompacted = items.filter(notUndefined)
    const returnObject = {}

    // if all items keyword values are schemas, we can merge them as simple schemas
    // if not we need to merge them as mixed
    if (itemsCompacted.every(isSchema)) {
      returnObject.items = mergers.items(items)
    } else {
      returnObject.items = mergeItems(values, mergers.items, items)
    }

    let schemasAtLastPos
    if (itemsCompacted.every(Array.isArray)) {
      schemasAtLastPos = values.map(s => s.additionalItems)
    } else if (itemsCompacted.some(Array.isArray)) {
      schemasAtLastPos = getAdditionalSchemas(values)
    }

    if (schemasAtLastPos) {
      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos)
    }

    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {
      removeFalseSchemasFromArray(returnObject.items)
    }

    return deleteUndefinedProps(returnObject)
  }
}


/***/ }),

/***/ "./node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


const compare = __webpack_require__(/*! json-schema-compare */ "./node_modules/json-schema-compare/src/index.js")
const forEach = __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js")
const {
  allUniqueKeys,
  deleteUndefinedProps,
  getValues,
  keys,
  notUndefined,
  uniqWith,
  withoutArr
} = __webpack_require__(/*! ../common */ "./node_modules/json-schema-merge-allof/src/common.js")

function removeFalseSchemas(target) {
  forEach(target, function(schema, prop) {
    if (schema === false) {
      delete target[prop]
    }
  })
}

function mergeSchemaGroup(group, mergeSchemas) {
  const allKeys = allUniqueKeys(group)
  return allKeys.reduce(function(all, key) {
    const schemas = getValues(group, key)
    const compacted = uniqWith(schemas.filter(notUndefined), compare)
    all[key] = mergeSchemas(compacted, key)
    return all
  }, {})
}

module.exports = {
  keywords: ['properties', 'patternProperties', 'additionalProperties'],
  resolver(values, parents, mergers, options) {
    // first get rid of all non permitted properties
    if (!options.ignoreAdditionalProperties) {
      values.forEach(function(subSchema) {
        const otherSubSchemas = values.filter(s => s !== subSchema)
        const ownKeys = keys(subSchema.properties)
        const ownPatternKeys = keys(subSchema.patternProperties)
        const ownPatterns = ownPatternKeys.map(k => new RegExp(k))
        otherSubSchemas.forEach(function(other) {
          const allOtherKeys = keys(other.properties)
          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)))
          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)
          additionalKeys.forEach(function(key) {
            other.properties[key] = mergers.properties([
              other.properties[key], subSchema.additionalProperties
            ], key)
          })
        })
      })

      // remove disallowed patternProperties
      values.forEach(function(subSchema) {
        const otherSubSchemas = values.filter(s => s !== subSchema)
        const ownPatternKeys = keys(subSchema.patternProperties)
        if (subSchema.additionalProperties === false) {
          otherSubSchemas.forEach(function(other) {
            const allOtherPatterns = keys(other.patternProperties)
            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)
            additionalPatternKeys.forEach(key => delete other.patternProperties[key])
          })
        }
      })
    }

    const returnObject = {
      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),
      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),
      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)
    }

    if (returnObject.additionalProperties === false) {
      removeFalseSchemas(returnObject.properties)
    }

    return deleteUndefinedProps(returnObject)
  }
}


/***/ }),

/***/ "./node_modules/json-schema-merge-allof/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/json-schema-merge-allof/src/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js")
const compare = __webpack_require__(/*! json-schema-compare */ "./node_modules/json-schema-compare/src/index.js")
const computeLcm = __webpack_require__(/*! compute-lcm */ "./node_modules/compute-lcm/lib/index.js")
const defaultsDeep = __webpack_require__(/*! lodash/defaultsDeep */ "./node_modules/lodash/defaultsDeep.js")
const flatten = __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js")
const flattenDeep = __webpack_require__(/*! lodash/flattenDeep */ "./node_modules/lodash/flattenDeep.js")
const intersection = __webpack_require__(/*! lodash/intersection */ "./node_modules/lodash/intersection.js")
const intersectionWith = __webpack_require__(/*! lodash/intersectionWith */ "./node_modules/lodash/intersectionWith.js")
const isEqual = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js")
const isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js")
const pullAll = __webpack_require__(/*! lodash/pullAll */ "./node_modules/lodash/pullAll.js")
const sortBy = __webpack_require__(/*! lodash/sortBy */ "./node_modules/lodash/sortBy.js")
const uniq = __webpack_require__(/*! lodash/uniq */ "./node_modules/lodash/uniq.js")
const uniqWith = __webpack_require__(/*! lodash/uniqWith */ "./node_modules/lodash/uniqWith.js")

const propertiesResolver = __webpack_require__(/*! ./complex-resolvers/properties */ "./node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js")
const itemsResolver = __webpack_require__(/*! ./complex-resolvers/items */ "./node_modules/json-schema-merge-allof/src/complex-resolvers/items.js")

const contains = (arr, val) => arr.indexOf(val) !== -1
const isSchema = (val) => isPlainObject(val) || val === true || val === false
const isFalse = (val) => val === false
const isTrue = (val) => val === true
const schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted)
const stringArray = (values) => sortBy(uniq(flattenDeep(values)))
const notUndefined = (val) => val !== undefined
const allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))

// resolvers
const first = compacted => compacted[0]
const required = compacted => stringArray(compacted)
const maximumValue = compacted => Math.max.apply(Math, compacted)
const minimumValue = compacted => Math.min.apply(Math, compacted)
const uniqueItems = compacted => compacted.some(isTrue)
const examples = compacted => uniqWith(flatten(compacted), isEqual)

function compareProp(key) {
  return function(a, b) {
    return compare({
      [key]: a
    }, { [key]: b })
  }
}

function getAllOf(schema) {
  let { allOf = [], ...copy } = schema
  copy = isPlainObject(schema) ? copy : schema // if schema is boolean
  return [copy, ...allOf.map(getAllOf)]
}

function getValues(schemas, key) {
  return schemas.map(schema => schema && schema[key])
}

function tryMergeSchemaGroups(schemaGroups, mergeSchemas) {
  return schemaGroups.map(function(schemas, index) {
    try {
      return mergeSchemas(schemas, index)
    } catch (e) {
      return undefined
    }
  }).filter(notUndefined)
}

function keys(obj) {
  if (isPlainObject(obj) || Array.isArray(obj)) {
    return Object.keys(obj)
  } else {
    return []
  }
}

function getAnyOfCombinations(arrOfArrays, combinations) {
  combinations = combinations || []
  if (!arrOfArrays.length) {
    return combinations
  }

  const values = arrOfArrays.slice(0).shift()
  const rest = arrOfArrays.slice(1)
  if (combinations.length) {
    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => ([item].concat(combination))))))
  }
  return getAnyOfCombinations(rest, values.map(item => (item)))
}

function throwIncompatible(values, paths) {
  let asJSON
  try {
    asJSON = values.map(function(val) {
      return JSON.stringify(val, null, 2)
    }).join('\n')
  } catch (variable) {
    asJSON = values.join(', ')
  }
  throw new Error('Could not resolve values for path:"' + paths.join('.') + '". They are probably incompatible. Values: \n' + asJSON)
}

function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {
  if (complexKeywords.length) {
    const resolverConfig = options.complexResolvers[resolverName]
    if (!resolverConfig || !resolverConfig.resolver) {
      throw new Error('No resolver found for ' + resolverName)
    }

    // extract all keywords from all the schemas that have one or more
    // then remove all undefined ones and not unique
    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {
      if (schema[key] !== undefined) all[key] = schema[key]
      return all
    }, {}))
    const unique = uniqWith(extractedKeywordsOnly, compare)

    // create mergers that automatically add the path of the keyword for use in the complex resolver
    const mergers = resolverConfig.keywords.reduce((all, key) => ({
      ...all,
      [key]: (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))
    }), {})

    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options)

    if (!isPlainObject(result)) {
      throwIncompatible(unique, parents.concat(resolverName))
    }

    return result
  }
}

function createRequiredMetaArray(arr) {
  return { required: arr }
}

const schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']
const schemaArrays = ['anyOf', 'oneOf']
const schemaProps = [
  'additionalProperties',
  'additionalItems',
  'contains',
  'propertyNames',
  'not',
  'items'
]

const defaultResolvers = {
  type(compacted) {
    if (compacted.some(Array.isArray)) {
      const normalized = compacted.map(function(val) {
        return Array.isArray(val)
          ? val
          : [val]
      })
      const common = intersection.apply(null, normalized)

      if (common.length === 1) {
        return common[0]
      } else if (common.length > 1) {
        return uniq(common)
      }
    }
  },
  dependencies(compacted, paths, mergeSchemas) {
    const allChildren = allUniqueKeys(compacted)

    return allChildren.reduce(function(all, childKey) {
      const childSchemas = getValues(compacted, childKey)
      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)

      // to support dependencies
      const innerArrays = innerCompacted.filter(Array.isArray)

      if (innerArrays.length) {
        if (innerArrays.length === innerCompacted.length) {
          all[childKey] = stringArray(innerCompacted)
        } else {
          const innerSchemas = innerCompacted.filter(isSchema)
          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray)
          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)
        }
        return all
      }

      innerCompacted = uniqWith(innerCompacted, compare)

      all[childKey] = mergeSchemas(innerCompacted, childKey)
      return all
    }, {})
  },
  oneOf(compacted, paths, mergeSchemas) {
    const combinations = getAnyOfCombinations(cloneDeep(compacted))
    const result = tryMergeSchemaGroups(combinations, mergeSchemas)
    const unique = uniqWith(result, compare)

    if (unique.length) {
      return unique
    }
  },
  not(compacted) {
    return { anyOf: compacted }
  },
  pattern(compacted) {
    return compacted.map(r => '(?=' + r + ')').join('')
  },
  multipleOf(compacted) {
    let integers = compacted.slice(0)
    let factor = 1
    while (integers.some(n => !Number.isInteger(n))) {
      integers = integers.map(n => n * 10)
      factor = factor * 10
    }
    return computeLcm(integers) / factor
  },
  enum(compacted) {
    const enums = intersectionWith.apply(null, compacted.concat(isEqual))
    if (enums.length) {
      return sortBy(enums)
    }
  }
}

defaultResolvers.$id = first
defaultResolvers.$ref = first
defaultResolvers.$schema = first
defaultResolvers.additionalItems = schemaResolver
defaultResolvers.additionalProperties = schemaResolver
defaultResolvers.anyOf = defaultResolvers.oneOf
defaultResolvers.contains = schemaResolver
defaultResolvers.default = first
defaultResolvers.definitions = defaultResolvers.dependencies
defaultResolvers.description = first
defaultResolvers.examples = examples
defaultResolvers.exclusiveMaximum = minimumValue
defaultResolvers.exclusiveMinimum = maximumValue
defaultResolvers.items = itemsResolver
defaultResolvers.maximum = minimumValue
defaultResolvers.maxItems = minimumValue
defaultResolvers.maxLength = minimumValue
defaultResolvers.maxProperties = minimumValue
defaultResolvers.minimum = maximumValue
defaultResolvers.minItems = maximumValue
defaultResolvers.minLength = maximumValue
defaultResolvers.minProperties = maximumValue
defaultResolvers.properties = propertiesResolver
defaultResolvers.propertyNames = schemaResolver
defaultResolvers.required = required
defaultResolvers.title = first
defaultResolvers.uniqueItems = uniqueItems

const defaultComplexResolvers = {
  properties: propertiesResolver,
  items: itemsResolver
}

function merger(rootSchema, options, totalSchemas) {
  totalSchemas = totalSchemas || []
  options = defaultsDeep(options, {
    ignoreAdditionalProperties: false,
    resolvers: defaultResolvers,
    complexResolvers: defaultComplexResolvers,
    deep: true
  })

  const complexResolvers = Object.entries(options.complexResolvers)

  function mergeSchemas(schemas, base, parents) {
    schemas = cloneDeep(schemas.filter(notUndefined))
    parents = parents || []
    const merged = isPlainObject(base)
      ? base
      : {}

    // return undefined, an empty schema
    if (!schemas.length) {
      return
    }

    if (schemas.some(isFalse)) {
      return false
    }

    if (schemas.every(isTrue)) {
      return true
    }

    // there are no false and we don't need the true ones as they accept everything
    schemas = schemas.filter(isPlainObject)

    const allKeys = allUniqueKeys(schemas)
    if (options.deep && contains(allKeys, 'allOf')) {
      return merger({
        allOf: schemas
      }, options, totalSchemas)
    }

    const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) =>
      allKeys.filter(k => resolverConf.keywords.includes(k)))

    // remove all complex keys before simple resolvers
    complexKeysArr.forEach(keys => pullAll(allKeys, keys))

    // call all simple resolvers for relevant keywords
    allKeys.forEach(function(key) {
      const values = getValues(schemas, key)
      const compacted = uniqWith(values.filter(notUndefined), compareProp(key))

      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas
      // allOf is treated differently alltogether
      if (compacted.length === 1 && contains(schemaArrays, key)) {
        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema))
        // prop groups must always be resolved
      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {
        merged[key] = compacted[0]
      } else {
        const resolver = options.resolvers[key] || options.resolvers.defaultResolver
        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')

        const merger = (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))
        merged[key] = resolver(compacted, parents.concat(key), merger, options)

        if (merged[key] === undefined) {
          throwIncompatible(compacted, parents.concat(key))
        } else if (merged[key] === undefined) {
          delete merged[key]
        }
      }
    })

    return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({
      ...all,
      ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)
    }), merged)
  }

  const allSchemas = flattenDeep(getAllOf(rootSchema))
  const merged = mergeSchemas(allSchemas)

  return merged
}

merger.options = {
  resolvers: defaultResolvers
}

module.exports = merger


/***/ }),

/***/ "./node_modules/jsonpointer/jsonpointer.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonpointer/jsonpointer.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

var hasExcape = /~/
var escapeMatcher = /~[01]/g
function escapeReplacer (m) {
  switch (m) {
    case '~1': return '/'
    case '~0': return '~'
  }
  throw new Error('Invalid tilde escape: ' + m)
}

function untilde (str) {
  if (!hasExcape.test(str)) return str
  return str.replace(escapeMatcher, escapeReplacer)
}

function setter (obj, pointer, value) {
  var part
  var hasNextPart

  for (var p = 1, len = pointer.length; p < len;) {
    if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj

    part = untilde(pointer[p++])
    hasNextPart = len > p

    if (typeof obj[part] === 'undefined') {
      // support setting of /-
      if (Array.isArray(obj) && part === '-') {
        part = obj.length
      }

      // support nested objects/array when setting values
      if (hasNextPart) {
        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []
        else obj[part] = {}
      }
    }

    if (!hasNextPart) break
    obj = obj[part]
  }

  var oldValue = obj[part]
  if (value === undefined) delete obj[part]
  else obj[part] = value
  return oldValue
}

function compilePointer (pointer) {
  if (typeof pointer === 'string') {
    pointer = pointer.split('/')
    if (pointer[0] === '') return pointer
    throw new Error('Invalid JSON pointer.')
  } else if (Array.isArray(pointer)) {
    for (const part of pointer) {
      if (typeof part !== 'string' && typeof part !== 'number') {
        throw new Error('Invalid JSON pointer. Must be of type string or number.')
      }
    }
    return pointer
  }

  throw new Error('Invalid JSON pointer.')
}

function get (obj, pointer) {
  if (typeof obj !== 'object') throw new Error('Invalid input object.')
  pointer = compilePointer(pointer)
  var len = pointer.length
  if (len === 1) return obj

  for (var p = 1; p < len;) {
    obj = obj[untilde(pointer[p++])]
    if (len === p) return obj
    if (typeof obj !== 'object' || obj === null) return undefined
  }
}

function set (obj, pointer, value) {
  if (typeof obj !== 'object') throw new Error('Invalid input object.')
  pointer = compilePointer(pointer)
  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')
  return setter(obj, pointer, value)
}

function compile (pointer) {
  var compiled = compilePointer(pointer)
  return {
    get: function (object) {
      return get(object, compiled)
    },
    set: function (object, value) {
      return set(object, compiled, value)
    }
  }
}

exports.get = get
exports.set = set
exports.compile = compile


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_assignMergeValue.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_baseDifference.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseDifference.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;


/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOfWith.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIndexOfWith.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOfWith;


/***/ }),

/***/ "./node_modules/lodash/_baseIntersection.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIntersection.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseIntersection;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseMerge.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseMergeDeep.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseOrderBy.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseOrderBy.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ "./node_modules/lodash/_baseSortBy.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ "./node_modules/lodash/_compareMultiple.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_basePullAll.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_basePullAll.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js"),
    baseIndexOfWith = __webpack_require__(/*! ./_baseIndexOfWith */ "./node_modules/lodash/_baseIndexOfWith.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */
function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
      index = -1,
      length = values.length,
      seen = array;

  if (array === values) {
    values = copyArray(values);
  }
  if (iteratee) {
    seen = arrayMap(array, baseUnary(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice.call(seen, fromIndex, 1);
      }
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}

module.exports = basePullAll;


/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSortBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseSortBy.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ "./node_modules/lodash/_castArrayLikeObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_castArrayLikeObject.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

module.exports = castArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_compareAscending.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_compareAscending.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ "./node_modules/lodash/_compareMultiple.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_compareMultiple.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compareAscending = __webpack_require__(/*! ./_compareAscending */ "./node_modules/lodash/_compareAscending.js");

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ "./node_modules/lodash/_customDefaultsMerge.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_customDefaultsMerge.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

module.exports = customDefaultsMerge;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_safeGet.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/lodash/defaultsDeep.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/defaultsDeep.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    customDefaultsMerge = __webpack_require__(/*! ./_customDefaultsMerge */ "./node_modules/lodash/_customDefaultsMerge.js"),
    mergeWith = __webpack_require__(/*! ./mergeWith */ "./node_modules/lodash/mergeWith.js");

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, customDefaultsMerge);
  return apply(mergeWith, undefined, args);
});

module.exports = defaultsDeep;


/***/ }),

/***/ "./node_modules/lodash/flattenDeep.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/flattenDeep.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, INFINITY) : [];
}

module.exports = flattenDeep;


/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ "./node_modules/lodash/intersection.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/intersection.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIntersection = __webpack_require__(/*! ./_baseIntersection */ "./node_modules/lodash/_baseIntersection.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    castArrayLikeObject = __webpack_require__(/*! ./_castArrayLikeObject */ "./node_modules/lodash/_castArrayLikeObject.js");

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

module.exports = intersection;


/***/ }),

/***/ "./node_modules/lodash/intersectionWith.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/intersectionWith.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIntersection = __webpack_require__(/*! ./_baseIntersection */ "./node_modules/lodash/_baseIntersection.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    castArrayLikeObject = __webpack_require__(/*! ./_castArrayLikeObject */ "./node_modules/lodash/_castArrayLikeObject.js"),
    last = __webpack_require__(/*! ./last */ "./node_modules/lodash/last.js");

/**
 * This method is like `_.intersection` except that it accepts `comparator`
 * which is invoked to compare elements of `arrays`. The order and references
 * of result values are determined by the first array. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.intersectionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }]
 */
var intersectionWith = baseRest(function(arrays) {
  var comparator = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  comparator = typeof comparator == 'function' ? comparator : undefined;
  if (comparator) {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, undefined, comparator)
    : [];
});

module.exports = intersectionWith;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBoolean.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/isBoolean.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

module.exports = isBoolean;


/***/ }),

/***/ "./node_modules/lodash/isEqualWith.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isEqualWith.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/**
 * This method is like `_.isEqual` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqualWith(array, other, customizer);
 * // => true
 */
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
}

module.exports = isEqualWith;


/***/ }),

/***/ "./node_modules/lodash/isNil.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isNil.js ***!
  \**************************************/
/***/ ((module) => {

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

module.exports = isNil;


/***/ }),

/***/ "./node_modules/lodash/isNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/mergeWith.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/mergeWith.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

module.exports = mergeWith;


/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/pullAll.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/pullAll.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePullAll = __webpack_require__(/*! ./_basePullAll */ "./node_modules/lodash/_basePullAll.js");

/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pullAll(array, ['a', 'c']);
 * console.log(array);
 * // => ['b', 'b']
 */
function pullAll(array, values) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values)
    : array;
}

module.exports = pullAll;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;


/***/ }),

/***/ "./node_modules/lodash/sortBy.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/sortBy.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ "./node_modules/lodash/_baseOrderBy.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ "./node_modules/lodash/times.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/times.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH,
      length = nativeMin(n, MAX_ARRAY_LENGTH);

  iteratee = castFunction(iteratee);
  n -= MAX_ARRAY_LENGTH;

  var result = baseTimes(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

module.exports = times;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/toPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;


/***/ }),

/***/ "./node_modules/lodash/uniq.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/uniq.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js");

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

module.exports = uniq;


/***/ }),

/***/ "./node_modules/lodash/uniqWith.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/uniqWith.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js");

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
}

module.exports = uniqWith;


/***/ }),

/***/ "./node_modules/lodash/without.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/without.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseDifference = __webpack_require__(/*! ./_baseDifference */ "./node_modules/lodash/_baseDifference.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_SERVER_CONTEXT_TYPE:
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false;
var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isConcurrentMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}
function isSuspenseList(object) {
  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
}

exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.SuspenseList = SuspenseList;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isSuspenseList = isSuspenseList;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/validate.io-array/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/validate.io-array/lib/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
* FUNCTION: isArray( value )
*	Validates if a value is an array.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an array
*/
function isArray( value ) {
	return Object.prototype.toString.call( value ) === '[object Array]';
} // end FUNCTION isArray()

// EXPORTS //

module.exports = Array.isArray || isArray;


/***/ }),

/***/ "./node_modules/validate.io-function/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/validate.io-function/lib/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
/**
*
*	VALIDATE: function
*
*
*	DESCRIPTION:
*		- Validates if a value is a function.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/



/**
* FUNCTION: isFunction( value )
*	Validates if a value is a function.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a function
*/
function isFunction( value ) {
	return ( typeof value === 'function' );
} // end FUNCTION isFunction()


// EXPORTS //

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/validate.io-integer-array/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/validate.io-integer-array/lib/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
*
*	VALIDATE: integer-array
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer array.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/



// MODULES //

var isArray = __webpack_require__( /*! validate.io-array */ "./node_modules/validate.io-array/lib/index.js" ),
	isInteger = __webpack_require__( /*! validate.io-integer */ "./node_modules/validate.io-integer/lib/index.js" );


// IS INTEGER ARRAY //

/**
* FUNCTION: isIntegerArray( value )
*	Validates if a value is an integer array.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is an integer array
*/
function isIntegerArray( value ) {
	var len;
	if ( !isArray( value ) ) {
		return false;
	}
	len = value.length;
	if ( !len ) {
		return false;
	}
	for ( var i = 0; i < len; i++ ) {
		if ( !isInteger( value[i] ) ) {
			return false;
		}
	}
	return true;
} // end FUNCTION isIntegerArray()


// EXPORTS //

module.exports = isIntegerArray;


/***/ }),

/***/ "./node_modules/validate.io-integer/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/validate.io-integer/lib/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
*
*	VALIDATE: integer
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/



// MODULES //

var isNumber = __webpack_require__( /*! validate.io-number */ "./node_modules/validate.io-number/lib/index.js" );


// ISINTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is an integer.
*
* @param {Number} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an integer
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;


/***/ }),

/***/ "./node_modules/validate.io-number/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/validate.io-number/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
/**
*
*	VALIDATE: number
*
*
*	DESCRIPTION:
*		- Validates if a value is a number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/



/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a number
*/
function isNumber( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmpzZl91dGlsc19saWJfaW5kZXhfanMuYmFkNzkxNzBiZDEzNWNmOWVmNjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDWjtBQUNBO0FBQ1k7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQUc7QUFDdEM7QUFDQTtBQUNBLFlBQVksaURBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdURBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFHLGFBQWEsa0RBQVU7QUFDbkQ7QUFDQTtBQUNBLHVCQUF1QixrREFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFHLGFBQWEsa0RBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQUcsYUFBYSxrREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3RHa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFRO0FBQ25CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUs7O0FBRVY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2IsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLGVBQWUsbUJBQU8sRUFBRSwwRUFBb0I7OztBQUc1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL0Vycm9yU2NoZW1hQnVpbGRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2FsbG93QWRkaXRpb25hbEl0ZW1zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvYXNOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9jYW5FeHBhbmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9jcmVhdGVFcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9jcmVhdGVTY2hlbWFVdGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2RhdGFVUkl0b0Jsb2IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9kZWVwRXF1YWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvZW5nbGlzaFN0cmluZ1RyYW5zbGF0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9lbnVtT3B0aW9uc0Rlc2VsZWN0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9lbnVtT3B0aW9uc0luZGV4Rm9yVmFsdWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9lbnVtT3B0aW9uc0lzU2VsZWN0ZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9lbnVtT3B0aW9uc1NlbGVjdFZhbHVlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvZW51bXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9maW5kU2NoZW1hRGVmaW5pdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2dldERpc2NyaW1pbmF0b3JGaWVsZEZyb21TY2hlbWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9nZXRJbnB1dFByb3BzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvZ2V0T3B0aW9uTWF0Y2hpbmdTaW1wbGVEaXNjcmltaW5hdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvZ2V0U2NoZW1hVHlwZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2dldFN1Ym1pdEJ1dHRvbk9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9nZXRUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2dldFVpT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2dldFdpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2d1ZXNzVHlwZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2hhc1dpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2hhc2hGb3JTY2hlbWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9pZEdlbmVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2lzQ29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9pc0N1c3RvbVdpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2lzRml4ZWRJdGVtcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2lzT2JqZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvbGFiZWxWYWx1ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL2xvY2FsVG9VVEMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9tZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvbWVyZ2VPYmplY3RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvbWVyZ2VTY2hlbWFzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvb3B0aW9uc0xpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9vcmRlclByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9wYWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9wYXJzZURhdGVTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9wYXJzZXIvUGFyc2VyVmFsaWRhdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvcGFyc2VyL3NjaGVtYVBhcnNlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL3JhbmdlU3BlYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL3JlcGxhY2VTdHJpbmdQYXJhbWV0ZXJzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvc2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvZ2V0Q2xvc2VzdE1hdGNoaW5nT3B0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvc2NoZW1hL2dldERlZmF1bHRGb3JtU3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvZ2V0RGlzcGxheUxhYmVsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvc2NoZW1hL2dldEZpcnN0TWF0Y2hpbmdPcHRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvZ2V0TWF0Y2hpbmdPcHRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvaXNGaWxlc0FycmF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvc2NoZW1hL2lzTXVsdGlTZWxlY3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvaXNTZWxlY3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvbWVyZ2VWYWxpZGF0aW9uRGF0YS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL3NjaGVtYS9yZXRyaWV2ZVNjaGVtYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL3NjaGVtYS9zYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zY2hlbWEvdG9JZFNjaGVtYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL3NjaGVtYS90b1BhdGhTY2hlbWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi9zaG91bGRSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi90b0NvbnN0YW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvdG9EYXRlU3RyaW5nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvdG9FcnJvckxpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi90b0Vycm9yU2NoZW1hLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi91bndyYXBFcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3V0aWxzL2xpYi91dGNUb0xvY2FsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi91dGlscy9saWIvdmFsaWRhdGlvbkRhdGFNZXJnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdXRpbHMvbGliL3dpdGhJZFJlZlByZWZpeC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1nY2QvbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jb21wdXRlLWxjbS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLWNvbXBhcmUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1tZXJnZS1hbGxvZi9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1tZXJnZS1hbGxvZi9zcmMvY29tcGxleC1yZXNvbHZlcnMvaXRlbXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLW1lcmdlLWFsbG9mL3NyYy9jb21wbGV4LXJlc29sdmVycy9wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS1tZXJnZS1hbGxvZi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2pzb25wb2ludGVyL2pzb25wb2ludGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZldpdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXAuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlT3JkZXJCeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHVsbEFsbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVkdWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTb3J0QnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRyaW0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuaXEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdEFycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29tcGFyZUFzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVTZXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3VzdG9tRGVmYXVsdHNNZXJnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190cmltbWVkRW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRzRGVlcC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW5EZWVwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVyc2VjdGlvbldpdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRXF1YWxXaXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNOaWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc051bWJlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2VXaXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHVsbEFsbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RpbWVzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VuaXEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxV2l0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3dpdGhvdXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLWFycmF5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tZnVuY3Rpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1pbnRlZ2VyLWFycmF5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8taW50ZWdlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW51bWJlci9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2gvY2xvbmVEZWVwJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9zZXQnO1xuaW1wb3J0IHsgRVJST1JTX0tFWSB9IGZyb20gJy4vY29uc3RhbnRzJztcbi8qKiBUaGUgYEVycm9yU2NoZW1hQnVpbGRlcjxUPmAgaXMgdXNlZCB0byBidWlsZCBhbiBgRXJyb3JTY2hlbWE8VD5gIHNpbmNlIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBgRXJyb3JTY2hlbWFgIHR5cGUgaXNcbiAqIGRlc2lnbmVkIGZvciByZWFkaW5nIGluZm9ybWF0aW9uIHJhdGhlciB0aGFuIHdyaXRpbmcgaXQuIFVzZSB0aGlzIGNsYXNzIHRvIGFkZCwgcmVwbGFjZSBvciBjbGVhciBlcnJvcnMgaW4gYW4gZXJyb3JcbiAqIHNjaGVtYSBieSB1c2luZyBlaXRoZXIgZG90dGVkIHBhdGggb3IgYW4gYXJyYXkgb2YgcGF0aCBuYW1lcy4gT25jZSB5b3UgYXJlIGRvbmUgYnVpbGRpbmcgdGhlIGBFcnJvclNjaGVtYWAsIHlvdSBjYW5cbiAqIGdldCB0aGUgcmVzdWx0IGFuZC9vciByZXNldCBhbGwgdGhlIGVycm9ycyBiYWNrIHRvIGFuIGluaXRpYWwgc2V0IGFuZCBzdGFydCBhZ2Fpbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JTY2hlbWFCdWlsZGVyIHtcbiAgICAvKiogQ29uc3RydWN0IGFuIGBFcnJvclNjaGVtYUJ1aWxkZXJgIHdpdGggYW4gb3B0aW9uYWwgaW5pdGlhbCBzZXQgb2YgZXJyb3JzIGluIGFuIGBFcnJvclNjaGVtYWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2luaXRpYWxTY2hlbWFdIC0gVGhlIG9wdGlvbmFsIHNldCBvZiBpbml0aWFsIGVycm9ycywgdGhhdCB3aWxsIGJlIGNsb25lZCBpbnRvIHRoZSBjbGFzc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxTY2hlbWEpIHtcbiAgICAgICAgLyoqIFRoZSBlcnJvciBzY2hlbWEgYmVpbmcgYnVpbHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXJyb3JTY2hlbWEgPSB7fTtcbiAgICAgICAgdGhpcy5yZXNldEFsbEVycm9ycyhpbml0aWFsU2NoZW1hKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGBFcnJvclNjaGVtYWAgdGhhdCBoYXMgYmVlbiB1cGRhdGVkIGJ5IHRoZSBtZXRob2RzIG9mIHRoZSBgRXJyb3JTY2hlbWFCdWlsZGVyYFxuICAgICAqL1xuICAgIGdldCBFcnJvclNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JTY2hlbWE7XG4gICAgfVxuICAgIC8qKiBXaWxsIGdldCBhbiBleGlzdGluZyBgRXJyb3JTY2hlbWFgIGF0IHRoZSBzcGVjaWZpZWQgYHBhdGhPZkVycm9yYCBvciBjcmVhdGUgYW5kIHJldHVybiBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW3BhdGhPZkVycm9yXSAtIFRoZSBvcHRpb25hbCBwYXRoIGludG8gdGhlIGBFcnJvclNjaGVtYWAgYXQgd2hpY2ggdG8gYWRkIHRoZSBlcnJvcihzKVxuICAgICAqIEByZXR1cm5zIC0gVGhlIGVycm9yIGJsb2NrIGZvciB0aGUgZ2l2ZW4gYHBhdGhPZkVycm9yYCBvciB0aGUgcm9vdCBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlRXJyb3JCbG9jayhwYXRoT2ZFcnJvcikge1xuICAgICAgICBjb25zdCBoYXNQYXRoID0gKEFycmF5LmlzQXJyYXkocGF0aE9mRXJyb3IpICYmIHBhdGhPZkVycm9yLmxlbmd0aCA+IDApIHx8IHR5cGVvZiBwYXRoT2ZFcnJvciA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGxldCBlcnJvckJsb2NrID0gaGFzUGF0aCA/IGdldCh0aGlzLmVycm9yU2NoZW1hLCBwYXRoT2ZFcnJvcikgOiB0aGlzLmVycm9yU2NoZW1hO1xuICAgICAgICBpZiAoIWVycm9yQmxvY2sgJiYgcGF0aE9mRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yQmxvY2sgPSB7fTtcbiAgICAgICAgICAgIHNldCh0aGlzLmVycm9yU2NoZW1hLCBwYXRoT2ZFcnJvciwgZXJyb3JCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yQmxvY2s7XG4gICAgfVxuICAgIC8qKiBSZXNldHMgYWxsIGVycm9ycyBpbiB0aGUgYEVycm9yU2NoZW1hQnVpbGRlcmAgYmFjayB0byB0aGUgYGluaXRpYWxTY2hlbWFgIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgYW4gZW1wdHkgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIFtpbml0aWFsU2NoZW1hXSAtIFRoZSBvcHRpb25hbCBzZXQgb2YgaW5pdGlhbCBlcnJvcnMsIHRoYXQgd2lsbCBiZSBjbG9uZWQgaW50byB0aGUgY2xhc3NcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBgRXJyb3JTY2hlbWFCdWlsZGVyYCBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzXG4gICAgICovXG4gICAgcmVzZXRBbGxFcnJvcnMoaW5pdGlhbFNjaGVtYSkge1xuICAgICAgICB0aGlzLmVycm9yU2NoZW1hID0gaW5pdGlhbFNjaGVtYSA/IGNsb25lRGVlcChpbml0aWFsU2NoZW1hKSA6IHt9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEFkZHMgdGhlIGBlcnJvck9yTGlzdGAgdG8gdGhlIGxpc3Qgb2YgZXJyb3JzIGluIHRoZSBgRXJyb3JTY2hlbWFgIGF0IGVpdGhlciB0aGUgcm9vdCBsZXZlbCBvciB0aGUgbG9jYXRpb24gd2l0aGluXG4gICAgICogdGhlIHNjaGVtYSBkZXNjcmliZWQgYnkgdGhlIGBwYXRoT2ZFcnJvcmAuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0byBzcGVjaWZ5IHRoZSBwYXRoIHNlZSB0aGVcbiAgICAgKiBbZXNsaW50IGxvZGFzaCBwbHVnaW4gZG9jc10oaHR0cHM6Ly9naXRodWIuY29tL3dpeC9lc2xpbnQtcGx1Z2luLWxvZGFzaC9ibG9iL21hc3Rlci9kb2NzL3J1bGVzL3BhdGgtc3R5bGUubWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yT3JMaXN0IC0gVGhlIGVycm9yIG9yIGxpc3Qgb2YgZXJyb3JzIHRvIGFkZCBpbnRvIHRoZSBgRXJyb3JTY2hlbWFgXG4gICAgICogQHBhcmFtIFtwYXRoT2ZFcnJvcl0gLSBUaGUgb3B0aW9uYWwgcGF0aCBpbnRvIHRoZSBgRXJyb3JTY2hlbWFgIGF0IHdoaWNoIHRvIGFkZCB0aGUgZXJyb3IocylcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBgRXJyb3JTY2hlbWFCdWlsZGVyYCBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzXG4gICAgICovXG4gICAgYWRkRXJyb3JzKGVycm9yT3JMaXN0LCBwYXRoT2ZFcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvckJsb2NrID0gdGhpcy5nZXRPckNyZWF0ZUVycm9yQmxvY2socGF0aE9mRXJyb3IpO1xuICAgICAgICBsZXQgZXJyb3JzTGlzdCA9IGdldChlcnJvckJsb2NrLCBFUlJPUlNfS0VZKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVycm9yc0xpc3QpKSB7XG4gICAgICAgICAgICBlcnJvcnNMaXN0ID0gW107XG4gICAgICAgICAgICBlcnJvckJsb2NrW0VSUk9SU19LRVldID0gZXJyb3JzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvck9yTGlzdCkpIHtcbiAgICAgICAgICAgIGVycm9yc0xpc3QucHVzaCguLi5lcnJvck9yTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnNMaXN0LnB1c2goZXJyb3JPckxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogU2V0cy9yZXBsYWNlcyB0aGUgYGVycm9yT3JMaXN0YCBhcyB0aGUgZXJyb3IocykgaW4gdGhlIGBFcnJvclNjaGVtYWAgYXQgZWl0aGVyIHRoZSByb290IGxldmVsIG9yIHRoZSBsb2NhdGlvblxuICAgICAqIHdpdGhpbiB0aGUgc2NoZW1hIGRlc2NyaWJlZCBieSB0aGUgYHBhdGhPZkVycm9yYC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIHNwZWNpZnkgdGhlIHBhdGggc2VlIHRoZVxuICAgICAqIFtlc2xpbnQgbG9kYXNoIHBsdWdpbiBkb2NzXShodHRwczovL2dpdGh1Yi5jb20vd2l4L2VzbGludC1wbHVnaW4tbG9kYXNoL2Jsb2IvbWFzdGVyL2RvY3MvcnVsZXMvcGF0aC1zdHlsZS5tZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JPckxpc3QgLSBUaGUgZXJyb3Igb3IgbGlzdCBvZiBlcnJvcnMgdG8gc2V0IGludG8gdGhlIGBFcnJvclNjaGVtYWBcbiAgICAgKiBAcGFyYW0gW3BhdGhPZkVycm9yXSAtIFRoZSBvcHRpb25hbCBwYXRoIGludG8gdGhlIGBFcnJvclNjaGVtYWAgYXQgd2hpY2ggdG8gc2V0IHRoZSBlcnJvcihzKVxuICAgICAqIEByZXR1cm5zIC0gVGhlIGBFcnJvclNjaGVtYUJ1aWxkZXJgIG9iamVjdCBmb3IgY2hhaW5pbmcgcHVycG9zZXNcbiAgICAgKi9cbiAgICBzZXRFcnJvcnMoZXJyb3JPckxpc3QsIHBhdGhPZkVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQmxvY2sgPSB0aGlzLmdldE9yQ3JlYXRlRXJyb3JCbG9jayhwYXRoT2ZFcnJvcik7XG4gICAgICAgIC8vIEVmZmVjdGl2ZWx5IGNsb25lIHRoZSBhcnJheSBiZWluZyBnaXZlbiB0byBwcmV2ZW50IGFjY2lkZW50YWwgb3V0c2lkZSBtYW5pcHVsYXRpb24gb2YgdGhlIGdpdmVuIGxpc3RcbiAgICAgICAgY29uc3QgbGlzdFRvQWRkID0gQXJyYXkuaXNBcnJheShlcnJvck9yTGlzdCkgPyBbLi4uZXJyb3JPckxpc3RdIDogW2Vycm9yT3JMaXN0XTtcbiAgICAgICAgc2V0KGVycm9yQmxvY2ssIEVSUk9SU19LRVksIGxpc3RUb0FkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQ2xlYXJzIHRoZSBlcnJvcihzKSBpbiB0aGUgYEVycm9yU2NoZW1hYCBhdCBlaXRoZXIgdGhlIHJvb3QgbGV2ZWwgb3IgdGhlIGxvY2F0aW9uIHdpdGhpbiB0aGUgc2NoZW1hIGRlc2NyaWJlZCBieVxuICAgICAqIHRoZSBgcGF0aE9mRXJyb3JgLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gc3BlY2lmeSB0aGUgcGF0aCBzZWUgdGhlXG4gICAgICogW2VzbGludCBsb2Rhc2ggcGx1Z2luIGRvY3NdKGh0dHBzOi8vZ2l0aHViLmNvbS93aXgvZXNsaW50LXBsdWdpbi1sb2Rhc2gvYmxvYi9tYXN0ZXIvZG9jcy9ydWxlcy9wYXRoLXN0eWxlLm1kKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbcGF0aE9mRXJyb3JdIC0gVGhlIG9wdGlvbmFsIHBhdGggaW50byB0aGUgYEVycm9yU2NoZW1hYCBhdCB3aGljaCB0byBjbGVhciB0aGUgZXJyb3IocylcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBgRXJyb3JTY2hlbWFCdWlsZGVyYCBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzXG4gICAgICovXG4gICAgY2xlYXJFcnJvcnMocGF0aE9mRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JCbG9jayA9IHRoaXMuZ2V0T3JDcmVhdGVFcnJvckJsb2NrKHBhdGhPZkVycm9yKTtcbiAgICAgICAgc2V0KGVycm9yQmxvY2ssIEVSUk9SU19LRVksIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JTY2hlbWFCdWlsZGVyLmpzLm1hcCIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0Jztcbi8qKiBDaGVja3MgdGhlIHNjaGVtYSB0byBzZWUgaWYgaXQgaXMgYWxsb3dpbmcgYWRkaXRpb25hbCBpdGVtcywgYnkgdmVyaWZ5aW5nIHRoYXQgYHNjaGVtYS5hZGRpdGlvbmFsSXRlbXNgIGlzIGFuXG4gKiBvYmplY3QuIFRoZSB1c2VyIGlzIHdhcm5lZCBpbiB0aGUgY29uc29sZSBpZiBgc2NoZW1hLmFkZGl0aW9uYWxJdGVtc2AgaGFzIHRoZSB2YWx1ZSBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgYWRkaXRpb25hbCBpdGVtcyBpcyBhbGxvd2VkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWxsb3dBZGRpdGlvbmFsSXRlbXMoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdhZGRpdGlvbmFsSXRlbXM9dHJ1ZSBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gaXNPYmplY3Qoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxvd0FkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCIvKiogQXR0ZW1wdHMgdG8gY29udmVydCB0aGUgc3RyaW5nIGludG8gYSBudW1iZXIuIElmIGFuIGVtcHR5IHN0cmluZyBpcyBwcm92aWRlZCwgdGhlbiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4gSWYgYVxuICogYG51bGxgIGlzIHByb3ZpZGVkLCBpdCBpcyByZXR1cm5lZC4gSWYgdGhlIHN0cmluZyBlbmRzIGluIGEgYC5gIHRoZW4gdGhlIHN0cmluZyBpcyByZXR1cm5lZCBiZWNhdXNlIHRoZSB1c2VyIG1heSBiZVxuICogaW4gdGhlIG1pZGRsZSBvZiB0eXBpbmcgYSBmbG9hdCBudW1iZXIuIElmIGEgbnVtYmVyIGVuZHMgaW4gYSBwYXR0ZXJuIGxpa2UgYC4wYCwgYC4yMGAsIGAuMDMwYCwgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBiZWNhdXNlIHRoZSB1c2VyIG1heSBiZSB0eXBpbmcgbnVtYmVyIHRoYXQgd2lsbCBlbmQgaW4gYSBub24temVybyBkaWdpdC4gT3RoZXJ3aXNlLCB0aGUgc3RyaW5nIGlzIHdyYXBwZWQgYnlcbiAqIGBOdW1iZXIoKWAgYW5kIGlmIHRoYXQgcmVzdWx0IGlzIG5vdCBgTmFOYCwgdGhhdCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlIHRoZSBzdHJpbmcgYHZhbHVlYCB3aWxsIGJlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgb3IgbnVsbCB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgbnVtYmVyXG4gKiBAcmV0dXJucyAtIFRoZSBgdmFsdWVgIGNvbnZlcnRlZCB0byBhIG51bWJlciB3aGVuIGFwcHJvcHJpYXRlLCBvdGhlcndpc2UgdGhlIGB2YWx1ZWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKC9cXC4kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAvLyAnMy4nIGNhbid0IHJlYWxseSBiZSBjb25zaWRlcmVkIGEgbnVtYmVyIGV2ZW4gaWYgaXQgcGFyc2VzIGluIGpzLiBUaGVcbiAgICAgICAgLy8gdXNlciBpcyBtb3N0IGxpa2VseSBlbnRlcmluZyBhIGZsb2F0LlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICgvXFwuMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIHRoaXMgYXMgYSBzdHJpbmcgaGVyZSwgdG8gYWxsb3cgZm9yIGlucHV0IGxpa2UgMy4wN1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICgvXFwuXFxkKjAkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAvLyBJdCdzIGEgbnVtYmVyLCB0aGF0J3MgY29vbCAtIGJ1dCB3ZSBuZWVkIGl0IGFzIGEgc3RyaW5nIHNvIGl0IGRvZXNuJ3Qgc2NyZXdcbiAgICAgICAgLy8gd2l0aCB0aGUgdXNlciB3aGVuIGVudGVyaW5nIGRvbGxhciBhbW91bnRzIG9yIG90aGVyIHZhbHVlcyAoc3VjaCBhcyB0aG9zZSB3aXRoXG4gICAgICAgIC8vIHNwZWNpZmljIHByZWNpc2lvbiBvciBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBOdW1iZXIodmFsdWUpO1xuICAgIGNvbnN0IHZhbGlkID0gdHlwZW9mIG4gPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4obik7XG4gICAgcmV0dXJuIHZhbGlkID8gbiA6IHZhbHVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNOdW1iZXIuanMubWFwIiwiaW1wb3J0IGdldFVpT3B0aW9ucyBmcm9tICcuL2dldFVpT3B0aW9ucyc7XG4vKiogQ2hlY2tzIHdoZXRoZXIgdGhlIGZpZWxkIGRlc2NyaWJlZCBieSBgc2NoZW1hYCwgaGF2aW5nIHRoZSBgdWlTY2hlbWFgIGFuZCBgZm9ybURhdGFgIHN1cHBvcnRzIGV4cGFuZGluZy4gVGhlIFVJIGZvclxuICogdGhlIGZpZWxkIGNhbiBleHBhbmQgaWYgaXQgaGFzIGFkZGl0aW9uYWwgcHJvcGVydGllcywgaXMgbm90IGZvcmNlZCBhcyBub24tZXhwYW5kYWJsZSBieSB0aGUgYHVpU2NoZW1hYCBhbmQgdGhlXG4gKiBgZm9ybURhdGFgIG9iamVjdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBgc2NoZW1hLm1heFByb3BlcnRpZXNgIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB0aGUgZmllbGQgdGhhdCBpcyBiZWluZyBjaGVja2VkXG4gKiBAcGFyYW0gW3VpU2NoZW1hPXt9XSAtIFRoZSB1aVNjaGVtYSBmb3IgdGhlIGZpZWxkXG4gKiBAcGFyYW0gW2Zvcm1EYXRhXSAtIFRoZSBmb3JtRGF0YSBmb3IgdGhlIGZpZWxkXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHNjaGVtYSBlbGVtZW50IGhhcyBhZGRpdGlvbmFsUHJvcGVydGllcywgaXMgZXhwYW5kYWJsZSwgYW5kIG5vdCBhdCB0aGUgbWF4UHJvcGVydGllcyBsaW1pdFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYW5FeHBhbmQoc2NoZW1hLCB1aVNjaGVtYSA9IHt9LCBmb3JtRGF0YSkge1xuICAgIGlmICghc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBleHBhbmRhYmxlID0gdHJ1ZSB9ID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgICBpZiAoZXhwYW5kYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGFibGU7XG4gICAgfVxuICAgIC8vIGlmIHVpOm9wdGlvbnMuZXhwYW5kYWJsZSB3YXMgbm90IGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLCB3ZSBjYW4gYWRkXG4gICAgLy8gYW5vdGhlciBwcm9wZXJ0eSBpZiB3ZSBoYXZlIG5vdCBleGNlZWRlZCBtYXhQcm9wZXJ0aWVzIHlldFxuICAgIGlmIChzY2hlbWEubWF4UHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICYmIGZvcm1EYXRhKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmb3JtRGF0YSkubGVuZ3RoIDwgc2NoZW1hLm1heFByb3BlcnRpZXM7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuRXhwYW5kLmpzLm1hcCIsIi8qKiBCZWxvdyBhcmUgdGhlIGxpc3Qgb2YgYWxsIHRoZSBrZXlzIGludG8gdmFyaW91cyBlbGVtZW50cyBvZiBhIFJKU0ZTY2hlbWEgb3IgVWlTY2hlbWEgdGhhdCBhcmUgdXNlZCBieSB0aGUgdmFyaW91c1xuICogdXRpbGl0eSBmdW5jdGlvbnMuIEluIGFkZGl0aW9uIHRvIHRob3NlIGtleXMsIHRoZXJlIGFyZSB0aGUgc3BlY2lhbCBgQURESVRJT05BTF9QUk9QRVJUWV9GTEFHYCBhbmRcbiAqIGBSSlNGX0FERElUT05BTF9QUk9QRVJUSUVTX0ZMQUdgIGZsYWdzIHRoYXQgaXMgYWRkZWQgdG8gYSBzY2hlbWEgdW5kZXIgY2VydGFpbiBjb25kaXRpb25zIGJ5IHRoZSBgcmV0cmlldmVTY2hlbWEoKWBcbiAqIHV0aWxpdHkuXG4gKi9cbmV4cG9ydCBjb25zdCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcgPSAnX19hZGRpdGlvbmFsX3Byb3BlcnR5JztcbmV4cG9ydCBjb25zdCBBRERJVElPTkFMX1BST1BFUlRJRVNfS0VZID0gJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbmV4cG9ydCBjb25zdCBBTExfT0ZfS0VZID0gJ2FsbE9mJztcbmV4cG9ydCBjb25zdCBBTllfT0ZfS0VZID0gJ2FueU9mJztcbmV4cG9ydCBjb25zdCBDT05TVF9LRVkgPSAnY29uc3QnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfS0VZID0gJ2RlZmF1bHQnO1xuZXhwb3J0IGNvbnN0IERFRklOSVRJT05TX0tFWSA9ICdkZWZpbml0aW9ucyc7XG5leHBvcnQgY29uc3QgREVQRU5ERU5DSUVTX0tFWSA9ICdkZXBlbmRlbmNpZXMnO1xuZXhwb3J0IGNvbnN0IEVOVU1fS0VZID0gJ2VudW0nO1xuZXhwb3J0IGNvbnN0IEVSUk9SU19LRVkgPSAnX19lcnJvcnMnO1xuZXhwb3J0IGNvbnN0IElEX0tFWSA9ICckaWQnO1xuZXhwb3J0IGNvbnN0IElGX0tFWSA9ICdpZic7XG5leHBvcnQgY29uc3QgSVRFTVNfS0VZID0gJ2l0ZW1zJztcbmV4cG9ydCBjb25zdCBKVU5LX09QVElPTl9JRCA9ICdfJGp1bmtfb3B0aW9uX3NjaGVtYV9pZCRfJztcbmV4cG9ydCBjb25zdCBOQU1FX0tFWSA9ICckbmFtZSc7XG5leHBvcnQgY29uc3QgT05FX09GX0tFWSA9ICdvbmVPZic7XG5leHBvcnQgY29uc3QgUFJPUEVSVElFU19LRVkgPSAncHJvcGVydGllcyc7XG5leHBvcnQgY29uc3QgUkVRVUlSRURfS0VZID0gJ3JlcXVpcmVkJztcbmV4cG9ydCBjb25zdCBTVUJNSVRfQlROX09QVElPTlNfS0VZID0gJ3N1Ym1pdEJ1dHRvbk9wdGlvbnMnO1xuZXhwb3J0IGNvbnN0IFJFRl9LRVkgPSAnJHJlZic7XG5leHBvcnQgY29uc3QgUkpTRl9BRERJVE9OQUxfUFJPUEVSVElFU19GTEFHID0gJ19fcmpzZl9hZGRpdGlvbmFsUHJvcGVydGllcyc7XG5leHBvcnQgY29uc3QgUk9PVF9TQ0hFTUFfUFJFRklYID0gJ19fcmpzZl9yb290U2NoZW1hJztcbmV4cG9ydCBjb25zdCBVSV9GSUVMRF9LRVkgPSAndWk6ZmllbGQnO1xuZXhwb3J0IGNvbnN0IFVJX1dJREdFVF9LRVkgPSAndWk6d2lkZ2V0JztcbmV4cG9ydCBjb25zdCBVSV9PUFRJT05TX0tFWSA9ICd1aTpvcHRpb25zJztcbmV4cG9ydCBjb25zdCBVSV9HTE9CQUxfT1BUSU9OU19LRVkgPSAndWk6Z2xvYmFsT3B0aW9ucyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHsgRVJST1JTX0tFWSB9IGZyb20gJy4vY29uc3RhbnRzJztcbi8qKiBHaXZlbiBhIGBmb3JtRGF0YWAgb2JqZWN0LCByZWN1cnNpdmVseSBjcmVhdGVzIGEgYEZvcm1WYWxpZGF0aW9uYCBlcnJvciBoYW5kbGluZyBzdHJ1Y3R1cmUgYXJvdW5kIGl0XG4gKlxuICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIGZvcm0gZGF0YSBhcm91bmQgd2hpY2ggdGhlIGVycm9yIGhhbmRsZXIgaXMgY3JlYXRlZFxuICogQHJldHVybnMgLSBBIGBGb3JtVmFsaWRhdGlvbmAgb2JqZWN0IGJhc2VkIG9uIHRoZSBgZm9ybURhdGFgIHN0cnVjdHVyZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVFcnJvckhhbmRsZXIoZm9ybURhdGEpIHtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICAvLyBXZSBzdG9yZSB0aGUgbGlzdCBvZiBlcnJvcnMgZm9yIHRoaXMgbm9kZSBpbiBhIHByb3BlcnR5IG5hbWVkIF9fZXJyb3JzXG4gICAgICAgIC8vIHRvIGF2b2lkIG5hbWUgY29sbGlzaW9uIHdpdGggYSBwb3NzaWJsZSBzdWIgc2NoZW1hIGZpZWxkIG5hbWVkXG4gICAgICAgIC8vICdlcnJvcnMnIChzZWUgYHV0aWxzLnRvRXJyb3JTY2hlbWFgKS5cbiAgICAgICAgW0VSUk9SU19LRVldOiBbXSxcbiAgICAgICAgYWRkRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpc1tFUlJPUlNfS0VZXS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybURhdGEpKSB7XG4gICAgICAgIHJldHVybiBmb3JtRGF0YS5yZWR1Y2UoKGFjYywgdmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCBba2V5XTogY3JlYXRlRXJyb3JIYW5kbGVyKHZhbHVlKSB9O1xuICAgICAgICB9LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoZm9ybURhdGEpKSB7XG4gICAgICAgIGNvbnN0IGZvcm1PYmplY3QgPSBmb3JtRGF0YTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGZvcm1PYmplY3QpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IGNyZWF0ZUVycm9ySGFuZGxlcihmb3JtT2JqZWN0W2tleV0pIH07XG4gICAgICAgIH0sIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUVycm9ySGFuZGxlci5qcy5tYXAiLCJpbXBvcnQgZGVlcEVxdWFscyBmcm9tICcuL2RlZXBFcXVhbHMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdEZvcm1TdGF0ZSwgZ2V0RGlzcGxheUxhYmVsLCBnZXRDbG9zZXN0TWF0Y2hpbmdPcHRpb24sIGdldEZpcnN0TWF0Y2hpbmdPcHRpb24sIGdldE1hdGNoaW5nT3B0aW9uLCBpc0ZpbGVzQXJyYXksIGlzTXVsdGlTZWxlY3QsIGlzU2VsZWN0LCBtZXJnZVZhbGlkYXRpb25EYXRhLCByZXRyaWV2ZVNjaGVtYSwgc2FuaXRpemVEYXRhRm9yTmV3U2NoZW1hLCB0b0lkU2NoZW1hLCB0b1BhdGhTY2hlbWEsIH0gZnJvbSAnLi9zY2hlbWEnO1xuLyoqIFRoZSBgU2NoZW1hVXRpbHNgIGNsYXNzIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgdGhlIHB1YmxpY2x5IGV4cG9ydGVkIEFQSXMgaW4gdGhlIGB1dGlscy9zY2hlbWFgIGRpcmVjdG9yeSBzdWNoXG4gKiB0aGF0IG9uZSBkb2VzIG5vdCBoYXZlIHRvIGV4cGxpY2l0bHkgcGFzcyB0aGUgYHZhbGlkYXRvcmAsIGByb290U2NoZW1hYCwgb3IgYGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3JgIHRvIGVhY2ggbWV0aG9kLlxuICogU2luY2UgdGhlc2UgZ2VuZXJhbGx5IGRvIG5vdCBjaGFuZ2UgYWNyb3NzIGEgYEZvcm1gLCB0aGlzIGFsbG93cyBmb3IgcHJvdmlkaW5nIGEgc2ltcGxpZmllZCBzZXQgb2YgQVBJcyB0byB0aGVcbiAqIGBAcmpzZi9jb3JlYCBjb21wb25lbnRzIGFuZCB0aGUgdmFyaW91cyB0aGVtZXMgYXMgd2VsbC4gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBgU2NoZW1hVXRpbHNUeXBlYCBpbnRlcmZhY2UuXG4gKi9cbmNsYXNzIFNjaGVtYVV0aWxzIHtcbiAgICAvKiogQ29uc3RydWN0cyB0aGUgYFNjaGVtYVV0aWxzYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBgdmFsaWRhdG9yYCBhbmQgYHJvb3RTY2hlbWFgIHN0b3JlZCBhcyBpbnN0YW5jZSB2YXJpYWJsZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICAgICAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIHRoZSBBUElzXG4gICAgICogQHBhcmFtIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IgLSBDb25maWd1cmF0aW9uIGZsYWdzIHRvIGFsbG93IHVzZXJzIHRvIG92ZXJyaWRlIGRlZmF1bHQgZm9ybSBzdGF0ZSBiZWhhdmlvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcikge1xuICAgICAgICB0aGlzLnJvb3RTY2hlbWEgPSByb290U2NoZW1hO1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICAgICAgdGhpcy5leHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yID0gZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcjtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbiB0aGUgYFNjaGVtYVV0aWxzVHlwZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGBWYWxpZGF0b3JUeXBlYFxuICAgICAqL1xuICAgIGdldFZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yO1xuICAgIH1cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIGVpdGhlciB0aGUgYHZhbGlkYXRvcmAgYW5kIGByb290U2NoZW1hYCBkaWZmZXIgZnJvbSB0aGUgb25lcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZSBvZlxuICAgICAqIHRoZSBgU2NoZW1hVXRpbHNUeXBlYC4gSWYgZWl0aGVyIGB2YWxpZGF0b3JgIG9yIGByb290U2NoZW1hYCBhcmUgZmFsc3ksIHRoZW4gcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgdGhlIGNyZWF0aW9uXG4gICAgICogb2YgYSBuZXcgYFNjaGVtYVV0aWxzVHlwZWAgd2l0aCBpbmNvbXBsZXRlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yIC0gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIGN1cnJlbnQgb25lXG4gICAgICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdGhhdCB3aWxsIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIGN1cnJlbnQgb25lXG4gICAgICogQHBhcmFtIFtleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCwgaWYgcHJvdmlkZWQsIGFsbG93cyB1c2VycyB0byBvdmVycmlkZSBkZWZhdWx0IGZvcm0gc3RhdGUgYmVoYXZpb3JcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGBTY2hlbWFVdGlsc1R5cGVgIGRpZmZlcnMgZnJvbSB0aGUgZ2l2ZW4gYHZhbGlkYXRvcmAgb3IgYHJvb3RTY2hlbWFgXG4gICAgICovXG4gICAgZG9lc1NjaGVtYVV0aWxzRGlmZmVyKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvciA9IHt9KSB7XG4gICAgICAgIGlmICghdmFsaWRhdG9yIHx8ICFyb290U2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbGlkYXRvciAhPT0gdmFsaWRhdG9yIHx8XG4gICAgICAgICAgICAhZGVlcEVxdWFscyh0aGlzLnJvb3RTY2hlbWEsIHJvb3RTY2hlbWEpIHx8XG4gICAgICAgICAgICAhZGVlcEVxdWFscyh0aGlzLmV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IsIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IpKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIHN1cGVyc2V0IG9mIGBmb3JtRGF0YWAgdGhhdCBpbmNsdWRlcyB0aGUgZ2l2ZW4gc2V0IHVwZGF0ZWQgdG8gaW5jbHVkZSBhbnkgbWlzc2luZyBmaWVsZHMgdGhhdCBoYXZlXG4gICAgICogY29tcHV0ZWQgdG8gaGF2ZSBkZWZhdWx0cyBwcm92aWRlZCBpbiB0aGUgYHNjaGVtYWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIGRlZmF1bHQgc3RhdGUgaXMgZGVzaXJlZFxuICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgb250byB3aGljaCB0byBwcm92aWRlIGFueSBtaXNzaW5nIGRlZmF1bHRzXG4gICAgICogQHBhcmFtIFtpbmNsdWRlVW5kZWZpbmVkVmFsdWVzPWZhbHNlXSAtIE9wdGlvbmFsIGZsYWcsIGlmIHRydWUsIGNhdXNlIHVuZGVmaW5lZCB2YWx1ZXMgdG8gYmUgYWRkZWQgYXMgZGVmYXVsdHMuXG4gICAgICogICAgICAgICAgSWYgXCJleGNsdWRlT2JqZWN0Q2hpbGRyZW5cIiwgcGFzcyBgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc2AgYXMgZmFsc2Ugd2hlbiBjb21wdXRpbmcgZGVmYXVsdHMgZm9yIGFueSBuZXN0ZWRcbiAgICAgKiAgICAgICAgICBvYmplY3QgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSByZXN1bHRpbmcgYGZvcm1EYXRhYCB3aXRoIGFsbCB0aGUgZGVmYXVsdHMgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Rm9ybVN0YXRlKHNjaGVtYSwgZm9ybURhdGEsIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdEZvcm1TdGF0ZSh0aGlzLnZhbGlkYXRvciwgc2NoZW1hLCBmb3JtRGF0YSwgdGhpcy5yb290U2NoZW1hLCBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzLCB0aGlzLmV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IpO1xuICAgIH1cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21iaW5hdGlvbiBvZiBgc2NoZW1hYCBhbmQgYHVpU2NoZW1hYCBwcm9wZXJ0aWVzIGluZGljYXRlcyB0aGF0IHRoZSBsYWJlbCBmb3IgdGhlIGBzY2hlbWFgXG4gICAgICogc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBhIFVJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHRoZSBkaXNwbGF5IGxhYmVsIGZsYWcgaXMgZGVzaXJlZFxuICAgICAqIEBwYXJhbSBbdWlTY2hlbWFdIC0gVGhlIFVJIHNjaGVtYSBmcm9tIHdoaWNoIHRvIGRlcml2ZSBwb3RlbnRpYWxseSBkaXNwbGF5YWJsZSBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBbZ2xvYmFsT3B0aW9ucz17fV0gLSBUaGUgb3B0aW9uYWwgR2xvYmFsIFVJIFNjaGVtYSBmcm9tIHdoaWNoIHRvIGdldCBhbnkgZmFsbGJhY2sgYHh4eGAgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCBvciBmYWxzZSBpZiBpdCBzaG91bGQgbm90XG4gICAgICovXG4gICAgZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIGdsb2JhbE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc3BsYXlMYWJlbCh0aGlzLnZhbGlkYXRvciwgc2NoZW1hLCB1aVNjaGVtYSwgdGhpcy5yb290U2NoZW1hLCBnbG9iYWxPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIGdpdmVuIGBvcHRpb25zYCBwcm92aWRlZCBtb3N0IGNsb3NlbHkgbWF0Y2hlcyB0aGUgYGZvcm1EYXRhYC5cbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgb3B0aW9uIHRoYXQgaXMgdmFsaWQgYW5kIGlzIHRoZSBjbG9zZXN0IG1hdGNoLCBvciAwIGlmIHRoZXJlIGlzIG5vIG1hdGNoLlxuICAgICAqXG4gICAgICogVGhlIGNsb3Nlc3QgbWF0Y2ggaXMgZGV0ZXJtaW5lZCB1c2luZyB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIHByb3BlcnRpZXMsIGFuZCBtb3JlIGhlYXZpbHkgZmF2b3JzIG9wdGlvbnMgd2l0aFxuICAgICAqIG1hdGNoaW5nIHJlYWRPbmx5LCBkZWZhdWx0LCBvciBjb25zdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgZm9ybSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2NoZW1hXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbGlzdCBvZiBvcHRpb25zIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGZyb21cbiAgICAgKiBAcGFyYW0gW3NlbGVjdGVkT3B0aW9uXSAtIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbiwgZGVmYXVsdGVkIHRvIC0xIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0gW2Rpc2NyaW1pbmF0b3JGaWVsZF0gLSBUaGUgb3B0aW9uYWwgbmFtZSBvZiB0aGUgZmllbGQgd2l0aGluIHRoZSBvcHRpb25zIG9iamVjdCB3aG9zZSB2YWx1ZSBpcyB1c2VkIHRvXG4gICAgICogICAgICAgICAgZGV0ZXJtaW5lIHdoaWNoIG9wdGlvbiBpcyBzZWxlY3RlZFxuICAgICAqIEByZXR1cm5zIC0gVGhlIGluZGV4IG9mIHRoZSBvcHRpb24gdGhhdCBpcyB0aGUgY2xvc2VzdCBtYXRjaCB0byB0aGUgYGZvcm1EYXRhYCBvciB0aGUgYHNlbGVjdGVkT3B0aW9uYCBpZiBubyBtYXRjaFxuICAgICAqL1xuICAgIGdldENsb3Nlc3RNYXRjaGluZ09wdGlvbihmb3JtRGF0YSwgb3B0aW9ucywgc2VsZWN0ZWRPcHRpb24sIGRpc2NyaW1pbmF0b3JGaWVsZCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2xvc2VzdE1hdGNoaW5nT3B0aW9uKHRoaXMudmFsaWRhdG9yLCB0aGlzLnJvb3RTY2hlbWEsIGZvcm1EYXRhLCBvcHRpb25zLCBzZWxlY3RlZE9wdGlvbiwgZGlzY3JpbWluYXRvckZpZWxkKTtcbiAgICB9XG4gICAgLyoqIEdpdmVuIHRoZSBgZm9ybURhdGFgIGFuZCBsaXN0IG9mIGBvcHRpb25zYCwgYXR0ZW1wdHMgdG8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9wdGlvbiB0aGF0IG1hdGNoZXMgdGhlIGRhdGEuXG4gICAgICogQWx3YXlzIHJldHVybnMgdGhlIGZpcnN0IG9wdGlvbiBpZiB0aGVyZSBpcyBub3RoaW5nIHRoYXQgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBjdXJyZW50IGZvcm1EYXRhLCBpZiBhbnksIHVzZWQgdG8gZmlndXJlIG91dCBhIG1hdGNoXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbGlzdCBvZiBvcHRpb25zIHRvIGZpbmQgYSBtYXRjaGluZyBvcHRpb25zIGZyb21cbiAgICAgKiBAcGFyYW0gW2Rpc2NyaW1pbmF0b3JGaWVsZF0gLSBUaGUgb3B0aW9uYWwgbmFtZSBvZiB0aGUgZmllbGQgd2l0aGluIHRoZSBvcHRpb25zIG9iamVjdCB3aG9zZSB2YWx1ZSBpcyB1c2VkIHRvXG4gICAgICogICAgICAgICAgZGV0ZXJtaW5lIHdoaWNoIG9wdGlvbiBpcyBzZWxlY3RlZFxuICAgICAqIEByZXR1cm5zIC0gVGhlIGZpcnN0aW5kZXggb2YgdGhlIG1hdGNoZWQgb3B0aW9uIG9yIDAgaWYgbm9uZSBpcyBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBnZXRGaXJzdE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCBvcHRpb25zLCBkaXNjcmltaW5hdG9yRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGdldEZpcnN0TWF0Y2hpbmdPcHRpb24odGhpcy52YWxpZGF0b3IsIGZvcm1EYXRhLCBvcHRpb25zLCB0aGlzLnJvb3RTY2hlbWEsIGRpc2NyaW1pbmF0b3JGaWVsZCk7XG4gICAgfVxuICAgIC8qKiBHaXZlbiB0aGUgYGZvcm1EYXRhYCBhbmQgbGlzdCBvZiBgb3B0aW9uc2AsIGF0dGVtcHRzIHRvIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBvcHRpb24gdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGRhdGEuXG4gICAgICogRGVwcmVjYXRlZCwgdXNlIGBnZXRGaXJzdE1hdGNoaW5nT3B0aW9uKClgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCBvbnRvIHdoaWNoIHRvIHByb3ZpZGUgYW55IG1pc3NpbmcgZGVmYXVsdHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBsaXN0IG9mIG9wdGlvbnMgdG8gZmluZCBhIG1hdGNoaW5nIG9wdGlvbnMgZnJvbVxuICAgICAqIEBwYXJhbSBbZGlzY3JpbWluYXRvckZpZWxkXSAtIFRoZSBvcHRpb25hbCBuYW1lIG9mIHRoZSBmaWVsZCB3aXRoaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHVzZWQgdG9cbiAgICAgKiAgICAgICAgICBkZXRlcm1pbmUgd2hpY2ggb3B0aW9uIGlzIHNlbGVjdGVkXG4gICAgICogQHJldHVybnMgLSBUaGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgb3B0aW9uIG9yIDAgaWYgbm9uZSBpcyBhdmFpbGFibGVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCBvcHRpb25zLCBkaXNjcmltaW5hdG9yRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGdldE1hdGNoaW5nT3B0aW9uKHRoaXMudmFsaWRhdG9yLCBmb3JtRGF0YSwgb3B0aW9ucywgdGhpcy5yb290U2NoZW1hLCBkaXNjcmltaW5hdG9yRmllbGQpO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgYHNjaGVtYWAgYW5kIGB1aVNjaGVtYWAgY29tYmluYXRpb24gcmVwcmVzZW50cyBhbiBhcnJheSBvZiBmaWxlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIGNoZWNrIGZvciBhcnJheSBvZiBmaWxlcyBmbGFnIGlzIGRlc2lyZWRcbiAgICAgKiBAcGFyYW0gW3VpU2NoZW1hXSAtIFRoZSBVSSBzY2hlbWEgZnJvbSB3aGljaCB0byBjaGVjayB0aGUgd2lkZ2V0XG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHNjaGVtYS91aVNjaGVtYSBjb250YWlucyBhbiBhcnJheSBvZiBmaWxlcywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgaXNGaWxlc0FycmF5KHNjaGVtYSwgdWlTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGlzRmlsZXNBcnJheSh0aGlzLnZhbGlkYXRvciwgc2NoZW1hLCB1aVNjaGVtYSwgdGhpcy5yb290U2NoZW1hKTtcbiAgICB9XG4gICAgLyoqIENoZWNrcyB0byBzZWUgaWYgdGhlIGBzY2hlbWFgIGNvbWJpbmF0aW9uIHJlcHJlc2VudHMgYSBtdWx0aS1zZWxlY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCBjaGVjayBmb3IgYSBtdWx0aS1zZWxlY3QgZmxhZyBpcyBkZXNpcmVkXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHNjaGVtYSBjb250YWlucyBhIG11bHRpLXNlbGVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgaXNNdWx0aVNlbGVjdChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGlzTXVsdGlTZWxlY3QodGhpcy52YWxpZGF0b3IsIHNjaGVtYSwgdGhpcy5yb290U2NoZW1hKTtcbiAgICB9XG4gICAgLyoqIENoZWNrcyB0byBzZWUgaWYgdGhlIGBzY2hlbWFgIGNvbWJpbmF0aW9uIHJlcHJlc2VudHMgYSBzZWxlY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCBjaGVjayBmb3IgYSBzZWxlY3QgZmxhZyBpcyBkZXNpcmVkXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHNjaGVtYSBjb250YWlucyBhIHNlbGVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgaXNTZWxlY3Qoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBpc1NlbGVjdCh0aGlzLnZhbGlkYXRvciwgc2NoZW1hLCB0aGlzLnJvb3RTY2hlbWEpO1xuICAgIH1cbiAgICAvKiogTWVyZ2VzIHRoZSBlcnJvcnMgaW4gYGFkZGl0aW9uYWxFcnJvclNjaGVtYWAgaW50byB0aGUgZXhpc3RpbmcgYHZhbGlkYXRpb25EYXRhYCBieSBjb21iaW5pbmcgdGhlIGhpZXJhcmNoaWVzIGluXG4gICAgICogdGhlIHR3byBgRXJyb3JTY2hlbWFgcyBhbmQgdGhlbiBhcHBlbmRpbmcgdGhlIGVycm9yIGxpc3QgZnJvbSB0aGUgYGFkZGl0aW9uYWxFcnJvclNjaGVtYWAgb2J0YWluZWQgYnkgY2FsbGluZ1xuICAgICAqIGBnZXRWYWxpZGF0b3IoKS50b0Vycm9yTGlzdCgpYCBvbnRvIHRoZSBgZXJyb3JzYCBpbiB0aGUgYHZhbGlkYXRpb25EYXRhYC4gSWYgbm8gYGFkZGl0aW9uYWxFcnJvclNjaGVtYWAgaXMgcGFzc2VkLFxuICAgICAqIHRoZW4gYHZhbGlkYXRpb25EYXRhYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0aW9uRGF0YSAtIFRoZSBjdXJyZW50IGBWYWxpZGF0aW9uRGF0YWAgaW50byB3aGljaCB0byBtZXJnZSB0aGUgYWRkaXRpb25hbCBlcnJvcnNcbiAgICAgKiBAcGFyYW0gW2FkZGl0aW9uYWxFcnJvclNjaGVtYV0gLSBUaGUgYWRkaXRpb25hbCBzZXQgb2YgZXJyb3JzXG4gICAgICogQHJldHVybnMgLSBUaGUgYHZhbGlkYXRpb25EYXRhYCB3aXRoIHRoZSBhZGRpdGlvbmFsIGVycm9ycyBmcm9tIGBhZGRpdGlvbmFsRXJyb3JTY2hlbWFgIG1lcmdlZCBpbnRvIGl0LCBpZiBwcm92aWRlZC5cbiAgICAgKiBAZGVwcmVjYXRlZCAtIFVzZSB0aGUgYHZhbGlkYXRpb25EYXRhTWVyZ2UoKWAgZnVuY3Rpb24gZXhwb3J0ZWQgZnJvbSBgQHJqc2YvdXRpbHNgIGluc3RlYWQuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAqICAgICAgICByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICovXG4gICAgbWVyZ2VWYWxpZGF0aW9uRGF0YSh2YWxpZGF0aW9uRGF0YSwgYWRkaXRpb25hbEVycm9yU2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBtZXJnZVZhbGlkYXRpb25EYXRhKHRoaXMudmFsaWRhdG9yLCB2YWxpZGF0aW9uRGF0YSwgYWRkaXRpb25hbEVycm9yU2NoZW1hKTtcbiAgICB9XG4gICAgLyoqIFJldHJpZXZlcyBhbiBleHBhbmRlZCBzY2hlbWEgdGhhdCBoYXMgaGFkIGFsbCBvZiBpdHMgY29uZGl0aW9ucywgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCByZWZlcmVuY2VzIGFuZFxuICAgICAqIGRlcGVuZGVuY2llcyByZXNvbHZlZCBhbmQgbWVyZ2VkIGludG8gdGhlIGBzY2hlbWFgIGdpdmVuIGEgYHJhd0Zvcm1EYXRhYCB0aGF0IGlzIHVzZWQgdG8gZG8gdGhlIHBvdGVudGlhbGx5XG4gICAgICogcmVjdXJzaXZlIHJlc29sdXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggcmV0cmlldmluZyBhIHNjaGVtYSBpcyBkZXNpcmVkXG4gICAgICogQHBhcmFtIFtyYXdGb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICAgICAqIEByZXR1cm5zIC0gVGhlIHNjaGVtYSBoYXZpbmcgaXRzIGNvbmRpdGlvbnMsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgcmVmZXJlbmNlcyBhbmQgZGVwZW5kZW5jaWVzIHJlc29sdmVkXG4gICAgICovXG4gICAgcmV0cmlldmVTY2hlbWEoc2NoZW1hLCByYXdGb3JtRGF0YSkge1xuICAgICAgICByZXR1cm4gcmV0cmlldmVTY2hlbWEodGhpcy52YWxpZGF0b3IsIHNjaGVtYSwgdGhpcy5yb290U2NoZW1hLCByYXdGb3JtRGF0YSk7XG4gICAgfVxuICAgIC8qKiBTYW5pdGl6ZSB0aGUgYGRhdGFgIGFzc29jaWF0ZWQgd2l0aCB0aGUgYG9sZFNjaGVtYWAgc28gaXQgaXMgY29uc2lkZXJlZCBhcHByb3ByaWF0ZSBmb3IgdGhlIGBuZXdTY2hlbWFgLiBJZiB0aGVcbiAgICAgKiBuZXcgc2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gYW55IHByb3BlcnRpZXMsIHRoZW4gYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgdG8gY2xlYXIgYWxsIHRoZSBmb3JtIGRhdGEuIER1ZSB0byB0aGVcbiAgICAgKiBuYXR1cmUgb2Ygc2NoZW1hcywgdGhpcyBzYW5pdGl6YXRpb24gaGFwcGVucyByZWN1cnNpdmVseSBmb3IgbmVzdGVkIG9iamVjdHMgb2YgZGF0YS4gQWxzbywgYW55IHByb3BlcnRpZXMgaW4gdGhlXG4gICAgICogb2xkIHNjaGVtYXMgdGhhdCBhcmUgbm9uLWV4aXN0ZW50IGluIHRoZSBuZXcgc2NoZW1hIGFyZSBzZXQgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW25ld1NjaGVtYV0gLSBUaGUgbmV3IHNjaGVtYSBmb3Igd2hpY2ggdGhlIGRhdGEgaXMgYmVpbmcgc2FuaXRpemVkXG4gICAgICogQHBhcmFtIFtvbGRTY2hlbWFdIC0gVGhlIG9sZCBzY2hlbWEgZnJvbSB3aGljaCB0aGUgZGF0YSBvcmlnaW5hdGVkXG4gICAgICogQHBhcmFtIFtkYXRhPXt9XSAtIFRoZSBmb3JtIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBzY2hlbWEsIGRlZmF1bHRpbmcgdG8gYW4gZW1wdHkgb2JqZWN0IHdoZW4gdW5kZWZpbmVkXG4gICAgICogQHJldHVybnMgLSBUaGUgbmV3IGZvcm0gZGF0YSwgd2l0aCBhbGwgdGhlIGZpZWxkcyB1bmlxdWVseSBhc3NvY2lhdGVkIHdpdGggdGhlIG9sZCBzY2hlbWEgc2V0XG4gICAgICogICAgICB0byBgdW5kZWZpbmVkYC4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIG5ldyBzY2hlbWEgaXMgbm90IGFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2FuaXRpemVEYXRhRm9yTmV3U2NoZW1hKG5ld1NjaGVtYSwgb2xkU2NoZW1hLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBzYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEodGhpcy52YWxpZGF0b3IsIHRoaXMucm9vdFNjaGVtYSwgbmV3U2NoZW1hLCBvbGRTY2hlbWEsIGRhdGEpO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIGFuIGBJZFNjaGVtYWAgb2JqZWN0IGZvciB0aGUgYHNjaGVtYWAsIHJlY3Vyc2l2ZWx5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIGRpc3BsYXkgbGFiZWwgZmxhZyBpcyBkZXNpcmVkXG4gICAgICogQHBhcmFtIFtpZF0gLSBUaGUgYmFzZSBpZCBmb3IgdGhlIHNjaGVtYVxuICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgb250byB3aGljaCB0byBwcm92aWRlIGFueSBtaXNzaW5nIGRlZmF1bHRzXG4gICAgICogQHBhcmFtIFtpZFByZWZpeD0ncm9vdCddIC0gVGhlIHByZWZpeCB0byB1c2UgZm9yIHRoZSBpZFxuICAgICAqIEBwYXJhbSBbaWRTZXBhcmF0b3I9J18nXSAtIFRoZSBzZXBhcmF0b3IgdG8gdXNlIGZvciB0aGUgcGF0aCBzZWdtZW50cyBpbiB0aGUgaWRcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBgSWRTY2hlbWFgIG9iamVjdCBmb3IgdGhlIGBzY2hlbWFgXG4gICAgICovXG4gICAgdG9JZFNjaGVtYShzY2hlbWEsIGlkLCBmb3JtRGF0YSwgaWRQcmVmaXggPSAncm9vdCcsIGlkU2VwYXJhdG9yID0gJ18nKSB7XG4gICAgICAgIHJldHVybiB0b0lkU2NoZW1hKHRoaXMudmFsaWRhdG9yLCBzY2hlbWEsIGlkLCB0aGlzLnJvb3RTY2hlbWEsIGZvcm1EYXRhLCBpZFByZWZpeCwgaWRTZXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIGFuIGBQYXRoU2NoZW1hYCBvYmplY3QgZm9yIHRoZSBgc2NoZW1hYCwgcmVjdXJzaXZlbHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCB0aGUgZGlzcGxheSBsYWJlbCBmbGFnIGlzIGRlc2lyZWRcbiAgICAgKiBAcGFyYW0gW25hbWVdIC0gVGhlIGJhc2UgbmFtZSBmb3IgdGhlIHNjaGVtYVxuICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgb250byB3aGljaCB0byBwcm92aWRlIGFueSBtaXNzaW5nIGRlZmF1bHRzXG4gICAgICogQHJldHVybnMgLSBUaGUgYFBhdGhTY2hlbWFgIG9iamVjdCBmb3IgdGhlIGBzY2hlbWFgXG4gICAgICovXG4gICAgdG9QYXRoU2NoZW1hKHNjaGVtYSwgbmFtZSwgZm9ybURhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRvUGF0aFNjaGVtYSh0aGlzLnZhbGlkYXRvciwgc2NoZW1hLCBuYW1lLCB0aGlzLnJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlcyBhIGBTY2hlbWFVdGlsc1R5cGVgIGludGVyZmFjZSB0aGF0IGlzIGJhc2VkIGFyb3VuZCB0aGUgZ2l2ZW4gYHZhbGlkYXRvcmAgYW5kIGByb290U2NoZW1hYCBwYXJhbWV0ZXJzLiBUaGVcbiAqIHJlc3VsdGluZyBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb24gd2lsbCBmb3J3YXJkIHRoZSBgdmFsaWRhdG9yYCBhbmQgYHJvb3RTY2hlbWFgIHRvIGFsbCB0aGUgd3JhcHBlZCBBUElzLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgdGhlIEFQSXNcbiAqIEBwYXJhbSBbZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcl0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QsIGlmIHByb3ZpZGVkLCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBmb3JtIHN0YXRlIGJlaGF2aW9yXG4gKiBAcmV0dXJucyAtIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgYFNjaGVtYVV0aWxzVHlwZWAgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYVV0aWxzKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvciA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlbWFVdGlscyh2YWxpZGF0b3IsIHJvb3RTY2hlbWEsIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU2NoZW1hVXRpbHMuanMubWFwIiwiLyoqIEdpdmVuIHRoZSBgRmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKClgIGJhc2VkIGBkYXRhVVJJYCBleHRyYWN0cyB0aGF0IGRhdGEgaW50byBhbiBhY3R1YWwgQmxvYiBhbG9uZyB3aXRoIHRoZSBuYW1lXG4gKiBvZiB0aGF0IEJsb2IgaWYgcHJvdmlkZWQgaW4gdGhlIFVSTC4gSWYgbm8gbmFtZSBpcyBwcm92aWRlZCwgdGhlbiB0aGUgbmFtZSBmYWxscyBiYWNrIHRvIGB1bmtub3duYC5cbiAqXG4gKiBAcGFyYW0gZGF0YVVSSSAtIFRoZSBgRGF0YVVybGAgcG90ZW50aWFsbHkgY29udGFpbmluZyBuYW1lIGFuZCByYXcgZGF0YSB0byBiZSBjb252ZXJ0ZWQgdG8gYSBCbG9iXG4gKiBAcmV0dXJucyAtIGFuIG9iamVjdCBjb250YWluaW5nIGEgQmxvYiBhbmQgaXRzIG5hbWUsIGV4dHJhY3RlZCBmcm9tIHRoZSBVUklcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGF0YVVSSXRvQmxvYihkYXRhVVJJKSB7XG4gICAgLy8gU3BsaXQgbWV0YWRhdGEgZnJvbSBkYXRhXG4gICAgY29uc3Qgc3BsaXR0ZWQgPSBkYXRhVVJJLnNwbGl0KCcsJyk7XG4gICAgLy8gU3BsaXQgcGFyYW1zXG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXR0ZWRbMF0uc3BsaXQoJzsnKTtcbiAgICAvLyBHZXQgbWltZS10eXBlIGZyb20gcGFyYW1zXG4gICAgY29uc3QgdHlwZSA9IHBhcmFtc1swXS5yZXBsYWNlKCdkYXRhOicsICcnKTtcbiAgICAvLyBGaWx0ZXIgdGhlIG5hbWUgcHJvcGVydHkgZnJvbSBwYXJhbXNcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcGFyYW1zLmZpbHRlcigocGFyYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLnNwbGl0KCc9JylbMF0gPT09ICduYW1lJztcbiAgICB9KTtcbiAgICAvLyBMb29rIGZvciB0aGUgbmFtZSBhbmQgdXNlIHVua25vd24gaWYgbm8gbmFtZSBwcm9wZXJ0eS5cbiAgICBsZXQgbmFtZTtcbiAgICBpZiAocHJvcGVydGllcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgbmFtZSA9ICd1bmtub3duJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEJlY2F1c2Ugd2UgZmlsdGVyZWQgb3V0IHRoZSBvdGhlciBwcm9wZXJ0eSxcbiAgICAgICAgLy8gd2Ugb25seSBoYXZlIHRoZSBuYW1lIGNhc2UgaGVyZSwgd2hpY2ggd2UgZGVjb2RlIHRvIG1ha2UgaXQgaHVtYW4tcmVhZGFibGVcbiAgICAgICAgbmFtZSA9IGRlY29kZVVSSShwcm9wZXJ0aWVzWzBdLnNwbGl0KCc9JylbMV0pO1xuICAgIH1cbiAgICAvLyBCdWlsdCB0aGUgVWludDhBcnJheSBCbG9iIHBhcmFtZXRlciBmcm9tIHRoZSBiYXNlNjQgc3RyaW5nLlxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeSA9IGF0b2Ioc3BsaXR0ZWRbMV0pO1xuICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaChiaW5hcnkuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBibG9iIG9iamVjdFxuICAgICAgICBjb25zdCBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFtuZXcgVWludDhBcnJheShhcnJheSldLCB7IHR5cGUgfSk7XG4gICAgICAgIHJldHVybiB7IGJsb2IsIG5hbWUgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGJsb2I6IHsgc2l6ZTogMCwgdHlwZTogZXJyb3IubWVzc2FnZSB9LCBuYW1lOiBkYXRhVVJJIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVVSSXRvQmxvYi5qcy5tYXAiLCJpbXBvcnQgaXNFcXVhbFdpdGggZnJvbSAnbG9kYXNoL2lzRXF1YWxXaXRoJztcbi8qKiBJbXBsZW1lbnRzIGEgZGVlcCBlcXVhbHMgdXNpbmcgdGhlIGBsb2Rhc2guaXNFcXVhbFdpdGhgIGZ1bmN0aW9uLCB0aGF0IHByb3ZpZGVzIGEgY3VzdG9taXplZCBjb21wYXJhdG9yIHRoYXRcbiAqIGFzc3VtZXMgYWxsIGZ1bmN0aW9ucyBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBlbGVtZW50IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBlbGVtZW50IHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgYGFgIGFuZCBgYmAgYXJlIGRlZXBseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZXBFcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBpc0VxdWFsV2l0aChhLCBiLCAob2JqLCBvdGhlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb3RoZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBhbGwgZnVuY3Rpb25zIGFyZSBlcXVpdmFsZW50XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Jqc2YtdGVhbS9yZWFjdC1qc29uc2NoZW1hLWZvcm0vaXNzdWVzLzI1NVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpc0VxdWFscyBiZWhhdmlvclxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVlcEVxdWFscy5qcy5tYXAiLCJpbXBvcnQgcmVwbGFjZVN0cmluZ1BhcmFtZXRlcnMgZnJvbSAnLi9yZXBsYWNlU3RyaW5nUGFyYW1ldGVycyc7XG4vKiogVHJhbnNsYXRlcyBhIGBUcmFuc2xhdGFibGVTdHJpbmdgIHZhbHVlIGBzdHJpbmdUb1RyYW5zbGF0ZWAgaW50byBlbmdsaXNoLiBXaGVuIGEgYHBhcmFtc2AgYXJyYXkgaXMgcHJvdmlkZWQsIGVhY2hcbiAqIHZhbHVlIGluIHRoZSBhcnJheSBpcyB1c2VkIHRvIHJlcGxhY2UgYW55IG9mIHRoZSByZXBsYWNlYWJsZSBwYXJhbWV0ZXJzIGluIHRoZSBgc3RyaW5nVG9UcmFuc2xhdGVgIHVzaW5nIHRoZSBgJTFgLFxuICogYCUyYCwgZXRjLiByZXBsYWNlbWVudCBzcGVjaWZpZXJzLlxuICpcbiAqIEBwYXJhbSBzdHJpbmdUb1RyYW5zbGF0ZSAtIFRoZSBgVHJhbnNsYXRhYmxlU3RyaW5nYCB2YWx1ZSB0byBjb252ZXJ0IHRvIGVuZ2xpc2hcbiAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgb3B0aW9uYWwgbGlzdCBvZiByZXBsYWNlYWJsZSBwYXJhbWV0ZXIgdmFsdWVzIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZW5nbGlzaCBzdHJpbmdcbiAqIEByZXR1cm5zIC0gVGhlIGBzdHJpbmdUb1RyYW5zbGF0ZWAgaXRzZWxmIHdpdGggYW55IHJlcGxhY2VhYmxlIHBhcmFtZXRlciB2YWx1ZXMgc3Vic3RpdHV0ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5nbGlzaFN0cmluZ1RyYW5zbGF0b3Ioc3RyaW5nVG9UcmFuc2xhdGUsIHBhcmFtcykge1xuICAgIHJldHVybiByZXBsYWNlU3RyaW5nUGFyYW1ldGVycyhzdHJpbmdUb1RyYW5zbGF0ZSwgcGFyYW1zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZ2xpc2hTdHJpbmdUcmFuc2xhdG9yLmpzLm1hcCIsImltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXggZnJvbSAnLi9lbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgnO1xuLyoqIFJlbW92ZXMgdGhlIGVudW0gb3B0aW9uIHZhbHVlIGF0IHRoZSBgdmFsdWVJbmRleGAgZnJvbSB0aGUgY3VycmVudGx5IGBzZWxlY3RlZGAgKGxpc3Qgb2YpIHZhbHVlKHMpLiBJZiBgc2VsZWN0ZWRgIGlzXG4gKiBhIGxpc3QsIHRoZW4gdGhhdCBsaXN0IGlzIHVwZGF0ZWQgdG8gcmVtb3ZlIHRoZSBlbnVtIG9wdGlvbiB2YWx1ZSB3aXRoIHRoZSBgdmFsdWVJbmRleGAgaW4gYGFsbEVudW1PcHRpb25zYC4gSWYgaXQgaXNcbiAqIGEgc2luZ2xlIHZhbHVlLCB0aGVuIGlmIHRoZSBlbnVtIG9wdGlvbiB2YWx1ZSB3aXRoIHRoZSBgdmFsdWVJbmRleGAgaW4gYGFsbEVudW1PcHRpb25zYCBtYXRjaGVzIGBzZWxlY3RlZGAsIHVuZGVmaW5lZFxuICogaXMgcmV0dXJuZWQsIG90aGVyd2lzZSB0aGUgYHNlbGVjdGVkYCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWVJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBzZWxlY3RlZCBsaXN0IG9yIHNpbmdsZSB2YWx1ZVxuICogQHBhcmFtIHNlbGVjdGVkIC0gVGhlIGN1cnJlbnQgKGxpc3Qgb2YpIHNlbGVjdGVkIHZhbHVlKHMpXG4gKiBAcGFyYW0gW2FsbEVudW1PcHRpb25zPVtdXSAtIFRoZSBsaXN0IG9mIGFsbCB0aGUga25vd24gZW51bU9wdGlvbnNcbiAqIEByZXR1cm5zIC0gVGhlIHVwZGF0ZWQgYHNlbGVjdGVkYCB3aXRoIHRoZSBlbnVtIG9wdGlvbiB2YWx1ZSBhdCBgdmFsdWVJbmRleGAgaW4gYGFsbEVudW1PcHRpb25zYCByZW1vdmVkIGZyb20gaXQsXG4gKiAgICAgICAgdW5sZXNzIGBzZWxlY3RlZGAgaXMgYSBzaW5nbGUgdmFsdWUuIEluIHRoYXQgY2FzZSwgaWYgdGhlIGB2YWx1ZUluZGV4YCB2YWx1ZSBtYXRjaGVzIGBzZWxlY3RlZGAsIHJldHVybnNcbiAqICAgICAgICB1bmRlZmluZWQsIG90aGVyd2lzZSBgc2VsZWN0ZWRgLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbnVtT3B0aW9uc0Rlc2VsZWN0VmFsdWUodmFsdWVJbmRleCwgc2VsZWN0ZWQsIGFsbEVudW1PcHRpb25zID0gW10pIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVudW1PcHRpb25zVmFsdWVGb3JJbmRleCh2YWx1ZUluZGV4LCBhbGxFbnVtT3B0aW9ucyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZC5maWx0ZXIoKHYpID0+ICFpc0VxdWFsKHYsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBpc0VxdWFsKHZhbHVlLCBzZWxlY3RlZCkgPyB1bmRlZmluZWQgOiBzZWxlY3RlZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW1PcHRpb25zRGVzZWxlY3RWYWx1ZS5qcy5tYXAiLCJpbXBvcnQgZW51bU9wdGlvbnNJc1NlbGVjdGVkIGZyb20gJy4vZW51bU9wdGlvbnNJc1NlbGVjdGVkJztcbi8qKiBSZXR1cm5zIHRoZSBpbmRleChlcykgb2YgdGhlIG9wdGlvbnMgaW4gYGFsbEVudW1PcHRpb25zYCB3aG9zZSB2YWx1ZShzKSBtYXRjaCB0aGUgb25lcyBpbiBgdmFsdWVgLiBBbGwgdGhlXG4gKiBgZW51bU9wdGlvbnNgIGFyZSBmaWx0ZXJlZCBiYXNlZCBvbiB3aGV0aGVyIHRoZXkgYXJlIGEgXCJzZWxlY3RlZFwiIGB2YWx1ZWAgYW5kIHRoZSBpbmRleCBvZiBlYWNoIHNlbGVjdGVkIG9uZSBpcyB0aGVuXG4gKiBzdG9yZWQgaW4gYW4gYXJyYXkuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhhdCBhcnJheSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHNpbmdsZSB2YWx1ZSBvciBsaXN0IG9mIHZhbHVlcyBmb3Igd2hpY2ggaW5kZXhlcyBhcmUgZGVzaXJlZFxuICogQHBhcmFtIFthbGxFbnVtT3B0aW9ucz1bXV0gLSBUaGUgbGlzdCBvZiBhbGwgdGhlIGtub3duIGVudW1PcHRpb25zXG4gKiBAcGFyYW0gW211bHRpcGxlPWZhbHNlXSAtIE9wdGlvbmFsIGZsYWcsIGlmIHRydWUgd2lsbCByZXR1cm4gYSBsaXN0IG9mIGluZGV4LCBvdGhlcndpc2UgYSBzaW5nbGUgb25lXG4gKiBAcmV0dXJucyAtIEEgc2luZ2xlIHN0cmluZyBpbmRleCBmb3IgdGhlIGZpcnN0IGB2YWx1ZWAgaW4gYGFsbEVudW1PcHRpb25zYCwgaWYgbm90IGBtdWx0aXBsZWAuIE90aGVyd2lzZSwgdGhlIGxpc3RcbiAqICAgICAgICBvZiBpbmRleGVzIGZvciAoZWFjaCBvZikgdGhlIHZhbHVlKHMpIGluIGB2YWx1ZWAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVudW1PcHRpb25zSW5kZXhGb3JWYWx1ZSh2YWx1ZSwgYWxsRW51bU9wdGlvbnMgPSBbXSwgbXVsdGlwbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXhlcyA9IGFsbEVudW1PcHRpb25zXG4gICAgICAgIC5tYXAoKG9wdCwgaW5kZXgpID0+IChlbnVtT3B0aW9uc0lzU2VsZWN0ZWQob3B0LnZhbHVlLCB2YWx1ZSkgPyBTdHJpbmcoaW5kZXgpIDogdW5kZWZpbmVkKSlcbiAgICAgICAgLmZpbHRlcigob3B0KSA9PiB0eXBlb2Ygb3B0ICE9PSAndW5kZWZpbmVkJyk7XG4gICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJbmRleGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRJbmRleGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bU9wdGlvbnNJbmRleEZvclZhbHVlLmpzLm1hcCIsImltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbi8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGB2YWx1ZWAgaXMgKG9uZSBvZikgdGhlIGBzZWxlY3RlZGAgdmFsdWUocykuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIGNoZWNrZWQgdG8gc2VlIGlmIGl0IGlzIHNlbGVjdGVkXG4gKiBAcGFyYW0gc2VsZWN0ZWQgLSBUaGUgY3VycmVudCBzZWxlY3RlZCB2YWx1ZSBvciBsaXN0IG9mIHZhbHVlc1xuICogQHJldHVybnMgLSB0cnVlIGlmIHRoZSBgdmFsdWVgIGlzIG9uZSBvZiB0aGUgYHNlbGVjdGVkYCBvbmVzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW51bU9wdGlvbnNJc1NlbGVjdGVkKHZhbHVlLCBzZWxlY3RlZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQuc29tZSgoc2VsKSA9PiBpc0VxdWFsKHNlbCwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRXF1YWwoc2VsZWN0ZWQsIHZhbHVlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW1PcHRpb25zSXNTZWxlY3RlZC5qcy5tYXAiLCJpbXBvcnQgZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4IGZyb20gJy4vZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4JztcbmltcG9ydCBpc05pbCBmcm9tICdsb2Rhc2gvaXNOaWwnO1xuLyoqIEFkZCB0aGUgZW51bSBvcHRpb24gdmFsdWUgYXQgdGhlIGB2YWx1ZUluZGV4YCB0byB0aGUgbGlzdCBvZiBgc2VsZWN0ZWRgIHZhbHVlcyBpbiB0aGUgcHJvcGVyIG9yZGVyIGFzIGRlZmluZWQgYnlcbiAqIGBhbGxFbnVtT3B0aW9uc2BcbiAqXG4gKiBAcGFyYW0gdmFsdWVJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWRcbiAqIEBwYXJhbSBzZWxlY3RlZCAtIFRoZSBjdXJyZW50IGxpc3Qgb2Ygc2VsZWN0ZWQgdmFsdWVzXG4gKiBAcGFyYW0gW2FsbEVudW1PcHRpb25zPVtdXSAtIFRoZSBsaXN0IG9mIGFsbCB0aGUga25vd24gZW51bU9wdGlvbnNcbiAqIEByZXR1cm5zIC0gVGhlIHVwZGF0ZWQgbGlzdCBvZiBzZWxlY3RlZCBlbnVtIHZhbHVlcyB3aXRoIGVudW0gdmFsdWUgYXQgdGhlIGB2YWx1ZUluZGV4YCBhZGRlZCB0byBpdFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbnVtT3B0aW9uc1NlbGVjdFZhbHVlKHZhbHVlSW5kZXgsIHNlbGVjdGVkLCBhbGxFbnVtT3B0aW9ucyA9IFtdKSB7XG4gICAgY29uc3QgdmFsdWUgPSBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgodmFsdWVJbmRleCwgYWxsRW51bU9wdGlvbnMpO1xuICAgIGlmICghaXNOaWwodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYWxsRW51bU9wdGlvbnMuZmluZEluZGV4KChvcHQpID0+IHZhbHVlID09PSBvcHQudmFsdWUpO1xuICAgICAgICBjb25zdCBhbGwgPSBhbGxFbnVtT3B0aW9ucy5tYXAoKHsgdmFsdWU6IHZhbCB9KSA9PiB2YWwpO1xuICAgICAgICBjb25zdCB1cGRhdGVkID0gc2VsZWN0ZWQuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdCh2YWx1ZSwgc2VsZWN0ZWQuc2xpY2UoaW5kZXgpKTtcbiAgICAgICAgLy8gQXMgaW5zZXJ0aW5nIHZhbHVlcyBhdCBwcmVkZWZpbmVkIGluZGV4IHBvc2l0aW9ucyBkb2Vzbid0IHdvcmsgd2l0aCBlbXB0eVxuICAgICAgICAvLyBhcnJheXMsIHdlIG5lZWQgdG8gcmVvcmRlciB0aGUgdXBkYXRlZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIGluaXRpYWwgb3JkZXJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQuc29ydCgoYSwgYikgPT4gTnVtYmVyKGFsbC5pbmRleE9mKGEpID4gYWxsLmluZGV4T2YoYikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bU9wdGlvbnNTZWxlY3RWYWx1ZS5qcy5tYXAiLCIvKiogUmV0dXJucyB0aGUgdmFsdWUocykgZnJvbSBgYWxsRW51bU9wdGlvbnNgIGF0IHRoZSBpbmRleChlcykgcHJvdmlkZWQgYnkgYHZhbHVlSW5kZXhgLiBJZiBgdmFsdWVJbmRleGAgaXMgbm90IGFuXG4gKiBhcnJheSBBTkQgdGhlIGluZGV4IGlzIG5vdCB2YWxpZCBmb3IgYGFsbEVudW1PcHRpb25zYCwgYGVtcHR5VmFsdWVgIGlzIHJldHVybmVkLiBJZiBgdmFsdWVJbmRleGAgaXMgYW4gYXJyYXksIEFORCBpdFxuICogY29udGFpbnMgYW4gaW52YWxpZCBpbmRleCwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgaGF2ZSB0aGUgcmVzdWx0aW5nIHVuZGVmaW5lZCB2YWx1ZXMgZmlsdGVyZWQgb3V0LCBsZWF2aW5nIG9ubHlcbiAqIHZhbGlkIHZhbHVlcyBvciBpbiB0aGUgd29yc3QgY2FzZSwgYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQHBhcmFtIHZhbHVlSW5kZXggLSBUaGUgaW5kZXgoZXMpIG9mIHRoZSB2YWx1ZShzKSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZFxuICogQHBhcmFtIFthbGxFbnVtT3B0aW9ucz1bXV0gLSBUaGUgbGlzdCBvZiBhbGwgdGhlIGtub3duIGVudW1PcHRpb25zXG4gKiBAcGFyYW0gW2VtcHR5VmFsdWVdIC0gVGhlIHZhbHVlIHRvIHJldHVybiB3aGVuIHRoZSBub24tYXJyYXkgYHZhbHVlSW5kZXhgIGRvZXMgbm90IHJlZmVyIHRvIGEgcmVhbCBvcHRpb25cbiAqIEByZXR1cm5zIC0gVGhlIHNpbmdsZSBvciBsaXN0IG9mIHZhbHVlcyBzcGVjaWZpZWQgYnkgdGhlIHNpbmdsZSBvciBsaXN0IG9mIGluZGV4ZXMgaWYgdGhleSBhcmUgdmFsaWQuIE90aGVyd2lzZSxcbiAqICAgICAgICBgZW1wdHlWYWx1ZWAgb3IgYW4gZW1wdHkgbGlzdC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4KHZhbHVlSW5kZXgsIGFsbEVudW1PcHRpb25zID0gW10sIGVtcHR5VmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZUluZGV4KSkge1xuICAgICAgICByZXR1cm4gdmFsdWVJbmRleC5tYXAoKGluZGV4KSA9PiBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgoaW5kZXgsIGFsbEVudW1PcHRpb25zKSkuZmlsdGVyKCh2YWwpID0+IHZhbCk7XG4gICAgfVxuICAgIC8vIFNvIE51bWJlcihudWxsKSBhbmQgTnVtYmVyKCcnKSBib3RoIHJldHVybiAwLCBzbyB1c2UgZW1wdHlWYWx1ZSBmb3IgdGhvc2UgdHdvIHZhbHVlc1xuICAgIGNvbnN0IGluZGV4ID0gdmFsdWVJbmRleCA9PT0gJycgfHwgdmFsdWVJbmRleCA9PT0gbnVsbCA/IC0xIDogTnVtYmVyKHZhbHVlSW5kZXgpO1xuICAgIGNvbnN0IG9wdGlvbiA9IGFsbEVudW1PcHRpb25zW2luZGV4XTtcbiAgICByZXR1cm4gb3B0aW9uID8gb3B0aW9uLnZhbHVlIDogZW1wdHlWYWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW1PcHRpb25zVmFsdWVGb3JJbmRleC5qcy5tYXAiLCIvKiogQW4gZW51bWVyYXRpb24gb2YgYWxsIHRoZSB0cmFuc2xhdGFibGUgc3RyaW5ncyB1c2VkIGJ5IGBAcmpzZi9jb3JlYCBhbmQgaXRzIHRoZW1lcy4gVGhlIHZhbHVlIG9mIGVhY2ggb2YgdGhlXG4gKiBlbnVtZXJhdGlvbiBrZXlzIGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBhY3R1YWwgZW5nbGlzaCBzdHJpbmcuIFNvbWUgc3RyaW5ncyBjb250YWluIHJlcGxhY2VhYmxlIHBhcmFtZXRlciB2YWx1ZXNcbiAqIGFzIGluZGljYXRlZCBieSBgJTFgLCBgJTJgLCBldGMuIFRoZSBudW1iZXIgYWZ0ZXIgdGhlIGAlYCBpbmRpY2F0ZXMgdGhlIG9yZGVyIG9mIHRoZSBwYXJhbWV0ZXIuIFRoZSBvcmRlcmluZyBvZlxuICogcGFyYW1ldGVycyBpcyBpbXBvcnRhbnQgYmVjYXVzZSBzb21lIGxhbmd1YWdlcyBtYXkgY2hvb3NlIHRvIHB1dCB0aGUgc2Vjb25kIHBhcmFtZXRlciBiZWZvcmUgdGhlIGZpcnN0IGluIGl0c1xuICogdHJhbnNsYXRpb24uIEFsc28sIHNvbWUgc3RyaW5ncyBhcmUgcmVuZGVyZWQgdXNpbmcgYG1hcmtkb3duLXRvLWpzeGAgYW5kIHRodXMgc3VwcG9ydCBtYXJrZG93biBhbmQgaW5saW5lIGh0bWwuXG4gKi9cbmV4cG9ydCB2YXIgVHJhbnNsYXRhYmxlU3RyaW5nO1xuKGZ1bmN0aW9uIChUcmFuc2xhdGFibGVTdHJpbmcpIHtcbiAgICAvKiogRmFsbGJhY2sgdGl0bGUgb2YgYW4gYXJyYXkgaXRlbSwgdXNlZCBieSBBcnJheUZpZWxkICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiQXJyYXlJdGVtVGl0bGVcIl0gPSBcIkl0ZW1cIjtcbiAgICAvKiogTWlzc2luZyBpdGVtcyByZWFzb24sIHVzZWQgYnkgQXJyYXlGaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIk1pc3NpbmdJdGVtc1wiXSA9IFwiTWlzc2luZyBpdGVtcyBkZWZpbml0aW9uXCI7XG4gICAgLyoqIFllcyBsYWJlbCwgdXNlZCBieSBCb29sZWFuRmllbGQgKi9cbiAgICBUcmFuc2xhdGFibGVTdHJpbmdbXCJZZXNMYWJlbFwiXSA9IFwiWWVzXCI7XG4gICAgLyoqIE5vIGxhYmVsLCB1c2VkIGJ5IEJvb2xlYW5GaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIk5vTGFiZWxcIl0gPSBcIk5vXCI7XG4gICAgLyoqIENsb3NlIGxhYmVsLCB1c2VkIGJ5IEVycm9yTGlzdCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIkNsb3NlTGFiZWxcIl0gPSBcIkNsb3NlXCI7XG4gICAgLyoqIEVycm9ycyBsYWJlbCwgdXNlZCBieSBFcnJvckxpc3QgKi9cbiAgICBUcmFuc2xhdGFibGVTdHJpbmdbXCJFcnJvcnNMYWJlbFwiXSA9IFwiRXJyb3JzXCI7XG4gICAgLyoqIE5ldyBhZGRpdGlvbmFsUHJvcGVydGllcyBzdHJpbmcgZGVmYXVsdCB2YWx1ZSwgdXNlZCBieSBPYmplY3RGaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIk5ld1N0cmluZ0RlZmF1bHRcIl0gPSBcIk5ldyBWYWx1ZVwiO1xuICAgIC8qKiBBZGQgYnV0dG9uIHRpdGxlLCB1c2VkIGJ5IEFkZEJ1dHRvbiAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIkFkZEJ1dHRvblwiXSA9IFwiQWRkXCI7XG4gICAgLyoqIEFkZCBidXR0b24gdGl0bGUsIHVzZWQgYnkgQWRkQnV0dG9uICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiQWRkSXRlbUJ1dHRvblwiXSA9IFwiQWRkIEl0ZW1cIjtcbiAgICAvKiogQ29weSBidXR0b24gdGl0bGUsIHVzZWQgYnkgSWNvbkJ1dHRvbiAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIkNvcHlCdXR0b25cIl0gPSBcIkNvcHlcIjtcbiAgICAvKiogTW92ZSBkb3duIGJ1dHRvbiB0aXRsZSwgdXNlZCBieSBJY29uQnV0dG9uICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiTW92ZURvd25CdXR0b25cIl0gPSBcIk1vdmUgZG93blwiO1xuICAgIC8qKiBNb3ZlIHVwIGJ1dHRvbiB0aXRsZSwgdXNlZCBieSBJY29uQnV0dG9uICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiTW92ZVVwQnV0dG9uXCJdID0gXCJNb3ZlIHVwXCI7XG4gICAgLyoqIFJlbW92ZSBidXR0b24gdGl0bGUsIHVzZWQgYnkgSWNvbkJ1dHRvbiAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIlJlbW92ZUJ1dHRvblwiXSA9IFwiUmVtb3ZlXCI7XG4gICAgLyoqIE5vdyBsYWJlbCwgdXNlZCBieSBBbHREYXRlV2lkZ2V0ICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiTm93TGFiZWxcIl0gPSBcIk5vd1wiO1xuICAgIC8qKiBDbGVhciBsYWJlbCwgdXNlZCBieSBBbHREYXRlV2lkZ2V0ICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiQ2xlYXJMYWJlbFwiXSA9IFwiQ2xlYXJcIjtcbiAgICAvKiogQXJpYSBkYXRlIGxhYmVsLCB1c2VkIGJ5IERhdGVXaWRnZXQgKi9cbiAgICBUcmFuc2xhdGFibGVTdHJpbmdbXCJBcmlhRGF0ZUxhYmVsXCJdID0gXCJTZWxlY3QgYSBkYXRlXCI7XG4gICAgLyoqIEZpbGUgcHJldmlldyBsYWJlbCwgdXNlZCBieSBGaWxlV2lkZ2V0ICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiUHJldmlld0xhYmVsXCJdID0gXCJQcmV2aWV3XCI7XG4gICAgLyoqIERlY3JlbWVudCBidXR0b24gYXJpYSBsYWJlbCwgdXNlZCBieSBVcERvd25XaWRnZXQgKi9cbiAgICBUcmFuc2xhdGFibGVTdHJpbmdbXCJEZWNyZW1lbnRBcmlhTGFiZWxcIl0gPSBcIkRlY3JlYXNlIHZhbHVlIGJ5IDFcIjtcbiAgICAvKiogSW5jcmVtZW50IGJ1dHRvbiBhcmlhIGxhYmVsLCB1c2VkIGJ5IFVwRG93bldpZGdldCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIkluY3JlbWVudEFyaWFMYWJlbFwiXSA9IFwiSW5jcmVhc2UgdmFsdWUgYnkgMVwiO1xuICAgIC8vIFN0cmluZ3Mgd2l0aCByZXBsYWNlYWJsZSBwYXJhbWV0ZXJzXG4gICAgLyoqIFVua25vd24gZmllbGQgdHlwZSByZWFzb24sIHdoZXJlICUxIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgdHlwZSBhcyBwcm92aWRlZCBieSBTY2hlbWFGaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIlVua25vd25GaWVsZFR5cGVcIl0gPSBcIlVua25vd24gZmllbGQgdHlwZSAlMVwiO1xuICAgIC8qKiBPcHRpb24gcHJlZml4LCB3aGVyZSAlMSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG9wdGlvbiBpbmRleCBhcyBwcm92aWRlZCBieSBNdWx0aVNjaGVtYUZpZWxkICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiT3B0aW9uUHJlZml4XCJdID0gXCJPcHRpb24gJTFcIjtcbiAgICAvKiogT3B0aW9uIHByZWZpeCwgd2hlcmUgJTEgYW5kICUyIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHNjaGVtYSB0aXRsZSBhbmQgb3B0aW9uIGluZGV4LCByZXNwZWN0aXZlbHkgYXMgcHJvdmlkZWQgYnlcbiAgICAgKiBNdWx0aVNjaGVtYUZpZWxkXG4gICAgICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiVGl0bGVPcHRpb25QcmVmaXhcIl0gPSBcIiUxIG9wdGlvbiAlMlwiO1xuICAgIC8qKiBLZXkgbGFiZWwsIHdoZXJlICUxIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGxhYmVsIGFzIHByb3ZpZGVkIGJ5IFdyYXBJZkFkZGl0aW9uYWxUZW1wbGF0ZSAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIktleUxhYmVsXCJdID0gXCIlMSBLZXlcIjtcbiAgICAvLyBTdHJpbmdzIHdpdGggcmVwbGFjZWFibGUgcGFyYW1ldGVycyBBTkQvT1IgdGhhdCBzdXBwb3J0IG1hcmtkb3duIGFuZCBodG1sXG4gICAgLyoqIEludmFsaWQgb2JqZWN0IGZpZWxkIGNvbmZpZ3VyYXRpb24gYXMgcHJvdmlkZWQgYnkgdGhlIE9iamVjdEZpZWxkICovXG4gICAgVHJhbnNsYXRhYmxlU3RyaW5nW1wiSW52YWxpZE9iamVjdEZpZWxkXCJdID0gXCJJbnZhbGlkIFxcXCIlMVxcXCIgb2JqZWN0IGZpZWxkIGNvbmZpZ3VyYXRpb246IDxlbT4lMjwvZW0+LlwiO1xuICAgIC8qKiBVbnN1cHBvcnRlZCBmaWVsZCBzY2hlbWEsIHVzZWQgYnkgVW5zdXBwb3J0ZWRGaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIlVuc3VwcG9ydGVkRmllbGRcIl0gPSBcIlVuc3VwcG9ydGVkIGZpZWxkIHNjaGVtYS5cIjtcbiAgICAvKiogVW5zdXBwb3J0ZWQgZmllbGQgc2NoZW1hLCB3aGVyZSAlMSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBpZFNjaGVtYS4kaWQgYXMgcHJvdmlkZWQgYnkgVW5zdXBwb3J0ZWRGaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIlVuc3VwcG9ydGVkRmllbGRXaXRoSWRcIl0gPSBcIlVuc3VwcG9ydGVkIGZpZWxkIHNjaGVtYSBmb3IgZmllbGQgPGNvZGU+JTE8L2NvZGU+LlwiO1xuICAgIC8qKiBVbnN1cHBvcnRlZCBmaWVsZCBzY2hlbWEsIHdoZXJlICUxIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHJlYXNvbiBzdHJpbmcgYXMgcHJvdmlkZWQgYnkgVW5zdXBwb3J0ZWRGaWVsZCAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIlVuc3VwcG9ydGVkRmllbGRXaXRoUmVhc29uXCJdID0gXCJVbnN1cHBvcnRlZCBmaWVsZCBzY2hlbWE6IDxlbT4lMTwvZW0+LlwiO1xuICAgIC8qKiBVbnN1cHBvcnRlZCBmaWVsZCBzY2hlbWEsIHdoZXJlICUxIGFuZCAlMiB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBpZFNjaGVtYS4kaWQgYW5kIHJlYXNvbiBzdHJpbmdzLCByZXNwZWN0aXZlbHksXG4gICAgICogYXMgcHJvdmlkZWQgYnkgVW5zdXBwb3J0ZWRGaWVsZFxuICAgICAqL1xuICAgIFRyYW5zbGF0YWJsZVN0cmluZ1tcIlVuc3VwcG9ydGVkRmllbGRXaXRoSWRBbmRSZWFzb25cIl0gPSBcIlVuc3VwcG9ydGVkIGZpZWxkIHNjaGVtYSBmb3IgZmllbGQgPGNvZGU+JTE8L2NvZGU+OiA8ZW0+JTI8L2VtPi5cIjtcbiAgICAvKiogRmlsZSBuYW1lLCB0eXBlIGFuZCBzaXplIGluZm8sIHdoZXJlICUxLCAlMiBhbmQgJTMgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZmlsZSBuYW1lLCBmaWxlIHR5cGUgYW5kIGZpbGUgc2l6ZSBhc1xuICAgICAqIHByb3ZpZGVkIGJ5IEZpbGVXaWRnZXRcbiAgICAgKi9cbiAgICBUcmFuc2xhdGFibGVTdHJpbmdbXCJGaWxlc0luZm9cIl0gPSBcIjxzdHJvbmc+JTE8L3N0cm9uZz4gKCUyLCAlMyBieXRlcylcIjtcbn0pKFRyYW5zbGF0YWJsZVN0cmluZyB8fCAoVHJhbnNsYXRhYmxlU3RyaW5nID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW1zLmpzLm1hcCIsImltcG9ydCBqc29ucG9pbnRlciBmcm9tICdqc29ucG9pbnRlcic7XG5pbXBvcnQgb21pdCBmcm9tICdsb2Rhc2gvb21pdCc7XG5pbXBvcnQgeyBSRUZfS0VZIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuLyoqIFNwbGl0cyBvdXQgdGhlIHZhbHVlIGF0IHRoZSBga2V5YCBpbiBgb2JqZWN0YCBmcm9tIHRoZSBgb2JqZWN0YCwgcmV0dXJuaW5nIGFuIGFycmF5IHRoYXQgY29udGFpbnMgaW4gdGhlIGZpcnN0XG4gKiBsb2NhdGlvbiwgdGhlIGBvYmplY3RgIG1pbnVzIHRoZSBga2V5OiB2YWx1ZWAgYW5kIGluIHRoZSBzZWNvbmQgbG9jYXRpb24gdGhlIGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgZnJvbSB0aGUgb2JqZWN0IHRvIGV4dHJhY3RcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgZWxlbWVudFxuICogQHJldHVybnMgLSBBbiBhcnJheSB3aXRoIHRoZSBmaXJzdCB2YWx1ZSBiZWluZyB0aGUgb2JqZWN0IG1pbnVzIHRoZSBga2V5YCBlbGVtZW50IGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgYmVpbmcgdGhlXG4gKiAgICAgIHZhbHVlIGZyb20gYG9iamVjdFtrZXldYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRLZXlFbGVtZW50RnJvbU9iamVjdChrZXksIG9iamVjdCkge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgY29uc3QgcmVtYWluaW5nID0gb21pdChvYmplY3QsIFtrZXldKTtcbiAgICByZXR1cm4gW3JlbWFpbmluZywgdmFsdWVdO1xufVxuLyoqIEdpdmVuIHRoZSBuYW1lIG9mIGEgYCRyZWZgIGZyb20gd2l0aGluIGEgc2NoZW1hLCB1c2luZyB0aGUgYHJvb3RTY2hlbWFgLCBsb29rIHVwIGFuZCByZXR1cm4gdGhlIHN1Yi1zY2hlbWEgdXNpbmcgdGhlXG4gKiBwYXRoIHByb3ZpZGVkIGJ5IHRoYXQgcmVmZXJlbmNlLiBJZiBgI2AgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHJlZmVyZW5jZSwgb3IgdGhlIHBhdGggZG9lcyBub3QgZXhpc3QgaW5cbiAqIHRoZSBzY2hlbWEsIHRoZW4gdGhyb3cgYW4gRXJyb3IuIE90aGVyd2lzZSByZXR1cm4gdGhlIHN1Yi1zY2hlbWEuIEFsc28gZGVhbHMgd2l0aCBuZXN0ZWQgYCRyZWZgcyBpbiB0aGUgc3ViLXNjaGVtYS5cbiAqXG4gKiBAcGFyYW0gJHJlZiAtIFRoZSByZWYgc3RyaW5nIGZvciB3aGljaCB0aGUgc2NoZW1hIGRlZmluaXRpb24gaXMgZGVzaXJlZFxuICogQHBhcmFtIFtyb290U2NoZW1hPXt9XSAtIFRoZSByb290IHNjaGVtYSBpbiB3aGljaCB0byBzZWFyY2ggZm9yIHRoZSBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyAtIFRoZSBzdWItc2NoZW1hIHdpdGhpbiB0aGUgYHJvb3RTY2hlbWFgIHdoaWNoIG1hdGNoZXMgdGhlIGAkcmVmYCBpZiBpdCBleGlzdHNcbiAqIEB0aHJvd3MgLSBFcnJvciBpbmRpY2F0aW5nIHRoYXQgbm8gc2NoZW1hIGZvciB0aGF0IHJlZmVyZW5jZSBleGlzdHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZFNjaGVtYURlZmluaXRpb24oJHJlZiwgcm9vdFNjaGVtYSA9IHt9KSB7XG4gICAgbGV0IHJlZiA9ICRyZWYgfHwgJyc7XG4gICAgaWYgKHJlZi5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgLy8gRGVjb2RlIFVSSSBmcmFnbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgcmVmID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlZi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIGRlZmluaXRpb24gZm9yICR7JHJlZn0uYCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBqc29ucG9pbnRlci5nZXQocm9vdFNjaGVtYSwgcmVmKTtcbiAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZpbml0aW9uIGZvciAkeyRyZWZ9LmApO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFtSRUZfS0VZXSkge1xuICAgICAgICBjb25zdCBbcmVtYWluaW5nLCB0aGVSZWZdID0gc3BsaXRLZXlFbGVtZW50RnJvbU9iamVjdChSRUZfS0VZLCBjdXJyZW50KTtcbiAgICAgICAgY29uc3Qgc3ViU2NoZW1hID0gZmluZFNjaGVtYURlZmluaXRpb24odGhlUmVmLCByb290U2NoZW1hKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbWFpbmluZykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVtYWluaW5nLCAuLi5zdWJTY2hlbWEgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViU2NoZW1hO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmRTY2hlbWFEZWZpbml0aW9uLmpzLm1hcCIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnbG9kYXNoL2lzU3RyaW5nJztcbi8qKiBSZXR1cm5zIHRoZSBgZGlzY3JpbWluYXRvci5wcm9wZXJ0eU5hbWVgIHdoZW4gZGVmaW5lZCBpbiB0aGUgYHNjaGVtYWAgaWYgaXQgaXMgYSBzdHJpbmcuIEEgd2FybmluZyBpcyBnZW5lcmF0ZWQgd2hlblxuICogaXQgaXMgbm90IGEgc3RyaW5nLiBSZXR1cm5zIGB1bmRlZmluZWRgIHdoZW4gYSB2YWxpZCBkaXNjcmltaW5hdG9yIGlzIG5vdCBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZyb20gd2hpY2ggdGhlIGRpc2NyaW1pbmF0b3IgaXMgcG90ZW50aWFsbHkgb2J0YWluZWRcbiAqIEByZXR1cm5zIC0gVGhlIGBkaXNjcmltaW5hdG9yLnByb3BlcnR5TmFtZWAgaWYgaXQgZXhpc3RzIGluIHRoZSBzY2hlbWEsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgIGxldCBkaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IG1heWJlU3RyaW5nID0gZ2V0KHNjaGVtYSwgJ2Rpc2NyaW1pbmF0b3IucHJvcGVydHlOYW1lJywgdW5kZWZpbmVkKTtcbiAgICBpZiAoaXNTdHJpbmcobWF5YmVTdHJpbmcpKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3IgPSBtYXliZVN0cmluZztcbiAgICB9XG4gICAgZWxzZSBpZiAobWF5YmVTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEV4cGVjdGluZyBkaXNjcmltaW5hdG9yIHRvIGJlIGEgc3RyaW5nLCBnb3QgXCIke3R5cGVvZiBtYXliZVN0cmluZ31cIiBpbnN0ZWFkYCk7XG4gICAgfVxuICAgIHJldHVybiBkaXNjcmltaW5hdG9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYS5qcy5tYXAiLCJpbXBvcnQgcmFuZ2VTcGVjIGZyb20gJy4vcmFuZ2VTcGVjJztcbi8qKiBVc2luZyB0aGUgYHNjaGVtYWAsIGBkZWZhdWx0VHlwZWAgYW5kIGBvcHRpb25zYCwgZXh0cmFjdCBvdXQgdGhlIHByb3BzIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHRoYXQgbWFrZSBzZW5zZS5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3IgdGhlIGZpZWxkIHByb3ZpZGVkIGJ5IHRoZSB3aWRnZXRcbiAqIEBwYXJhbSBbZGVmYXVsdFR5cGVdIC0gVGhlIGRlZmF1bHQgdHlwZSwgaWYgYW55LCBmb3IgdGhlIGZpZWxkIHByb3ZpZGVkIGJ5IHRoZSB3aWRnZXRcbiAqIEBwYXJhbSBbb3B0aW9ucz17fV0gLSBUaGUgVUkgT3B0aW9ucyBmb3IgdGhlIGZpZWxkIHByb3ZpZGVkIGJ5IHRoZSB3aWRnZXRcbiAqIEBwYXJhbSBbYXV0b0RlZmF1bHRTdGVwQW55PXRydWVdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGF1dG8tZGVmYXVsdCBzdGVwPWFueSB3aGVuIHRoZSB0eXBlIGlzIG51bWJlciBhbmQgbm8gc3RlcFxuICogQHJldHVybnMgLSBUaGUgZXh0cmFjdGVkIGBJbnB1dFByb3BzVHlwZWAgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldElucHV0UHJvcHMoc2NoZW1hLCBkZWZhdWx0VHlwZSwgb3B0aW9ucyA9IHt9LCBhdXRvRGVmYXVsdFN0ZXBBbnkgPSB0cnVlKSB7XG4gICAgY29uc3QgaW5wdXRQcm9wcyA9IHtcbiAgICAgICAgdHlwZTogZGVmYXVsdFR5cGUgfHwgJ3RleHQnLFxuICAgICAgICAuLi5yYW5nZVNwZWMoc2NoZW1hKSxcbiAgICB9O1xuICAgIC8vIElmIG9wdGlvbnMuaW5wdXRUeXBlIGlzIHNldCB1c2UgdGhhdCBhcyB0aGUgaW5wdXQgdHlwZVxuICAgIGlmIChvcHRpb25zLmlucHV0VHlwZSkge1xuICAgICAgICBpbnB1dFByb3BzLnR5cGUgPSBvcHRpb25zLmlucHV0VHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWRlZmF1bHRUeXBlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzY2hlbWEgaXMgb2YgdHlwZSBudW1iZXIgb3IgaW50ZWdlciwgc2V0IHRoZSBpbnB1dCB0eXBlIHRvIG51bWJlclxuICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbnB1dFByb3BzLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHN0ZXAgaWYgb25lIGlzbid0IGFscmVhZHkgZGVmaW5lZCBhbmQgd2UgYXJlIGF1dG8tZGVmYXVsdGluZyB0aGUgXCJhbnlcIiBzdGVwXG4gICAgICAgICAgICBpZiAoYXV0b0RlZmF1bHRTdGVwQW55ICYmIGlucHV0UHJvcHMuc3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBzdGVwIHRvICdhbnknIGZpeGVzIGEgYnVnIGluIFNhZmFyaSB3aGVyZSBkZWNpbWFscyBhcmUgbm90XG4gICAgICAgICAgICAgICAgLy8gYWxsb3dlZCBpbiBudW1iZXIgaW5wdXRzXG4gICAgICAgICAgICAgICAgaW5wdXRQcm9wcy5zdGVwID0gJ2FueSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdpbnRlZ2VyJykge1xuICAgICAgICAgICAgaW5wdXRQcm9wcy50eXBlID0gJ251bWJlcic7XG4gICAgICAgICAgICAvLyBPbmx5IGFkZCBzdGVwIGlmIG9uZSBpc24ndCBhbHJlYWR5IGRlZmluZWRcbiAgICAgICAgICAgIGlmIChpbnB1dFByb3BzLnN0ZXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgaW50ZWdlciwgeW91IGFsd2F5cyB3YW50IHRvIHN0ZXAgdXAgb3IgZG93biBpbiBtdWx0aXBsZXMgb2YgMVxuICAgICAgICAgICAgICAgIGlucHV0UHJvcHMuc3RlcCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXV0b2NvbXBsZXRlKSB7XG4gICAgICAgIGlucHV0UHJvcHMuYXV0b0NvbXBsZXRlID0gb3B0aW9ucy5hdXRvY29tcGxldGU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0SW5wdXRQcm9wcy5qcy5tYXAiLCJpbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IHsgUFJPUEVSVElFU19LRVkgfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKiogQ29tcGFyZXMgdGhlIHZhbHVlIG9mIGBkaXNjcmltaW5hdG9yRmllbGRgIHdpdGhpbiBgZm9ybURhdGFgIGFnYWluc3QgdGhlIHZhbHVlIG9mIGBkaXNjcmltaW5hdG9yRmllbGRgIHdpdGhpbiBzY2hlbWEgZm9yIGVhY2ggYG9wdGlvbmAuXG4gKiBSZXR1cm5zIGluZGV4IG9mIGZpcnN0IGBvcHRpb25gIHdob3NlIGRpc2NyaW1pbmF0b3IgbWF0Y2hlcyBmb3JtRGF0YS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBtYXRjaC5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgd29yayB3aXRoIGRpc2NyaW1pbmF0b3JzIG9mIGBcInR5cGVcIjogXCJvYmplY3RcImAgYW5kIGBcInR5cGVcIjogXCJhcnJheVwiYFxuICpcbiAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBjdXJyZW50IGZvcm1EYXRhLCBpZiBhbnksIHVzZWQgdG8gZmlndXJlIG91dCBhIG1hdGNoXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBsaXN0IG9mIG9wdGlvbnMgdG8gZmluZCBhIG1hdGNoaW5nIG9wdGlvbnMgZnJvbVxuICogQHBhcmFtIFtkaXNjcmltaW5hdG9yRmllbGRdIC0gVGhlIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGZpZWxkIHdpdGhpbiB0aGUgb3B0aW9ucyBvYmplY3Qgd2hvc2UgdmFsdWUgaXMgdXNlZCB0b1xuICogICAgICAgICAgZGV0ZXJtaW5lIHdoaWNoIG9wdGlvbiBpcyBzZWxlY3RlZFxuICogQHJldHVybnMgLSBUaGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgb3B0aW9uIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBtYXRjaFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHRpb25NYXRjaGluZ1NpbXBsZURpc2NyaW1pbmF0b3IoZm9ybURhdGEsIG9wdGlvbnMsIGRpc2NyaW1pbmF0b3JGaWVsZCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZm9ybURhdGEgJiYgZGlzY3JpbWluYXRvckZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KGZvcm1EYXRhLCBkaXNjcmltaW5hdG9yRmllbGQpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBnZXQob3B0aW9uLCBbUFJPUEVSVElFU19LRVksIGRpc2NyaW1pbmF0b3JGaWVsZF0sIHt9KTtcbiAgICAgICAgICAgIGlmIChkaXNjcmltaW5hdG9yLnR5cGUgPT09ICdvYmplY3QnIHx8IGRpc2NyaW1pbmF0b3IudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3IuY29uc3QgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKF9hID0gZGlzY3JpbWluYXRvci5lbnVtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0T3B0aW9uTWF0Y2hpbmdTaW1wbGVEaXNjcmltaW5hdG9yLmpzLm1hcCIsImltcG9ydCBndWVzc1R5cGUgZnJvbSAnLi9ndWVzc1R5cGUnO1xuLyoqIEdldHMgdGhlIHR5cGUgb2YgYSBnaXZlbiBgc2NoZW1hYC4gSWYgdGhlIHR5cGUgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCwgdGhlbiBhbiBhdHRlbXB0IGlzIG1hZGUgdG8gaW5mZXIgaXQgZnJvbVxuICogb3RoZXIgZWxlbWVudHMgb2YgdGhlIHNjaGVtYSBhcyBmb2xsb3dzOlxuICogLSBzY2hlbWEuY29uc3Q6IFJldHVybnMgdGhlIGBndWVzc1R5cGUoKWAgb2YgdGhhdCB2YWx1ZVxuICogLSBzY2hlbWEuZW51bTogUmV0dXJucyBgc3RyaW5nYFxuICogLSBzY2hlbWEucHJvcGVydGllczogUmV0dXJucyBgb2JqZWN0YFxuICogLSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM6IFJldHVybnMgYG9iamVjdGBcbiAqIC0gdHlwZSBpcyBhbiBhcnJheSB3aXRoIGEgbGVuZ3RoIG9mIDIgYW5kIG9uZSB0eXBlIGlzICdudWxsJzogUmV0dXJucyB0aGUgb3RoZXIgdHlwZVxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCB0byBnZXQgdGhlIHR5cGVcbiAqIEByZXR1cm5zIC0gVGhlIHR5cGUgb2YgdGhlIHNjaGVtYVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlKHNjaGVtYSkge1xuICAgIGxldCB7IHR5cGUgfSA9IHNjaGVtYTtcbiAgICBpZiAoIXR5cGUgJiYgc2NoZW1hLmNvbnN0KSB7XG4gICAgICAgIHJldHVybiBndWVzc1R5cGUoc2NoZW1hLmNvbnN0KTtcbiAgICB9XG4gICAgaWYgKCF0eXBlICYmIHNjaGVtYS5lbnVtKSB7XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9XG4gICAgaWYgKCF0eXBlICYmIChzY2hlbWEucHJvcGVydGllcyB8fCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpKSB7XG4gICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgaWYgKHR5cGUubGVuZ3RoID09PSAyICYmIHR5cGUuaW5jbHVkZXMoJ251bGwnKSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZmluZCgodHlwZSkgPT4gdHlwZSAhPT0gJ251bGwnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0U2NoZW1hVHlwZS5qcy5tYXAiLCJpbXBvcnQgeyBTVUJNSVRfQlROX09QVElPTlNfS0VZIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGdldFVpT3B0aW9ucyBmcm9tICcuL2dldFVpT3B0aW9ucyc7XG4vKiogVGhlIGRlZmF1bHQgc3VibWl0IGJ1dHRvbiBvcHRpb25zLCBleHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIHByb3BzOiB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHN1Ym1pdFRleHQ6ICdTdWJtaXQnLFxuICAgIG5vcmVuZGVyOiBmYWxzZSxcbn07XG4vKiogRXh0cmFjdHMgYW55IGB1aTpzdWJtaXRCdXR0b25PcHRpb25zYCBmcm9tIHRoZSBgdWlTY2hlbWFgIGFuZCBtZXJnZXMgdGhlbSBvbnRvIHRoZSBgREVGQVVMVF9PUFRJT05TYFxuICpcbiAqIEBwYXJhbSBbdWlTY2hlbWE9e31dIC0gdGhlIFVJIFNjaGVtYSBmcm9tIHdoaWNoIHRvIGV4dHJhY3Qgc3VibWl0IGJ1dHRvbiBwcm9wc1xuICogQHJldHVybnMgLSBUaGUgbWVyZ2luZyBvZiB0aGUgYERFRkFVTFRfT1BUSU9OU2Agd2l0aCBhbnkgY3VzdG9tIG9uZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3VibWl0QnV0dG9uT3B0aW9ucyh1aVNjaGVtYSA9IHt9KSB7XG4gICAgY29uc3QgdWlPcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgICBpZiAodWlPcHRpb25zICYmIHVpT3B0aW9uc1tTVUJNSVRfQlROX09QVElPTlNfS0VZXSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdWlPcHRpb25zW1NVQk1JVF9CVE5fT1BUSU9OU19LRVldO1xuICAgICAgICByZXR1cm4geyAuLi5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuIERFRkFVTFRfT1BUSU9OUztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFN1Ym1pdEJ1dHRvbk9wdGlvbnMuanMubWFwIiwiLyoqIFJldHVybnMgdGhlIHRlbXBsYXRlIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBmcm9tIGVpdGhlciB0aGUgYHVpU2NoZW1hYCBpZiBpdCBpcyBkZWZpbmVkIG9yIGZyb20gdGhlIGByZWdpc3RyeWBcbiAqIG90aGVyd2lzZS4gTk9URSwgc2luY2UgYEJ1dHRvblRlbXBsYXRlc2AgYXJlIG5vdCBvdmVycmlkZGVuIGluIGB1aVNjaGVtYWAgb25seSB0aG9zZSBpbiB0aGUgYHJlZ2lzdHJ5YCBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgdG8gZmV0Y2gsIHJlc3RyaWN0ZWQgdG8gdGhlIGtleXMgb2YgYFRlbXBsYXRlc1R5cGVgXG4gKiBAcGFyYW0gcmVnaXN0cnkgLSBUaGUgYFJlZ2lzdHJ5YCBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHRlbXBsYXRlXG4gKiBAcGFyYW0gW3VpT3B0aW9ucz17fV0gLSBUaGUgYFVJT3B0aW9uc1R5cGVgIGZyb20gd2hpY2ggdG8gcmVhZCBhbiBhbHRlcm5hdGUgdGVtcGxhdGVcbiAqIEByZXR1cm5zIC0gVGhlIHRlbXBsYXRlIGZyb20gZWl0aGVyIHRoZSBgdWlTY2hlbWFgIG9yIGByZWdpc3RyeWAgZm9yIHRoZSBgbmFtZWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VGVtcGxhdGUobmFtZSwgcmVnaXN0cnksIHVpT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZXMgfSA9IHJlZ2lzdHJ5O1xuICAgIGlmIChuYW1lID09PSAnQnV0dG9uVGVtcGxhdGVzJykge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgIC8vIEV2YWx1YXRpbmcgdWlPcHRpb25zW25hbWVdIHJlc3VsdHMgaW4gVFMyNTkwOiBFeHByZXNzaW9uIHByb2R1Y2VzIGEgdW5pb24gdHlwZSB0aGF0IGlzIHRvbyBjb21wbGV4IHRvIHJlcHJlc2VudFxuICAgIC8vIFRvIGF2b2lkIHRoYXQsIHdlIGNhc3QgdWlPcHRpb25zIHRvIGBhbnlgIGJlZm9yZSBhY2Nlc3NpbmcgdGhlIG5hbWUgZmllbGRcbiAgICB1aU9wdGlvbnNbbmFtZV0gfHwgdGVtcGxhdGVzW25hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFRlbXBsYXRlLmpzLm1hcCIsImltcG9ydCB7IFVJX09QVElPTlNfS0VZLCBVSV9XSURHRVRfS0VZIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QnO1xuLyoqIEdldCBhbGwgcGFzc2VkIG9wdGlvbnMgZnJvbSB1aTpvcHRpb25zLCBhbmQgdWk6PG9wdGlvbk5hbWU+LCByZXR1cm5pbmcgdGhlbSBpbiBhbiBvYmplY3Qgd2l0aCB0aGUgYHVpOmBcbiAqIHN0cmlwcGVkIG9mZi4gQW55IGBnbG9iYWxPcHRpb25zYCB3aWxsIGFsd2F5cyBiZSByZXR1cm5lZCwgdW5sZXNzIHRoZXkgYXJlIG92ZXJyaWRkZW4gYnkgb3B0aW9ucyBpbiB0aGUgYHVpU2NoZW1hYC5cbiAqXG4gKiBAcGFyYW0gW3VpU2NoZW1hPXt9XSAtIFRoZSBVSSBTY2hlbWEgZnJvbSB3aGljaCB0byBnZXQgYW55IGB1aTp4eHhgIG9wdGlvbnNcbiAqIEBwYXJhbSBbZ2xvYmFsT3B0aW9ucz17fV0gLSBUaGUgb3B0aW9uYWwgR2xvYmFsIFVJIFNjaGVtYSBmcm9tIHdoaWNoIHRvIGdldCBhbnkgZmFsbGJhY2sgYHh4eGAgb3B0aW9uc1xuICogQHJldHVybnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGB1aTp4eHhgIG9wdGlvbnMgd2l0aCB0aGUgYHVpOmAgc3RyaXBwZWQgb2ZmIGFsb25nIHdpdGggYWxsIGBnbG9iYWxPcHRpb25zYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVaU9wdGlvbnModWlTY2hlbWEgPSB7fSwgZ2xvYmFsT3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHVpU2NoZW1hKVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IGtleS5pbmRleE9mKCd1aTonKSA9PT0gMClcbiAgICAgICAgLnJlZHVjZSgob3B0aW9ucywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdWlTY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKGtleSA9PT0gVUlfV0lER0VUX0tFWSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NldHRpbmcgb3B0aW9ucyB2aWEgdWk6d2lkZ2V0IG9iamVjdCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCB1c2UgdWk6b3B0aW9ucyBpbnN0ZWFkJyk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBVSV9PUFRJT05TX0tFWSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIC4uLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgW2tleS5zdWJzdHJpbmcoMyldOiB2YWx1ZSB9O1xuICAgIH0sIHsgLi4uZ2xvYmFsT3B0aW9ucyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFVpT3B0aW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdElzIGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9zZXQnO1xuaW1wb3J0IGdldFNjaGVtYVR5cGUgZnJvbSAnLi9nZXRTY2hlbWFUeXBlJztcbi8qKiBUaGUgbWFwIG9mIHNjaGVtYSB0eXBlcyB0byB3aWRnZXQgdHlwZSB0byB3aWRnZXQgbmFtZVxuICovXG5jb25zdCB3aWRnZXRNYXAgPSB7XG4gICAgYm9vbGVhbjoge1xuICAgICAgICBjaGVja2JveDogJ0NoZWNrYm94V2lkZ2V0JyxcbiAgICAgICAgcmFkaW86ICdSYWRpb1dpZGdldCcsXG4gICAgICAgIHNlbGVjdDogJ1NlbGVjdFdpZGdldCcsXG4gICAgICAgIGhpZGRlbjogJ0hpZGRlbldpZGdldCcsXG4gICAgfSxcbiAgICBzdHJpbmc6IHtcbiAgICAgICAgdGV4dDogJ1RleHRXaWRnZXQnLFxuICAgICAgICBwYXNzd29yZDogJ1Bhc3N3b3JkV2lkZ2V0JyxcbiAgICAgICAgZW1haWw6ICdFbWFpbFdpZGdldCcsXG4gICAgICAgIGhvc3RuYW1lOiAnVGV4dFdpZGdldCcsXG4gICAgICAgIGlwdjQ6ICdUZXh0V2lkZ2V0JyxcbiAgICAgICAgaXB2NjogJ1RleHRXaWRnZXQnLFxuICAgICAgICB1cmk6ICdVUkxXaWRnZXQnLFxuICAgICAgICAnZGF0YS11cmwnOiAnRmlsZVdpZGdldCcsXG4gICAgICAgIHJhZGlvOiAnUmFkaW9XaWRnZXQnLFxuICAgICAgICBzZWxlY3Q6ICdTZWxlY3RXaWRnZXQnLFxuICAgICAgICB0ZXh0YXJlYTogJ1RleHRhcmVhV2lkZ2V0JyxcbiAgICAgICAgaGlkZGVuOiAnSGlkZGVuV2lkZ2V0JyxcbiAgICAgICAgZGF0ZTogJ0RhdGVXaWRnZXQnLFxuICAgICAgICBkYXRldGltZTogJ0RhdGVUaW1lV2lkZ2V0JyxcbiAgICAgICAgJ2RhdGUtdGltZSc6ICdEYXRlVGltZVdpZGdldCcsXG4gICAgICAgICdhbHQtZGF0ZSc6ICdBbHREYXRlV2lkZ2V0JyxcbiAgICAgICAgJ2FsdC1kYXRldGltZSc6ICdBbHREYXRlVGltZVdpZGdldCcsXG4gICAgICAgIHRpbWU6ICdUaW1lV2lkZ2V0JyxcbiAgICAgICAgY29sb3I6ICdDb2xvcldpZGdldCcsXG4gICAgICAgIGZpbGU6ICdGaWxlV2lkZ2V0JyxcbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgICB0ZXh0OiAnVGV4dFdpZGdldCcsXG4gICAgICAgIHNlbGVjdDogJ1NlbGVjdFdpZGdldCcsXG4gICAgICAgIHVwZG93bjogJ1VwRG93bldpZGdldCcsXG4gICAgICAgIHJhbmdlOiAnUmFuZ2VXaWRnZXQnLFxuICAgICAgICByYWRpbzogJ1JhZGlvV2lkZ2V0JyxcbiAgICAgICAgaGlkZGVuOiAnSGlkZGVuV2lkZ2V0JyxcbiAgICB9LFxuICAgIGludGVnZXI6IHtcbiAgICAgICAgdGV4dDogJ1RleHRXaWRnZXQnLFxuICAgICAgICBzZWxlY3Q6ICdTZWxlY3RXaWRnZXQnLFxuICAgICAgICB1cGRvd246ICdVcERvd25XaWRnZXQnLFxuICAgICAgICByYW5nZTogJ1JhbmdlV2lkZ2V0JyxcbiAgICAgICAgcmFkaW86ICdSYWRpb1dpZGdldCcsXG4gICAgICAgIGhpZGRlbjogJ0hpZGRlbldpZGdldCcsXG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgICBzZWxlY3Q6ICdTZWxlY3RXaWRnZXQnLFxuICAgICAgICBjaGVja2JveGVzOiAnQ2hlY2tib3hlc1dpZGdldCcsXG4gICAgICAgIGZpbGVzOiAnRmlsZVdpZGdldCcsXG4gICAgICAgIGhpZGRlbjogJ0hpZGRlbldpZGdldCcsXG4gICAgfSxcbn07XG4vKiogV3JhcHMgdGhlIGdpdmVuIHdpZGdldCB3aXRoIHN0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudCB0aGF0IHdpbGwgbWVyZ2UgYW55IGBkZWZhdWx0UHJvcHMub3B0aW9uc2Agd2l0aCB0aGVcbiAqIGBvcHRpb25zYCB0aGF0IGFyZSBwcm92aWRlZCBpbiB0aGUgcHJvcHMuIEl0IHdpbGwgYWRkIHRoZSB3cmFwcGVyIGNvbXBvbmVudCBhcyBhIGBNZXJnZWRXaWRnZXRgIHByb3BlcnR5IG9udG8gdGhlXG4gKiBgV2lkZ2V0YCBzbyB0aGF0IGZ1dHVyZSBhdHRlbXB0cyB0byB3cmFwIGBBV2lkZ2V0YCB3aWxsIHJldHVybiB0aGUgYWxyZWFkeSBleGlzdGluZyB3cmFwcGVyLlxuICpcbiAqIEBwYXJhbSBBV2lkZ2V0IC0gQSB3aWRnZXQgdGhhdCB3aWxsIGJlIHdyYXBwZWQgb3Igb25lIHRoYXQgaXMgYWxyZWFkeSB3cmFwcGVkXG4gKiBAcmV0dXJucyAtIFRoZSB3cmFwcGVyIHdpZGdldFxuICovXG5mdW5jdGlvbiBtZXJnZVdpZGdldE9wdGlvbnMoQVdpZGdldCkge1xuICAgIGxldCBNZXJnZWRXaWRnZXQgPSBnZXQoQVdpZGdldCwgJ01lcmdlZFdpZGdldCcpO1xuICAgIC8vIGNhY2hlIHJldHVybiB2YWx1ZSBhcyBwcm9wZXJ0eSBvZiB3aWRnZXQgZm9yIHByb3BlciByZWFjdCByZWNvbmNpbGlhdGlvblxuICAgIGlmICghTWVyZ2VkV2lkZ2V0KSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gKEFXaWRnZXQuZGVmYXVsdFByb3BzICYmIEFXaWRnZXQuZGVmYXVsdFByb3BzLm9wdGlvbnMpIHx8IHt9O1xuICAgICAgICBNZXJnZWRXaWRnZXQgPSAoeyBvcHRpb25zLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gX2pzeChBV2lkZ2V0LCB7IG9wdGlvbnM6IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfSwgLi4ucHJvcHMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHNldChBV2lkZ2V0LCAnTWVyZ2VkV2lkZ2V0JywgTWVyZ2VkV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIE1lcmdlZFdpZGdldDtcbn1cbi8qKiBHaXZlbiBhIHNjaGVtYSByZXByZXNlbnRpbmcgYSBmaWVsZCB0byByZW5kZXIgYW5kIGVpdGhlciB0aGUgbmFtZSBvciBhY3R1YWwgYFdpZGdldGAgaW1wbGVtZW50YXRpb24sIHJldHVybnMgdGhlXG4gKiBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgd2lkZ2V0LiBJZiB0aGUgYHdpZGdldGAgaXMgYWxyZWFkeSBhIFJlYWN0IGNvbXBvbmVudCwgdGhlbiBpdCBpcyB3cmFwcGVkXG4gKiB3aXRoIGEgYE1lcmdlZFdpZGdldGAuIE90aGVyd2lzZSBhbiBhdHRlbXB0IGlzIG1hZGUgdG8gbG9vayB1cCB0aGUgd2lkZ2V0IGluc2lkZSBvZiB0aGUgYHJlZ2lzdGVyZWRXaWRnZXRzYCBtYXAgYmFzZWRcbiAqIG9uIHRoZSBzY2hlbWEgdHlwZSBhbmQgYHdpZGdldGAgbmFtZS4gSWYgbm8gd2lkZ2V0IGNvbXBvbmVudCBjYW4gYmUgZm91bmQgYW4gYEVycm9yYCBpcyB0aHJvd24uXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHRoZSBmaWVsZFxuICogQHBhcmFtIFt3aWRnZXRdIC0gRWl0aGVyIHRoZSBuYW1lIG9mIHRoZSB3aWRnZXQgT1IgYSBgV2lkZ2V0YCBpbXBsZW1lbnRhdGlvbiB0byB1c2VcbiAqIEBwYXJhbSBbcmVnaXN0ZXJlZFdpZGdldHM9e31dIC0gQSByZWdpc3RyeSBvZiB3aWRnZXQgbmFtZSB0byBgV2lkZ2V0YCBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMgLSBUaGUgYFdpZGdldGAgY29tcG9uZW50IHRvIHVzZVxuICogQHRocm93cyAtIEFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGBXaWRnZXRgIGNvbXBvbmVudCB0aGF0IGNhbiBiZSByZXR1cm5lZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHJlZ2lzdGVyZWRXaWRnZXRzID0ge30pIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0U2NoZW1hVHlwZShzY2hlbWEpO1xuICAgIGlmICh0eXBlb2Ygd2lkZ2V0ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICh3aWRnZXQgJiYgUmVhY3RJcy5pc0ZvcndhcmRSZWYoY3JlYXRlRWxlbWVudCh3aWRnZXQpKSkgfHxcbiAgICAgICAgUmVhY3RJcy5pc01lbW8od2lkZ2V0KSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VXaWRnZXRPcHRpb25zKHdpZGdldCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2lkZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHdpZGdldCBkZWZpbml0aW9uOiAke3R5cGVvZiB3aWRnZXR9YCk7XG4gICAgfVxuICAgIGlmICh3aWRnZXQgaW4gcmVnaXN0ZXJlZFdpZGdldHMpIHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFdpZGdldCA9IHJlZ2lzdGVyZWRXaWRnZXRzW3dpZGdldF07XG4gICAgICAgIHJldHVybiBnZXRXaWRnZXQoc2NoZW1hLCByZWdpc3RlcmVkV2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiB3aWRnZXRNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHdpZGdldCBmb3IgdHlwZSAnJHt0eXBlfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkZ2V0IGluIHdpZGdldE1hcFt0eXBlXSkge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFdpZGdldCA9IHJlZ2lzdGVyZWRXaWRnZXRzW3dpZGdldE1hcFt0eXBlXVt3aWRnZXRdXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRXaWRnZXQoc2NoZW1hLCByZWdpc3RlcmVkV2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyB3aWRnZXQgJyR7d2lkZ2V0fScgZm9yIHR5cGUgJyR7dHlwZX0nYCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRXaWRnZXQuanMubWFwIiwiLyoqIEdpdmVuIGEgc3BlY2lmaWMgYHZhbHVlYCBhdHRlbXB0cyB0byBndWVzcyB0aGUgdHlwZSBvZiBhIHNjaGVtYSBlbGVtZW50LiBJbiB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIHRvIGltcGxpY2l0bHlcbiAqICBjcmVhdGUgYSBzY2hlbWEsIGl0IGlzIHVzZWZ1bCB0byBrbm93IHdoYXQgdHlwZSB0byB1c2UgYmFzZWQgb24gdGhlIGRhdGEgd2UgYXJlIGRlZmluaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmcm9tIHdoaWNoIHRvIGd1ZXNzIHRoZSB0eXBlXG4gKiBAcmV0dXJucyAtIFRoZSBiZXN0IGd1ZXNzIGZvciB0aGUgb2JqZWN0IHR5cGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3Vlc3NUeXBlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgLy8gRGVmYXVsdCB0byBzdHJpbmcgaWYgd2UgY2FuJ3QgZmlndXJlIGl0IG91dFxuICAgIHJldHVybiAnc3RyaW5nJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWd1ZXNzVHlwZS5qcy5tYXAiLCJpbXBvcnQgZ2V0V2lkZ2V0IGZyb20gJy4vZ2V0V2lkZ2V0Jztcbi8qKiBEZXRlY3RzIHdoZXRoZXIgdGhlIGB3aWRnZXRgIGV4aXN0cyBmb3IgdGhlIGBzY2hlbWFgIHdpdGggdGhlIGFzc29jaWF0ZWQgYHJlZ2lzdHJ5V2lkZ2V0c2AgYW5kIHJldHVybnMgdHJ1ZSBpZiBpdFxuICogZG9lcywgb3IgZmFsc2UgaWYgaXQgZG9lc24ndC5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3IgdGhlIGZpZWxkXG4gKiBAcGFyYW0gd2lkZ2V0IC0gRWl0aGVyIHRoZSBuYW1lIG9mIHRoZSB3aWRnZXQgT1IgYSBgV2lkZ2V0YCBpbXBsZW1lbnRhdGlvbiB0byB1c2VcbiAqIEBwYXJhbSBbcmVnaXN0ZXJlZFdpZGdldHM9e31dIC0gQSByZWdpc3RyeSBvZiB3aWRnZXQgbmFtZSB0byBgV2lkZ2V0YCBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSB3aWRnZXQgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFzV2lkZ2V0KHNjaGVtYSwgd2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0V2lkZ2V0KHNjaGVtYSwgd2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgKGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ05vIHdpZGdldCcpIHx8IGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ1Vuc3VwcG9ydGVkIHdpZGdldCcpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzV2lkZ2V0LmpzLm1hcCIsIi8qKiBKUyBoYXMgbm8gYnVpbHQtaW4gaGFzaGluZyBmdW5jdGlvbiwgc28gcm9sbGluZyBvdXIgb3duXG4gKiAgYmFzZWQgb24gSmF2YSdzIGhhc2hpbmcgZm46XG4gKiAgaHR0cDovL3d3dy5qYXZhMnMuY29tL2V4YW1wbGUvbm9kZWpzLXV0aWxpdHktbWV0aG9kL3N0cmluZy1oYXNoL2hhc2hjb2RlLTRkYzJiLmh0bWxcbiAqXG4gKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHN0cmluZyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBoYXNoXG4gKiBAcmV0dXJucyAtIFRoZSByZXN1bHRpbmcgaGFzaCBvZiB0aGUgc3RyaW5nIGluIGhleCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gaGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgICBsZXQgaGFzaCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIHJldHVybiBoYXNoLnRvU3RyaW5nKDE2KTtcbn1cbi8qKiBTdHJpbmdpZmllcyB0aGUgc2NoZW1hIGFuZCByZXR1cm5zIHRoZSBoYXNoIG9mIHRoZSByZXN1bHRpbmcgc3RyaW5nLiBTb3J0cyBzY2hlbWEgZmllbGRzXG4gKiBpbiBjb25zaXN0ZW50IG9yZGVyIGJlZm9yZSBzdHJpbmdpZnkgdG8gcHJldmVudCBkaWZmZXJlbnQgaGFzaCBpZHMgZm9yIHRoZSBzYW1lIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIGhhc2ggaXMgZGVzaXJlZFxuICogQHJldHVybnMgLSBUaGUgc3RyaW5nIG9idGFpbmVkIGZyb20gdGhlIGhhc2ggb2YgdGhlIHN0cmluZ2lmaWVkIHNjaGVtYVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYXNoRm9yU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IGFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgLy8gc29sdXRpb24gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjE2NzU4MS9zb3J0LW9iamVjdC1wcm9wZXJ0aWVzLWFuZC1qc29uLXN0cmluZ2lmeS81MzU5MzMyOCM1MzU5MzMyOFxuICAgIEpTT04uc3RyaW5naWZ5KHNjaGVtYSwgKGtleSwgdmFsdWUpID0+IChhbGxLZXlzLmFkZChrZXkpLCB2YWx1ZSkpO1xuICAgIHJldHVybiBoYXNoU3RyaW5nKEpTT04uc3RyaW5naWZ5KHNjaGVtYSwgQXJyYXkuZnJvbShhbGxLZXlzKS5zb3J0KCkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hGb3JTY2hlbWEuanMubWFwIiwiaW1wb3J0IGlzU3RyaW5nIGZyb20gJ2xvZGFzaC9pc1N0cmluZyc7XG5pbXBvcnQgeyBJRF9LRVkgfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKiogR2VuZXJhdGVzIGEgY29uc2lzdGVudCBgaWRgIHBhdHRlcm4gZm9yIGEgZ2l2ZW4gYGlkYCBhbmQgYSBgc3VmZml4YFxuICpcbiAqIEBwYXJhbSBpZCAtIEVpdGhlciBzaW1wbGUgc3RyaW5nIGlkIG9yIGFuIElkU2NoZW1hIGZyb20gd2hpY2ggdG8gZXh0cmFjdCBpdFxuICogQHBhcmFtIHN1ZmZpeCAtIFRoZSBzdWZmaXggdG8gYXBwZW5kIHRvIHRoZSBpZFxuICovXG5mdW5jdGlvbiBpZEdlbmVyYXRvcihpZCwgc3VmZml4KSB7XG4gICAgY29uc3QgdGhlSWQgPSBpc1N0cmluZyhpZCkgPyBpZCA6IGlkW0lEX0tFWV07XG4gICAgcmV0dXJuIGAke3RoZUlkfV9fJHtzdWZmaXh9YDtcbn1cbi8qKiBSZXR1cm4gYSBjb25zaXN0ZW50IGBpZGAgZm9yIHRoZSBmaWVsZCBkZXNjcmlwdGlvbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIGlkIC0gRWl0aGVyIHNpbXBsZSBzdHJpbmcgaWQgb3IgYW4gSWRTY2hlbWEgZnJvbSB3aGljaCB0byBleHRyYWN0IGl0XG4gKiBAcmV0dXJucyAtIFRoZSBjb25zaXN0ZW50IGlkIGZvciB0aGUgZmllbGQgZGVzY3JpcHRpb24gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBgaWRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmlwdGlvbklkKGlkKSB7XG4gICAgcmV0dXJuIGlkR2VuZXJhdG9yKGlkLCAnZGVzY3JpcHRpb24nKTtcbn1cbi8qKiBSZXR1cm4gYSBjb25zaXN0ZW50IGBpZGAgZm9yIHRoZSBmaWVsZCBlcnJvciBlbGVtZW50XG4gKlxuICogQHBhcmFtIGlkIC0gRWl0aGVyIHNpbXBsZSBzdHJpbmcgaWQgb3IgYW4gSWRTY2hlbWEgZnJvbSB3aGljaCB0byBleHRyYWN0IGl0XG4gKiBAcmV0dXJucyAtIFRoZSBjb25zaXN0ZW50IGlkIGZvciB0aGUgZmllbGQgZXJyb3IgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBgaWRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvcklkKGlkKSB7XG4gICAgcmV0dXJuIGlkR2VuZXJhdG9yKGlkLCAnZXJyb3InKTtcbn1cbi8qKiBSZXR1cm4gYSBjb25zaXN0ZW50IGBpZGAgZm9yIHRoZSBmaWVsZCBleGFtcGxlcyBlbGVtZW50XG4gKlxuICogQHBhcmFtIGlkIC0gRWl0aGVyIHNpbXBsZSBzdHJpbmcgaWQgb3IgYW4gSWRTY2hlbWEgZnJvbSB3aGljaCB0byBleHRyYWN0IGl0XG4gKiBAcmV0dXJucyAtIFRoZSBjb25zaXN0ZW50IGlkIGZvciB0aGUgZmllbGQgZXhhbXBsZXMgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBgaWRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFtcGxlc0lkKGlkKSB7XG4gICAgcmV0dXJuIGlkR2VuZXJhdG9yKGlkLCAnZXhhbXBsZXMnKTtcbn1cbi8qKiBSZXR1cm4gYSBjb25zaXN0ZW50IGBpZGAgZm9yIHRoZSBmaWVsZCBoZWxwIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gaWQgLSBFaXRoZXIgc2ltcGxlIHN0cmluZyBpZCBvciBhbiBJZFNjaGVtYSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgaXRcbiAqIEByZXR1cm5zIC0gVGhlIGNvbnNpc3RlbnQgaWQgZm9yIHRoZSBmaWVsZCBoZWxwIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYGlkYFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVscElkKGlkKSB7XG4gICAgcmV0dXJuIGlkR2VuZXJhdG9yKGlkLCAnaGVscCcpO1xufVxuLyoqIFJldHVybiBhIGNvbnNpc3RlbnQgYGlkYCBmb3IgdGhlIGZpZWxkIHRpdGxlIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gaWQgLSBFaXRoZXIgc2ltcGxlIHN0cmluZyBpZCBvciBhbiBJZFNjaGVtYSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgaXRcbiAqIEByZXR1cm5zIC0gVGhlIGNvbnNpc3RlbnQgaWQgZm9yIHRoZSBmaWVsZCB0aXRsZSBlbGVtZW50IGZyb20gdGhlIGdpdmVuIGBpZGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpdGxlSWQoaWQpIHtcbiAgICByZXR1cm4gaWRHZW5lcmF0b3IoaWQsICd0aXRsZScpO1xufVxuLyoqIFJldHVybiBhIGxpc3Qgb2YgZWxlbWVudCBpZHMgdGhhdCBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZpZWxkIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXMgdGhlIGFyaWFcbiAqIGRlc2NyaXB0aW9uIG9mIHRoZSBmaWVsZC4gVGhpcyBpcyBjb3JyZWN0bHkgb21pdHRpbmcgYHRpdGxlSWRgIHdoaWNoIHdvdWxkIGJlIFwibGFiZWxpbmdcIiByYXRoZXIgdGhhbiBcImRlc2NyaWJpbmdcIiB0aGVcbiAqIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIGlkIC0gRWl0aGVyIHNpbXBsZSBzdHJpbmcgaWQgb3IgYW4gSWRTY2hlbWEgZnJvbSB3aGljaCB0byBleHRyYWN0IGl0XG4gKiBAcGFyYW0gW2luY2x1ZGVFeGFtcGxlcz1mYWxzZV0gLSBPcHRpb25hbCBmbGFnLCBpZiB0cnVlLCB3aWxsIGFkZCB0aGUgYGV4YW1wbGVzSWRgIGludG8gdGhlIGxpc3RcbiAqIEByZXR1cm5zIC0gVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBsaXN0IG9mIGlkcyBmb3IgdXNlIGluIGFuIGBhcmlhLWRlc2NyaWJlZEJ5YCBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyaWFEZXNjcmliZWRCeUlkcyhpZCwgaW5jbHVkZUV4YW1wbGVzID0gZmFsc2UpIHtcbiAgICBjb25zdCBleGFtcGxlcyA9IGluY2x1ZGVFeGFtcGxlcyA/IGAgJHtleGFtcGxlc0lkKGlkKX1gIDogJyc7XG4gICAgcmV0dXJuIGAke2Vycm9ySWQoaWQpfSAke2Rlc2NyaXB0aW9uSWQoaWQpfSAke2hlbHBJZChpZCl9JHtleGFtcGxlc31gO1xufVxuLyoqIFJldHVybiBhIGNvbnNpc3RlbnQgYGlkYCBmb3IgdGhlIGBvcHRpb25JbmRleGBzIG9mIGEgYFJhZGlvYCBvciBgQ2hlY2tib3hlc2Agd2lkZ2V0XG4gKlxuICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50IGZvciB0aGUgb3B0aW9uXG4gKiBAcGFyYW0gb3B0aW9uSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG9wdGlvbiBmb3Igd2hpY2ggdGhlIGlkIGlzIGRlc2lyZWRcbiAqIEByZXR1cm5zIC0gQW4gaWQgZm9yIHRoZSBvcHRpb24gaW5kZXggYmFzZWQgb24gdGhlIHBhcmVudCBgaWRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25JZChpZCwgb3B0aW9uSW5kZXgpIHtcbiAgICByZXR1cm4gYCR7aWR9LSR7b3B0aW9uSW5kZXh9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkR2VuZXJhdG9ycy5qcy5tYXAiLCJpbXBvcnQgYWxsb3dBZGRpdGlvbmFsSXRlbXMgZnJvbSAnLi9hbGxvd0FkZGl0aW9uYWxJdGVtcyc7XG5pbXBvcnQgYXNOdW1iZXIgZnJvbSAnLi9hc051bWJlcic7XG5pbXBvcnQgY2FuRXhwYW5kIGZyb20gJy4vY2FuRXhwYW5kJztcbmltcG9ydCBjcmVhdGVFcnJvckhhbmRsZXIgZnJvbSAnLi9jcmVhdGVFcnJvckhhbmRsZXInO1xuaW1wb3J0IGNyZWF0ZVNjaGVtYVV0aWxzIGZyb20gJy4vY3JlYXRlU2NoZW1hVXRpbHMnO1xuaW1wb3J0IGRhdGFVUkl0b0Jsb2IgZnJvbSAnLi9kYXRhVVJJdG9CbG9iJztcbmltcG9ydCBkZWVwRXF1YWxzIGZyb20gJy4vZGVlcEVxdWFscyc7XG5pbXBvcnQgZW5nbGlzaFN0cmluZ1RyYW5zbGF0b3IgZnJvbSAnLi9lbmdsaXNoU3RyaW5nVHJhbnNsYXRvcic7XG5pbXBvcnQgZW51bU9wdGlvbnNEZXNlbGVjdFZhbHVlIGZyb20gJy4vZW51bU9wdGlvbnNEZXNlbGVjdFZhbHVlJztcbmltcG9ydCBlbnVtT3B0aW9uc0luZGV4Rm9yVmFsdWUgZnJvbSAnLi9lbnVtT3B0aW9uc0luZGV4Rm9yVmFsdWUnO1xuaW1wb3J0IGVudW1PcHRpb25zSXNTZWxlY3RlZCBmcm9tICcuL2VudW1PcHRpb25zSXNTZWxlY3RlZCc7XG5pbXBvcnQgZW51bU9wdGlvbnNTZWxlY3RWYWx1ZSBmcm9tICcuL2VudW1PcHRpb25zU2VsZWN0VmFsdWUnO1xuaW1wb3J0IGVudW1PcHRpb25zVmFsdWVGb3JJbmRleCBmcm9tICcuL2VudW1PcHRpb25zVmFsdWVGb3JJbmRleCc7XG5pbXBvcnQgRXJyb3JTY2hlbWFCdWlsZGVyIGZyb20gJy4vRXJyb3JTY2hlbWFCdWlsZGVyJztcbmltcG9ydCBmaW5kU2NoZW1hRGVmaW5pdGlvbiBmcm9tICcuL2ZpbmRTY2hlbWFEZWZpbml0aW9uJztcbmltcG9ydCBnZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hIGZyb20gJy4vZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYSc7XG5pbXBvcnQgZ2V0SW5wdXRQcm9wcyBmcm9tICcuL2dldElucHV0UHJvcHMnO1xuaW1wb3J0IGdldFNjaGVtYVR5cGUgZnJvbSAnLi9nZXRTY2hlbWFUeXBlJztcbmltcG9ydCBnZXRTdWJtaXRCdXR0b25PcHRpb25zIGZyb20gJy4vZ2V0U3VibWl0QnV0dG9uT3B0aW9ucyc7XG5pbXBvcnQgZ2V0VGVtcGxhdGUgZnJvbSAnLi9nZXRUZW1wbGF0ZSc7XG5pbXBvcnQgZ2V0VWlPcHRpb25zIGZyb20gJy4vZ2V0VWlPcHRpb25zJztcbmltcG9ydCBnZXRXaWRnZXQgZnJvbSAnLi9nZXRXaWRnZXQnO1xuaW1wb3J0IGd1ZXNzVHlwZSBmcm9tICcuL2d1ZXNzVHlwZSc7XG5pbXBvcnQgaGFzaEZvclNjaGVtYSBmcm9tICcuL2hhc2hGb3JTY2hlbWEnO1xuaW1wb3J0IGhhc1dpZGdldCBmcm9tICcuL2hhc1dpZGdldCc7XG5pbXBvcnQgeyBhcmlhRGVzY3JpYmVkQnlJZHMsIGRlc2NyaXB0aW9uSWQsIGVycm9ySWQsIGV4YW1wbGVzSWQsIGhlbHBJZCwgb3B0aW9uSWQsIHRpdGxlSWQgfSBmcm9tICcuL2lkR2VuZXJhdG9ycyc7XG5pbXBvcnQgaXNDb25zdGFudCBmcm9tICcuL2lzQ29uc3RhbnQnO1xuaW1wb3J0IGlzQ3VzdG9tV2lkZ2V0IGZyb20gJy4vaXNDdXN0b21XaWRnZXQnO1xuaW1wb3J0IGlzRml4ZWRJdGVtcyBmcm9tICcuL2lzRml4ZWRJdGVtcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdCc7XG5pbXBvcnQgbGFiZWxWYWx1ZSBmcm9tICcuL2xhYmVsVmFsdWUnO1xuaW1wb3J0IGxvY2FsVG9VVEMgZnJvbSAnLi9sb2NhbFRvVVRDJztcbmltcG9ydCBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhIGZyb20gJy4vbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YSc7XG5pbXBvcnQgbWVyZ2VPYmplY3RzIGZyb20gJy4vbWVyZ2VPYmplY3RzJztcbmltcG9ydCBtZXJnZVNjaGVtYXMgZnJvbSAnLi9tZXJnZVNjaGVtYXMnO1xuaW1wb3J0IG9wdGlvbnNMaXN0IGZyb20gJy4vb3B0aW9uc0xpc3QnO1xuaW1wb3J0IG9yZGVyUHJvcGVydGllcyBmcm9tICcuL29yZGVyUHJvcGVydGllcyc7XG5pbXBvcnQgcGFkIGZyb20gJy4vcGFkJztcbmltcG9ydCBwYXJzZURhdGVTdHJpbmcgZnJvbSAnLi9wYXJzZURhdGVTdHJpbmcnO1xuaW1wb3J0IHJhbmdlU3BlYyBmcm9tICcuL3JhbmdlU3BlYyc7XG5pbXBvcnQgcmVwbGFjZVN0cmluZ1BhcmFtZXRlcnMgZnJvbSAnLi9yZXBsYWNlU3RyaW5nUGFyYW1ldGVycyc7XG5pbXBvcnQgc2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUgZnJvbSAnLi9zY2hlbWFSZXF1aXJlc1RydWVWYWx1ZSc7XG5pbXBvcnQgc2hvdWxkUmVuZGVyIGZyb20gJy4vc2hvdWxkUmVuZGVyJztcbmltcG9ydCB0b0NvbnN0YW50IGZyb20gJy4vdG9Db25zdGFudCc7XG5pbXBvcnQgdG9EYXRlU3RyaW5nIGZyb20gJy4vdG9EYXRlU3RyaW5nJztcbmltcG9ydCB0b0Vycm9yTGlzdCBmcm9tICcuL3RvRXJyb3JMaXN0JztcbmltcG9ydCB0b0Vycm9yU2NoZW1hIGZyb20gJy4vdG9FcnJvclNjaGVtYSc7XG5pbXBvcnQgdW53cmFwRXJyb3JIYW5kbGVyIGZyb20gJy4vdW53cmFwRXJyb3JIYW5kbGVyJztcbmltcG9ydCB1dGNUb0xvY2FsIGZyb20gJy4vdXRjVG9Mb2NhbCc7XG5pbXBvcnQgdmFsaWRhdGlvbkRhdGFNZXJnZSBmcm9tICcuL3ZhbGlkYXRpb25EYXRhTWVyZ2UnO1xuaW1wb3J0IHdpdGhJZFJlZlByZWZpeCBmcm9tICcuL3dpdGhJZFJlZlByZWZpeCc7XG5pbXBvcnQgZ2V0T3B0aW9uTWF0Y2hpbmdTaW1wbGVEaXNjcmltaW5hdG9yIGZyb20gJy4vZ2V0T3B0aW9uTWF0Y2hpbmdTaW1wbGVEaXNjcmltaW5hdG9yJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgKiBmcm9tICcuL3BhcnNlcic7XG5leHBvcnQgKiBmcm9tICcuL3NjaGVtYSc7XG5leHBvcnQgeyBhbGxvd0FkZGl0aW9uYWxJdGVtcywgYXJpYURlc2NyaWJlZEJ5SWRzLCBhc051bWJlciwgY2FuRXhwYW5kLCBjcmVhdGVFcnJvckhhbmRsZXIsIGNyZWF0ZVNjaGVtYVV0aWxzLCBkYXRhVVJJdG9CbG9iLCBkZWVwRXF1YWxzLCBkZXNjcmlwdGlvbklkLCBlbmdsaXNoU3RyaW5nVHJhbnNsYXRvciwgZW51bU9wdGlvbnNEZXNlbGVjdFZhbHVlLCBlbnVtT3B0aW9uc0luZGV4Rm9yVmFsdWUsIGVudW1PcHRpb25zSXNTZWxlY3RlZCwgZW51bU9wdGlvbnNTZWxlY3RWYWx1ZSwgZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4LCBlcnJvcklkLCBleGFtcGxlc0lkLCBFcnJvclNjaGVtYUJ1aWxkZXIsIGZpbmRTY2hlbWFEZWZpbml0aW9uLCBnZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hLCBnZXRJbnB1dFByb3BzLCBnZXRPcHRpb25NYXRjaGluZ1NpbXBsZURpc2NyaW1pbmF0b3IsIGdldFNjaGVtYVR5cGUsIGdldFN1Ym1pdEJ1dHRvbk9wdGlvbnMsIGdldFRlbXBsYXRlLCBnZXRVaU9wdGlvbnMsIGdldFdpZGdldCwgZ3Vlc3NUeXBlLCBoYXNXaWRnZXQsIGhhc2hGb3JTY2hlbWEsIGhlbHBJZCwgaXNDb25zdGFudCwgaXNDdXN0b21XaWRnZXQsIGlzRml4ZWRJdGVtcywgaXNPYmplY3QsIGxhYmVsVmFsdWUsIGxvY2FsVG9VVEMsIG1lcmdlRGVmYXVsdHNXaXRoRm9ybURhdGEsIG1lcmdlT2JqZWN0cywgbWVyZ2VTY2hlbWFzLCBvcHRpb25JZCwgb3B0aW9uc0xpc3QsIG9yZGVyUHJvcGVydGllcywgcGFkLCBwYXJzZURhdGVTdHJpbmcsIHJhbmdlU3BlYywgcmVwbGFjZVN0cmluZ1BhcmFtZXRlcnMsIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlLCBzaG91bGRSZW5kZXIsIHRpdGxlSWQsIHRvQ29uc3RhbnQsIHRvRGF0ZVN0cmluZywgdG9FcnJvckxpc3QsIHRvRXJyb3JTY2hlbWEsIHVud3JhcEVycm9ySGFuZGxlciwgdXRjVG9Mb2NhbCwgdmFsaWRhdGlvbkRhdGFNZXJnZSwgd2l0aElkUmVmUHJlZml4LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgQ09OU1RfS0VZIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuLyoqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBnaXZlbiBgc2NoZW1hYCBtYXRjaGVzIGEgc2luZ2xlIGNvbnN0YW50IHZhbHVlLiBUaGlzIGhhcHBlbnMgd2hlbiBlaXRoZXIgdGhlIHNjaGVtYSBoYXNcbiAqIGFuIGBlbnVtYCBhcnJheSB3aXRoIGEgc2luZ2xlIHZhbHVlIG9yIHRoZXJlIGlzIGEgYGNvbnN0YCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciBhIGZpZWxkXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGBzY2hlbWFgIGhhcyBhIHNpbmdsZSBjb25zdGFudCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ29uc3RhbnQoc2NoZW1hKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSAmJiBzY2hlbWEuZW51bS5sZW5ndGggPT09IDEpIHx8IENPTlNUX0tFWSBpbiBzY2hlbWE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0NvbnN0YW50LmpzLm1hcCIsImltcG9ydCBnZXRVaU9wdGlvbnMgZnJvbSAnLi9nZXRVaU9wdGlvbnMnO1xuLyoqIENoZWNrcyB0byBzZWUgaWYgdGhlIGB1aVNjaGVtYWAgY29udGFpbnMgdGhlIGB3aWRnZXRgIGZpZWxkIGFuZCB0aGF0IHRoZSB3aWRnZXQgaXMgbm90IGBoaWRkZW5gXG4gKlxuICogQHBhcmFtIHVpU2NoZW1hIC0gVGhlIFVJIFNjaGVtYSBmcm9tIHdoaWNoIHRvIGRldGVjdCBpZiBpdCBpcyBjdXN0b21pemVkXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGB1aVNjaGVtYWAgZGVzY3JpYmVzIGEgY3VzdG9tIHdpZGdldCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ3VzdG9tV2lkZ2V0KHVpU2NoZW1hID0ge30pIHtcbiAgICByZXR1cm4gKFxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGUgYCYmIHVpU2NoZW1hWyd1aTp3aWRnZXQnXSAhPT0gJ2hpZGRlbidgIG9uY2Ugd2Ugc3VwcG9ydCBoaWRkZW4gd2lkZ2V0cyBmb3IgYXJyYXlzLlxuICAgIC8vIGh0dHBzOi8vcmpzZi10ZWFtLmdpdGh1Yi5pby9yZWFjdC1qc29uc2NoZW1hLWZvcm0vZG9jcy91c2FnZS93aWRnZXRzLyNoaWRkZW4td2lkZ2V0c1xuICAgICd3aWRnZXQnIGluIGdldFVpT3B0aW9ucyh1aVNjaGVtYSkgJiYgZ2V0VWlPcHRpb25zKHVpU2NoZW1hKVsnd2lkZ2V0J10gIT09ICdoaWRkZW4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQ3VzdG9tV2lkZ2V0LmpzLm1hcCIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0Jztcbi8qKiBEZXRlY3RzIHdoZXRoZXIgdGhlIGdpdmVuIGBzY2hlbWFgIGNvbnRhaW5zIGZpeGVkIGl0ZW1zLiBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gYHNjaGVtYS5pdGVtc2AgaXMgYSBub24tZW1wdHkgYXJyYXlcbiAqIHRoYXQgb25seSBjb250YWlucyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGluIHdoaWNoIHRvIGNoZWNrIGZvciBmaXhlZCBpdGVtc1xuICogQHJldHVybnMgLSBUcnVlIGlmIHRoZXJlIGFyZSBmaXhlZCBpdGVtcyBpbiB0aGUgc2NoZW1hLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNGaXhlZEl0ZW1zKHNjaGVtYSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgJiYgc2NoZW1hLml0ZW1zLmxlbmd0aCA+IDAgJiYgc2NoZW1hLml0ZW1zLmV2ZXJ5KChpdGVtKSA9PiBpc09iamVjdChpdGVtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0ZpeGVkSXRlbXMuanMubWFwIiwiLyoqIERldGVybWluZXMgd2hldGhlciBhIGB0aGluZ2AgaXMgYW4gb2JqZWN0IGZvciB0aGUgcHVycG9zZXMgb2YgUlNKRi4gSW4gdGhpcyBjYXNlLCBgdGhpbmdgIGlzIGFuIG9iamVjdCBpZiBpdCBoYXNcbiAqIHRoZSB0eXBlIGBvYmplY3RgIGJ1dCBpcyBOT1QgbnVsbCwgYW4gYXJyYXkgb3IgYSBGaWxlLlxuICpcbiAqIEBwYXJhbSB0aGluZyAtIFRoZSB0aGluZyB0byBjaGVjayB0byBzZWUgd2hldGhlciBpdCBpcyBhbiBvYmplY3RcbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBpdCBpcyBhIG5vbi1udWxsLCBub24tYXJyYXksIG5vbi1GaWxlIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICAgIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpbmcgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBEYXRlICE9PSAndW5kZWZpbmVkJyAmJiB0aGluZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JyAmJiB0aGluZyAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0aGluZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc09iamVjdC5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWJlbFZhbHVlKGxhYmVsLCBoaWRlTGFiZWwsIGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGhpZGVMYWJlbCA/IGZhbGxiYWNrIDogbGFiZWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYWJlbFZhbHVlLmpzLm1hcCIsIi8qKiBDb252ZXJ0cyBhIGxvY2FsIERhdGUgc3RyaW5nIGludG8gYSBVVEMgZGF0ZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gZGF0ZVN0cmluZyAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkYXRlIGFzIGFjY2VwdGVkIGJ5IHRoZSBgRGF0ZSgpYCBjb25zdHJ1Y3RvclxuICogQHJldHVybnMgLSBBIFVUQyBkYXRlIHN0cmluZyBpZiBgZGF0ZVN0cmluZ2AgaXMgdHJ1dGh5LCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvY2FsVG9VVEMoZGF0ZVN0cmluZykge1xuICAgIHJldHVybiBkYXRlU3RyaW5nID8gbmV3IERhdGUoZGF0ZVN0cmluZykudG9KU09OKCkgOiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbFRvVVRDLmpzLm1hcCIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdCc7XG4vKiogTWVyZ2VzIHRoZSBgZGVmYXVsdHNgIG9iamVjdCBvZiB0eXBlIGBUYCBpbnRvIHRoZSBgZm9ybURhdGFgIG9mIHR5cGUgYFRgXG4gKlxuICogV2hlbiBtZXJnaW5nIGRlZmF1bHRzIGFuZCBmb3JtIGRhdGEsIHdlIHdhbnQgdG8gbWVyZ2UgaW4gdGhpcyBzcGVjaWZpYyB3YXk6XG4gKiAtIG9iamVjdHMgYXJlIGRlZXBseSBtZXJnZWRcbiAqIC0gYXJyYXlzIGFyZSBtZXJnZWQgaW4gc3VjaCBhIHdheSB0aGF0OlxuICogICAtIHdoZW4gdGhlIGFycmF5IGlzIHNldCBpbiBmb3JtIGRhdGEsIG9ubHkgYXJyYXkgZW50cmllcyBzZXQgaW4gZm9ybSBkYXRhXG4gKiAgICAgYXJlIGRlZXBseSBtZXJnZWQ7IGFkZGl0aW9uYWwgZW50cmllcyBmcm9tIHRoZSBkZWZhdWx0cyBhcmUgaWdub3JlZCB1bmxlc3MgYG1lcmdlRXh0cmFBcnJheURlZmF1bHRzYCBpcyB0cnVlLCBpblxuICogICAgIHdoaWNoIGNhc2UgdGhlIGV4dHJhcyBhcmUgYXBwZW5kZWQgb250byB0aGUgZW5kIG9mIHRoZSBmb3JtIGRhdGFcbiAqICAgLSB3aGVuIHRoZSBhcnJheSBpcyBub3Qgc2V0IGluIGZvcm0gZGF0YSwgdGhlIGRlZmF1bHQgaXMgY29waWVkIG92ZXJcbiAqIC0gc2NhbGFycyBhcmUgb3ZlcndyaXR0ZW4vc2V0IGJ5IGZvcm0gZGF0YVxuICpcbiAqIEBwYXJhbSBbZGVmYXVsdHNdIC0gVGhlIGRlZmF1bHRzIHRvIG1lcmdlXG4gKiBAcGFyYW0gW2Zvcm1EYXRhXSAtIFRoZSBmb3JtIGRhdGEgaW50byB3aGljaCB0aGUgZGVmYXVsdHMgd2lsbCBiZSBtZXJnZWRcbiAqIEBwYXJhbSBbbWVyZ2VFeHRyYUFycmF5RGVmYXVsdHM9ZmFsc2VdIC0gSWYgdHJ1ZSwgYW55IGFkZGl0aW9uYWwgZGVmYXVsdCBhcnJheSBlbnRyaWVzIGFyZSBhcHBlbmRlZCBvbnRvIHRoZSBmb3JtRGF0YVxuICogQHJldHVybnMgLSBUaGUgcmVzdWx0aW5nIG1lcmdlZCBmb3JtIGRhdGEgd2l0aCBkZWZhdWx0c1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhKGRlZmF1bHRzLCBmb3JtRGF0YSwgbWVyZ2VFeHRyYUFycmF5RGVmYXVsdHMgPSBmYWxzZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0c0FycmF5ID0gQXJyYXkuaXNBcnJheShkZWZhdWx0cykgPyBkZWZhdWx0cyA6IFtdO1xuICAgICAgICBjb25zdCBtYXBwZWQgPSBmb3JtRGF0YS5tYXAoKHZhbHVlLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0c0FycmF5W2lkeF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShkZWZhdWx0c0FycmF5W2lkeF0sIHZhbHVlLCBtZXJnZUV4dHJhQXJyYXlEZWZhdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNZXJnZSBhbnkgZXh0cmEgZGVmYXVsdHMgd2hlbiBtZXJnZUV4dHJhQXJyYXlEZWZhdWx0cyBpcyB0cnVlXG4gICAgICAgIGlmIChtZXJnZUV4dHJhQXJyYXlEZWZhdWx0cyAmJiBtYXBwZWQubGVuZ3RoIDwgZGVmYXVsdHNBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKC4uLmRlZmF1bHRzQXJyYXkuc2xpY2UobWFwcGVkLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChmb3JtRGF0YSkpIHtcbiAgICAgICAgY29uc3QgYWNjID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpOyAvLyBQcmV2ZW50IG11dGF0aW9uIG9mIHNvdXJjZSBvYmplY3QuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmb3JtRGF0YSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhKGRlZmF1bHRzID8gZ2V0KGRlZmF1bHRzLCBrZXkpIDoge30sIGdldChmb3JtRGF0YSwga2V5KSwgbWVyZ2VFeHRyYUFycmF5RGVmYXVsdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgYWNjKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1EYXRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YS5qcy5tYXAiLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdCc7XG4vKiogUmVjdXJzaXZlbHkgbWVyZ2UgZGVlcGx5IG5lc3RlZCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBvYmoxIC0gVGhlIGZpcnN0IG9iamVjdCB0byBtZXJnZVxuICogQHBhcmFtIG9iajIgLSBUaGUgc2Vjb25kIG9iamVjdCB0byBtZXJnZVxuICogQHBhcmFtIFtjb25jYXRBcnJheXM9ZmFsc2VdIC0gT3B0aW9uYWwgZmxhZyB0aGF0LCB3aGVuIHRydWUsIHdpbGwgY2F1c2UgYXJyYXlzIHRvIGJlIGNvbmNhdGVuYXRlZC4gVXNlXG4gKiAgICAgICAgICBcInByZXZlbnREdXBsaWNhdGVzXCIgdG8gbWVyZ2UgYXJyYXlzIGluIGEgbWFubmVyIHRoYXQgcHJldmVudHMgYW55IGR1cGxpY2F0ZSBlbnRyaWVzIGZyb20gYmVpbmcgbWVyZ2VkLlxuICogICAgICAgICAgTk9URTogVXNlcyBzaGFsbG93IGNvbXBhcmlzb24gZm9yIHRoZSBkdXBsaWNhdGUgY2hlY2tpbmcuXG4gKiBAcmV0dXJucyAtIEEgbmV3IG9iamVjdCB0aGF0IGlzIHRoZSBtZXJnZSBvZiB0aGUgdHdvIGdpdmVuIG9iamVjdHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIsIGNvbmNhdEFycmF5cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iajIpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbGVmdCA9IG9iajEgPyBvYmoxW2tleV0gOiB7fSwgcmlnaHQgPSBvYmoyW2tleV07XG4gICAgICAgIGlmIChvYmoxICYmIGtleSBpbiBvYmoxICYmIGlzT2JqZWN0KHJpZ2h0KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZU9iamVjdHMobGVmdCwgcmlnaHQsIGNvbmNhdEFycmF5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uY2F0QXJyYXlzICYmIEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgICAgICAgIGxldCB0b01lcmdlID0gcmlnaHQ7XG4gICAgICAgICAgICBpZiAoY29uY2F0QXJyYXlzID09PSAncHJldmVudER1cGxpY2F0ZXMnKSB7XG4gICAgICAgICAgICAgICAgdG9NZXJnZSA9IHJpZ2h0LnJlZHVjZSgocmVzdWx0LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZnQuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGxlZnQuY29uY2F0KHRvTWVyZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIE9iamVjdC5hc3NpZ24oe30sIG9iajEpKTsgLy8gUHJldmVudCBtdXRhdGlvbiBvZiBzb3VyY2Ugb2JqZWN0LlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VPYmplY3RzLmpzLm1hcCIsImltcG9ydCB1bmlvbiBmcm9tICdsb2Rhc2gvdW5pb24nO1xuaW1wb3J0IHsgUkVRVUlSRURfS0VZIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGdldFNjaGVtYVR5cGUgZnJvbSAnLi9nZXRTY2hlbWFUeXBlJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0Jztcbi8qKiBSZWN1cnNpdmVseSBtZXJnZSBkZWVwbHkgbmVzdGVkIHNjaGVtYXMuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYG1lcmdlU2NoZW1hc2AgYW5kIGBtZXJnZU9iamVjdHNgIGlzIHRoYXRcbiAqIGBtZXJnZVNjaGVtYXNgIG9ubHkgY29uY2F0cyBhcnJheXMgZm9yIHZhbHVlcyB1bmRlciB0aGUgJ3JlcXVpcmVkJyBrZXl3b3JkLCBhbmQgd2hlbiBpdCBkb2VzLCBpdCBkb2Vzbid0IGluY2x1ZGVcbiAqIGR1cGxpY2F0ZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIG9iajEgLSBUaGUgZmlyc3Qgc2NoZW1hIG9iamVjdCB0byBtZXJnZVxuICogQHBhcmFtIG9iajIgLSBUaGUgc2Vjb25kIHNjaGVtYSBvYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIC0gVGhlIG1lcmdlZCBzY2hlbWEgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlU2NoZW1hcyhvYmoxLCBvYmoyKSB7XG4gICAgY29uc3QgYWNjID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqMSk7IC8vIFByZXZlbnQgbXV0YXRpb24gb2Ygc291cmNlIG9iamVjdC5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqMikucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBsZWZ0ID0gb2JqMSA/IG9iajFba2V5XSA6IHt9LCByaWdodCA9IG9iajJba2V5XTtcbiAgICAgICAgaWYgKG9iajEgJiYga2V5IGluIG9iajEgJiYgaXNPYmplY3QocmlnaHQpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlU2NoZW1hcyhsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqMSAmJlxuICAgICAgICAgICAgb2JqMiAmJlxuICAgICAgICAgICAgKGdldFNjaGVtYVR5cGUob2JqMSkgPT09ICdvYmplY3QnIHx8IGdldFNjaGVtYVR5cGUob2JqMikgPT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAga2V5ID09PSBSRVFVSVJFRF9LRVkgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobGVmdCkgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBpbmNsdWRlIGR1cGxpY2F0ZSB2YWx1ZXMgd2hlbiBtZXJnaW5nICdyZXF1aXJlZCcgZmllbGRzLlxuICAgICAgICAgICAgYWNjW2tleV0gPSB1bmlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgYWNjKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlU2NoZW1hcy5qcy5tYXAiLCJpbXBvcnQgdG9Db25zdGFudCBmcm9tICcuL3RvQ29uc3RhbnQnO1xuLyoqIEdldHMgdGhlIGxpc3Qgb2Ygb3B0aW9ucyBmcm9tIHRoZSBzY2hlbWEuIElmIHRoZSBzY2hlbWEgaGFzIGFuIGVudW0gbGlzdCwgdGhlbiB0aG9zZSBlbnVtIHZhbHVlcyBhcmUgcmV0dXJuZWQuIFRoZVxuICogbGFiZWxzIGZvciB0aGUgb3B0aW9ucyB3aWxsIGJlIGV4dHJhY3RlZCBmcm9tIHRoZSBub24tc3RhbmRhcmQsIFJKU0YtZGVwcmVjYXRlZCBgZW51bU5hbWVzYCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZVxuICogdGhlIGxhYmVsIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGB2YWx1ZWAuIElmIHRoZSBzY2hlbWEgaGFzIGEgYG9uZU9mYCBvciBgYW55T2ZgLCB0aGVuIHRoZSB2YWx1ZSBpcyB0aGUgbGlzdCBvZlxuICogYGNvbnN0YCB2YWx1ZXMgZnJvbSB0aGUgc2NoZW1hIGFuZCB0aGUgbGFiZWwgaXMgZWl0aGVyIHRoZSBgc2NoZW1hLnRpdGxlYCBvciB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBvcHRpb25zIGxpc3RcbiAqIEByZXR1cm5zIC0gVGhlIGxpc3Qgb2Ygb3B0aW9ucyBmcm9tIHRoZSBzY2hlbWFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3B0aW9uc0xpc3Qoc2NoZW1hKSB7XG4gICAgLy8gZW51bU5hbWVzIHdhcyBkZXByZWNhdGVkIGluIHY1IGFuZCBpcyBpbnRlbnRpb25hbGx5IG9taXR0ZWQgZnJvbSB0aGUgUkpTRlNjaGVtYSB0eXBlLlxuICAgIC8vIENhc3QgdGhlIHR5cGUgdG8gaW5jbHVkZSBlbnVtTmFtZXMgc28gdGhlIGZlYXR1cmUgc3RpbGwgd29ya3MuXG4gICAgY29uc3Qgc2NoZW1hV2l0aEVudW1OYW1lcyA9IHNjaGVtYTtcbiAgICBpZiAoc2NoZW1hV2l0aEVudW1OYW1lcy5lbnVtTmFtZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBlbnVtTmFtZXMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4nKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5lbnVtKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZW51bS5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IChzY2hlbWFXaXRoRW51bU5hbWVzLmVudW1OYW1lcyAmJiBzY2hlbWFXaXRoRW51bU5hbWVzLmVudW1OYW1lc1tpXSkgfHwgU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7IGxhYmVsLCB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYWx0U2NoZW1hcyA9IHNjaGVtYS5vbmVPZiB8fCBzY2hlbWEuYW55T2Y7XG4gICAgcmV0dXJuIChhbHRTY2hlbWFzICYmXG4gICAgICAgIGFsdFNjaGVtYXMubWFwKChhU2NoZW1hRGVmKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhU2NoZW1hID0gYVNjaGVtYURlZjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdG9Db25zdGFudChhU2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gYVNjaGVtYS50aXRsZSB8fCBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IGFTY2hlbWEsXG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb25zTGlzdC5qcy5tYXAiLCIvKiogR2l2ZW4gYSBsaXN0IG9mIGBwcm9wZXJ0aWVzYCBhbmQgYW4gYG9yZGVyYCBsaXN0LCByZXR1cm5zIGEgbGlzdCB0aGF0IGNvbnRhaW5zIHRoZSBgcHJvcGVydGllc2Agb3JkZXJlZCBjb3JyZWN0bHkuXG4gKiBJZiBgb3JkZXJgIGlzIG5vdCBhbiBhcnJheSwgdGhlbiB0aGUgdW50b3VjaGVkIGBwcm9wZXJ0aWVzYCBsaXN0IGlzIHJldHVybmVkLiBPdGhlcndpc2UgYHByb3BlcnRpZXNgIGlzIG9yZGVyZWQgcGVyXG4gKiB0aGUgYG9yZGVyYCBsaXN0LiBJZiBgb3JkZXJgIGNvbnRhaW5zIGEgJyonIHRoZW4gYW55IGBwcm9wZXJ0aWVzYCB0aGF0IGFyZSBub3QgbWVudGlvbmVkIGV4cGxpY2l0eSBpbiBgb3JkZXJgIHdpbGwgYmVcbiAqIHBsYWNlcyBpbiB0aGUgbG9jYXRpb24gb2YgdGhlIGAqYC5cbiAqXG4gKiBAcGFyYW0gcHJvcGVydGllcyAtIFRoZSBsaXN0IG9mIHByb3BlcnR5IGtleXMgdG8gYmUgb3JkZXJlZFxuICogQHBhcmFtIG9yZGVyIC0gQW4gYXJyYXkgb2YgcHJvcGVydHkga2V5cyB0byBiZSBvcmRlcmVkIGZpcnN0LCB3aXRoIGFuIG9wdGlvbmFsICcqJyBwcm9wZXJ0eVxuICogQHJldHVybnMgLSBBIGxpc3Qgd2l0aCB0aGUgYHByb3BlcnRpZXNgIG9yZGVyZWRcbiAqIEB0aHJvd3MgLSBFcnJvciB3aGVuIHRoZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBvcmRlcmVkIGNvcnJlY3RseVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlclByb3BlcnRpZXMocHJvcGVydGllcywgb3JkZXIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBjb25zdCBhcnJheVRvSGFzaCA9IChhcnIpID0+IGFyci5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgcHJldltjdXJyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBlcnJvclByb3BMaXN0ID0gKGFycikgPT4gYXJyLmxlbmd0aCA+IDEgPyBgcHJvcGVydGllcyAnJHthcnIuam9pbihcIicsICdcIil9J2AgOiBgcHJvcGVydHkgJyR7YXJyWzBdfSdgO1xuICAgIGNvbnN0IHByb3BlcnR5SGFzaCA9IGFycmF5VG9IYXNoKHByb3BlcnRpZXMpO1xuICAgIGNvbnN0IG9yZGVyRmlsdGVyZWQgPSBvcmRlci5maWx0ZXIoKHByb3ApID0+IHByb3AgPT09ICcqJyB8fCBwcm9wZXJ0eUhhc2hbcHJvcF0pO1xuICAgIGNvbnN0IG9yZGVySGFzaCA9IGFycmF5VG9IYXNoKG9yZGVyRmlsdGVyZWQpO1xuICAgIGNvbnN0IHJlc3QgPSBwcm9wZXJ0aWVzLmZpbHRlcigocHJvcCkgPT4gIW9yZGVySGFzaFtwcm9wXSk7XG4gICAgY29uc3QgcmVzdEluZGV4ID0gb3JkZXJGaWx0ZXJlZC5pbmRleE9mKCcqJyk7XG4gICAgaWYgKHJlc3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVpU2NoZW1hIG9yZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiAke2Vycm9yUHJvcExpc3QocmVzdCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yZGVyRmlsdGVyZWQ7XG4gICAgfVxuICAgIGlmIChyZXN0SW5kZXggIT09IG9yZGVyRmlsdGVyZWQubGFzdEluZGV4T2YoJyonKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpU2NoZW1hIG9yZGVyIGxpc3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSB3aWxkY2FyZCBpdGVtJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gWy4uLm9yZGVyRmlsdGVyZWRdO1xuICAgIGNvbXBsZXRlLnNwbGljZShyZXN0SW5kZXgsIDEsIC4uLnJlc3QpO1xuICAgIHJldHVybiBjb21wbGV0ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVyUHJvcGVydGllcy5qcy5tYXAiLCIvKiogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYG51bWAgdGhhdCBpcyBwYWRkZWQgd2l0aCBsZWFkaW5nIFwiMFwicyBpZiBuZWNlc3NhcnlcbiAqXG4gKiBAcGFyYW0gbnVtIC0gVGhlIG51bWJlciB0byBwYWRcbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgc3RyaW5nIGF0IHdoaWNoIG5vIGxlYWQgcGFkZGluZyBpcyBuZWNlc3NhcnlcbiAqIEByZXR1cm5zIC0gVGhlIG51bWJlciBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgd2l0aCBsZWFkaW5nIHplcm8gcGFkZGluZyBpZiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBpcyBsZXNzIHRoYW4gYHdpZHRoYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYWQobnVtLCB3aWR0aCkge1xuICAgIGxldCBzID0gU3RyaW5nKG51bSk7XG4gICAgd2hpbGUgKHMubGVuZ3RoIDwgd2lkdGgpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkLmpzLm1hcCIsIi8qKiBQYXJzZXMgdGhlIGBkYXRlU3RyaW5nYCBpbnRvIGEgYERhdGVPYmplY3RgLCBpbmNsdWRpbmcgdGhlIHRpbWUgaW5mb3JtYXRpb24gd2hlbiBgaW5jbHVkZVRpbWVgIGlzIHRydWVcbiAqXG4gKiBAcGFyYW0gZGF0ZVN0cmluZyAtIFRoZSBkYXRlIHN0cmluZyB0byBwYXJzZSBpbnRvIGEgRGF0ZU9iamVjdFxuICogQHBhcmFtIFtpbmNsdWRlVGltZT10cnVlXSAtIE9wdGlvbmFsIGZsYWcsIGlmIGZhbHNlLCB3aWxsIG5vdCBpbmNsdWRlIHRoZSB0aW1lIGRhdGEgaW50byB0aGUgb2JqZWN0XG4gKiBAcmV0dXJucyAtIFRoZSBkYXRlIHN0cmluZyBjb252ZXJ0ZWQgdG8gYSBgRGF0ZU9iamVjdGBcbiAqIEB0aHJvd3MgLSBFcnJvciB3aGVuIHRoZSBkYXRlIGNhbm5vdCBiZSBwYXJzZWQgZnJvbSB0aGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlRGF0ZVN0cmluZyhkYXRlU3RyaW5nLCBpbmNsdWRlVGltZSA9IHRydWUpIHtcbiAgICBpZiAoIWRhdGVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IC0xLFxuICAgICAgICAgICAgbW9udGg6IC0xLFxuICAgICAgICAgICAgZGF5OiAtMSxcbiAgICAgICAgICAgIGhvdXI6IGluY2x1ZGVUaW1lID8gLTEgOiAwLFxuICAgICAgICAgICAgbWludXRlOiBpbmNsdWRlVGltZSA/IC0xIDogMCxcbiAgICAgICAgICAgIHNlY29uZDogaW5jbHVkZVRpbWUgPyAtMSA6IDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBkYXRlICcgKyBkYXRlU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtb250aDogZGF0ZS5nZXRVVENNb250aCgpICsgMSxcbiAgICAgICAgZGF5OiBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgaG91cjogaW5jbHVkZVRpbWUgPyBkYXRlLmdldFVUQ0hvdXJzKCkgOiAwLFxuICAgICAgICBtaW51dGU6IGluY2x1ZGVUaW1lID8gZGF0ZS5nZXRVVENNaW51dGVzKCkgOiAwLFxuICAgICAgICBzZWNvbmQ6IGluY2x1ZGVUaW1lID8gZGF0ZS5nZXRVVENTZWNvbmRzKCkgOiAwLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZURhdGVTdHJpbmcuanMubWFwIiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCB7IElEX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgaGFzaEZvclNjaGVtYSBmcm9tICcuLi9oYXNoRm9yU2NoZW1hJztcbi8qKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IGlzIGRlc2lnbmVkIGZvciB1c2UgaW4gY2FwdHVyaW5nIHNjaGVtYXMgdXNlZCBieSB0aGVcbiAqIGBpc1ZhbGlkKClgIGZ1bmN0aW9uLiBUaGUgcmVzdCBvZiB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGludGVyZmFjZSB0aHJvd3MgZXJyb3JzIHdoZW4gaXQgaXMgYXR0ZW1wdGVkIHRvIGJlIHVzZWQuXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgb2JqZWN0IGFsbG93cyB0aGUgY2FsbGVyIHRvIGNhcHR1cmUgdGhlIHNjaGVtYXMgdXNlZCBpbiBjYWxscyB0byB0aGUgYGlzVmFsaWQoKWAgZnVuY3Rpb24uIFRoZXNlXG4gKiBjYXB0dXJlZCBzY2hlbWEsIGFsb25nIHdpdGggdGhlIHJvb3Qgc2NoZW1hIHVzZWQgdG8gY29uc3RydWN0IHRoZSBvYmplY3QgYXJlIHN0b3JlZCBpbiB0aGUgbWFwIG9mIHNjaGVtYXMga2V5ZWQgYnlcbiAqIHRoZSBoYXNoZWQgdmFsdWUgb2YgdGhlIHNjaGVtYS4gTk9URTogQWZ0ZXIgaGFzaGluZyB0aGUgc2NoZW1hLCBhbiAkaWQgd2l0aCB0aGUgaGFzaCB2YWx1ZSBpcyBhZGRlZCB0byB0aGVcbiAqIHNjaGVtYSBJRiB0aGF0IHNjaGVtYSBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhbiAkaWQsIHByaW9yIHRvIHB1dHRpbmcgdGhlIHNjaGVtYSBpbnRvIHRoZSBtYXAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlclZhbGlkYXRvciB7XG4gICAgLyoqIENvbnN0cnVjdCB0aGUgUGFyc2VyVmFsaWRhdG9yIGZvciB0aGUgZ2l2ZW4gYHJvb3RTY2hlbWFgLiBUaGlzIGByb290U2NoZW1hYCB3aWxsIGJlIHN0YXNoZWQgaW4gdGhlIGBzY2hlbWFNYXBgXG4gICAgICogZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSBhZ2FpbnN0IHdoaWNoIHRoaXMgdmFsaWRhdG9yIHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290U2NoZW1hKSB7XG4gICAgICAgIC8qKiBUaGUgbWFwIG9mIHNjaGVtYXMgZW5jb3VudGVyZWQgYnkgdGhlIFBhcnNlclZhbGlkYXRvciAqL1xuICAgICAgICB0aGlzLnNjaGVtYU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJvb3RTY2hlbWEgPSByb290U2NoZW1hO1xuICAgICAgICB0aGlzLmFkZFNjaGVtYShyb290U2NoZW1hLCBoYXNoRm9yU2NoZW1hKHJvb3RTY2hlbWEpKTtcbiAgICB9XG4gICAgLyoqIEFkZHMgdGhlIGdpdmVuIGBzY2hlbWFgIHRvIHRoZSBgc2NoZW1hTWFwYCBrZXllZCBieSB0aGUgYGhhc2hgIG9yIGBJRF9LRVlgIGlmIHByZXNlbnQgb24gdGhlIGBzY2hlbWFgLiBJZiB0aGVcbiAgICAgKiBzY2hlbWEgZG9lcyBub3QgaGF2ZSBhbiBgSURfS0VZYCwgdGhlbiB0aGUgYGhhc2hgIHdpbGwgYmUgYWRkZWQgYXMgdGhlIGBJRF9LRVlgIHRvIGFsbG93IHRoZSBzY2hlbWEgdG8gYmVcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggaXQncyBgaGFzaGAgZm9yIGZ1dHVyZSB1c2UgKGJ5IGEgc2NoZW1hIGNvbXBpbGVyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHdoaWNoIGlzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXBcbiAgICAgKiBAcGFyYW0gaGFzaCAtIFRoZSBoYXNoIHZhbHVlIGF0IHdoaWNoIHRvIG1hcCB0aGUgc2NoZW1hXG4gICAgICovXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgaGFzaCkge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXQoc2NoZW1hLCBJRF9LRVksIGhhc2gpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVkU2NoZW1hID0geyAuLi5zY2hlbWEsIFtJRF9LRVldOiBrZXkgfTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLnNjaGVtYU1hcFtrZXldO1xuICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYU1hcFtrZXldID0gaWRlbnRpZmllZFNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNFcXVhbChleGlzdGluZywgaWRlbnRpZmllZFNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2V4aXN0aW5nIHNjaGVtYTonLCBKU09OLnN0cmluZ2lmeShleGlzdGluZywgbnVsbCwgMikpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignbmV3IHNjaGVtYTonLCBKU09OLnN0cmluZ2lmeShpZGVudGlmaWVkU2NoZW1hLCBudWxsLCAyKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR3byBkaWZmZXJlbnQgc2NoZW1hcyBleGlzdCB3aXRoIHRoZSBzYW1lIGtleSAke2tleX0hIFdoYXQgYSBiYWQgY29pbmNpZGVuY2UuIElmIHBvc3NpYmxlLCB0cnkgYWRkaW5nIGFuICRpZCB0byBvbmUgb2YgdGhlIHNjaGVtYXNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgY3VycmVudCBgc2NoZW1hTWFwYCB0byB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgZ2V0U2NoZW1hTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFNYXA7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnRzIHRoZSBgVmFsaWRhdG9yVHlwZWAgYGlzVmFsaWQoKWAgbWV0aG9kIHRvIGNhcHR1cmUgdGhlIGBzY2hlbWFgIGluIHRoZSBgc2NoZW1hTWFwYC4gVGhyb3dzIGFuIGVycm9yIHdoZW5cbiAgICAgKiB0aGUgYHJvb3RTY2hlbWFgIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgcm9vdCBzY2hlbWEgcHJvdmlkZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHJlY29yZCBpbiB0aGUgYHNjaGVtYU1hcGBcbiAgICAgKiBAcGFyYW0gX2Zvcm1EYXRhIC0gVGhlIGZvcm1EYXRhIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSBhc3NvY2lhdGVkIHdpdGggdGhlIHNjaGVtYVxuICAgICAqIEB0aHJvd3MgLSBFcnJvciB3aGVuIHRoZSBnaXZlbiBgcm9vdFNjaGVtYWAgZGlmZmVycyBmcm9tIHRoZSByb290IHNjaGVtYSBwcm92aWRlZCBkdXJpbmcgY29uc3RydWN0aW9uXG4gICAgICovXG4gICAgaXNWYWxpZChzY2hlbWEsIF9mb3JtRGF0YSwgcm9vdFNjaGVtYSkge1xuICAgICAgICBpZiAoIWlzRXF1YWwocm9vdFNjaGVtYSwgdGhpcy5yb290U2NoZW1hKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkbHkgY2FsbGluZyBpc1ZhbGlkKCkgd2l0aCBhIHJvb3RTY2hlbWEgdGhhdCBkaWZmZXJzIGZyb20gdGhlIGNvbnN0cnVjdGlvbiByb290U2NoZW1hJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBoYXNoRm9yU2NoZW1hKHNjaGVtYSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnRzIHRoZSBgVmFsaWRhdG9yVHlwZWAgYHJhd1ZhbGlkYXRpb24oKWAgbWV0aG9kIHRvIHRocm93IGFuIGVycm9yIHNpbmNlIGl0IGlzIG5ldmVyIHN1cHBvc2VkIHRvIGJlIGNhbGxlZFxuICAgICAqXG4gICAgICogQHBhcmFtIF9zY2hlbWEgLSBUaGUgc2NoZW1hIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKiBAcGFyYW0gX2Zvcm1EYXRhIC0gVGhlIGZvcm1EYXRhIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKi9cbiAgICByYXdWYWxpZGF0aW9uKF9zY2hlbWEsIF9mb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWRseSBjYWxsaW5nIHRoZSBgcmF3VmFsaWRhdGlvbigpYCBtZXRob2QgZHVyaW5nIHNjaGVtYSBwYXJzaW5nJyk7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnRzIHRoZSBgVmFsaWRhdG9yVHlwZWAgYHRvRXJyb3JMaXN0KClgIG1ldGhvZCB0byB0aHJvdyBhbiBlcnJvciBzaW5jZSBpdCBpcyBuZXZlciBzdXBwb3NlZCB0byBiZSBjYWxsZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBfZXJyb3JTY2hlbWEgLSBUaGUgZXJyb3Igc2NoZW1hIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKiBAcGFyYW0gX2ZpZWxkUGF0aCAtIFRoZSBmaWVsZCBwYXRoIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKi9cbiAgICB0b0Vycm9yTGlzdChfZXJyb3JTY2hlbWEsIF9maWVsZFBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkbHkgY2FsbGluZyB0aGUgYHRvRXJyb3JMaXN0KClgIG1ldGhvZCBkdXJpbmcgc2NoZW1hIHBhcnNpbmcnKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudHMgdGhlIGBWYWxpZGF0b3JUeXBlYCBgdmFsaWRhdGVGb3JtRGF0YSgpYCBtZXRob2QgdG8gdGhyb3cgYW4gZXJyb3Igc2luY2UgaXQgaXMgbmV2ZXIgc3VwcG9zZWQgdG8gYmVcbiAgICAgKiBjYWxsZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBfZm9ybURhdGEgLSBUaGUgZm9ybURhdGEgcGFyYW1ldGVyIHRoYXQgaXMgaWdub3JlZFxuICAgICAqIEBwYXJhbSBfc2NoZW1hIC0gVGhlIHNjaGVtYSBwYXJhbWV0ZXIgdGhhdCBpcyBpZ25vcmVkXG4gICAgICogQHBhcmFtIF9jdXN0b21WYWxpZGF0ZSAtIFRoZSBjdXN0b21WYWxpZGF0ZSBwYXJhbWV0ZXIgdGhhdCBpcyBpZ25vcmVkXG4gICAgICogQHBhcmFtIF90cmFuc2Zvcm1FcnJvcnMgLSBUaGUgdHJhbnNmb3JtRXJyb3JzIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKiBAcGFyYW0gX3VpU2NoZW1hIC0gVGhlIHVpU2NoZW1hIHBhcmFtZXRlciB0aGF0IGlzIGlnbm9yZWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUZvcm1EYXRhKF9mb3JtRGF0YSwgX3NjaGVtYSwgX2N1c3RvbVZhbGlkYXRlLCBfdHJhbnNmb3JtRXJyb3JzLCBfdWlTY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkbHkgY2FsbGluZyB0aGUgYHZhbGlkYXRlRm9ybURhdGEoKWAgbWV0aG9kIGR1cmluZyBzY2hlbWEgcGFyc2luZycpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnNlclZhbGlkYXRvci5qcy5tYXAiLCJpbXBvcnQgc2NoZW1hUGFyc2VyIGZyb20gJy4vc2NoZW1hUGFyc2VyJztcbmV4cG9ydCB7IHNjaGVtYVBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IGZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoL2lzRXF1YWwnO1xuaW1wb3J0IHsgUFJPUEVSVElFU19LRVksIElURU1TX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgUGFyc2VyVmFsaWRhdG9yIGZyb20gJy4vUGFyc2VyVmFsaWRhdG9yJztcbmltcG9ydCB7IHJldHJpZXZlU2NoZW1hSW50ZXJuYWwsIHJlc29sdmVBbnlPck9uZU9mU2NoZW1hcyB9IGZyb20gJy4uL3NjaGVtYS9yZXRyaWV2ZVNjaGVtYSc7XG4vKiogUmVjdXJzaXZlIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2UgdGhlIGdpdmVuIGBzY2hlbWFgIGJlbG9uZ2luZyB0byB0aGUgYHJvb3RTY2hlbWFgLiBUaGUgYHZhbGlkYXRvcmAgaXMgdXNlZCB0b1xuICogY2FwdHVyZSB0aGUgc3ViLXNjaGVtYXMgdGhhdCB0aGUgYGlzVmFsaWQoKWAgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGguIEZvciBlYWNoIHNjaGVtYSByZXR1cm5lZCBieSB0aGVcbiAqIGByZXRyaWV2ZVNjaGVtYUludGVybmFsKClgLCB0aGUgYHJlc29sdmVBbnlPck9uZU9mU2NoZW1hcygpYCBmdW5jdGlvbiBpcyBjYWxsZWQuIEZvciBlYWNoIG9mIHRoZSBzY2hlbWFzIHJldHVybmVkXG4gKiBmcm9tIFRIQVQgY2FsbCBoYXZlIGBwcm9wZXJ0aWVzYCwgdGhlbiBlYWNoIG9mIHRoZSBzdWItc2NoZW1hIHByb3BlcnR5IG9iamVjdHMgYXJlIHRoZW4gcmVjdXJzaXZlbHkgcGFyc2VkLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBUaGUgYFBhcnNlclZhbGlkYXRvcmAgaW1wbGVtZW50YXRpb24gdXNlZCB0byBjYXB0dXJlIGBpc1ZhbGlkKClgIGNhbGxzIGR1cmluZyBwYXJzaW5nXG4gKiBAcGFyYW0gcmVjdXJzZUxpc3QgLSBUaGUgbGlzdCBvZiBzY2hlbWFzIHJldHVybmVkIGZyb20gdGhlIGByZXRyaWV2ZVNjaGVtYUludGVybmFsYCwgcHJldmVudGluZyBpbmZpbml0ZSByZWN1cnNpb25cbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hIGZyb20gd2hpY2ggdGhlIHNjaGVtYSBwYXJzaW5nIGJlZ2FuXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIGN1cnJlbnQgc2NoZW1hIGVsZW1lbnQgYmVpbmcgcGFyc2VkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2NoZW1hKHZhbGlkYXRvciwgcmVjdXJzZUxpc3QsIHJvb3RTY2hlbWEsIHNjaGVtYSkge1xuICAgIGNvbnN0IHNjaGVtYXMgPSByZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHNjaGVtYXMuZm9yRWFjaCgoc2NoZW1hKSA9PiB7XG4gICAgICAgIGNvbnN0IHNhbWVTY2hlbWFJbmRleCA9IHJlY3Vyc2VMaXN0LmZpbmRJbmRleCgoaXRlbSkgPT4gaXNFcXVhbChpdGVtLCBzY2hlbWEpKTtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlY3Vyc2VMaXN0LnB1c2goc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbE9wdGlvbnMgPSByZXNvbHZlQW55T3JPbmVPZlNjaGVtYXModmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIHRydWUpO1xuICAgICAgICAgICAgYWxsT3B0aW9ucy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFBST1BFUlRJRVNfS0VZIGluIHMgJiYgc1tQUk9QRVJUSUVTX0tFWV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChzY2hlbWFbUFJPUEVSVElFU19LRVldLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU2NoZW1hKHZhbGlkYXRvciwgcmVjdXJzZUxpc3QsIHJvb3RTY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoSVRFTVNfS0VZIGluIHNjaGVtYSAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpICYmIHR5cGVvZiBzY2hlbWEuaXRlbXMgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHBhcnNlU2NoZW1hKHZhbGlkYXRvciwgcmVjdXJzZUxpc3QsIHJvb3RTY2hlbWEsIHNjaGVtYS5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKiBQYXJzZXMgdGhlIGdpdmVuIGByb290U2NoZW1hYCB0byBleHRyYWN0IG91dCBhbGwgdGhlIHN1Yi1zY2hlbWFzIHRoYXQgbWF5YmUgY29udGFpbmVkIHdpdGhpbiBpdC4gUmV0dXJucyBhIG1hcCBvZlxuICogdGhlIGhhc2ggb2YgdGhlIHNjaGVtYSB0byBzY2hlbWEvc3ViLXNjaGVtYS5cbiAqXG4gKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSB0byBwYXJzZSBmb3Igc3ViLXNjaGVtYXMgdXNlZCBieSBgaXNWYWxpZCgpYCBjYWxsc1xuICogQHJldHVybnMgLSBUaGUgYFNjaGVtYU1hcGAgb2YgYWxsIHNjaGVtYXMgdGhhdCB3ZXJlIHBhcnNlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzY2hlbWFQYXJzZXIocm9vdFNjaGVtYSkge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBQYXJzZXJWYWxpZGF0b3Iocm9vdFNjaGVtYSk7XG4gICAgY29uc3QgcmVjdXJzZUxpc3QgPSBbXTtcbiAgICBwYXJzZVNjaGVtYSh2YWxpZGF0b3IsIHJlY3Vyc2VMaXN0LCByb290U2NoZW1hLCByb290U2NoZW1hKTtcbiAgICByZXR1cm4gdmFsaWRhdG9yLmdldFNjaGVtYU1hcCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZW1hUGFyc2VyLmpzLm1hcCIsIi8qKiBFeHRyYWN0cyB0aGUgcmFuZ2Ugc3BlYyBpbmZvcm1hdGlvbiBgeyBzdGVwPzogbnVtYmVyLCBtaW4/OiBudW1iZXIsIG1heD86IG51bWJlciB9YCB0aGF0IGNhbiBiZSBzcHJlYWQgb250byBhbiBIVE1MXG4gKiBpbnB1dCBmcm9tIHRoZSByYW5nZSBhbmFsb2cgaW4gdGhlIHNjaGVtYSBgeyBtdWx0aXBsZU9mPzogbnVtYmVyLCBtaW5pbXVtPzogbnVtYmVyLCBtYXhpbXVtPzogbnVtYmVyIH1gLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgcmFuZ2Ugc3BlY1xuICogQHJldHVybnMgLSBBIHJhbmdlIHNwZWNpZmljYXRpb24gZnJvbSB0aGUgc2NoZW1hXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhbmdlU3BlYyhzY2hlbWEpIHtcbiAgICBjb25zdCBzcGVjID0ge307XG4gICAgaWYgKHNjaGVtYS5tdWx0aXBsZU9mKSB7XG4gICAgICAgIHNwZWMuc3RlcCA9IHNjaGVtYS5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLm1pbmltdW0gfHwgc2NoZW1hLm1pbmltdW0gPT09IDApIHtcbiAgICAgICAgc3BlYy5taW4gPSBzY2hlbWEubWluaW11bTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5tYXhpbXVtIHx8IHNjaGVtYS5tYXhpbXVtID09PSAwKSB7XG4gICAgICAgIHNwZWMubWF4ID0gc2NoZW1hLm1heGltdW07XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2VTcGVjLmpzLm1hcCIsIi8qKiBQb3RlbnRpYWxseSBzdWJzdGl0dXRlcyBhbGwgcmVwbGFjZWFibGUgcGFyYW1ldGVycyB3aXRoIHRoZSBhc3NvY2lhdGVkIHZhbHVlKHMpIGZyb20gdGhlIGBwYXJhbXNgIGlmIGF2YWlsYWJsZS4gV2hlblxuICogYSBgcGFyYW1zYCBhcnJheSBpcyBwcm92aWRlZCwgZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgaXMgdXNlZCB0byByZXBsYWNlIGFueSBvZiB0aGUgcmVwbGFjZWFibGUgcGFyYW1ldGVycyBpbiB0aGVcbiAqIGBpbnB1dFN0cmluZ2AgdXNpbmcgdGhlIGAlMWAsIGAlMmAsIGV0Yy4gcmVwbGFjZW1lbnQgc3BlY2lmaWVycy5cbiAqXG4gKiBAcGFyYW0gaW5wdXRTdHJpbmcgLSBUaGUgc3RyaW5nIHdoaWNoIHdpbGwgYmUgcG90ZW50aWFsbHkgdXBkYXRlZCB3aXRoIHJlcGxhY2VtZW50IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgb3B0aW9uYWwgbGlzdCBvZiByZXBsYWNlYWJsZSBwYXJhbWV0ZXIgdmFsdWVzIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZW5nbGlzaCBzdHJpbmdcbiAqIEByZXR1cm5zIC0gVGhlIHVwZGF0ZWQgc3RyaW5nIHdpdGggYW55IHJlcGxhY2VtZW50IHNwZWNpZmllcnMgcmVwbGFjZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVwbGFjZVN0cmluZ1BhcmFtZXRlcnMoaW5wdXRTdHJpbmcsIHBhcmFtcykge1xuICAgIGxldCBvdXRwdXQgPSBpbnB1dFN0cmluZztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gb3V0cHV0LnNwbGl0KC8oJVxcZCkvKTtcbiAgICAgICAgcGFyYW1zLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydEluZGV4ID0gcGFydHMuZmluZEluZGV4KChwYXJ0KSA9PiBwYXJ0ID09PSBgJSR7aW5kZXggKyAxfWApO1xuICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbcGFydEluZGV4XSA9IHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0ID0gcGFydHMuam9pbignJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBsYWNlU3RyaW5nUGFyYW1ldGVycy5qcy5tYXAiLCIvKiogQ2hlY2sgdG8gc2VlIGlmIGEgYHNjaGVtYWAgc3BlY2lmaWVzIHRoYXQgYSB2YWx1ZSBtdXN0IGJlIHRydWUuIFRoaXMgaGFwcGVucyB3aGVuOlxuICogLSBgc2NoZW1hLmNvbnN0YCBpcyB0cnV0aHlcbiAqIC0gYHNjaGVtYS5lbnVtYCA9PSBgW3RydWVdYFxuICogLSBgc2NoZW1hLmFueU9mYCBvciBgc2NoZW1hLm9uZU9mYCBoYXMgYSBzaW5nbGUgdmFsdWUgd2hpY2ggcmVjdXJzaXZlbHkgcmV0dXJucyB0cnVlXG4gKiAtIGBzY2hlbWEuYWxsT2ZgIGhhcyBhdCBsZWFzdCBvbmUgdmFsdWUgd2hpY2ggcmVjdXJzaXZlbHkgcmV0dXJucyB0cnVlXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gY2hlY2tcbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgc2NoZW1hIHNwZWNpZmllcyBhIHZhbHVlIHRoYXQgbXVzdCBiZSB0cnVlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUoc2NoZW1hKSB7XG4gICAgLy8gQ2hlY2sgaWYgY29uc3QgaXMgYSB0cnV0aHkgdmFsdWVcbiAgICBpZiAoc2NoZW1hLmNvbnN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbiBlbnVtIGhhcyBhIHNpbmdsZSB2YWx1ZSBvZiB0cnVlXG4gICAgaWYgKHNjaGVtYS5lbnVtICYmIHNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSAmJiBzY2hlbWEuZW51bVswXSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSWYgYW55T2YgaGFzIGEgc2luZ2xlIHZhbHVlLCBldmFsdWF0ZSB0aGUgc3Vic2NoZW1hXG4gICAgaWYgKHNjaGVtYS5hbnlPZiAmJiBzY2hlbWEuYW55T2YubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZShzY2hlbWEuYW55T2ZbMF0pO1xuICAgIH1cbiAgICAvLyBJZiBvbmVPZiBoYXMgYSBzaW5nbGUgdmFsdWUsIGV2YWx1YXRlIHRoZSBzdWJzY2hlbWFcbiAgICBpZiAoc2NoZW1hLm9uZU9mICYmIHNjaGVtYS5vbmVPZi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKHNjaGVtYS5vbmVPZlswXSk7XG4gICAgfVxuICAgIC8vIEV2YWx1YXRlIGVhY2ggc3Vic2NoZW1hIGluIGFsbE9mLCB0byBzZWUgaWYgb25lIG9mIHRoZW0gcmVxdWlyZXMgYSB0cnVlIHZhbHVlXG4gICAgaWYgKHNjaGVtYS5hbGxPZikge1xuICAgICAgICBjb25zdCBzY2hlbWFTb21lID0gKHN1YlNjaGVtYSkgPT4gc2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUoc3ViU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5zb21lKHNjaGVtYVNvbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlbWFSZXF1aXJlc1RydWVWYWx1ZS5qcy5tYXAiLCJpbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IGhhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCBpc051bWJlciBmcm9tICdsb2Rhc2gvaXNOdW1iZXInO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJ2xvZGFzaC9pc09iamVjdCc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnbG9kYXNoL2lzU3RyaW5nJztcbmltcG9ydCByZWR1Y2UgZnJvbSAnbG9kYXNoL3JlZHVjZSc7XG5pbXBvcnQgdGltZXMgZnJvbSAnbG9kYXNoL3RpbWVzJztcbmltcG9ydCBnZXRGaXJzdE1hdGNoaW5nT3B0aW9uIGZyb20gJy4vZ2V0Rmlyc3RNYXRjaGluZ09wdGlvbic7XG5pbXBvcnQgcmV0cmlldmVTY2hlbWEsIHsgcmVzb2x2ZUFsbFJlZmVyZW5jZXMgfSBmcm9tICcuL3JldHJpZXZlU2NoZW1hJztcbmltcG9ydCB7IE9ORV9PRl9LRVksIFJFRl9LRVksIEpVTktfT1BUSU9OX0lELCBBTllfT0ZfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBndWVzc1R5cGUgZnJvbSAnLi4vZ3Vlc3NUeXBlJztcbmltcG9ydCBnZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hIGZyb20gJy4uL2dldERpc2NyaW1pbmF0b3JGaWVsZEZyb21TY2hlbWEnO1xuaW1wb3J0IGdldE9wdGlvbk1hdGNoaW5nU2ltcGxlRGlzY3JpbWluYXRvciBmcm9tICcuLi9nZXRPcHRpb25NYXRjaGluZ1NpbXBsZURpc2NyaW1pbmF0b3InO1xuLyoqIEEganVuayBvcHRpb24gdXNlZCB0byBkZXRlcm1pbmUgd2hlbiB0aGUgZ2V0Rmlyc3RNYXRjaGluZ09wdGlvbiBjYWxsIHJlYWxseSBtYXRjaGVzIGFuIG9wdGlvbiByYXRoZXIgdGhhbiByZXR1cm5pbmdcbiAqIHRoZSBmaXJzdCBpdGVtXG4gKi9cbmV4cG9ydCBjb25zdCBKVU5LX09QVElPTiA9IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAkaWQ6IEpVTktfT1BUSU9OX0lELFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgX19ub3RfcmVhbGx5X3RoZXJlX186IHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuLyoqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgdGhlIHNjb3JlIG9mIGEgYGZvcm1EYXRhYCBhZ2FpbnN0IHRoZSBnaXZlbiBgc2NoZW1hYC4gVGhlIGNvbXB1dGF0aW9uIGlzIGZhaXJseVxuICogc2ltcGxlLiBJbml0aWFsbHkgdGhlIHRvdGFsIHNjb3JlIGlzIDAuIFdoZW4gYHNjaGVtYS5wcm9wZXJ0aWVzYCBvYmplY3QgZXhpc3RzLCB0aGVuIGFsbCB0aGUgYGtleS92YWx1ZWAgcGFpcnMgd2l0aGluXG4gKiB0aGUgb2JqZWN0IGFyZSBwcm9jZXNzZWQgYXMgZm9sbG93cyBhZnRlciBvYnRhaW5pbmcgdGhlIGZvcm1WYWx1ZSBmcm9tIGBmb3JtRGF0YWAgdXNpbmcgdGhlIGBrZXlgOlxuICogLSBJZiB0aGUgYHZhbHVlYCBjb250YWlucyBhIGAkcmVmYCwgYGNhbGN1bGF0ZUluZGV4U2NvcmUoKWAgaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IHdpdGggdGhlIGZvcm1WYWx1ZSBhbmQgdGhlIG5ld1xuICogICBzY2hlbWEgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIHRoZSByZWYgaW4gdGhlIHNjaGVtYSBiZWluZyByZXNvbHZlZCBhbmQgdGhhdCBzdWItc2NoZW1hJ3MgcmVzdWx0aW5nIHNjb3JlIGlzIGFkZGVkIHRvXG4gKiAgIHRoZSB0b3RhbC5cbiAqIC0gSWYgdGhlIGB2YWx1ZWAgY29udGFpbnMgYSBgb25lT2ZgIGFuZCB0aGVyZSBpcyBhIGZvcm1WYWx1ZSwgdGhlbiBzY29yZSBiYXNlZCBvbiB0aGUgaW5kZXggcmV0dXJuZWQgZnJvbSBjYWxsaW5nXG4gKiAgIGBnZXRDbG9zZXN0TWF0Y2hpbmdPcHRpb24oKWAgb2YgdGhhdCBvbmVPZi5cbiAqIC0gSWYgdGhlIHR5cGUgb2YgdGhlIGB2YWx1ZWAgaXMgJ29iamVjdCcsIGBjYWxjdWxhdGVJbmRleFNjb3JlKClgIGlzIGNhbGxlZCByZWN1cnNpdmVseSB3aXRoIHRoZSBmb3JtVmFsdWUgYW5kIHRoZVxuICogICBgdmFsdWVgIGl0c2VsZiBhcyB0aGUgc3ViLXNjaGVtYSwgYW5kIHRoZSBzY29yZSBpcyBhZGRlZCB0byB0aGUgdG90YWwuXG4gKiAtIElmIHRoZSB0eXBlIG9mIHRoZSBgdmFsdWVgIG1hdGNoZXMgdGhlIGd1ZXNzZWQtdHlwZSBvZiB0aGUgYGZvcm1WYWx1ZWAsIHRoZSBzY29yZSBpcyBpbmNyZW1lbnRlZCBieSAxLCBVTkxFU1MgdGhlXG4gKiAgIHZhbHVlIGhhcyBhIGBkZWZhdWx0YCBvciBgY29uc3RgLiBJbiB0aG9zZSBjYXNlLCBpZiB0aGUgYGRlZmF1bHRgIG9yIGBjb25zdGAgYW5kIHRoZSBgZm9ybVZhbHVlYCBtYXRjaCwgdGhlIHNjb3JlXG4gKiAgIGlzIGluY3JlbWVudGVkIGJ5IGFub3RoZXIgMSBvdGhlcndpc2UgaXQgaXMgZGVjcmVtZW50ZWQgYnkgMS5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBuZWNlc3NhcnlcbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3QgSlNPTiBzY2hlbWEgb2YgdGhlIGVudGlyZSBmb3JtXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIHNjb3JlIGlzIGJlaW5nIGNhbGN1bGF0ZWRcbiAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBmb3JtIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBzY2hlbWEsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBzY29yZVxuICogQHJldHVybnMgLSBUaGUgc2NvcmUgYSBzY2hlbWEgYWdhaW5zdCB0aGUgZm9ybURhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUluZGV4U2NvcmUodmFsaWRhdG9yLCByb290U2NoZW1hLCBzY2hlbWEsIGZvcm1EYXRhID0ge30pIHtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICB0b3RhbFNjb3JlICs9IHJlZHVjZShzY2hlbWEucHJvcGVydGllcywgKHNjb3JlLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybVZhbHVlID0gZ2V0KGZvcm1EYXRhLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXModmFsdWUsIFJFRl9LRVkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHZhbGlkYXRvciwgdmFsdWUsIHJvb3RTY2hlbWEsIGZvcm1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29yZSArIGNhbGN1bGF0ZUluZGV4U2NvcmUodmFsaWRhdG9yLCByb290U2NoZW1hLCBuZXdTY2hlbWEsIGZvcm1WYWx1ZSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoaGFzKHZhbHVlLCBPTkVfT0ZfS0VZKSB8fCBoYXModmFsdWUsIEFOWV9PRl9LRVkpKSAmJiBmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaGFzKHZhbHVlLCBPTkVfT0ZfS0VZKSA/IE9ORV9PRl9LRVkgOiBBTllfT0ZfS0VZO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc2NvcmUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2xvc2VzdE1hdGNoaW5nT3B0aW9uKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgZm9ybVZhbHVlLCBnZXQodmFsdWUsIGtleSksIC0xLCBkaXNjcmltaW5hdG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcmUgKyBjYWxjdWxhdGVJbmRleFNjb3JlKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgdmFsdWUsIGZvcm1WYWx1ZSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBndWVzc1R5cGUoZm9ybVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZXMgbWF0Y2gsIHRoZW4gd2UgYnVtcCB0aGUgc2NvcmUgYnkgb25lXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdTY29yZSA9IHNjb3JlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY2hlbWEgY29udGFpbnMgYSByZWFkb25seSBkZWZhdWx0IHZhbHVlIHNjb3JlIHRoZSB2YWx1ZSB0aGF0IG1hdGNoZXMgdGhlIGRlZmF1bHQgaGlnaGVyIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IG5vbi1tYXRjaGluZyB2YWx1ZSBsb3dlclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcmUgKz0gZm9ybVZhbHVlID09PSB2YWx1ZS5kZWZhdWx0ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NoZW1hIGNvbnRhaW5zIGEgY29uc3QgdmFsdWUgc2NvcmUgdGhlIHZhbHVlIHRoYXQgbWF0Y2hlcyB0aGUgZGVmYXVsdCBoaWdoZXIgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgbm9uLW1hdGNoaW5nIHZhbHVlIGxvd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29yZSArPSBmb3JtVmFsdWUgPT09IHZhbHVlLmNvbnN0ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZXZlbnR1YWxseSwgZGVhbCB3aXRoIGVudW1zL2FycmF5c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzY29yZTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHNjaGVtYS50eXBlKSAmJiBzY2hlbWEudHlwZSA9PT0gZ3Vlc3NUeXBlKGZvcm1EYXRhKSkge1xuICAgICAgICAgICAgdG90YWxTY29yZSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbFNjb3JlO1xufVxuLyoqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIGdpdmVuIGBvcHRpb25zYCBwcm92aWRlZCBtb3N0IGNsb3NlbHkgbWF0Y2hlcyB0aGUgYGZvcm1EYXRhYC4gVXNpbmdcbiAqIGBnZXRGaXJzdE1hdGNoaW5nT3B0aW9uKClgIHRvIG1hdGNoIHR3byBzY2hlbWFzIHRoYXQgZGlmZmVyIG9ubHkgYnkgdGhlIHJlYWRPbmx5LCBkZWZhdWx0IG9yIGNvbnN0IHZhbHVlIG9mIGEgZmllbGRcbiAqIGJhc2VkIG9uIHRoZSBgZm9ybURhdGFgIGFuZCByZXR1cm5zIDAgd2hlbiB0aGVyZSBpcyBubyBtYXRjaC4gUmF0aGVyIHRoYW4gcGFzc2luZyBpbiBhbGwgdGhlIGBvcHRpb25zYCBhdCBvbmNlIHRvXG4gKiB0aGlzIHV0aWxpdHksIGluc3RlYWQgYW4gYXJyYXkgb2YgdmFsaWQgb3B0aW9uIGluZGV4ZXMgaXMgY3JlYXRlZCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgbGlzdCBvZiBvcHRpb25zLCBjYWxsXG4gKiBgZ2V0Rmlyc3RNYXRjaGluZ09wdGlvbnNgIHdpdGggYSBsaXN0IG9mIG9uZSBqdW5rIG9wdGlvbiBhbmQgb25lIGdvb2Qgb3B0aW9uLCBzZWVpbmcgaWYgdGhlIGdvb2Qgb3B0aW9uIGlzIGNvbnNpZGVyZWRcbiAqIG1hdGNoZWQuXG4gKlxuICogT25jZSB0aGUgbGlzdCBvZiB2YWxpZCBpbmRleGVzIGlzIGNyZWF0ZWQsIGlmIHRoZXJlIGlzIG9ubHkgb25lIHZhbGlkIGluZGV4LCBqdXN0IHJldHVybiBpdC4gT3RoZXJ3aXNlLCBpZiB0aGVyZSBhcmVcbiAqIG5vIHZhbGlkIGluZGV4ZXMsIHRoZW4gZmlsbCB0aGUgdmFsaWQgaW5kZXhlcyBhcnJheSB3aXRoIHRoZSBpbmRleGVzIG9mIGFsbCB0aGUgb3B0aW9ucy4gTmV4dCwgdGhlIGluZGV4IG9mIHRoZVxuICogb3B0aW9uIHdpdGggdGhlIGhpZ2hlc3Qgc2NvcmUgaXMgZGV0ZXJtaW5lZCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgbGlzdCBvZiB2YWxpZCBvcHRpb25zLCBjYWxsaW5nXG4gKiBgY2FsY3VsYXRlSW5kZXhTY29yZSgpYCBvbiBlYWNoLCBjb21wYXJpbmcgaXQgYWdhaW5zdCB0aGUgY3VycmVudCBiZXN0IHNjb3JlLCBhbmQgcmV0dXJuaW5nIHRoZSBpbmRleCBvZiB0aGUgb25lIHRoYXRcbiAqIGV2ZW50dWFsbHkgaGFzIHRoZSBiZXN0IHNjb3JlLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIG5lY2Vzc2FyeVxuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBKU09OIHNjaGVtYSBvZiB0aGUgZW50aXJlIGZvcm1cbiAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBmb3JtIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGxpc3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSBzZWxlY3RlZCBmcm9tXG4gKiBAcGFyYW0gW3NlbGVjdGVkT3B0aW9uPS0xXSAtIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbiwgZGVmYXVsdGVkIHRvIC0xIGlmIG5vdCBzcGVjaWZpZWRcbiAqIEBwYXJhbSBbZGlzY3JpbWluYXRvckZpZWxkXSAtIFRoZSBvcHRpb25hbCBuYW1lIG9mIHRoZSBmaWVsZCB3aXRoaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHVzZWQgdG9cbiAqICAgICAgICAgIGRldGVybWluZSB3aGljaCBvcHRpb24gaXMgc2VsZWN0ZWRcbiAqIEByZXR1cm5zIC0gVGhlIGluZGV4IG9mIHRoZSBvcHRpb24gdGhhdCBpcyB0aGUgY2xvc2VzdCBtYXRjaCB0byB0aGUgYGZvcm1EYXRhYCBvciB0aGUgYHNlbGVjdGVkT3B0aW9uYCBpZiBubyBtYXRjaFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbG9zZXN0TWF0Y2hpbmdPcHRpb24odmFsaWRhdG9yLCByb290U2NoZW1hLCBmb3JtRGF0YSwgb3B0aW9ucywgc2VsZWN0ZWRPcHRpb24gPSAtMSwgZGlzY3JpbWluYXRvckZpZWxkKSB7XG4gICAgLy8gRmlyc3QgcmVzb2x2ZSBhbnkgcmVmcyBpbiB0aGUgb3B0aW9uc1xuICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnMubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBbGxSZWZlcmVuY2VzKG9wdGlvbiwgcm9vdFNjaGVtYSwgW10pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNpbXBsZURpc2NyaW1pbmF0b3JNYXRjaCA9IGdldE9wdGlvbk1hdGNoaW5nU2ltcGxlRGlzY3JpbWluYXRvcihmb3JtRGF0YSwgb3B0aW9ucywgZGlzY3JpbWluYXRvckZpZWxkKTtcbiAgICBpZiAoaXNOdW1iZXIoc2ltcGxlRGlzY3JpbWluYXRvck1hdGNoKSkge1xuICAgICAgICByZXR1cm4gc2ltcGxlRGlzY3JpbWluYXRvck1hdGNoO1xuICAgIH1cbiAgICAvLyBSZWR1Y2UgdGhlIGFycmF5IG9mIG9wdGlvbnMgZG93biB0byBhIGxpc3Qgb2YgdGhlIGluZGV4ZXMgdGhhdCBhcmUgY29uc2lkZXJlZCBtYXRjaGluZyBvcHRpb25zXG4gICAgY29uc3QgYWxsVmFsaWRJbmRleGVzID0gcmVzb2x2ZWRPcHRpb25zLnJlZHVjZSgodmFsaWRMaXN0LCBvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RPcHRpb25zID0gW0pVTktfT1BUSU9OLCBvcHRpb25dO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGdldEZpcnN0TWF0Y2hpbmdPcHRpb24odmFsaWRhdG9yLCBmb3JtRGF0YSwgdGVzdE9wdGlvbnMsIHJvb3RTY2hlbWEsIGRpc2NyaW1pbmF0b3JGaWVsZCk7XG4gICAgICAgIC8vIFRoZSBtYXRjaCBpcyB0aGUgcmVhbCBvcHRpb24sIHNvIGFkZCBpdHMgaW5kZXggdG8gbGlzdCBvZiB2YWxpZCBpbmRleGVzXG4gICAgICAgIGlmIChtYXRjaCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsaWRMaXN0LnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZExpc3Q7XG4gICAgfSwgW10pO1xuICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIHZhbGlkIGluZGV4LCBzbyByZXR1cm4gaXQhXG4gICAgaWYgKGFsbFZhbGlkSW5kZXhlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFsbFZhbGlkSW5kZXhlc1swXTtcbiAgICB9XG4gICAgaWYgKCFhbGxWYWxpZEluZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vIGluZGV4ZXMgd2VyZSB2YWxpZCwgc28gd2UnbGwgc2NvcmUgYWxsIHRoZSBvcHRpb25zLCBhZGQgYWxsIHRoZSBpbmRleGVzXG4gICAgICAgIHRpbWVzKHJlc29sdmVkT3B0aW9ucy5sZW5ndGgsIChpKSA9PiBhbGxWYWxpZEluZGV4ZXMucHVzaChpKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjb3JlQ291bnQgPSBuZXcgU2V0KCk7XG4gICAgLy8gU2NvcmUgYWxsIHRoZSBvcHRpb25zIGluIHRoZSBsaXN0IG9mIHZhbGlkIGluZGV4ZXMgYW5kIHJldHVybiB0aGUgaW5kZXggd2l0aCB0aGUgYmVzdCBzY29yZVxuICAgIGNvbnN0IHsgYmVzdEluZGV4IH0gPSBhbGxWYWxpZEluZGV4ZXMucmVkdWNlKChzY29yZURhdGEsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYmVzdFNjb3JlIH0gPSBzY29yZURhdGE7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHJlc29sdmVkT3B0aW9uc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHNjb3JlID0gY2FsY3VsYXRlSW5kZXhTY29yZSh2YWxpZGF0b3IsIHJvb3RTY2hlbWEsIG9wdGlvbiwgZm9ybURhdGEpO1xuICAgICAgICBzY29yZUNvdW50LmFkZChzY29yZSk7XG4gICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgYmVzdEluZGV4OiBpbmRleCwgYmVzdFNjb3JlOiBzY29yZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29yZURhdGE7XG4gICAgfSwgeyBiZXN0SW5kZXg6IHNlbGVjdGVkT3B0aW9uLCBiZXN0U2NvcmU6IDAgfSk7XG4gICAgLy8gaWYgYWxsIHNjb3JlcyBhcmUgdGhlIHNhbWUgZ28gd2l0aCBzZWxlY3RlZE9wdGlvblxuICAgIGlmIChzY29yZUNvdW50LnNpemUgPT09IDEgJiYgc2VsZWN0ZWRPcHRpb24gPj0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb247XG4gICAgfVxuICAgIHJldHVybiBiZXN0SW5kZXg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDbG9zZXN0TWF0Y2hpbmdPcHRpb24uanMubWFwIiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBpc0VtcHR5IGZyb20gJ2xvZGFzaC9pc0VtcHR5JztcbmltcG9ydCB7IEFOWV9PRl9LRVksIERFRkFVTFRfS0VZLCBERVBFTkRFTkNJRVNfS0VZLCBQUk9QRVJUSUVTX0tFWSwgT05FX09GX0tFWSwgUkVGX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgZmluZFNjaGVtYURlZmluaXRpb24gZnJvbSAnLi4vZmluZFNjaGVtYURlZmluaXRpb24nO1xuaW1wb3J0IGdldENsb3Nlc3RNYXRjaGluZ09wdGlvbiBmcm9tICcuL2dldENsb3Nlc3RNYXRjaGluZ09wdGlvbic7XG5pbXBvcnQgZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYSBmcm9tICcuLi9nZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hJztcbmltcG9ydCBnZXRTY2hlbWFUeXBlIGZyb20gJy4uL2dldFNjaGVtYVR5cGUnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4uL2lzT2JqZWN0JztcbmltcG9ydCBpc0ZpeGVkSXRlbXMgZnJvbSAnLi4vaXNGaXhlZEl0ZW1zJztcbmltcG9ydCBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhIGZyb20gJy4uL21lcmdlRGVmYXVsdHNXaXRoRm9ybURhdGEnO1xuaW1wb3J0IG1lcmdlT2JqZWN0cyBmcm9tICcuLi9tZXJnZU9iamVjdHMnO1xuaW1wb3J0IG1lcmdlU2NoZW1hcyBmcm9tICcuLi9tZXJnZVNjaGVtYXMnO1xuaW1wb3J0IGlzTXVsdGlTZWxlY3QgZnJvbSAnLi9pc011bHRpU2VsZWN0JztcbmltcG9ydCByZXRyaWV2ZVNjaGVtYSwgeyByZXNvbHZlRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi9yZXRyaWV2ZVNjaGVtYSc7XG4vKiogRW51bSB0aGF0IGluZGljYXRlcyBob3cgYHNjaGVtYS5hZGRpdGlvbmFsSXRlbXNgIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBgZ2V0SW5uZXJTY2hlbWFGb3JBcnJheUl0ZW0oKWAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCB2YXIgQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmc7XG4oZnVuY3Rpb24gKEFkZGl0aW9uYWxJdGVtc0hhbmRsaW5nKSB7XG4gICAgQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmdbQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmdbXCJJZ25vcmVcIl0gPSAwXSA9IFwiSWdub3JlXCI7XG4gICAgQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmdbQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmdbXCJJbnZlcnRcIl0gPSAxXSA9IFwiSW52ZXJ0XCI7XG4gICAgQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmdbQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmdbXCJGYWxsYmFja1wiXSA9IDJdID0gXCJGYWxsYmFja1wiO1xufSkoQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmcgfHwgKEFkZGl0aW9uYWxJdGVtc0hhbmRsaW5nID0ge30pKTtcbi8qKiBHaXZlbiBhIGBzY2hlbWFgIHdpbGwgcmV0dXJuIGFuIGlubmVyIHNjaGVtYSB0aGF0IGZvciBhbiBhcnJheSBpdGVtLiBUaGlzIGlzIGNvbXB1dGVkIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoZVxuICogYGFkZGl0aW9uYWxJdGVtc2AgZW51bSBhbmQgdGhlIHZhbHVlIG9mIGBpZHhgLiBUaGVyZSBhcmUgZm91ciBwb3NzaWJsZSByZXR1cm5zOlxuICogMS4gSWYgYGlkeGAgaXMgPj0gMCwgdGhlbiBpZiBgc2NoZW1hLml0ZW1zYCBpcyBhbiBhcnJheSB0aGUgYGlkeGB0aCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyByZXR1cm5lZCBpZiBpdCBpcyBhIHZhbGlkXG4gKiAgICBpbmRleCBhbmQgbm90IGEgYm9vbGVhbiwgb3RoZXJ3aXNlIGl0IGZhbGxzIHRocm91Z2ggdG8gMy5cbiAqIDIuIElmIGBzY2hlbWEuaXRlbXNgIGlzIG5vdCBhbiBhcnJheSBBTkQgdHJ1dGh5IGFuZCBub3QgYSBib29sZWFuLCB0aGVuIGBzY2hlbWEuaXRlbXNgIGlzIHJldHVybmVkIHNpbmNlIGl0IGFjdHVhbGx5XG4gKiAgICBpcyBhIHNjaGVtYSwgb3RoZXJ3aXNlIGl0IGZhbGxzIHRocm91Z2ggdG8gMy5cbiAqIDMuIElmIGBhZGRpdGlvbmFsSXRlbXNgIGlzIG5vdCBgQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmcuSWdub3JlYCBhbmQgYHNjaGVtYS5hZGRpdGlvbmFsSXRlbXNgIGlzIGFuIG9iamVjdCwgdGhlblxuICogICAgYHNjaGVtYS5hZGRpdGlvbmFsSXRlbXNgIGlzIHJldHVybmVkIHNpbmNlIGl0IGFjdHVhbGx5IGlzIGEgc2NoZW1hLCBvdGhlcndpc2UgaXQgZmFsbHMgdGhyb3VnaCB0byA0LlxuICogNC4ge30gaXMgcmV0dXJuZWQgcmVwcmVzZW50aW5nIGFuIGVtcHR5IHNjaGVtYVxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBwYXJ0aWN1bGFyIGl0ZW1cbiAqIEBwYXJhbSBbYWRkaXRpb25hbEl0ZW1zPUFkZGl0aW9uYWxJdGVtc0hhbmRsaW5nLklnbm9yZV0gLSBIb3cgZG8gd2Ugd2FudCB0byBoYW5kbGUgYWRkaXRpb25hbCBpdGVtcz9cbiAqIEBwYXJhbSBbaWR4PS0xXSAtIEluZGV4LCBpZiBub24tbmVnYXRpdmUsIHdpbGwgYmUgdXNlZCB0byByZXR1cm4gdGhlIGlkeC10aCBlbGVtZW50IGluIGEgYHNjaGVtYS5pdGVtc2AgYXJyYXlcbiAqIEByZXR1cm5zIC0gVGhlIGJlc3QgZml0IHNjaGVtYSBvYmplY3QgZnJvbSB0aGUgYHNjaGVtYWAgZ2l2ZW4gdGhlIGBhZGRpdGlvbmFsSXRlbXNgIGFuZCBgaWR4YCBtb2RpZmllcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElubmVyU2NoZW1hRm9yQXJyYXlJdGVtKHNjaGVtYSwgYWRkaXRpb25hbEl0ZW1zID0gQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmcuSWdub3JlLCBpZHggPSAtMSkge1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpICYmIGlkeCA8IHNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzY2hlbWEuaXRlbXNbaWR4XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hLml0ZW1zICYmICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgJiYgdHlwZW9mIHNjaGVtYS5pdGVtcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuaXRlbXM7XG4gICAgfVxuICAgIGlmIChhZGRpdGlvbmFsSXRlbXMgIT09IEFkZGl0aW9uYWxJdGVtc0hhbmRsaW5nLklnbm9yZSAmJiBpc09iamVjdChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuLyoqIEVpdGhlciBhZGQgYGNvbXB1dGVkRGVmYXVsdGAgYXQgYGtleWAgaW50byBgb2JqYCBvciBub3QgYWRkIGl0IGJhc2VkIG9uIGl0cyB2YWx1ZSwgdGhlIHZhbHVlIG9mXG4gKiBgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc2AsIHRoZSB2YWx1ZSBvZiBgZW1wdHlPYmplY3RGaWVsZHNgIGFuZCBpZiBpdHMgcGFyZW50IGZpZWxkIGlzIHJlcXVpcmVkLiBHZW5lcmFsbHkgdW5kZWZpbmVkXG4gKiBgY29tcHV0ZWREZWZhdWx0YCB2YWx1ZXMgYXJlIGFkZGVkIG9ubHkgd2hlbiBgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc2AgaXMgZWl0aGVyIHRydWUvXCJleGNsdWRlT2JqZWN0Q2hpbGRyZW5cIi4gSWYgYFxuICogaW5jbHVkZVVuZGVmaW5lZFZhbHVlc2AgaXMgZmFsc2UgYW5kIGBlbXB0eU9iamVjdEZpZWxkc2AgaXMgbm90IFwic2tpcERlZmF1bHRzXCIsIHRoZW4gbm9uLXVuZGVmaW5lZCBhbmQgbm9uLWVtcHR5LW9iamVjdFxuICogdmFsdWVzIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gY2VydGFpbiBjb25kaXRpb25zLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IGludG8gd2hpY2ggdGhlIGNvbXB1dGVkIGRlZmF1bHQgbWF5IGJlIGFkZGVkXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBpbnRvIHRoZSBvYmplY3QgYXQgd2hpY2ggdGhlIGNvbXB1dGVkIGRlZmF1bHQgbWF5IGJlIGFkZGVkXG4gKiBAcGFyYW0gY29tcHV0ZWREZWZhdWx0IC0gVGhlIGNvbXB1dGVkIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXliZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG9ialxuICogQHBhcmFtIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMgLSBPcHRpb25hbCBmbGFnLCBpZiB0cnVlLCBjYXVzZSB1bmRlZmluZWQgdmFsdWVzIHRvIGJlIGFkZGVkIGFzIGRlZmF1bHRzLlxuICogICAgICAgICAgSWYgXCJleGNsdWRlT2JqZWN0Q2hpbGRyZW5cIiwgY2F1c2UgdW5kZWZpbmVkIHZhbHVlcyBmb3IgdGhpcyBvYmplY3QgYW5kIHBhc3MgYGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNgIGFzXG4gKiAgICAgICAgICBmYWxzZSB3aGVuIGNvbXB1dGluZyBkZWZhdWx0cyBmb3IgYW55IG5lc3RlZCBvYmplY3QgcHJvcGVydGllcy4gSWYgXCJhbGxvd0VtcHR5T2JqZWN0XCIsIHByZXZlbnRzIHVuZGVmaW5lZFxuICogICAgICAgICAgdmFsdWVzIGluIHRoaXMgb2JqZWN0IHdoaWxlIGFsbG93IHRoZSBvYmplY3QgaXRzZWxmIHRvIGJlIGVtcHR5IGFuZCBwYXNzaW5nIGBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzYCBhc1xuICogICAgICAgICAgZmFsc2Ugd2hlbiBjb21wdXRpbmcgZGVmYXVsdHMgZm9yIGFueSBuZXN0ZWQgb2JqZWN0IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gaXNQYXJlbnRSZXF1aXJlZCAtIFRoZSBvcHRpb25hbCBib29sZWFuIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBhcmVudCBmaWVsZCBpcyByZXF1aXJlZFxuICogQHBhcmFtIHJlcXVpcmVkRmllbGRzIC0gVGhlIGxpc3Qgb2YgZmllbGRzIHRoYXQgYXJlIHJlcXVpcmVkXG4gKiBAcGFyYW0gZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvciAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBpZiBwcm92aWRlZCwgYWxsb3dzIHVzZXJzIHRvIG92ZXJyaWRlXG4gKiAgICAgICAgZGVmYXVsdCBmb3JtIHN0YXRlIGJlaGF2aW9yXG4gKi9cbmZ1bmN0aW9uIG1heWJlQWRkRGVmYXVsdFRvT2JqZWN0KG9iaiwga2V5LCBjb21wdXRlZERlZmF1bHQsIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMsIGlzUGFyZW50UmVxdWlyZWQsIHJlcXVpcmVkRmllbGRzID0gW10sIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IgPSB7fSkge1xuICAgIGNvbnN0IHsgZW1wdHlPYmplY3RGaWVsZHMgPSAncG9wdWxhdGVBbGxEZWZhdWx0cycgfSA9IGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3I7XG4gICAgaWYgKGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMpIHtcbiAgICAgICAgb2JqW2tleV0gPSBjb21wdXRlZERlZmF1bHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVtcHR5T2JqZWN0RmllbGRzICE9PSAnc2tpcERlZmF1bHRzJykge1xuICAgICAgICBpZiAoaXNPYmplY3QoY29tcHV0ZWREZWZhdWx0KSkge1xuICAgICAgICAgICAgLy8gSWYgaXNQYXJlbnRSZXF1aXJlZCBpcyB1bmRlZmluZWQsIHRoZW4gd2UgYXJlIGF0IHRoZSByb290IGxldmVsIG9mIHRoZSBzY2hlbWEgc28gZGVmZXIgdG8gdGhlIHJlcXVpcmVkbmVzcyBvZlxuICAgICAgICAgICAgLy8gdGhlIGZpZWxkIGtleSBpdHNlbGYgaW4gdGhlIGByZXF1aXJlZEZpZWxkYCBsaXN0XG4gICAgICAgICAgICBjb25zdCBpc1NlbGZPclBhcmVudFJlcXVpcmVkID0gaXNQYXJlbnRSZXF1aXJlZCA9PT0gdW5kZWZpbmVkID8gcmVxdWlyZWRGaWVsZHMuaW5jbHVkZXMoa2V5KSA6IGlzUGFyZW50UmVxdWlyZWQ7XG4gICAgICAgICAgICAvLyBTdG9yZSBjb21wdXRlZERlZmF1bHQgaWYgaXQncyBhIG5vbi1lbXB0eSBvYmplY3QoZS5nLiBub3Qge30pIGFuZCBzYXRpc2ZpZXMgY2VydGFpbiBjb25kaXRpb25zXG4gICAgICAgICAgICAvLyBDb25kaXRpb24gMTogSWYgY29tcHV0ZWREZWZhdWx0IGlzIG5vdCBlbXB0eSBvciBpZiB0aGUga2V5IGlzIGEgcmVxdWlyZWQgZmllbGRcbiAgICAgICAgICAgIC8vIENvbmRpdGlvbiAyOiBJZiB0aGUgcGFyZW50IG9iamVjdCBpcyByZXF1aXJlZCBvciBlbXB0eU9iamVjdEZpZWxkcyBpcyBub3QgJ3BvcHVsYXRlUmVxdWlyZWREZWZhdWx0cydcbiAgICAgICAgICAgIGlmICgoIWlzRW1wdHkoY29tcHV0ZWREZWZhdWx0KSB8fCByZXF1aXJlZEZpZWxkcy5pbmNsdWRlcyhrZXkpKSAmJlxuICAgICAgICAgICAgICAgIChpc1NlbGZPclBhcmVudFJlcXVpcmVkIHx8IGVtcHR5T2JqZWN0RmllbGRzICE9PSAncG9wdWxhdGVSZXF1aXJlZERlZmF1bHRzJykpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGNvbXB1dGVkRGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gU3RvcmUgY29tcHV0ZWREZWZhdWx0IGlmIGl0J3MgYSBkZWZpbmVkIHByaW1pdGl2ZSAoZS5nLiwgdHJ1ZSkgYW5kIHNhdGlzZmllcyBjZXJ0YWluIGNvbmRpdGlvbnNcbiAgICAgICAgLy8gQ29uZGl0aW9uIDE6IGNvbXB1dGVkRGVmYXVsdCBpcyBub3QgdW5kZWZpbmVkXG4gICAgICAgIC8vIENvbmRpdGlvbiAyOiBJZiBlbXB0eU9iamVjdEZpZWxkcyBpcyAncG9wdWxhdGVBbGxEZWZhdWx0cycgb3IgaWYgdGhlIGtleSBpcyBhIHJlcXVpcmVkIGZpZWxkXG4gICAgICAgIGNvbXB1dGVkRGVmYXVsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoZW1wdHlPYmplY3RGaWVsZHMgPT09ICdwb3B1bGF0ZUFsbERlZmF1bHRzJyB8fCByZXF1aXJlZEZpZWxkcy5pbmNsdWRlcyhrZXkpKSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBjb21wdXRlZERlZmF1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQ29tcHV0ZXMgdGhlIGRlZmF1bHRzIGZvciB0aGUgY3VycmVudCBgc2NoZW1hYCBnaXZlbiB0aGUgYHJhd0Zvcm1EYXRhYCBhbmQgYHBhcmVudERlZmF1bHRzYCBpZiBhbnkuIFRoaXMgZHJpbGxzIGludG9cbiAqIGVhY2ggbGV2ZWwgb2YgdGhlIHNjaGVtYSwgcmVjdXJzaXZlbHksIHRvIGZpbGwgb3V0IGV2ZXJ5IGxldmVsIG9mIGRlZmF1bHRzIHByb3ZpZGVkIGJ5IHRoZSBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gcmF3U2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIGRlZmF1bHQgc3RhdGUgaXMgZGVzaXJlZFxuICogQHBhcmFtIFtwcm9wc10gLSBPcHRpb25hbCBwcm9wcyBmb3IgdGhpcyBmdW5jdGlvblxuICogQHBhcmFtIFtwcm9wcy5wYXJlbnREZWZhdWx0c10gLSBBbnkgZGVmYXVsdHMgcHJvdmlkZWQgYnkgdGhlIHBhcmVudCBmaWVsZCBpbiB0aGUgc2NoZW1hXG4gKiBAcGFyYW0gW3Byb3BzLnJvb3RTY2hlbWFdIC0gVGhlIG9wdGlvbnMgcm9vdCBzY2hlbWEsIHVzZWQgdG8gcHJpbWFyaWx5IHRvIGxvb2sgdXAgYCRyZWZgc1xuICogQHBhcmFtIFtwcm9wcy5yYXdGb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCBvbnRvIHdoaWNoIHRvIHByb3ZpZGUgYW55IG1pc3NpbmcgZGVmYXVsdHNcbiAqIEBwYXJhbSBbcHJvcHMuaW5jbHVkZVVuZGVmaW5lZFZhbHVlcz1mYWxzZV0gLSBPcHRpb25hbCBmbGFnLCBpZiB0cnVlLCBjYXVzZSB1bmRlZmluZWQgdmFsdWVzIHRvIGJlIGFkZGVkIGFzIGRlZmF1bHRzLlxuICogICAgICAgICAgSWYgXCJleGNsdWRlT2JqZWN0Q2hpbGRyZW5cIiwgY2F1c2UgdW5kZWZpbmVkIHZhbHVlcyBmb3IgdGhpcyBvYmplY3QgYW5kIHBhc3MgYGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNgIGFzXG4gKiAgICAgICAgICBmYWxzZSB3aGVuIGNvbXB1dGluZyBkZWZhdWx0cyBmb3IgYW55IG5lc3RlZCBvYmplY3QgcHJvcGVydGllcy5cbiAqIEBwYXJhbSBbcHJvcHMuX3JlY3Vyc2VMaXN0PVtdXSAtIFRoZSBsaXN0IG9mIHJlZiBuYW1lcyBjdXJyZW50bHkgYmVpbmcgcmVjdXJzZWQsIHVzZWQgdG8gcHJldmVudCBpbmZpbml0ZSByZWN1cnNpb25cbiAqIEBwYXJhbSBbcHJvcHMuZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcl0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QsIGlmIHByb3ZpZGVkLCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBmb3JtIHN0YXRlIGJlaGF2aW9yXG4gKiBAcGFyYW0gW3Byb3BzLnJlcXVpcmVkXSAtIE9wdGlvbmFsIGZsYWcsIGlmIHRydWUsIGluZGljYXRlcyB0aGlzIHNjaGVtYSB3YXMgcmVxdWlyZWQgaW4gdGhlIHBhcmVudCBzY2hlbWEuXG4gKiBAcmV0dXJucyAtIFRoZSByZXN1bHRpbmcgYGZvcm1EYXRhYCB3aXRoIGFsbCB0aGUgZGVmYXVsdHMgcHJvdmlkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0cyh2YWxpZGF0b3IsIHJhd1NjaGVtYSwgeyBwYXJlbnREZWZhdWx0cywgcmF3Rm9ybURhdGEsIHJvb3RTY2hlbWEgPSB7fSwgaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyA9IGZhbHNlLCBfcmVjdXJzZUxpc3QgPSBbXSwgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvciA9IHVuZGVmaW5lZCwgcmVxdWlyZWQsIH0gPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZm9ybURhdGEgPSAoaXNPYmplY3QocmF3Rm9ybURhdGEpID8gcmF3Rm9ybURhdGEgOiB7fSk7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNPYmplY3QocmF3U2NoZW1hKSA/IHJhd1NjaGVtYSA6IHt9O1xuICAgIC8vIENvbXB1dGUgdGhlIGRlZmF1bHRzIHJlY3Vyc2l2ZWx5OiBnaXZlIGhpZ2hlc3QgcHJpb3JpdHkgdG8gZGVlcGVzdCBub2Rlcy5cbiAgICBsZXQgZGVmYXVsdHMgPSBwYXJlbnREZWZhdWx0cztcbiAgICAvLyBJZiB3ZSBnZXQgYSBuZXcgc2NoZW1hLCB0aGVuIHdlIG5lZWQgdG8gcmVjb21wdXRlIGRlZmF1bHRzIGFnYWluIGZvciB0aGUgbmV3IHNjaGVtYSBmb3VuZC5cbiAgICBsZXQgc2NoZW1hVG9Db21wdXRlID0gbnVsbDtcbiAgICBsZXQgdXBkYXRlZFJlY3Vyc2VMaXN0ID0gX3JlY3Vyc2VMaXN0O1xuICAgIGlmIChpc09iamVjdChkZWZhdWx0cykgJiYgaXNPYmplY3Qoc2NoZW1hLmRlZmF1bHQpKSB7XG4gICAgICAgIC8vIEZvciBvYmplY3QgZGVmYXVsdHMsIG9ubHkgb3ZlcnJpZGUgcGFyZW50IGRlZmF1bHRzIHRoYXQgYXJlIGRlZmluZWQgaW5cbiAgICAgICAgLy8gc2NoZW1hLmRlZmF1bHQuXG4gICAgICAgIGRlZmF1bHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRzLCBzY2hlbWEuZGVmYXVsdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKERFRkFVTFRfS0VZIGluIHNjaGVtYSkge1xuICAgICAgICBkZWZhdWx0cyA9IHNjaGVtYS5kZWZhdWx0O1xuICAgIH1cbiAgICBlbHNlIGlmIChSRUZfS0VZIGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCByZWZOYW1lID0gc2NoZW1hW1JFRl9LRVldO1xuICAgICAgICAvLyBVc2UgcmVmZXJlbmNlZCBzY2hlbWEgZGVmYXVsdHMgZm9yIHRoaXMgbm9kZS5cbiAgICAgICAgaWYgKCFfcmVjdXJzZUxpc3QuaW5jbHVkZXMocmVmTmFtZSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRSZWN1cnNlTGlzdCA9IF9yZWN1cnNlTGlzdC5jb25jYXQocmVmTmFtZSk7XG4gICAgICAgICAgICBzY2hlbWFUb0NvbXB1dGUgPSBmaW5kU2NoZW1hRGVmaW5pdGlvbihyZWZOYW1lLCByb290U2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChERVBFTkRFTkNJRVNfS0VZIGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IHJlc29sdmVEZXBlbmRlbmNpZXModmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIGZhbHNlLCBbXSwgZm9ybURhdGEpO1xuICAgICAgICBzY2hlbWFUb0NvbXB1dGUgPSByZXNvbHZlZFNjaGVtYVswXTsgLy8gcGljayB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHJlc29sdmUgZGVwZW5kZW5jaWVzXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRml4ZWRJdGVtcyhzY2hlbWEpKSB7XG4gICAgICAgIGRlZmF1bHRzID0gc2NoZW1hLml0ZW1zLm1hcCgoaXRlbVNjaGVtYSwgaWR4KSA9PiBjb21wdXRlRGVmYXVsdHModmFsaWRhdG9yLCBpdGVtU2NoZW1hLCB7XG4gICAgICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyxcbiAgICAgICAgICAgIF9yZWN1cnNlTGlzdCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IsXG4gICAgICAgICAgICBwYXJlbnREZWZhdWx0czogQXJyYXkuaXNBcnJheShwYXJlbnREZWZhdWx0cykgPyBwYXJlbnREZWZhdWx0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmF3Rm9ybURhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT05FX09GX0tFWSBpbiBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgeyBvbmVPZiwgLi4ucmVtYWluaW5nIH0gPSBzY2hlbWE7XG4gICAgICAgIGlmIChvbmVPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldERpc2NyaW1pbmF0b3JGaWVsZEZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgc2NoZW1hVG9Db21wdXRlID0gb25lT2ZbZ2V0Q2xvc2VzdE1hdGNoaW5nT3B0aW9uKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgaXNFbXB0eShmb3JtRGF0YSkgPyB1bmRlZmluZWQgOiBmb3JtRGF0YSwgb25lT2YsIDAsIGRpc2NyaW1pbmF0b3IpXTtcbiAgICAgICAgc2NoZW1hVG9Db21wdXRlID0gbWVyZ2VTY2hlbWFzKHJlbWFpbmluZywgc2NoZW1hVG9Db21wdXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQU5ZX09GX0tFWSBpbiBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgeyBhbnlPZiwgLi4ucmVtYWluaW5nIH0gPSBzY2hlbWE7XG4gICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldERpc2NyaW1pbmF0b3JGaWVsZEZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgc2NoZW1hVG9Db21wdXRlID0gYW55T2ZbZ2V0Q2xvc2VzdE1hdGNoaW5nT3B0aW9uKHZhbGlkYXRvciwgcm9vdFNjaGVtYSwgaXNFbXB0eShmb3JtRGF0YSkgPyB1bmRlZmluZWQgOiBmb3JtRGF0YSwgYW55T2YsIDAsIGRpc2NyaW1pbmF0b3IpXTtcbiAgICAgICAgc2NoZW1hVG9Db21wdXRlID0gbWVyZ2VTY2hlbWFzKHJlbWFpbmluZywgc2NoZW1hVG9Db21wdXRlKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVRvQ29tcHV0ZSkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRzKHZhbGlkYXRvciwgc2NoZW1hVG9Db21wdXRlLCB7XG4gICAgICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyxcbiAgICAgICAgICAgIF9yZWN1cnNlTGlzdDogdXBkYXRlZFJlY3Vyc2VMaXN0LFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcixcbiAgICAgICAgICAgIHBhcmVudERlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgIHJhd0Zvcm1EYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTm8gZGVmYXVsdHMgZGVmaW5lZCBmb3IgdGhpcyBub2RlLCBmYWxsYmFjayB0byBnZW5lcmljIHR5cGVkIG9uZXMuXG4gICAgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmYXVsdHMgPSBzY2hlbWEuZGVmYXVsdDtcbiAgICB9XG4gICAgc3dpdGNoIChnZXRTY2hlbWFUeXBlKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZWN1cnNlIGZvciBvYmplY3Qgc2NoZW1hIGlubmVyIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3REZWZhdWx0cyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9KS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGRlZmF1bHRzIGZvciB0aGlzIG5vZGUsIHdpdGggdGhlIHBhcmVudCBkZWZhdWx0cyB3ZSBtaWdodFxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZnJvbSBhIHByZXZpb3VzIHJ1bjogZGVmYXVsdHNba2V5XS5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wdXRlZERlZmF1bHQgPSBjb21wdXRlRGVmYXVsdHModmFsaWRhdG9yLCBnZXQoc2NoZW1hLCBbUFJPUEVSVElFU19LRVksIGtleV0pLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIF9yZWN1cnNlTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlczogaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyA9PT0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVmYXVsdHM6IGdldChkZWZhdWx0cywgW2tleV0pLFxuICAgICAgICAgICAgICAgICAgICByYXdGb3JtRGF0YTogZ2V0KGZvcm1EYXRhLCBba2V5XSksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAoX2EgPSBzY2hlbWEucmVxdWlyZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhrZXkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1heWJlQWRkRGVmYXVsdFRvT2JqZWN0KGFjYywga2V5LCBjb21wdXRlZERlZmF1bHQsIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMsIHJlcXVpcmVkLCBzY2hlbWEucmVxdWlyZWQsIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gYXMgcGVyIHNwZWMgYWRkaXRpb25hbFByb3BlcnRpZXMgbWF5IGJlIGVpdGhlciBzY2hlbWEgb3IgYm9vbGVhblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzU2NoZW1hID0gaXNPYmplY3Qoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA/IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA6IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4gIXNjaGVtYS5wcm9wZXJ0aWVzIHx8ICFzY2hlbWEucHJvcGVydGllc1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKGtleSkgPT4ga2V5cy5hZGQoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhUmVxdWlyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3JtRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiAhc2NoZW1hLnByb3BlcnRpZXMgfHwgIXNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGFSZXF1aXJlZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wdXRlZERlZmF1bHQgPSBjb21wdXRlRGVmYXVsdHModmFsaWRhdG9yLCBhZGRpdGlvbmFsUHJvcGVydGllc1NjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWN1cnNlTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzOiBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzID09PSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVmYXVsdHM6IGdldChkZWZhdWx0cywgW2tleV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Rm9ybURhdGE6IGdldChmb3JtRGF0YSwgW2tleV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IChfYSA9IHNjaGVtYS5yZXF1aXJlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKGtleSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGVzZSBhcmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdlIGRvbid0IG5lZWQgdG8gYWRkIHRoZSBgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcmAgcHJvcFxuICAgICAgICAgICAgICAgICAgICBtYXliZUFkZERlZmF1bHRUb09iamVjdChvYmplY3REZWZhdWx0cywga2V5LCBjb21wdXRlZERlZmF1bHQsIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMsIHJlcXVpcmVkLCBmb3JtRGF0YVJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3REZWZhdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgICAgIGNvbnN0IG5ldmVyUG9wdWxhdGUgPSAoKF9hID0gZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvciA9PT0gbnVsbCB8fCBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yLmFycmF5TWluSXRlbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3B1bGF0ZSkgPT09ICduZXZlcic7XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVNaW5JdGVtc0ZsYWdTZXQgPSAoKF9iID0gZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvciA9PT0gbnVsbCB8fCBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yLmFycmF5TWluSXRlbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wb3B1bGF0ZSkgPT09ICdyZXF1aXJlZE9ubHknO1xuICAgICAgICAgICAgLy8gSW5qZWN0IGRlZmF1bHRzIGludG8gZXhpc3RpbmcgYXJyYXkgZGVmYXVsdHNcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRzID0gZGVmYXVsdHMubWFwKChpdGVtLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IGdldElubmVyU2NoZW1hRm9yQXJyYXlJdGVtKHNjaGVtYSwgQWRkaXRpb25hbEl0ZW1zSGFuZGxpbmcuRmFsbGJhY2ssIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wdXRlRGVmYXVsdHModmFsaWRhdG9yLCBzY2hlbWFJdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlY3Vyc2VMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERlZmF1bHRzOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVlcGx5IGluamVjdCBkZWZhdWx0cyBpbnRvIGFscmVhZHkgZXhpc3RpbmcgZm9ybSBkYXRhXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdGb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gZ2V0SW5uZXJTY2hlbWFGb3JBcnJheUl0ZW0oc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAobmV2ZXJQb3B1bGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cyA9IHJhd0Zvcm1EYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgPSByYXdGb3JtRGF0YS5tYXAoKGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0cyh2YWxpZGF0b3IsIHNjaGVtYUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWN1cnNlTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0Zvcm1EYXRhOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERlZmF1bHRzOiBnZXQoZGVmYXVsdHMsIFtpZHhdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV2ZXJQb3B1bGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0cyAhPT0gbnVsbCAmJiBkZWZhdWx0cyAhPT0gdm9pZCAwID8gZGVmYXVsdHMgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZ25vcmVNaW5JdGVtc0ZsYWdTZXQgJiYgIXJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZm9ybSBkYXRhIGV4aXN0cyBvciBkZWZhdWx0cyBhcmUgc2V0IGxlYXZlIHRoZSBmaWVsZCBlbXB0eS9ub24tZXhpc3RlbnQsIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBmb3JtIGRhdGEvZGVmYXVsdHNcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdHMgPyBkZWZhdWx0cyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRzTGVuZ3RoID0gQXJyYXkuaXNBcnJheShkZWZhdWx0cykgPyBkZWZhdWx0cy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEubWluSXRlbXMgfHxcbiAgICAgICAgICAgICAgICBpc011bHRpU2VsZWN0KHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIHNjaGVtYS5taW5JdGVtcyA8PSBkZWZhdWx0c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0cyA/IGRlZmF1bHRzIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RW50cmllcyA9IChkZWZhdWx0cyB8fCBbXSk7XG4gICAgICAgICAgICBjb25zdCBmaWxsZXJTY2hlbWEgPSBnZXRJbm5lclNjaGVtYUZvckFycmF5SXRlbShzY2hlbWEsIEFkZGl0aW9uYWxJdGVtc0hhbmRsaW5nLkludmVydCk7XG4gICAgICAgICAgICBjb25zdCBmaWxsZXJEZWZhdWx0ID0gZmlsbGVyU2NoZW1hLmRlZmF1bHQ7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZmlsbGVyIGVudHJpZXMgZm9yIHJlbWFpbmluZyBpdGVtcyAobWluSXRlbXMgLSBleGlzdGluZyByYXcgZGF0YS9kZWZhdWx0cylcbiAgICAgICAgICAgIGNvbnN0IGZpbGxlckVudHJpZXMgPSBuZXcgQXJyYXkoc2NoZW1hLm1pbkl0ZW1zIC0gZGVmYXVsdHNMZW5ndGgpLmZpbGwoY29tcHV0ZURlZmF1bHRzKHZhbGlkYXRvciwgZmlsbGVyU2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgcGFyZW50RGVmYXVsdHM6IGZpbGxlckRlZmF1bHQsXG4gICAgICAgICAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgICAgICAgICBfcmVjdXJzZUxpc3QsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcixcbiAgICAgICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIHRoZW4gZmlsbCB1cCB0aGUgcmVzdCB3aXRoIGVpdGhlciB0aGUgaXRlbSBkZWZhdWx0IG9yIGVtcHR5LCB1cCB0byBtaW5JdGVtc1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRFbnRyaWVzLmNvbmNhdChmaWxsZXJFbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG59XG4vKiogUmV0dXJucyB0aGUgc3VwZXJzZXQgb2YgYGZvcm1EYXRhYCB0aGF0IGluY2x1ZGVzIHRoZSBnaXZlbiBzZXQgdXBkYXRlZCB0byBpbmNsdWRlIGFueSBtaXNzaW5nIGZpZWxkcyB0aGF0IGhhdmVcbiAqIGNvbXB1dGVkIHRvIGhhdmUgZGVmYXVsdHMgcHJvdmlkZWQgaW4gdGhlIGBzY2hlbWFgLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIG5lY2Vzc2FyeVxuICogQHBhcmFtIHRoZVNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHRoZSBkZWZhdWx0IHN0YXRlIGlzIGRlc2lyZWRcbiAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgb250byB3aGljaCB0byBwcm92aWRlIGFueSBtaXNzaW5nIGRlZmF1bHRzXG4gKiBAcGFyYW0gW3Jvb3RTY2hlbWFdIC0gVGhlIHJvb3Qgc2NoZW1hLCB1c2VkIHRvIHByaW1hcmlseSB0byBsb29rIHVwIGAkcmVmYHNcbiAqIEBwYXJhbSBbaW5jbHVkZVVuZGVmaW5lZFZhbHVlcz1mYWxzZV0gLSBPcHRpb25hbCBmbGFnLCBpZiB0cnVlLCBjYXVzZSB1bmRlZmluZWQgdmFsdWVzIHRvIGJlIGFkZGVkIGFzIGRlZmF1bHRzLlxuICogICAgICAgICAgSWYgXCJleGNsdWRlT2JqZWN0Q2hpbGRyZW5cIiwgY2F1c2UgdW5kZWZpbmVkIHZhbHVlcyBmb3IgdGhpcyBvYmplY3QgYW5kIHBhc3MgYGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNgIGFzXG4gKiAgICAgICAgICBmYWxzZSB3aGVuIGNvbXB1dGluZyBkZWZhdWx0cyBmb3IgYW55IG5lc3RlZCBvYmplY3QgcHJvcGVydGllcy5cbiAqIEBwYXJhbSBbZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcl0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QsIGlmIHByb3ZpZGVkLCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBmb3JtIHN0YXRlIGJlaGF2aW9yXG4gKiBAcmV0dXJucyAtIFRoZSByZXN1bHRpbmcgYGZvcm1EYXRhYCB3aXRoIGFsbCB0aGUgZGVmYXVsdHMgcHJvdmlkZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZvcm1TdGF0ZSh2YWxpZGF0b3IsIHRoZVNjaGVtYSwgZm9ybURhdGEsIHJvb3RTY2hlbWEsIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMgPSBmYWxzZSwgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcikge1xuICAgIGlmICghaXNPYmplY3QodGhlU2NoZW1hKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2NoZW1hOiAnICsgdGhlU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0gcmV0cmlldmVTY2hlbWEodmFsaWRhdG9yLCB0aGVTY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IGNvbXB1dGVEZWZhdWx0cyh2YWxpZGF0b3IsIHNjaGVtYSwge1xuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzLFxuICAgICAgICBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yLFxuICAgICAgICByYXdGb3JtRGF0YTogZm9ybURhdGEsXG4gICAgfSk7XG4gICAgaWYgKGZvcm1EYXRhID09PSB1bmRlZmluZWQgfHwgZm9ybURhdGEgPT09IG51bGwgfHwgKHR5cGVvZiBmb3JtRGF0YSA9PT0gJ251bWJlcicgJiYgaXNOYU4oZm9ybURhdGEpKSkge1xuICAgICAgICAvLyBObyBmb3JtIGRhdGE/IFVzZSBzY2hlbWEgZGVmYXVsdHMuXG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG4gICAgY29uc3QgeyBtZXJnZUV4dHJhRGVmYXVsdHMgfSA9IChleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yID09PSBudWxsIHx8IGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3IuYXJyYXlNaW5JdGVtcykgfHwge307XG4gICAgaWYgKGlzT2JqZWN0KGZvcm1EYXRhKSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShkZWZhdWx0cywgZm9ybURhdGEsIG1lcmdlRXh0cmFEZWZhdWx0cyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShkZWZhdWx0cywgZm9ybURhdGEsIG1lcmdlRXh0cmFEZWZhdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtRGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldERlZmF1bHRGb3JtU3RhdGUuanMubWFwIiwiaW1wb3J0IHsgVUlfRklFTERfS0VZLCBVSV9XSURHRVRfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBnZXRTY2hlbWFUeXBlIGZyb20gJy4uL2dldFNjaGVtYVR5cGUnO1xuaW1wb3J0IGdldFVpT3B0aW9ucyBmcm9tICcuLi9nZXRVaU9wdGlvbnMnO1xuaW1wb3J0IGlzQ3VzdG9tV2lkZ2V0IGZyb20gJy4uL2lzQ3VzdG9tV2lkZ2V0JztcbmltcG9ydCBpc0ZpbGVzQXJyYXkgZnJvbSAnLi9pc0ZpbGVzQXJyYXknO1xuaW1wb3J0IGlzTXVsdGlTZWxlY3QgZnJvbSAnLi9pc011bHRpU2VsZWN0Jztcbi8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbWJpbmF0aW9uIG9mIGBzY2hlbWFgIGFuZCBgdWlTY2hlbWFgIHByb3BlcnRpZXMgaW5kaWNhdGVzIHRoYXQgdGhlIGxhYmVsIGZvciB0aGUgYHNjaGVtYWBcbiAqIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYSBVSS5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBuZWNlc3NhcnlcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCB0aGUgZGlzcGxheSBsYWJlbCBmbGFnIGlzIGRlc2lyZWRcbiAqIEBwYXJhbSBbdWlTY2hlbWE9e31dIC0gVGhlIFVJIHNjaGVtYSBmcm9tIHdoaWNoIHRvIGRlcml2ZSBwb3RlbnRpYWxseSBkaXNwbGF5YWJsZSBpbmZvcm1hdGlvblxuICogQHBhcmFtIFtyb290U2NoZW1hXSAtIFRoZSByb290IHNjaGVtYSwgdXNlZCB0byBwcmltYXJpbHkgdG8gbG9vayB1cCBgJHJlZmBzXG4gKiBAcGFyYW0gW2dsb2JhbE9wdGlvbnM9e31dIC0gVGhlIG9wdGlvbmFsIEdsb2JhbCBVSSBTY2hlbWEgZnJvbSB3aGljaCB0byBnZXQgYW55IGZhbGxiYWNrIGB4eHhgIG9wdGlvbnNcbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCBvciBmYWxzZSBpZiBpdCBzaG91bGQgbm90XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERpc3BsYXlMYWJlbCh2YWxpZGF0b3IsIHNjaGVtYSwgdWlTY2hlbWEgPSB7fSwgcm9vdFNjaGVtYSwgZ2xvYmFsT3B0aW9ucykge1xuICAgIGNvbnN0IHVpT3B0aW9ucyA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgY29uc3QgeyBsYWJlbCA9IHRydWUgfSA9IHVpT3B0aW9ucztcbiAgICBsZXQgZGlzcGxheUxhYmVsID0gISFsYWJlbDtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZShzY2hlbWEpO1xuICAgIGlmIChzY2hlbWFUeXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIGRpc3BsYXlMYWJlbCA9XG4gICAgICAgICAgICBpc011bHRpU2VsZWN0KHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIGlzRmlsZXNBcnJheSh2YWxpZGF0b3IsIHNjaGVtYSwgdWlTY2hlbWEsIHJvb3RTY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgaXNDdXN0b21XaWRnZXQodWlTY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZGlzcGxheUxhYmVsID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnYm9vbGVhbicgJiYgIXVpU2NoZW1hW1VJX1dJREdFVF9LRVldKSB7XG4gICAgICAgIGRpc3BsYXlMYWJlbCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodWlTY2hlbWFbVUlfRklFTERfS0VZXSkge1xuICAgICAgICBkaXNwbGF5TGFiZWwgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BsYXlMYWJlbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldERpc3BsYXlMYWJlbC5qcy5tYXAiLCJpbXBvcnQgZ2V0TWF0Y2hpbmdPcHRpb24gZnJvbSAnLi9nZXRNYXRjaGluZ09wdGlvbic7XG4vKiogR2l2ZW4gdGhlIGBmb3JtRGF0YWAgYW5kIGxpc3Qgb2YgYG9wdGlvbnNgLCBhdHRlbXB0cyB0byBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb3B0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgZGF0YS5cbiAqIEFsd2F5cyByZXR1cm5zIHRoZSBmaXJzdCBvcHRpb24gaWYgdGhlcmUgaXMgbm90aGluZyB0aGF0IG1hdGNoZXMuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB1c2VkIHRvIGZpZ3VyZSBvdXQgYSBtYXRjaFxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbGlzdCBvZiBvcHRpb25zIHRvIGZpbmQgYSBtYXRjaGluZyBvcHRpb25zIGZyb21cbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hLCB1c2VkIHRvIHByaW1hcmlseSB0byBsb29rIHVwIGAkcmVmYHNcbiAqIEBwYXJhbSBbZGlzY3JpbWluYXRvckZpZWxkXSAtIFRoZSBvcHRpb25hbCBuYW1lIG9mIHRoZSBmaWVsZCB3aXRoaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHVzZWQgdG9cbiAqICAgICAgICAgIGRldGVybWluZSB3aGljaCBvcHRpb24gaXMgc2VsZWN0ZWRcbiAqIEByZXR1cm5zIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaGVkIG9wdGlvbiBvciAwIGlmIG5vbmUgaXMgYXZhaWxhYmxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZpcnN0TWF0Y2hpbmdPcHRpb24odmFsaWRhdG9yLCBmb3JtRGF0YSwgb3B0aW9ucywgcm9vdFNjaGVtYSwgZGlzY3JpbWluYXRvckZpZWxkKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoaW5nT3B0aW9uKHZhbGlkYXRvciwgZm9ybURhdGEsIG9wdGlvbnMsIHJvb3RTY2hlbWEsIGRpc2NyaW1pbmF0b3JGaWVsZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGaXJzdE1hdGNoaW5nT3B0aW9uLmpzLm1hcCIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IGlzTnVtYmVyIGZyb20gJ2xvZGFzaC9pc051bWJlcic7XG5pbXBvcnQgeyBQUk9QRVJUSUVTX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgZ2V0T3B0aW9uTWF0Y2hpbmdTaW1wbGVEaXNjcmltaW5hdG9yIGZyb20gJy4uL2dldE9wdGlvbk1hdGNoaW5nU2ltcGxlRGlzY3JpbWluYXRvcic7XG4vKiogR2l2ZW4gdGhlIGBmb3JtRGF0YWAgYW5kIGxpc3Qgb2YgYG9wdGlvbnNgLCBhdHRlbXB0cyB0byBmaW5kIHRoZSBpbmRleCBvZiB0aGUgb3B0aW9uIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBkYXRhLlxuICogRGVwcmVjYXRlZCwgdXNlIGBnZXRGaXJzdE1hdGNoaW5nT3B0aW9uKClgIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB1c2VkIHRvIGZpZ3VyZSBvdXQgYSBtYXRjaFxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbGlzdCBvZiBvcHRpb25zIHRvIGZpbmQgYSBtYXRjaGluZyBvcHRpb25zIGZyb21cbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hLCB1c2VkIHRvIHByaW1hcmlseSB0byBsb29rIHVwIGAkcmVmYHNcbiAqIEBwYXJhbSBbZGlzY3JpbWluYXRvckZpZWxkXSAtIFRoZSBvcHRpb25hbCBuYW1lIG9mIHRoZSBmaWVsZCB3aXRoaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHVzZWQgdG9cbiAqICAgICAgICAgIGRldGVybWluZSB3aGljaCBvcHRpb24gaXMgc2VsZWN0ZWRcbiAqIEByZXR1cm5zIC0gVGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIG9wdGlvbiBvciAwIGlmIG5vbmUgaXMgYXZhaWxhYmxlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYXRjaGluZ09wdGlvbih2YWxpZGF0b3IsIGZvcm1EYXRhLCBvcHRpb25zLCByb290U2NoZW1hLCBkaXNjcmltaW5hdG9yRmllbGQpIHtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UsIHNraXAgdmFsaWRhdGluZyBzdWJzY2hlbWFzIGlmIGZvcm1EYXRhIGlzIHVuZGVmaW5lZC4gV2UganVzdFxuICAgIC8vIHdhbnQgdG8gZ2V0IHRoZSBmaXJzdCBvcHRpb24gaW4gdGhhdCBjYXNlLlxuICAgIGlmIChmb3JtRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBzaW1wbGVEaXNjcmltaW5hdG9yTWF0Y2ggPSBnZXRPcHRpb25NYXRjaGluZ1NpbXBsZURpc2NyaW1pbmF0b3IoZm9ybURhdGEsIG9wdGlvbnMsIGRpc2NyaW1pbmF0b3JGaWVsZCk7XG4gICAgaWYgKGlzTnVtYmVyKHNpbXBsZURpc2NyaW1pbmF0b3JNYXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZURpc2NyaW1pbmF0b3JNYXRjaDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBkaXNjcmltaW5hdG9yIGZpZWxkLCB0aGVuIHdlIHdpbGwgdXNlIHRoaXMgdG8gbWFrZSB0aGUgZGV0ZXJtaW5hdGlvblxuICAgICAgICBpZiAoZGlzY3JpbWluYXRvckZpZWxkICYmIGhhcyhvcHRpb24sIFtQUk9QRVJUSUVTX0tFWSwgZGlzY3JpbWluYXRvckZpZWxkXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KGZvcm1EYXRhLCBkaXNjcmltaW5hdG9yRmllbGQpO1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldChvcHRpb24sIFtQUk9QRVJUSUVTX0tFWSwgZGlzY3JpbWluYXRvckZpZWxkXSwge30pO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5pc1ZhbGlkKGRpc2NyaW1pbmF0b3IsIHZhbHVlLCByb290U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbltQUk9QRVJUSUVTX0tFWV0pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzY2hlbWEgZGVzY3JpYmVzIGFuIG9iamVjdCB0aGVuIHdlIG5lZWQgdG8gYWRkIHNsaWdodGx5IG1vcmVcbiAgICAgICAgICAgIC8vIHN0cmljdCBtYXRjaGluZyB0byB0aGUgc2NoZW1hLCBiZWNhdXNlIHVubGVzcyB0aGUgc2NoZW1hIHVzZXMgdGhlXG4gICAgICAgICAgICAvLyBcInJlcXVpcmVzXCIga2V5d29yZCwgYW4gb2JqZWN0IHdpbGwgbWF0Y2ggdGhlIHNjaGVtYSBhcyBsb25nIGFzIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGhhdmUgbWF0Y2hpbmcga2V5cyB3aXRoIGEgY29uZmxpY3RpbmcgdHlwZS4gVG8gZG8gdGhpcyB3ZSB1c2UgYW5cbiAgICAgICAgICAgIC8vIFwiYW55T2ZcIiB3aXRoIGFuIGFycmF5IG9mIHJlcXVpcmVzLiBUaGlzIGF1Z21lbnRhdGlvbiBleHByZXNzZXMgdGhhdCB0aGVcbiAgICAgICAgICAgIC8vIHNjaGVtYSBzaG91bGQgbWF0Y2ggaWYgYW55IG9mIHRoZSBrZXlzIGluIHRoZSBzY2hlbWEgYXJlIHByZXNlbnQgb24gdGhlXG4gICAgICAgICAgICAvLyBvYmplY3QgYW5kIHBhc3MgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gXCJhbnlPZlwiIHNjaGVtYSB0aGF0IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvZiB0aGUga2V5cyBpbiB0aGVcbiAgICAgICAgICAgIC8vIFwicHJvcGVydGllc1wiIG9iamVjdFxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZXNBbnlPZiA9IHtcbiAgICAgICAgICAgICAgICBhbnlPZjogT2JqZWN0LmtleXMob3B0aW9uW1BST1BFUlRJRVNfS0VZXSkubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBba2V5XSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGF1Z21lbnRlZFNjaGVtYTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBcImFueU9mXCIga2V5d29yZCBhbHJlYWR5IGV4aXN0cywgd3JhcCB0aGUgYXVnbWVudGF0aW9uIGluIGFuIFwiYWxsT2ZcIlxuICAgICAgICAgICAgaWYgKG9wdGlvbi5hbnlPZikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgLi4uc2hhbGxvd0Nsb25lIH0gPSBvcHRpb247XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93Q2xvbmUuYWxsT2YpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhbGxvd0Nsb25lLmFsbE9mID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBcImFsbE9mXCIgYWxyZWFkeSBleGlzdHMsIHNoYWxsb3cgY2xvbmUgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHNoYWxsb3dDbG9uZS5hbGxPZiA9IHNoYWxsb3dDbG9uZS5hbGxPZi5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGFsbG93Q2xvbmUuYWxsT2YucHVzaChyZXF1aXJlc0FueU9mKTtcbiAgICAgICAgICAgICAgICBhdWdtZW50ZWRTY2hlbWEgPSBzaGFsbG93Q2xvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdWdtZW50ZWRTY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb24sIHJlcXVpcmVzQW55T2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBcInJlcXVpcmVkXCIgZmllbGQgYXMgaXQncyBsaWtlbHkgdGhhdCBub3QgYWxsIGZpZWxkcyBoYXZlXG4gICAgICAgICAgICAvLyBiZWVuIGZpbGxlZCBpbiB5ZXQsIHdoaWNoIHdpbGwgbWVhbiB0aGF0IHRoZSBzY2hlbWEgaXMgbm90IHZhbGlkXG4gICAgICAgICAgICBkZWxldGUgYXVnbWVudGVkU2NoZW1hLnJlcXVpcmVkO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5pc1ZhbGlkKGF1Z21lbnRlZFNjaGVtYSwgZm9ybURhdGEsIHJvb3RTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsaWRhdG9yLmlzVmFsaWQob3B0aW9uLCBmb3JtRGF0YSwgcm9vdFNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0TWF0Y2hpbmdPcHRpb24uanMubWFwIiwiaW1wb3J0IGdldERlZmF1bHRGb3JtU3RhdGUgZnJvbSAnLi9nZXREZWZhdWx0Rm9ybVN0YXRlJztcbmltcG9ydCBnZXREaXNwbGF5TGFiZWwgZnJvbSAnLi9nZXREaXNwbGF5TGFiZWwnO1xuaW1wb3J0IGdldENsb3Nlc3RNYXRjaGluZ09wdGlvbiBmcm9tICcuL2dldENsb3Nlc3RNYXRjaGluZ09wdGlvbic7XG5pbXBvcnQgZ2V0Rmlyc3RNYXRjaGluZ09wdGlvbiBmcm9tICcuL2dldEZpcnN0TWF0Y2hpbmdPcHRpb24nO1xuaW1wb3J0IGdldE1hdGNoaW5nT3B0aW9uIGZyb20gJy4vZ2V0TWF0Y2hpbmdPcHRpb24nO1xuaW1wb3J0IGlzRmlsZXNBcnJheSBmcm9tICcuL2lzRmlsZXNBcnJheSc7XG5pbXBvcnQgaXNNdWx0aVNlbGVjdCBmcm9tICcuL2lzTXVsdGlTZWxlY3QnO1xuaW1wb3J0IGlzU2VsZWN0IGZyb20gJy4vaXNTZWxlY3QnO1xuaW1wb3J0IG1lcmdlVmFsaWRhdGlvbkRhdGEgZnJvbSAnLi9tZXJnZVZhbGlkYXRpb25EYXRhJztcbmltcG9ydCByZXRyaWV2ZVNjaGVtYSBmcm9tICcuL3JldHJpZXZlU2NoZW1hJztcbmltcG9ydCBzYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEgZnJvbSAnLi9zYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEnO1xuaW1wb3J0IHRvSWRTY2hlbWEgZnJvbSAnLi90b0lkU2NoZW1hJztcbmltcG9ydCB0b1BhdGhTY2hlbWEgZnJvbSAnLi90b1BhdGhTY2hlbWEnO1xuZXhwb3J0IHsgZ2V0RGVmYXVsdEZvcm1TdGF0ZSwgZ2V0RGlzcGxheUxhYmVsLCBnZXRDbG9zZXN0TWF0Y2hpbmdPcHRpb24sIGdldEZpcnN0TWF0Y2hpbmdPcHRpb24sIGdldE1hdGNoaW5nT3B0aW9uLCBpc0ZpbGVzQXJyYXksIGlzTXVsdGlTZWxlY3QsIGlzU2VsZWN0LCBtZXJnZVZhbGlkYXRpb25EYXRhLCByZXRyaWV2ZVNjaGVtYSwgc2FuaXRpemVEYXRhRm9yTmV3U2NoZW1hLCB0b0lkU2NoZW1hLCB0b1BhdGhTY2hlbWEsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBVSV9XSURHRVRfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCByZXRyaWV2ZVNjaGVtYSBmcm9tICcuL3JldHJpZXZlU2NoZW1hJztcbi8qKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBgc2NoZW1hYCBhbmQgYHVpU2NoZW1hYCBjb21iaW5hdGlvbiByZXByZXNlbnRzIGFuIGFycmF5IG9mIGZpbGVzXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggY2hlY2sgZm9yIGFycmF5IG9mIGZpbGVzIGZsYWcgaXMgZGVzaXJlZFxuICogQHBhcmFtIFt1aVNjaGVtYT17fV0gLSBUaGUgVUkgc2NoZW1hIGZyb20gd2hpY2ggdG8gY2hlY2sgdGhlIHdpZGdldFxuICogQHBhcmFtIFtyb290U2NoZW1hXSAtIFRoZSByb290IHNjaGVtYSwgdXNlZCB0byBwcmltYXJpbHkgdG8gbG9vayB1cCBgJHJlZmBzXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgc2NoZW1hL3VpU2NoZW1hIGNvbnRhaW5zIGFuIGFycmF5IG9mIGZpbGVzLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNGaWxlc0FycmF5KHZhbGlkYXRvciwgc2NoZW1hLCB1aVNjaGVtYSA9IHt9LCByb290U2NoZW1hKSB7XG4gICAgaWYgKHVpU2NoZW1hW1VJX1dJREdFVF9LRVldID09PSAnZmlsZXMnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zU2NoZW1hID0gcmV0cmlldmVTY2hlbWEodmFsaWRhdG9yLCBzY2hlbWEuaXRlbXMsIHJvb3RTY2hlbWEpO1xuICAgICAgICByZXR1cm4gaXRlbXNTY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiYgaXRlbXNTY2hlbWEuZm9ybWF0ID09PSAnZGF0YS11cmwnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0ZpbGVzQXJyYXkuanMubWFwIiwiaW1wb3J0IGlzU2VsZWN0IGZyb20gJy4vaXNTZWxlY3QnO1xuLyoqIENoZWNrcyB0byBzZWUgaWYgdGhlIGBzY2hlbWFgIGNvbWJpbmF0aW9uIHJlcHJlc2VudHMgYSBtdWx0aS1zZWxlY3RcbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBuZWNlc3NhcnlcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCBjaGVjayBmb3IgYSBtdWx0aS1zZWxlY3QgZmxhZyBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gW3Jvb3RTY2hlbWFdIC0gVGhlIHJvb3Qgc2NoZW1hLCB1c2VkIHRvIHByaW1hcmlseSB0byBsb29rIHVwIGAkcmVmYHNcbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBzY2hlbWEgY29udGFpbnMgYSBtdWx0aS1zZWxlY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc011bHRpU2VsZWN0KHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hKSB7XG4gICAgaWYgKCFzY2hlbWEudW5pcXVlSXRlbXMgfHwgIXNjaGVtYS5pdGVtcyB8fCB0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNTZWxlY3QodmFsaWRhdG9yLCBzY2hlbWEuaXRlbXMsIHJvb3RTY2hlbWEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNdWx0aVNlbGVjdC5qcy5tYXAiLCJpbXBvcnQgaXNDb25zdGFudCBmcm9tICcuLi9pc0NvbnN0YW50JztcbmltcG9ydCByZXRyaWV2ZVNjaGVtYSBmcm9tICcuL3JldHJpZXZlU2NoZW1hJztcbi8qKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBgc2NoZW1hYCBjb21iaW5hdGlvbiByZXByZXNlbnRzIGEgc2VsZWN0XG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gdGhlU2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggY2hlY2sgZm9yIGEgc2VsZWN0IGZsYWcgaXMgZGVzaXJlZFxuICogQHBhcmFtIFtyb290U2NoZW1hXSAtIFRoZSByb290IHNjaGVtYSwgdXNlZCB0byBwcmltYXJpbHkgdG8gbG9vayB1cCBgJHJlZmBzXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgc2NoZW1hIGNvbnRhaW5zIGEgc2VsZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTZWxlY3QodmFsaWRhdG9yLCB0aGVTY2hlbWEsIHJvb3RTY2hlbWEgPSB7fSkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHZhbGlkYXRvciwgdGhlU2NoZW1hLCByb290U2NoZW1hLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGFsdFNjaGVtYXMgPSBzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWx0U2NoZW1hcykpIHtcbiAgICAgICAgcmV0dXJuIGFsdFNjaGVtYXMuZXZlcnkoKGFsdFNjaGVtYXMpID0+IHR5cGVvZiBhbHRTY2hlbWFzICE9PSAnYm9vbGVhbicgJiYgaXNDb25zdGFudChhbHRTY2hlbWFzKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2VsZWN0LmpzLm1hcCIsImltcG9ydCBpc0VtcHR5IGZyb20gJ2xvZGFzaC9pc0VtcHR5JztcbmltcG9ydCBtZXJnZU9iamVjdHMgZnJvbSAnLi4vbWVyZ2VPYmplY3RzJztcbi8qKiBNZXJnZXMgdGhlIGVycm9ycyBpbiBgYWRkaXRpb25hbEVycm9yU2NoZW1hYCBpbnRvIHRoZSBleGlzdGluZyBgdmFsaWRhdGlvbkRhdGFgIGJ5IGNvbWJpbmluZyB0aGUgaGllcmFyY2hpZXMgaW4gdGhlXG4gKiB0d28gYEVycm9yU2NoZW1hYHMgYW5kIHRoZW4gYXBwZW5kaW5nIHRoZSBlcnJvciBsaXN0IGZyb20gdGhlIGBhZGRpdGlvbmFsRXJyb3JTY2hlbWFgIG9idGFpbmVkIGJ5IGNhbGxpbmdcbiAqIGB2YWxpZGF0b3IudG9FcnJvckxpc3QoKWAgb250byB0aGUgYGVycm9yc2AgaW4gdGhlIGB2YWxpZGF0aW9uRGF0YWAuIElmIG5vIGBhZGRpdGlvbmFsRXJyb3JTY2hlbWFgIGlzIHBhc3NlZCwgdGhlblxuICogYHZhbGlkYXRpb25EYXRhYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gVGhlIHZhbGlkYXRvciB1c2VkIHRvIGNvbnZlcnQgYW4gRXJyb3JTY2hlbWEgdG8gYSBsaXN0IG9mIGVycm9yc1xuICogQHBhcmFtIHZhbGlkYXRpb25EYXRhIC0gVGhlIGN1cnJlbnQgYFZhbGlkYXRpb25EYXRhYCBpbnRvIHdoaWNoIHRvIG1lcmdlIHRoZSBhZGRpdGlvbmFsIGVycm9yc1xuICogQHBhcmFtIFthZGRpdGlvbmFsRXJyb3JTY2hlbWFdIC0gVGhlIGFkZGl0aW9uYWwgc2V0IG9mIGVycm9ycyBpbiBhbiBgRXJyb3JTY2hlbWFgXG4gKiBAcmV0dXJucyAtIFRoZSBgdmFsaWRhdGlvbkRhdGFgIHdpdGggdGhlIGFkZGl0aW9uYWwgZXJyb3JzIGZyb20gYGFkZGl0aW9uYWxFcnJvclNjaGVtYWAgbWVyZ2VkIGludG8gaXQsIGlmIHByb3ZpZGVkLlxuICogQGRlcHJlY2F0ZWQgLSBVc2UgdGhlIGB2YWxpZGF0aW9uRGF0YU1lcmdlKClgIGZ1bmN0aW9uIGV4cG9ydGVkIGZyb20gYEByanNmL3V0aWxzYCBpbnN0ZWFkLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmVcbiAqICAgICAgICByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlVmFsaWRhdGlvbkRhdGEodmFsaWRhdG9yLCB2YWxpZGF0aW9uRGF0YSwgYWRkaXRpb25hbEVycm9yU2NoZW1hKSB7XG4gICAgaWYgKCFhZGRpdGlvbmFsRXJyb3JTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25EYXRhO1xuICAgIH1cbiAgICBjb25zdCB7IGVycm9yczogb2xkRXJyb3JzLCBlcnJvclNjaGVtYTogb2xkRXJyb3JTY2hlbWEgfSA9IHZhbGlkYXRpb25EYXRhO1xuICAgIGxldCBlcnJvcnMgPSB2YWxpZGF0b3IudG9FcnJvckxpc3QoYWRkaXRpb25hbEVycm9yU2NoZW1hKTtcbiAgICBsZXQgZXJyb3JTY2hlbWEgPSBhZGRpdGlvbmFsRXJyb3JTY2hlbWE7XG4gICAgaWYgKCFpc0VtcHR5KG9sZEVycm9yU2NoZW1hKSkge1xuICAgICAgICBlcnJvclNjaGVtYSA9IG1lcmdlT2JqZWN0cyhvbGRFcnJvclNjaGVtYSwgYWRkaXRpb25hbEVycm9yU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgZXJyb3JzID0gWy4uLm9sZEVycm9yc10uY29uY2F0KGVycm9ycyk7XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yU2NoZW1hLCBlcnJvcnMgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlVmFsaWRhdGlvbkRhdGEuanMubWFwIiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCBzZXQgZnJvbSAnbG9kYXNoL3NldCc7XG5pbXBvcnQgdGltZXMgZnJvbSAnbG9kYXNoL3RpbWVzJztcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSAnbG9kYXNoL3RyYW5zZm9ybSc7XG5pbXBvcnQgbWVyZ2VBbGxPZiBmcm9tICdqc29uLXNjaGVtYS1tZXJnZS1hbGxvZic7XG5pbXBvcnQgeyBBRERJVElPTkFMX1BST1BFUlRJRVNfS0VZLCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcsIEFMTF9PRl9LRVksIEFOWV9PRl9LRVksIERFUEVOREVOQ0lFU19LRVksIElGX0tFWSwgT05FX09GX0tFWSwgUkVGX0tFWSwgUFJPUEVSVElFU19LRVksIElURU1TX0tFWSwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IGZpbmRTY2hlbWFEZWZpbml0aW9uLCB7IHNwbGl0S2V5RWxlbWVudEZyb21PYmplY3QgfSBmcm9tICcuLi9maW5kU2NoZW1hRGVmaW5pdGlvbic7XG5pbXBvcnQgZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYSBmcm9tICcuLi9nZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hJztcbmltcG9ydCBndWVzc1R5cGUgZnJvbSAnLi4vZ3Vlc3NUeXBlJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuLi9pc09iamVjdCc7XG5pbXBvcnQgbWVyZ2VTY2hlbWFzIGZyb20gJy4uL21lcmdlU2NoZW1hcyc7XG5pbXBvcnQgZ2V0Rmlyc3RNYXRjaGluZ09wdGlvbiBmcm9tICcuL2dldEZpcnN0TWF0Y2hpbmdPcHRpb24nO1xuLyoqIFJldHJpZXZlcyBhbiBleHBhbmRlZCBzY2hlbWEgdGhhdCBoYXMgaGFkIGFsbCBvZiBpdHMgY29uZGl0aW9ucywgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCByZWZlcmVuY2VzIGFuZCBkZXBlbmRlbmNpZXNcbiAqIHJlc29sdmVkIGFuZCBtZXJnZWQgaW50byB0aGUgYHNjaGVtYWAgZ2l2ZW4gYSBgdmFsaWRhdG9yYCwgYHJvb3RTY2hlbWFgIGFuZCBgcmF3Rm9ybURhdGFgIHRoYXQgaXMgdXNlZCB0byBkbyB0aGVcbiAqIHBvdGVudGlhbGx5IHJlY3Vyc2l2ZSByZXNvbHV0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHJldHJpZXZpbmcgYSBzY2hlbWEgaXMgZGVzaXJlZFxuICogQHBhcmFtIFtyb290U2NoZW1hPXt9XSAtIFRoZSByb290IHNjaGVtYSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIFtyYXdGb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHJldHVybnMgLSBUaGUgc2NoZW1hIGhhdmluZyBpdHMgY29uZGl0aW9ucywgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCByZWZlcmVuY2VzIGFuZCBkZXBlbmRlbmNpZXMgcmVzb2x2ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmV0cmlldmVTY2hlbWEodmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEgPSB7fSwgcmF3Rm9ybURhdGEpIHtcbiAgICByZXR1cm4gcmV0cmlldmVTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIHNjaGVtYSwgcm9vdFNjaGVtYSwgcmF3Rm9ybURhdGEpWzBdO1xufVxuLyoqIFJlc29sdmVzIGEgY29uZGl0aW9uYWwgYmxvY2sgKGlmL2Vsc2UvdGhlbikgYnkgcmVtb3ZpbmcgdGhlIGNvbmRpdGlvbiBhbmQgbWVyZ2luZyB0aGUgYXBwcm9wcmlhdGUgY29uZGl0aW9uYWwgYnJhbmNoXG4gKiB3aXRoIHRoZSByZXN0IG9mIHRoZSBzY2hlbWEuIElmIGBleHBhbmRBbGxCcmFuY2hlc2AgaXMgdHJ1ZSwgdGhlbiB0aGUgYHJldHJpZXZlU2NoZW1hSW50ZXJhbCgpYCByZXN1bHRzIGZvciBib3RoXG4gKiBjb25kaXRpb25zIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgaXMgdXNlZCB0byBkZXRlY3QgdmFsaWQgc2NoZW1hIGNvbmRpdGlvbnNcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCByZXNvbHZpbmcgYSBjb25kaXRpb24gaXMgZGVzaXJlZFxuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgdGhlIEFQSXNcbiAqIEBwYXJhbSBleHBhbmRBbGxCcmFuY2hlcyAtIEZsYWcsIGlmIHRydWUsIHdpbGwgcmV0dXJuIGFsbCBwb3NzaWJsZSBicmFuY2hlcyBvZiBjb25kaXRpb25zLCBhbnkvb25lT2YgYW5kXG4gKiAgICAgICAgICBkZXBlbmRlbmNpZXMgYXMgYSBsaXN0IG9mIHNjaGVtYXNcbiAqIEBwYXJhbSByZWN1cnNlTGlzdCAtIFRoZSBsaXN0IG9mIHJlY3Vyc2l2ZSByZWZlcmVuY2VzIGFscmVhZHkgcHJvY2Vzc2VkXG4gKiBAcGFyYW0gW2Zvcm1EYXRhXSAtIFRoZSBjdXJyZW50IGZvcm1EYXRhIHRvIGFzc2lzdCByZXRyaWV2aW5nIGEgc2NoZW1hXG4gKiBAcmV0dXJucyAtIEEgbGlzdCBvZiBzY2hlbWFzIHdpdGggdGhlIGFwcHJvcHJpYXRlIGNvbmRpdGlvbnMgcmVzb2x2ZWQsIHBvc3NpYmx5IHdpdGggYWxsIGJyYW5jaGVzIGV4cGFuZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29uZGl0aW9uKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKSB7XG4gICAgY29uc3QgeyBpZjogZXhwcmVzc2lvbiwgdGhlbiwgZWxzZTogb3RoZXJ3aXNlLCAuLi5yZXNvbHZlZFNjaGVtYUxlc3NDb25kaXRpb25hbCB9ID0gc2NoZW1hO1xuICAgIGNvbnN0IGNvbmRpdGlvblZhbHVlID0gdmFsaWRhdG9yLmlzVmFsaWQoZXhwcmVzc2lvbiwgZm9ybURhdGEgfHwge30sIHJvb3RTY2hlbWEpO1xuICAgIGxldCByZXNvbHZlZFNjaGVtYXMgPSBbcmVzb2x2ZWRTY2hlbWFMZXNzQ29uZGl0aW9uYWxdO1xuICAgIGxldCBzY2hlbWFzID0gW107XG4gICAgaWYgKGV4cGFuZEFsbEJyYW5jaGVzKSB7XG4gICAgICAgIGlmICh0aGVuICYmIHR5cGVvZiB0aGVuICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHNjaGVtYXMgPSBzY2hlbWFzLmNvbmNhdChyZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgdGhlbiwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcndpc2UgJiYgdHlwZW9mIG90aGVyd2lzZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzY2hlbWFzID0gc2NoZW1hcy5jb25jYXQocmV0cmlldmVTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIG90aGVyd2lzZSwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjb25kaXRpb25hbFNjaGVtYSA9IGNvbmRpdGlvblZhbHVlID8gdGhlbiA6IG90aGVyd2lzZTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsU2NoZW1hICYmIHR5cGVvZiBjb25kaXRpb25hbFNjaGVtYSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzY2hlbWFzID0gc2NoZW1hcy5jb25jYXQocmV0cmlldmVTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIGNvbmRpdGlvbmFsU2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmVkU2NoZW1hcyA9IHNjaGVtYXMubWFwKChzKSA9PiBtZXJnZVNjaGVtYXMocmVzb2x2ZWRTY2hlbWFMZXNzQ29uZGl0aW9uYWwsIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hcy5mbGF0TWFwKChzKSA9PiByZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgcywgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCkpO1xufVxuLyoqIEdpdmVuIGEgbGlzdCBvZiBsaXN0cyBvZiBhbGxPZiwgYW55T2Ygb3Igb25lT2YgdmFsdWVzLCBjcmVhdGUgYSBsaXN0IG9mIGxpc3RzIG9mIGFsbCBwZXJtdXRhdGlvbnMgb2YgdGhlIHZhbHVlcy4gVGhlXG4gKiBgbGlzdE9mTGlzdHNgIGlzIGV4cGVjdGVkIHRvIGJlIGFsbCByZXNvbHZlZCB2YWx1ZXMgb2YgdGhlIDFzdC4uLm50aCBzY2hlbWFzIHdpdGhpbiBhbiBgYWxsT2ZgLCBgYW55T2ZgIG9yIGBvbmVPZmAuXG4gKiBGcm9tIHRob3NlIGxpc3RzLCBidWlsZCBhIG1hdHJpeCBmb3IgZWFjaCBgeHh4T2ZgIHdoZXJlIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgc2NoZW1hIGZvciBhIHJvdyBpbiB0aGUgbGlzdCBvZiBsaXN0cy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIC0gSWYgdGhlcmUgYXJlIHRocmVlIHh4eE9mIHJvd3MgKEEsIEIsIEMpIGFuZCB0aGV5IGhhdmUgYmVlbiByZXNvbHZlZCBzdWNoIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgQSwgdHdvIEIgYW5kIHRocmVlXG4gKiAgIEMgc2NoZW1hcyB0aGVuOlxuICogICAtIFRoZSBwZXJtdXRhdGlvbiBmb3IgdGhlIGZpcnN0IHJvdyBpcyBgW1tBXV1gXG4gKiAgIC0gVGhlIHBlcm11dGF0aW9ucyBmb3IgdGhlIHNlY29uZCByb3cgYXJlIGBbW0EsQjFdLCBbQSxCMl1dYFxuICogICAtIFRoZSBwZXJtdXRhdGlvbnMgZm9yIHRoZSB0aGlyZCByb3cgYXJlIGBbW0EsQjEsQzFdLCBbQSxCMSxDMl0sIFtBLEIxLEMzXSwgW0EsQjIsQzFdLCBbQSxCMixDMl0sIFtBLEIyLEMzXV1gXG4gKlxuICogQHBhcmFtIGxpc3RPZkxpc3RzIC0gVGhlIGxpc3Qgb2YgbGlzdHMgb2YgZWxlbWVudHMgdGhhdCByZXByZXNlbnQgdGhlIGFsbE9mLCBhbnlPZiBvciBvbmVPZiByZXNvbHZlZCB2YWx1ZXMgaW4gb3JkZXJcbiAqIEByZXR1cm5zIC0gVGhlIGxpc3Qgb2YgYWxsIHBlcm11dGF0aW9ucyBvZiBzY2hlbWFzIGZvciBhIHNldCBvZiBgeHh4T2Zgc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsUGVybXV0YXRpb25zT2ZYeHhPZihsaXN0T2ZMaXN0cykge1xuICAgIGNvbnN0IGFsbFBlcm11dGF0aW9ucyA9IGxpc3RPZkxpc3RzLnJlZHVjZSgocGVybXV0YXRpb25zLCBsaXN0KSA9PiB7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgc2V0IG9mIHNjaGVtYXMgZm9yIGEgcm93LCBkdXBsaWNhdGUgdGhlIHNldCBvZiBwZXJtdXRhdGlvbnMgYW5kIGFkZCBpbiB0aGUgdmFsdWVzXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmZsYXRNYXAoKGVsZW1lbnQpID0+IHRpbWVzKHBlcm11dGF0aW9ucy5sZW5ndGgsIChpKSA9PiBbLi4ucGVybXV0YXRpb25zW2ldXS5jb25jYXQoZWxlbWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBwdXNoIGluIHRoZSBzaW5nbGUgdmFsdWUgaW50byB0aGUgY3VycmVudCBzZXQgb2YgcGVybXV0YXRpb25zXG4gICAgICAgIHBlcm11dGF0aW9ucy5mb3JFYWNoKChwZXJtdXRhdGlvbikgPT4gcGVybXV0YXRpb24ucHVzaChsaXN0WzBdKSk7XG4gICAgICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XG4gICAgfSwgW1tdXSAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IGxpc3RcbiAgICApO1xuICAgIHJldHVybiBhbGxQZXJtdXRhdGlvbnM7XG59XG4vKiogUmVzb2x2ZXMgcmVmZXJlbmNlcyBhbmQgZGVwZW5kZW5jaWVzIHdpdGhpbiBhIHNjaGVtYSBhbmQgaXRzICdhbGxPZicgY2hpbGRyZW4uIFBhc3NlcyB0aGUgYGV4cGFuZEFsbEJyYW5jaGVzYCBmbGFnXG4gKiBkb3duIHRvIHRoZSBgcmV0cmlldmVTY2hlbWFJbnRlcm5hbCgpYCwgYHJlc29sdmVSZWZlcmVuY2UoKWAgYW5kIGByZXNvbHZlRGVwZW5kZW5jaWVzKClgIGhlbHBlciBjYWxscy4gSWZcbiAqIGBleHBhbmRBbGxCcmFuY2hlc2AgaXMgdHJ1ZSwgdGhlbiBhbGwgcG9zc2libGUgZGVwZW5kZW5jaWVzIGFuZC9vciBhbGxPZiBicmFuY2hlcyBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIHRoZSBBUElzXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggcmVzb2x2aW5nIGEgc2NoZW1hIGlzIGRlc2lyZWRcbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIHRoZSBBUElzXG4gKiBAcGFyYW0gZXhwYW5kQWxsQnJhbmNoZXMgLSBGbGFnLCBpZiB0cnVlLCB3aWxsIHJldHVybiBhbGwgcG9zc2libGUgYnJhbmNoZXMgb2YgY29uZGl0aW9ucywgYW55L29uZU9mIGFuZCBkZXBlbmRlbmNpZXNcbiAqICAgICAgICAgIGFzIGEgbGlzdCBvZiBzY2hlbWFzXG4gKiBAcGFyYW0gcmVjdXJzZUxpc3QgLSBUaGUgbGlzdCBvZiByZWN1cnNpdmUgcmVmZXJlbmNlcyBhbHJlYWR5IHByb2Nlc3NlZFxuICogQHBhcmFtIFtmb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHJldHVybnMgLSBUaGUgbGlzdCBvZiBzY2hlbWFzIGhhdmluZyBpdHMgcmVmZXJlbmNlcywgZGVwZW5kZW5jaWVzIGFuZCBhbGxPZiBzY2hlbWFzIHJlc29sdmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKSB7XG4gICAgY29uc3QgdXBkYXRlZFNjaGVtYXMgPSByZXNvbHZlUmVmZXJlbmNlKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKTtcbiAgICBpZiAodXBkYXRlZFNjaGVtYXMubGVuZ3RoID4gMSB8fCB1cGRhdGVkU2NoZW1hc1swXSAhPT0gc2NoZW1hKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgdXBkYXRlZFNjaGVtYXMgYXJyYXkgaWYgaXQgaGFzIGVpdGhlciBtdWx0aXBsZSBzY2hlbWFzIHdpdGhpbiBpdFxuICAgICAgICAvLyBPUiB0aGUgZmlyc3Qgc2NoZW1hIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luYWwgc2NoZW1hXG4gICAgICAgIHJldHVybiB1cGRhdGVkU2NoZW1hcztcbiAgICB9XG4gICAgaWYgKERFUEVOREVOQ0lFU19LRVkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hcyA9IHJlc29sdmVEZXBlbmRlbmNpZXModmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCwgZm9ybURhdGEpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWFzLmZsYXRNYXAoKHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgcywgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoQUxMX09GX0tFWSBpbiBzY2hlbWEgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgIGNvbnN0IGFsbE9mU2NoZW1hRWxlbWVudHMgPSBzY2hlbWEuYWxsT2YubWFwKChhbGxPZlN1YnNjaGVtYSkgPT4gcmV0cmlldmVTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIGFsbE9mU3Vic2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0KSk7XG4gICAgICAgIGNvbnN0IGFsbFBlcm11dGF0aW9ucyA9IGdldEFsbFBlcm11dGF0aW9uc09mWHh4T2YoYWxsT2ZTY2hlbWFFbGVtZW50cyk7XG4gICAgICAgIHJldHVybiBhbGxQZXJtdXRhdGlvbnMubWFwKChwZXJtdXRhdGlvbikgPT4gKHsgLi4uc2NoZW1hLCBhbGxPZjogcGVybXV0YXRpb24gfSkpO1xuICAgIH1cbiAgICAvLyBObyAkcmVmIG9yIGRlcGVuZGVuY2llcyBvciBhbGxPZiBhdHRyaWJ1dGUgd2FzIGZvdW5kLCByZXR1cm5pbmcgdGhlIG9yaWdpbmFsIHNjaGVtYS5cbiAgICByZXR1cm4gW3NjaGVtYV07XG59XG4vKiogUmVzb2x2ZXMgYWxsIHJlZmVyZW5jZXMgd2l0aGluIGEgc2NoZW1hIGFuZCB0aGVuIHJldHVybnMgdGhlIGByZXRyaWV2ZVNjaGVtYUludGVybmFsKClgIGlmIHRoZSByZXNvbHZlZCBzY2hlbWEgaXNcbiAqIGFjdHVhbGx5IGRpZmZlcmVudCB0aGFuIHRoZSBvcmlnaW5hbC4gUGFzc2VzIHRoZSBgZXhwYW5kQWxsQnJhbmNoZXNgIGZsYWcgZG93biB0byB0aGUgYHJldHJpZXZlU2NoZW1hSW50ZXJuYWwoKWBcbiAqIGhlbHBlciBjYWxsLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHJlc29sdmluZyBhIHJlZmVyZW5jZSBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIGV4cGFuZEFsbEJyYW5jaGVzIC0gRmxhZywgaWYgdHJ1ZSwgd2lsbCByZXR1cm4gYWxsIHBvc3NpYmxlIGJyYW5jaGVzIG9mIGNvbmRpdGlvbnMsIGFueS9vbmVPZiBhbmQgZGVwZW5kZW5jaWVzXG4gKiAgICAgICAgICBhcyBhIGxpc3Qgb2Ygc2NoZW1hc1xuICogQHBhcmFtIHJlY3Vyc2VMaXN0IC0gVGhlIGxpc3Qgb2YgcmVjdXJzaXZlIHJlZmVyZW5jZXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgdG8gYXNzaXN0IHJldHJpZXZpbmcgYSBzY2hlbWFcbiAqIEByZXR1cm5zIC0gVGhlIGxpc3Qgc2NoZW1hcyByZXRyaWV2ZWQgYWZ0ZXIgaGF2aW5nIGFsbCByZWZlcmVuY2VzIHJlc29sdmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUmVmZXJlbmNlKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKSB7XG4gICAgY29uc3QgdXBkYXRlZFNjaGVtYSA9IHJlc29sdmVBbGxSZWZlcmVuY2VzKHNjaGVtYSwgcm9vdFNjaGVtYSwgcmVjdXJzZUxpc3QpO1xuICAgIGlmICh1cGRhdGVkU2NoZW1hICE9PSBzY2hlbWEpIHtcbiAgICAgICAgLy8gT25seSBjYWxsIHRoaXMgaWYgdGhlIHNjaGVtYSB3YXMgYWN0dWFsbHkgY2hhbmdlZCBieSB0aGUgYHJlc29sdmVBbGxSZWZlcmVuY2VzKClgIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiByZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgdXBkYXRlZFNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBbc2NoZW1hXTtcbn1cbi8qKiBSZXNvbHZlcyBhbGwgcmVmZXJlbmNlcyB3aXRoaW4gdGhlIHNjaGVtYSBpdHNlbGYgYXMgd2VsbCBhcyBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYW5kIGFycmF5IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCByZXNvbHZpbmcgYWxsIHJlZmVyZW5jZXMgaXMgZGVzaXJlZFxuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgdGhlIEFQSXNcbiAqIEBwYXJhbSByZWN1cnNlTGlzdCAtIExpc3Qgb2YgJHJlZnMgYWxyZWFkeSByZXNvbHZlZCB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICogQHJldHVybnMgLSBnaXZlbiBzY2hlbWEgd2lsbCBhbGwgcmVmZXJlbmNlcyByZXNvbHZlZCBvciB0aGUgb3JpZ2luYWwgc2NoZW1hIGlmIG5vIGludGVybmFsIGAkcmVmc2Agd2VyZSByZXNvbHZlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFsbFJlZmVyZW5jZXMoc2NoZW1hLCByb290U2NoZW1hLCByZWN1cnNlTGlzdCkge1xuICAgIGlmICghaXNPYmplY3Qoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSBzY2hlbWE7XG4gICAgLy8gcmVzb2x2ZSB0b3AgbGV2ZWwgcmVmXG4gICAgaWYgKFJFRl9LRVkgaW4gcmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgeyAkcmVmLCAuLi5sb2NhbFNjaGVtYSB9ID0gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgIC8vIENoZWNrIGZvciBhIHJlY3Vyc2l2ZSByZWZlcmVuY2UgYW5kIHN0b3AgdGhlIGxvb3BcbiAgICAgICAgaWYgKHJlY3Vyc2VMaXN0LmluY2x1ZGVzKCRyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdXJzZUxpc3QucHVzaCgkcmVmKTtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlZmVyZW5jZWQgc2NoZW1hIGRlZmluaXRpb24uXG4gICAgICAgIGNvbnN0IHJlZlNjaGVtYSA9IGZpbmRTY2hlbWFEZWZpbml0aW9uKCRyZWYsIHJvb3RTY2hlbWEpO1xuICAgICAgICByZXNvbHZlZFNjaGVtYSA9IHsgLi4ucmVmU2NoZW1hLCAuLi5sb2NhbFNjaGVtYSB9O1xuICAgIH1cbiAgICBpZiAoUFJPUEVSVElFU19LRVkgaW4gcmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFByb3BzID0gdHJhbnNmb3JtKHJlc29sdmVkU2NoZW1hW1BST1BFUlRJRVNfS0VZXSwgKHJlc3VsdCwgdmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXNvbHZlQWxsUmVmZXJlbmNlcyh2YWx1ZSwgcm9vdFNjaGVtYSwgcmVjdXJzZUxpc3QpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJlc29sdmVkU2NoZW1hID0geyAuLi5yZXNvbHZlZFNjaGVtYSwgW1BST1BFUlRJRVNfS0VZXTogdXBkYXRlZFByb3BzIH07XG4gICAgfVxuICAgIGlmIChJVEVNU19LRVkgaW4gcmVzb2x2ZWRTY2hlbWEgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkocmVzb2x2ZWRTY2hlbWEuaXRlbXMpICYmXG4gICAgICAgIHR5cGVvZiByZXNvbHZlZFNjaGVtYS5pdGVtcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJlc29sdmVkU2NoZW1hID0ge1xuICAgICAgICAgICAgLi4ucmVzb2x2ZWRTY2hlbWEsXG4gICAgICAgICAgICBpdGVtczogcmVzb2x2ZUFsbFJlZmVyZW5jZXMocmVzb2x2ZWRTY2hlbWEuaXRlbXMsIHJvb3RTY2hlbWEsIHJlY3Vyc2VMaXN0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRXF1YWwoc2NoZW1hLCByZXNvbHZlZFNjaGVtYSkgPyBzY2hlbWEgOiByZXNvbHZlZFNjaGVtYTtcbn1cbi8qKiBDcmVhdGVzIG5ldyAncHJvcGVydGllcycgaXRlbXMgZm9yIGVhY2gga2V5IGluIHRoZSBgZm9ybURhdGFgXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gdGhlU2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIGV4aXN0aW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gW3Jvb3RTY2hlbWFdIC0gVGhlIHJvb3Qgc2NoZW1hLCB1c2VkIHRvIHByaW1hcmlseSB0byBsb29rIHVwIGAkcmVmYHMgKiBAcGFyYW0gdmFsaWRhdG9yXG4gKiBAcGFyYW0gW2FGb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHJldHVybnMgLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgc3R1YmJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3R1YkV4aXN0aW5nQWRkaXRpb25hbFByb3BlcnRpZXModmFsaWRhdG9yLCB0aGVTY2hlbWEsIHJvb3RTY2hlbWEsIGFGb3JtRGF0YSkge1xuICAgIC8vIENsb25lIHRoZSBzY2hlbWEgc28gdGhhdCB3ZSBkb24ndCBydWluIHRoZSBjb25zdW1lcidzIG9yaWdpbmFsXG4gICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICAuLi50aGVTY2hlbWEsXG4gICAgICAgIHByb3BlcnRpZXM6IHsgLi4udGhlU2NoZW1hLnByb3BlcnRpZXMgfSxcbiAgICB9O1xuICAgIC8vIG1ha2Ugc3VyZSBmb3JtRGF0YSBpcyBhbiBvYmplY3RcbiAgICBjb25zdCBmb3JtRGF0YSA9IGFGb3JtRGF0YSAmJiBpc09iamVjdChhRm9ybURhdGEpID8gYUZvcm1EYXRhIDoge307XG4gICAgT2JqZWN0LmtleXMoZm9ybURhdGEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoa2V5IGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN0dWIsIG91ciBzY2hlbWEgYWxyZWFkeSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChSRUZfS0VZIGluIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcmV0cmlldmVTY2hlbWEodmFsaWRhdG9yLCB7ICRyZWY6IGdldChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIFtSRUZfS0VZXSkgfSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3R5cGUnIGluIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0geyAuLi5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFOWV9PRl9LRVkgaW4gc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzIHx8IE9ORV9PRl9LRVkgaW4gc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAuLi5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0geyB0eXBlOiBndWVzc1R5cGUoZ2V0KGZvcm1EYXRhLCBba2V5XSkpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHsgdHlwZTogZ3Vlc3NUeXBlKGdldChmb3JtRGF0YSwgW2tleV0pKSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSB0eXBlIG9mIG91ciBuZXcga2V5IHNob3VsZCBtYXRjaCB0aGUgYWRkaXRpb25hbFByb3BlcnRpZXMgdmFsdWU7XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0gPSBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgLy8gU2V0IG91ciBhZGRpdGlvbmFsIHByb3BlcnR5IGZsYWcgc28gd2Uga25vdyBpdCB3YXMgZHluYW1pY2FsbHkgYWRkZWRcbiAgICAgICAgc2V0KHNjaGVtYS5wcm9wZXJ0aWVzLCBba2V5LCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUddLCB0cnVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuLyoqIEludGVybmFsIGhhbmRsZXIgdGhhdCByZXRyaWV2ZXMgYW4gZXhwYW5kZWQgc2NoZW1hIHRoYXQgaGFzIGhhZCBhbGwgb2YgaXRzIGNvbmRpdGlvbnMsIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAqIHJlZmVyZW5jZXMgYW5kIGRlcGVuZGVuY2llcyByZXNvbHZlZCBhbmQgbWVyZ2VkIGludG8gdGhlIGBzY2hlbWFgIGdpdmVuIGEgYHZhbGlkYXRvcmAsIGByb290U2NoZW1hYCBhbmQgYHJhd0Zvcm1EYXRhYFxuICogdGhhdCBpcyB1c2VkIHRvIGRvIHRoZSBwb3RlbnRpYWxseSByZWN1cnNpdmUgcmVzb2x1dGlvbi4gSWYgYGV4cGFuZEFsbEJyYW5jaGVzYCBpcyB0cnVlLCB0aGVuIGFsbCBwb3NzaWJsZSBicmFuY2hlc1xuICogb2YgdGhlIHNjaGVtYSBhbmQgaXRzIHJlZmVyZW5jZXMsIGNvbmRpdGlvbnMgYW5kIGRlcGVuZGVuY2llcyBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIHRoZSBBUElzXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggcmV0cmlldmluZyBhIHNjaGVtYSBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIFtyYXdGb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHBhcmFtIFtleHBhbmRBbGxCcmFuY2hlcz1mYWxzZV0gLSBGbGFnLCBpZiB0cnVlLCB3aWxsIHJldHVybiBhbGwgcG9zc2libGUgYnJhbmNoZXMgb2YgY29uZGl0aW9ucywgYW55L29uZU9mIGFuZFxuICogICAgICAgICAgZGVwZW5kZW5jaWVzIGFzIGEgbGlzdCBvZiBzY2hlbWFzXG4gKiBAcGFyYW0gW3JlY3Vyc2VMaXN0PVtdXSAtIFRoZSBvcHRpb25hbCwgbGlzdCBvZiByZWN1cnNpdmUgcmVmZXJlbmNlcyBhbHJlYWR5IHByb2Nlc3NlZFxuICogQHJldHVybnMgLSBUaGUgc2NoZW1hKHMpIHJlc3VsdGluZyBmcm9tIGhhdmluZyBpdHMgY29uZGl0aW9ucywgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLCByZWZlcmVuY2VzIGFuZCBkZXBlbmRlbmNpZXNcbiAqICAgICAgICAgIHJlc29sdmVkLiBNdWx0aXBsZSBzY2hlbWFzIG1heSBiZSByZXR1cm5lZCBpZiBgZXhwYW5kQWxsQnJhbmNoZXNgIGlzIHRydWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCByYXdGb3JtRGF0YSwgZXhwYW5kQWxsQnJhbmNoZXMgPSBmYWxzZSwgcmVjdXJzZUxpc3QgPSBbXSkge1xuICAgIGlmICghaXNPYmplY3Qoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gW3t9XTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRTY2hlbWFzID0gcmVzb2x2ZVNjaGVtYSh2YWxpZGF0b3IsIHNjaGVtYSwgcm9vdFNjaGVtYSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0LCByYXdGb3JtRGF0YSk7XG4gICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hcy5mbGF0TWFwKChzKSA9PiB7XG4gICAgICAgIGxldCByZXNvbHZlZFNjaGVtYSA9IHM7XG4gICAgICAgIGlmIChJRl9LRVkgaW4gcmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlQ29uZGl0aW9uKHZhbGlkYXRvciwgcmVzb2x2ZWRTY2hlbWEsIHJvb3RTY2hlbWEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCwgcmF3Rm9ybURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBTExfT0ZfS0VZIGluIHJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICAvLyByZXNvbHZlIGFsbE9mIHNjaGVtYXNcbiAgICAgICAgICAgIGlmIChleHBhbmRBbGxCcmFuY2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWxsT2YsIC4uLnJlc3RPZlNjaGVtYSB9ID0gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hbGxPZiwgcmVzdE9mU2NoZW1hXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZUFsbE9mKHJlc29sdmVkU2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlZXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NvdWxkIG5vdCBtZXJnZSBzdWJzY2hlbWFzIGluIGFsbE9mOlxcbicsIGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWxsT2YsIC4uLnJlc29sdmVkU2NoZW1hV2l0aG91dEFsbE9mIH0gPSByZXNvbHZlZFNjaGVtYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWFXaXRob3V0QWxsT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzQWRkaXRpb25hbFByb3BlcnRpZXMgPSBBRERJVElPTkFMX1BST1BFUlRJRVNfS0VZIGluIHJlc29sdmVkU2NoZW1hICYmIHJlc29sdmVkU2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKGhhc0FkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R1YkV4aXN0aW5nQWRkaXRpb25hbFByb3BlcnRpZXModmFsaWRhdG9yLCByZXNvbHZlZFNjaGVtYSwgcm9vdFNjaGVtYSwgcmF3Rm9ybURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFNjaGVtYTtcbiAgICB9KTtcbn1cbi8qKiBSZXNvbHZlcyBhbiBgYW55T2ZgIG9yIGBvbmVPZmAgd2l0aGluIGEgc2NoZW1hIChpZiBwcmVzZW50KSB0byB0aGUgbGlzdCBvZiBzY2hlbWFzIHJldHVybmVkIGZyb21cbiAqIGByZXRyaWV2ZVNjaGVtYUludGVybmFsKClgIGZvciB0aGUgYmVzdCBtYXRjaGluZyBvcHRpb24uIElmIGBleHBhbmRBbGxCcmFuY2hlc2AgaXMgdHJ1ZSwgdGhlbiBhIGxpc3Qgb2Ygc2NoZW1hcyBmb3IgQUxMXG4gKiBvcHRpb25zIGFyZSByZXRyaWV2ZWQgYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHJldHJpZXZpbmcgYSBzY2hlbWEgaXMgZGVzaXJlZFxuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgdGhlIEFQSXNcbiAqIEBwYXJhbSBleHBhbmRBbGxCcmFuY2hlcyAtIEZsYWcsIGlmIHRydWUsIHdpbGwgcmV0dXJuIGFsbCBwb3NzaWJsZSBicmFuY2hlcyBvZiBjb25kaXRpb25zLCBhbnkvb25lT2YgYW5kIGRlcGVuZGVuY2llc1xuICogICAgICAgICAgYXMgYSBsaXN0IG9mIHNjaGVtYXNcbiAqIEBwYXJhbSBbcmF3Rm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgdG8gYXNzaXN0IHJldHJpZXZpbmcgYSBzY2hlbWEsIGRlZmF1bHRzIHRvIGFuIGVtcHR5IG9iamVjdFxuICogQHJldHVybnMgLSBFaXRoZXIgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYmVzdCBtYXRjaGluZyBvcHRpb24gb3IgYWxsIG9wdGlvbnMgaWYgYGV4cGFuZEFsbEJyYW5jaGVzYCBpcyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQW55T3JPbmVPZlNjaGVtYXModmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIGV4cGFuZEFsbEJyYW5jaGVzLCByYXdGb3JtRGF0YSkge1xuICAgIGxldCBhbnlPck9uZU9mO1xuICAgIGNvbnN0IHsgb25lT2YsIGFueU9mLCAuLi5yZW1haW5pbmcgfSA9IHNjaGVtYTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbmVPZikpIHtcbiAgICAgICAgYW55T3JPbmVPZiA9IG9uZU9mO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFueU9mKSkge1xuICAgICAgICBhbnlPck9uZU9mID0gYW55T2Y7XG4gICAgfVxuICAgIGlmIChhbnlPck9uZU9mKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGR1cmluZyBleHBhbmQgYWxsIGJyYW5jaGVzIHdlIHBhc3MgYW4gb2JqZWN0IHJhdGhlciB0aGFuIHVuZGVmaW5lZCBzbyB0aGF0IGFsbCBvcHRpb25zIGFyZSBpbnRlcnJvZ2F0ZWRcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSByYXdGb3JtRGF0YSA9PT0gdW5kZWZpbmVkICYmIGV4cGFuZEFsbEJyYW5jaGVzID8ge30gOiByYXdGb3JtRGF0YTtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldERpc2NyaW1pbmF0b3JGaWVsZEZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgYW55T3JPbmVPZiA9IGFueU9yT25lT2YubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAvLyBEdWUgdG8gYW55T2Yvb25lT2YgcG9zc2libHkgdXNpbmcgdGhlIHNhbWUgJHJlZiB3ZSBhbHdheXMgcGFzcyBhIGZyZXNoIHJlY3Vyc2UgbGlzdCBhcnJheSBzbyB0aGF0IGVhY2ggb3B0aW9uXG4gICAgICAgICAgICAvLyBjYW4gcmVzb2x2ZSByZWN1cnNpdmUgcmVmZXJlbmNlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFsbFJlZmVyZW5jZXMocywgcm9vdFNjaGVtYSwgW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FsbCB0aGlzIHRvIHRyaWdnZXIgdGhlIHNldCBvZiBpc1ZhbGlkKCkgY2FsbHMgdGhhdCB0aGUgc2NoZW1hIHBhcnNlciB3aWxsIG5lZWRcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZ2V0Rmlyc3RNYXRjaGluZ09wdGlvbih2YWxpZGF0b3IsIGZvcm1EYXRhLCBhbnlPck9uZU9mLCByb290U2NoZW1hLCBkaXNjcmltaW5hdG9yKTtcbiAgICAgICAgaWYgKGV4cGFuZEFsbEJyYW5jaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYW55T3JPbmVPZi5tYXAoKGl0ZW0pID0+IG1lcmdlU2NoZW1hcyhyZW1haW5pbmcsIGl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEgPSBtZXJnZVNjaGVtYXMocmVtYWluaW5nLCBhbnlPck9uZU9mW29wdGlvbl0pO1xuICAgIH1cbiAgICByZXR1cm4gW3NjaGVtYV07XG59XG4vKiogUmVzb2x2ZXMgZGVwZW5kZW5jaWVzIHdpdGhpbiBhIHNjaGVtYSBhbmQgaXRzICdhbnlPZi9vbmVPZicgY2hpbGRyZW4uIFBhc3NlcyB0aGUgYGV4cGFuZEFsbEJyYW5jaGVzYCBmbGFnIGRvd24gdG9cbiAqIHRoZSBgcmVzb2x2ZUFueU9yT25lT2ZTY2hlbWEoKWAgYW5kIGBwcm9jZXNzRGVwZW5kZW5jaWVzKClgIGhlbHBlciBjYWxscy5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgdGhlIEFQSXNcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCByZXNvbHZpbmcgYSBkZXBlbmRlbmN5IGlzIGRlc2lyZWRcbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIHRoZSBBUElzXG4gKiBAcGFyYW0gZXhwYW5kQWxsQnJhbmNoZXMgLSBGbGFnLCBpZiB0cnVlLCB3aWxsIHJldHVybiBhbGwgcG9zc2libGUgYnJhbmNoZXMgb2YgY29uZGl0aW9ucywgYW55L29uZU9mIGFuZCBkZXBlbmRlbmNpZXNcbiAqICAgICAgICAgIGFzIGEgbGlzdCBvZiBzY2hlbWFzXG4gKiBAcGFyYW0gcmVjdXJzZUxpc3QgLSBUaGUgbGlzdCBvZiByZWN1cnNpdmUgcmVmZXJlbmNlcyBhbHJlYWR5IHByb2Nlc3NlZFxuICogQHBhcmFtIFtmb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHJldHVybnMgLSBUaGUgbGlzdCBvZiBzY2hlbWFzIHdpdGggdGhlaXIgZGVwZW5kZW5jaWVzIHJlc29sdmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRGVwZW5kZW5jaWVzKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKSB7XG4gICAgLy8gRHJvcCB0aGUgZGVwZW5kZW5jaWVzIGZyb20gdGhlIHNvdXJjZSBzY2hlbWEuXG4gICAgY29uc3QgeyBkZXBlbmRlbmNpZXMsIC4uLnJlbWFpbmluZ1NjaGVtYSB9ID0gc2NoZW1hO1xuICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hcyA9IHJlc29sdmVBbnlPck9uZU9mU2NoZW1hcyh2YWxpZGF0b3IsIHJlbWFpbmluZ1NjaGVtYSwgcm9vdFNjaGVtYSwgZXhwYW5kQWxsQnJhbmNoZXMsIGZvcm1EYXRhKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWFzLmZsYXRNYXAoKHJlc29sdmVkU2NoZW1hKSA9PiBwcm9jZXNzRGVwZW5kZW5jaWVzKHZhbGlkYXRvciwgZGVwZW5kZW5jaWVzLCByZXNvbHZlZFNjaGVtYSwgcm9vdFNjaGVtYSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0LCBmb3JtRGF0YSkpO1xufVxuLyoqIFByb2Nlc3NlcyBhbGwgdGhlIGBkZXBlbmRlbmNpZXNgIHJlY3Vyc2l2ZWx5IGludG8gdGhlIGxpc3Qgb2YgYHJlc29sdmVkU2NoZW1hYHMgYXMgbmVlZGVkLiBQYXNzZXMgdGhlXG4gKiBgZXhwYW5kQWxsQnJhbmNoZXNgIGZsYWcgZG93biB0byB0aGUgYHdpdGhEZXBlbmRlbnRTY2hlbWEoKWAgYW5kIHRoZSByZWN1cnNpdmUgYHByb2Nlc3NEZXBlbmRlbmNpZXMoKWAgaGVscGVyIGNhbGxzLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIGRlcGVuZGVuY2llcyAtIFRoZSBzZXQgb2YgZGVwZW5kZW5jaWVzIHRoYXQgbmVlZHMgdG8gYmUgcHJvY2Vzc2VkXG4gKiBAcGFyYW0gcmVzb2x2ZWRTY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCBwcm9jZXNzaW5nIGRlcGVuZGVuY2llcyBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIGV4cGFuZEFsbEJyYW5jaGVzIC0gRmxhZywgaWYgdHJ1ZSwgd2lsbCByZXR1cm4gYWxsIHBvc3NpYmxlIGJyYW5jaGVzIG9mIGNvbmRpdGlvbnMsIGFueS9vbmVPZiBhbmQgZGVwZW5kZW5jaWVzXG4gKiAgICAgICAgICBhcyBhIGxpc3Qgb2Ygc2NoZW1hc1xuICogQHBhcmFtIHJlY3Vyc2VMaXN0IC0gVGhlIGxpc3Qgb2YgcmVjdXJzaXZlIHJlZmVyZW5jZXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgdG8gYXNzaXN0IHJldHJpZXZpbmcgYSBzY2hlbWFcbiAqIEByZXR1cm5zIC0gVGhlIHNjaGVtYSB3aXRoIHRoZSBgZGVwZW5kZW5jaWVzYCByZXNvbHZlZCBpbnRvIGl0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzRGVwZW5kZW5jaWVzKHZhbGlkYXRvciwgZGVwZW5kZW5jaWVzLCByZXNvbHZlZFNjaGVtYSwgcm9vdFNjaGVtYSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0LCBmb3JtRGF0YSkge1xuICAgIGxldCBzY2hlbWFzID0gW3Jlc29sdmVkU2NoZW1hXTtcbiAgICAvLyBQcm9jZXNzIGRlcGVuZGVuY2llcyB1cGRhdGluZyB0aGUgbG9jYWwgc2NoZW1hIHByb3BlcnRpZXMgYXMgYXBwcm9wcmlhdGUuXG4gICAgZm9yIChjb25zdCBkZXBlbmRlbmN5S2V5IGluIGRlcGVuZGVuY2llcykge1xuICAgICAgICAvLyBTa2lwIHRoaXMgZGVwZW5kZW5jeSBpZiBpdHMgdHJpZ2dlciBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudC5cbiAgICAgICAgaWYgKCFleHBhbmRBbGxCcmFuY2hlcyAmJiBnZXQoZm9ybURhdGEsIFtkZXBlbmRlbmN5S2V5XSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCB0aGlzIGRlcGVuZGVuY3kgaWYgaXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBzY2hlbWEgKHN1Y2ggYXMgd2hlbiBkZXBlbmRlbmN5S2V5IGlzIGl0c2VsZiBhIGhpZGRlbiBkZXBlbmRlbmN5LilcbiAgICAgICAgaWYgKHJlc29sdmVkU2NoZW1hLnByb3BlcnRpZXMgJiYgIShkZXBlbmRlbmN5S2V5IGluIHJlc29sdmVkU2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmVtYWluaW5nRGVwZW5kZW5jaWVzLCBkZXBlbmRlbmN5VmFsdWVdID0gc3BsaXRLZXlFbGVtZW50RnJvbU9iamVjdChkZXBlbmRlbmN5S2V5LCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXBlbmRlbmN5VmFsdWUpKSB7XG4gICAgICAgICAgICBzY2hlbWFzWzBdID0gd2l0aERlcGVuZGVudFByb3BlcnRpZXMocmVzb2x2ZWRTY2hlbWEsIGRlcGVuZGVuY3lWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoZGVwZW5kZW5jeVZhbHVlKSkge1xuICAgICAgICAgICAgc2NoZW1hcyA9IHdpdGhEZXBlbmRlbnRTY2hlbWEodmFsaWRhdG9yLCByZXNvbHZlZFNjaGVtYSwgcm9vdFNjaGVtYSwgZGVwZW5kZW5jeUtleSwgZGVwZW5kZW5jeVZhbHVlLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hcy5mbGF0TWFwKChzY2hlbWEpID0+IHByb2Nlc3NEZXBlbmRlbmNpZXModmFsaWRhdG9yLCByZW1haW5pbmdEZXBlbmRlbmNpZXMsIHNjaGVtYSwgcm9vdFNjaGVtYSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0LCBmb3JtRGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hcztcbn1cbi8qKiBVcGRhdGVzIGEgc2NoZW1hIHdpdGggYWRkaXRpb25hbGx5IHJlcXVpcmVkIHByb3BlcnRpZXMgYWRkZWRcbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggcmVzb2x2aW5nIGEgZGVwZW5kZW50IHByb3BlcnRpZXMgaXMgZGVzaXJlZFxuICogQHBhcmFtIFthZGRpdGlvbmFsbHlSZXF1aXJlZF0gLSBBbiBvcHRpb25hbCBhcnJheSBvZiBhZGRpdGlvbmFsbHkgcmVxdWlyZWQgbmFtZXNcbiAqIEByZXR1cm5zIC0gVGhlIHNjaGVtYSB3aXRoIHRoZSBhZGRpdGlvbmFsIHJlcXVpcmVkIHZhbHVlcyBtZXJnZWQgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhEZXBlbmRlbnRQcm9wZXJ0aWVzKHNjaGVtYSwgYWRkaXRpb25hbGx5UmVxdWlyZWQpIHtcbiAgICBpZiAoIWFkZGl0aW9uYWxseVJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVkID0gQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpXG4gICAgICAgID8gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5zY2hlbWEucmVxdWlyZWQsIC4uLmFkZGl0aW9uYWxseVJlcXVpcmVkXSkpXG4gICAgICAgIDogYWRkaXRpb25hbGx5UmVxdWlyZWQ7XG4gICAgcmV0dXJuIHsgLi4uc2NoZW1hLCByZXF1aXJlZDogcmVxdWlyZWQgfTtcbn1cbi8qKiBNZXJnZXMgYSBkZXBlbmRlbnQgc2NoZW1hIGludG8gdGhlIGBzY2hlbWFgIGRlYWxpbmcgd2l0aCBvbmVPZnMgYW5kIHJlZmVyZW5jZXMuIFBhc3NlcyB0aGUgYGV4cGFuZEFsbEJyYW5jaGVzYCBmbGFnXG4gKiBkb3duIHRvIHRoZSBgcmV0cmlldmVTY2hlbWFJbnRlcm5hbCgpYCwgYHJlc29sdmVSZWZlcmVuY2UoKWAgYW5kIGB3aXRoRXhhY3RseU9uZVN1YnNjaGVtYSgpYCBoZWxwZXIgY2FsbHMuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIHRoZSBBUElzXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggcmVzb2x2aW5nIGEgZGVwZW5kZW50IHNjaGVtYSBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRvIGFsbCB0aGUgQVBJc1xuICogQHBhcmFtIGRlcGVuZGVuY3lLZXkgLSBUaGUga2V5IG5hbWUgb2YgdGhlIGRlcGVuZGVuY3lcbiAqIEBwYXJhbSBkZXBlbmRlbmN5VmFsdWUgLSBUaGUgcG90ZW50aWFsbHkgZGVwZW5kZW50IHNjaGVtYVxuICogQHBhcmFtIGV4cGFuZEFsbEJyYW5jaGVzIC0gRmxhZywgaWYgdHJ1ZSwgd2lsbCByZXR1cm4gYWxsIHBvc3NpYmxlIGJyYW5jaGVzIG9mIGNvbmRpdGlvbnMsIGFueS9vbmVPZiBhbmQgZGVwZW5kZW5jaWVzXG4gKiAgICAgICAgICBhcyBhIGxpc3Qgb2Ygc2NoZW1hc1xuICogQHBhcmFtIHJlY3Vyc2VMaXN0IC0gVGhlIGxpc3Qgb2YgcmVjdXJzaXZlIHJlZmVyZW5jZXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAqIEBwYXJhbSBbZm9ybURhdGFdLSBUaGUgY3VycmVudCBmb3JtRGF0YSB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHJldHVybnMgLSBUaGUgbGlzdCBvZiBzY2hlbWFzIHdpdGggdGhlIGRlcGVuZGVudCBzY2hlbWEgcmVzb2x2ZWQgaW50byB0aGVtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoRGVwZW5kZW50U2NoZW1hKHZhbGlkYXRvciwgc2NoZW1hLCByb290U2NoZW1hLCBkZXBlbmRlbmN5S2V5LCBkZXBlbmRlbmN5VmFsdWUsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCwgZm9ybURhdGEpIHtcbiAgICBjb25zdCBkZXBlbmRlbnRTY2hlbWFzID0gcmV0cmlldmVTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIGRlcGVuZGVuY3lWYWx1ZSwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGV4cGFuZEFsbEJyYW5jaGVzLCByZWN1cnNlTGlzdCk7XG4gICAgcmV0dXJuIGRlcGVuZGVudFNjaGVtYXMuZmxhdE1hcCgoZGVwZW5kZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25lT2YsIC4uLmRlcGVuZGVudFNjaGVtYSB9ID0gZGVwZW5kZW50O1xuICAgICAgICBzY2hlbWEgPSBtZXJnZVNjaGVtYXMoc2NoZW1hLCBkZXBlbmRlbnRTY2hlbWEpO1xuICAgICAgICAvLyBTaW5jZSBpdCBkb2VzIG5vdCBjb250YWluIG9uZU9mLCB3ZSByZXR1cm4gdGhlIG9yaWdpbmFsIHNjaGVtYS5cbiAgICAgICAgaWYgKG9uZU9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSAkcmVmcyBpbnNpZGUgb25lT2YuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkT25lT2ZzID0gb25lT2YubWFwKChzdWJzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NoZW1hID09PSAnYm9vbGVhbicgfHwgIShSRUZfS0VZIGluIHN1YnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N1YnNjaGVtYV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZmVyZW5jZSh2YWxpZGF0b3IsIHN1YnNjaGVtYSwgcm9vdFNjaGVtYSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0LCBmb3JtRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbGxQZXJtdXRhdGlvbnMgPSBnZXRBbGxQZXJtdXRhdGlvbnNPZlh4eE9mKHJlc29sdmVkT25lT2ZzKTtcbiAgICAgICAgcmV0dXJuIGFsbFBlcm11dGF0aW9ucy5mbGF0TWFwKChyZXNvbHZlZE9uZU9mKSA9PiB3aXRoRXhhY3RseU9uZVN1YnNjaGVtYSh2YWxpZGF0b3IsIHNjaGVtYSwgcm9vdFNjaGVtYSwgZGVwZW5kZW5jeUtleSwgcmVzb2x2ZWRPbmVPZiwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0LCBmb3JtRGF0YSkpO1xuICAgIH0pO1xufVxuLyoqIFJldHVybnMgYSBsaXN0IG9mIGBzY2hlbWFgcyB3aXRoIHRoZSBiZXN0IGNob2ljZSBmcm9tIHRoZSBgb25lT2ZgIG9wdGlvbnMgbWVyZ2VkIGludG8gaXQuIElmIGBleHBhbmRBbGxCcmFuY2hlc2AgaXNcbiAqIHRydWUsIHRoZW4gYSBsaXN0IG9mIHNjaGVtYXMgZm9yIEFMTCBvcHRpb25zIGFyZSByZXRyaWV2ZWQgYW5kIHJldHVybmVkLiBQYXNzZXMgdGhlIGBleHBhbmRBbGxCcmFuY2hlc2AgZmxhZyBkb3duIHRvXG4gKiB0aGUgYHJldHJpZXZlU2NoZW1hSW50ZXJuYWwoKWAgaGVscGVyIGNhbGwuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG9uZU9mIG9wdGlvbnNcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCByZXNvbHZpbmcgYSBvbmVPZiBzdWJzY2hlbWEgaXMgZGVzaXJlZFxuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgdGhlIEFQSXNcbiAqIEBwYXJhbSBkZXBlbmRlbmN5S2V5IC0gVGhlIGtleSBuYW1lIG9mIHRoZSBvbmVPZiBkZXBlbmRlbmN5XG4gKiBAcGFyYW0gb25lT2YgLSBUaGUgbGlzdCBvZiBzY2hlbWFzIHJlcHJlc2VudGluZyB0aGUgb25lT2Ygb3B0aW9uc1xuICogQHBhcmFtIGV4cGFuZEFsbEJyYW5jaGVzIC0gRmxhZywgaWYgdHJ1ZSwgd2lsbCByZXR1cm4gYWxsIHBvc3NpYmxlIGJyYW5jaGVzIG9mIGNvbmRpdGlvbnMsIGFueS9vbmVPZiBhbmQgZGVwZW5kZW5jaWVzXG4gKiAgICAgICAgICBhcyBhIGxpc3Qgb2Ygc2NoZW1hc1xuICogQHBhcmFtIHJlY3Vyc2VMaXN0IC0gVGhlIGxpc3Qgb2YgcmVjdXJzaXZlIHJlZmVyZW5jZXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEgdG8gYXNzaXN0IHJldHJpZXZpbmcgYSBzY2hlbWFcbiAqIEByZXR1cm5zIC0gRWl0aGVyIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGJlc3QgbWF0Y2hpbmcgb3B0aW9uIG9yIGFsbCBvcHRpb25zIGlmIGBleHBhbmRBbGxCcmFuY2hlc2AgaXMgdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aEV4YWN0bHlPbmVTdWJzY2hlbWEodmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIGRlcGVuZGVuY3lLZXksIG9uZU9mLCBleHBhbmRBbGxCcmFuY2hlcywgcmVjdXJzZUxpc3QsIGZvcm1EYXRhKSB7XG4gICAgY29uc3QgdmFsaWRTdWJzY2hlbWFzID0gb25lT2YuZmlsdGVyKChzdWJzY2hlbWEpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY2hlbWEgPT09ICdib29sZWFuJyB8fCAhc3Vic2NoZW1hIHx8ICFzdWJzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgW2RlcGVuZGVuY3lLZXldOiBjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSB9ID0gc3Vic2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGlmIChjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uU2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgW2RlcGVuZGVuY3lLZXldOiBjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0b3IuaXNWYWxpZChjb25kaXRpb25TY2hlbWEsIGZvcm1EYXRhLCByb290U2NoZW1hKSB8fCBleHBhbmRBbGxCcmFuY2hlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKCFleHBhbmRBbGxCcmFuY2hlcyAmJiB2YWxpZFN1YnNjaGVtYXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImlnbm9yaW5nIG9uZU9mIGluIGRlcGVuZGVuY2llcyBiZWNhdXNlIHRoZXJlIGlzbid0IGV4YWN0bHkgb25lIHN1YnNjaGVtYSB0aGF0IGlzIHZhbGlkXCIpO1xuICAgICAgICByZXR1cm4gW3NjaGVtYV07XG4gICAgfVxuICAgIHJldHVybiB2YWxpZFN1YnNjaGVtYXMuZmxhdE1hcCgocykgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSBzO1xuICAgICAgICBjb25zdCBbZGVwZW5kZW50U3Vic2NoZW1hXSA9IHNwbGl0S2V5RWxlbWVudEZyb21PYmplY3QoZGVwZW5kZW5jeUtleSwgc3Vic2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBkZXBlbmRlbnRTY2hlbWEgPSB7IC4uLnN1YnNjaGVtYSwgcHJvcGVydGllczogZGVwZW5kZW50U3Vic2NoZW1hIH07XG4gICAgICAgIGNvbnN0IHNjaGVtYXMgPSByZXRyaWV2ZVNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgZGVwZW5kZW50U2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSwgZXhwYW5kQWxsQnJhbmNoZXMsIHJlY3Vyc2VMaXN0KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYXMubWFwKChzKSA9PiBtZXJnZVNjaGVtYXMoc2NoZW1hLCBzKSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyaWV2ZVNjaGVtYS5qcy5tYXAiLCJpbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IGhhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCB7IFBST1BFUlRJRVNfS0VZLCBSRUZfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCByZXRyaWV2ZVNjaGVtYSBmcm9tICcuL3JldHJpZXZlU2NoZW1hJztcbmNvbnN0IE5PX1ZBTFVFID0gU3ltYm9sKCdubyBWYWx1ZScpO1xuLyoqIFNhbml0aXplIHRoZSBgZGF0YWAgYXNzb2NpYXRlZCB3aXRoIHRoZSBgb2xkU2NoZW1hYCBzbyBpdCBpcyBjb25zaWRlcmVkIGFwcHJvcHJpYXRlIGZvciB0aGUgYG5ld1NjaGVtYWAuIElmIHRoZSBuZXdcbiAqIHNjaGVtYSBkb2VzIG5vdCBjb250YWluIGFueSBwcm9wZXJ0aWVzLCB0aGVuIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHRvIGNsZWFyIGFsbCB0aGUgZm9ybSBkYXRhLiBEdWUgdG8gdGhlIG5hdHVyZVxuICogb2Ygc2NoZW1hcywgdGhpcyBzYW5pdGl6YXRpb24gaGFwcGVucyByZWN1cnNpdmVseSBmb3IgbmVzdGVkIG9iamVjdHMgb2YgZGF0YS4gQWxzbywgYW55IHByb3BlcnRpZXMgaW4gdGhlIG9sZCBzY2hlbWFcbiAqIHRoYXQgYXJlIG5vbi1leGlzdGVudCBpbiB0aGUgbmV3IHNjaGVtYSBhcmUgc2V0IHRvIGB1bmRlZmluZWRgLiBUaGUgZGF0YSBzYW5pdGl6YXRpb24gcHJvY2VzcyBoYXMgdGhlIGZvbGxvd2luZyBmbG93OlxuICpcbiAqIC0gSWYgdGhlIG5ldyBzY2hlbWEgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBgcHJvcGVydGllc2Agb2JqZWN0IHRoZW46XG4gKiAgIC0gQ3JlYXRlIGEgYHJlbW92ZU9sZFNjaGVtYURhdGFgIG9iamVjdCwgc2V0dGluZyBlYWNoIGtleSBpbiB0aGUgYG9sZFNjaGVtYS5wcm9wZXJ0aWVzYCBoYXZpbmcgYGRhdGFgIHRvIHVuZGVmaW5lZFxuICogICAtIENyZWF0ZSBhbiBlbXB0eSBgbmVzdGVkRGF0YWAgb2JqZWN0IGZvciB1c2UgaW4gdGhlIGtleSBmaWx0ZXJpbmcgYmVsb3c6XG4gKiAgIC0gSXRlcmF0ZSBvdmVyIGVhY2gga2V5IGluIHRoZSBgbmV3U2NoZW1hLnByb3BlcnRpZXNgIGFzIGZvbGxvd3M6XG4gKiAgICAgLSBHZXQgdGhlIGBmb3JtVmFsdWVgIG9mIHRoZSBrZXkgZnJvbSB0aGUgYGRhdGFgXG4gKiAgICAgLSBHZXQgdGhlIGBvbGRLZXlTY2hlbWFgIGFuZCBgbmV3S2V5ZWRTY2hlbWFgIGZvciB0aGUga2V5LCBkZWZhdWx0aW5nIHRvIGB7fWAgd2hlbiBpdCBkb2Vzbid0IGV4aXN0XG4gKiAgICAgLSBSZXRyaWV2ZSB0aGUgc2NoZW1hIGZvciBhbnkgcmVmcyB3aXRoaW4gZWFjaCBgb2xkS2V5U2NoZW1hYCBhbmQvb3IgYG5ld0tleVNjaGVtYWBcbiAqICAgICAtIEdldCB0aGUgdHlwZXMgb2YgdGhlIG9sZCBhbmQgbmV3IGtleWVkIHNjaGVtYXMgYW5kIGlmIHRoZSBvbGQgZG9lc24ndCBleGlzdCBvciB0aGUgb2xkICYgbmV3IGFyZSB0aGUgc2FtZSB0aGVuOlxuICogICAgICAgLSBJZiBgcmVtb3ZlT2xkU2NoZW1hRGF0YWAgaGFzIGFuIGVudHJ5IGZvciB0aGUga2V5LCBkZWxldGUgaXQgc2luY2UgdGhlIG5ldyBzY2hlbWEgaGFzIHRoZSBzYW1lIHByb3BlcnR5XG4gKiAgICAgICAtIElmIHR5cGUgb2YgdGhlIGtleSBpbiB0aGUgbmV3IHNjaGVtYSBpcyBgb2JqZWN0YDpcbiAqICAgICAgICAgLSBTdG9yZSB0aGUgdmFsdWUgZnJvbSB0aGUgcmVjdXJzaXZlIGBzYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWFgIGNhbGwgaW4gYG5lc3RlZERhdGFba2V5XWBcbiAqICAgICAgIC0gT3RoZXJ3aXNlLCBjaGVjayBmb3IgZGVmYXVsdCBvciBjb25zdCB2YWx1ZXM6XG4gKiAgICAgICAgIC0gR2V0IHRoZSBvbGQgYW5kIG5ldyBgZGVmYXVsdGAgdmFsdWVzIGZyb20gdGhlIHNjaGVtYSBhbmQgY2hlY2s6XG4gKiAgICAgICAgICAgLSBJZiB0aGUgbmV3IGBkZWZhdWx0YCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybSB2YWx1ZTpcbiAqICAgICAgICAgICAgIC0gSWYgdGhlIG9sZCBgZGVmYXVsdGAgdmFsdWUgRE9FUyBtYXRjaCB0aGUgZm9ybSB2YWx1ZSwgdGhlbjpcbiAqICAgICAgICAgICAgICAgLSBSZXBsYWNlIGByZW1vdmVPbGRTY2hlbWFEYXRhW2tleV1gIHdpdGggdGhlIG5ldyBgZGVmYXVsdGBcbiAqICAgICAgICAgICAgICAgLSBPdGhlcndpc2UsIGlmIHRoZSBuZXcgc2NoZW1hIGlzIGByZWFkT25seWAgdGhlbiByZXBsYWNlIGByZW1vdmVPbGRTY2hlbWFEYXRhW2tleV1gIHdpdGggdW5kZWZpbmVkXG4gKiAgICAgICAgIC0gR2V0IHRoZSBvbGQgYW5kIG5ldyBgY29uc3RgIHZhbHVlcyBmcm9tIHRoZSBzY2hlbWEgYW5kIGNoZWNrOlxuICogICAgICAgICAgIC0gSWYgdGhlIG5ldyBgY29uc3RgIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtIHZhbHVlOlxuICogICAgICAgICAgIC0gSWYgdGhlIG9sZCBgY29uc3RgIHZhbHVlIERPRVMgbWF0Y2ggdGhlIGZvcm0gdmFsdWUsIHRoZW46XG4gKiAgICAgICAgICAgICAtIFJlcGxhY2UgYHJlbW92ZU9sZFNjaGVtYURhdGFba2V5XWAgd2l0aCB0aGUgbmV3IGBjb25zdGBcbiAqICAgICAgICAgICAgIC0gT3RoZXJ3aXNlLCByZXBsYWNlIGByZW1vdmVPbGRTY2hlbWFEYXRhW2tleV1gIHdpdGggdW5kZWZpbmVkXG4gKiAgIC0gT25jZSBhbGwga2V5cyBoYXZlIGJlZW4gcHJvY2Vzc2VkLCByZXR1cm4gYW4gb2JqZWN0IGJ1aWx0IGFzIGZvbGxvd3M6XG4gKiAgICAgLSBgeyAuLi5yZW1vdmVPbGRTY2hlbWFEYXRhLCAuLi5uZXN0ZWREYXRhLCAuLi5waWNrKGRhdGEsIGtleXNUb0tlZXApIH1gXG4gKiAtIElmIHRoZSBuZXcgYW5kIG9sZCBzY2hlbWEgdHlwZXMgYXJlIGFycmF5IGFuZCB0aGUgYGRhdGFgIGlzIGFuIGFycmF5IHRoZW46XG4gKiAgIC0gSWYgdGhlIHR5cGUgb2YgdGhlIG9sZCBhbmQgbmV3IHNjaGVtYSBgaXRlbXNgIGFyZSBhIG5vbi1hcnJheSBvYmplY3RzOlxuICogICAgIC0gUmV0cmlldmUgdGhlIHNjaGVtYSBmb3IgYW55IHJlZnMgd2l0aGluIGVhY2ggYG9sZEtleVNjaGVtYS5pdGVtc2AgYW5kL29yIGBuZXdLZXlTY2hlbWEuaXRlbXNgXG4gKiAgICAgLSBJZiB0aGUgYHR5cGVgcyBvZiBib3RoIGl0ZW1zIGFyZSB0aGUgc2FtZSAob3IgdGhlIG9sZCBkb2VzIG5vdCBoYXZlIGEgdHlwZSk6XG4gKiAgICAgICAtIElmIHRoZSB0eXBlIGlzIFwib2JqZWN0XCIsIHRoZW46XG4gKiAgICAgICAgIC0gRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYGRhdGFgIHJlY3Vyc2l2ZWx5IHNhbml0aXplIHRoZSBkYXRhLCBzdG9wcGluZyBhdCBgbWF4SXRlbXNgIGlmIHNwZWNpZmllZFxuICogICAgICAgLSBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIHRoZSBgZGF0YWAgcmVtb3ZpbmcgYW55IHZhbHVlcyBhZnRlciBgbWF4SXRlbXNgIGlmIGl0IGlzIHNldFxuICogICAtIElmIHRoZSB0eXBlIG9mIHRoZSBvbGQgYW5kIG5ldyBzY2hlbWEgYGl0ZW1zYCBhcmUgYm9vbGVhbnMgb2YgdGhlIHNhbWUgdmFsdWUsIHJldHVybiBgZGF0YWAgYXMgaXNcbiAqIC0gT3RoZXJ3aXNlIHJldHVybiBgdW5kZWZpbmVkYFxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIG5lY2Vzc2FyeVxuICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBKU09OIHNjaGVtYSBvZiB0aGUgZW50aXJlIGZvcm1cbiAqIEBwYXJhbSBbbmV3U2NoZW1hXSAtIFRoZSBuZXcgc2NoZW1hIGZvciB3aGljaCB0aGUgZGF0YSBpcyBiZWluZyBzYW5pdGl6ZWRcbiAqIEBwYXJhbSBbb2xkU2NoZW1hXSAtIFRoZSBvbGQgc2NoZW1hIGZyb20gd2hpY2ggdGhlIGRhdGEgb3JpZ2luYXRlZFxuICogQHBhcmFtIFtkYXRhPXt9XSAtIFRoZSBmb3JtIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBzY2hlbWEsIGRlZmF1bHRpbmcgdG8gYW4gZW1wdHkgb2JqZWN0IHdoZW4gdW5kZWZpbmVkXG4gKiBAcmV0dXJucyAtIFRoZSBuZXcgZm9ybSBkYXRhLCB3aXRoIGFsbCB0aGUgZmllbGRzIHVuaXF1ZWx5IGFzc29jaWF0ZWQgd2l0aCB0aGUgb2xkIHNjaGVtYSBzZXRcbiAqICAgICAgdG8gYHVuZGVmaW5lZGAuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSBuZXcgc2NoZW1hIGlzIG5vdCBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEodmFsaWRhdG9yLCByb290U2NoZW1hLCBuZXdTY2hlbWEsIG9sZFNjaGVtYSwgZGF0YSA9IHt9KSB7XG4gICAgLy8gQnkgZGVmYXVsdCwgd2Ugd2lsbCBjbGVhciB0aGUgZm9ybSBkYXRhXG4gICAgbGV0IG5ld0Zvcm1EYXRhO1xuICAgIC8vIElmIHRoZSBuZXcgc2NoZW1hIGlzIG9mIHR5cGUgb2JqZWN0IGFuZCB0aGF0IG9iamVjdCBjb250YWlucyBhIGxpc3Qgb2YgcHJvcGVydGllc1xuICAgIGlmIChoYXMobmV3U2NoZW1hLCBQUk9QRVJUSUVTX0tFWSkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIG9iamVjdCBjb250YWluaW5nIHJvb3QtbGV2ZWwga2V5cyBpbiB0aGUgb2xkIHNjaGVtYSwgc2V0dGluZyBlYWNoIGtleSB0byB1bmRlZmluZWQgdG8gcmVtb3ZlIHRoZSBkYXRhXG4gICAgICAgIGNvbnN0IHJlbW92ZU9sZFNjaGVtYURhdGEgPSB7fTtcbiAgICAgICAgaWYgKGhhcyhvbGRTY2hlbWEsIFBST1BFUlRJRVNfS0VZKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGdldChvbGRTY2hlbWEsIFBST1BFUlRJRVNfS0VZLCB7fSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT2xkU2NoZW1hRGF0YVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhnZXQobmV3U2NoZW1hLCBQUk9QRVJUSUVTX0tFWSwge30pKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcGxhY2UgdG8gc3RvcmUgbmVzdGVkIGRhdGEgdGhhdCB3aWxsIGJlIGEgc2lkZS1lZmZlY3Qgb2YgdGhlIGZpbHRlclxuICAgICAgICBjb25zdCBuZXN0ZWREYXRhID0ge307XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtVmFsdWUgPSBnZXQoZGF0YSwga2V5KTtcbiAgICAgICAgICAgIGxldCBvbGRLZXllZFNjaGVtYSA9IGdldChvbGRTY2hlbWEsIFtQUk9QRVJUSUVTX0tFWSwga2V5XSwge30pO1xuICAgICAgICAgICAgbGV0IG5ld0tleWVkU2NoZW1hID0gZ2V0KG5ld1NjaGVtYSwgW1BST1BFUlRJRVNfS0VZLCBrZXldLCB7fSk7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSByZWZzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgICAgIGlmIChoYXMob2xkS2V5ZWRTY2hlbWEsIFJFRl9LRVkpKSB7XG4gICAgICAgICAgICAgICAgb2xkS2V5ZWRTY2hlbWEgPSByZXRyaWV2ZVNjaGVtYSh2YWxpZGF0b3IsIG9sZEtleWVkU2NoZW1hLCByb290U2NoZW1hLCBmb3JtVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhcyhuZXdLZXllZFNjaGVtYSwgUkVGX0tFWSkpIHtcbiAgICAgICAgICAgICAgICBuZXdLZXllZFNjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHZhbGlkYXRvciwgbmV3S2V5ZWRTY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgZ2V0IHR5cGVzIGFuZCBzZWUgaWYgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIGNvbnN0IG9sZFNjaGVtYVR5cGVGb3JLZXkgPSBnZXQob2xkS2V5ZWRTY2hlbWEsICd0eXBlJyk7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2hlbWFUeXBlRm9yS2V5ID0gZ2V0KG5ld0tleWVkU2NoZW1hLCAndHlwZScpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9sZCBvcHRpb24gaGFzIHRoZSBzYW1lIGtleSB3aXRoIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgIGlmICghb2xkU2NoZW1hVHlwZUZvcktleSB8fCBvbGRTY2hlbWFUeXBlRm9yS2V5ID09PSBuZXdTY2hlbWFUeXBlRm9yS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhcyhyZW1vdmVPbGRTY2hlbWFEYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNJREUtRUZGRUNUOiByZW1vdmUgdGhlIHVuZGVmaW5lZCB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBoYXMgdGhlIHNhbWUgdHlwZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZW1vdmVPbGRTY2hlbWFEYXRhW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIG9iamVjdCwgd2UnbGwgcmVjdXJzZSBhbmQgc3RvcmUgdGhlIHJlc3VsdGluZyBzYW5pdGl6ZWQgZGF0YSBmb3IgdGhlIGtleVxuICAgICAgICAgICAgICAgIGlmIChuZXdTY2hlbWFUeXBlRm9yS2V5ID09PSAnb2JqZWN0JyB8fCAobmV3U2NoZW1hVHlwZUZvcktleSA9PT0gJ2FycmF5JyAmJiBBcnJheS5pc0FycmF5KGZvcm1WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNJREUtRUZGRUNUOiBwcm9jZXNzIHRoZSBuZXcgc2NoZW1hIHR5cGUgb2Ygb2JqZWN0IHJlY3Vyc2l2ZWx5IHRvIHNhdmUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtRGF0YSA9IHNhbml0aXplRGF0YUZvck5ld1NjaGVtYSh2YWxpZGF0b3IsIHJvb3RTY2hlbWEsIG5ld0tleWVkU2NoZW1hLCBvbGRLZXllZFNjaGVtYSwgZm9ybVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1EYXRhICE9PSB1bmRlZmluZWQgfHwgbmV3U2NoZW1hVHlwZUZvcktleSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBwdXQgdW5kZWZpbmVkIHZhbHVlcyBmb3IgdGhlIGFycmF5IHR5cGUgYW5kIG5vdCB0aGUgb2JqZWN0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZERhdGFba2V5XSA9IGl0ZW1EYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPaywgdGhlIG5vbi1vYmplY3QgdHlwZXMgbWF0Y2gsIGxldCdzIG1ha2Ugc3VyZSB0aGF0IGEgZGVmYXVsdCBvciBhIGNvbnN0IG9mIGEgZGlmZmVyZW50IHZhbHVlIGlzIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIG5ldyBkZWZhdWx0IG9yIGNvbnN0LiBUaGlzIGFsbG93cyB0aGUgY2FzZSB3aGVyZSB0d28gc2NoZW1hcyBkaWZmZXIgdGhhdCBvbmx5IGJ5IHRoZSBkZWZhdWx0L2NvbnN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHRvIGJlIHByb3Blcmx5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbkRlZmF1bHQgPSBnZXQobmV3S2V5ZWRTY2hlbWEsICdkZWZhdWx0JywgTk9fVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPcHRpb25EZWZhdWx0ID0gZ2V0KG9sZEtleWVkU2NoZW1hLCAnZGVmYXVsdCcsIE5PX1ZBTFVFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld09wdGlvbkRlZmF1bHQgIT09IE5PX1ZBTFVFICYmIG5ld09wdGlvbkRlZmF1bHQgIT09IGZvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbkRlZmF1bHQgPT09IGZvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvbGQgZGVmYXVsdCBtYXRjaGVzIHRoZSBmb3JtVmFsdWUsIHdlJ2xsIHVwZGF0ZSB0aGUgbmV3IHZhbHVlIHRvIG1hdGNoIHRoZSBuZXcgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU9sZFNjaGVtYURhdGFba2V5XSA9IG5ld09wdGlvbkRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnZXQobmV3S2V5ZWRTY2hlbWEsICdyZWFkT25seScpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldyBzY2hlbWEgaGFzIHRoZSBkZWZhdWx0IHNldCB0byByZWFkLW9ubHksIHRyZWF0IGl0IGxpa2UgYSBjb25zdCBhbmQgcmVtb3ZlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU9sZFNjaGVtYURhdGFba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPcHRpb25Db25zdCA9IGdldChuZXdLZXllZFNjaGVtYSwgJ2NvbnN0JywgTk9fVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPcHRpb25Db25zdCA9IGdldChvbGRLZXllZFNjaGVtYSwgJ2NvbnN0JywgTk9fVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3T3B0aW9uQ29uc3QgIT09IE5PX1ZBTFVFICYmIG5ld09wdGlvbkNvbnN0ICE9PSBmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBjb25zdCwgaWYgdGhlIG9sZCB2YWx1ZSBtYXRjaGVzLCByZXBsYWNlIHRoZSB2YWx1ZSB3aXRoIHRoZSBuZXcgY29uc3Qgb3RoZXJ3aXNlIGNsZWFyIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPbGRTY2hlbWFEYXRhW2tleV0gPSBvbGRPcHRpb25Db25zdCA9PT0gZm9ybVZhbHVlID8gbmV3T3B0aW9uQ29uc3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdGb3JtRGF0YSA9IHtcbiAgICAgICAgICAgIC4uLih0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGRhdGEpID8gdW5kZWZpbmVkIDogZGF0YSksXG4gICAgICAgICAgICAuLi5yZW1vdmVPbGRTY2hlbWFEYXRhLFxuICAgICAgICAgICAgLi4ubmVzdGVkRGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRmlyc3QgYXBwbHkgcmVtb3ZpbmcgdGhlIG9sZCBzY2hlbWEgZGF0YSwgdGhlbiBhcHBseSB0aGUgbmVzdGVkIGRhdGEsIHRoZW4gYXBwbHkgdGhlIG9sZCBkYXRhIGtleXMgdG8ga2VlcFxuICAgIH1cbiAgICBlbHNlIGlmIChnZXQob2xkU2NoZW1hLCAndHlwZScpID09PSAnYXJyYXknICYmIGdldChuZXdTY2hlbWEsICd0eXBlJykgPT09ICdhcnJheScgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBsZXQgb2xkU2NoZW1hSXRlbXMgPSBnZXQob2xkU2NoZW1hLCAnaXRlbXMnKTtcbiAgICAgICAgbGV0IG5ld1NjaGVtYUl0ZW1zID0gZ2V0KG5ld1NjaGVtYSwgJ2l0ZW1zJyk7XG4gICAgICAgIC8vIElmIGFueSBvZiB0aGUgYXJyYXkgdHlwZXMgYGl0ZW1zYCBhcmUgYXJyYXlzIChyZW1lbWJlciBhcnJheXMgYXJlIG9iamVjdHMpIHRoZW4gd2UnbGwganVzdCBkcm9wIHRoZSBkYXRhXG4gICAgICAgIC8vIEV2ZW50dWFsbHksIHdlIG1heSB3YW50IHRvIGRlYWwgd2l0aCB3aGVuIGVpdGhlciBvZiB0aGUgYGl0ZW1zYCBhcmUgYXJyYXlzIHNpbmNlIHRob3NlIHR1cGxlIHZhbGlkYXRpb25zXG4gICAgICAgIGlmICh0eXBlb2Ygb2xkU2NoZW1hSXRlbXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgbmV3U2NoZW1hSXRlbXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShvbGRTY2hlbWFJdGVtcykgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KG5ld1NjaGVtYUl0ZW1zKSkge1xuICAgICAgICAgICAgaWYgKGhhcyhvbGRTY2hlbWFJdGVtcywgUkVGX0tFWSkpIHtcbiAgICAgICAgICAgICAgICBvbGRTY2hlbWFJdGVtcyA9IHJldHJpZXZlU2NoZW1hKHZhbGlkYXRvciwgb2xkU2NoZW1hSXRlbXMsIHJvb3RTY2hlbWEsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhcyhuZXdTY2hlbWFJdGVtcywgUkVGX0tFWSkpIHtcbiAgICAgICAgICAgICAgICBuZXdTY2hlbWFJdGVtcyA9IHJldHJpZXZlU2NoZW1hKHZhbGlkYXRvciwgbmV3U2NoZW1hSXRlbXMsIHJvb3RTY2hlbWEsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGdldCB0eXBlcyBhbmQgc2VlIGlmIHRoZXkgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBjb25zdCBvbGRTY2hlbWFUeXBlID0gZ2V0KG9sZFNjaGVtYUl0ZW1zLCAndHlwZScpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2NoZW1hVHlwZSA9IGdldChuZXdTY2hlbWFJdGVtcywgJ3R5cGUnKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBvbGQgb3B0aW9uIGhhcyB0aGUgc2FtZSBrZXkgd2l0aCB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICBpZiAoIW9sZFNjaGVtYVR5cGUgfHwgb2xkU2NoZW1hVHlwZSA9PT0gbmV3U2NoZW1hVHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEl0ZW1zID0gZ2V0KG5ld1NjaGVtYSwgJ21heEl0ZW1zJywgLTEpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTY2hlbWFUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXdGb3JtRGF0YSA9IGRhdGEucmVkdWNlKChuZXdWYWx1ZSwgYVZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsdWUgPSBzYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEodmFsaWRhdG9yLCByb290U2NoZW1hLCBuZXdTY2hlbWFJdGVtcywgb2xkU2NoZW1hSXRlbXMsIGFWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG1heEl0ZW1zIDwgMCB8fCBuZXdWYWx1ZS5sZW5ndGggPCBtYXhJdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZS5wdXNoKGl0ZW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Zvcm1EYXRhID0gbWF4SXRlbXMgPiAwICYmIGRhdGEubGVuZ3RoID4gbWF4SXRlbXMgPyBkYXRhLnNsaWNlKDAsIG1heEl0ZW1zKSA6IGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvbGRTY2hlbWFJdGVtcyA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICB0eXBlb2YgbmV3U2NoZW1hSXRlbXMgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgb2xkU2NoZW1hSXRlbXMgPT09IG5ld1NjaGVtYUl0ZW1zKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBib3RoIGJvb2xlYW5zIGFuZCBoYXZlIHRoZSBzYW1lIHZhbHVlIGp1c3QgcmV0dXJuIHRoZSBkYXRhIGFzIGlzIG90aGVyd2lzZSBmYWxsLXRocnUgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICBuZXdGb3JtRGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxzbyBwcm9iYWJseSB3YW50IHRvIGRlYWwgd2l0aCBgcHJlZml4SXRlbXNgIGFzIHR1cGxlcyB3aXRoIHRoZSBsYXRlc3QgMjAyMCBkcmFmdFxuICAgIH1cbiAgICByZXR1cm4gbmV3Rm9ybURhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEuanMubWFwIiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCB7IEFMTF9PRl9LRVksIERFUEVOREVOQ0lFU19LRVksIElEX0tFWSwgSVRFTVNfS0VZLCBQUk9QRVJUSUVTX0tFWSwgUkVGX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi4vaXNPYmplY3QnO1xuaW1wb3J0IHJldHJpZXZlU2NoZW1hIGZyb20gJy4vcmV0cmlldmVTY2hlbWEnO1xuaW1wb3J0IGdldFNjaGVtYVR5cGUgZnJvbSAnLi4vZ2V0U2NoZW1hVHlwZSc7XG4vKiogQW4gaW50ZXJuYWwgaGVscGVyIHRoYXQgZ2VuZXJhdGVzIGFuIGBJZFNjaGVtYWAgb2JqZWN0IGZvciB0aGUgYHNjaGVtYWAsIHJlY3Vyc2l2ZWx5IHdpdGggcHJvdGVjdGlvbiBhZ2FpbnN0XG4gKiBpbmZpbml0ZSByZWN1cnNpb25cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBuZWNlc3NhcnlcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCB0aGUgYElkU2NoZW1hYCBpcyBkZXNpcmVkXG4gKiBAcGFyYW0gaWRQcmVmaXggLSBUaGUgcHJlZml4IHRvIHVzZSBmb3IgdGhlIGlkXG4gKiBAcGFyYW0gaWRTZXBhcmF0b3IgLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSBmb3IgdGhlIHBhdGggc2VnbWVudHMgaW4gdGhlIGlkXG4gKiBAcGFyYW0gW2lkXSAtIFRoZSBiYXNlIGlkIGZvciB0aGUgc2NoZW1hXG4gKiBAcGFyYW0gW3Jvb3RTY2hlbWFdIC0gVGhlIHJvb3Qgc2NoZW1hLCB1c2VkIHRvIHByaW1hcmlseSB0byBsb29rIHVwIGAkcmVmYHNcbiAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGN1cnJlbnQgZm9ybURhdGEsIGlmIGFueSwgdG8gYXNzaXN0IHJldHJpZXZpbmcgYSBzY2hlbWFcbiAqIEBwYXJhbSBbX3JlY3Vyc2VMaXN0PVtdXSAtIFRoZSBsaXN0IG9mIHJldHJpZXZlZCBzY2hlbWFzIGN1cnJlbnRseSBiZWluZyByZWN1cnNlZCwgdXNlZCB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvblxuICogQHJldHVybnMgLSBUaGUgYElkU2NoZW1hYCBvYmplY3QgZm9yIHRoZSBgc2NoZW1hYFxuICovXG5mdW5jdGlvbiB0b0lkU2NoZW1hSW50ZXJuYWwodmFsaWRhdG9yLCBzY2hlbWEsIGlkUHJlZml4LCBpZFNlcGFyYXRvciwgaWQsIHJvb3RTY2hlbWEsIGZvcm1EYXRhLCBfcmVjdXJzZUxpc3QgPSBbXSkge1xuICAgIGlmIChSRUZfS0VZIGluIHNjaGVtYSB8fCBERVBFTkRFTkNJRVNfS0VZIGluIHNjaGVtYSB8fCBBTExfT0ZfS0VZIGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCBfc2NoZW1hID0gcmV0cmlldmVTY2hlbWEodmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICAgICAgY29uc3Qgc2FtZVNjaGVtYUluZGV4ID0gX3JlY3Vyc2VMaXN0LmZpbmRJbmRleCgoaXRlbSkgPT4gaXNFcXVhbChpdGVtLCBfc2NoZW1hKSk7XG4gICAgICAgIGlmIChzYW1lU2NoZW1hSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9JZFNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgX3NjaGVtYSwgaWRQcmVmaXgsIGlkU2VwYXJhdG9yLCBpZCwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIF9yZWN1cnNlTGlzdC5jb25jYXQoX3NjaGVtYSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChJVEVNU19LRVkgaW4gc2NoZW1hICYmICFnZXQoc2NoZW1hLCBbSVRFTVNfS0VZLCBSRUZfS0VZXSkpIHtcbiAgICAgICAgcmV0dXJuIHRvSWRTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIGdldChzY2hlbWEsIElURU1TX0tFWSksIGlkUHJlZml4LCBpZFNlcGFyYXRvciwgaWQsIHJvb3RTY2hlbWEsIGZvcm1EYXRhLCBfcmVjdXJzZUxpc3QpO1xuICAgIH1cbiAgICBjb25zdCAkaWQgPSBpZCB8fCBpZFByZWZpeDtcbiAgICBjb25zdCBpZFNjaGVtYSA9IHsgJGlkIH07XG4gICAgaWYgKGdldFNjaGVtYVR5cGUoc2NoZW1hKSA9PT0gJ29iamVjdCcgJiYgUFJPUEVSVElFU19LRVkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoc2NoZW1hLCBbUFJPUEVSVElFU19LRVksIG5hbWVdKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSWQgPSBpZFNjaGVtYVtJRF9LRVldICsgaWRTZXBhcmF0b3IgKyBuYW1lO1xuICAgICAgICAgICAgaWRTY2hlbWFbbmFtZV0gPSB0b0lkU2NoZW1hSW50ZXJuYWwodmFsaWRhdG9yLCBpc09iamVjdChmaWVsZCkgPyBmaWVsZCA6IHt9LCBpZFByZWZpeCwgaWRTZXBhcmF0b3IsIGZpZWxkSWQsIHJvb3RTY2hlbWEsIFxuICAgICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGZvcm1EYXRhIGlzIG5vdCBhbiBvYmplY3QgLS0gdGhpcyBjYW4gaGFwcGVuIGlmIGFuXG4gICAgICAgICAgICAvLyBhcnJheSBpdGVtIGhhcyBqdXN0IGJlZW4gYWRkZWQsIGJ1dCBub3QgcG9wdWxhdGVkIHdpdGggZGF0YSB5ZXRcbiAgICAgICAgICAgIGdldChmb3JtRGF0YSwgW25hbWVdKSwgX3JlY3Vyc2VMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRTY2hlbWE7XG59XG4vKiogR2VuZXJhdGVzIGFuIGBJZFNjaGVtYWAgb2JqZWN0IGZvciB0aGUgYHNjaGVtYWAsIHJlY3Vyc2l2ZWx5XG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gbmVjZXNzYXJ5XG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmb3Igd2hpY2ggdGhlIGBJZFNjaGVtYWAgaXMgZGVzaXJlZFxuICogQHBhcmFtIFtpZF0gLSBUaGUgYmFzZSBpZCBmb3IgdGhlIHNjaGVtYVxuICogQHBhcmFtIFtyb290U2NoZW1hXSAtIFRoZSByb290IHNjaGVtYSwgdXNlZCB0byBwcmltYXJpbHkgdG8gbG9vayB1cCBgJHJlZmBzXG4gKiBAcGFyYW0gW2Zvcm1EYXRhXSAtIFRoZSBjdXJyZW50IGZvcm1EYXRhLCBpZiBhbnksIHRvIGFzc2lzdCByZXRyaWV2aW5nIGEgc2NoZW1hXG4gKiBAcGFyYW0gW2lkUHJlZml4PSdyb290J10gLSBUaGUgcHJlZml4IHRvIHVzZSBmb3IgdGhlIGlkXG4gKiBAcGFyYW0gW2lkU2VwYXJhdG9yPSdfJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSBmb3IgdGhlIHBhdGggc2VnbWVudHMgaW4gdGhlIGlkXG4gKiBAcmV0dXJucyAtIFRoZSBgSWRTY2hlbWFgIG9iamVjdCBmb3IgdGhlIGBzY2hlbWFgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvSWRTY2hlbWEodmFsaWRhdG9yLCBzY2hlbWEsIGlkLCByb290U2NoZW1hLCBmb3JtRGF0YSwgaWRQcmVmaXggPSAncm9vdCcsIGlkU2VwYXJhdG9yID0gJ18nKSB7XG4gICAgcmV0dXJuIHRvSWRTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIHNjaGVtYSwgaWRQcmVmaXgsIGlkU2VwYXJhdG9yLCBpZCwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9JZFNjaGVtYS5qcy5tYXAiLCJpbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoL2lzRXF1YWwnO1xuaW1wb3J0IHNldCBmcm9tICdsb2Rhc2gvc2V0JztcbmltcG9ydCB7IEFMTF9PRl9LRVksIEFOWV9PRl9LRVksIEFERElUSU9OQUxfUFJPUEVSVElFU19LRVksIERFUEVOREVOQ0lFU19LRVksIElURU1TX0tFWSwgTkFNRV9LRVksIE9ORV9PRl9LRVksIFBST1BFUlRJRVNfS0VZLCBSRUZfS0VZLCBSSlNGX0FERElUT05BTF9QUk9QRVJUSUVTX0ZMQUcsIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBnZXREaXNjcmltaW5hdG9yRmllbGRGcm9tU2NoZW1hIGZyb20gJy4uL2dldERpc2NyaW1pbmF0b3JGaWVsZEZyb21TY2hlbWEnO1xuaW1wb3J0IGdldENsb3Nlc3RNYXRjaGluZ09wdGlvbiBmcm9tICcuL2dldENsb3Nlc3RNYXRjaGluZ09wdGlvbic7XG5pbXBvcnQgcmV0cmlldmVTY2hlbWEgZnJvbSAnLi9yZXRyaWV2ZVNjaGVtYSc7XG4vKiogQW4gaW50ZXJuYWwgaGVscGVyIHRoYXQgZ2VuZXJhdGVzIGFuIGBQYXRoU2NoZW1hYCBvYmplY3QgZm9yIHRoZSBgc2NoZW1hYCwgcmVjdXJzaXZlbHkgd2l0aCBwcm90ZWN0aW9uIGFnYWluc3RcbiAqIGluZmluaXRlIHJlY3Vyc2lvblxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIG5lY2Vzc2FyeVxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHRoZSBgUGF0aFNjaGVtYWAgaXMgZGVzaXJlZFxuICogQHBhcmFtIFtuYW1lPScnXSAtIFRoZSBiYXNlIG5hbWUgZm9yIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBbcm9vdFNjaGVtYV0gLSBUaGUgcm9vdCBzY2hlbWEsIHVzZWQgdG8gcHJpbWFyaWx5IHRvIGxvb2sgdXAgYCRyZWZgc1xuICogQHBhcmFtIFtmb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHBhcmFtIFtfcmVjdXJzZUxpc3Q9W11dIC0gVGhlIGxpc3Qgb2YgcmV0cmlldmVkIHNjaGVtYXMgY3VycmVudGx5IGJlaW5nIHJlY3Vyc2VkLCB1c2VkIHRvIHByZXZlbnQgaW5maW5pdGUgcmVjdXJzaW9uXG4gKiBAcmV0dXJucyAtIFRoZSBgUGF0aFNjaGVtYWAgb2JqZWN0IGZvciB0aGUgYHNjaGVtYWBcbiAqL1xuZnVuY3Rpb24gdG9QYXRoU2NoZW1hSW50ZXJuYWwodmFsaWRhdG9yLCBzY2hlbWEsIG5hbWUsIHJvb3RTY2hlbWEsIGZvcm1EYXRhLCBfcmVjdXJzZUxpc3QgPSBbXSkge1xuICAgIGlmIChSRUZfS0VZIGluIHNjaGVtYSB8fCBERVBFTkRFTkNJRVNfS0VZIGluIHNjaGVtYSB8fCBBTExfT0ZfS0VZIGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCBfc2NoZW1hID0gcmV0cmlldmVTY2hlbWEodmFsaWRhdG9yLCBzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICAgICAgY29uc3Qgc2FtZVNjaGVtYUluZGV4ID0gX3JlY3Vyc2VMaXN0LmZpbmRJbmRleCgoaXRlbSkgPT4gaXNFcXVhbChpdGVtLCBfc2NoZW1hKSk7XG4gICAgICAgIGlmIChzYW1lU2NoZW1hSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9QYXRoU2NoZW1hSW50ZXJuYWwodmFsaWRhdG9yLCBfc2NoZW1hLCBuYW1lLCByb290U2NoZW1hLCBmb3JtRGF0YSwgX3JlY3Vyc2VMaXN0LmNvbmNhdChfc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhdGhTY2hlbWEgPSB7XG4gICAgICAgIFtOQU1FX0tFWV06IG5hbWUucmVwbGFjZSgvXlxcLi8sICcnKSxcbiAgICB9O1xuICAgIGlmIChPTkVfT0ZfS0VZIGluIHNjaGVtYSB8fCBBTllfT0ZfS0VZIGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCB4eHhPZiA9IE9ORV9PRl9LRVkgaW4gc2NoZW1hID8gc2NoZW1hLm9uZU9mIDogc2NoZW1hLmFueU9mO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldENsb3Nlc3RNYXRjaGluZ09wdGlvbih2YWxpZGF0b3IsIHJvb3RTY2hlbWEsIGZvcm1EYXRhLCB4eHhPZiwgMCwgZGlzY3JpbWluYXRvcik7XG4gICAgICAgIGNvbnN0IF9zY2hlbWEgPSB4eHhPZltpbmRleF07XG4gICAgICAgIHBhdGhTY2hlbWEgPSB7XG4gICAgICAgICAgICAuLi5wYXRoU2NoZW1hLFxuICAgICAgICAgICAgLi4udG9QYXRoU2NoZW1hSW50ZXJuYWwodmFsaWRhdG9yLCBfc2NoZW1hLCBuYW1lLCByb290U2NoZW1hLCBmb3JtRGF0YSwgX3JlY3Vyc2VMaXN0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKEFERElUSU9OQUxfUFJPUEVSVElFU19LRVkgaW4gc2NoZW1hICYmIHNjaGVtYVtBRERJVElPTkFMX1BST1BFUlRJRVNfS0VZXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0KHBhdGhTY2hlbWEsIFJKU0ZfQURESVRPTkFMX1BST1BFUlRJRVNfRkxBRywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChJVEVNU19LRVkgaW4gc2NoZW1hICYmIEFycmF5LmlzQXJyYXkoZm9ybURhdGEpKSB7XG4gICAgICAgIGNvbnN0IHsgaXRlbXM6IHNjaGVtYUl0ZW1zLCBhZGRpdGlvbmFsSXRlbXM6IHNjaGVtYUFkZGl0aW9uYWxJdGVtcyB9ID0gc2NoZW1hO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFJdGVtcykpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2goKGVsZW1lbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFNjaGVtYVtpXSA9IHRvUGF0aFNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgc2NoZW1hSXRlbXNbaV0sIGAke25hbWV9LiR7aX1gLCByb290U2NoZW1hLCBlbGVtZW50LCBfcmVjdXJzZUxpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWFBZGRpdGlvbmFsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFNjaGVtYVtpXSA9IHRvUGF0aFNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgc2NoZW1hQWRkaXRpb25hbEl0ZW1zLCBgJHtuYW1lfS4ke2l9YCwgcm9vdFNjaGVtYSwgZWxlbWVudCwgX3JlY3Vyc2VMaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIGdlbmVyYXRlIHBhdGggc2NoZW1hIGZvciBcIiR7bmFtZX0uJHtpfVwiLiBObyBzY2hlbWEgZGVmaW5lZCBmb3IgaXRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2goKGVsZW1lbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBwYXRoU2NoZW1hW2ldID0gdG9QYXRoU2NoZW1hSW50ZXJuYWwodmFsaWRhdG9yLCBzY2hlbWFJdGVtcywgYCR7bmFtZX0uJHtpfWAsIHJvb3RTY2hlbWEsIGVsZW1lbnQsIF9yZWN1cnNlTGlzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChQUk9QRVJUSUVTX0tFWSBpbiBzY2hlbWEpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoc2NoZW1hLCBbUFJPUEVSVElFU19LRVksIHByb3BlcnR5XSk7XG4gICAgICAgICAgICBwYXRoU2NoZW1hW3Byb3BlcnR5XSA9IHRvUGF0aFNjaGVtYUludGVybmFsKHZhbGlkYXRvciwgZmllbGQsIGAke25hbWV9LiR7cHJvcGVydHl9YCwgcm9vdFNjaGVtYSwgXG4gICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZm9ybURhdGEgaXMgbm90IGFuIG9iamVjdCAtLSB0aGlzIGNhbiBoYXBwZW4gaWYgYW5cbiAgICAgICAgICAgIC8vIGFycmF5IGl0ZW0gaGFzIGp1c3QgYmVlbiBhZGRlZCwgYnV0IG5vdCBwb3B1bGF0ZWQgd2l0aCBkYXRhIHlldFxuICAgICAgICAgICAgZ2V0KGZvcm1EYXRhLCBbcHJvcGVydHldKSwgX3JlY3Vyc2VMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aFNjaGVtYTtcbn1cbi8qKiBHZW5lcmF0ZXMgYW4gYFBhdGhTY2hlbWFgIG9iamVjdCBmb3IgdGhlIGBzY2hlbWFgLCByZWN1cnNpdmVseVxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIG5lY2Vzc2FyeVxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgZm9yIHdoaWNoIHRoZSBgUGF0aFNjaGVtYWAgaXMgZGVzaXJlZFxuICogQHBhcmFtIFtuYW1lPScnXSAtIFRoZSBiYXNlIG5hbWUgZm9yIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBbcm9vdFNjaGVtYV0gLSBUaGUgcm9vdCBzY2hlbWEsIHVzZWQgdG8gcHJpbWFyaWx5IHRvIGxvb2sgdXAgYCRyZWZgc1xuICogQHBhcmFtIFtmb3JtRGF0YV0gLSBUaGUgY3VycmVudCBmb3JtRGF0YSwgaWYgYW55LCB0byBhc3Npc3QgcmV0cmlldmluZyBhIHNjaGVtYVxuICogQHJldHVybnMgLSBUaGUgYFBhdGhTY2hlbWFgIG9iamVjdCBmb3IgdGhlIGBzY2hlbWFgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvUGF0aFNjaGVtYSh2YWxpZGF0b3IsIHNjaGVtYSwgbmFtZSA9ICcnLCByb290U2NoZW1hLCBmb3JtRGF0YSkge1xuICAgIHJldHVybiB0b1BhdGhTY2hlbWFJbnRlcm5hbCh2YWxpZGF0b3IsIHNjaGVtYSwgbmFtZSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9QYXRoU2NoZW1hLmpzLm1hcCIsImltcG9ydCBkZWVwRXF1YWxzIGZyb20gJy4vZGVlcEVxdWFscyc7XG4vKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBgY29tcG9uZW50YCBzaG91bGQgYmUgcmVyZW5kZXJlZCBieSBjb21wYXJpbmcgaXRzIGN1cnJlbnQgc2V0IG9mIHByb3BzIGFuZCBzdGF0ZVxuICogYWdhaW5zdCB0aGUgbmV4dCBzZXQuIElmIGVpdGhlciBvZiB0aG9zZSB0d28gc2V0cyBhcmUgbm90IHRoZSBzYW1lLCB0aGVuIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHJlcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIEEgUmVhY3QgY29tcG9uZW50IGJlaW5nIGNoZWNrZWRcbiAqIEBwYXJhbSBuZXh0UHJvcHMgLSBUaGUgbmV4dCBzZXQgb2YgcHJvcHMgYWdhaW5zdCB3aGljaCB0byBjaGVja1xuICogQHBhcmFtIG5leHRTdGF0ZSAtIFRoZSBuZXh0IHNldCBvZiBzdGF0ZSBhZ2FpbnN0IHdoaWNoIHRvIGNoZWNrXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgcmUtcmVuZGVyZWQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaG91bGRSZW5kZXIoY29tcG9uZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIGNvbnN0IHsgcHJvcHMsIHN0YXRlIH0gPSBjb21wb25lbnQ7XG4gICAgcmV0dXJuICFkZWVwRXF1YWxzKHByb3BzLCBuZXh0UHJvcHMpIHx8ICFkZWVwRXF1YWxzKHN0YXRlLCBuZXh0U3RhdGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hvdWxkUmVuZGVyLmpzLm1hcCIsImltcG9ydCB7IENPTlNUX0tFWSwgRU5VTV9LRVkgfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKiogUmV0dXJucyB0aGUgY29uc3RhbnQgdmFsdWUgZnJvbSB0aGUgc2NoZW1hIHdoZW4gaXQgaXMgZWl0aGVyIGEgc2luZ2xlIHZhbHVlIGVudW0gb3IgaGFzIGEgY29uc3Qga2V5LiBPdGhlcndpc2VcbiAqIHRocm93cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBmcm9tIHdoaWNoIHRvIG9idGFpbiB0aGUgY29uc3RhbnQgdmFsdWVcbiAqIEByZXR1cm5zIC0gVGhlIGNvbnN0YW50IHZhbHVlIGZvciB0aGUgc2NoZW1hXG4gKiBAdGhyb3dzIC0gRXJyb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXMgbm90IGhhdmUgYSBjb25zdGFudCB2YWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0NvbnN0YW50KHNjaGVtYSkge1xuICAgIGlmIChFTlVNX0tFWSBpbiBzY2hlbWEgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZW51bVswXTtcbiAgICB9XG4gICAgaWYgKENPTlNUX0tFWSBpbiBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jb25zdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgY2Fubm90IGJlIGluZmVycmVkIGFzIGEgY29uc3RhbnQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvQ29uc3RhbnQuanMubWFwIiwiLyoqIFJldHVybnMgYSBVVEMgZGF0ZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBgZGF0ZU9iamVjdGAuIElmIGB0aW1lYCBpcyBmYWxzZSwgdGhlbiB0aGUgdGltZSBwb3J0aW9uIG9mIHRoZSBzdHJpbmcgaXNcbiAqIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIGRhdGVPYmplY3QgLSBUaGUgYERhdGVPYmplY3RgIHRvIGNvbnZlcnQgdG8gYSBkYXRlIHN0cmluZ1xuICogQHBhcmFtIFt0aW1lPXRydWVdIC0gT3B0aW9uYWwgZmxhZyB1c2VkIHRvIHJlbW92ZSB0aGUgdGltZSBwb3J0aW9uIG9mIHRoZSBkYXRlIHN0cmluZyBpZiBmYWxzZVxuICogQHJldHVybnMgLSBUaGUgVVRDIGRhdGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvRGF0ZVN0cmluZyhkYXRlT2JqZWN0LCB0aW1lID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSwgaG91ciA9IDAsIG1pbnV0ZSA9IDAsIHNlY29uZCA9IDAgfSA9IGRhdGVPYmplY3Q7XG4gICAgY29uc3QgdXRjVGltZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCk7XG4gICAgY29uc3QgZGF0ZXRpbWUgPSBuZXcgRGF0ZSh1dGNUaW1lKS50b0pTT04oKTtcbiAgICByZXR1cm4gdGltZSA/IGRhdGV0aW1lIDogZGF0ZXRpbWUuc2xpY2UoMCwgMTApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9EYXRlU3RyaW5nLmpzLm1hcCIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB7IEVSUk9SU19LRVkgfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKiogQ29udmVydHMgYW4gYGVycm9yU2NoZW1hYCBpbnRvIGEgbGlzdCBvZiBgUkpTRlZhbGlkYXRpb25FcnJvcnNgXG4gKlxuICogQHBhcmFtIGVycm9yU2NoZW1hIC0gVGhlIGBFcnJvclNjaGVtYWAgaW5zdGFuY2UgdG8gY29udmVydFxuICogQHBhcmFtIFtmaWVsZFBhdGg9W11dIC0gVGhlIGN1cnJlbnQgZmllbGQgcGF0aCwgZGVmYXVsdHMgdG8gW10gaWYgbm90IHNwZWNpZmllZFxuICogQHJldHVybnMgLSBUaGUgbGlzdCBvZiBgUkpTRlZhbGlkYXRpb25FcnJvcnNgIGV4dHJhY3RlZCBmcm9tIHRoZSBgZXJyb3JTY2hlbWFgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvRXJyb3JMaXN0KGVycm9yU2NoZW1hLCBmaWVsZFBhdGggPSBbXSkge1xuICAgIGlmICghZXJyb3JTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgZXJyb3JMaXN0ID0gW107XG4gICAgaWYgKEVSUk9SU19LRVkgaW4gZXJyb3JTY2hlbWEpIHtcbiAgICAgICAgZXJyb3JMaXN0ID0gZXJyb3JMaXN0LmNvbmNhdChlcnJvclNjaGVtYVtFUlJPUlNfS0VZXS5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gYC4ke2ZpZWxkUGF0aC5qb2luKCcuJyl9YDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBzdGFjazogYCR7cHJvcGVydHl9ICR7bWVzc2FnZX1gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZXJyb3JTY2hlbWEpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGtleSAhPT0gRVJST1JTX0tFWSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRTY2hlbWEgPSBlcnJvclNjaGVtYVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY2hpbGRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmNvbmNhdCh0b0Vycm9yTGlzdChjaGlsZFNjaGVtYSwgWy4uLmZpZWxkUGF0aCwga2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgZXJyb3JMaXN0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvRXJyb3JMaXN0LmpzLm1hcCIsImltcG9ydCB0b1BhdGggZnJvbSAnbG9kYXNoL3RvUGF0aCc7XG5pbXBvcnQgRXJyb3JTY2hlbWFCdWlsZGVyIGZyb20gJy4vRXJyb3JTY2hlbWFCdWlsZGVyJztcbi8qKiBUcmFuc2Zvcm1zIGEgcmpzZiB2YWxpZGF0aW9uIGVycm9ycyBsaXN0OlxuICogW1xuICogICB7cHJvcGVydHk6ICcubGV2ZWwxLmxldmVsMlsyXS5sZXZlbDMnLCBtZXNzYWdlOiAnZXJyIGEnfSxcbiAqICAge3Byb3BlcnR5OiAnLmxldmVsMS5sZXZlbDJbMl0ubGV2ZWwzJywgbWVzc2FnZTogJ2VyciBiJ30sXG4gKiAgIHtwcm9wZXJ0eTogJy5sZXZlbDEubGV2ZWwyWzRdLmxldmVsMycsIG1lc3NhZ2U6ICdlcnIgYid9LFxuICogXVxuICogSW50byBhbiBlcnJvciB0cmVlOlxuICoge1xuICogICBsZXZlbDE6IHtcbiAqICAgICBsZXZlbDI6IHtcbiAqICAgICAgIDI6IHtsZXZlbDM6IHtlcnJvcnM6IFsnZXJyIGEnLCAnZXJyIGInXX19LFxuICogICAgICAgNDoge2xldmVsMzoge2Vycm9yczogWydlcnIgYiddfX0sXG4gKiAgICAgfVxuICogICB9XG4gKiB9O1xuICpcbiAqIEBwYXJhbSBlcnJvcnMgLSBUaGUgbGlzdCBvZiBSSlNGVmFsaWRhdGlvbkVycm9yIG9iamVjdHNcbiAqIEByZXR1cm5zIC0gVGhlIGBFcnJvclNjaGVtYWAgYnVpbHQgZnJvbSB0aGUgbGlzdCBvZiBgUkpTRlZhbGlkYXRpb25FcnJvcnNgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvRXJyb3JTY2hlbWEoZXJyb3JzKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBFcnJvclNjaGVtYUJ1aWxkZXIoKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBlcnJvcnMuZm9yRWFjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcGVydHksIG1lc3NhZ2UgfSA9IGVycm9yO1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgcHJvcGVydHkgaXMgdGhlIHJvb3QgZWxlbWVudCwganVzdCB1c2UgYW4gZW1wdHkgYXJyYXkgZm9yIHRoZSBwYXRoXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcHJvcGVydHkgPT09ICcuJyA/IFtdIDogdG9QYXRoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBhdCB0aGUgcm9vdCAoLmxldmVsMSkgdGhlbiB0b1BhdGggY3JlYXRlc1xuICAgICAgICAgICAgLy8gYW4gZW1wdHkgYXJyYXkgZWxlbWVudCBhdCB0aGUgZmlyc3QgaW5kZXguIFJlbW92ZSBpdC5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRFcnJvcnMobWVzc2FnZSwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlci5FcnJvclNjaGVtYTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvRXJyb3JTY2hlbWEuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoL2lzUGxhaW5PYmplY3QnO1xuLyoqIFVud3JhcHMgdGhlIGBlcnJvckhhbmRsZXJgIHN0cnVjdHVyZSBpbnRvIHRoZSBhc3NvY2lhdGVkIGBFcnJvclNjaGVtYWAsIHN0cmlwcGluZyB0aGUgYGFkZEVycm9yKClgIGZ1bmN0aW9ucyBmcm9tIGl0XG4gKlxuICogQHBhcmFtIGVycm9ySGFuZGxlciAtIFRoZSBgRm9ybVZhbGlkYXRpb25gIGVycm9yIGhhbmRsaW5nIHN0cnVjdHVyZVxuICogQHJldHVybnMgLSBUaGUgYEVycm9yU2NoZW1hYCByZXN1bHRpbmcgZnJvbSB0aGUgc3RyaXBwaW5nIG9mIHRoZSBgYWRkRXJyb3IoKWAgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW53cmFwRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlcnJvckhhbmRsZXIpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2FkZEVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gZXJyb3JIYW5kbGVyW2tleV07XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChjaGlsZFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiB1bndyYXBFcnJvckhhbmRsZXIoY2hpbGRTY2hlbWEpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtrZXldOiBjaGlsZFNjaGVtYSB9O1xuICAgICAgICB9XG4gICAgfSwge30pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW53cmFwRXJyb3JIYW5kbGVyLmpzLm1hcCIsImltcG9ydCBwYWQgZnJvbSAnLi9wYWQnO1xuLyoqIENvbnZlcnRzIGEgVVRDIGRhdGUgc3RyaW5nIGludG8gYSBsb2NhbCBEYXRlIGZvcm1hdFxuICpcbiAqIEBwYXJhbSBqc29uRGF0ZSAtIEEgVVRDIGRhdGUgc3RyaW5nXG4gKiBAcmV0dXJucyAtIEFuIGVtcHR5IHN0cmluZyB3aGVuIGBqc29uRGF0ZWAgaXMgZmFsc2V5LCBvdGhlcndpc2UgYSBkYXRlIHN0cmluZyBpbiBsb2NhbCBmb3JtYXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXRjVG9Mb2NhbChqc29uRGF0ZSkge1xuICAgIGlmICghanNvbkRhdGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyByZXF1aXJlZCBmb3JtYXQgb2YgYCd5eXl5LU1NLWRkVGhoOm1tJyBmb2xsb3dlZCBieSBvcHRpb25hbCAnOnNzJyBvciAnOnNzLlNTUydcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnB1dC5odG1sI2xvY2FsLWRhdGUtYW5kLXRpbWUtc3RhdGUtKHR5cGUlM0RkYXRldGltZS1sb2NhbClcbiAgICAvLyA+IHNob3VsZCBiZSBhIF92YWxpZCBsb2NhbCBkYXRlIGFuZCB0aW1lIHN0cmluZ18gKG5vdCBHTVQpXG4gICAgLy8gTm90ZSAtIGRhdGUgY29uc3RydWN0b3IgcGFzc2VkIGxvY2FsIElTTy04NjAxIGRvZXMgbm90IGNvcnJlY3RseVxuICAgIC8vIGNoYW5nZSB0aW1lIHRvIFVUQyBpbiBub2RlIHByZS04XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGpzb25EYXRlKTtcbiAgICBjb25zdCB5eXl5ID0gcGFkKGRhdGUuZ2V0RnVsbFllYXIoKSwgNCk7XG4gICAgY29uc3QgTU0gPSBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgY29uc3QgZGQgPSBwYWQoZGF0ZS5nZXREYXRlKCksIDIpO1xuICAgIGNvbnN0IGhoID0gcGFkKGRhdGUuZ2V0SG91cnMoKSwgMik7XG4gICAgY29uc3QgbW0gPSBwYWQoZGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICAgIGNvbnN0IHNzID0gcGFkKGRhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgICBjb25zdCBTU1MgPSBwYWQoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgMyk7XG4gICAgcmV0dXJuIGAke3l5eXl9LSR7TU19LSR7ZGR9VCR7aGh9OiR7bW19OiR7c3N9LiR7U1NTfWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGNUb0xvY2FsLmpzLm1hcCIsImltcG9ydCBpc0VtcHR5IGZyb20gJ2xvZGFzaC9pc0VtcHR5JztcbmltcG9ydCBtZXJnZU9iamVjdHMgZnJvbSAnLi9tZXJnZU9iamVjdHMnO1xuaW1wb3J0IHRvRXJyb3JMaXN0IGZyb20gJy4vdG9FcnJvckxpc3QnO1xuLyoqIE1lcmdlcyB0aGUgZXJyb3JzIGluIGBhZGRpdGlvbmFsRXJyb3JTY2hlbWFgIGludG8gdGhlIGV4aXN0aW5nIGB2YWxpZGF0aW9uRGF0YWAgYnkgY29tYmluaW5nIHRoZSBoaWVyYXJjaGllcyBpbiB0aGVcbiAqIHR3byBgRXJyb3JTY2hlbWFgcyBhbmQgdGhlbiBhcHBlbmRpbmcgdGhlIGVycm9yIGxpc3QgZnJvbSB0aGUgYGFkZGl0aW9uYWxFcnJvclNjaGVtYWAgb2J0YWluZWQgYnkgY2FsbGluZ1xuICogYHRvRXJyb3JMaXN0KClgIG9uIHRoZSBgZXJyb3JzYCBpbiB0aGUgYHZhbGlkYXRpb25EYXRhYC4gSWYgbm8gYGFkZGl0aW9uYWxFcnJvclNjaGVtYWAgaXMgcGFzc2VkLCB0aGVuXG4gKiBgdmFsaWRhdGlvbkRhdGFgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0aW9uRGF0YSAtIFRoZSBjdXJyZW50IGBWYWxpZGF0aW9uRGF0YWAgaW50byB3aGljaCB0byBtZXJnZSB0aGUgYWRkaXRpb25hbCBlcnJvcnNcbiAqIEBwYXJhbSBbYWRkaXRpb25hbEVycm9yU2NoZW1hXSAtIFRoZSBvcHRpb25hbCBhZGRpdGlvbmFsIHNldCBvZiBlcnJvcnMgaW4gYW4gYEVycm9yU2NoZW1hYFxuICogQHJldHVybnMgLSBUaGUgYHZhbGlkYXRpb25EYXRhYCB3aXRoIHRoZSBhZGRpdGlvbmFsIGVycm9ycyBmcm9tIGBhZGRpdGlvbmFsRXJyb3JTY2hlbWFgIG1lcmdlZCBpbnRvIGl0LCBpZiBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGlvbkRhdGFNZXJnZSh2YWxpZGF0aW9uRGF0YSwgYWRkaXRpb25hbEVycm9yU2NoZW1hKSB7XG4gICAgaWYgKCFhZGRpdGlvbmFsRXJyb3JTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25EYXRhO1xuICAgIH1cbiAgICBjb25zdCB7IGVycm9yczogb2xkRXJyb3JzLCBlcnJvclNjaGVtYTogb2xkRXJyb3JTY2hlbWEgfSA9IHZhbGlkYXRpb25EYXRhO1xuICAgIGxldCBlcnJvcnMgPSB0b0Vycm9yTGlzdChhZGRpdGlvbmFsRXJyb3JTY2hlbWEpO1xuICAgIGxldCBlcnJvclNjaGVtYSA9IGFkZGl0aW9uYWxFcnJvclNjaGVtYTtcbiAgICBpZiAoIWlzRW1wdHkob2xkRXJyb3JTY2hlbWEpKSB7XG4gICAgICAgIGVycm9yU2NoZW1hID0gbWVyZ2VPYmplY3RzKG9sZEVycm9yU2NoZW1hLCBhZGRpdGlvbmFsRXJyb3JTY2hlbWEsIHRydWUpO1xuICAgICAgICBlcnJvcnMgPSBbLi4ub2xkRXJyb3JzXS5jb25jYXQoZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3JTY2hlbWEsIGVycm9ycyB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbkRhdGFNZXJnZS5qcy5tYXAiLCJpbXBvcnQgeyBSRUZfS0VZLCBST09UX1NDSEVNQV9QUkVGSVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnbG9kYXNoL2lzT2JqZWN0Jztcbi8qKiBUYWtlcyBhIGBub2RlYCBvYmplY3QgYW5kIHRyYW5zZm9ybXMgYW55IGNvbnRhaW5lZCBgJHJlZmAgbm9kZSB2YXJpYWJsZXMgd2l0aCBhIHByZWZpeCwgcmVjdXJzaXZlbHkgY2FsbGluZ1xuICogYHdpdGhJZFJlZlByZWZpeGAgZm9yIGFueSBvdGhlciBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBvYmplY3Qgbm9kZSB0byB3aGljaCBhIFJPT1RfU0NIRU1BX1BSRUZJWCBpcyBhZGRlZCB3aGVuIGEgUkVGX0tFWSBpcyBwYXJ0IG9mIGl0XG4gKi9cbmZ1bmN0aW9uIHdpdGhJZFJlZlByZWZpeE9iamVjdChub2RlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xuICAgICAgICBjb25zdCByZWFsT2JqID0gbm9kZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZWFsT2JqW2tleV07XG4gICAgICAgIGlmIChrZXkgPT09IFJFRl9LRVkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgICAgIHJlYWxPYmpba2V5XSA9IFJPT1RfU0NIRU1BX1BSRUZJWCArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVhbE9ialtrZXldID0gd2l0aElkUmVmUHJlZml4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKiBUYWtlcyBhIGBub2RlYCBvYmplY3QgbGlzdCBhbmQgdHJhbnNmb3JtcyBhbnkgY29udGFpbmVkIGAkcmVmYCBub2RlIHZhcmlhYmxlcyB3aXRoIGEgcHJlZml4LCByZWN1cnNpdmVseSBjYWxsaW5nXG4gKiBgd2l0aElkUmVmUHJlZml4YCBmb3IgYW55IG90aGVyIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBub2RlIC0gVGhlIGxpc3Qgb2Ygb2JqZWN0IG5vZGVzIHRvIHdoaWNoIGEgUk9PVF9TQ0hFTUFfUFJFRklYIGlzIGFkZGVkIHdoZW4gYSBSRUZfS0VZIGlzIHBhcnQgb2YgaXRcbiAqL1xuZnVuY3Rpb24gd2l0aElkUmVmUHJlZml4QXJyYXkobm9kZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlW2ldID0gd2l0aElkUmVmUHJlZml4KG5vZGVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKiBSZWN1cnNpdmVseSBwcmVmaXhlcyBhbGwgYCRyZWZgcyBpbiBhIHNjaGVtYSB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgYFJPT1RfU0NIRU1BX1BSRUZJWGAgY29uc3RhbnQuXG4gKiBUaGlzIGlzIHVzZWQgaW4gaXNWYWxpZCB0byBtYWtlIHJlZmVyZW5jZXMgdG8gdGhlIHJvb3RTY2hlbWFcbiAqXG4gKiBAcGFyYW0gc2NoZW1hTm9kZSAtIFRoZSBvYmplY3Qgbm9kZSB0byB3aGljaCBhIFJPT1RfU0NIRU1BX1BSRUZJWCBpcyBhZGRlZCB3aGVuIGEgUkVGX0tFWSBpcyBwYXJ0IG9mIGl0XG4gKiBAcmV0dXJucyAtIEEgY29weSBvZiB0aGUgYHNjaGVtYU5vZGVgIHdpdGggdXBkYXRlZCBgJHJlZmBzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhJZFJlZlByZWZpeChzY2hlbWFOb2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHdpdGhJZFJlZlByZWZpeEFycmF5KFsuLi5zY2hlbWFOb2RlXSk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzY2hlbWFOb2RlKSkge1xuICAgICAgICByZXR1cm4gd2l0aElkUmVmUHJlZml4T2JqZWN0KHsgLi4uc2NoZW1hTm9kZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYU5vZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoSWRSZWZQcmVmaXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLWFycmF5JyApLFxuXHRpc0ludGVnZXJBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1pbnRlZ2VyLWFycmF5JyApLFxuXHRpc0Z1bmN0aW9uID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLWZ1bmN0aW9uJyApO1xuXG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgTUFYSU5UID0gTWF0aC5wb3coIDIsIDMxICkgLSAxO1xuXG5cbi8vIEZVTkNUSU9OUyAvL1xuXG4vKipcbiogRlVOQ1RJT046IGdjZCggYSwgYiApXG4qXHRDb21wdXRlcyB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgdHdvIGludGVnZXJzIGBhYCBhbmQgYGJgLCB1c2luZyB0aGUgYmluYXJ5IEdDRCBhbGdvcml0aG0uXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBhIC0gaW50ZWdlclxuKiBAcGFyYW0ge051bWJlcn0gYiAtIGludGVnZXJcbiogQHJldHVybnMge051bWJlcn0gZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3JcbiovXG5mdW5jdGlvbiBnY2QoIGEsIGIgKSB7XG5cdHZhciBrID0gMSxcblx0XHR0O1xuXHQvLyBTaW1wbGUgY2FzZXM6XG5cdGlmICggYSA9PT0gMCApIHtcblx0XHRyZXR1cm4gYjtcblx0fVxuXHRpZiAoIGIgPT09IDAgKSB7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblx0Ly8gUmVkdWNlIGBhYCBhbmQvb3IgYGJgIHRvIG9kZCBudW1iZXJzIGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBncmVhdGVzdCBwb3dlciBvZiAyIGRpdmlkaW5nIGJvdGggYGFgIGFuZCBgYmAuLi5cblx0d2hpbGUgKCBhJTIgPT09IDAgJiYgYiUyID09PSAwICkge1xuXHRcdGEgPSBhIC8gMjsgLy8gcmlnaHQgc2hpZnRcblx0XHRiID0gYiAvIDI7IC8vIHJpZ2h0IHNoaWZ0XG5cdFx0ayA9IGsgKiAyOyAvLyBsZWZ0IHNoaWZ0XG5cdH1cblx0Ly8gUmVkdWNlIGBhYCB0byBhbiBvZGQgbnVtYmVyLi4uXG5cdHdoaWxlICggYSUyID09PSAwICkge1xuXHRcdGEgPSBhIC8gMjsgLy8gcmlnaHQgc2hpZnRcblx0fVxuXHQvLyBIZW5jZWZvcnRoLCBgYWAgaXMgYWx3YXlzIG9kZC4uLlxuXHR3aGlsZSAoIGIgKSB7XG5cdFx0Ly8gUmVtb3ZlIGFsbCBmYWN0b3JzIG9mIDIgaW4gYGJgLCBhcyB0aGV5IGFyZSBub3QgY29tbW9uLi4uXG5cdFx0d2hpbGUgKCBiJTIgPT09IDAgKSB7XG5cdFx0XHRiID0gYiAvIDI7IC8vIHJpZ2h0IHNoaWZ0XG5cdFx0fVxuXHRcdC8vIGBhYCBhbmQgYGJgIGFyZSBib3RoIG9kZC4gU3dhcCB2YWx1ZXMgc3VjaCB0aGF0IGBiYCBpcyB0aGUgbGFyZ2VyIG9mIHRoZSB0d28gdmFsdWVzLCBhbmQgdGhlbiBzZXQgYGJgIHRvIHRoZSBkaWZmZXJlbmNlICh3aGljaCBpcyBldmVuKS4uLlxuXHRcdGlmICggYSA+IGIgKSB7XG5cdFx0XHR0ID0gYjtcblx0XHRcdGIgPSBhO1xuXHRcdFx0YSA9IHQ7XG5cdFx0fVxuXHRcdGIgPSBiIC0gYTsgLy8gYj0wIGlmZiBiPWFcblx0fVxuXHQvLyBSZXN0b3JlIGNvbW1vbiBmYWN0b3JzIG9mIDIuLi5cblx0cmV0dXJuIGsgKiBhO1xufSAvLyBlbmQgRlVOQ1RJT04gZ2NkKClcblxuLyoqXG4qIEZVTkNUSU9OOiBiaXR3aXNlKCBhLCBiIClcbipcdENvbXB1dGVzIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB0d28gaW50ZWdlcnMgYGFgIGFuZCBgYmAsIHVzaW5nIHRoZSBiaW5hcnkgR0NEIGFsZ29yaXRobSBhbmQgYml0d2lzZSBvcGVyYXRpb25zLlxuKlxuKiBAcGFyYW0ge051bWJlcn0gYSAtIHNhZmUgaW50ZWdlclxuKiBAcGFyYW0ge051bWJlcn0gYiAtIHNhZmUgaW50ZWdlclxuKiBAcmV0dXJucyB7TnVtYmVyfSBncmVhdGVzdCBjb21tb24gZGl2aXNvclxuKi9cbmZ1bmN0aW9uIGJpdHdpc2UoIGEsIGIgKSB7XG5cdHZhciBrID0gMCxcblx0XHR0O1xuXHQvLyBTaW1wbGUgY2FzZXM6XG5cdGlmICggYSA9PT0gMCApIHtcblx0XHRyZXR1cm4gYjtcblx0fVxuXHRpZiAoIGIgPT09IDAgKSB7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblx0Ly8gUmVkdWNlIGBhYCBhbmQvb3IgYGJgIHRvIG9kZCBudW1iZXJzIGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBncmVhdGVzdCBwb3dlciBvZiAyIGRpdmlkaW5nIGJvdGggYGFgIGFuZCBgYmAuLi5cblx0d2hpbGUgKCAoYSAmIDEpID09PSAwICYmIChiICYgMSkgPT09IDAgKSB7XG5cdFx0YSA+Pj49IDE7IC8vIHJpZ2h0IHNoaWZ0XG5cdFx0YiA+Pj49IDE7IC8vIHJpZ2h0IHNoaWZ0XG5cdFx0aysrO1xuXHR9XG5cdC8vIFJlZHVjZSBgYWAgdG8gYW4gb2RkIG51bWJlci4uLlxuXHR3aGlsZSAoIChhICYgMSkgPT09IDAgKSB7XG5cdFx0YSA+Pj49IDE7IC8vIHJpZ2h0IHNoaWZ0XG5cdH1cblx0Ly8gSGVuY2Vmb3J0aCwgYGFgIGlzIGFsd2F5cyBvZGQuLi5cblx0d2hpbGUgKCBiICkge1xuXHRcdC8vIFJlbW92ZSBhbGwgZmFjdG9ycyBvZiAyIGluIGBiYCwgYXMgdGhleSBhcmUgbm90IGNvbW1vbi4uLlxuXHRcdHdoaWxlICggKGIgJiAxKSA9PT0gMCApIHtcblx0XHRcdGIgPj4+PSAxOyAvLyByaWdodCBzaGlmdFxuXHRcdH1cblx0XHQvLyBgYWAgYW5kIGBiYCBhcmUgYm90aCBvZGQuIFN3YXAgdmFsdWVzIHN1Y2ggdGhhdCBgYmAgaXMgdGhlIGxhcmdlciBvZiB0aGUgdHdvIHZhbHVlcywgYW5kIHRoZW4gc2V0IGBiYCB0byB0aGUgZGlmZmVyZW5jZSAod2hpY2ggaXMgZXZlbikuLi5cblx0XHRpZiAoIGEgPiBiICkge1xuXHRcdFx0dCA9IGI7XG5cdFx0XHRiID0gYTtcblx0XHRcdGEgPSB0O1xuXHRcdH1cblx0XHRiID0gYiAtIGE7IC8vIGI9MCBpZmYgYj1hXG5cdH1cblx0Ly8gUmVzdG9yZSBjb21tb24gZmFjdG9ycyBvZiAyLi4uXG5cdHJldHVybiBhIDw8IGs7XG59IC8vIGVuZCBGVU5DVElPTiBiaXR3aXNlKClcblxuXG4vLyBHUkVBVEVTVCBDT01NT04gRElWSVNPUiAvL1xuXG4vKipcbiogRlVOQ1RJT046IGNvbXB1dGUoIGFyclssIGNsYmtdIClcbipcdENvbXB1dGVzIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvci5cbipcbiogQHBhcmFtIHtOdW1iZXJbXXxOdW1iZXJ9IGFyciAtIGlucHV0IGFycmF5IG9mIGludGVnZXJzXG4qIEBwYXJhbSB7RnVuY3Rpb258TnVtYmVyfSBbY2xia10gLSBhY2Nlc3NvciBmdW5jdGlvbiBmb3IgYWNjZXNzaW5nIGFycmF5IHZhbHVlc1xuKiBAcmV0dXJucyB7TnVtYmVyfE51bGx9IGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIG9yIG51bGxcbiovXG5mdW5jdGlvbiBjb21wdXRlKCkge1xuXHR2YXIgbmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGFyZ3MsXG5cdFx0Y2xiayxcblx0XHRhcnIsXG5cdFx0bGVuLFxuXHRcdGEsIGIsXG5cdFx0aTtcblxuXHQvLyBDb3B5IHRoZSBpbnB1dCBhcmd1bWVudHMgdG8gYW4gYXJyYXkuLi5cblx0YXJncyA9IG5ldyBBcnJheSggbmFyZ3MgKTtcblx0Zm9yICggaSA9IDA7IGkgPCBuYXJnczsgaSsrICkge1xuXHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHR9XG5cdC8vIEhhdmUgd2UgYmVlbiBwcm92aWRlZCB3aXRoIGludGVnZXIgYXJndW1lbnRzP1xuXHRpZiAoIGlzSW50ZWdlckFycmF5KCBhcmdzICkgKSB7XG5cdFx0aWYgKCBuYXJncyA9PT0gMiApIHtcblx0XHRcdGEgPSBhcmdzWyAwIF07XG5cdFx0XHRiID0gYXJnc1sgMSBdO1xuXHRcdFx0aWYgKCBhIDwgMCApIHtcblx0XHRcdFx0YSA9IC1hO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiIDwgMCApIHtcblx0XHRcdFx0YiA9IC1iO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBhIDw9IE1BWElOVCAmJiBiIDw9IE1BWElOVCApIHtcblx0XHRcdFx0cmV0dXJuIGJpdHdpc2UoIGEsIGIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBnY2QoIGEsIGIgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXJyID0gYXJncztcblx0fVxuXHQvLyBJZiBub3QgaW50ZWdlcnMsIGVuc3VyZSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXkuLi5cblx0ZWxzZSBpZiAoICFpc0FycmF5KCBhcmdzWyAwIF0gKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnZ2NkKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBhcnJheSBvZiBpbnRlZ2Vycy4gVmFsdWU6IGAnICsgYXJnc1sgMCBdICsgJ2AuJyApO1xuXHR9XG5cdC8vIEhhdmUgd2UgYmVlbiBwcm92aWRlZCB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQ/IElmIHNvLCBlbnN1cmUgdGhhdCB0aGUgYWNjZXNzb3IgYXJndW1lbnQgaXMgYSBmdW5jdGlvbi4uLlxuXHRlbHNlIGlmICggbmFyZ3MgPiAxICkge1xuXHRcdGFyciA9IGFyZ3NbIDAgXTtcblx0XHRjbGJrID0gYXJnc1sgMSBdO1xuXHRcdGlmICggIWlzRnVuY3Rpb24oIGNsYmsgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdnY2QoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gQWNjZXNzb3IgbXVzdCBiZSBhIGZ1bmN0aW9uLiBWYWx1ZTogYCcgKyBjbGJrICsgJ2AuJyApO1xuXHRcdH1cblx0fVxuXHQvLyBXZSBoYXZlIGJlZW4gcHJvdmlkZWQgYW4gYXJyYXkuLi5cblx0ZWxzZSB7XG5cdFx0YXJyID0gYXJnc1sgMCBdO1xuXHR9XG5cdGxlbiA9IGFyci5sZW5ndGg7XG5cblx0Ly8gQ2hlY2sgaWYgYSBzdWZmaWNpZW50IG51bWJlciBvZiB2YWx1ZXMgaGF2ZSBiZWVuIHByb3ZpZGVkLi4uXG5cdGlmICggbGVuIDwgMiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHQvLyBJZiBhbiBhY2Nlc3NvciBpcyBwcm92aWRlZCwgZXh0cmFjdCB0aGUgYXJyYXkgdmFsdWVzLi4uXG5cdGlmICggY2xiayApIHtcblx0XHRhID0gbmV3IEFycmF5KCBsZW4gKTtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0YVsgaSBdID0gY2xiayggYXJyWyBpIF0sIGkgKTtcblx0XHR9XG5cdFx0YXJyID0gYTtcblx0fVxuXHQvLyBHaXZlbiBhbiBpbnB1dCBhcnJheSwgZW5zdXJlIGFsbCBhcnJheSB2YWx1ZXMgYXJlIGludGVnZXJzLi4uXG5cdGlmICggbmFyZ3MgPCAzICkge1xuXHRcdGlmICggIWlzSW50ZWdlckFycmF5KCBhcnIgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdnY2QoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gQWNjZXNzZWQgYXJyYXkgdmFsdWVzIG11c3QgYmUgaW50ZWdlcnMuIFZhbHVlOiBgJyArIGFyciArICdgLicgKTtcblx0XHR9XG5cdH1cblx0Ly8gQ29udmVydCBhbnkgbmVnYXRpdmUgaW50ZWdlcnMgdG8gcG9zaXRpdmUgaW50ZWdlcnMuLi5cblx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRhID0gYXJyWyBpIF07XG5cdFx0aWYgKCBhIDwgMCApIHtcblx0XHRcdGFyclsgaSBdID0gLWE7XG5cdFx0fVxuXHR9XG5cdC8vIEV4cGxvaXQgdGhlIGZhY3QgdGhhdCB0aGUgZ2NkIGlzIGFuIGFzc29jaWF0aXZlIGZ1bmN0aW9uLi4uXG5cdGEgPSBhcnJbIDAgXTtcblx0Zm9yICggaSA9IDE7IGkgPCBsZW47IGkrKyApIHtcblx0XHRiID0gYXJyWyBpIF07XG5cdFx0aWYgKCBiIDw9IE1BWElOVCAmJiBhIDw9IE1BWElOVCApIHtcblx0XHRcdGEgPSBiaXR3aXNlKCBhLCBiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGEgPSBnY2QoIGEsIGIgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGE7XG59IC8vIGVuZCBGVU5DVElPTiBjb21wdXRlKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcHV0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgZ2NkID0gcmVxdWlyZSggJ2NvbXB1dGUtZ2NkJyApLFxuXHRpc0FycmF5ID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLWFycmF5JyApLFxuXHRpc0ludGVnZXJBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1pbnRlZ2VyLWFycmF5JyApLFxuXHRpc0Z1bmN0aW9uID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLWZ1bmN0aW9uJyApO1xuXG5cbi8vIExFQVNUIENPTU1PTiBNVUxUSVBMRSAvL1xuXG4vKipcbiogRlVOQ1RJT046IGxjbSggYXJyWywgY2xia10gKVxuKlx0Q29tcHV0ZXMgdGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZSAobGNtKS5cbipcbiogQHBhcmFtIHtOdW1iZXJbXXxOdW1iZXJ9IGFyciAtIGlucHV0IGFycmF5IG9mIGludGVnZXJzXG4qIEBwYXJhbSB7RnVuY3Rpb258TnVtYmVyfSBbYWNjZXNzb3JdIC0gYWNjZXNzb3IgZnVuY3Rpb24gZm9yIGFjY2Vzc2luZyBhcnJheSB2YWx1ZXNcbiogQHJldHVybnMge051bWJlcnxOdWxsfSBsZWFzdCBjb21tb24gbXVsdGlwbGUgb3IgbnVsbFxuKi9cbmZ1bmN0aW9uIGxjbSgpIHtcblx0dmFyIG5hcmdzID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRhcmdzLFxuXHRcdGNsYmssXG5cdFx0YXJyLFxuXHRcdGxlbixcblx0XHRhLCBiLFxuXHRcdGk7XG5cblx0Ly8gQ29weSB0aGUgaW5wdXQgYXJndW1lbnRzIHRvIGFuIGFycmF5Li4uXG5cdGFyZ3MgPSBuZXcgQXJyYXkoIG5hcmdzICk7XG5cdGZvciAoIGkgPSAwOyBpIDwgbmFyZ3M7IGkrKyApIHtcblx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0fVxuXHQvLyBIYXZlIHdlIGJlZW4gcHJvdmlkZWQgd2l0aCBpbnRlZ2VyIGFyZ3VtZW50cz9cblx0aWYgKCBpc0ludGVnZXJBcnJheSggYXJncyApICkge1xuXHRcdGlmICggbmFyZ3MgPT09IDIgKSB7XG5cdFx0XHRhID0gYXJnc1sgMCBdO1xuXHRcdFx0YiA9IGFyZ3NbIDEgXTtcblx0XHRcdGlmICggYSA8IDAgKSB7XG5cdFx0XHRcdGEgPSAtYTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA8IDAgKSB7XG5cdFx0XHRcdGIgPSAtYjtcblx0XHRcdH1cblx0XHRcdGlmICggYSA9PT0gMCB8fCBiID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoIGEvZ2NkKGEsYikgKSAqIGI7XG5cdFx0fVxuXHRcdGFyciA9IGFyZ3M7XG5cdH1cblx0Ly8gSWYgbm90IGludGVnZXJzLCBlbnN1cmUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXkuLi5cblx0ZWxzZSBpZiAoICFpc0FycmF5KCBhcmdzWyAwIF0gKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnbGNtKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBhcnJheSBvZiBpbnRlZ2Vycy4gVmFsdWU6IGAnICsgYXJnc1sgMCBdICsgJ2AuJyApO1xuXHR9XG5cdC8vIEhhdmUgd2UgYmVlbiBwcm92aWRlZCB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQ/IElmIHNvLCBlbnN1cmUgdGhhdCB0aGUgYWNjZXNzb3IgYXJndW1lbnQgaXMgYSBmdW5jdGlvbi4uLlxuXHRlbHNlIGlmICggbmFyZ3MgPiAxICkge1xuXHRcdGFyciA9IGFyZ3NbIDAgXTtcblx0XHRjbGJrID0gYXJnc1sgMSBdO1xuXHRcdGlmICggIWlzRnVuY3Rpb24oIGNsYmsgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdsY20oKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gQWNjZXNzb3IgbXVzdCBiZSBhIGZ1bmN0aW9uLiBWYWx1ZTogYCcgKyBjbGJrICsgJ2AuJyApO1xuXHRcdH1cblx0fVxuXHQvLyBXZSBoYXZlIGJlZW4gcHJvdmlkZWQgYW4gYXJyYXkuLi5cblx0ZWxzZSB7XG5cdFx0YXJyID0gYXJnc1sgMCBdO1xuXHR9XG5cdGxlbiA9IGFyci5sZW5ndGg7XG5cblx0Ly8gQ2hlY2sgaWYgYSBzdWZmaWNpZW50IG51bWJlciBvZiB2YWx1ZXMgaGF2ZSBiZWVuIHByb3ZpZGVkLi4uXG5cdGlmICggbGVuIDwgMiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHQvLyBJZiBhbiBhY2Nlc3NvciBpcyBwcm92aWRlZCwgZXh0cmFjdCB0aGUgYXJyYXkgdmFsdWVzLi4uXG5cdGlmICggY2xiayApIHtcblx0XHRhID0gbmV3IEFycmF5KCBsZW4gKTtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0YVsgaSBdID0gY2xiayggYXJyWyBpIF0sIGkgKTtcblx0XHR9XG5cdFx0YXJyID0gYTtcblx0fVxuXHQvLyBHaXZlbiBhbiBpbnB1dCBhcnJheSwgZW5zdXJlIGFsbCBhcnJheSB2YWx1ZXMgYXJlIGludGVnZXJzLi4uXG5cdGlmICggbmFyZ3MgPCAzICkge1xuXHRcdGlmICggIWlzSW50ZWdlckFycmF5KCBhcnIgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdsY20oKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gQWNjZXNzZWQgYXJyYXkgdmFsdWVzIG11c3QgYmUgaW50ZWdlcnMuIFZhbHVlOiBgJyArIGFyciArICdgLicgKTtcblx0XHR9XG5cdH1cblx0Ly8gQ29udmVydCBhbnkgbmVnYXRpdmUgaW50ZWdlcnMgdG8gcG9zaXRpdmUgaW50ZWdlcnMuLi5cblx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRhID0gYXJyWyBpIF07XG5cdFx0aWYgKCBhIDwgMCApIHtcblx0XHRcdGFyclsgaSBdID0gLWE7XG5cdFx0fVxuXHR9XG5cdC8vIEV4cGxvaXQgdGhlIGZhY3QgdGhhdCB0aGUgbGNtIGlzIGFuIGFzc29jaWF0aXZlIGZ1bmN0aW9uLi4uXG5cdGEgPSBhcnJbIDAgXTtcblx0Zm9yICggaSA9IDE7IGkgPCBsZW47IGkrKyApIHtcblx0XHRiID0gYXJyWyBpIF07XG5cdFx0aWYgKCBhID09PSAwIHx8IGIgPT09IDAgKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0YSA9ICggYS9nY2QoYSxiKSApICogYjtcblx0fVxuXHRyZXR1cm4gYTtcbn0gLy8gZW5kIEZVTkNUSU9OIGxjbSgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxjbTtcbiIsInZhciBpc0VxdWFsID0gcmVxdWlyZSgnbG9kYXNoL2lzRXF1YWwnKVxudmFyIHNvcnRCeSA9IHJlcXVpcmUoJ2xvZGFzaC9zb3J0QnknKVxudmFyIHVuaXEgPSByZXF1aXJlKCdsb2Rhc2gvdW5pcScpXG52YXIgdW5pcVdpdGggPSByZXF1aXJlKCdsb2Rhc2gvdW5pcVdpdGgnKVxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRzJylcbnZhciBpbnRlcnNlY3Rpb25XaXRoID0gcmVxdWlyZSgnbG9kYXNoL2ludGVyc2VjdGlvbldpdGgnKVxudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpXG52YXIgaXNCb29sZWFuID0gcmVxdWlyZSgnbG9kYXNoL2lzQm9vbGVhbicpXG5cbnZhciBub3JtYWxpemVBcnJheSA9IHZhbCA9PiBBcnJheS5pc0FycmF5KHZhbClcbiAgPyB2YWwgOiBbdmFsXVxudmFyIHVuZGVmID0gdmFsID0+IHZhbCA9PT0gdW5kZWZpbmVkXG52YXIga2V5cyA9IG9iaiA9PiBpc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdXG52YXIgaGFzID0gKG9iaiwga2V5KSA9PiBvYmouaGFzT3duUHJvcGVydHkoa2V5KVxudmFyIHN0cmluZ0FycmF5ID0gYXJyID0+IHNvcnRCeSh1bmlxKGFycikpXG52YXIgdW5kZWZFbXB0eSA9IHZhbCA9PiB1bmRlZih2YWwpIHx8IChBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCA9PT0gMClcbnZhciBrZXlWYWxFcXVhbCA9IChhLCBiLCBrZXksIGNvbXBhcmUpID0+IGIgJiYgaGFzKGIsIGtleSkgJiYgYSAmJiBoYXMoYSwga2V5KSAmJiBjb21wYXJlKGFba2V5XSwgYltrZXldKVxudmFyIHVuZGVmQW5kWmVybyA9IChhLCBiKSA9PiAodW5kZWYoYSkgJiYgYiA9PT0gMCkgfHwgKHVuZGVmKGIpICYmIGEgPT09IDApIHx8IGlzRXF1YWwoYSwgYilcbnZhciBmYWxzZVVuZGVmaW5lZCA9IChhLCBiKSA9PiAodW5kZWYoYSkgJiYgYiA9PT0gZmFsc2UpIHx8ICh1bmRlZihiKSAmJiBhID09PSBmYWxzZSkgfHwgaXNFcXVhbChhLCBiKVxudmFyIGVtcHR5U2NoZW1hID0gc2NoZW1hID0+IHVuZGVmKHNjaGVtYSkgfHwgaXNFcXVhbChzY2hlbWEsIHt9KSB8fCBzY2hlbWEgPT09IHRydWVcbnZhciBlbXB0eU9ialVuZGVmID0gc2NoZW1hID0+IHVuZGVmKHNjaGVtYSkgfHwgaXNFcXVhbChzY2hlbWEsIHt9KVxudmFyIGlzU2NoZW1hID0gdmFsID0+IHVuZGVmKHZhbCkgfHwgaXNQbGFpbk9iamVjdCh2YWwpIHx8IHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlXG5cbmZ1bmN0aW9uIHVuZGVmQXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmICh1bmRlZkVtcHR5KGEpICYmIHVuZGVmRW1wdHkoYikpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc0VxdWFsKHN0cmluZ0FycmF5KGEpLCBzdHJpbmdBcnJheShiKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnNvcnRlZE5vcm1hbGl6ZWRBcnJheShhLCBiKSB7XG4gIGEgPSBub3JtYWxpemVBcnJheShhKVxuICBiID0gbm9ybWFsaXplQXJyYXkoYilcbiAgcmV0dXJuIGlzRXF1YWwoc3RyaW5nQXJyYXkoYSksIHN0cmluZ0FycmF5KGIpKVxufVxuXG5mdW5jdGlvbiBzY2hlbWFHcm91cChhLCBiLCBrZXksIGNvbXBhcmUpIHtcbiAgdmFyIGFsbFByb3BzID0gdW5pcShrZXlzKGEpLmNvbmNhdChrZXlzKGIpKSlcbiAgaWYgKGVtcHR5T2JqVW5kZWYoYSkgJiYgZW1wdHlPYmpVbmRlZihiKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoZW1wdHlPYmpVbmRlZihhKSAmJiBrZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGVtcHR5T2JqVW5kZWYoYikgJiYga2V5cyhhKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBhbGxQcm9wcy5ldmVyeShmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgYVZhbCA9IGFba2V5XVxuICAgIHZhciBiVmFsID0gYltrZXldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYVZhbCkgJiYgQXJyYXkuaXNBcnJheShiVmFsKSkge1xuICAgICAgcmV0dXJuIGlzRXF1YWwoc3RyaW5nQXJyYXkoYSksIHN0cmluZ0FycmF5KGIpKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhVmFsKSAmJiAhQXJyYXkuaXNBcnJheShiVmFsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJWYWwpICYmICFBcnJheS5pc0FycmF5KGFWYWwpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbEVxdWFsKGEsIGIsIGtleSwgY29tcGFyZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXRlbXMoYSwgYiwga2V5LCBjb21wYXJlKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICByZXR1cm4gY29tcGFyZShhLCBiKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBzY2hlbWFHcm91cChhLCBiLCBrZXksIGNvbXBhcmUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzRXF1YWwoYSwgYilcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnNvcnRlZEFycmF5KGEsIGIsIGtleSwgY29tcGFyZSkge1xuICB2YXIgdW5pcXVlQSA9IHVuaXFXaXRoKGEsIGNvbXBhcmUpXG4gIHZhciB1bmlxdWVCID0gdW5pcVdpdGgoYiwgY29tcGFyZSlcbiAgdmFyIGludGVyID0gaW50ZXJzZWN0aW9uV2l0aCh1bmlxdWVBLCB1bmlxdWVCLCBjb21wYXJlKVxuICByZXR1cm4gaW50ZXIubGVuZ3RoID09PSBNYXRoLm1heCh1bmlxdWVBLmxlbmd0aCwgdW5pcXVlQi5sZW5ndGgpXG59XG5cbnZhciBjb21wYXJlcnMgPSB7XG4gIHRpdGxlOiBpc0VxdWFsLFxuICB1bmlxdWVJdGVtczogZmFsc2VVbmRlZmluZWQsXG4gIG1pbkxlbmd0aDogdW5kZWZBbmRaZXJvLFxuICBtaW5JdGVtczogdW5kZWZBbmRaZXJvLFxuICBtaW5Qcm9wZXJ0aWVzOiB1bmRlZkFuZFplcm8sXG4gIHJlcXVpcmVkOiB1bmRlZkFycmF5RXF1YWwsXG4gIGVudW06IHVuZGVmQXJyYXlFcXVhbCxcbiAgdHlwZTogdW5zb3J0ZWROb3JtYWxpemVkQXJyYXksXG4gIGl0ZW1zOiBpdGVtcyxcbiAgYW55T2Y6IHVuc29ydGVkQXJyYXksXG4gIGFsbE9mOiB1bnNvcnRlZEFycmF5LFxuICBvbmVPZjogdW5zb3J0ZWRBcnJheSxcbiAgcHJvcGVydGllczogc2NoZW1hR3JvdXAsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiBzY2hlbWFHcm91cCxcbiAgZGVwZW5kZW5jaWVzOiBzY2hlbWFHcm91cFxufVxuXG52YXIgYWNjZXB0c1VuZGVmaW5lZCA9IFtcbiAgJ3Byb3BlcnRpZXMnLFxuICAncGF0dGVyblByb3BlcnRpZXMnLFxuICAnZGVwZW5kZW5jaWVzJyxcbiAgJ3VuaXF1ZUl0ZW1zJyxcbiAgJ21pbkxlbmd0aCcsXG4gICdtaW5JdGVtcycsXG4gICdtaW5Qcm9wZXJ0aWVzJyxcbiAgJ3JlcXVpcmVkJ1xuXVxuXG52YXIgc2NoZW1hUHJvcHMgPSBbJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJywgJ2FkZGl0aW9uYWxJdGVtcycsICdjb250YWlucycsICdwcm9wZXJ0eU5hbWVzJywgJ25vdCddXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgIGlnbm9yZTogW11cbiAgfSlcblxuICBpZiAoZW1wdHlTY2hlbWEoYSkgJiYgZW1wdHlTY2hlbWEoYikpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKCFpc1NjaGVtYShhKSB8fCAhaXNTY2hlbWEoYikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBvZiB0aGUgdmFsdWVzIGFyZSBub3QgYSBKU09OIHNjaGVtYS4nKVxuICB9XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW4oYSkgJiYgaXNCb29sZWFuKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfVxuXG4gIGlmICgoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IGZhbHNlKSB8fCAoYiA9PT0gdW5kZWZpbmVkICYmIGEgPT09IGZhbHNlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCh1bmRlZihhKSAmJiAhdW5kZWYoYikpIHx8ICghdW5kZWYoYSkgJiYgdW5kZWYoYikpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgYWxsS2V5cyA9IHVuaXEoT2JqZWN0LmtleXMoYSkuY29uY2F0KE9iamVjdC5rZXlzKGIpKSlcblxuICBpZiAob3B0aW9ucy5pZ25vcmUubGVuZ3RoKSB7XG4gICAgYWxsS2V5cyA9IGFsbEtleXMuZmlsdGVyKGsgPT4gb3B0aW9ucy5pZ25vcmUuaW5kZXhPZihrKSA9PT0gLTEpXG4gIH1cblxuICBpZiAoIWFsbEtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBhbGxLZXlzLmV2ZXJ5KGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBhVmFsdWUgPSBhW2tleV1cbiAgICB2YXIgYlZhbHVlID0gYltrZXldXG5cbiAgICBpZiAoc2NoZW1hUHJvcHMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoYVZhbHVlLCBiVmFsdWUsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBhcmVyID0gY29tcGFyZXJzW2tleV1cbiAgICBpZiAoIWNvbXBhcmVyKSB7XG4gICAgICBjb21wYXJlciA9IGlzRXF1YWxcbiAgICB9XG5cbiAgICAvLyBkbyBzaW1wbGUgbG9kYXNoIGNoZWNrIGZpcnN0XG4gICAgaWYgKGlzRXF1YWwoYVZhbHVlLCBiVmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChhY2NlcHRzVW5kZWZpbmVkLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGlmICgoIWhhcyhhLCBrZXkpICYmIGhhcyhiLCBrZXkpKSB8fCAoaGFzKGEsIGtleSkgJiYgIWhhcyhiLCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlID09PSBiVmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZXIoYVZhbHVlLCBiVmFsdWUsIGtleSwgaW5uZXJDb21wYXJlKVxuICAgIGlmICghaXNCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcGFyZXIgbXVzdCByZXR1cm4gdHJ1ZSBvciBmYWxzZScpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBmbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoL2ZsYXR0ZW4nKVxuY29uc3QgZmxhdHRlbkRlZXAgPSByZXF1aXJlKCdsb2Rhc2gvZmxhdHRlbkRlZXAnKVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0JylcbmNvbnN0IHVuaXEgPSByZXF1aXJlKCdsb2Rhc2gvdW5pcScpXG5jb25zdCB1bmlxV2l0aCA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxV2l0aCcpXG5jb25zdCB3aXRob3V0ID0gcmVxdWlyZSgnbG9kYXNoL3dpdGhvdXQnKVxuXG5mdW5jdGlvbiBkZWxldGVVbmRlZmluZWRQcm9wcyhyZXR1cm5PYmplY3QpIHtcbiAgLy8gY2xlYW51cCBlbXB0eVxuICBmb3IgKGNvbnN0IHByb3AgaW4gcmV0dXJuT2JqZWN0KSB7XG4gICAgaWYgKGhhcyhyZXR1cm5PYmplY3QsIHByb3ApICYmIGlzRW1wdHlTY2hlbWEocmV0dXJuT2JqZWN0W3Byb3BdKSkge1xuICAgICAgZGVsZXRlIHJldHVybk9iamVjdFtwcm9wXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0dXJuT2JqZWN0XG59XG5cbmNvbnN0IGFsbFVuaXF1ZUtleXMgPSAoYXJyKSA9PiB1bmlxKGZsYXR0ZW5EZWVwKGFyci5tYXAoa2V5cykpKVxuY29uc3QgZ2V0VmFsdWVzID0gKHNjaGVtYXMsIGtleSkgPT4gc2NoZW1hcy5tYXAoc2NoZW1hID0+IHNjaGVtYSAmJiBzY2hlbWFba2V5XSlcbmNvbnN0IGhhcyA9IChvYmosIHByb3BOYW1lKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbmNvbnN0IGtleXMgPSBvYmogPT4ge1xuICBpZiAoaXNQbGFpbk9iamVjdChvYmopIHx8IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuY29uc3Qgbm90VW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsICE9PSB1bmRlZmluZWRcbmNvbnN0IGlzU2NoZW1hID0gKHZhbCkgPT4gaXNQbGFpbk9iamVjdCh2YWwpIHx8IHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlXG5jb25zdCBpc0VtcHR5U2NoZW1hID0gKG9iaikgPT4gKCFrZXlzKG9iaikubGVuZ3RoKSAmJiBvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gdHJ1ZVxuY29uc3Qgd2l0aG91dEFyciA9IChhcnIsIC4uLnJlc3QpID0+IHdpdGhvdXQuYXBwbHkobnVsbCwgW2Fycl0uY29uY2F0KGZsYXR0ZW4ocmVzdCkpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxsVW5pcXVlS2V5cyxcbiAgZGVsZXRlVW5kZWZpbmVkUHJvcHMsXG4gIGdldFZhbHVlcyxcbiAgaGFzLFxuICBpc0VtcHR5U2NoZW1hLFxuICBpc1NjaGVtYSxcbiAga2V5cyxcbiAgbm90VW5kZWZpbmVkLFxuICB1bmlxV2l0aCxcbiAgd2l0aG91dEFyclxufVxuIiwiXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnanNvbi1zY2hlbWEtY29tcGFyZScpXG5jb25zdCBmb3JFYWNoID0gcmVxdWlyZSgnbG9kYXNoL2ZvckVhY2gnKVxuY29uc3Qge1xuICBhbGxVbmlxdWVLZXlzLFxuICBkZWxldGVVbmRlZmluZWRQcm9wcyxcbiAgaGFzLFxuICBpc1NjaGVtYSxcbiAgbm90VW5kZWZpbmVkLFxuICB1bmlxV2l0aFxufSA9IHJlcXVpcmUoJy4uL2NvbW1vbicpXG5cbmZ1bmN0aW9uIHJlbW92ZUZhbHNlU2NoZW1hc0Zyb21BcnJheSh0YXJnZXQpIHtcbiAgZm9yRWFjaCh0YXJnZXQsIGZ1bmN0aW9uKHNjaGVtYSwgaW5kZXgpIHtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgdGFyZ2V0LnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEl0ZW1TY2hlbWFzKHN1YlNjaGVtYXMsIGtleSkge1xuICByZXR1cm4gc3ViU2NoZW1hcy5tYXAoZnVuY3Rpb24oc3ViKSB7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWIuaXRlbXMpKSB7XG4gICAgICBjb25zdCBzY2hlbWFBdFBvcyA9IHN1Yi5pdGVtc1trZXldXG4gICAgICBpZiAoaXNTY2hlbWEoc2NoZW1hQXRQb3MpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFBdFBvc1xuICAgICAgfSBlbHNlIGlmIChoYXMoc3ViLCAnYWRkaXRpb25hbEl0ZW1zJykpIHtcbiAgICAgICAgcmV0dXJuIHN1Yi5hZGRpdGlvbmFsSXRlbXNcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1Yi5pdGVtc1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFNjaGVtYXMoc3ViU2NoZW1hcykge1xuICByZXR1cm4gc3ViU2NoZW1hcy5tYXAoZnVuY3Rpb24oc3ViKSB7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViLml0ZW1zKSkge1xuICAgICAgcmV0dXJuIHN1Yi5hZGRpdGlvbmFsSXRlbXNcbiAgICB9XG4gICAgcmV0dXJuIHN1Yi5pdGVtc1xuICB9KVxufVxuXG4vLyBQcm92aWRlIHNvdXJjZSB3aGVuIGFycmF5XG5mdW5jdGlvbiBtZXJnZUl0ZW1zKGdyb3VwLCBtZXJnZVNjaGVtYXMsIGl0ZW1zKSB7XG4gIGNvbnN0IGFsbEtleXMgPSBhbGxVbmlxdWVLZXlzKGl0ZW1zKVxuICByZXR1cm4gYWxsS2V5cy5yZWR1Y2UoZnVuY3Rpb24oYWxsLCBrZXkpIHtcbiAgICBjb25zdCBzY2hlbWFzID0gZ2V0SXRlbVNjaGVtYXMoZ3JvdXAsIGtleSlcbiAgICBjb25zdCBjb21wYWN0ZWQgPSB1bmlxV2l0aChzY2hlbWFzLmZpbHRlcihub3RVbmRlZmluZWQpLCBjb21wYXJlKVxuICAgIGFsbFtrZXldID0gbWVyZ2VTY2hlbWFzKGNvbXBhY3RlZCwga2V5KVxuICAgIHJldHVybiBhbGxcbiAgfSwgW10pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXl3b3JkczogWydpdGVtcycsICdhZGRpdGlvbmFsSXRlbXMnXSxcbiAgcmVzb2x2ZXIodmFsdWVzLCBwYXJlbnRzLCBtZXJnZXJzKSB7XG4gICAgLy8gY29uc3QgY3JlYXRlU3ViTWVyZ2VyID0gZ3JvdXBLZXkgPT4gKHNjaGVtYXMsIGtleSkgPT4gbWVyZ2VTY2hlbWFzKHNjaGVtYXMsIHBhcmVudHMuY29uY2F0KGdyb3VwS2V5LCBrZXkpKVxuICAgIGNvbnN0IGl0ZW1zID0gdmFsdWVzLm1hcChzID0+IHMuaXRlbXMpXG4gICAgY29uc3QgaXRlbXNDb21wYWN0ZWQgPSBpdGVtcy5maWx0ZXIobm90VW5kZWZpbmVkKVxuICAgIGNvbnN0IHJldHVybk9iamVjdCA9IHt9XG5cbiAgICAvLyBpZiBhbGwgaXRlbXMga2V5d29yZCB2YWx1ZXMgYXJlIHNjaGVtYXMsIHdlIGNhbiBtZXJnZSB0aGVtIGFzIHNpbXBsZSBzY2hlbWFzXG4gICAgLy8gaWYgbm90IHdlIG5lZWQgdG8gbWVyZ2UgdGhlbSBhcyBtaXhlZFxuICAgIGlmIChpdGVtc0NvbXBhY3RlZC5ldmVyeShpc1NjaGVtYSkpIHtcbiAgICAgIHJldHVybk9iamVjdC5pdGVtcyA9IG1lcmdlcnMuaXRlbXMoaXRlbXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybk9iamVjdC5pdGVtcyA9IG1lcmdlSXRlbXModmFsdWVzLCBtZXJnZXJzLml0ZW1zLCBpdGVtcylcbiAgICB9XG5cbiAgICBsZXQgc2NoZW1hc0F0TGFzdFBvc1xuICAgIGlmIChpdGVtc0NvbXBhY3RlZC5ldmVyeShBcnJheS5pc0FycmF5KSkge1xuICAgICAgc2NoZW1hc0F0TGFzdFBvcyA9IHZhbHVlcy5tYXAocyA9PiBzLmFkZGl0aW9uYWxJdGVtcylcbiAgICB9IGVsc2UgaWYgKGl0ZW1zQ29tcGFjdGVkLnNvbWUoQXJyYXkuaXNBcnJheSkpIHtcbiAgICAgIHNjaGVtYXNBdExhc3RQb3MgPSBnZXRBZGRpdGlvbmFsU2NoZW1hcyh2YWx1ZXMpXG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYXNBdExhc3RQb3MpIHtcbiAgICAgIHJldHVybk9iamVjdC5hZGRpdGlvbmFsSXRlbXMgPSBtZXJnZXJzLmFkZGl0aW9uYWxJdGVtcyhzY2hlbWFzQXRMYXN0UG9zKVxuICAgIH1cblxuICAgIGlmIChyZXR1cm5PYmplY3QuYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSAmJiBBcnJheS5pc0FycmF5KHJldHVybk9iamVjdC5pdGVtcykpIHtcbiAgICAgIHJlbW92ZUZhbHNlU2NoZW1hc0Zyb21BcnJheShyZXR1cm5PYmplY3QuaXRlbXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZVVuZGVmaW5lZFByb3BzKHJldHVybk9iamVjdClcbiAgfVxufVxuIiwiXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnanNvbi1zY2hlbWEtY29tcGFyZScpXG5jb25zdCBmb3JFYWNoID0gcmVxdWlyZSgnbG9kYXNoL2ZvckVhY2gnKVxuY29uc3Qge1xuICBhbGxVbmlxdWVLZXlzLFxuICBkZWxldGVVbmRlZmluZWRQcm9wcyxcbiAgZ2V0VmFsdWVzLFxuICBrZXlzLFxuICBub3RVbmRlZmluZWQsXG4gIHVuaXFXaXRoLFxuICB3aXRob3V0QXJyXG59ID0gcmVxdWlyZSgnLi4vY29tbW9uJylcblxuZnVuY3Rpb24gcmVtb3ZlRmFsc2VTY2hlbWFzKHRhcmdldCkge1xuICBmb3JFYWNoKHRhcmdldCwgZnVuY3Rpb24oc2NoZW1hLCBwcm9wKSB7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1lcmdlU2NoZW1hR3JvdXAoZ3JvdXAsIG1lcmdlU2NoZW1hcykge1xuICBjb25zdCBhbGxLZXlzID0gYWxsVW5pcXVlS2V5cyhncm91cClcbiAgcmV0dXJuIGFsbEtleXMucmVkdWNlKGZ1bmN0aW9uKGFsbCwga2V5KSB7XG4gICAgY29uc3Qgc2NoZW1hcyA9IGdldFZhbHVlcyhncm91cCwga2V5KVxuICAgIGNvbnN0IGNvbXBhY3RlZCA9IHVuaXFXaXRoKHNjaGVtYXMuZmlsdGVyKG5vdFVuZGVmaW5lZCksIGNvbXBhcmUpXG4gICAgYWxsW2tleV0gPSBtZXJnZVNjaGVtYXMoY29tcGFjdGVkLCBrZXkpXG4gICAgcmV0dXJuIGFsbFxuICB9LCB7fSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtleXdvcmRzOiBbJ3Byb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnYWRkaXRpb25hbFByb3BlcnRpZXMnXSxcbiAgcmVzb2x2ZXIodmFsdWVzLCBwYXJlbnRzLCBtZXJnZXJzLCBvcHRpb25zKSB7XG4gICAgLy8gZmlyc3QgZ2V0IHJpZCBvZiBhbGwgbm9uIHBlcm1pdHRlZCBwcm9wZXJ0aWVzXG4gICAgaWYgKCFvcHRpb25zLmlnbm9yZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihzdWJTY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJTdWJTY2hlbWFzID0gdmFsdWVzLmZpbHRlcihzID0+IHMgIT09IHN1YlNjaGVtYSlcbiAgICAgICAgY29uc3Qgb3duS2V5cyA9IGtleXMoc3ViU2NoZW1hLnByb3BlcnRpZXMpXG4gICAgICAgIGNvbnN0IG93blBhdHRlcm5LZXlzID0ga2V5cyhzdWJTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgIGNvbnN0IG93blBhdHRlcm5zID0gb3duUGF0dGVybktleXMubWFwKGsgPT4gbmV3IFJlZ0V4cChrKSlcbiAgICAgICAgb3RoZXJTdWJTY2hlbWFzLmZvckVhY2goZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICBjb25zdCBhbGxPdGhlcktleXMgPSBrZXlzKG90aGVyLnByb3BlcnRpZXMpXG4gICAgICAgICAgY29uc3Qga2V5c01hdGNoaW5nUGF0dGVybiA9IGFsbE90aGVyS2V5cy5maWx0ZXIoayA9PiBvd25QYXR0ZXJucy5zb21lKHBrID0+IHBrLnRlc3QoaykpKVxuICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxLZXlzID0gd2l0aG91dEFycihhbGxPdGhlcktleXMsIG93bktleXMsIGtleXNNYXRjaGluZ1BhdHRlcm4pXG4gICAgICAgICAgYWRkaXRpb25hbEtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIG90aGVyLnByb3BlcnRpZXNba2V5XSA9IG1lcmdlcnMucHJvcGVydGllcyhbXG4gICAgICAgICAgICAgIG90aGVyLnByb3BlcnRpZXNba2V5XSwgc3ViU2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgICAgICBdLCBrZXkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIHJlbW92ZSBkaXNhbGxvd2VkIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihzdWJTY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJTdWJTY2hlbWFzID0gdmFsdWVzLmZpbHRlcihzID0+IHMgIT09IHN1YlNjaGVtYSlcbiAgICAgICAgY29uc3Qgb3duUGF0dGVybktleXMgPSBrZXlzKHN1YlNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgaWYgKHN1YlNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvdGhlclN1YlNjaGVtYXMuZm9yRWFjaChmdW5jdGlvbihvdGhlcikge1xuICAgICAgICAgICAgY29uc3QgYWxsT3RoZXJQYXR0ZXJucyA9IGtleXMob3RoZXIucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsUGF0dGVybktleXMgPSB3aXRob3V0QXJyKGFsbE90aGVyUGF0dGVybnMsIG93blBhdHRlcm5LZXlzKVxuICAgICAgICAgICAgYWRkaXRpb25hbFBhdHRlcm5LZXlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBvdGhlci5wYXR0ZXJuUHJvcGVydGllc1trZXldKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuT2JqZWN0ID0ge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IG1lcmdlcnMuYWRkaXRpb25hbFByb3BlcnRpZXModmFsdWVzLm1hcChzID0+IHMuYWRkaXRpb25hbFByb3BlcnRpZXMpKSxcbiAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiBtZXJnZVNjaGVtYUdyb3VwKHZhbHVlcy5tYXAocyA9PiBzLnBhdHRlcm5Qcm9wZXJ0aWVzKSwgbWVyZ2Vycy5wYXR0ZXJuUHJvcGVydGllcyksXG4gICAgICBwcm9wZXJ0aWVzOiBtZXJnZVNjaGVtYUdyb3VwKHZhbHVlcy5tYXAocyA9PiBzLnByb3BlcnRpZXMpLCBtZXJnZXJzLnByb3BlcnRpZXMpXG4gICAgfVxuXG4gICAgaWYgKHJldHVybk9iamVjdC5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJlbW92ZUZhbHNlU2NoZW1hcyhyZXR1cm5PYmplY3QucHJvcGVydGllcylcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlVW5kZWZpbmVkUHJvcHMocmV0dXJuT2JqZWN0KVxuICB9XG59XG4iLCJjb25zdCBjbG9uZURlZXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmVEZWVwJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCdqc29uLXNjaGVtYS1jb21wYXJlJylcbmNvbnN0IGNvbXB1dGVMY20gPSByZXF1aXJlKCdjb21wdXRlLWxjbScpXG5jb25zdCBkZWZhdWx0c0RlZXAgPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdHNEZWVwJylcbmNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCdsb2Rhc2gvZmxhdHRlbicpXG5jb25zdCBmbGF0dGVuRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9mbGF0dGVuRGVlcCcpXG5jb25zdCBpbnRlcnNlY3Rpb24gPSByZXF1aXJlKCdsb2Rhc2gvaW50ZXJzZWN0aW9uJylcbmNvbnN0IGludGVyc2VjdGlvbldpdGggPSByZXF1aXJlKCdsb2Rhc2gvaW50ZXJzZWN0aW9uV2l0aCcpXG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZSgnbG9kYXNoL2lzRXF1YWwnKVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0JylcbmNvbnN0IHB1bGxBbGwgPSByZXF1aXJlKCdsb2Rhc2gvcHVsbEFsbCcpXG5jb25zdCBzb3J0QnkgPSByZXF1aXJlKCdsb2Rhc2gvc29ydEJ5JylcbmNvbnN0IHVuaXEgPSByZXF1aXJlKCdsb2Rhc2gvdW5pcScpXG5jb25zdCB1bmlxV2l0aCA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxV2l0aCcpXG5cbmNvbnN0IHByb3BlcnRpZXNSZXNvbHZlciA9IHJlcXVpcmUoJy4vY29tcGxleC1yZXNvbHZlcnMvcHJvcGVydGllcycpXG5jb25zdCBpdGVtc1Jlc29sdmVyID0gcmVxdWlyZSgnLi9jb21wbGV4LXJlc29sdmVycy9pdGVtcycpXG5cbmNvbnN0IGNvbnRhaW5zID0gKGFyciwgdmFsKSA9PiBhcnIuaW5kZXhPZih2YWwpICE9PSAtMVxuY29uc3QgaXNTY2hlbWEgPSAodmFsKSA9PiBpc1BsYWluT2JqZWN0KHZhbCkgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2VcbmNvbnN0IGlzRmFsc2UgPSAodmFsKSA9PiB2YWwgPT09IGZhbHNlXG5jb25zdCBpc1RydWUgPSAodmFsKSA9PiB2YWwgPT09IHRydWVcbmNvbnN0IHNjaGVtYVJlc29sdmVyID0gKGNvbXBhY3RlZCwga2V5LCBtZXJnZVNjaGVtYXMpID0+IG1lcmdlU2NoZW1hcyhjb21wYWN0ZWQpXG5jb25zdCBzdHJpbmdBcnJheSA9ICh2YWx1ZXMpID0+IHNvcnRCeSh1bmlxKGZsYXR0ZW5EZWVwKHZhbHVlcykpKVxuY29uc3Qgbm90VW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsICE9PSB1bmRlZmluZWRcbmNvbnN0IGFsbFVuaXF1ZUtleXMgPSAoYXJyKSA9PiB1bmlxKGZsYXR0ZW5EZWVwKGFyci5tYXAoa2V5cykpKVxuXG4vLyByZXNvbHZlcnNcbmNvbnN0IGZpcnN0ID0gY29tcGFjdGVkID0+IGNvbXBhY3RlZFswXVxuY29uc3QgcmVxdWlyZWQgPSBjb21wYWN0ZWQgPT4gc3RyaW5nQXJyYXkoY29tcGFjdGVkKVxuY29uc3QgbWF4aW11bVZhbHVlID0gY29tcGFjdGVkID0+IE1hdGgubWF4LmFwcGx5KE1hdGgsIGNvbXBhY3RlZClcbmNvbnN0IG1pbmltdW1WYWx1ZSA9IGNvbXBhY3RlZCA9PiBNYXRoLm1pbi5hcHBseShNYXRoLCBjb21wYWN0ZWQpXG5jb25zdCB1bmlxdWVJdGVtcyA9IGNvbXBhY3RlZCA9PiBjb21wYWN0ZWQuc29tZShpc1RydWUpXG5jb25zdCBleGFtcGxlcyA9IGNvbXBhY3RlZCA9PiB1bmlxV2l0aChmbGF0dGVuKGNvbXBhY3RlZCksIGlzRXF1YWwpXG5cbmZ1bmN0aW9uIGNvbXBhcmVQcm9wKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlKHtcbiAgICAgIFtrZXldOiBhXG4gICAgfSwgeyBba2V5XTogYiB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbE9mKHNjaGVtYSkge1xuICBsZXQgeyBhbGxPZiA9IFtdLCAuLi5jb3B5IH0gPSBzY2hlbWFcbiAgY29weSA9IGlzUGxhaW5PYmplY3Qoc2NoZW1hKSA/IGNvcHkgOiBzY2hlbWEgLy8gaWYgc2NoZW1hIGlzIGJvb2xlYW5cbiAgcmV0dXJuIFtjb3B5LCAuLi5hbGxPZi5tYXAoZ2V0QWxsT2YpXVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoc2NoZW1hcywga2V5KSB7XG4gIHJldHVybiBzY2hlbWFzLm1hcChzY2hlbWEgPT4gc2NoZW1hICYmIHNjaGVtYVtrZXldKVxufVxuXG5mdW5jdGlvbiB0cnlNZXJnZVNjaGVtYUdyb3VwcyhzY2hlbWFHcm91cHMsIG1lcmdlU2NoZW1hcykge1xuICByZXR1cm4gc2NoZW1hR3JvdXBzLm1hcChmdW5jdGlvbihzY2hlbWFzLCBpbmRleCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVyZ2VTY2hlbWFzKHNjaGVtYXMsIGluZGV4KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH0pLmZpbHRlcihub3RVbmRlZmluZWQpXG59XG5cbmZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbnlPZkNvbWJpbmF0aW9ucyhhcnJPZkFycmF5cywgY29tYmluYXRpb25zKSB7XG4gIGNvbWJpbmF0aW9ucyA9IGNvbWJpbmF0aW9ucyB8fCBbXVxuICBpZiAoIWFyck9mQXJyYXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBjb21iaW5hdGlvbnNcbiAgfVxuXG4gIGNvbnN0IHZhbHVlcyA9IGFyck9mQXJyYXlzLnNsaWNlKDApLnNoaWZ0KClcbiAgY29uc3QgcmVzdCA9IGFyck9mQXJyYXlzLnNsaWNlKDEpXG4gIGlmIChjb21iaW5hdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdldEFueU9mQ29tYmluYXRpb25zKHJlc3QsIGZsYXR0ZW4oY29tYmluYXRpb25zLm1hcChjb21iaW5hdGlvbiA9PiB2YWx1ZXMubWFwKGl0ZW0gPT4gKFtpdGVtXS5jb25jYXQoY29tYmluYXRpb24pKSkpKSlcbiAgfVxuICByZXR1cm4gZ2V0QW55T2ZDb21iaW5hdGlvbnMocmVzdCwgdmFsdWVzLm1hcChpdGVtID0+IChpdGVtKSkpXG59XG5cbmZ1bmN0aW9uIHRocm93SW5jb21wYXRpYmxlKHZhbHVlcywgcGF0aHMpIHtcbiAgbGV0IGFzSlNPTlxuICB0cnkge1xuICAgIGFzSlNPTiA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgIH0pLmpvaW4oJ1xcbicpXG4gIH0gY2F0Y2ggKHZhcmlhYmxlKSB7XG4gICAgYXNKU09OID0gdmFsdWVzLmpvaW4oJywgJylcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXNvbHZlIHZhbHVlcyBmb3IgcGF0aDpcIicgKyBwYXRocy5qb2luKCcuJykgKyAnXCIuIFRoZXkgYXJlIHByb2JhYmx5IGluY29tcGF0aWJsZS4gVmFsdWVzOiBcXG4nICsgYXNKU09OKVxufVxuXG5mdW5jdGlvbiBjYWxsR3JvdXBSZXNvbHZlcihjb21wbGV4S2V5d29yZHMsIHJlc29sdmVyTmFtZSwgc2NoZW1hcywgbWVyZ2VTY2hlbWFzLCBvcHRpb25zLCBwYXJlbnRzKSB7XG4gIGlmIChjb21wbGV4S2V5d29yZHMubGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzb2x2ZXJDb25maWcgPSBvcHRpb25zLmNvbXBsZXhSZXNvbHZlcnNbcmVzb2x2ZXJOYW1lXVxuICAgIGlmICghcmVzb2x2ZXJDb25maWcgfHwgIXJlc29sdmVyQ29uZmlnLnJlc29sdmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc29sdmVyIGZvdW5kIGZvciAnICsgcmVzb2x2ZXJOYW1lKVxuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgYWxsIGtleXdvcmRzIGZyb20gYWxsIHRoZSBzY2hlbWFzIHRoYXQgaGF2ZSBvbmUgb3IgbW9yZVxuICAgIC8vIHRoZW4gcmVtb3ZlIGFsbCB1bmRlZmluZWQgb25lcyBhbmQgbm90IHVuaXF1ZVxuICAgIGNvbnN0IGV4dHJhY3RlZEtleXdvcmRzT25seSA9IHNjaGVtYXMubWFwKHNjaGVtYSA9PiBjb21wbGV4S2V5d29yZHMucmVkdWNlKChhbGwsIGtleSkgPT4ge1xuICAgICAgaWYgKHNjaGVtYVtrZXldICE9PSB1bmRlZmluZWQpIGFsbFtrZXldID0gc2NoZW1hW2tleV1cbiAgICAgIHJldHVybiBhbGxcbiAgICB9LCB7fSkpXG4gICAgY29uc3QgdW5pcXVlID0gdW5pcVdpdGgoZXh0cmFjdGVkS2V5d29yZHNPbmx5LCBjb21wYXJlKVxuXG4gICAgLy8gY3JlYXRlIG1lcmdlcnMgdGhhdCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcGF0aCBvZiB0aGUga2V5d29yZCBmb3IgdXNlIGluIHRoZSBjb21wbGV4IHJlc29sdmVyXG4gICAgY29uc3QgbWVyZ2VycyA9IHJlc29sdmVyQ29uZmlnLmtleXdvcmRzLnJlZHVjZSgoYWxsLCBrZXkpID0+ICh7XG4gICAgICAuLi5hbGwsXG4gICAgICBba2V5XTogKHNjaGVtYXMsIGV4dHJhS2V5ID0gW10pID0+IG1lcmdlU2NoZW1hcyhzY2hlbWFzLCBudWxsLCBwYXJlbnRzLmNvbmNhdChrZXksIGV4dHJhS2V5KSlcbiAgICB9KSwge30pXG5cbiAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlckNvbmZpZy5yZXNvbHZlcih1bmlxdWUsIHBhcmVudHMuY29uY2F0KHJlc29sdmVyTmFtZSksIG1lcmdlcnMsIG9wdGlvbnMpXG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocmVzdWx0KSkge1xuICAgICAgdGhyb3dJbmNvbXBhdGlibGUodW5pcXVlLCBwYXJlbnRzLmNvbmNhdChyZXNvbHZlck5hbWUpKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1aXJlZE1ldGFBcnJheShhcnIpIHtcbiAgcmV0dXJuIHsgcmVxdWlyZWQ6IGFyciB9XG59XG5cbmNvbnN0IHNjaGVtYUdyb3VwUHJvcHMgPSBbJ3Byb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnZGVmaW5pdGlvbnMnLCAnZGVwZW5kZW5jaWVzJ11cbmNvbnN0IHNjaGVtYUFycmF5cyA9IFsnYW55T2YnLCAnb25lT2YnXVxuY29uc3Qgc2NoZW1hUHJvcHMgPSBbXG4gICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICdhZGRpdGlvbmFsSXRlbXMnLFxuICAnY29udGFpbnMnLFxuICAncHJvcGVydHlOYW1lcycsXG4gICdub3QnLFxuICAnaXRlbXMnXG5dXG5cbmNvbnN0IGRlZmF1bHRSZXNvbHZlcnMgPSB7XG4gIHR5cGUoY29tcGFjdGVkKSB7XG4gICAgaWYgKGNvbXBhY3RlZC5zb21lKEFycmF5LmlzQXJyYXkpKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gY29tcGFjdGVkLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKVxuICAgICAgICAgID8gdmFsXG4gICAgICAgICAgOiBbdmFsXVxuICAgICAgfSlcbiAgICAgIGNvbnN0IGNvbW1vbiA9IGludGVyc2VjdGlvbi5hcHBseShudWxsLCBub3JtYWxpemVkKVxuXG4gICAgICBpZiAoY29tbW9uLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29tbW9uWzBdXG4gICAgICB9IGVsc2UgaWYgKGNvbW1vbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiB1bmlxKGNvbW1vbilcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlcGVuZGVuY2llcyhjb21wYWN0ZWQsIHBhdGhzLCBtZXJnZVNjaGVtYXMpIHtcbiAgICBjb25zdCBhbGxDaGlsZHJlbiA9IGFsbFVuaXF1ZUtleXMoY29tcGFjdGVkKVxuXG4gICAgcmV0dXJuIGFsbENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbihhbGwsIGNoaWxkS2V5KSB7XG4gICAgICBjb25zdCBjaGlsZFNjaGVtYXMgPSBnZXRWYWx1ZXMoY29tcGFjdGVkLCBjaGlsZEtleSlcbiAgICAgIGxldCBpbm5lckNvbXBhY3RlZCA9IHVuaXFXaXRoKGNoaWxkU2NoZW1hcy5maWx0ZXIobm90VW5kZWZpbmVkKSwgaXNFcXVhbClcblxuICAgICAgLy8gdG8gc3VwcG9ydCBkZXBlbmRlbmNpZXNcbiAgICAgIGNvbnN0IGlubmVyQXJyYXlzID0gaW5uZXJDb21wYWN0ZWQuZmlsdGVyKEFycmF5LmlzQXJyYXkpXG5cbiAgICAgIGlmIChpbm5lckFycmF5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlubmVyQXJyYXlzLmxlbmd0aCA9PT0gaW5uZXJDb21wYWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgYWxsW2NoaWxkS2V5XSA9IHN0cmluZ0FycmF5KGlubmVyQ29tcGFjdGVkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGlubmVyU2NoZW1hcyA9IGlubmVyQ29tcGFjdGVkLmZpbHRlcihpc1NjaGVtYSlcbiAgICAgICAgICBjb25zdCBhcnJheU1ldGFTY2hlYW1zID0gaW5uZXJBcnJheXMubWFwKGNyZWF0ZVJlcXVpcmVkTWV0YUFycmF5KVxuICAgICAgICAgIGFsbFtjaGlsZEtleV0gPSBtZXJnZVNjaGVtYXMoaW5uZXJTY2hlbWFzLmNvbmNhdChhcnJheU1ldGFTY2hlYW1zKSwgY2hpbGRLZXkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbFxuICAgICAgfVxuXG4gICAgICBpbm5lckNvbXBhY3RlZCA9IHVuaXFXaXRoKGlubmVyQ29tcGFjdGVkLCBjb21wYXJlKVxuXG4gICAgICBhbGxbY2hpbGRLZXldID0gbWVyZ2VTY2hlbWFzKGlubmVyQ29tcGFjdGVkLCBjaGlsZEtleSlcbiAgICAgIHJldHVybiBhbGxcbiAgICB9LCB7fSlcbiAgfSxcbiAgb25lT2YoY29tcGFjdGVkLCBwYXRocywgbWVyZ2VTY2hlbWFzKSB7XG4gICAgY29uc3QgY29tYmluYXRpb25zID0gZ2V0QW55T2ZDb21iaW5hdGlvbnMoY2xvbmVEZWVwKGNvbXBhY3RlZCkpXG4gICAgY29uc3QgcmVzdWx0ID0gdHJ5TWVyZ2VTY2hlbWFHcm91cHMoY29tYmluYXRpb25zLCBtZXJnZVNjaGVtYXMpXG4gICAgY29uc3QgdW5pcXVlID0gdW5pcVdpdGgocmVzdWx0LCBjb21wYXJlKVxuXG4gICAgaWYgKHVuaXF1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1bmlxdWVcbiAgICB9XG4gIH0sXG4gIG5vdChjb21wYWN0ZWQpIHtcbiAgICByZXR1cm4geyBhbnlPZjogY29tcGFjdGVkIH1cbiAgfSxcbiAgcGF0dGVybihjb21wYWN0ZWQpIHtcbiAgICByZXR1cm4gY29tcGFjdGVkLm1hcChyID0+ICcoPz0nICsgciArICcpJykuam9pbignJylcbiAgfSxcbiAgbXVsdGlwbGVPZihjb21wYWN0ZWQpIHtcbiAgICBsZXQgaW50ZWdlcnMgPSBjb21wYWN0ZWQuc2xpY2UoMClcbiAgICBsZXQgZmFjdG9yID0gMVxuICAgIHdoaWxlIChpbnRlZ2Vycy5zb21lKG4gPT4gIU51bWJlci5pc0ludGVnZXIobikpKSB7XG4gICAgICBpbnRlZ2VycyA9IGludGVnZXJzLm1hcChuID0+IG4gKiAxMClcbiAgICAgIGZhY3RvciA9IGZhY3RvciAqIDEwXG4gICAgfVxuICAgIHJldHVybiBjb21wdXRlTGNtKGludGVnZXJzKSAvIGZhY3RvclxuICB9LFxuICBlbnVtKGNvbXBhY3RlZCkge1xuICAgIGNvbnN0IGVudW1zID0gaW50ZXJzZWN0aW9uV2l0aC5hcHBseShudWxsLCBjb21wYWN0ZWQuY29uY2F0KGlzRXF1YWwpKVxuICAgIGlmIChlbnVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzb3J0QnkoZW51bXMpXG4gICAgfVxuICB9XG59XG5cbmRlZmF1bHRSZXNvbHZlcnMuJGlkID0gZmlyc3RcbmRlZmF1bHRSZXNvbHZlcnMuJHJlZiA9IGZpcnN0XG5kZWZhdWx0UmVzb2x2ZXJzLiRzY2hlbWEgPSBmaXJzdFxuZGVmYXVsdFJlc29sdmVycy5hZGRpdGlvbmFsSXRlbXMgPSBzY2hlbWFSZXNvbHZlclxuZGVmYXVsdFJlc29sdmVycy5hZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYVJlc29sdmVyXG5kZWZhdWx0UmVzb2x2ZXJzLmFueU9mID0gZGVmYXVsdFJlc29sdmVycy5vbmVPZlxuZGVmYXVsdFJlc29sdmVycy5jb250YWlucyA9IHNjaGVtYVJlc29sdmVyXG5kZWZhdWx0UmVzb2x2ZXJzLmRlZmF1bHQgPSBmaXJzdFxuZGVmYXVsdFJlc29sdmVycy5kZWZpbml0aW9ucyA9IGRlZmF1bHRSZXNvbHZlcnMuZGVwZW5kZW5jaWVzXG5kZWZhdWx0UmVzb2x2ZXJzLmRlc2NyaXB0aW9uID0gZmlyc3RcbmRlZmF1bHRSZXNvbHZlcnMuZXhhbXBsZXMgPSBleGFtcGxlc1xuZGVmYXVsdFJlc29sdmVycy5leGNsdXNpdmVNYXhpbXVtID0gbWluaW11bVZhbHVlXG5kZWZhdWx0UmVzb2x2ZXJzLmV4Y2x1c2l2ZU1pbmltdW0gPSBtYXhpbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMuaXRlbXMgPSBpdGVtc1Jlc29sdmVyXG5kZWZhdWx0UmVzb2x2ZXJzLm1heGltdW0gPSBtaW5pbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMubWF4SXRlbXMgPSBtaW5pbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMubWF4TGVuZ3RoID0gbWluaW11bVZhbHVlXG5kZWZhdWx0UmVzb2x2ZXJzLm1heFByb3BlcnRpZXMgPSBtaW5pbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMubWluaW11bSA9IG1heGltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5taW5JdGVtcyA9IG1heGltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5taW5MZW5ndGggPSBtYXhpbXVtVmFsdWVcbmRlZmF1bHRSZXNvbHZlcnMubWluUHJvcGVydGllcyA9IG1heGltdW1WYWx1ZVxuZGVmYXVsdFJlc29sdmVycy5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1Jlc29sdmVyXG5kZWZhdWx0UmVzb2x2ZXJzLnByb3BlcnR5TmFtZXMgPSBzY2hlbWFSZXNvbHZlclxuZGVmYXVsdFJlc29sdmVycy5yZXF1aXJlZCA9IHJlcXVpcmVkXG5kZWZhdWx0UmVzb2x2ZXJzLnRpdGxlID0gZmlyc3RcbmRlZmF1bHRSZXNvbHZlcnMudW5pcXVlSXRlbXMgPSB1bmlxdWVJdGVtc1xuXG5jb25zdCBkZWZhdWx0Q29tcGxleFJlc29sdmVycyA9IHtcbiAgcHJvcGVydGllczogcHJvcGVydGllc1Jlc29sdmVyLFxuICBpdGVtczogaXRlbXNSZXNvbHZlclxufVxuXG5mdW5jdGlvbiBtZXJnZXIocm9vdFNjaGVtYSwgb3B0aW9ucywgdG90YWxTY2hlbWFzKSB7XG4gIHRvdGFsU2NoZW1hcyA9IHRvdGFsU2NoZW1hcyB8fCBbXVxuICBvcHRpb25zID0gZGVmYXVsdHNEZWVwKG9wdGlvbnMsIHtcbiAgICBpZ25vcmVBZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgcmVzb2x2ZXJzOiBkZWZhdWx0UmVzb2x2ZXJzLFxuICAgIGNvbXBsZXhSZXNvbHZlcnM6IGRlZmF1bHRDb21wbGV4UmVzb2x2ZXJzLFxuICAgIGRlZXA6IHRydWVcbiAgfSlcblxuICBjb25zdCBjb21wbGV4UmVzb2x2ZXJzID0gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5jb21wbGV4UmVzb2x2ZXJzKVxuXG4gIGZ1bmN0aW9uIG1lcmdlU2NoZW1hcyhzY2hlbWFzLCBiYXNlLCBwYXJlbnRzKSB7XG4gICAgc2NoZW1hcyA9IGNsb25lRGVlcChzY2hlbWFzLmZpbHRlcihub3RVbmRlZmluZWQpKVxuICAgIHBhcmVudHMgPSBwYXJlbnRzIHx8IFtdXG4gICAgY29uc3QgbWVyZ2VkID0gaXNQbGFpbk9iamVjdChiYXNlKVxuICAgICAgPyBiYXNlXG4gICAgICA6IHt9XG5cbiAgICAvLyByZXR1cm4gdW5kZWZpbmVkLCBhbiBlbXB0eSBzY2hlbWFcbiAgICBpZiAoIXNjaGVtYXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hcy5zb21lKGlzRmFsc2UpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hcy5ldmVyeShpc1RydWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHRoZXJlIGFyZSBubyBmYWxzZSBhbmQgd2UgZG9uJ3QgbmVlZCB0aGUgdHJ1ZSBvbmVzIGFzIHRoZXkgYWNjZXB0IGV2ZXJ5dGhpbmdcbiAgICBzY2hlbWFzID0gc2NoZW1hcy5maWx0ZXIoaXNQbGFpbk9iamVjdClcblxuICAgIGNvbnN0IGFsbEtleXMgPSBhbGxVbmlxdWVLZXlzKHNjaGVtYXMpXG4gICAgaWYgKG9wdGlvbnMuZGVlcCAmJiBjb250YWlucyhhbGxLZXlzLCAnYWxsT2YnKSkge1xuICAgICAgcmV0dXJuIG1lcmdlcih7XG4gICAgICAgIGFsbE9mOiBzY2hlbWFzXG4gICAgICB9LCBvcHRpb25zLCB0b3RhbFNjaGVtYXMpXG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxleEtleXNBcnIgPSBjb21wbGV4UmVzb2x2ZXJzLm1hcCgoW21haW5LZXlXb3JkLCByZXNvbHZlckNvbmZdKSA9PlxuICAgICAgYWxsS2V5cy5maWx0ZXIoayA9PiByZXNvbHZlckNvbmYua2V5d29yZHMuaW5jbHVkZXMoaykpKVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBjb21wbGV4IGtleXMgYmVmb3JlIHNpbXBsZSByZXNvbHZlcnNcbiAgICBjb21wbGV4S2V5c0Fyci5mb3JFYWNoKGtleXMgPT4gcHVsbEFsbChhbGxLZXlzLCBrZXlzKSlcblxuICAgIC8vIGNhbGwgYWxsIHNpbXBsZSByZXNvbHZlcnMgZm9yIHJlbGV2YW50IGtleXdvcmRzXG4gICAgYWxsS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgY29uc3QgdmFsdWVzID0gZ2V0VmFsdWVzKHNjaGVtYXMsIGtleSlcbiAgICAgIGNvbnN0IGNvbXBhY3RlZCA9IHVuaXFXaXRoKHZhbHVlcy5maWx0ZXIobm90VW5kZWZpbmVkKSwgY29tcGFyZVByb3Aoa2V5KSlcblxuICAgICAgLy8gYXJyYXlwcm9wcyBsaWtlIGFueU9mIGFuZCBvbmVPZiBtdXN0IGJlIG1lcmdlZCBmaXJzdCwgYXMgdGhleSBjb250YWlucyBzY2hlbWFzXG4gICAgICAvLyBhbGxPZiBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGFsbHRvZ2V0aGVyXG4gICAgICBpZiAoY29tcGFjdGVkLmxlbmd0aCA9PT0gMSAmJiBjb250YWlucyhzY2hlbWFBcnJheXMsIGtleSkpIHtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSBjb21wYWN0ZWRbMF0ubWFwKHNjaGVtYSA9PiBtZXJnZVNjaGVtYXMoW3NjaGVtYV0sIHNjaGVtYSkpXG4gICAgICAgIC8vIHByb3AgZ3JvdXBzIG11c3QgYWx3YXlzIGJlIHJlc29sdmVkXG4gICAgICB9IGVsc2UgaWYgKGNvbXBhY3RlZC5sZW5ndGggPT09IDEgJiYgIWNvbnRhaW5zKHNjaGVtYUdyb3VwUHJvcHMsIGtleSkgJiYgIWNvbnRhaW5zKHNjaGVtYVByb3BzLCBrZXkpKSB7XG4gICAgICAgIG1lcmdlZFtrZXldID0gY29tcGFjdGVkWzBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IG9wdGlvbnMucmVzb2x2ZXJzW2tleV0gfHwgb3B0aW9ucy5yZXNvbHZlcnMuZGVmYXVsdFJlc29sdmVyXG4gICAgICAgIGlmICghcmVzb2x2ZXIpIHRocm93IG5ldyBFcnJvcignTm8gcmVzb2x2ZXIgZm91bmQgZm9yIGtleSAnICsga2V5ICsgJy4gWW91IGNhbiBwcm92aWRlIGEgcmVzb2x2ZXIgZm9yIHRoaXMga2V5d29yZCBpbiB0aGUgb3B0aW9ucywgb3IgcHJvdmlkZSBhIGRlZmF1bHQgcmVzb2x2ZXIuJylcblxuICAgICAgICBjb25zdCBtZXJnZXIgPSAoc2NoZW1hcywgZXh0cmFLZXkgPSBbXSkgPT4gbWVyZ2VTY2hlbWFzKHNjaGVtYXMsIG51bGwsIHBhcmVudHMuY29uY2F0KGtleSwgZXh0cmFLZXkpKVxuICAgICAgICBtZXJnZWRba2V5XSA9IHJlc29sdmVyKGNvbXBhY3RlZCwgcGFyZW50cy5jb25jYXQoa2V5KSwgbWVyZ2VyLCBvcHRpb25zKVxuXG4gICAgICAgIGlmIChtZXJnZWRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3dJbmNvbXBhdGlibGUoY29tcGFjdGVkLCBwYXJlbnRzLmNvbmNhdChrZXkpKVxuICAgICAgICB9IGVsc2UgaWYgKG1lcmdlZFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgbWVyZ2VkW2tleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY29tcGxleFJlc29sdmVycy5yZWR1Y2UoKGFsbCwgW3Jlc29sdmVyS2V5d29yZCwgY29uZmlnXSwgaW5kZXgpID0+ICh7XG4gICAgICAuLi5hbGwsXG4gICAgICAuLi5jYWxsR3JvdXBSZXNvbHZlcihjb21wbGV4S2V5c0FycltpbmRleF0sIHJlc29sdmVyS2V5d29yZCwgc2NoZW1hcywgbWVyZ2VTY2hlbWFzLCBvcHRpb25zLCBwYXJlbnRzKVxuICAgIH0pLCBtZXJnZWQpXG4gIH1cblxuICBjb25zdCBhbGxTY2hlbWFzID0gZmxhdHRlbkRlZXAoZ2V0QWxsT2Yocm9vdFNjaGVtYSkpXG4gIGNvbnN0IG1lcmdlZCA9IG1lcmdlU2NoZW1hcyhhbGxTY2hlbWFzKVxuXG4gIHJldHVybiBtZXJnZWRcbn1cblxubWVyZ2VyLm9wdGlvbnMgPSB7XG4gIHJlc29sdmVyczogZGVmYXVsdFJlc29sdmVyc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlclxuIiwidmFyIGhhc0V4Y2FwZSA9IC9+L1xudmFyIGVzY2FwZU1hdGNoZXIgPSAvflswMV0vZ1xuZnVuY3Rpb24gZXNjYXBlUmVwbGFjZXIgKG0pIHtcbiAgc3dpdGNoIChtKSB7XG4gICAgY2FzZSAnfjEnOiByZXR1cm4gJy8nXG4gICAgY2FzZSAnfjAnOiByZXR1cm4gJ34nXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRpbGRlIGVzY2FwZTogJyArIG0pXG59XG5cbmZ1bmN0aW9uIHVudGlsZGUgKHN0cikge1xuICBpZiAoIWhhc0V4Y2FwZS50ZXN0KHN0cikpIHJldHVybiBzdHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGVzY2FwZU1hdGNoZXIsIGVzY2FwZVJlcGxhY2VyKVxufVxuXG5mdW5jdGlvbiBzZXR0ZXIgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgdmFyIHBhcnRcbiAgdmFyIGhhc05leHRQYXJ0XG5cbiAgZm9yICh2YXIgcCA9IDEsIGxlbiA9IHBvaW50ZXIubGVuZ3RoOyBwIDwgbGVuOykge1xuICAgIGlmIChwb2ludGVyW3BdID09PSAnY29uc3RydWN0b3InIHx8IHBvaW50ZXJbcF0gPT09ICdwcm90b3R5cGUnIHx8IHBvaW50ZXJbcF0gPT09ICdfX3Byb3RvX18nKSByZXR1cm4gb2JqXG5cbiAgICBwYXJ0ID0gdW50aWxkZShwb2ludGVyW3ArK10pXG4gICAgaGFzTmV4dFBhcnQgPSBsZW4gPiBwXG5cbiAgICBpZiAodHlwZW9mIG9ialtwYXJ0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHN1cHBvcnQgc2V0dGluZyBvZiAvLVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiBwYXJ0ID09PSAnLScpIHtcbiAgICAgICAgcGFydCA9IG9iai5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgLy8gc3VwcG9ydCBuZXN0ZWQgb2JqZWN0cy9hcnJheSB3aGVuIHNldHRpbmcgdmFsdWVzXG4gICAgICBpZiAoaGFzTmV4dFBhcnQpIHtcbiAgICAgICAgaWYgKChwb2ludGVyW3BdICE9PSAnJyAmJiBwb2ludGVyW3BdIDwgSW5maW5pdHkpIHx8IHBvaW50ZXJbcF0gPT09ICctJykgb2JqW3BhcnRdID0gW11cbiAgICAgICAgZWxzZSBvYmpbcGFydF0gPSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzTmV4dFBhcnQpIGJyZWFrXG4gICAgb2JqID0gb2JqW3BhcnRdXG4gIH1cblxuICB2YXIgb2xkVmFsdWUgPSBvYmpbcGFydF1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGRlbGV0ZSBvYmpbcGFydF1cbiAgZWxzZSBvYmpbcGFydF0gPSB2YWx1ZVxuICByZXR1cm4gb2xkVmFsdWVcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBvaW50ZXIgKHBvaW50ZXIpIHtcbiAgaWYgKHR5cGVvZiBwb2ludGVyID09PSAnc3RyaW5nJykge1xuICAgIHBvaW50ZXIgPSBwb2ludGVyLnNwbGl0KCcvJylcbiAgICBpZiAocG9pbnRlclswXSA9PT0gJycpIHJldHVybiBwb2ludGVyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4nKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRlcikpIHtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcG9pbnRlcikge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4gTXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciBudW1iZXIuJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvaW50ZXJcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIuJylcbn1cblxuZnVuY3Rpb24gZ2V0IChvYmosIHBvaW50ZXIpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgb2JqZWN0LicpXG4gIHBvaW50ZXIgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICB2YXIgbGVuID0gcG9pbnRlci5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMSkgcmV0dXJuIG9ialxuXG4gIGZvciAodmFyIHAgPSAxOyBwIDwgbGVuOykge1xuICAgIG9iaiA9IG9ialt1bnRpbGRlKHBvaW50ZXJbcCsrXSldXG4gICAgaWYgKGxlbiA9PT0gcCkgcmV0dXJuIG9ialxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgb2JqZWN0LicpXG4gIHBvaW50ZXIgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICBpZiAocG9pbnRlci5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIgZm9yIHNldC4nKVxuICByZXR1cm4gc2V0dGVyKG9iaiwgcG9pbnRlciwgdmFsdWUpXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUgKHBvaW50ZXIpIHtcbiAgdmFyIGNvbXBpbGVkID0gY29tcGlsZVBvaW50ZXIocG9pbnRlcilcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiBnZXQob2JqZWN0LCBjb21waWxlZClcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKG9iamVjdCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXQob2JqZWN0LCBjb21waWxlZCwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZ2V0ID0gZ2V0XG5leHBvcnRzLnNldCA9IHNldFxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpdGVyYXRlZSkge1xuICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gIH1cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRGlmZmVyZW5jZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mV2l0aDtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICB9XG4gICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuICBhcnJheSA9IGFycmF5c1swXTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmICghKHNlZW5cbiAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgKSkge1xuICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW50ZXJzZWN0aW9uO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBiYXNlU29ydEJ5ID0gcmVxdWlyZSgnLi9fYmFzZVNvcnRCeScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNvbXBhcmVNdWx0aXBsZSA9IHJlcXVpcmUoJy4vX2NvbXBhcmVNdWx0aXBsZScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlT3JkZXJCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKSxcbiAgICBiYXNlSW5kZXhPZldpdGggPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZldpdGgnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgc2VlbiA9IGFycmF5O1xuXG4gIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQdWxsQWxsO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZWR1Y2U7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0Qnk7XG4iLCJ2YXIgdHJpbW1lZEVuZEluZGV4ID0gcmVxdWlyZSgnLi9fdHJpbW1lZEVuZEluZGV4Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nXG4gICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVHJpbTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpLFxuICAgIGNyZWF0ZVNldCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVNldCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG4iLCJ2YXIgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEFycmF5TGlrZU9iamVjdDtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQXNjZW5kaW5nO1xuIiwidmFyIGNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuL19jb21wYXJlQXNjZW5kaW5nJyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZU11bHRpcGxlO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcbiIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3VzdG9tRGVmYXVsdHNNZXJnZTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbnZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICByZXR1cm4gaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJpbW1lZEVuZEluZGV4O1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgIGxlbmd0aCA9IDE7XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgY3VzdG9tRGVmYXVsdHNNZXJnZSA9IHJlcXVpcmUoJy4vX2N1c3RvbURlZmF1bHRzTWVyZ2UnKSxcbiAgICBtZXJnZVdpdGggPSByZXF1aXJlKCcuL21lcmdlV2l0aCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAqL1xudmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0c0RlZXA7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuRGVlcDtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi9fYmFzZUludGVyc2VjdGlvbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBjYXN0QXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9fY2FzdEFycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICogLy8gPT4gWzJdXG4gKi9cbnZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgIDogW107XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3Rpb247XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL19iYXNlSW50ZXJzZWN0aW9uJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGNhc3RBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL19jYXN0QXJyYXlMaWtlT2JqZWN0JyksXG4gICAgbGFzdCA9IHJlcXVpcmUoJy4vbGFzdCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICpcbiAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICovXG52YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICBpZiAoY29tcGFyYXRvcikge1xuICAgIG1hcHBlZC5wb3AoKTtcbiAgfVxuICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgIDogW107XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3Rpb25XaXRoO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQm9vbGVhbihudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCb29sZWFuO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICogICAgIHJldHVybiB0cnVlO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAqXG4gKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsV2l0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05pbChudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmlsKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05pbChOYU4pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOaWw7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlV2l0aDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBiYXNlUHVsbEFsbCA9IHJlcXVpcmUoJy4vX2Jhc2VQdWxsQWxsJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gKlxuICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsnYicsICdiJ11cbiAqL1xuZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICA6IGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHB1bGxBbGw7XG4iLCJ2YXIgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlUmVkdWNlID0gcmVxdWlyZSgnLi9fYmFzZVJlZHVjZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICogYW5kIGBzb3J0QnlgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gKiAgIHJldHVybiBzdW0gKyBuO1xuICogfSwgMCk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogICByZXR1cm4gcmVzdWx0O1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VPcmRlckJ5ID0gcmVxdWlyZSgnLi9fYmFzZU9yZGVyQnknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG52YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAqXG4gKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAqIC8vID0+IFswLCAwLCAwLCAwXVxuICovXG5mdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICBuID0gdG9JbnRlZ2VyKG4pO1xuICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICBpdGVyYXRlZSA9IGNhc3RGdW5jdGlvbihpdGVyYXRlZSk7XG4gIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aW1lcztcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuIiwidmFyIGJhc2VUcmltID0gcmVxdWlyZSgnLi9fYmFzZVRyaW0nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfSwgW10pO1xuICogLy8gPT4gWzQsIDldXG4gKlxuICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgfVxuICB9XG4gIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xudmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcbiIsInZhciBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICogaW4gdGhlIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsyLCAxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxO1xuIiwidmFyIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gKlxuICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICovXG5mdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcVdpdGg7XG4iLCJ2YXIgYmFzZURpZmZlcmVuY2UgPSByZXF1aXJlKCcuL19iYXNlRGlmZmVyZW5jZScpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICogLy8gPT4gWzNdXG4gKi9cbnZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgIDogW107XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB3aXRob3V0O1xuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgU3VzcGVuc2VMaXN0ID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VMaXN0KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbn1cblxuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLlN1c3BlbnNlTGlzdCA9IFN1c3BlbnNlTGlzdDtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1N1c3BlbnNlTGlzdCA9IGlzU3VzcGVuc2VMaXN0O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRlVOQ1RJT046IGlzQXJyYXkoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGFuIGFycmF5LlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBhcnJheVxuKi9cbmZ1bmN0aW9uIGlzQXJyYXkoIHZhbHVlICkge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCB2YWx1ZSApID09PSAnW29iamVjdCBBcnJheV0nO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNBcnJheSgpXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGlzQXJyYXk7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBmdW5jdGlvblxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gVmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRlVOQ1RJT046IGlzRnVuY3Rpb24oIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKCB2YWx1ZSApIHtcblx0cmV0dXJuICggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICk7XG59IC8vIGVuZCBGVU5DVElPTiBpc0Z1bmN0aW9uKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKlxuKlxuKlx0VkFMSURBVEU6IGludGVnZXItYXJyYXlcbipcbipcbipcdERFU0NSSVBUSU9OOlxuKlx0XHQtIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIgYXJyYXkuXG4qXG4qXG4qXHROT1RFUzpcbipcdFx0WzFdXG4qXG4qXG4qXHRUT0RPOlxuKlx0XHRbMV1cbipcbipcbipcdExJQ0VOU0U6XG4qXHRcdE1JVFxuKlxuKlx0Q29weXJpZ2h0IChjKSAyMDE1LiBBdGhhbiBSZWluZXMuXG4qXG4qXG4qXHRBVVRIT1I6XG4qXHRcdEF0aGFuIFJlaW5lcy4ga2dyeXRlQGdtYWlsLmNvbS4gMjAxNS5cbipcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1hcnJheScgKSxcblx0aXNJbnRlZ2VyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLWludGVnZXInICk7XG5cblxuLy8gSVMgSU5URUdFUiBBUlJBWSAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzSW50ZWdlckFycmF5KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGFycmF5LlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGFycmF5XG4qL1xuZnVuY3Rpb24gaXNJbnRlZ2VyQXJyYXkoIHZhbHVlICkge1xuXHR2YXIgbGVuO1xuXHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cdGlmICggIWxlbiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAhaXNJbnRlZ2VyKCB2YWx1ZVtpXSApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn0gLy8gZW5kIEZVTkNUSU9OIGlzSW50ZWdlckFycmF5KClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyQXJyYXk7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBpbnRlZ2VyXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW51bWJlcicgKTtcblxuXG4vLyBJU0lOVEVHRVIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBpc0ludGVnZXIoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHZhbGlkYXRlZFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gaW50ZWdlclxuKi9cbmZ1bmN0aW9uIGlzSW50ZWdlciggdmFsdWUgKSB7XG5cdHJldHVybiBpc051bWJlciggdmFsdWUgKSAmJiB2YWx1ZSUxID09PSAwO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNJbnRlZ2VyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbnRlZ2VyO1xuIiwiLyoqXG4qXG4qXHRWQUxJREFURTogbnVtYmVyXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlci5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRlVOQ1RJT046IGlzTnVtYmVyKCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlci5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHZhbGlkYXRlZFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBudW1iZXJcbiovXG5mdW5jdGlvbiBpc051bWJlciggdmFsdWUgKSB7XG5cdHJldHVybiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCB2YWx1ZSApID09PSAnW29iamVjdCBOdW1iZXJdJyApICYmIHZhbHVlLnZhbHVlT2YoKSA9PT0gdmFsdWUudmFsdWVPZigpO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNOdW1iZXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc051bWJlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==