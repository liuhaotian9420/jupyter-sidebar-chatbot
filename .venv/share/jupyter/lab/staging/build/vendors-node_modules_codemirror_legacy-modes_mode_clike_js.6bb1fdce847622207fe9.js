"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_clike_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/clike.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/clike.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ c),
/* harmony export */   ceylon: () => (/* binding */ ceylon),
/* harmony export */   clike: () => (/* binding */ clike),
/* harmony export */   cpp: () => (/* binding */ cpp),
/* harmony export */   csharp: () => (/* binding */ csharp),
/* harmony export */   dart: () => (/* binding */ dart),
/* harmony export */   java: () => (/* binding */ java),
/* harmony export */   kotlin: () => (/* binding */ kotlin),
/* harmony export */   nesC: () => (/* binding */ nesC),
/* harmony export */   objectiveC: () => (/* binding */ objectiveC),
/* harmony export */   objectiveCpp: () => (/* binding */ objectiveCpp),
/* harmony export */   scala: () => (/* binding */ scala),
/* harmony export */   shader: () => (/* binding */ shader),
/* harmony export */   squirrel: () => (/* binding */ squirrel)
/* harmony export */ });
function Context(indented, column, type, info, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.info = info;
  this.align = align;
  this.prev = prev;
}
function pushContext(state, col, type, info) {
  var indent = state.indented;
  if (state.context && state.context.type == "statement" && type != "statement")
    indent = state.context.indented;
  return state.context = new Context(indent, col, type, info, null, state.context);
}
function popContext(state) {
  var t = state.context.type;
  if (t == ")" || t == "]" || t == "}")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}

function typeBefore(stream, state, pos) {
  if (state.prevToken == "variable" || state.prevToken == "type") return true;
  if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos))) return true;
  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;
}

function isTopScope(context) {
  for (;;) {
    if (!context || context.type == "top") return true;
    if (context.type == "}" && context.prev.info != "namespace") return false;
    context = context.prev;
  }
}

function clike(parserConfig) {
  var statementIndentUnit = parserConfig.statementIndentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      types = parserConfig.types || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      defKeywords = parserConfig.defKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false,
      indentSwitch = parserConfig.indentSwitch !== false,
      namespaceSeparator = parserConfig.namespaceSeparator,
      isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
      numberStart = parserConfig.numberStart || /[\d\.]/,
      number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
      isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/,
      isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/,
      // An optional function that takes a {string} token and returns true if it
      // should be treated as a builtin.
      isReservedIdentifier = parserConfig.isReservedIdentifier || false;

  var curPunc, isDefKeyword;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (numberStart.test(ch)) {
      stream.backUp(1)
      if (stream.match(number)) return "number"
      stream.next()
    }
    if (isPunctuationChar.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar)) {}
      return "operator";
    }
    stream.eatWhile(isIdentifierChar);
    if (namespaceSeparator) while (stream.match(namespaceSeparator))
      stream.eatWhile(isIdentifierChar);

    var cur = stream.current();
    if (contains(keywords, cur)) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      if (contains(defKeywords, cur)) isDefKeyword = true;
      return "keyword";
    }
    if (contains(types, cur)) return "type";
    if (contains(builtin, cur)
        || (isReservedIdentifier && isReservedIdentifier(cur))) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (contains(atoms, cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function maybeEOL(stream, state) {
    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)
  }

  // Interface

  return {
    name: parserConfig.name,
    startState: function(indentUnit) {
      return {
        tokenize: null,
        context: new Context(-indentUnit, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }
      curPunc = isDefKeyword = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if (curPunc == ";" || curPunc == ":" || (curPunc == "," && stream.match(/^\s*(?:\/\/.*)?$/, false)))
        while (state.context.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (indentStatements &&
               (((ctx.type == "}" || ctx.type == "top") && curPunc != ";") ||
                (ctx.type == "statement" && curPunc == "newstatement"))) {
        pushContext(state, stream.column(), "statement", stream.current());
      }

      if (style == "variable" &&
          ((state.prevToken == "def" ||
            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&
             isTopScope(state.context) && stream.match(/^\s*\(/, false)))))
        style = "def";

      if (hooks.token) {
        var result = hooks.token(stream, state, style);
        if (result !== undefined) style = result;
      }

      if (style == "def" && parserConfig.styleDefs === false) style = "variable";

      state.startOfLine = false;
      state.prevToken = isDefKeyword ? "def" : style || curPunc;
      maybeEOL(stream, state);
      return style;
    },

    indent: function(state, textAfter, context) {
      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine && isTopScope(state.context))
        return null;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      if (parserConfig.dontIndentStatements)
        while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
          ctx = ctx.prev
      if (hooks.indent) {
        var hook = hooks.indent(state, ctx, textAfter, context.unit);
        if (typeof hook == "number") return hook
      }
      var switchBlock = ctx.prev && ctx.prev.info == "switch";
      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
        while (ctx.type != "top" && ctx.type != "}") ctx = ctx.prev
        return ctx.indented
      }
      if (ctx.type == "statement")
        return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit || context.unit);
      if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
        return ctx.column + (closing ? 0 : 1);
      if (ctx.type == ")" && !closing)
        return ctx.indented + (statementIndentUnit || context.unit);

      return ctx.indented + (closing ? 0 : context.unit) +
        (!closing && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? context.unit : 0);
    },

    languageData: {
      indentOnInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      commentTokens: {line: "//", block: {open: "/*", close: "*/"}},
      autocomplete: Object.keys(keywords).concat(Object.keys(types)).concat(Object.keys(builtin)).concat(Object.keys(atoms)),
      ...parserConfig.languageData
    }
  };
};

function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
function contains(words, word) {
  if (typeof words === "function") {
    return words(word);
  } else {
    return words.propertyIsEnumerable(word);
  }
}
var cKeywords = "auto if break case register continue return default do sizeof " +
    "static else struct switch extern typedef union for goto while enum const " +
    "volatile inline restrict asm fortran";

// Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.
var cppKeywords = "alignas alignof and and_eq audit axiom bitand bitor catch " +
    "class compl concept constexpr const_cast decltype delete dynamic_cast " +
    "explicit export final friend import module mutable namespace new noexcept " +
    "not not_eq operator or or_eq override private protected public " +
    "reinterpret_cast requires static_assert static_cast template this " +
    "thread_local throw try typeid typename using virtual xor xor_eq";

var objCKeywords = "bycopy byref in inout oneway out self super atomic nonatomic retain copy " +
    "readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd " +
    "@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class " +
    "@public @package @private @protected @required @optional @try @catch @finally @import " +
    "@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";

var objCBuiltins = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION " +
    " NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER " +
    "NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION " +
    "NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT"

// Do not use this. Use the cTypes function below. This is global just to avoid
// excessive calls when cTypes is being called multiple times during a parse.
var basicCTypes = words("int long char short double float unsigned signed " +
                        "void bool");

// Do not use this. Use the objCTypes function below. This is global just to avoid
// excessive calls when objCTypes is being called multiple times during a parse.
var basicObjCTypes = words("SEL instancetype id Class Protocol BOOL");

// Returns true if identifier is a "C" type.
// C type is defined as those that are reserved by the compiler (basicTypes),
// and those that end in _t (Reserved by POSIX for types)
// http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html
function cTypes(identifier) {
  return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);
}

// Returns true if identifier is a "Objective C" type.
function objCTypes(identifier) {
  return cTypes(identifier) || contains(basicObjCTypes, identifier);
}

var cBlockKeywords = "case do else for if switch while struct enum union";
var cDefKeywords = "struct enum union";

function cppHook(stream, state) {
  if (!state.startOfLine) return false
  for (var ch, next = null; ch = stream.peek();) {
    if (ch == "\\" && stream.match(/^.$/)) {
      next = cppHook
      break
    } else if (ch == "/" && stream.match(/^\/[\/\*]/, false)) {
      break
    }
    stream.next()
  }
  state.tokenize = next
  return "meta"
}

function pointerHook(_stream, state) {
  if (state.prevToken == "type") return "type";
  return false;
}

// For C and C++ (and ObjC): identifiers starting with __
// or _ followed by a capital letter are reserved for the compiler.
function cIsReservedIdentifier(token) {
  if (!token || token.length < 2) return false;
  if (token[0] != '_') return false;
  return (token[1] == '_') || (token[1] !== token[1].toLowerCase());
}

function cpp14Literal(stream) {
  stream.eatWhile(/[\w\.']/);
  return "number";
}

function cpp11StringHook(stream, state) {
  stream.backUp(1);
  // Raw strings.
  if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {
    var match = stream.match(/^"([^\s\\()]{0,16})\(/);
    if (!match) {
      return false;
    }
    state.cpp11RawStringDelim = match[1];
    state.tokenize = tokenRawString;
    return tokenRawString(stream, state);
  }
  // Unicode strings/chars.
  if (stream.match(/^(?:u8|u|U|L)/)) {
    if (stream.match(/^["']/, /* eat */ false)) {
      return "string";
    }
    return false;
  }
  // Ignore this hook.
  stream.next();
  return false;
}

function cppLooksLikeConstructor(word) {
  var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
  return lastTwo && lastTwo[1] == lastTwo[2];
}

// C#-style strings where "" escapes a quote.
function tokenAtString(stream, state) {
  var next;
  while ((next = stream.next()) != null) {
    if (next == '"' && !stream.eat('"')) {
      state.tokenize = null;
      break;
    }
  }
  return "string";
}

// C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
// <delim> can be a string up to 16 characters long.
function tokenRawString(stream, state) {
  // Escape characters that have special regex meanings.
  var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
  var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
  if (match)
    state.tokenize = null;
  else
    stream.skipToEnd();
  return "string";
}

const c = clike({
  name: "c",
  keywords: words(cKeywords),
  types: cTypes,
  blockKeywords: words(cBlockKeywords),
  defKeywords: words(cDefKeywords),
  typeFirstDefinitions: true,
  atoms: words("NULL true false"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
  }
})

const cpp = clike({
  name: "cpp",
  keywords: words(cKeywords + " " + cppKeywords),
  types: cTypes,
  blockKeywords: words(cBlockKeywords + " class try catch"),
  defKeywords: words(cDefKeywords + " class namespace"),
  typeFirstDefinitions: true,
  atoms: words("true false NULL nullptr"),
  dontIndentStatements: /^template$/,
  isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
    "u": cpp11StringHook,
    "U": cpp11StringHook,
    "L": cpp11StringHook,
    "R": cpp11StringHook,
    "0": cpp14Literal,
    "1": cpp14Literal,
    "2": cpp14Literal,
    "3": cpp14Literal,
    "4": cpp14Literal,
    "5": cpp14Literal,
    "6": cpp14Literal,
    "7": cpp14Literal,
    "8": cpp14Literal,
    "9": cpp14Literal,
    token: function(stream, state, style) {
      if (style == "variable" && stream.peek() == "(" &&
          (state.prevToken == ";" || state.prevToken == null ||
           state.prevToken == "}") &&
          cppLooksLikeConstructor(stream.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});

const java = clike({
  name: "java",
  keywords: words("abstract assert break case catch class const continue default " +
                  "do else enum extends final finally for goto if implements import " +
                  "instanceof interface native new package private protected public " +
                  "return static strictfp super switch synchronized this throw throws transient " +
                  "try volatile while @interface"),
  types: words("var byte short int long float double boolean char void Boolean Byte Character Double Float " +
               "Integer Long Number Object Short String StringBuffer StringBuilder Void"),
  blockKeywords: words("catch class do else finally for if switch try while"),
  defKeywords: words("class interface enum @interface"),
  typeFirstDefinitions: true,
  atoms: words("true false null"),
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  hooks: {
    "@": function(stream) {
      // Don't match the @interface keyword.
      if (stream.match('interface', false)) return false;

      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      if (!stream.match(/""$/)) return false;
      state.tokenize = tokenTripleString;
      return state.tokenize(stream, state);
    }
  }
})

const csharp = clike({
  name: "csharp",
  keywords: words("abstract as async await base break case catch checked class const continue" +
                  " default delegate do else enum event explicit extern finally fixed for" +
                  " foreach goto if implicit in init interface internal is lock namespace new" +
                  " operator out override params private protected public readonly record ref required return sealed" +
                  " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                  " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                  " global group into join let orderby partial remove select set value var yield"),
  types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func" +
               " Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32" +
               " UInt64 bool byte char decimal double short int long object"  +
               " sbyte float string ushort uint ulong"),
  blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
  defKeywords: words("class interface namespace record struct var"),
  typeFirstDefinitions: true,
  atoms: words("true false null"),
  hooks: {
    "@": function(stream, state) {
      if (stream.eat('"')) {
        state.tokenize = tokenAtString;
        return tokenAtString(stream, state);
      }
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    }
  }
});

function tokenTripleString(stream, state) {
  var escaped = false;
  while (!stream.eol()) {
    if (!escaped && stream.match('"""')) {
      state.tokenize = null;
      break;
    }
    escaped = stream.next() == "\\" && !escaped;
  }
  return "string";
}

function tokenNestedComment(depth) {
  return function (stream, state) {
    var ch
    while (ch = stream.next()) {
      if (ch == "*" && stream.eat("/")) {
        if (depth == 1) {
          state.tokenize = null
          break
        } else {
          state.tokenize = tokenNestedComment(depth - 1)
          return state.tokenize(stream, state)
        }
      } else if (ch == "/" && stream.eat("*")) {
        state.tokenize = tokenNestedComment(depth + 1)
        return state.tokenize(stream, state)
      }
    }
    return "comment"
  }
}

const scala = clike({
  name: "scala",
  keywords: words(
    /* scala */
    "abstract case catch class def do else extends final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try type val var while with yield _ " +

    /* package scala */
    "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble"
  ),
  types: words(
    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector " +

    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
  ),
  multiLineStrings: true,
  blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),
  defKeywords: words("class enum def object package trait type val var"),
  atoms: words("true false null"),
  indentStatements: false,
  indentSwitch: false,
  isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      if (!stream.match('""')) return false;
      state.tokenize = tokenTripleString;
      return state.tokenize(stream, state);
    },
    "'": function(stream) {
      if (stream.match(/^(\\[^'\s]+|[^\\'])'/)) return "character"
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      return "atom";
    },
    "=": function(stream, state) {
      var cx = state.context
      if (cx.type == "}" && cx.align && stream.eat(">")) {
        state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)
        return "operator"
      } else {
        return false
      }
    },

    "/": function(stream, state) {
      if (!stream.eat("*")) return false
      state.tokenize = tokenNestedComment(1)
      return state.tokenize(stream, state)
    }
  },
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', '"""']}
  }
});

function tokenKotlinString(tripleString){
  return function (stream, state) {
    var escaped = false, next, end = false;
    while (!stream.eol()) {
      if (!tripleString && !escaped && stream.match('"') ) {end = true; break;}
      if (tripleString && stream.match('"""')) {end = true; break;}
      next = stream.next();
      if(!escaped && next == "$" && stream.match('{'))
        stream.skipTo("}");
      escaped = !escaped && next == "\\" && !tripleString;
    }
    if (end || !tripleString)
      state.tokenize = null;
    return "string";
  }
}

const kotlin = clike({
  name: "kotlin",
  keywords: words(
    /*keywords*/
    "package as typealias class interface this super val operator " +
      "var fun for is in This throw return annotation " +
      "break continue object if else while do try when !in !is as? " +

    /*soft keywords*/
    "file import where by get set abstract enum open inner override private public internal " +
      "protected catch finally out final vararg reified dynamic companion constructor init " +
      "sealed field property receiver param sparam lateinit data inline noinline tailrec " +
      "external annotation crossinline const operator infix suspend actual expect setparam"
  ),
  types: words(
    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray " +
      "ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy " +
      "LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
  ),
  intendSwitch: false,
  indentStatements: false,
  multiLineStrings: true,
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  blockKeywords: words("catch class do else finally for if where try while enum"),
  defKeywords: words("class val var object interface fun"),
  atoms: words("true false null this"),
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '*': function(_stream, state) {
      return state.prevToken == '.' ? 'variable' : 'operator';
    },
    '"': function(stream, state) {
      state.tokenize = tokenKotlinString(stream.match('""'));
      return state.tokenize(stream, state);
    },
    "/": function(stream, state) {
      if (!stream.eat("*")) return false;
      state.tokenize = tokenNestedComment(1);
      return state.tokenize(stream, state)
    },
    indent: function(state, ctx, textAfter, indentUnit) {
      var firstChar = textAfter && textAfter.charAt(0);
      if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")
        return state.indented;
      if ((state.prevToken == "operator" && textAfter != "}" && state.context.type != "}") ||
          state.prevToken == "variable" && firstChar == "." ||
          (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")
        return indentUnit * 2 + ctx.indented;
      if (ctx.align && ctx.type == "}")
        return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);
    }
  },
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', '"""']}
  }
});

const shader = clike({
  name: "shader",
  keywords: words("sampler1D sampler2D sampler3D samplerCube " +
                  "sampler1DShadow sampler2DShadow " +
                  "const attribute uniform varying " +
                  "break continue discard return " +
                  "for while do if else struct " +
                  "in out inout"),
  types: words("float int bool void " +
               "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
               "mat2 mat3 mat4"),
  blockKeywords: words("for while do if else struct"),
  builtin: words("radians degrees sin cos tan asin acos atan " +
                 "pow exp log exp2 sqrt inversesqrt " +
                 "abs sign floor ceil fract mod min max clamp mix step smoothstep " +
                 "length distance dot cross normalize ftransform faceforward " +
                 "reflect refract matrixCompMult " +
                 "lessThan lessThanEqual greaterThan greaterThanEqual " +
                 "equal notEqual any all not " +
                 "texture1D texture1DProj texture1DLod texture1DProjLod " +
                 "texture2D texture2DProj texture2DLod texture2DProjLod " +
                 "texture3D texture3DProj texture3DLod texture3DProjLod " +
                 "textureCube textureCubeLod " +
                 "shadow1D shadow2D shadow1DProj shadow2DProj " +
                 "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                 "dFdx dFdy fwidth " +
                 "noise1 noise2 noise3 noise4"),
  atoms: words("true false " +
               "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
               "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
               "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
               "gl_FogCoord gl_PointCoord " +
               "gl_Position gl_PointSize gl_ClipVertex " +
               "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
               "gl_TexCoord gl_FogFragCoord " +
               "gl_FragCoord gl_FrontFacing " +
               "gl_FragData gl_FragDepth " +
               "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
               "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
               "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
               "gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
               "gl_ProjectionMatrixInverseTranspose " +
               "gl_ModelViewProjectionMatrixInverseTranspose " +
               "gl_TextureMatrixInverseTranspose " +
               "gl_NormalScale gl_DepthRange gl_ClipPlane " +
               "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
               "gl_FrontLightModelProduct gl_BackLightModelProduct " +
               "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
               "gl_FogParameters " +
               "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
               "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
               "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
               "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
               "gl_MaxDrawBuffers"),
  indentSwitch: false,
  hooks: {"#": cppHook}
})

const nesC = clike({
  name: "nesc",
  keywords: words(cKeywords + " as atomic async call command component components configuration event generic " +
                  "implementation includes interface module new norace nx_struct nx_union post provides " +
                  "signal task uses abstract extends"),
  types: cTypes,
  blockKeywords: words(cBlockKeywords),
  atoms: words("null true false"),
  hooks: {"#": cppHook}
})

const objectiveC = clike({
  name: "objectivec",
  keywords: words(cKeywords + " " + objCKeywords),
  types: objCTypes,
  builtin: words(objCBuiltins),
  blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
  defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class"),
  dontIndentStatements: /^@.*$/,
  typeFirstDefinitions: true,
  atoms: words("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
  }
})

const objectiveCpp = clike({
  name: "objectivecpp",
  keywords: words(cKeywords + " " + objCKeywords + " " + cppKeywords),
  types: objCTypes,
  builtin: words(objCBuiltins),
  blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
  defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class class namespace"),
  dontIndentStatements: /^@.*$|^template$/,
  typeFirstDefinitions: true,
  atoms: words("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
    "u": cpp11StringHook,
    "U": cpp11StringHook,
    "L": cpp11StringHook,
    "R": cpp11StringHook,
    "0": cpp14Literal,
    "1": cpp14Literal,
    "2": cpp14Literal,
    "3": cpp14Literal,
    "4": cpp14Literal,
    "5": cpp14Literal,
    "6": cpp14Literal,
    "7": cpp14Literal,
    "8": cpp14Literal,
    "9": cpp14Literal,
    token: function(stream, state, style) {
      if (style == "variable" && stream.peek() == "(" &&
          (state.prevToken == ";" || state.prevToken == null ||
           state.prevToken == "}") &&
          cppLooksLikeConstructor(stream.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
})

const squirrel = clike({
  name: "squirrel",
  keywords: words("base break clone continue const default delete enum extends function in class" +
                  " foreach local resume return this throw typeof yield constructor instanceof static"),
  types: cTypes,
  blockKeywords: words("case catch class else for foreach if switch try while"),
  defKeywords: words("function local class"),
  typeFirstDefinitions: true,
  atoms: words("true false null"),
  hooks: {"#": cppHook}
})

// Ceylon Strings need to deal with interpolation
var stringTokenizer = null;
function tokenCeylonString(type) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while (!stream.eol()) {
      if (!escaped && stream.match('"') &&
          (type == "single" || stream.match('""'))) {
        end = true;
        break;
      }
      if (!escaped && stream.match('``')) {
        stringTokenizer = tokenCeylonString(type);
        end = true;
        break;
      }
      next = stream.next();
      escaped = type == "single" && !escaped && next == "\\";
    }
    if (end)
      state.tokenize = null;
    return "string";
  }
}

const ceylon = clike({
  name: "ceylon",
  keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else" +
                  " exists extends finally for function given if import in interface is let module new" +
                  " nonempty object of out outer package return satisfies super switch then this throw" +
                  " try value void while"),
  types: function(word) {
    // In Ceylon all identifiers that start with an uppercase are types
    var first = word.charAt(0);
    return (first === first.toUpperCase() && first !== first.toLowerCase());
  },
  blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),
  defKeywords: words("class dynamic function interface module object package value"),
  builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license" +
                 " native optional sealed see serializable shared suppressWarnings tagged throws variable"),
  isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
  isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
  numberStart: /[\d#$]/,
  number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
  multiLineStrings: true,
  typeFirstDefinitions: true,
  atoms: words("true false null larger smaller equal empty finished"),
  indentSwitch: false,
  styleDefs: false,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single");
      return state.tokenize(stream, state);
    },
    '`': function(stream, state) {
      if (!stringTokenizer || !stream.match('`')) return false;
      state.tokenize = stringTokenizer;
      stringTokenizer = null;
      return state.tokenize(stream, state);
    },
    "'": function(stream) {
      if (stream.match(/^(\\[^'\s]+|[^\\'])'/)) return "string.special"
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      return "atom";
    },
    token: function(_stream, state, style) {
      if ((style == "variable" || style == "type") &&
          state.prevToken == ".") {
        return "variableName.special";
      }
    }
  },
  languageData: {
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', '"""']}
  }
})

function pushInterpolationStack(state) {
  (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);
}

function popInterpolationStack(state) {
  return (state.interpolationStack || (state.interpolationStack = [])).pop();
}

function sizeInterpolationStack(state) {
  return state.interpolationStack ? state.interpolationStack.length : 0;
}

function tokenDartString(quote, stream, state, raw) {
  var tripleQuoted = false;
  if (stream.eat(quote)) {
    if (stream.eat(quote)) tripleQuoted = true;
    else return "string"; //empty string
  }
  function tokenStringHelper(stream, state) {
    var escaped = false;
    while (!stream.eol()) {
      if (!raw && !escaped && stream.peek() == "$") {
        pushInterpolationStack(state);
        state.tokenize = tokenInterpolation;
        return "string";
      }
      var next = stream.next();
      if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {
        state.tokenize = null;
        break;
      }
      escaped = !raw && !escaped && next == "\\";
    }
    return "string";
  }
  state.tokenize = tokenStringHelper;
  return tokenStringHelper(stream, state);
}

function tokenInterpolation(stream, state) {
  stream.eat("$");
  if (stream.eat("{")) {
    // let clike handle the content of ${...},
    // we take over again when "}" appears (see hooks).
    state.tokenize = null;
  } else {
    state.tokenize = tokenInterpolationIdentifier;
  }
  return null;
}

function tokenInterpolationIdentifier(stream, state) {
  stream.eatWhile(/[\w_]/);
  state.tokenize = popInterpolationStack(state);
  return "variable";
}

const dart = clike({
  name: "dart",
  keywords: words("this super static final const abstract class extends external factory " +
                  "implements mixin get native set typedef with enum throw rethrow assert break case " +
                  "continue default in return new deferred async await covariant try catch finally " +
                  "do else for if switch while import library export part of show hide is as extension " +
                  "on yield late required sealed base interface when inline"),
  blockKeywords: words("try catch finally do else for if switch while"),
  builtin: words("void bool num int double dynamic var String Null Never"),
  atoms: words("true false null"),
  // clike numbers without the suffixes, and with '_' separators.
  number: /^(?:0x[a-f\d_]+|(?:[\d_]+\.?[\d_]*|\.[\d_]+)(?:e[-+]?[\d_]+)?)/i,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_\.]/);
      return "meta";
    },

    // custom string handling to deal with triple-quoted strings and string interpolation
    "'": function(stream, state) {
      return tokenDartString("'", stream, state, false);
    },
    "\"": function(stream, state) {
      return tokenDartString("\"", stream, state, false);
    },
    "r": function(stream, state) {
      var peek = stream.peek();
      if (peek == "'" || peek == "\"") {
        return tokenDartString(stream.next(), stream, state, true);
      }
      return false;
    },

    "}": function(_stream, state) {
      // "}" is end of interpolation, if interpolation stack is non-empty
      if (sizeInterpolationStack(state) > 0) {
        state.tokenize = popInterpolationStack(state);
        return null;
      }
      return false;
    },

    "/": function(stream, state) {
      if (!stream.eat("*")) return false
      state.tokenize = tokenNestedComment(1)
      return state.tokenize(stream, state)
    },
    token: function(stream, _, style) {
      if (style == "variable") {
        // Assume uppercase symbols are classes
        var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$','g');
        if (isUpper.test(stream.current())) {
          return 'type';
        }
      }
    }
  }
})


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9jbGlrZV9qcy42YmIxZmRjZTg0NzYyMjIwN2ZlOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsc0NBQXNDO0FBQ3RDLDBDQUEwQztBQUMxQyxzREFBc0Q7QUFDdEQsa0RBQWtEO0FBQ2xELHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0Msa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlFQUFpRSxFQUFFLElBQUksY0FBYztBQUNyRixzQkFBc0Isb0JBQW9CLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsWUFBWTtBQUN4RSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLG1EQUFtRDtBQUNuRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkRBQTJELDZCQUE2QjtBQUN4RjtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHlDQUF5QyxJQUFJO0FBQzdDLGlDQUFpQztBQUNqQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLE1BQU07QUFDTixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2NsaWtlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgaW5mbywgYWxpZ24sIHByZXYpIHtcbiAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5pbmZvID0gaW5mbztcbiAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB0aGlzLnByZXYgPSBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSwgaW5mbykge1xuICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIHR5cGUgIT0gXCJzdGF0ZW1lbnRcIilcbiAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICByZXR1cm4gc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGluZGVudCwgY29sLCB0eXBlLCBpbmZvLCBudWxsLCBzdGF0ZS5jb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xufVxuXG5mdW5jdGlvbiB0eXBlQmVmb3JlKHN0cmVhbSwgc3RhdGUsIHBvcykge1xuICBpZiAoc3RhdGUucHJldlRva2VuID09IFwidmFyaWFibGVcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ0eXBlXCIpIHJldHVybiB0cnVlO1xuICBpZiAoL1xcUyg/OlteLSBdPnxbKlxcXV0pXFxzKiR8XFwqJC8udGVzdChzdHJlYW0uc3RyaW5nLnNsaWNlKDAsIHBvcykpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHN0YXRlLnR5cGVBdEVuZE9mTGluZSAmJiBzdHJlYW0uY29sdW1uKCkgPT0gc3RyZWFtLmluZGVudGF0aW9uKCkpIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1RvcFNjb3BlKGNvbnRleHQpIHtcbiAgZm9yICg7Oykge1xuICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0LnR5cGUgPT0gXCJ0b3BcIikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PSBcIn1cIiAmJiBjb250ZXh0LnByZXYuaW5mbyAhPSBcIm5hbWVzcGFjZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpa2UocGFyc2VyQ29uZmlnKSB7XG4gIHZhciBzdGF0ZW1lbnRJbmRlbnRVbml0ID0gcGFyc2VyQ29uZmlnLnN0YXRlbWVudEluZGVudFVuaXQsXG4gICAgICBkb250QWxpZ25DYWxscyA9IHBhcnNlckNvbmZpZy5kb250QWxpZ25DYWxscyxcbiAgICAgIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9LFxuICAgICAgdHlwZXMgPSBwYXJzZXJDb25maWcudHlwZXMgfHwge30sXG4gICAgICBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge30sXG4gICAgICBibG9ja0tleXdvcmRzID0gcGFyc2VyQ29uZmlnLmJsb2NrS2V5d29yZHMgfHwge30sXG4gICAgICBkZWZLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5kZWZLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGF0b21zID0gcGFyc2VyQ29uZmlnLmF0b21zIHx8IHt9LFxuICAgICAgaG9va3MgPSBwYXJzZXJDb25maWcuaG9va3MgfHwge30sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgICBpbmRlbnRTdGF0ZW1lbnRzID0gcGFyc2VyQ29uZmlnLmluZGVudFN0YXRlbWVudHMgIT09IGZhbHNlLFxuICAgICAgaW5kZW50U3dpdGNoID0gcGFyc2VyQ29uZmlnLmluZGVudFN3aXRjaCAhPT0gZmFsc2UsXG4gICAgICBuYW1lc3BhY2VTZXBhcmF0b3IgPSBwYXJzZXJDb25maWcubmFtZXNwYWNlU2VwYXJhdG9yLFxuICAgICAgaXNQdW5jdHVhdGlvbkNoYXIgPSBwYXJzZXJDb25maWcuaXNQdW5jdHVhdGlvbkNoYXIgfHwgL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8sXG4gICAgICBudW1iZXJTdGFydCA9IHBhcnNlckNvbmZpZy5udW1iZXJTdGFydCB8fCAvW1xcZFxcLl0vLFxuICAgICAgbnVtYmVyID0gcGFyc2VyQ29uZmlnLm51bWJlciB8fCAvXig/OjB4W2EtZlxcZF0rfDBiWzAxXSt8KD86XFxkK1xcLj9cXGQqfFxcLlxcZCspKD86ZVstK10/XFxkKyk/KSh1fGxsP3xsfGYpPy9pLFxuICAgICAgaXNPcGVyYXRvckNoYXIgPSBwYXJzZXJDb25maWcuaXNPcGVyYXRvckNoYXIgfHwgL1srXFwtKiYlPTw+IT98XFwvXS8sXG4gICAgICBpc0lkZW50aWZpZXJDaGFyID0gcGFyc2VyQ29uZmlnLmlzSWRlbnRpZmllckNoYXIgfHwgL1tcXHdcXCRfXFx4YTEtXFx1ZmZmZl0vLFxuICAgICAgLy8gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtzdHJpbmd9IHRva2VuIGFuZCByZXR1cm5zIHRydWUgaWYgaXRcbiAgICAgIC8vIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgYnVpbHRpbi5cbiAgICAgIGlzUmVzZXJ2ZWRJZGVudGlmaWVyID0gcGFyc2VyQ29uZmlnLmlzUmVzZXJ2ZWRJZGVudGlmaWVyIHx8IGZhbHNlO1xuXG4gIHZhciBjdXJQdW5jLCBpc0RlZktleXdvcmQ7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChob29rc1tjaF0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBob29rc1tjaF0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyU3RhcnQudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSlcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gobnVtYmVyKSkgcmV0dXJuIFwibnVtYmVyXCJcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICB9XG4gICAgaWYgKGlzUHVuY3R1YXRpb25DaGFyLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0ubWF0Y2goL15cXC9bXFwvKl0vLCBmYWxzZSkgJiYgc3RyZWFtLmVhdChpc09wZXJhdG9yQ2hhcikpIHt9XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNJZGVudGlmaWVyQ2hhcik7XG4gICAgaWYgKG5hbWVzcGFjZVNlcGFyYXRvcikgd2hpbGUgKHN0cmVhbS5tYXRjaChuYW1lc3BhY2VTZXBhcmF0b3IpKVxuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzSWRlbnRpZmllckNoYXIpO1xuXG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYgKGNvbnRhaW5zKGtleXdvcmRzLCBjdXIpKSB7XG4gICAgICBpZiAoY29udGFpbnMoYmxvY2tLZXl3b3JkcywgY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICBpZiAoY29udGFpbnMoZGVmS2V5d29yZHMsIGN1cikpIGlzRGVmS2V5d29yZCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIGlmIChjb250YWlucyh0eXBlcywgY3VyKSkgcmV0dXJuIFwidHlwZVwiO1xuICAgIGlmIChjb250YWlucyhidWlsdGluLCBjdXIpXG4gICAgICAgIHx8IChpc1Jlc2VydmVkSWRlbnRpZmllciAmJiBpc1Jlc2VydmVkSWRlbnRpZmllcihjdXIpKSkge1xuICAgICAgaWYgKGNvbnRhaW5zKGJsb2NrS2V5d29yZHMsIGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnMoYXRvbXMsIGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlRU9MKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAocGFyc2VyQ29uZmlnLnR5cGVGaXJzdERlZmluaXRpb25zICYmIHN0cmVhbS5lb2woKSAmJiBpc1RvcFNjb3BlKHN0YXRlLmNvbnRleHQpKVxuICAgICAgc3RhdGUudHlwZUF0RW5kT2ZMaW5lID0gdHlwZUJlZm9yZShzdHJlYW0sIHN0YXRlLCBzdHJlYW0ucG9zKVxuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwYXJzZXJDb25maWcubmFtZSxcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoLWluZGVudFVuaXQsIDAsIFwidG9wXCIsIG51bGwsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlLFxuICAgICAgICBwcmV2VG9rZW46IG51bGxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7IG1heWJlRU9MKHN0cmVhbSwgc3RhdGUpOyByZXR1cm4gbnVsbDsgfVxuICAgICAgY3VyUHVuYyA9IGlzRGVmS2V5d29yZCA9IG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIiB8fCBzdHlsZSA9PSBcIm1ldGFcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgICBpZiAoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiOlwiIHx8IChjdXJQdW5jID09IFwiLFwiICYmIHN0cmVhbS5tYXRjaCgvXlxccyooPzpcXC9cXC8uKik/JC8sIGZhbHNlKSkpXG4gICAgICAgIHdoaWxlIChzdGF0ZS5jb250ZXh0LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwie1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIn1cIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIl1cIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwifVwiKSB7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmIChpbmRlbnRTdGF0ZW1lbnRzICYmXG4gICAgICAgICAgICAgICAoKChjdHgudHlwZSA9PSBcIn1cIiB8fCBjdHgudHlwZSA9PSBcInRvcFwiKSAmJiBjdXJQdW5jICE9IFwiO1wiKSB8fFxuICAgICAgICAgICAgICAgIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGN1clB1bmMgPT0gXCJuZXdzdGF0ZW1lbnRcIikpKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwic3RhdGVtZW50XCIsIHN0cmVhbS5jdXJyZW50KCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUgPT0gXCJ2YXJpYWJsZVwiICYmXG4gICAgICAgICAgKChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJkZWZcIiB8fFxuICAgICAgICAgICAgKHBhcnNlckNvbmZpZy50eXBlRmlyc3REZWZpbml0aW9ucyAmJiB0eXBlQmVmb3JlKHN0cmVhbSwgc3RhdGUsIHN0cmVhbS5zdGFydCkgJiZcbiAgICAgICAgICAgICBpc1RvcFNjb3BlKHN0YXRlLmNvbnRleHQpICYmIHN0cmVhbS5tYXRjaCgvXlxccypcXCgvLCBmYWxzZSkpKSkpXG4gICAgICAgIHN0eWxlID0gXCJkZWZcIjtcblxuICAgICAgaWYgKGhvb2tzLnRva2VuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBob29rcy50b2tlbihzdHJlYW0sIHN0YXRlLCBzdHlsZSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgc3R5bGUgPSByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZSA9PSBcImRlZlwiICYmIHBhcnNlckNvbmZpZy5zdHlsZURlZnMgPT09IGZhbHNlKSBzdHlsZSA9IFwidmFyaWFibGVcIjtcblxuICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnByZXZUb2tlbiA9IGlzRGVmS2V5d29yZCA/IFwiZGVmXCIgOiBzdHlsZSB8fCBjdXJQdW5jO1xuICAgICAgbWF5YmVFT0woc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY29udGV4dCkge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPSBudWxsIHx8IHN0YXRlLnR5cGVBdEVuZE9mTGluZSAmJiBpc1RvcFNjb3BlKHN0YXRlLmNvbnRleHQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0LCBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBjbG9zaW5nID0gZmlyc3RDaGFyID09IGN0eC50eXBlO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBjdHggPSBjdHgucHJldjtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZG9udEluZGVudFN0YXRlbWVudHMpXG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIHBhcnNlckNvbmZpZy5kb250SW5kZW50U3RhdGVtZW50cy50ZXN0KGN0eC5pbmZvKSlcbiAgICAgICAgICBjdHggPSBjdHgucHJldlxuICAgICAgaWYgKGhvb2tzLmluZGVudCkge1xuICAgICAgICB2YXIgaG9vayA9IGhvb2tzLmluZGVudChzdGF0ZSwgY3R4LCB0ZXh0QWZ0ZXIsIGNvbnRleHQudW5pdCk7XG4gICAgICAgIGlmICh0eXBlb2YgaG9vayA9PSBcIm51bWJlclwiKSByZXR1cm4gaG9va1xuICAgICAgfVxuICAgICAgdmFyIHN3aXRjaEJsb2NrID0gY3R4LnByZXYgJiYgY3R4LnByZXYuaW5mbyA9PSBcInN3aXRjaFwiO1xuICAgICAgaWYgKHBhcnNlckNvbmZpZy5hbGxtYW5JbmRlbnRhdGlvbiAmJiAvW3soXS8udGVzdChmaXJzdENoYXIpKSB7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSAhPSBcInRvcFwiICYmIGN0eC50eXBlICE9IFwifVwiKSBjdHggPSBjdHgucHJldlxuICAgICAgICByZXR1cm4gY3R4LmluZGVudGVkXG4gICAgICB9XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIilcbiAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChmaXJzdENoYXIgPT0gXCJ7XCIgPyAwIDogc3RhdGVtZW50SW5kZW50VW5pdCB8fCBjb250ZXh0LnVuaXQpO1xuICAgICAgaWYgKGN0eC5hbGlnbiAmJiAoIWRvbnRBbGlnbkNhbGxzIHx8IGN0eC50eXBlICE9IFwiKVwiKSlcbiAgICAgICAgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcIilcIiAmJiAhY2xvc2luZylcbiAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChzdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGNvbnRleHQudW5pdCk7XG5cbiAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBjb250ZXh0LnVuaXQpICtcbiAgICAgICAgKCFjbG9zaW5nICYmIHN3aXRjaEJsb2NrICYmICEvXig/OmNhc2V8ZGVmYXVsdClcXGIvLnRlc3QodGV4dEFmdGVyKSA/IGNvbnRleHQudW5pdCA6IDApO1xuICAgIH0sXG5cbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgIGluZGVudE9uSW5wdXQ6IGluZGVudFN3aXRjaCA/IC9eXFxzKig/OmNhc2UgLio/OnxkZWZhdWx0OnxcXHtcXH0/fFxcfSkkLyA6IC9eXFxzKlt7fV0kLyxcbiAgICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX0sXG4gICAgICBhdXRvY29tcGxldGU6IE9iamVjdC5rZXlzKGtleXdvcmRzKS5jb25jYXQoT2JqZWN0LmtleXModHlwZXMpKS5jb25jYXQoT2JqZWN0LmtleXMoYnVpbHRpbikpLmNvbmNhdChPYmplY3Qua2V5cyhhdG9tcykpLFxuICAgICAgLi4ucGFyc2VyQ29uZmlnLmxhbmd1YWdlRGF0YVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBjb250YWlucyh3b3Jkcywgd29yZCkge1xuICBpZiAodHlwZW9mIHdvcmRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gd29yZHMod29yZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpO1xuICB9XG59XG52YXIgY0tleXdvcmRzID0gXCJhdXRvIGlmIGJyZWFrIGNhc2UgcmVnaXN0ZXIgY29udGludWUgcmV0dXJuIGRlZmF1bHQgZG8gc2l6ZW9mIFwiICtcbiAgICBcInN0YXRpYyBlbHNlIHN0cnVjdCBzd2l0Y2ggZXh0ZXJuIHR5cGVkZWYgdW5pb24gZm9yIGdvdG8gd2hpbGUgZW51bSBjb25zdCBcIiArXG4gICAgXCJ2b2xhdGlsZSBpbmxpbmUgcmVzdHJpY3QgYXNtIGZvcnRyYW5cIjtcblxuLy8gS2V5d29yZHMgZnJvbSBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAva2V5d29yZCBpbmNsdWRlcyBDKysyMC5cbnZhciBjcHBLZXl3b3JkcyA9IFwiYWxpZ25hcyBhbGlnbm9mIGFuZCBhbmRfZXEgYXVkaXQgYXhpb20gYml0YW5kIGJpdG9yIGNhdGNoIFwiICtcbiAgICBcImNsYXNzIGNvbXBsIGNvbmNlcHQgY29uc3RleHByIGNvbnN0X2Nhc3QgZGVjbHR5cGUgZGVsZXRlIGR5bmFtaWNfY2FzdCBcIiArXG4gICAgXCJleHBsaWNpdCBleHBvcnQgZmluYWwgZnJpZW5kIGltcG9ydCBtb2R1bGUgbXV0YWJsZSBuYW1lc3BhY2UgbmV3IG5vZXhjZXB0IFwiICtcbiAgICBcIm5vdCBub3RfZXEgb3BlcmF0b3Igb3Igb3JfZXEgb3ZlcnJpZGUgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIFwiICtcbiAgICBcInJlaW50ZXJwcmV0X2Nhc3QgcmVxdWlyZXMgc3RhdGljX2Fzc2VydCBzdGF0aWNfY2FzdCB0ZW1wbGF0ZSB0aGlzIFwiICtcbiAgICBcInRocmVhZF9sb2NhbCB0aHJvdyB0cnkgdHlwZWlkIHR5cGVuYW1lIHVzaW5nIHZpcnR1YWwgeG9yIHhvcl9lcVwiO1xuXG52YXIgb2JqQ0tleXdvcmRzID0gXCJieWNvcHkgYnlyZWYgaW4gaW5vdXQgb25ld2F5IG91dCBzZWxmIHN1cGVyIGF0b21pYyBub25hdG9taWMgcmV0YWluIGNvcHkgXCIgK1xuICAgIFwicmVhZHdyaXRlIHJlYWRvbmx5IHN0cm9uZyB3ZWFrIGFzc2lnbiB0eXBlb2YgbnVsbGFibGUgbm9ubnVsbCBudWxsX3Jlc2V0dGFibGUgX2NtZCBcIiArXG4gICAgXCJAaW50ZXJmYWNlIEBpbXBsZW1lbnRhdGlvbiBAZW5kIEBwcm90b2NvbCBAZW5jb2RlIEBwcm9wZXJ0eSBAc3ludGhlc2l6ZSBAZHluYW1pYyBAY2xhc3MgXCIgK1xuICAgIFwiQHB1YmxpYyBAcGFja2FnZSBAcHJpdmF0ZSBAcHJvdGVjdGVkIEByZXF1aXJlZCBAb3B0aW9uYWwgQHRyeSBAY2F0Y2ggQGZpbmFsbHkgQGltcG9ydCBcIiArXG4gICAgXCJAc2VsZWN0b3IgQGVuY29kZSBAZGVmcyBAc3luY2hyb25pemVkIEBhdXRvcmVsZWFzZXBvb2wgQGNvbXBhdGliaWxpdHlfYWxpYXMgQGF2YWlsYWJsZVwiO1xuXG52YXIgb2JqQ0J1aWx0aW5zID0gXCJGT1VOREFUSU9OX0VYUE9SVCBGT1VOREFUSU9OX0VYVEVSTiBOU19JTkxJTkUgTlNfRk9STUFUX0ZVTkNUSU9OIFwiICtcbiAgICBcIiBOU19SRVRVUk5TX1JFVEFJTkVETlNfRVJST1JfRU5VTSBOU19SRVRVUk5TX05PVF9SRVRBSU5FRCBOU19SRVRVUk5TX0lOTkVSX1BPSU5URVIgXCIgK1xuICAgIFwiTlNfREVTSUdOQVRFRF9JTklUSUFMSVpFUiBOU19FTlVNIE5TX09QVElPTlMgTlNfUkVRVUlSRVNfTklMX1RFUk1JTkFUSU9OIFwiICtcbiAgICBcIk5TX0FTU1VNRV9OT05OVUxMX0JFR0lOIE5TX0FTU1VNRV9OT05OVUxMX0VORCBOU19TV0lGVF9OQU1FIE5TX1JFRklORURfRk9SX1NXSUZUXCJcblxuLy8gRG8gbm90IHVzZSB0aGlzLiBVc2UgdGhlIGNUeXBlcyBmdW5jdGlvbiBiZWxvdy4gVGhpcyBpcyBnbG9iYWwganVzdCB0byBhdm9pZFxuLy8gZXhjZXNzaXZlIGNhbGxzIHdoZW4gY1R5cGVzIGlzIGJlaW5nIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBwYXJzZS5cbnZhciBiYXNpY0NUeXBlcyA9IHdvcmRzKFwiaW50IGxvbmcgY2hhciBzaG9ydCBkb3VibGUgZmxvYXQgdW5zaWduZWQgc2lnbmVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidm9pZCBib29sXCIpO1xuXG4vLyBEbyBub3QgdXNlIHRoaXMuIFVzZSB0aGUgb2JqQ1R5cGVzIGZ1bmN0aW9uIGJlbG93LiBUaGlzIGlzIGdsb2JhbCBqdXN0IHRvIGF2b2lkXG4vLyBleGNlc3NpdmUgY2FsbHMgd2hlbiBvYmpDVHlwZXMgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIHBhcnNlLlxudmFyIGJhc2ljT2JqQ1R5cGVzID0gd29yZHMoXCJTRUwgaW5zdGFuY2V0eXBlIGlkIENsYXNzIFByb3RvY29sIEJPT0xcIik7XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBpZGVudGlmaWVyIGlzIGEgXCJDXCIgdHlwZS5cbi8vIEMgdHlwZSBpcyBkZWZpbmVkIGFzIHRob3NlIHRoYXQgYXJlIHJlc2VydmVkIGJ5IHRoZSBjb21waWxlciAoYmFzaWNUeXBlcyksXG4vLyBhbmQgdGhvc2UgdGhhdCBlbmQgaW4gX3QgKFJlc2VydmVkIGJ5IFBPU0lYIGZvciB0eXBlcylcbi8vIGh0dHA6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9saWJjL21hbnVhbC9odG1sX25vZGUvUmVzZXJ2ZWQtTmFtZXMuaHRtbFxuZnVuY3Rpb24gY1R5cGVzKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIGNvbnRhaW5zKGJhc2ljQ1R5cGVzLCBpZGVudGlmaWVyKSB8fCAvLitfdCQvLnRlc3QoaWRlbnRpZmllcik7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBpZGVudGlmaWVyIGlzIGEgXCJPYmplY3RpdmUgQ1wiIHR5cGUuXG5mdW5jdGlvbiBvYmpDVHlwZXMoaWRlbnRpZmllcikge1xuICByZXR1cm4gY1R5cGVzKGlkZW50aWZpZXIpIHx8IGNvbnRhaW5zKGJhc2ljT2JqQ1R5cGVzLCBpZGVudGlmaWVyKTtcbn1cblxudmFyIGNCbG9ja0tleXdvcmRzID0gXCJjYXNlIGRvIGVsc2UgZm9yIGlmIHN3aXRjaCB3aGlsZSBzdHJ1Y3QgZW51bSB1bmlvblwiO1xudmFyIGNEZWZLZXl3b3JkcyA9IFwic3RydWN0IGVudW0gdW5pb25cIjtcblxuZnVuY3Rpb24gY3BwSG9vayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuc3RhcnRPZkxpbmUpIHJldHVybiBmYWxzZVxuICBmb3IgKHZhciBjaCwgbmV4dCA9IG51bGw7IGNoID0gc3RyZWFtLnBlZWsoKTspIHtcbiAgICBpZiAoY2ggPT0gXCJcXFxcXCIgJiYgc3RyZWFtLm1hdGNoKC9eLiQvKSkge1xuICAgICAgbmV4dCA9IGNwcEhvb2tcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0ubWF0Y2goL15cXC9bXFwvXFwqXS8sIGZhbHNlKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgc3RyZWFtLm5leHQoKVxuICB9XG4gIHN0YXRlLnRva2VuaXplID0gbmV4dFxuICByZXR1cm4gXCJtZXRhXCJcbn1cblxuZnVuY3Rpb24gcG9pbnRlckhvb2soX3N0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnByZXZUb2tlbiA9PSBcInR5cGVcIikgcmV0dXJuIFwidHlwZVwiO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZvciBDIGFuZCBDKysgKGFuZCBPYmpDKTogaWRlbnRpZmllcnMgc3RhcnRpbmcgd2l0aCBfX1xuLy8gb3IgXyBmb2xsb3dlZCBieSBhIGNhcGl0YWwgbGV0dGVyIGFyZSByZXNlcnZlZCBmb3IgdGhlIGNvbXBpbGVyLlxuZnVuY3Rpb24gY0lzUmVzZXJ2ZWRJZGVudGlmaWVyKHRva2VuKSB7XG4gIGlmICghdG9rZW4gfHwgdG9rZW4ubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICBpZiAodG9rZW5bMF0gIT0gJ18nKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodG9rZW5bMV0gPT0gJ18nKSB8fCAodG9rZW5bMV0gIT09IHRva2VuWzFdLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiBjcHAxNExpdGVyYWwoc3RyZWFtKSB7XG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLiddLyk7XG4gIHJldHVybiBcIm51bWJlclwiO1xufVxuXG5mdW5jdGlvbiBjcHAxMVN0cmluZ0hvb2soc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uYmFja1VwKDEpO1xuICAvLyBSYXcgc3RyaW5ncy5cbiAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OlJ8dThSfHVSfFVSfExSKS8pKSB7XG4gICAgdmFyIG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXCIoW15cXHNcXFxcKCldezAsMTZ9KVxcKC8pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGUuY3BwMTFSYXdTdHJpbmdEZWxpbSA9IG1hdGNoWzFdO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5SYXdTdHJpbmc7XG4gICAgcmV0dXJuIHRva2VuUmF3U3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIC8vIFVuaWNvZGUgc3RyaW5ncy9jaGFycy5cbiAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OnU4fHV8VXxMKS8pKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXltcIiddLywgLyogZWF0ICovIGZhbHNlKSkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJZ25vcmUgdGhpcyBob29rLlxuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNwcExvb2tzTGlrZUNvbnN0cnVjdG9yKHdvcmQpIHtcbiAgdmFyIGxhc3RUd28gPSAvKFxcdyspOjp+PyhcXHcrKSQvLmV4ZWMod29yZCk7XG4gIHJldHVybiBsYXN0VHdvICYmIGxhc3RUd29bMV0gPT0gbGFzdFR3b1syXTtcbn1cblxuLy8gQyMtc3R5bGUgc3RyaW5ncyB3aGVyZSBcIlwiIGVzY2FwZXMgYSBxdW90ZS5cbmZ1bmN0aW9uIHRva2VuQXRTdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChuZXh0ID09ICdcIicgJiYgIXN0cmVhbS5lYXQoJ1wiJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn1cblxuLy8gQysrMTEgcmF3IHN0cmluZyBsaXRlcmFsIGlzIDxwcmVmaXg+XCI8ZGVsaW0+KCBhbnl0aGluZyApPGRlbGltPlwiLCB3aGVyZVxuLy8gPGRlbGltPiBjYW4gYmUgYSBzdHJpbmcgdXAgdG8gMTYgY2hhcmFjdGVycyBsb25nLlxuZnVuY3Rpb24gdG9rZW5SYXdTdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgc3BlY2lhbCByZWdleCBtZWFuaW5ncy5cbiAgdmFyIGRlbGltID0gc3RhdGUuY3BwMTFSYXdTdHJpbmdEZWxpbS5yZXBsYWNlKC9bXlxcd1xcc10vZywgJ1xcXFwkJicpO1xuICB2YXIgbWF0Y2ggPSBzdHJlYW0ubWF0Y2gobmV3IFJlZ0V4cChcIi4qP1xcXFwpXCIgKyBkZWxpbSArICdcIicpKTtcbiAgaWYgKG1hdGNoKVxuICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgZWxzZVxuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBjb25zdCBjID0gY2xpa2Uoe1xuICBuYW1lOiBcImNcIixcbiAga2V5d29yZHM6IHdvcmRzKGNLZXl3b3JkcyksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKGNEZWZLZXl3b3JkcyksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJOVUxMIHRydWUgZmFsc2VcIiksXG4gIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gIGhvb2tzOiB7XG4gICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICB9XG59KVxuXG5leHBvcnQgY29uc3QgY3BwID0gY2xpa2Uoe1xuICBuYW1lOiBcImNwcFwiLFxuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBjcHBLZXl3b3JkcyksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzICsgXCIgY2xhc3MgdHJ5IGNhdGNoXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzICsgXCIgY2xhc3MgbmFtZXNwYWNlXCIpLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBOVUxMIG51bGxwdHJcIiksXG4gIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXnRlbXBsYXRlJC8sXG4gIGlzSWRlbnRpZmllckNoYXI6IC9bXFx3XFwkX35cXHhhMS1cXHVmZmZmXS8sXG4gIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gIGhvb2tzOiB7XG4gICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICAgIFwidVwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCJVXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIkxcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiUlwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCIwXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjFcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiMlwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCIzXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjRcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiNVwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI2XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjdcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiOFwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI5XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSwgc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIihcIiAmJlxuICAgICAgICAgIChzdGF0ZS5wcmV2VG9rZW4gPT0gXCI7XCIgfHwgc3RhdGUucHJldlRva2VuID09IG51bGwgfHxcbiAgICAgICAgICAgc3RhdGUucHJldlRva2VuID09IFwifVwiKSAmJlxuICAgICAgICAgIGNwcExvb2tzTGlrZUNvbnN0cnVjdG9yKHN0cmVhbS5jdXJyZW50KCkpKVxuICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9XG4gIH0sXG4gIG5hbWVzcGFjZVNlcGFyYXRvcjogXCI6OlwiXG59KTtcblxuZXhwb3J0IGNvbnN0IGphdmEgPSBjbGlrZSh7XG4gIG5hbWU6IFwiamF2YVwiLFxuICBrZXl3b3Jkczogd29yZHMoXCJhYnN0cmFjdCBhc3NlcnQgYnJlYWsgY2FzZSBjYXRjaCBjbGFzcyBjb25zdCBjb250aW51ZSBkZWZhdWx0IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiZG8gZWxzZSBlbnVtIGV4dGVuZHMgZmluYWwgZmluYWxseSBmb3IgZ290byBpZiBpbXBsZW1lbnRzIGltcG9ydCBcIiArXG4gICAgICAgICAgICAgICAgICBcImluc3RhbmNlb2YgaW50ZXJmYWNlIG5hdGl2ZSBuZXcgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJyZXR1cm4gc3RhdGljIHN0cmljdGZwIHN1cGVyIHN3aXRjaCBzeW5jaHJvbml6ZWQgdGhpcyB0aHJvdyB0aHJvd3MgdHJhbnNpZW50IFwiICtcbiAgICAgICAgICAgICAgICAgIFwidHJ5IHZvbGF0aWxlIHdoaWxlIEBpbnRlcmZhY2VcIiksXG4gIHR5cGVzOiB3b3JkcyhcInZhciBieXRlIHNob3J0IGludCBsb25nIGZsb2F0IGRvdWJsZSBib29sZWFuIGNoYXIgdm9pZCBCb29sZWFuIEJ5dGUgQ2hhcmFjdGVyIERvdWJsZSBGbG9hdCBcIiArXG4gICAgICAgICAgICAgICBcIkludGVnZXIgTG9uZyBOdW1iZXIgT2JqZWN0IFNob3J0IFN0cmluZyBTdHJpbmdCdWZmZXIgU3RyaW5nQnVpbGRlciBWb2lkXCIpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgaWYgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgaW50ZXJmYWNlIGVudW0gQGludGVyZmFjZVwiKSxcbiAgdHlwZUZpcnN0RGVmaW5pdGlvbnM6IHRydWUsXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgbnVtYmVyOiAvXig/OjB4W2EtZlxcZF9dK3wwYlswMV9dK3woPzpbXFxkX10rXFwuP1xcZCp8XFwuXFxkKykoPzplWy0rXT9bXFxkX10rKT8pKHV8bGw/fGx8Zik/L2ksXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgLy8gRG9uJ3QgbWF0Y2ggdGhlIEBpbnRlcmZhY2Uga2V5d29yZC5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goJ2ludGVyZmFjZScsIGZhbHNlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG4gICAgJ1wiJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJlYW0ubWF0Y2goL1wiXCIkLykpIHJldHVybiBmYWxzZTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5UcmlwbGVTdHJpbmc7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG59KVxuXG5leHBvcnQgY29uc3QgY3NoYXJwID0gY2xpa2Uoe1xuICBuYW1lOiBcImNzaGFycFwiLFxuICBrZXl3b3Jkczogd29yZHMoXCJhYnN0cmFjdCBhcyBhc3luYyBhd2FpdCBiYXNlIGJyZWFrIGNhc2UgY2F0Y2ggY2hlY2tlZCBjbGFzcyBjb25zdCBjb250aW51ZVwiICtcbiAgICAgICAgICAgICAgICAgIFwiIGRlZmF1bHQgZGVsZWdhdGUgZG8gZWxzZSBlbnVtIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmaW5hbGx5IGZpeGVkIGZvclwiICtcbiAgICAgICAgICAgICAgICAgIFwiIGZvcmVhY2ggZ290byBpZiBpbXBsaWNpdCBpbiBpbml0IGludGVyZmFjZSBpbnRlcm5hbCBpcyBsb2NrIG5hbWVzcGFjZSBuZXdcIiArXG4gICAgICAgICAgICAgICAgICBcIiBvcGVyYXRvciBvdXQgb3ZlcnJpZGUgcGFyYW1zIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyByZWFkb25seSByZWNvcmQgcmVmIHJlcXVpcmVkIHJldHVybiBzZWFsZWRcIiArXG4gICAgICAgICAgICAgICAgICBcIiBzaXplb2Ygc3RhY2thbGxvYyBzdGF0aWMgc3RydWN0IHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdW5jaGVja2VkXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgdW5zYWZlIHVzaW5nIHZpcnR1YWwgdm9pZCB2b2xhdGlsZSB3aGlsZSBhZGQgYWxpYXMgYXNjZW5kaW5nIGRlc2NlbmRpbmcgZHluYW1pYyBmcm9tIGdldFwiICtcbiAgICAgICAgICAgICAgICAgIFwiIGdsb2JhbCBncm91cCBpbnRvIGpvaW4gbGV0IG9yZGVyYnkgcGFydGlhbCByZW1vdmUgc2VsZWN0IHNldCB2YWx1ZSB2YXIgeWllbGRcIiksXG4gIHR5cGVzOiB3b3JkcyhcIkFjdGlvbiBCb29sZWFuIEJ5dGUgQ2hhciBEYXRlVGltZSBEYXRlVGltZU9mZnNldCBEZWNpbWFsIERvdWJsZSBGdW5jXCIgK1xuICAgICAgICAgICAgICAgXCIgR3VpZCBJbnQxNiBJbnQzMiBJbnQ2NCBPYmplY3QgU0J5dGUgU2luZ2xlIFN0cmluZyBUYXNrIFRpbWVTcGFuIFVJbnQxNiBVSW50MzJcIiArXG4gICAgICAgICAgICAgICBcIiBVSW50NjQgYm9vbCBieXRlIGNoYXIgZGVjaW1hbCBkb3VibGUgc2hvcnQgaW50IGxvbmcgb2JqZWN0XCIgICtcbiAgICAgICAgICAgICAgIFwiIHNieXRlIGZsb2F0IHN0cmluZyB1c2hvcnQgdWludCB1bG9uZ1wiKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXRjaCBjbGFzcyBkbyBlbHNlIGZpbmFsbHkgZm9yIGZvcmVhY2ggaWYgc3RydWN0IHN3aXRjaCB0cnkgd2hpbGVcIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhcImNsYXNzIGludGVyZmFjZSBuYW1lc3BhY2UgcmVjb3JkIHN0cnVjdCB2YXJcIiksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KCdcIicpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5BdFN0cmluZztcbiAgICAgICAgcmV0dXJuIHRva2VuQXRTdHJpbmcoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRva2VuVHJpcGxlU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGVzY2FwZWQgPSBmYWxzZTtcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICBpZiAoIWVzY2FwZWQgJiYgc3RyZWFtLm1hdGNoKCdcIlwiXCInKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSBzdHJlYW0ubmV4dCgpID09IFwiXFxcXFwiICYmICFlc2NhcGVkO1xuICB9XG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoXG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiKlwiICYmIHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PSAxKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkQ29tbWVudChkZXB0aCAtIDEpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGggKyAxKVxuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNjYWxhID0gY2xpa2Uoe1xuICBuYW1lOiBcInNjYWxhXCIsXG4gIGtleXdvcmRzOiB3b3JkcyhcbiAgICAvKiBzY2FsYSAqL1xuICAgIFwiYWJzdHJhY3QgY2FzZSBjYXRjaCBjbGFzcyBkZWYgZG8gZWxzZSBleHRlbmRzIGZpbmFsIGZpbmFsbHkgZm9yIGZvclNvbWUgaWYgXCIgK1xuICAgICAgXCJpbXBsaWNpdCBpbXBvcnQgbGF6eSBtYXRjaCBuZXcgbnVsbCBvYmplY3Qgb3ZlcnJpZGUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCByZXR1cm4gXCIgK1xuICAgICAgXCJzZWFsZWQgc3VwZXIgdGhpcyB0aHJvdyB0cmFpdCB0cnkgdHlwZSB2YWwgdmFyIHdoaWxlIHdpdGggeWllbGQgXyBcIiArXG5cbiAgICAvKiBwYWNrYWdlIHNjYWxhICovXG4gICAgXCJhc3NlcnQgYXNzdW1lIHJlcXVpcmUgcHJpbnQgcHJpbnRsbiBwcmludGYgcmVhZExpbmUgcmVhZEJvb2xlYW4gcmVhZEJ5dGUgcmVhZFNob3J0IFwiICtcbiAgICAgIFwicmVhZENoYXIgcmVhZEludCByZWFkTG9uZyByZWFkRmxvYXQgcmVhZERvdWJsZVwiXG4gICksXG4gIHR5cGVzOiB3b3JkcyhcbiAgICBcIkFueVZhbCBBcHAgQXBwbGljYXRpb24gQXJyYXkgQnVmZmVyZWRJdGVyYXRvciBCaWdEZWNpbWFsIEJpZ0ludCBDaGFyIENvbnNvbGUgRWl0aGVyIFwiICtcbiAgICAgIFwiRW51bWVyYXRpb24gRXF1aXYgRXJyb3IgRXhjZXB0aW9uIEZyYWN0aW9uYWwgRnVuY3Rpb24gSW5kZXhlZFNlcSBJbnQgSW50ZWdyYWwgSXRlcmFibGUgXCIgK1xuICAgICAgXCJJdGVyYXRvciBMaXN0IE1hcCBOdW1lcmljIE5pbCBOb3ROdWxsIE9wdGlvbiBPcmRlcmVkIE9yZGVyaW5nIFBhcnRpYWxGdW5jdGlvbiBQYXJ0aWFsT3JkZXJpbmcgXCIgK1xuICAgICAgXCJQcm9kdWN0IFByb3h5IFJhbmdlIFJlc3BvbmRlciBTZXEgU2VyaWFsaXphYmxlIFNldCBTcGVjaWFsaXphYmxlIFN0cmVhbSBTdHJpbmdCdWlsZGVyIFwiICtcbiAgICAgIFwiU3RyaW5nQ29udGV4dCBTeW1ib2wgVGhyb3dhYmxlIFRyYXZlcnNhYmxlIFRyYXZlcnNhYmxlT25jZSBUdXBsZSBVbml0IFZlY3RvciBcIiArXG5cbiAgICAvKiBwYWNrYWdlIGphdmEubGFuZyAqL1xuICAgIFwiQm9vbGVhbiBCeXRlIENoYXJhY3RlciBDaGFyU2VxdWVuY2UgQ2xhc3MgQ2xhc3NMb2FkZXIgQ2xvbmVhYmxlIENvbXBhcmFibGUgXCIgK1xuICAgICAgXCJDb21waWxlciBEb3VibGUgRXhjZXB0aW9uIEZsb2F0IEludGVnZXIgTG9uZyBNYXRoIE51bWJlciBPYmplY3QgUGFja2FnZSBQYWlyIFByb2Nlc3MgXCIgK1xuICAgICAgXCJSdW50aW1lIFJ1bm5hYmxlIFNlY3VyaXR5TWFuYWdlciBTaG9ydCBTdGFja1RyYWNlRWxlbWVudCBTdHJpY3RNYXRoIFN0cmluZyBcIiArXG4gICAgICBcIlN0cmluZ0J1ZmZlciBTeXN0ZW0gVGhyZWFkIFRocmVhZEdyb3VwIFRocmVhZExvY2FsIFRocm93YWJsZSBUcmlwbGUgVm9pZFwiXG4gICksXG4gIG11bHRpTGluZVN0cmluZ3M6IHRydWUsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZW51bSBkbyBlbHNlIGZpbmFsbHkgZm9yIGZvclNvbWUgaWYgbWF0Y2ggc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgZW51bSBkZWYgb2JqZWN0IHBhY2thZ2UgdHJhaXQgdHlwZSB2YWwgdmFyXCIpLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIGluZGVudFN0YXRlbWVudHM6IGZhbHNlLFxuICBpbmRlbnRTd2l0Y2g6IGZhbHNlLFxuICBpc09wZXJhdG9yQ2hhcjogL1srXFwtKiYlPTw+IT98XFwvIzpAXS8sXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9LFxuICAgICdcIic6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyZWFtLm1hdGNoKCdcIlwiJykpIHJldHVybiBmYWxzZTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5UcmlwbGVTdHJpbmc7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcbiAgICBcIidcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxcXFxbXidcXHNdK3xbXlxcXFwnXSknLykpIHJldHVybiBcImNoYXJhY3RlclwiXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXFx4YTEtXFx1ZmZmZl0vKTtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9LFxuICAgIFwiPVwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY3ggPSBzdGF0ZS5jb250ZXh0XG4gICAgICBpZiAoY3gudHlwZSA9PSBcIn1cIiAmJiBjeC5hbGlnbiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgICBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoY3guaW5kZW50ZWQsIGN4LmNvbHVtbiwgY3gudHlwZSwgY3guaW5mbywgbnVsbCwgY3gucHJldilcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXN0cmVhbS5lYXQoXCIqXCIpKSByZXR1cm4gZmFsc2VcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KDEpXG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCAnXCJcIlwiJ119XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0b2tlbktvdGxpblN0cmluZyh0cmlwbGVTdHJpbmcpe1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKCF0cmlwbGVTdHJpbmcgJiYgIWVzY2FwZWQgJiYgc3RyZWFtLm1hdGNoKCdcIicpICkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgIGlmICh0cmlwbGVTdHJpbmcgJiYgc3RyZWFtLm1hdGNoKCdcIlwiXCInKSkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgIG5leHQgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYoIWVzY2FwZWQgJiYgbmV4dCA9PSBcIiRcIiAmJiBzdHJlYW0ubWF0Y2goJ3snKSlcbiAgICAgICAgc3RyZWFtLnNraXBUbyhcIn1cIik7XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIiAmJiAhdHJpcGxlU3RyaW5nO1xuICAgIH1cbiAgICBpZiAoZW5kIHx8ICF0cmlwbGVTdHJpbmcpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGtvdGxpbiA9IGNsaWtlKHtcbiAgbmFtZTogXCJrb3RsaW5cIixcbiAga2V5d29yZHM6IHdvcmRzKFxuICAgIC8qa2V5d29yZHMqL1xuICAgIFwicGFja2FnZSBhcyB0eXBlYWxpYXMgY2xhc3MgaW50ZXJmYWNlIHRoaXMgc3VwZXIgdmFsIG9wZXJhdG9yIFwiICtcbiAgICAgIFwidmFyIGZ1biBmb3IgaXMgaW4gVGhpcyB0aHJvdyByZXR1cm4gYW5ub3RhdGlvbiBcIiArXG4gICAgICBcImJyZWFrIGNvbnRpbnVlIG9iamVjdCBpZiBlbHNlIHdoaWxlIGRvIHRyeSB3aGVuICFpbiAhaXMgYXM/IFwiICtcblxuICAgIC8qc29mdCBrZXl3b3JkcyovXG4gICAgXCJmaWxlIGltcG9ydCB3aGVyZSBieSBnZXQgc2V0IGFic3RyYWN0IGVudW0gb3BlbiBpbm5lciBvdmVycmlkZSBwcml2YXRlIHB1YmxpYyBpbnRlcm5hbCBcIiArXG4gICAgICBcInByb3RlY3RlZCBjYXRjaCBmaW5hbGx5IG91dCBmaW5hbCB2YXJhcmcgcmVpZmllZCBkeW5hbWljIGNvbXBhbmlvbiBjb25zdHJ1Y3RvciBpbml0IFwiICtcbiAgICAgIFwic2VhbGVkIGZpZWxkIHByb3BlcnR5IHJlY2VpdmVyIHBhcmFtIHNwYXJhbSBsYXRlaW5pdCBkYXRhIGlubGluZSBub2lubGluZSB0YWlscmVjIFwiICtcbiAgICAgIFwiZXh0ZXJuYWwgYW5ub3RhdGlvbiBjcm9zc2lubGluZSBjb25zdCBvcGVyYXRvciBpbmZpeCBzdXNwZW5kIGFjdHVhbCBleHBlY3Qgc2V0cGFyYW1cIlxuICApLFxuICB0eXBlczogd29yZHMoXG4gICAgLyogcGFja2FnZSBqYXZhLmxhbmcgKi9cbiAgICBcIkJvb2xlYW4gQnl0ZSBDaGFyYWN0ZXIgQ2hhclNlcXVlbmNlIENsYXNzIENsYXNzTG9hZGVyIENsb25lYWJsZSBDb21wYXJhYmxlIFwiICtcbiAgICAgIFwiQ29tcGlsZXIgRG91YmxlIEV4Y2VwdGlvbiBGbG9hdCBJbnRlZ2VyIExvbmcgTWF0aCBOdW1iZXIgT2JqZWN0IFBhY2thZ2UgUGFpciBQcm9jZXNzIFwiICtcbiAgICAgIFwiUnVudGltZSBSdW5uYWJsZSBTZWN1cml0eU1hbmFnZXIgU2hvcnQgU3RhY2tUcmFjZUVsZW1lbnQgU3RyaWN0TWF0aCBTdHJpbmcgXCIgK1xuICAgICAgXCJTdHJpbmdCdWZmZXIgU3lzdGVtIFRocmVhZCBUaHJlYWRHcm91cCBUaHJlYWRMb2NhbCBUaHJvd2FibGUgVHJpcGxlIFZvaWQgQW5ub3RhdGlvbiBBbnkgQm9vbGVhbkFycmF5IFwiICtcbiAgICAgIFwiQnl0ZUFycmF5IENoYXIgQ2hhckFycmF5IERlcHJlY2F0aW9uTGV2ZWwgRG91YmxlQXJyYXkgRW51bSBGbG9hdEFycmF5IEZ1bmN0aW9uIEludCBJbnRBcnJheSBMYXp5IFwiICtcbiAgICAgIFwiTGF6eVRocmVhZFNhZmV0eU1vZGUgTG9uZ0FycmF5IE5vdGhpbmcgU2hvcnRBcnJheSBVbml0XCJcbiAgKSxcbiAgaW50ZW5kU3dpdGNoOiBmYWxzZSxcbiAgaW5kZW50U3RhdGVtZW50czogZmFsc2UsXG4gIG11bHRpTGluZVN0cmluZ3M6IHRydWUsXG4gIG51bWJlcjogL14oPzoweFthLWZcXGRfXSt8MGJbMDFfXSt8KD86W1xcZF9dKyhcXC5cXGQrKT98XFwuXFxkKykoPzplWy0rXT9bXFxkX10rKT8pKHV8bGw/fGx8Zik/L2ksXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZG8gZWxzZSBmaW5hbGx5IGZvciBpZiB3aGVyZSB0cnkgd2hpbGUgZW51bVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgdmFsIHZhciBvYmplY3QgaW50ZXJmYWNlIGZ1blwiKSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBudWxsIHRoaXNcIiksXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9LFxuICAgICcqJzogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5wcmV2VG9rZW4gPT0gJy4nID8gJ3ZhcmlhYmxlJyA6ICdvcGVyYXRvcic7XG4gICAgfSxcbiAgICAnXCInOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuS290bGluU3RyaW5nKHN0cmVhbS5tYXRjaCgnXCJcIicpKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXN0cmVhbS5lYXQoXCIqXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkQ29tbWVudCgxKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgIH0sXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgY3R4LCB0ZXh0QWZ0ZXIsIGluZGVudFVuaXQpIHtcbiAgICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIGlmICgoc3RhdGUucHJldlRva2VuID09IFwifVwiIHx8IHN0YXRlLnByZXZUb2tlbiA9PSBcIilcIikgJiYgdGV4dEFmdGVyID09IFwiXCIpXG4gICAgICAgIHJldHVybiBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgIGlmICgoc3RhdGUucHJldlRva2VuID09IFwib3BlcmF0b3JcIiAmJiB0ZXh0QWZ0ZXIgIT0gXCJ9XCIgJiYgc3RhdGUuY29udGV4dC50eXBlICE9IFwifVwiKSB8fFxuICAgICAgICAgIHN0YXRlLnByZXZUb2tlbiA9PSBcInZhcmlhYmxlXCIgJiYgZmlyc3RDaGFyID09IFwiLlwiIHx8XG4gICAgICAgICAgKHN0YXRlLnByZXZUb2tlbiA9PSBcIn1cIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gXCIpXCIpICYmIGZpcnN0Q2hhciA9PSBcIi5cIilcbiAgICAgICAgcmV0dXJuIGluZGVudFVuaXQgKiAyICsgY3R4LmluZGVudGVkO1xuICAgICAgaWYgKGN0eC5hbGlnbiAmJiBjdHgudHlwZSA9PSBcIn1cIilcbiAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChzdGF0ZS5jb250ZXh0LnR5cGUgPT0gKHRleHRBZnRlciB8fCBcIlwiKS5jaGFyQXQoMCkgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfVxuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjbG9zZUJyYWNrZXRzOiB7YnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgJ1wiXCJcIiddfVxuICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IHNoYWRlciA9IGNsaWtlKHtcbiAgbmFtZTogXCJzaGFkZXJcIixcbiAga2V5d29yZHM6IHdvcmRzKFwic2FtcGxlcjFEIHNhbXBsZXIyRCBzYW1wbGVyM0Qgc2FtcGxlckN1YmUgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJzYW1wbGVyMURTaGFkb3cgc2FtcGxlcjJEU2hhZG93IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiY29uc3QgYXR0cmlidXRlIHVuaWZvcm0gdmFyeWluZyBcIiArXG4gICAgICAgICAgICAgICAgICBcImJyZWFrIGNvbnRpbnVlIGRpc2NhcmQgcmV0dXJuIFwiICtcbiAgICAgICAgICAgICAgICAgIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3RydWN0IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiaW4gb3V0IGlub3V0XCIpLFxuICB0eXBlczogd29yZHMoXCJmbG9hdCBpbnQgYm9vbCB2b2lkIFwiICtcbiAgICAgICAgICAgICAgIFwidmVjMiB2ZWMzIHZlYzQgaXZlYzIgaXZlYzMgaXZlYzQgYnZlYzIgYnZlYzMgYnZlYzQgXCIgK1xuICAgICAgICAgICAgICAgXCJtYXQyIG1hdDMgbWF0NFwiKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJmb3Igd2hpbGUgZG8gaWYgZWxzZSBzdHJ1Y3RcIiksXG4gIGJ1aWx0aW46IHdvcmRzKFwicmFkaWFucyBkZWdyZWVzIHNpbiBjb3MgdGFuIGFzaW4gYWNvcyBhdGFuIFwiICtcbiAgICAgICAgICAgICAgICAgXCJwb3cgZXhwIGxvZyBleHAyIHNxcnQgaW52ZXJzZXNxcnQgXCIgK1xuICAgICAgICAgICAgICAgICBcImFicyBzaWduIGZsb29yIGNlaWwgZnJhY3QgbW9kIG1pbiBtYXggY2xhbXAgbWl4IHN0ZXAgc21vb3Roc3RlcCBcIiArXG4gICAgICAgICAgICAgICAgIFwibGVuZ3RoIGRpc3RhbmNlIGRvdCBjcm9zcyBub3JtYWxpemUgZnRyYW5zZm9ybSBmYWNlZm9yd2FyZCBcIiArXG4gICAgICAgICAgICAgICAgIFwicmVmbGVjdCByZWZyYWN0IG1hdHJpeENvbXBNdWx0IFwiICtcbiAgICAgICAgICAgICAgICAgXCJsZXNzVGhhbiBsZXNzVGhhbkVxdWFsIGdyZWF0ZXJUaGFuIGdyZWF0ZXJUaGFuRXF1YWwgXCIgK1xuICAgICAgICAgICAgICAgICBcImVxdWFsIG5vdEVxdWFsIGFueSBhbGwgbm90IFwiICtcbiAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlMUQgdGV4dHVyZTFEUHJvaiB0ZXh0dXJlMURMb2QgdGV4dHVyZTFEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgIFwidGV4dHVyZTJEIHRleHR1cmUyRFByb2ogdGV4dHVyZTJETG9kIHRleHR1cmUyRFByb2pMb2QgXCIgK1xuICAgICAgICAgICAgICAgICBcInRleHR1cmUzRCB0ZXh0dXJlM0RQcm9qIHRleHR1cmUzRExvZCB0ZXh0dXJlM0RQcm9qTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlQ3ViZSB0ZXh0dXJlQ3ViZUxvZCBcIiArXG4gICAgICAgICAgICAgICAgIFwic2hhZG93MUQgc2hhZG93MkQgc2hhZG93MURQcm9qIHNoYWRvdzJEUHJvaiBcIiArXG4gICAgICAgICAgICAgICAgIFwic2hhZG93MURMb2Qgc2hhZG93MkRMb2Qgc2hhZG93MURQcm9qTG9kIHNoYWRvdzJEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgIFwiZEZkeCBkRmR5IGZ3aWR0aCBcIiArXG4gICAgICAgICAgICAgICAgIFwibm9pc2UxIG5vaXNlMiBub2lzZTMgbm9pc2U0XCIpLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yIGdsX1NlY29uZGFyeUNvbG9yIGdsX05vcm1hbCBnbF9WZXJ0ZXggXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NdWx0aVRleENvb3JkMCBnbF9NdWx0aVRleENvb3JkMSBnbF9NdWx0aVRleENvb3JkMiBnbF9NdWx0aVRleENvb3JkMyBcIiArXG4gICAgICAgICAgICAgICBcImdsX011bHRpVGV4Q29vcmQ0IGdsX011bHRpVGV4Q29vcmQ1IGdsX011bHRpVGV4Q29vcmQ2IGdsX011bHRpVGV4Q29vcmQ3IFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRm9nQ29vcmQgZ2xfUG9pbnRDb29yZCBcIiArXG4gICAgICAgICAgICAgICBcImdsX1Bvc2l0aW9uIGdsX1BvaW50U2l6ZSBnbF9DbGlwVmVydGV4IFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRnJvbnRDb2xvciBnbF9CYWNrQ29sb3IgZ2xfRnJvbnRTZWNvbmRhcnlDb2xvciBnbF9CYWNrU2Vjb25kYXJ5Q29sb3IgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9UZXhDb29yZCBnbF9Gb2dGcmFnQ29vcmQgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29vcmQgZ2xfRnJvbnRGYWNpbmcgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9GcmFnRGF0YSBnbF9GcmFnRGVwdGggXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Nb2RlbFZpZXdNYXRyaXggZ2xfUHJvamVjdGlvbk1hdHJpeCBnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4IFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZU1hdHJpeCBnbF9Ob3JtYWxNYXRyaXggZ2xfTW9kZWxWaWV3TWF0cml4SW52ZXJzZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlIGdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZU1hdHJpeFRyYW5zcG9zZSBnbF9Nb2RlbFZpZXdNYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfUHJvamVjdGlvbk1hdHJpeEludmVyc2VUcmFuc3Bvc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX1RleHR1cmVNYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTm9ybWFsU2NhbGUgZ2xfRGVwdGhSYW5nZSBnbF9DbGlwUGxhbmUgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Qb2ludCBnbF9Gcm9udE1hdGVyaWFsIGdsX0JhY2tNYXRlcmlhbCBnbF9MaWdodFNvdXJjZSBnbF9MaWdodE1vZGVsIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRnJvbnRMaWdodE1vZGVsUHJvZHVjdCBnbF9CYWNrTGlnaHRNb2RlbFByb2R1Y3QgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9UZXh0dXJlQ29sb3IgZ2xfRXllUGxhbmVTIGdsX0V5ZVBsYW5lVCBnbF9FeWVQbGFuZVIgZ2xfRXllUGxhbmVRIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfRm9nUGFyYW1ldGVycyBcIiArXG4gICAgICAgICAgICAgICBcImdsX01heExpZ2h0cyBnbF9NYXhDbGlwUGxhbmVzIGdsX01heFRleHR1cmVVbml0cyBnbF9NYXhUZXh0dXJlQ29vcmRzIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTWF4VmVydGV4QXR0cmlicyBnbF9NYXhWZXJ0ZXhVbmlmb3JtQ29tcG9uZW50cyBnbF9NYXhWYXJ5aW5nRmxvYXRzIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTWF4VmVydGV4VGV4dHVyZUltYWdlVW5pdHMgZ2xfTWF4VGV4dHVyZUltYWdlVW5pdHMgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NYXhGcmFnbWVudFVuaWZvcm1Db21wb25lbnRzIGdsX01heENvbWJpbmVUZXh0dXJlSW1hZ2VVbml0cyBcIiArXG4gICAgICAgICAgICAgICBcImdsX01heERyYXdCdWZmZXJzXCIpLFxuICBpbmRlbnRTd2l0Y2g6IGZhbHNlLFxuICBob29rczoge1wiI1wiOiBjcHBIb29rfVxufSlcblxuZXhwb3J0IGNvbnN0IG5lc0MgPSBjbGlrZSh7XG4gIG5hbWU6IFwibmVzY1wiLFxuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgYXMgYXRvbWljIGFzeW5jIGNhbGwgY29tbWFuZCBjb21wb25lbnQgY29tcG9uZW50cyBjb25maWd1cmF0aW9uIGV2ZW50IGdlbmVyaWMgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJpbXBsZW1lbnRhdGlvbiBpbmNsdWRlcyBpbnRlcmZhY2UgbW9kdWxlIG5ldyBub3JhY2Ugbnhfc3RydWN0IG54X3VuaW9uIHBvc3QgcHJvdmlkZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJzaWduYWwgdGFzayB1c2VzIGFic3RyYWN0IGV4dGVuZHNcIiksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzKSxcbiAgYXRvbXM6IHdvcmRzKFwibnVsbCB0cnVlIGZhbHNlXCIpLFxuICBob29rczoge1wiI1wiOiBjcHBIb29rfVxufSlcblxuZXhwb3J0IGNvbnN0IG9iamVjdGl2ZUMgPSBjbGlrZSh7XG4gIG5hbWU6IFwib2JqZWN0aXZlY1wiLFxuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBvYmpDS2V5d29yZHMpLFxuICB0eXBlczogb2JqQ1R5cGVzLFxuICBidWlsdGluOiB3b3JkcyhvYmpDQnVpbHRpbnMpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhjQmxvY2tLZXl3b3JkcyArIFwiIEBzeW50aGVzaXplIEB0cnkgQGNhdGNoIEBmaW5hbGx5IEBhdXRvcmVsZWFzZXBvb2wgQHN5bmNocm9uaXplZFwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKGNEZWZLZXl3b3JkcyArIFwiIEBpbnRlcmZhY2UgQGltcGxlbWVudGF0aW9uIEBwcm90b2NvbCBAY2xhc3NcIiksXG4gIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXkAuKiQvLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwiWUVTIE5PIE5VTEwgTmlsIG5pbCB0cnVlIGZhbHNlIG51bGxwdHJcIiksXG4gIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gIGhvb2tzOiB7XG4gICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICB9XG59KVxuXG5leHBvcnQgY29uc3Qgb2JqZWN0aXZlQ3BwID0gY2xpa2Uoe1xuICBuYW1lOiBcIm9iamVjdGl2ZWNwcFwiLFxuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBvYmpDS2V5d29yZHMgKyBcIiBcIiArIGNwcEtleXdvcmRzKSxcbiAgdHlwZXM6IG9iakNUeXBlcyxcbiAgYnVpbHRpbjogd29yZHMob2JqQ0J1aWx0aW5zKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMgKyBcIiBAc3ludGhlc2l6ZSBAdHJ5IEBjYXRjaCBAZmluYWxseSBAYXV0b3JlbGVhc2Vwb29sIEBzeW5jaHJvbml6ZWQgY2xhc3MgdHJ5IGNhdGNoXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzICsgXCIgQGludGVyZmFjZSBAaW1wbGVtZW50YXRpb24gQHByb3RvY29sIEBjbGFzcyBjbGFzcyBuYW1lc3BhY2VcIiksXG4gIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXkAuKiR8XnRlbXBsYXRlJC8sXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJZRVMgTk8gTlVMTCBOaWwgbmlsIHRydWUgZmFsc2UgbnVsbHB0clwiKSxcbiAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgaG9va3M6IHtcbiAgICBcIiNcIjogY3BwSG9vayxcbiAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gICAgXCJ1XCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIlVcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiTFwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCJSXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIjBcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiMVwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCIyXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjNcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiNFwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI1XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjZcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiN1wiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI4XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjlcIjogY3BwMTRMaXRlcmFsLFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlLCBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIiAmJiBzdHJlYW0ucGVlaygpID09IFwiKFwiICYmXG4gICAgICAgICAgKHN0YXRlLnByZXZUb2tlbiA9PSBcIjtcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ9XCIpICYmXG4gICAgICAgICAgY3BwTG9va3NMaWtlQ29uc3RydWN0b3Ioc3RyZWFtLmN1cnJlbnQoKSkpXG4gICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgIH1cbiAgfSxcbiAgbmFtZXNwYWNlU2VwYXJhdG9yOiBcIjo6XCJcbn0pXG5cbmV4cG9ydCBjb25zdCBzcXVpcnJlbCA9IGNsaWtlKHtcbiAgbmFtZTogXCJzcXVpcnJlbFwiLFxuICBrZXl3b3Jkczogd29yZHMoXCJiYXNlIGJyZWFrIGNsb25lIGNvbnRpbnVlIGNvbnN0IGRlZmF1bHQgZGVsZXRlIGVudW0gZXh0ZW5kcyBmdW5jdGlvbiBpbiBjbGFzc1wiICtcbiAgICAgICAgICAgICAgICAgIFwiIGZvcmVhY2ggbG9jYWwgcmVzdW1lIHJldHVybiB0aGlzIHRocm93IHR5cGVvZiB5aWVsZCBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIHN0YXRpY1wiKSxcbiAgdHlwZXM6IGNUeXBlcyxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXNlIGNhdGNoIGNsYXNzIGVsc2UgZm9yIGZvcmVhY2ggaWYgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiZnVuY3Rpb24gbG9jYWwgY2xhc3NcIiksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIGhvb2tzOiB7XCIjXCI6IGNwcEhvb2t9XG59KVxuXG4vLyBDZXlsb24gU3RyaW5ncyBuZWVkIHRvIGRlYWwgd2l0aCBpbnRlcnBvbGF0aW9uXG52YXIgc3RyaW5nVG9rZW5pemVyID0gbnVsbDtcbmZ1bmN0aW9uIHRva2VuQ2V5bG9uU3RyaW5nKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKCFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaCgnXCInKSAmJlxuICAgICAgICAgICh0eXBlID09IFwic2luZ2xlXCIgfHwgc3RyZWFtLm1hdGNoKCdcIlwiJykpKSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaCgnYGAnKSkge1xuICAgICAgICBzdHJpbmdUb2tlbml6ZXIgPSB0b2tlbkNleWxvblN0cmluZyh0eXBlKTtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuZXh0ID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIGVzY2FwZWQgPSB0eXBlID09IFwic2luZ2xlXCIgJiYgIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKGVuZClcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2V5bG9uID0gY2xpa2Uoe1xuICBuYW1lOiBcImNleWxvblwiLFxuICBrZXl3b3Jkczogd29yZHMoXCJhYnN0cmFjdHMgYWxpYXMgYXNzZW1ibHkgYXNzZXJ0IGFzc2lnbiBicmVhayBjYXNlIGNhdGNoIGNsYXNzIGNvbnRpbnVlIGR5bmFtaWMgZWxzZVwiICtcbiAgICAgICAgICAgICAgICAgIFwiIGV4aXN0cyBleHRlbmRzIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGdpdmVuIGlmIGltcG9ydCBpbiBpbnRlcmZhY2UgaXMgbGV0IG1vZHVsZSBuZXdcIiArXG4gICAgICAgICAgICAgICAgICBcIiBub25lbXB0eSBvYmplY3Qgb2Ygb3V0IG91dGVyIHBhY2thZ2UgcmV0dXJuIHNhdGlzZmllcyBzdXBlciBzd2l0Y2ggdGhlbiB0aGlzIHRocm93XCIgK1xuICAgICAgICAgICAgICAgICAgXCIgdHJ5IHZhbHVlIHZvaWQgd2hpbGVcIiksXG4gIHR5cGVzOiBmdW5jdGlvbih3b3JkKSB7XG4gICAgLy8gSW4gQ2V5bG9uIGFsbCBpZGVudGlmaWVycyB0aGF0IHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGFyZSB0eXBlc1xuICAgIHZhciBmaXJzdCA9IHdvcmQuY2hhckF0KDApO1xuICAgIHJldHVybiAoZmlyc3QgPT09IGZpcnN0LnRvVXBwZXJDYXNlKCkgJiYgZmlyc3QgIT09IGZpcnN0LnRvTG93ZXJDYXNlKCkpO1xuICB9LFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhc2UgY2F0Y2ggY2xhc3MgZHluYW1pYyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIGludGVyZmFjZSBtb2R1bGUgbmV3IG9iamVjdCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyBkeW5hbWljIGZ1bmN0aW9uIGludGVyZmFjZSBtb2R1bGUgb2JqZWN0IHBhY2thZ2UgdmFsdWVcIiksXG4gIGJ1aWx0aW46IHdvcmRzKFwiYWJzdHJhY3QgYWN0dWFsIGFsaWFzZWQgYW5ub3RhdGlvbiBieSBkZWZhdWx0IGRlcHJlY2F0ZWQgZG9jIGZpbmFsIGZvcm1hbCBsYXRlIGxpY2Vuc2VcIiArXG4gICAgICAgICAgICAgICAgIFwiIG5hdGl2ZSBvcHRpb25hbCBzZWFsZWQgc2VlIHNlcmlhbGl6YWJsZSBzaGFyZWQgc3VwcHJlc3NXYXJuaW5ncyB0YWdnZWQgdGhyb3dzIHZhcmlhYmxlXCIpLFxuICBpc1B1bmN0dWF0aW9uQ2hhcjogL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuYF0vLFxuICBpc09wZXJhdG9yQ2hhcjogL1srXFwtKiYlPTw+IT98Xn46XFwvXS8sXG4gIG51bWJlclN0YXJ0OiAvW1xcZCMkXS8sXG4gIG51bWJlcjogL14oPzojW1xcZGEtZkEtRl9dK3xcXCRbMDFfXSt8W1xcZF9dK1trTUdUUG11bnBmXT98W1xcZF9dK1xcLltcXGRfXSsoPzpbZUVdWy0rXT9cXGQrfFtrTUdUUG11bnBmXXwpfCkvaSxcbiAgbXVsdGlMaW5lU3RyaW5nczogdHJ1ZSxcbiAgdHlwZUZpcnN0RGVmaW5pdGlvbnM6IHRydWUsXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbCBsYXJnZXIgc21hbGxlciBlcXVhbCBlbXB0eSBmaW5pc2hlZFwiKSxcbiAgaW5kZW50U3dpdGNoOiBmYWxzZSxcbiAgc3R5bGVEZWZzOiBmYWxzZSxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG4gICAgJ1wiJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNleWxvblN0cmluZyhzdHJlYW0ubWF0Y2goJ1wiXCInKSA/IFwidHJpcGxlXCIgOiBcInNpbmdsZVwiKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuICAgICdgJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJpbmdUb2tlbml6ZXIgfHwgIXN0cmVhbS5tYXRjaCgnYCcpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHN0cmluZ1Rva2VuaXplcjtcbiAgICAgIHN0cmluZ1Rva2VuaXplciA9IG51bGw7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcbiAgICBcIidcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxcXFxbXidcXHNdK3xbXlxcXFwnXSknLykpIHJldHVybiBcInN0cmluZy5zcGVjaWFsXCJcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKF9zdHJlYW0sIHN0YXRlLCBzdHlsZSkge1xuICAgICAgaWYgKChzdHlsZSA9PSBcInZhcmlhYmxlXCIgfHwgc3R5bGUgPT0gXCJ0eXBlXCIpICYmXG4gICAgICAgICAgc3RhdGUucHJldlRva2VuID09IFwiLlwiKSB7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCI7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjbG9zZUJyYWNrZXRzOiB7YnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgJ1wiXCJcIiddfVxuICB9XG59KVxuXG5mdW5jdGlvbiBwdXNoSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gIChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgfHwgKHN0YXRlLmludGVycG9sYXRpb25TdGFjayA9IFtdKSkucHVzaChzdGF0ZS50b2tlbml6ZSk7XG59XG5cbmZ1bmN0aW9uIHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmludGVycG9sYXRpb25TdGFjayB8fCAoc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrID0gW10pKS5wb3AoKTtcbn1cblxuZnVuY3Rpb24gc2l6ZUludGVycG9sYXRpb25TdGFjayhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrID8gc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrLmxlbmd0aCA6IDA7XG59XG5cbmZ1bmN0aW9uIHRva2VuRGFydFN0cmluZyhxdW90ZSwgc3RyZWFtLCBzdGF0ZSwgcmF3KSB7XG4gIHZhciB0cmlwbGVRdW90ZWQgPSBmYWxzZTtcbiAgaWYgKHN0cmVhbS5lYXQocXVvdGUpKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQocXVvdGUpKSB0cmlwbGVRdW90ZWQgPSB0cnVlO1xuICAgIGVsc2UgcmV0dXJuIFwic3RyaW5nXCI7IC8vZW1wdHkgc3RyaW5nXG4gIH1cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmdIZWxwZXIoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIGlmICghcmF3ICYmICFlc2NhcGVkICYmIHN0cmVhbS5wZWVrKCkgPT0gXCIkXCIpIHtcbiAgICAgICAgcHVzaEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5JbnRlcnBvbGF0aW9uO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkICYmICghdHJpcGxlUXVvdGVkIHx8IHN0cmVhbS5tYXRjaChxdW90ZSArIHF1b3RlKSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhcmF3ICYmICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmdIZWxwZXI7XG4gIHJldHVybiB0b2tlblN0cmluZ0hlbHBlcihzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gdG9rZW5JbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLmVhdChcIiRcIik7XG4gIGlmIChzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgIC8vIGxldCBjbGlrZSBoYW5kbGUgdGhlIGNvbnRlbnQgb2YgJHsuLi59LFxuICAgIC8vIHdlIHRha2Ugb3ZlciBhZ2FpbiB3aGVuIFwifVwiIGFwcGVhcnMgKHNlZSBob29rcykuXG4gICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5JbnRlcnBvbGF0aW9uSWRlbnRpZmllcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9rZW5JbnRlcnBvbGF0aW9uSWRlbnRpZmllcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19dLyk7XG4gIHN0YXRlLnRva2VuaXplID0gcG9wSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKTtcbiAgcmV0dXJuIFwidmFyaWFibGVcIjtcbn1cblxuZXhwb3J0IGNvbnN0IGRhcnQgPSBjbGlrZSh7XG4gIG5hbWU6IFwiZGFydFwiLFxuICBrZXl3b3Jkczogd29yZHMoXCJ0aGlzIHN1cGVyIHN0YXRpYyBmaW5hbCBjb25zdCBhYnN0cmFjdCBjbGFzcyBleHRlbmRzIGV4dGVybmFsIGZhY3RvcnkgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJpbXBsZW1lbnRzIG1peGluIGdldCBuYXRpdmUgc2V0IHR5cGVkZWYgd2l0aCBlbnVtIHRocm93IHJldGhyb3cgYXNzZXJ0IGJyZWFrIGNhc2UgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJjb250aW51ZSBkZWZhdWx0IGluIHJldHVybiBuZXcgZGVmZXJyZWQgYXN5bmMgYXdhaXQgY292YXJpYW50IHRyeSBjYXRjaCBmaW5hbGx5IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiZG8gZWxzZSBmb3IgaWYgc3dpdGNoIHdoaWxlIGltcG9ydCBsaWJyYXJ5IGV4cG9ydCBwYXJ0IG9mIHNob3cgaGlkZSBpcyBhcyBleHRlbnNpb24gXCIgK1xuICAgICAgICAgICAgICAgICAgXCJvbiB5aWVsZCBsYXRlIHJlcXVpcmVkIHNlYWxlZCBiYXNlIGludGVyZmFjZSB3aGVuIGlubGluZVwiKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJ0cnkgY2F0Y2ggZmluYWxseSBkbyBlbHNlIGZvciBpZiBzd2l0Y2ggd2hpbGVcIiksXG4gIGJ1aWx0aW46IHdvcmRzKFwidm9pZCBib29sIG51bSBpbnQgZG91YmxlIGR5bmFtaWMgdmFyIFN0cmluZyBOdWxsIE5ldmVyXCIpLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIC8vIGNsaWtlIG51bWJlcnMgd2l0aG91dCB0aGUgc3VmZml4ZXMsIGFuZCB3aXRoICdfJyBzZXBhcmF0b3JzLlxuICBudW1iZXI6IC9eKD86MHhbYS1mXFxkX10rfCg/OltcXGRfXStcXC4/W1xcZF9dKnxcXC5bXFxkX10rKSg/OmVbLStdP1tcXGRfXSspPykvaSxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXFwuXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG5cbiAgICAvLyBjdXN0b20gc3RyaW5nIGhhbmRsaW5nIHRvIGRlYWwgd2l0aCB0cmlwbGUtcXVvdGVkIHN0cmluZ3MgYW5kIHN0cmluZyBpbnRlcnBvbGF0aW9uXG4gICAgXCInXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiB0b2tlbkRhcnRTdHJpbmcoXCInXCIsIHN0cmVhbSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9LFxuICAgIFwiXFxcIlwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gdG9rZW5EYXJ0U3RyaW5nKFwiXFxcIlwiLCBzdHJlYW0sIHN0YXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBcInJcIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHBlZWsgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgaWYgKHBlZWsgPT0gXCInXCIgfHwgcGVlayA9PSBcIlxcXCJcIikge1xuICAgICAgICByZXR1cm4gdG9rZW5EYXJ0U3RyaW5nKHN0cmVhbS5uZXh0KCksIHN0cmVhbSwgc3RhdGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBcIn1cIjogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgIC8vIFwifVwiIGlzIGVuZCBvZiBpbnRlcnBvbGF0aW9uLCBpZiBpbnRlcnBvbGF0aW9uIHN0YWNrIGlzIG5vbi1lbXB0eVxuICAgICAgaWYgKHNpemVJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpID4gMCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkQ29tbWVudCgxKVxuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgfSxcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBfLCBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIikge1xuICAgICAgICAvLyBBc3N1bWUgdXBwZXJjYXNlIHN5bWJvbHMgYXJlIGNsYXNzZXNcbiAgICAgICAgdmFyIGlzVXBwZXIgPSBSZWdFeHAoJ15bXyRdKltBLVpdW2EtekEtWjAtOV8kXSokJywnZycpO1xuICAgICAgICBpZiAoaXNVcHBlci50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgICAgcmV0dXJuICd0eXBlJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==