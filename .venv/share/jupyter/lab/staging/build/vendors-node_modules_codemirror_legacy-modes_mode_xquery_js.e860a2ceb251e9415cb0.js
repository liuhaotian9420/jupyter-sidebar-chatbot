"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_xquery_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/xquery.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/xquery.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   xQuery: () => (/* binding */ xQuery)
/* harmony export */ });
// The keywords object is set to the result of this self executing
// function. Each keyword is a property of the keywords object whose
// value is {type: atype, style: astyle}
var keywords = function(){
  // convenience functions used to build keywords object
  function kw(type) {return {type: type, style: "keyword"};}
  var operator = kw("operator")
  , atom = {type: "atom", style: "atom"}
  , punctuation = {type: "punctuation", style: null}
  , qualifier = {type: "axis_specifier", style: "qualifier"};

  // kwObj is what is return from this function at the end
  var kwObj = {
    ',': punctuation
  };

  // a list of 'basic' keywords. For each add a property to kwObj with the value of
  // {type: basic[i], style: "keyword"} e.g. 'after' --> {type: "after", style: "keyword"}
  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',
               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',
               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',
               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',
               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',
               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',
               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',
               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',
               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',
               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',
               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',
               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',
               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',
               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',
               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',
               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',
               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',
               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',
               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',
               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];
  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};

  // a list of types. For each add a property to kwObj with the value of
  // {type: "atom", style: "atom"}
  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',
               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',
               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',
               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',
               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',
               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',
               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',
               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',
               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',
               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];
  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};

  // each operator will add a property to kwObj with value of {type: "operator", style: "keyword"}
  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];
  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};

  // each axis_specifiers will add a property to kwObj with value of {type: "axis_specifier", style: "qualifier"}
  var axis_specifiers = ["self::", "attribute::", "child::", "descendant::", "descendant-or-self::", "parent::",
                         "ancestor::", "ancestor-or-self::", "following::", "preceding::", "following-sibling::", "preceding-sibling::"];
  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };

  return kwObj;
}();

function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

// the primary mode tokenizer
function tokenBase(stream, state) {
  var ch = stream.next(),
      mightBeFunction = false,
      isEQName = isEQNameAhead(stream);

  // an XML tag (if not in some sub, chained tokenizer)
  if (ch == "<") {
    if(stream.match("!--", true))
      return chain(stream, state, tokenXMLComment);

    if(stream.match("![CDATA", false)) {
      state.tokenize = tokenCDATA;
      return "tag";
    }

    if(stream.match("?", false)) {
      return chain(stream, state, tokenPreProcessing);
    }

    var isclose = stream.eat("/");
    stream.eatSpace();
    var tagName = "", c;
    while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;

    return chain(stream, state, tokenTag(tagName, isclose));
  }
  // start code block
  else if(ch == "{") {
    pushStateStack(state, { type: "codeblock"});
    return null;
  }
  // end code block
  else if(ch == "}") {
    popStateStack(state);
    return null;
  }
  // if we're in an XML block
  else if(isInXmlBlock(state)) {
    if(ch == ">")
      return "tag";
    else if(ch == "/" && stream.eat(">")) {
      popStateStack(state);
      return "tag";
    }
    else
      return "variable";
  }
  // if a number
  else if (/\d/.test(ch)) {
    stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/);
    return "atom";
  }
  // comment start
  else if (ch === "(" && stream.eat(":")) {
    pushStateStack(state, { type: "comment"});
    return chain(stream, state, tokenComment);
  }
  // quoted string
  else if (!isEQName && (ch === '"' || ch === "'"))
    return chain(stream, state, tokenString(ch));
  // variable
  else if(ch === "$") {
    return chain(stream, state, tokenVariable);
  }
  // assignment
  else if(ch ===":" && stream.eat("=")) {
    return "keyword";
  }
  // open paren
  else if(ch === "(") {
    pushStateStack(state, { type: "paren"});
    return null;
  }
  // close paren
  else if(ch === ")") {
    popStateStack(state);
    return null;
  }
  // open paren
  else if(ch === "[") {
    pushStateStack(state, { type: "bracket"});
    return null;
  }
  // close paren
  else if(ch === "]") {
    popStateStack(state);
    return null;
  }
  else {
    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];

    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function
    if(isEQName && ch === '\"') while(stream.next() !== '"'){}
    if(isEQName && ch === '\'') while(stream.next() !== '\''){}

    // gobble up a word if the character is not known
    if(!known) stream.eatWhile(/[\w\$_-]/);

    // gobble a colon in the case that is a lib func type call fn:doc
    var foundColon = stream.eat(":");

    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier
    // which should get matched as a keyword
    if(!stream.eat(":") && foundColon) {
      stream.eatWhile(/[\w\$_-]/);
    }
    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)
    if(stream.match(/^[ \t]*\(/, false)) {
      mightBeFunction = true;
    }
    // is the word a keyword?
    var word = stream.current();
    known = keywords.propertyIsEnumerable(word) && keywords[word];

    // if we think it's a function call but not yet known,
    // set style to variable for now for lack of something better
    if(mightBeFunction && !known) known = {type: "function_call", style: "def"};

    // if the previous word was element, attribute, axis specifier, this word should be the name of that
    if(isInXmlConstructor(state)) {
      popStateStack(state);
      return "variable";
    }
    // as previously checked, if the word is element,attribute, axis specifier, call it an "xmlconstructor" and
    // push the stack so we know to look for it on the next word
    if(word == "element" || word == "attribute" || known.type == "axis_specifier") pushStateStack(state, {type: "xmlconstructor"});

    // if the word is known, return the details of that else just call this a generic 'word'
    return known ? known.style : "variable";
  }
}

// handle comments, including nested
function tokenComment(stream, state) {
  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
  while (ch = stream.next()) {
    if (ch == ")" && maybeEnd) {
      if(nestedCount > 0)
        nestedCount--;
      else {
        popStateStack(state);
        break;
      }
    }
    else if(ch == ":" && maybeNested) {
      nestedCount++;
    }
    maybeEnd = (ch == ":");
    maybeNested = (ch == "(");
  }

  return "comment";
}

// tokenizer for string literals
// optionally pass a tokenizer function to set state.tokenize back to when finished
function tokenString(quote, f) {
  return function(stream, state) {
    var ch;

    if(isInString(state) && stream.current() == quote) {
      popStateStack(state);
      if(f) state.tokenize = f;
      return "string";
    }

    pushStateStack(state, { type: "string", name: quote, tokenize: tokenString(quote, f) });

    // if we're in a string and in an XML block, allow an embedded code block
    if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
      state.tokenize = tokenBase;
      return "string";
    }


    while (ch = stream.next()) {
      if (ch ==  quote) {
        popStateStack(state);
        if(f) state.tokenize = f;
        break;
      }
      else {
        // if we're in a string and in an XML block, allow an embedded code block in an attribute
        if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
          state.tokenize = tokenBase;
          return "string";
        }

      }
    }

    return "string";
  };
}

// tokenizer for variables
function tokenVariable(stream, state) {
  var isVariableChar = /[\w\$_-]/;

  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
  if(stream.eat("\"")) {
    while(stream.next() !== '\"'){};
    stream.eat(":");
  } else {
    stream.eatWhile(isVariableChar);
    if(!stream.match(":=", false)) stream.eat(":");
  }
  stream.eatWhile(isVariableChar);
  state.tokenize = tokenBase;
  return "variable";
}

// tokenizer for XML tags
function tokenTag(name, isclose) {
  return function(stream, state) {
    stream.eatSpace();
    if(isclose && stream.eat(">")) {
      popStateStack(state);
      state.tokenize = tokenBase;
      return "tag";
    }
    // self closing tag without attributes?
    if(!stream.eat("/"))
      pushStateStack(state, { type: "tag", name: name, tokenize: tokenBase});
    if(!stream.eat(">")) {
      state.tokenize = tokenAttribute;
      return "tag";
    }
    else {
      state.tokenize = tokenBase;
    }
    return "tag";
  };
}

// tokenizer for XML attributes
function tokenAttribute(stream, state) {
  var ch = stream.next();

  if(ch == "/" && stream.eat(">")) {
    if(isInXmlAttributeBlock(state)) popStateStack(state);
    if(isInXmlBlock(state)) popStateStack(state);
    return "tag";
  }
  if(ch == ">") {
    if(isInXmlAttributeBlock(state)) popStateStack(state);
    return "tag";
  }
  if(ch == "=")
    return null;
  // quoted string
  if (ch == '"' || ch == "'")
    return chain(stream, state, tokenString(ch, tokenAttribute));

  if(!isInXmlAttributeBlock(state))
    pushStateStack(state, { type: "attribute", tokenize: tokenAttribute});

  stream.eat(/[a-zA-Z_:]/);
  stream.eatWhile(/[-a-zA-Z0-9_:.]/);
  stream.eatSpace();

  // the case where the attribute has not value and the tag was closed
  if(stream.match(">", false) || stream.match("/", false)) {
    popStateStack(state);
    state.tokenize = tokenBase;
  }

  return "attribute";
}

// handle comments, including nested
function tokenXMLComment(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "-" && stream.match("->", true)) {
      state.tokenize = tokenBase;
      return "comment";
    }
  }
}


// handle CDATA
function tokenCDATA(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "]" && stream.match("]", true)) {
      state.tokenize = tokenBase;
      return "comment";
    }
  }
}

// handle preprocessing instructions
function tokenPreProcessing(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "?" && stream.match(">", true)) {
      state.tokenize = tokenBase;
      return "processingInstruction";
    }
  }
}


// functions to test the current context of the state
function isInXmlBlock(state) { return isIn(state, "tag"); }
function isInXmlAttributeBlock(state) { return isIn(state, "attribute"); }
function isInXmlConstructor(state) { return isIn(state, "xmlconstructor"); }
function isInString(state) { return isIn(state, "string"); }

function isEQNameAhead(stream) {
  // assume we've already eaten a quote (")
  if(stream.current() === '"')
    return stream.match(/^[^\"]+\"\:/, false);
  else if(stream.current() === '\'')
    return stream.match(/^[^\"]+\'\:/, false);
  else
    return false;
}

function isIn(state, type) {
  return (state.stack.length && state.stack[state.stack.length - 1].type == type);
}

function pushStateStack(state, newState) {
  state.stack.push(newState);
}

function popStateStack(state) {
  state.stack.pop();
  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;
  state.tokenize = reinstateTokenize || tokenBase;
}

// the interface for the mode API
const xQuery = {
  name: "xquery",
  startState: function() {
    return {
      tokenize: tokenBase,
      cc: [],
      stack: []
    };
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);
    return style;
  },

  languageData: {
    commentTokens: {block: {open: "(:", close: ":)"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV94cXVlcnlfanMuZTg2MGEyY2ViMjUxZTk0MTVjYjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxrQ0FBa0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxPQUFPOztBQUU3QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLE9BQU87O0FBRTdDLCtEQUErRDtBQUMvRDtBQUNBLG1DQUFtQyxPQUFPLE9BQU87O0FBRWpELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sT0FBTzs7QUFFdkQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHVCQUF1Qjs7QUFFakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qiw4REFBOEQ7O0FBRTFGO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDRDQUE0Qzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS94cXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIGtleXdvcmRzIG9iamVjdCBpcyBzZXQgdG8gdGhlIHJlc3VsdCBvZiB0aGlzIHNlbGYgZXhlY3V0aW5nXG4vLyBmdW5jdGlvbi4gRWFjaCBrZXl3b3JkIGlzIGEgcHJvcGVydHkgb2YgdGhlIGtleXdvcmRzIG9iamVjdCB3aG9zZVxuLy8gdmFsdWUgaXMge3R5cGU6IGF0eXBlLCBzdHlsZTogYXN0eWxlfVxudmFyIGtleXdvcmRzID0gZnVuY3Rpb24oKXtcbiAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb25zIHVzZWQgdG8gYnVpbGQga2V5d29yZHMgb2JqZWN0XG4gIGZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxuICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpXG4gICwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICAsIHB1bmN0dWF0aW9uID0ge3R5cGU6IFwicHVuY3R1YXRpb25cIiwgc3R5bGU6IG51bGx9XG4gICwgcXVhbGlmaWVyID0ge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9O1xuXG4gIC8vIGt3T2JqIGlzIHdoYXQgaXMgcmV0dXJuIGZyb20gdGhpcyBmdW5jdGlvbiBhdCB0aGUgZW5kXG4gIHZhciBrd09iaiA9IHtcbiAgICAnLCc6IHB1bmN0dWF0aW9uXG4gIH07XG5cbiAgLy8gYSBsaXN0IG9mICdiYXNpYycga2V5d29yZHMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gIC8vIHt0eXBlOiBiYXNpY1tpXSwgc3R5bGU6IFwia2V5d29yZFwifSBlLmcuICdhZnRlcicgLS0+IHt0eXBlOiBcImFmdGVyXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgdmFyIGJhc2ljID0gWydhZnRlcicsICdhbGwnLCAnYWxsb3dpbmcnLCAnYW5jZXN0b3InLCAnYW5jZXN0b3Itb3Itc2VsZicsICdhbnknLCAnYXJyYXknLCAnYXMnLFxuICAgICAgICAgICAgICAgJ2FzY2VuZGluZycsICdhdCcsICdhdHRyaWJ1dGUnLCAnYmFzZS11cmknLCAnYmVmb3JlJywgJ2JvdW5kYXJ5LXNwYWNlJywgJ2J5JywgJ2Nhc2UnLCAnY2FzdCcsXG4gICAgICAgICAgICAgICAnY2FzdGFibGUnLCAnY2F0Y2gnLCAnY2hpbGQnLCAnY29sbGF0aW9uJywgJ2NvbW1lbnQnLCAnY29uc3RydWN0aW9uJywgJ2NvbnRhaW5zJywgJ2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgJ2NvbnRleHQnLCAnY29weScsICdjb3B5LW5hbWVzcGFjZXMnLCAnY291bnQnLCAnZGVjaW1hbC1mb3JtYXQnLCAnZGVjbGFyZScsICdkZWZhdWx0JywgJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAnZGVzY2VuZGFudCcsICdkZXNjZW5kYW50LW9yLXNlbGYnLCAnZGVzY2VuZGluZycsICdkaWFjcml0aWNzJywgJ2RpZmZlcmVudCcsICdkaXN0YW5jZScsXG4gICAgICAgICAgICAgICAnZG9jdW1lbnQnLCAnZG9jdW1lbnQtbm9kZScsICdlbGVtZW50JywgJ2Vsc2UnLCAnZW1wdHknLCAnZW1wdHktc2VxdWVuY2UnLCAnZW5jb2RpbmcnLCAnZW5kJyxcbiAgICAgICAgICAgICAgICdlbnRpcmUnLCAnZXZlcnknLCAnZXhhY3RseScsICdleGNlcHQnLCAnZXh0ZXJuYWwnLCAnZmlyc3QnLCAnZm9sbG93aW5nJywgJ2ZvbGxvd2luZy1zaWJsaW5nJyxcbiAgICAgICAgICAgICAgICdmb3InLCAnZnJvbScsICdmdGFuZCcsICdmdG5vdCcsICdmdC1vcHRpb24nLCAnZnRvcicsICdmdW5jdGlvbicsICdmdXp6eScsICdncmVhdGVzdCcsICdncm91cCcsXG4gICAgICAgICAgICAgICAnaWYnLCAnaW1wb3J0JywgJ2luJywgJ2luaGVyaXQnLCAnaW5zZW5zaXRpdmUnLCAnaW5zZXJ0JywgJ2luc3RhbmNlJywgJ2ludGVyc2VjdCcsICdpbnRvJyxcbiAgICAgICAgICAgICAgICdpbnZva2UnLCAnaXMnLCAnaXRlbScsICdsYW5ndWFnZScsICdsYXN0JywgJ2xheCcsICdsZWFzdCcsICdsZXQnLCAnbGV2ZWxzJywgJ2xvd2VyY2FzZScsICdtYXAnLFxuICAgICAgICAgICAgICAgJ21vZGlmeScsICdtb2R1bGUnLCAnbW9zdCcsICduYW1lc3BhY2UnLCAnbmV4dCcsICdubycsICdub2RlJywgJ25vZGVzJywgJ25vLWluaGVyaXQnLFxuICAgICAgICAgICAgICAgJ25vLXByZXNlcnZlJywgJ25vdCcsICdvY2N1cnMnLCAnb2YnLCAnb25seScsICdvcHRpb24nLCAnb3JkZXInLCAnb3JkZXJlZCcsICdvcmRlcmluZycsXG4gICAgICAgICAgICAgICAncGFyYWdyYXBoJywgJ3BhcmFncmFwaHMnLCAncGFyZW50JywgJ3BocmFzZScsICdwcmVjZWRpbmcnLCAncHJlY2VkaW5nLXNpYmxpbmcnLCAncHJlc2VydmUnLFxuICAgICAgICAgICAgICAgJ3ByZXZpb3VzJywgJ3Byb2Nlc3NpbmctaW5zdHJ1Y3Rpb24nLCAncmVsYXRpb25zaGlwJywgJ3JlbmFtZScsICdyZXBsYWNlJywgJ3JldHVybicsXG4gICAgICAgICAgICAgICAncmV2YWxpZGF0aW9uJywgJ3NhbWUnLCAnc2F0aXNmaWVzJywgJ3NjaGVtYScsICdzY2hlbWEtYXR0cmlidXRlJywgJ3NjaGVtYS1lbGVtZW50JywgJ3Njb3JlJyxcbiAgICAgICAgICAgICAgICdzZWxmJywgJ3NlbnNpdGl2ZScsICdzZW50ZW5jZScsICdzZW50ZW5jZXMnLCAnc2VxdWVuY2UnLCAnc2tpcCcsICdzbGlkaW5nJywgJ3NvbWUnLCAnc3RhYmxlJyxcbiAgICAgICAgICAgICAgICdzdGFydCcsICdzdGVtbWluZycsICdzdG9wJywgJ3N0cmljdCcsICdzdHJpcCcsICdzd2l0Y2gnLCAndGV4dCcsICd0aGVuJywgJ3RoZXNhdXJ1cycsICd0aW1lcycsXG4gICAgICAgICAgICAgICAndG8nLCAndHJhbnNmb3JtJywgJ3RyZWF0JywgJ3RyeScsICd0dW1ibGluZycsICd0eXBlJywgJ3R5cGVzd2l0Y2gnLCAndW5pb24nLCAndW5vcmRlcmVkJyxcbiAgICAgICAgICAgICAgICd1cGRhdGUnLCAndXBkYXRpbmcnLCAndXBwZXJjYXNlJywgJ3VzaW5nJywgJ3ZhbGlkYXRlJywgJ3ZhbHVlJywgJ3ZhcmlhYmxlJywgJ3ZlcnNpb24nLFxuICAgICAgICAgICAgICAgJ3dlaWdodCcsICd3aGVuJywgJ3doZXJlJywgJ3dpbGRjYXJkcycsICd3aW5kb3cnLCAnd2l0aCcsICd3aXRob3V0JywgJ3dvcmQnLCAnd29yZHMnLCAneHF1ZXJ5J107XG4gIGZvcih2YXIgaT0wLCBsPWJhc2ljLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtiYXNpY1tpXV0gPSBrdyhiYXNpY1tpXSk7fTtcblxuICAvLyBhIGxpc3Qgb2YgdHlwZXMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gIC8vIHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICB2YXIgdHlwZXMgPSBbJ3hzOmFueUF0b21pY1R5cGUnLCAneHM6YW55U2ltcGxlVHlwZScsICd4czphbnlUeXBlJywgJ3hzOmFueVVSSScsXG4gICAgICAgICAgICAgICAneHM6YmFzZTY0QmluYXJ5JywgJ3hzOmJvb2xlYW4nLCAneHM6Ynl0ZScsICd4czpkYXRlJywgJ3hzOmRhdGVUaW1lJywgJ3hzOmRhdGVUaW1lU3RhbXAnLFxuICAgICAgICAgICAgICAgJ3hzOmRheVRpbWVEdXJhdGlvbicsICd4czpkZWNpbWFsJywgJ3hzOmRvdWJsZScsICd4czpkdXJhdGlvbicsICd4czpFTlRJVElFUycsICd4czpFTlRJVFknLFxuICAgICAgICAgICAgICAgJ3hzOmZsb2F0JywgJ3hzOmdEYXknLCAneHM6Z01vbnRoJywgJ3hzOmdNb250aERheScsICd4czpnWWVhcicsICd4czpnWWVhck1vbnRoJywgJ3hzOmhleEJpbmFyeScsXG4gICAgICAgICAgICAgICAneHM6SUQnLCAneHM6SURSRUYnLCAneHM6SURSRUZTJywgJ3hzOmludCcsICd4czppbnRlZ2VyJywgJ3hzOml0ZW0nLCAneHM6amF2YScsICd4czpsYW5ndWFnZScsXG4gICAgICAgICAgICAgICAneHM6bG9uZycsICd4czpOYW1lJywgJ3hzOk5DTmFtZScsICd4czpuZWdhdGl2ZUludGVnZXInLCAneHM6Tk1UT0tFTicsICd4czpOTVRPS0VOUycsXG4gICAgICAgICAgICAgICAneHM6bm9uTmVnYXRpdmVJbnRlZ2VyJywgJ3hzOm5vblBvc2l0aXZlSW50ZWdlcicsICd4czpub3JtYWxpemVkU3RyaW5nJywgJ3hzOk5PVEFUSU9OJyxcbiAgICAgICAgICAgICAgICd4czpudW1lcmljJywgJ3hzOnBvc2l0aXZlSW50ZWdlcicsICd4czpwcmVjaXNpb25EZWNpbWFsJywgJ3hzOlFOYW1lJywgJ3hzOnNob3J0JywgJ3hzOnN0cmluZycsXG4gICAgICAgICAgICAgICAneHM6dGltZScsICd4czp0b2tlbicsICd4czp1bnNpZ25lZEJ5dGUnLCAneHM6dW5zaWduZWRJbnQnLCAneHM6dW5zaWduZWRMb25nJyxcbiAgICAgICAgICAgICAgICd4czp1bnNpZ25lZFNob3J0JywgJ3hzOnVudHlwZWQnLCAneHM6dW50eXBlZEF0b21pYycsICd4czp5ZWFyTW9udGhEdXJhdGlvbiddO1xuICBmb3IodmFyIGk9MCwgbD10eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbdHlwZXNbaV1dID0gYXRvbTt9O1xuXG4gIC8vIGVhY2ggb3BlcmF0b3Igd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcIm9wZXJhdG9yXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgdmFyIG9wZXJhdG9ycyA9IFsnZXEnLCAnbmUnLCAnbHQnLCAnbGUnLCAnZ3QnLCAnZ2UnLCAnOj0nLCAnPScsICc+JywgJz49JywgJzwnLCAnPD0nLCAnLicsICd8JywgJz8nLCAnYW5kJywgJ29yJywgJ2RpdicsICdpZGl2JywgJ21vZCcsICcqJywgJy8nLCAnKycsICctJ107XG4gIGZvcih2YXIgaT0wLCBsPW9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbb3BlcmF0b3JzW2ldXSA9IG9wZXJhdG9yO307XG5cbiAgLy8gZWFjaCBheGlzX3NwZWNpZmllcnMgd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcImF4aXNfc3BlY2lmaWVyXCIsIHN0eWxlOiBcInF1YWxpZmllclwifVxuICB2YXIgYXhpc19zcGVjaWZpZXJzID0gW1wic2VsZjo6XCIsIFwiYXR0cmlidXRlOjpcIiwgXCJjaGlsZDo6XCIsIFwiZGVzY2VuZGFudDo6XCIsIFwiZGVzY2VuZGFudC1vci1zZWxmOjpcIiwgXCJwYXJlbnQ6OlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW5jZXN0b3I6OlwiLCBcImFuY2VzdG9yLW9yLXNlbGY6OlwiLCBcImZvbGxvd2luZzo6XCIsIFwicHJlY2VkaW5nOjpcIiwgXCJmb2xsb3dpbmctc2libGluZzo6XCIsIFwicHJlY2VkaW5nLXNpYmxpbmc6OlwiXTtcbiAgZm9yKHZhciBpPTAsIGw9YXhpc19zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtheGlzX3NwZWNpZmllcnNbaV1dID0gcXVhbGlmaWVyOyB9O1xuXG4gIHJldHVybiBrd09iajtcbn0oKTtcblxuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyB0aGUgcHJpbWFyeSBtb2RlIHRva2VuaXplclxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKSxcbiAgICAgIG1pZ2h0QmVGdW5jdGlvbiA9IGZhbHNlLFxuICAgICAgaXNFUU5hbWUgPSBpc0VRTmFtZUFoZWFkKHN0cmVhbSk7XG5cbiAgLy8gYW4gWE1MIHRhZyAoaWYgbm90IGluIHNvbWUgc3ViLCBjaGFpbmVkIHRva2VuaXplcilcbiAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiIS0tXCIsIHRydWUpKVxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuWE1MQ29tbWVudCk7XG5cbiAgICBpZihzdHJlYW0ubWF0Y2goXCIhW0NEQVRBXCIsIGZhbHNlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNEQVRBO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuXG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiP1wiLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblByZVByb2Nlc3NpbmcpO1xuICAgIH1cblxuICAgIHZhciBpc2Nsb3NlID0gc3RyZWFtLmVhdChcIi9cIik7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgdmFyIHRhZ05hbWUgPSBcIlwiLCBjO1xuICAgIHdoaWxlICgoYyA9IHN0cmVhbS5lYXQoL1teXFxzXFx1MDBhMD08PlxcXCJcXCdcXC8/XS8pKSkgdGFnTmFtZSArPSBjO1xuXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVGFnKHRhZ05hbWUsIGlzY2xvc2UpKTtcbiAgfVxuICAvLyBzdGFydCBjb2RlIGJsb2NrXG4gIGVsc2UgaWYoY2ggPT0gXCJ7XCIpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvZGVibG9ja1wifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gZW5kIGNvZGUgYmxvY2tcbiAgZWxzZSBpZihjaCA9PSBcIn1cIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGlmIHdlJ3JlIGluIGFuIFhNTCBibG9ja1xuICBlbHNlIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHtcbiAgICBpZihjaCA9PSBcIj5cIilcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIGVsc2UgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cbiAgLy8gaWYgYSBudW1iZXJcbiAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKik/KD86RVsrXFwtXT9cXGQrKT8vKTtcbiAgICByZXR1cm4gXCJhdG9tXCI7XG4gIH1cbiAgLy8gY29tbWVudCBzdGFydFxuICBlbHNlIGlmIChjaCA9PT0gXCIoXCIgJiYgc3RyZWFtLmVhdChcIjpcIikpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvbW1lbnRcIn0pO1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICB9XG4gIC8vIHF1b3RlZCBzdHJpbmdcbiAgZWxzZSBpZiAoIWlzRVFOYW1lICYmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpKVxuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCkpO1xuICAvLyB2YXJpYWJsZVxuICBlbHNlIGlmKGNoID09PSBcIiRcIikge1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblZhcmlhYmxlKTtcbiAgfVxuICAvLyBhc3NpZ25tZW50XG4gIGVsc2UgaWYoY2ggPT09XCI6XCIgJiYgc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cbiAgLy8gb3BlbiBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIihcIikge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwicGFyZW5cIn0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGNsb3NlIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiKVwiKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gb3BlbiBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIltcIikge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiYnJhY2tldFwifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gY2xvc2UgcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCJdXCIpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjaCkgJiYga2V5d29yZHNbY2hdO1xuXG4gICAgLy8gaWYgdGhlcmUncyBhIEVRTmFtZSBhaGVhZCwgY29uc3VtZSB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHBvcnRpb24sIGl0J3MgbGlrZWx5IGEgZnVuY3Rpb25cbiAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcXCInKSB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXCInKXt9XG4gICAgaWYoaXNFUU5hbWUgJiYgY2ggPT09ICdcXCcnKSB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXFwnJyl7fVxuXG4gICAgLy8gZ29iYmxlIHVwIGEgd29yZCBpZiB0aGUgY2hhcmFjdGVyIGlzIG5vdCBrbm93blxuICAgIGlmKCFrbm93bikgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkXy1dLyk7XG5cbiAgICAvLyBnb2JibGUgYSBjb2xvbiBpbiB0aGUgY2FzZSB0aGF0IGlzIGEgbGliIGZ1bmMgdHlwZSBjYWxsIGZuOmRvY1xuICAgIHZhciBmb3VuZENvbG9uID0gc3RyZWFtLmVhdChcIjpcIik7XG5cbiAgICAvLyBpZiB0aGVyZSdzIG5vdCBhIHNlY29uZCBjb2xvbiwgZ29iYmxlIGFub3RoZXIgd29yZC4gT3RoZXJ3aXNlLCBpdCdzIHByb2JhYmx5IGFuIGF4aXMgc3BlY2lmaWVyXG4gICAgLy8gd2hpY2ggc2hvdWxkIGdldCBtYXRjaGVkIGFzIGEga2V5d29yZFxuICAgIGlmKCFzdHJlYW0uZWF0KFwiOlwiKSAmJiBmb3VuZENvbG9uKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG5leHQgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGFuIG9wZW4gcGFyZW4sIHRoaXMgaXMgcHJvYmFibHkgYSBmdW5jdGlvbiAoaWYgbm90IGEga2V5d29yZCBvZiBvdGhlciBzb3J0KVxuICAgIGlmKHN0cmVhbS5tYXRjaCgvXlsgXFx0XSpcXCgvLCBmYWxzZSkpIHtcbiAgICAgIG1pZ2h0QmVGdW5jdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIC8vIGlzIHRoZSB3b3JkIGEga2V5d29yZD9cbiAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSAmJiBrZXl3b3Jkc1t3b3JkXTtcblxuICAgIC8vIGlmIHdlIHRoaW5rIGl0J3MgYSBmdW5jdGlvbiBjYWxsIGJ1dCBub3QgeWV0IGtub3duLFxuICAgIC8vIHNldCBzdHlsZSB0byB2YXJpYWJsZSBmb3Igbm93IGZvciBsYWNrIG9mIHNvbWV0aGluZyBiZXR0ZXJcbiAgICBpZihtaWdodEJlRnVuY3Rpb24gJiYgIWtub3duKSBrbm93biA9IHt0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIiwgc3R5bGU6IFwiZGVmXCJ9O1xuXG4gICAgLy8gaWYgdGhlIHByZXZpb3VzIHdvcmQgd2FzIGVsZW1lbnQsIGF0dHJpYnV0ZSwgYXhpcyBzcGVjaWZpZXIsIHRoaXMgd29yZCBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhhdFxuICAgIGlmKGlzSW5YbWxDb25zdHJ1Y3RvcihzdGF0ZSkpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9XG4gICAgLy8gYXMgcHJldmlvdXNseSBjaGVja2VkLCBpZiB0aGUgd29yZCBpcyBlbGVtZW50LGF0dHJpYnV0ZSwgYXhpcyBzcGVjaWZpZXIsIGNhbGwgaXQgYW4gXCJ4bWxjb25zdHJ1Y3RvclwiIGFuZFxuICAgIC8vIHB1c2ggdGhlIHN0YWNrIHNvIHdlIGtub3cgdG8gbG9vayBmb3IgaXQgb24gdGhlIG5leHQgd29yZFxuICAgIGlmKHdvcmQgPT0gXCJlbGVtZW50XCIgfHwgd29yZCA9PSBcImF0dHJpYnV0ZVwiIHx8IGtub3duLnR5cGUgPT0gXCJheGlzX3NwZWNpZmllclwiKSBwdXNoU3RhdGVTdGFjayhzdGF0ZSwge3R5cGU6IFwieG1sY29uc3RydWN0b3JcIn0pO1xuXG4gICAgLy8gaWYgdGhlIHdvcmQgaXMga25vd24sIHJldHVybiB0aGUgZGV0YWlscyBvZiB0aGF0IGVsc2UganVzdCBjYWxsIHRoaXMgYSBnZW5lcmljICd3b3JkJ1xuICAgIHJldHVybiBrbm93biA/IGtub3duLnN0eWxlIDogXCJ2YXJpYWJsZVwiO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb21tZW50cywgaW5jbHVkaW5nIG5lc3RlZFxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIG1heWJlTmVzdGVkID0gZmFsc2UsIG5lc3RlZENvdW50ID0gMCwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIpXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIGlmKG5lc3RlZENvdW50ID4gMClcbiAgICAgICAgbmVzdGVkQ291bnQtLTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYoY2ggPT0gXCI6XCIgJiYgbWF5YmVOZXN0ZWQpIHtcbiAgICAgIG5lc3RlZENvdW50Kys7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiOlwiKTtcbiAgICBtYXliZU5lc3RlZCA9IChjaCA9PSBcIihcIik7XG4gIH1cblxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbi8vIHRva2VuaXplciBmb3Igc3RyaW5nIGxpdGVyYWxzXG4vLyBvcHRpb25hbGx5IHBhc3MgYSB0b2tlbml6ZXIgZnVuY3Rpb24gdG8gc2V0IHN0YXRlLnRva2VuaXplIGJhY2sgdG8gd2hlbiBmaW5pc2hlZFxuZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUsIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2g7XG5cbiAgICBpZihpc0luU3RyaW5nKHN0YXRlKSAmJiBzdHJlYW0uY3VycmVudCgpID09IHF1b3RlKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIGlmKGYpIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IHF1b3RlLCB0b2tlbml6ZTogdG9rZW5TdHJpbmcocXVvdGUsIGYpIH0pO1xuXG4gICAgLy8gaWYgd2UncmUgaW4gYSBzdHJpbmcgYW5kIGluIGFuIFhNTCBibG9jaywgYWxsb3cgYW4gZW1iZWRkZWQgY29kZSBibG9ja1xuICAgIGlmKHN0cmVhbS5tYXRjaChcIntcIiwgZmFsc2UpICYmIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG5cbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gIHF1b3RlKSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICBpZihmKSBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIGEgc3RyaW5nIGFuZCBpbiBhbiBYTUwgYmxvY2ssIGFsbG93IGFuIGVtYmVkZGVkIGNvZGUgYmxvY2sgaW4gYW4gYXR0cmlidXRlXG4gICAgICAgIGlmKHN0cmVhbS5tYXRjaChcIntcIiwgZmFsc2UpICYmIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH07XG59XG5cbi8vIHRva2VuaXplciBmb3IgdmFyaWFibGVzXG5mdW5jdGlvbiB0b2tlblZhcmlhYmxlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGlzVmFyaWFibGVDaGFyID0gL1tcXHdcXCRfLV0vO1xuXG4gIC8vIGEgdmFyaWFibGUgbWF5IHN0YXJ0IHdpdGggYSBxdW90ZWQgRVFOYW1lIHNvIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBxdW90ZSwgY29uc3VtZSB0byB0aGUgbmV4dCBxdW90ZVxuICBpZihzdHJlYW0uZWF0KFwiXFxcIlwiKSkge1xuICAgIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcXFwiJyl7fTtcbiAgICBzdHJlYW0uZWF0KFwiOlwiKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNWYXJpYWJsZUNoYXIpO1xuICAgIGlmKCFzdHJlYW0ubWF0Y2goXCI6PVwiLCBmYWxzZSkpIHN0cmVhbS5lYXQoXCI6XCIpO1xuICB9XG4gIHN0cmVhbS5lYXRXaGlsZShpc1ZhcmlhYmxlQ2hhcik7XG4gIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xufVxuXG4vLyB0b2tlbml6ZXIgZm9yIFhNTCB0YWdzXG5mdW5jdGlvbiB0b2tlblRhZyhuYW1lLCBpc2Nsb3NlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgaWYoaXNjbG9zZSAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cbiAgICAvLyBzZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYXR0cmlidXRlcz9cbiAgICBpZighc3RyZWFtLmVhdChcIi9cIikpXG4gICAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcInRhZ1wiLCBuYW1lOiBuYW1lLCB0b2tlbml6ZTogdG9rZW5CYXNlfSk7XG4gICAgaWYoIXN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQXR0cmlidXRlO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgfVxuICAgIHJldHVybiBcInRhZ1wiO1xuICB9O1xufVxuXG4vLyB0b2tlbml6ZXIgZm9yIFhNTCBhdHRyaWJ1dGVzXG5mdW5jdGlvbiB0b2tlbkF0dHJpYnV0ZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICBpZihpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICBpZihpc0luWG1sQmxvY2soc3RhdGUpKSBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgfVxuICBpZihjaCA9PSBcIj5cIikge1xuICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBcInRhZ1wiO1xuICB9XG4gIGlmKGNoID09IFwiPVwiKVxuICAgIHJldHVybiBudWxsO1xuICAvLyBxdW90ZWQgc3RyaW5nXG4gIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKVxuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCwgdG9rZW5BdHRyaWJ1dGUpKTtcblxuICBpZighaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSlcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImF0dHJpYnV0ZVwiLCB0b2tlbml6ZTogdG9rZW5BdHRyaWJ1dGV9KTtcblxuICBzdHJlYW0uZWF0KC9bYS16QS1aXzpdLyk7XG4gIHN0cmVhbS5lYXRXaGlsZSgvWy1hLXpBLVowLTlfOi5dLyk7XG4gIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gIC8vIHRoZSBjYXNlIHdoZXJlIHRoZSBhdHRyaWJ1dGUgaGFzIG5vdCB2YWx1ZSBhbmQgdGhlIHRhZyB3YXMgY2xvc2VkXG4gIGlmKHN0cmVhbS5tYXRjaChcIj5cIiwgZmFsc2UpIHx8IHN0cmVhbS5tYXRjaChcIi9cIiwgZmFsc2UpKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIH1cblxuICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbn1cblxuLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG5mdW5jdGlvbiB0b2tlblhNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIiwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIGhhbmRsZSBDREFUQVxuZnVuY3Rpb24gdG9rZW5DREFUQShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIl1cIiAmJiBzdHJlYW0ubWF0Y2goXCJdXCIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGFuZGxlIHByZXByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG5mdW5jdGlvbiB0b2tlblByZVByb2Nlc3Npbmcoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCI/XCIgJiYgc3RyZWFtLm1hdGNoKFwiPlwiLCB0cnVlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBmdW5jdGlvbnMgdG8gdGVzdCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBzdGF0ZVxuZnVuY3Rpb24gaXNJblhtbEJsb2NrKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInRhZ1wiKTsgfVxuZnVuY3Rpb24gaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcImF0dHJpYnV0ZVwiKTsgfVxuZnVuY3Rpb24gaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInhtbGNvbnN0cnVjdG9yXCIpOyB9XG5mdW5jdGlvbiBpc0luU3RyaW5nKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInN0cmluZ1wiKTsgfVxuXG5mdW5jdGlvbiBpc0VRTmFtZUFoZWFkKHN0cmVhbSkge1xuICAvLyBhc3N1bWUgd2UndmUgYWxyZWFkeSBlYXRlbiBhIHF1b3RlIChcIilcbiAgaWYoc3RyZWFtLmN1cnJlbnQoKSA9PT0gJ1wiJylcbiAgICByZXR1cm4gc3RyZWFtLm1hdGNoKC9eW15cXFwiXStcXFwiXFw6LywgZmFsc2UpO1xuICBlbHNlIGlmKHN0cmVhbS5jdXJyZW50KCkgPT09ICdcXCcnKVxuICAgIHJldHVybiBzdHJlYW0ubWF0Y2goL15bXlxcXCJdK1xcJ1xcOi8sIGZhbHNlKTtcbiAgZWxzZVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbihzdGF0ZSwgdHlwZSkge1xuICByZXR1cm4gKHN0YXRlLnN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGggLSAxXS50eXBlID09IHR5cGUpO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgbmV3U3RhdGUpIHtcbiAgc3RhdGUuc3RhY2sucHVzaChuZXdTdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFN0YXRlU3RhY2soc3RhdGUpIHtcbiAgc3RhdGUuc3RhY2sucG9wKCk7XG4gIHZhciByZWluc3RhdGVUb2tlbml6ZSA9IHN0YXRlLnN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGgtMV0udG9rZW5pemU7XG4gIHN0YXRlLnRva2VuaXplID0gcmVpbnN0YXRlVG9rZW5pemUgfHwgdG9rZW5CYXNlO1xufVxuXG4vLyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgbW9kZSBBUElcbmV4cG9ydCBjb25zdCB4UXVlcnkgPSB7XG4gIG5hbWU6IFwieHF1ZXJ5XCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgY2M6IFtdLFxuICAgICAgc3RhY2s6IFtdXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtibG9jazoge29wZW46IFwiKDpcIiwgY2xvc2U6IFwiOilcIn19XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=