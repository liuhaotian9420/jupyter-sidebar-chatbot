"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_output_chtml_js"],{

/***/ "./node_modules/mathjax-full/js/core/OutputJax.js":
/*!********************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/OutputJax.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractOutputJax = void 0;
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var FunctionList_js_1 = __webpack_require__(/*! ../util/FunctionList.js */ "./node_modules/mathjax-full/js/util/FunctionList.js");
var AbstractOutputJax = (function () {
    function AbstractOutputJax(options) {
        if (options === void 0) { options = {}; }
        this.adaptor = null;
        var CLASS = this.constructor;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
        this.postFilters = new FunctionList_js_1.FunctionList();
    }
    Object.defineProperty(AbstractOutputJax.prototype, "name", {
        get: function () {
            return this.constructor.NAME;
        },
        enumerable: false,
        configurable: true
    });
    AbstractOutputJax.prototype.setAdaptor = function (adaptor) {
        this.adaptor = adaptor;
    };
    AbstractOutputJax.prototype.initialize = function () {
    };
    AbstractOutputJax.prototype.reset = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    AbstractOutputJax.prototype.getMetrics = function (_document) {
    };
    AbstractOutputJax.prototype.styleSheet = function (_document) {
        return null;
    };
    AbstractOutputJax.prototype.pageElements = function (_document) {
        return null;
    };
    AbstractOutputJax.prototype.executeFilters = function (filters, math, document, data) {
        var args = { math: math, document: document, data: data };
        filters.execute(args);
        return args.data;
    };
    AbstractOutputJax.NAME = 'generic';
    AbstractOutputJax.OPTIONS = {};
    return AbstractOutputJax;
}());
exports.AbstractOutputJax = AbstractOutputJax;
//# sourceMappingURL=OutputJax.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/Tree/Wrapper.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/Tree/Wrapper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractWrapper = void 0;
var AbstractWrapper = (function () {
    function AbstractWrapper(factory, node) {
        this.factory = factory;
        this.node = node;
    }
    Object.defineProperty(AbstractWrapper.prototype, "kind", {
        get: function () {
            return this.node.kind;
        },
        enumerable: false,
        configurable: true
    });
    AbstractWrapper.prototype.wrap = function (node) {
        return this.factory.wrap(node);
    };
    return AbstractWrapper;
}());
exports.AbstractWrapper = AbstractWrapper;
//# sourceMappingURL=Wrapper.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/Tree/WrapperFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/Tree/WrapperFactory.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractWrapperFactory = void 0;
var Factory_js_1 = __webpack_require__(/*! ./Factory.js */ "./node_modules/mathjax-full/js/core/Tree/Factory.js");
var AbstractWrapperFactory = (function (_super) {
    __extends(AbstractWrapperFactory, _super);
    function AbstractWrapperFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractWrapperFactory.prototype.wrap = function (node) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.create.apply(this, __spreadArray([node.kind, node], __read(args), false));
    };
    return AbstractWrapperFactory;
}(Factory_js_1.AbstractFactory));
exports.AbstractWrapperFactory = AbstractWrapperFactory;
//# sourceMappingURL=WrapperFactory.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTML = void 0;
var OutputJax_js_1 = __webpack_require__(/*! ./common/OutputJax.js */ "./node_modules/mathjax-full/js/output/common/OutputJax.js");
var StyleList_js_1 = __webpack_require__(/*! ../util/StyleList.js */ "./node_modules/mathjax-full/js/util/StyleList.js");
var WrapperFactory_js_1 = __webpack_require__(/*! ./chtml/WrapperFactory.js */ "./node_modules/mathjax-full/js/output/chtml/WrapperFactory.js");
var Usage_js_1 = __webpack_require__(/*! ./chtml/Usage.js */ "./node_modules/mathjax-full/js/output/chtml/Usage.js");
var tex_js_1 = __webpack_require__(/*! ./chtml/fonts/tex.js */ "./node_modules/mathjax-full/js/output/chtml/fonts/tex.js");
var LENGTHS = __importStar(__webpack_require__(/*! ../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js"));
var string_js_1 = __webpack_require__(/*! ../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
var CHTML = (function (_super) {
    __extends(CHTML, _super);
    function CHTML(options) {
        if (options === void 0) { options = null; }
        var _this = _super.call(this, options, WrapperFactory_js_1.CHTMLWrapperFactory, tex_js_1.TeXFont) || this;
        _this.chtmlStyles = null;
        _this.font.adaptiveCSS(_this.options.adaptiveCSS);
        _this.wrapperUsage = new Usage_js_1.Usage();
        return _this;
    }
    CHTML.prototype.escaped = function (math, html) {
        this.setDocument(html);
        return this.html('span', {}, [this.text(math.math)]);
    };
    CHTML.prototype.styleSheet = function (html) {
        if (this.chtmlStyles) {
            if (this.options.adaptiveCSS) {
                var styles = new StyleList_js_1.CssStyles();
                this.addWrapperStyles(styles);
                this.updateFontStyles(styles);
                this.adaptor.insertRules(this.chtmlStyles, styles.getStyleRules());
            }
            return this.chtmlStyles;
        }
        var sheet = this.chtmlStyles = _super.prototype.styleSheet.call(this, html);
        this.adaptor.setAttribute(sheet, 'id', CHTML.STYLESHEETID);
        this.wrapperUsage.update();
        return sheet;
    };
    CHTML.prototype.updateFontStyles = function (styles) {
        styles.addStyles(this.font.updateStyles({}));
    };
    CHTML.prototype.addWrapperStyles = function (styles) {
        var e_1, _a;
        if (!this.options.adaptiveCSS) {
            _super.prototype.addWrapperStyles.call(this, styles);
            return;
        }
        try {
            for (var _b = __values(this.wrapperUsage.update()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var kind = _c.value;
                var wrapper = this.factory.getNodeClass(kind);
                wrapper && this.addClassStyles(wrapper, styles);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    CHTML.prototype.addClassStyles = function (wrapper, styles) {
        var _a;
        var CLASS = wrapper;
        if (CLASS.autoStyle && CLASS.kind !== 'unknown') {
            styles.addStyles((_a = {},
                _a['mjx-' + CLASS.kind] = {
                    display: 'inline-block',
                    'text-align': 'left'
                },
                _a));
        }
        this.wrapperUsage.add(CLASS.kind);
        _super.prototype.addClassStyles.call(this, wrapper, styles);
    };
    CHTML.prototype.processMath = function (math, parent) {
        this.factory.wrap(math).toCHTML(parent);
    };
    CHTML.prototype.clearCache = function () {
        this.cssStyles.clear();
        this.font.clearCache();
        this.wrapperUsage.clear();
        this.chtmlStyles = null;
    };
    CHTML.prototype.reset = function () {
        this.clearCache();
    };
    CHTML.prototype.unknownText = function (text, variant, width) {
        if (width === void 0) { width = null; }
        var styles = {};
        var scale = 100 / this.math.metrics.scale;
        if (scale !== 100) {
            styles['font-size'] = this.fixed(scale, 1) + '%';
            styles.padding = LENGTHS.em(75 / scale) + ' 0 ' + LENGTHS.em(20 / scale) + ' 0';
        }
        if (variant !== '-explicitFont') {
            var c = (0, string_js_1.unicodeChars)(text);
            if (c.length !== 1 || c[0] < 0x1D400 || c[0] > 0x1D7FF) {
                this.cssFontStyles(this.font.getCssFont(variant), styles);
            }
        }
        if (width !== null) {
            var metrics = this.math.metrics;
            styles.width = Math.round(width * metrics.em * metrics.scale) + 'px';
        }
        return this.html('mjx-utext', { variant: variant, style: styles }, [this.text(text)]);
    };
    CHTML.prototype.measureTextNode = function (textNode) {
        var adaptor = this.adaptor;
        var text = adaptor.clone(textNode);
        adaptor.setStyle(text, 'font-family', adaptor.getStyle(text, 'font-family').replace(/MJXZERO, /g, ''));
        var style = { position: 'absolute', 'white-space': 'nowrap' };
        var node = this.html('mjx-measure-text', { style: style }, [text]);
        adaptor.append(adaptor.parent(this.math.start.node), this.container);
        adaptor.append(this.container, node);
        var w = adaptor.nodeSize(text, this.math.metrics.em)[0] / this.math.metrics.scale;
        adaptor.remove(this.container);
        adaptor.remove(node);
        return { w: w, h: .75, d: .2 };
    };
    CHTML.NAME = 'CHTML';
    CHTML.OPTIONS = __assign(__assign({}, OutputJax_js_1.CommonOutputJax.OPTIONS), { adaptiveCSS: true, matchFontHeight: true });
    CHTML.commonStyles = {
        'mjx-container[jax="CHTML"]': { 'line-height': 0 },
        'mjx-container [space="1"]': { 'margin-left': '.111em' },
        'mjx-container [space="2"]': { 'margin-left': '.167em' },
        'mjx-container [space="3"]': { 'margin-left': '.222em' },
        'mjx-container [space="4"]': { 'margin-left': '.278em' },
        'mjx-container [space="5"]': { 'margin-left': '.333em' },
        'mjx-container [rspace="1"]': { 'margin-right': '.111em' },
        'mjx-container [rspace="2"]': { 'margin-right': '.167em' },
        'mjx-container [rspace="3"]': { 'margin-right': '.222em' },
        'mjx-container [rspace="4"]': { 'margin-right': '.278em' },
        'mjx-container [rspace="5"]': { 'margin-right': '.333em' },
        'mjx-container [size="s"]': { 'font-size': '70.7%' },
        'mjx-container [size="ss"]': { 'font-size': '50%' },
        'mjx-container [size="Tn"]': { 'font-size': '60%' },
        'mjx-container [size="sm"]': { 'font-size': '85%' },
        'mjx-container [size="lg"]': { 'font-size': '120%' },
        'mjx-container [size="Lg"]': { 'font-size': '144%' },
        'mjx-container [size="LG"]': { 'font-size': '173%' },
        'mjx-container [size="hg"]': { 'font-size': '207%' },
        'mjx-container [size="HG"]': { 'font-size': '249%' },
        'mjx-container [width="full"]': { width: '100%' },
        'mjx-box': { display: 'inline-block' },
        'mjx-block': { display: 'block' },
        'mjx-itable': { display: 'inline-table' },
        'mjx-row': { display: 'table-row' },
        'mjx-row > *': { display: 'table-cell' },
        'mjx-mtext': {
            display: 'inline-block'
        },
        'mjx-mstyle': {
            display: 'inline-block'
        },
        'mjx-merror': {
            display: 'inline-block',
            color: 'red',
            'background-color': 'yellow'
        },
        'mjx-mphantom': {
            visibility: 'hidden'
        },
        '_::-webkit-full-page-media, _:future, :root mjx-container': {
            'will-change': 'opacity'
        }
    };
    CHTML.STYLESHEETID = 'MJX-CHTML-styles';
    return CHTML;
}(OutputJax_js_1.CommonOutputJax));
exports.CHTML = CHTML;
//# sourceMappingURL=chtml.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Notation.js":
/*!***************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Notation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Arrow = exports.DiagonalArrow = exports.DiagonalStrike = exports.Border2 = exports.Border = exports.RenderElement = void 0;
var Notation = __importStar(__webpack_require__(/*! ../common/Notation.js */ "./node_modules/mathjax-full/js/output/common/Notation.js"));
__exportStar(__webpack_require__(/*! ../common/Notation.js */ "./node_modules/mathjax-full/js/output/common/Notation.js"), exports);
var RenderElement = function (name, offset) {
    if (offset === void 0) { offset = ''; }
    return (function (node, _child) {
        var shape = node.adjustBorder(node.html('mjx-' + name));
        if (offset) {
            var d = node.getOffset(offset);
            if (node.thickness !== Notation.THICKNESS || d) {
                var transform = "translate".concat(offset, "(").concat(node.em(node.thickness / 2 - d), ")");
                node.adaptor.setStyle(shape, 'transform', transform);
            }
        }
        node.adaptor.append(node.chtml, shape);
    });
};
exports.RenderElement = RenderElement;
var Border = function (side) {
    return Notation.CommonBorder(function (node, child) {
        node.adaptor.setStyle(child, 'border-' + side, node.em(node.thickness) + ' solid');
    })(side);
};
exports.Border = Border;
var Border2 = function (name, side1, side2) {
    return Notation.CommonBorder2(function (node, child) {
        var border = node.em(node.thickness) + ' solid';
        node.adaptor.setStyle(child, 'border-' + side1, border);
        node.adaptor.setStyle(child, 'border-' + side2, border);
    })(name, side1, side2);
};
exports.Border2 = Border2;
var DiagonalStrike = function (name, neg) {
    return Notation.CommonDiagonalStrike(function (cname) { return function (node, _child) {
        var _a = node.getBBox(), w = _a.w, h = _a.h, d = _a.d;
        var _b = __read(node.getArgMod(w, h + d), 2), a = _b[0], W = _b[1];
        var t = neg * node.thickness / 2;
        var strike = node.adjustBorder(node.html(cname, { style: {
                width: node.em(W),
                transform: 'rotate(' + node.fixed(-neg * a) + 'rad) translateY(' + t + 'em)',
            } }));
        node.adaptor.append(node.chtml, strike);
    }; })(name);
};
exports.DiagonalStrike = DiagonalStrike;
var DiagonalArrow = function (name) {
    return Notation.CommonDiagonalArrow(function (node, arrow) {
        node.adaptor.append(node.chtml, arrow);
    })(name);
};
exports.DiagonalArrow = DiagonalArrow;
var Arrow = function (name) {
    return Notation.CommonArrow(function (node, arrow) {
        node.adaptor.append(node.chtml, arrow);
    })(name);
};
exports.Arrow = Arrow;
//# sourceMappingURL=Notation.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js":
/*!**************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrapper.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLWrapper = exports.SPACE = exports.FONTSIZE = void 0;
var LENGTHS = __importStar(__webpack_require__(/*! ../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js"));
var Wrapper_js_1 = __webpack_require__(/*! ../common/Wrapper.js */ "./node_modules/mathjax-full/js/output/common/Wrapper.js");
var BBox_js_1 = __webpack_require__(/*! ../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
exports.FONTSIZE = {
    '70.7%': 's',
    '70%': 's',
    '50%': 'ss',
    '60%': 'Tn',
    '85%': 'sm',
    '120%': 'lg',
    '144%': 'Lg',
    '173%': 'LG',
    '207%': 'hg',
    '249%': 'HG'
};
exports.SPACE = (_a = {},
    _a[LENGTHS.em(2 / 18)] = '1',
    _a[LENGTHS.em(3 / 18)] = '2',
    _a[LENGTHS.em(4 / 18)] = '3',
    _a[LENGTHS.em(5 / 18)] = '4',
    _a[LENGTHS.em(6 / 18)] = '5',
    _a);
var CHTMLWrapper = (function (_super) {
    __extends(CHTMLWrapper, _super);
    function CHTMLWrapper() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.chtml = null;
        return _this;
    }
    CHTMLWrapper.prototype.toCHTML = function (parent) {
        var e_1, _a;
        var chtml = this.standardCHTMLnode(parent);
        try {
            for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                child.toCHTML(chtml);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    CHTMLWrapper.prototype.standardCHTMLnode = function (parent) {
        this.markUsed();
        var chtml = this.createCHTMLnode(parent);
        this.handleStyles();
        this.handleVariant();
        this.handleScale();
        this.handleColor();
        this.handleSpace();
        this.handleAttributes();
        this.handlePWidth();
        return chtml;
    };
    CHTMLWrapper.prototype.markUsed = function () {
        this.jax.wrapperUsage.add(this.kind);
    };
    CHTMLWrapper.prototype.createCHTMLnode = function (parent) {
        var href = this.node.attributes.get('href');
        if (href) {
            parent = this.adaptor.append(parent, this.html('a', { href: href }));
        }
        this.chtml = this.adaptor.append(parent, this.html('mjx-' + this.node.kind));
        return this.chtml;
    };
    CHTMLWrapper.prototype.handleStyles = function () {
        if (!this.styles)
            return;
        var styles = this.styles.cssText;
        if (styles) {
            this.adaptor.setAttribute(this.chtml, 'style', styles);
            var family = this.styles.get('font-family');
            if (family) {
                this.adaptor.setStyle(this.chtml, 'font-family', 'MJXZERO, ' + family);
            }
        }
    };
    CHTMLWrapper.prototype.handleVariant = function () {
        if (this.node.isToken && this.variant !== '-explicitFont') {
            this.adaptor.setAttribute(this.chtml, 'class', (this.font.getVariant(this.variant) || this.font.getVariant('normal')).classes);
        }
    };
    CHTMLWrapper.prototype.handleScale = function () {
        this.setScale(this.chtml, this.bbox.rscale);
    };
    CHTMLWrapper.prototype.setScale = function (chtml, rscale) {
        var scale = (Math.abs(rscale - 1) < .001 ? 1 : rscale);
        if (chtml && scale !== 1) {
            var size = this.percent(scale);
            if (exports.FONTSIZE[size]) {
                this.adaptor.setAttribute(chtml, 'size', exports.FONTSIZE[size]);
            }
            else {
                this.adaptor.setStyle(chtml, 'fontSize', size);
            }
        }
        return chtml;
    };
    CHTMLWrapper.prototype.handleSpace = function () {
        var e_2, _a;
        try {
            for (var _b = __values([[this.bbox.L, 'space', 'marginLeft'],
                [this.bbox.R, 'rspace', 'marginRight']]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var data = _c.value;
                var _d = __read(data, 3), dimen = _d[0], name_1 = _d[1], margin = _d[2];
                if (dimen) {
                    var space = this.em(dimen);
                    if (exports.SPACE[space]) {
                        this.adaptor.setAttribute(this.chtml, name_1, exports.SPACE[space]);
                    }
                    else {
                        this.adaptor.setStyle(this.chtml, margin, space);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    CHTMLWrapper.prototype.handleColor = function () {
        var attributes = this.node.attributes;
        var mathcolor = attributes.getExplicit('mathcolor');
        var color = attributes.getExplicit('color');
        var mathbackground = attributes.getExplicit('mathbackground');
        var background = attributes.getExplicit('background');
        if (mathcolor || color) {
            this.adaptor.setStyle(this.chtml, 'color', mathcolor || color);
        }
        if (mathbackground || background) {
            this.adaptor.setStyle(this.chtml, 'backgroundColor', mathbackground || background);
        }
    };
    CHTMLWrapper.prototype.handleAttributes = function () {
        var e_3, _a, e_4, _b;
        var attributes = this.node.attributes;
        var defaults = attributes.getAllDefaults();
        var skip = CHTMLWrapper.skipAttributes;
        try {
            for (var _c = __values(attributes.getExplicitNames()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var name_2 = _d.value;
                if (skip[name_2] === false || (!(name_2 in defaults) && !skip[name_2] &&
                    !this.adaptor.hasAttribute(this.chtml, name_2))) {
                    this.adaptor.setAttribute(this.chtml, name_2, attributes.getExplicit(name_2));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (attributes.get('class')) {
            var names = attributes.get('class').trim().split(/ +/);
            try {
                for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                    var name_3 = names_1_1.value;
                    this.adaptor.addClass(this.chtml, name_3);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (names_1_1 && !names_1_1.done && (_b = names_1.return)) _b.call(names_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    };
    CHTMLWrapper.prototype.handlePWidth = function () {
        if (this.bbox.pwidth) {
            if (this.bbox.pwidth === BBox_js_1.BBox.fullWidth) {
                this.adaptor.setAttribute(this.chtml, 'width', 'full');
            }
            else {
                this.adaptor.setStyle(this.chtml, 'width', this.bbox.pwidth);
            }
        }
    };
    CHTMLWrapper.prototype.setIndent = function (chtml, align, shift) {
        var adaptor = this.adaptor;
        if (align === 'center' || align === 'left') {
            var L = this.getBBox().L;
            adaptor.setStyle(chtml, 'margin-left', this.em(shift + L));
        }
        if (align === 'center' || align === 'right') {
            var R = this.getBBox().R;
            adaptor.setStyle(chtml, 'margin-right', this.em(-shift + R));
        }
    };
    CHTMLWrapper.prototype.drawBBox = function () {
        var _a = this.getBBox(), w = _a.w, h = _a.h, d = _a.d, R = _a.R;
        var box = this.html('mjx-box', { style: {
                opacity: .25, 'margin-left': this.em(-w - R)
            } }, [
            this.html('mjx-box', { style: {
                    height: this.em(h),
                    width: this.em(w),
                    'background-color': 'red'
                } }),
            this.html('mjx-box', { style: {
                    height: this.em(d),
                    width: this.em(w),
                    'margin-left': this.em(-w),
                    'vertical-align': this.em(-d),
                    'background-color': 'green'
                } })
        ]);
        var node = this.chtml || this.parent.chtml;
        var size = this.adaptor.getAttribute(node, 'size');
        if (size) {
            this.adaptor.setAttribute(box, 'size', size);
        }
        var fontsize = this.adaptor.getStyle(node, 'fontSize');
        if (fontsize) {
            this.adaptor.setStyle(box, 'fontSize', fontsize);
        }
        this.adaptor.append(this.adaptor.parent(node), box);
        this.adaptor.setStyle(node, 'backgroundColor', '#FFEE00');
    };
    CHTMLWrapper.prototype.html = function (type, def, content) {
        if (def === void 0) { def = {}; }
        if (content === void 0) { content = []; }
        return this.jax.html(type, def, content);
    };
    CHTMLWrapper.prototype.text = function (text) {
        return this.jax.text(text);
    };
    CHTMLWrapper.prototype.char = function (n) {
        return this.font.charSelector(n).substr(1);
    };
    CHTMLWrapper.kind = 'unknown';
    CHTMLWrapper.autoStyle = true;
    return CHTMLWrapper;
}(Wrapper_js_1.CommonWrapper));
exports.CHTMLWrapper = CHTMLWrapper;
//# sourceMappingURL=Wrapper.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/WrapperFactory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/WrapperFactory.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLWrapperFactory = void 0;
var WrapperFactory_js_1 = __webpack_require__(/*! ../common/WrapperFactory.js */ "./node_modules/mathjax-full/js/output/common/WrapperFactory.js");
var Wrappers_js_1 = __webpack_require__(/*! ./Wrappers.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers.js");
var CHTMLWrapperFactory = (function (_super) {
    __extends(CHTMLWrapperFactory, _super);
    function CHTMLWrapperFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLWrapperFactory.defaultNodes = Wrappers_js_1.CHTMLWrappers;
    return CHTMLWrapperFactory;
}(WrapperFactory_js_1.CommonWrapperFactory));
exports.CHTMLWrapperFactory = CHTMLWrapperFactory;
//# sourceMappingURL=WrapperFactory.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers.js":
/*!***************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLWrappers = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ./Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var math_js_1 = __webpack_require__(/*! ./Wrappers/math.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/math.js");
var mi_js_1 = __webpack_require__(/*! ./Wrappers/mi.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mi.js");
var mo_js_1 = __webpack_require__(/*! ./Wrappers/mo.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mo.js");
var mn_js_1 = __webpack_require__(/*! ./Wrappers/mn.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mn.js");
var ms_js_1 = __webpack_require__(/*! ./Wrappers/ms.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/ms.js");
var mtext_js_1 = __webpack_require__(/*! ./Wrappers/mtext.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtext.js");
var mspace_js_1 = __webpack_require__(/*! ./Wrappers/mspace.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mspace.js");
var mpadded_js_1 = __webpack_require__(/*! ./Wrappers/mpadded.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mpadded.js");
var menclose_js_1 = __webpack_require__(/*! ./Wrappers/menclose.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/menclose.js");
var mrow_js_1 = __webpack_require__(/*! ./Wrappers/mrow.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mrow.js");
var mfenced_js_1 = __webpack_require__(/*! ./Wrappers/mfenced.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mfenced.js");
var mfrac_js_1 = __webpack_require__(/*! ./Wrappers/mfrac.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mfrac.js");
var msqrt_js_1 = __webpack_require__(/*! ./Wrappers/msqrt.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msqrt.js");
var mroot_js_1 = __webpack_require__(/*! ./Wrappers/mroot.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mroot.js");
var msubsup_js_1 = __webpack_require__(/*! ./Wrappers/msubsup.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msubsup.js");
var munderover_js_1 = __webpack_require__(/*! ./Wrappers/munderover.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/munderover.js");
var mmultiscripts_js_1 = __webpack_require__(/*! ./Wrappers/mmultiscripts.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mmultiscripts.js");
var mtable_js_1 = __webpack_require__(/*! ./Wrappers/mtable.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtable.js");
var mtr_js_1 = __webpack_require__(/*! ./Wrappers/mtr.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtr.js");
var mtd_js_1 = __webpack_require__(/*! ./Wrappers/mtd.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtd.js");
var maction_js_1 = __webpack_require__(/*! ./Wrappers/maction.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/maction.js");
var mglyph_js_1 = __webpack_require__(/*! ./Wrappers/mglyph.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mglyph.js");
var semantics_js_1 = __webpack_require__(/*! ./Wrappers/semantics.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/semantics.js");
var TeXAtom_js_1 = __webpack_require__(/*! ./Wrappers/TeXAtom.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/TeXAtom.js");
var TextNode_js_1 = __webpack_require__(/*! ./Wrappers/TextNode.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/TextNode.js");
exports.CHTMLWrappers = (_a = {},
    _a[math_js_1.CHTMLmath.kind] = math_js_1.CHTMLmath,
    _a[mrow_js_1.CHTMLmrow.kind] = mrow_js_1.CHTMLmrow,
    _a[mrow_js_1.CHTMLinferredMrow.kind] = mrow_js_1.CHTMLinferredMrow,
    _a[mi_js_1.CHTMLmi.kind] = mi_js_1.CHTMLmi,
    _a[mo_js_1.CHTMLmo.kind] = mo_js_1.CHTMLmo,
    _a[mn_js_1.CHTMLmn.kind] = mn_js_1.CHTMLmn,
    _a[ms_js_1.CHTMLms.kind] = ms_js_1.CHTMLms,
    _a[mtext_js_1.CHTMLmtext.kind] = mtext_js_1.CHTMLmtext,
    _a[mspace_js_1.CHTMLmspace.kind] = mspace_js_1.CHTMLmspace,
    _a[mpadded_js_1.CHTMLmpadded.kind] = mpadded_js_1.CHTMLmpadded,
    _a[menclose_js_1.CHTMLmenclose.kind] = menclose_js_1.CHTMLmenclose,
    _a[mfrac_js_1.CHTMLmfrac.kind] = mfrac_js_1.CHTMLmfrac,
    _a[msqrt_js_1.CHTMLmsqrt.kind] = msqrt_js_1.CHTMLmsqrt,
    _a[mroot_js_1.CHTMLmroot.kind] = mroot_js_1.CHTMLmroot,
    _a[msubsup_js_1.CHTMLmsub.kind] = msubsup_js_1.CHTMLmsub,
    _a[msubsup_js_1.CHTMLmsup.kind] = msubsup_js_1.CHTMLmsup,
    _a[msubsup_js_1.CHTMLmsubsup.kind] = msubsup_js_1.CHTMLmsubsup,
    _a[munderover_js_1.CHTMLmunder.kind] = munderover_js_1.CHTMLmunder,
    _a[munderover_js_1.CHTMLmover.kind] = munderover_js_1.CHTMLmover,
    _a[munderover_js_1.CHTMLmunderover.kind] = munderover_js_1.CHTMLmunderover,
    _a[mmultiscripts_js_1.CHTMLmmultiscripts.kind] = mmultiscripts_js_1.CHTMLmmultiscripts,
    _a[mfenced_js_1.CHTMLmfenced.kind] = mfenced_js_1.CHTMLmfenced,
    _a[mtable_js_1.CHTMLmtable.kind] = mtable_js_1.CHTMLmtable,
    _a[mtr_js_1.CHTMLmtr.kind] = mtr_js_1.CHTMLmtr,
    _a[mtr_js_1.CHTMLmlabeledtr.kind] = mtr_js_1.CHTMLmlabeledtr,
    _a[mtd_js_1.CHTMLmtd.kind] = mtd_js_1.CHTMLmtd,
    _a[maction_js_1.CHTMLmaction.kind] = maction_js_1.CHTMLmaction,
    _a[mglyph_js_1.CHTMLmglyph.kind] = mglyph_js_1.CHTMLmglyph,
    _a[semantics_js_1.CHTMLsemantics.kind] = semantics_js_1.CHTMLsemantics,
    _a[semantics_js_1.CHTMLannotation.kind] = semantics_js_1.CHTMLannotation,
    _a[semantics_js_1.CHTMLannotationXML.kind] = semantics_js_1.CHTMLannotationXML,
    _a[semantics_js_1.CHTMLxml.kind] = semantics_js_1.CHTMLxml,
    _a[TeXAtom_js_1.CHTMLTeXAtom.kind] = TeXAtom_js_1.CHTMLTeXAtom,
    _a[TextNode_js_1.CHTMLTextNode.kind] = TextNode_js_1.CHTMLTextNode,
    _a[Wrapper_js_1.CHTMLWrapper.kind] = Wrapper_js_1.CHTMLWrapper,
    _a);
//# sourceMappingURL=Wrappers.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/TeXAtom.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/TeXAtom.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLTeXAtom = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var TeXAtom_js_1 = __webpack_require__(/*! ../../common/Wrappers/TeXAtom.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/TeXAtom.js");
var TeXAtom_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/TeXAtom.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/TeXAtom.js");
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var CHTMLTeXAtom = (function (_super) {
    __extends(CHTMLTeXAtom, _super);
    function CHTMLTeXAtom() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLTeXAtom.prototype.toCHTML = function (parent) {
        _super.prototype.toCHTML.call(this, parent);
        this.adaptor.setAttribute(this.chtml, 'texclass', MmlNode_js_1.TEXCLASSNAMES[this.node.texClass]);
        if (this.node.texClass === MmlNode_js_1.TEXCLASS.VCENTER) {
            var bbox = this.childNodes[0].getBBox();
            var h = bbox.h, d = bbox.d;
            var a = this.font.params.axis_height;
            var dh = ((h + d) / 2 + a) - h;
            this.adaptor.setStyle(this.chtml, 'verticalAlign', this.em(dh));
        }
    };
    CHTMLTeXAtom.kind = TeXAtom_js_2.TeXAtom.prototype.kind;
    return CHTMLTeXAtom;
}((0, TeXAtom_js_1.CommonTeXAtomMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLTeXAtom = CHTMLTeXAtom;
//# sourceMappingURL=TeXAtom.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/TextNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/TextNode.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLTextNode = void 0;
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var TextNode_js_1 = __webpack_require__(/*! ../../common/Wrappers/TextNode.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/TextNode.js");
var CHTMLTextNode = (function (_super) {
    __extends(CHTMLTextNode, _super);
    function CHTMLTextNode() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLTextNode.prototype.toCHTML = function (parent) {
        var e_1, _a;
        this.markUsed();
        var adaptor = this.adaptor;
        var variant = this.parent.variant;
        var text = this.node.getText();
        if (text.length === 0)
            return;
        if (variant === '-explicitFont') {
            adaptor.append(parent, this.jax.unknownText(text, variant, this.getBBox().w));
        }
        else {
            var chars = this.remappedText(text, variant);
            try {
                for (var chars_1 = __values(chars), chars_1_1 = chars_1.next(); !chars_1_1.done; chars_1_1 = chars_1.next()) {
                    var n = chars_1_1.value;
                    var data = this.getVariantChar(variant, n)[3];
                    var font = (data.f ? ' TEX-' + data.f : '');
                    var node = (data.unknown ?
                        this.jax.unknownText(String.fromCodePoint(n), variant) :
                        this.html('mjx-c', { class: this.char(n) + font }));
                    adaptor.append(parent, node);
                    !data.unknown && this.font.charUsage.add([variant, n]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (chars_1_1 && !chars_1_1.done && (_a = chars_1.return)) _a.call(chars_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    CHTMLTextNode.kind = MmlNode_js_1.TextNode.prototype.kind;
    CHTMLTextNode.autoStyle = false;
    CHTMLTextNode.styles = {
        'mjx-c': {
            display: 'inline-block'
        },
        'mjx-utext': {
            display: 'inline-block',
            padding: '.75em 0 .2em 0'
        }
    };
    return CHTMLTextNode;
}((0, TextNode_js_1.CommonTextNodeMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLTextNode = CHTMLTextNode;
//# sourceMappingURL=TextNode.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/maction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/maction.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmaction = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var maction_js_1 = __webpack_require__(/*! ../../common/Wrappers/maction.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/maction.js");
var maction_js_2 = __webpack_require__(/*! ../../common/Wrappers/maction.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/maction.js");
var maction_js_3 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/maction.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/maction.js");
var CHTMLmaction = (function (_super) {
    __extends(CHTMLmaction, _super);
    function CHTMLmaction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmaction.prototype.toCHTML = function (parent) {
        var chtml = this.standardCHTMLnode(parent);
        var child = this.selected;
        child.toCHTML(chtml);
        this.action(this, this.data);
    };
    CHTMLmaction.prototype.setEventHandler = function (type, handler) {
        this.chtml.addEventListener(type, handler);
    };
    CHTMLmaction.kind = maction_js_3.MmlMaction.prototype.kind;
    CHTMLmaction.styles = {
        'mjx-maction': {
            position: 'relative'
        },
        'mjx-maction > mjx-tool': {
            display: 'none',
            position: 'absolute',
            bottom: 0, right: 0,
            width: 0, height: 0,
            'z-index': 500
        },
        'mjx-tool > mjx-tip': {
            display: 'inline-block',
            padding: '.2em',
            border: '1px solid #888',
            'font-size': '70%',
            'background-color': '#F8F8F8',
            color: 'black',
            'box-shadow': '2px 2px 5px #AAAAAA'
        },
        'mjx-maction[toggle]': {
            cursor: 'pointer'
        },
        'mjx-status': {
            display: 'block',
            position: 'fixed',
            left: '1em',
            bottom: '1em',
            'min-width': '25%',
            padding: '.2em .4em',
            border: '1px solid #888',
            'font-size': '90%',
            'background-color': '#F8F8F8',
            color: 'black'
        }
    };
    CHTMLmaction.actions = new Map([
        ['toggle', [function (node, _data) {
                    node.adaptor.setAttribute(node.chtml, 'toggle', node.node.attributes.get('selection'));
                    var math = node.factory.jax.math;
                    var document = node.factory.jax.document;
                    var mml = node.node;
                    node.setEventHandler('click', function (event) {
                        if (!math.end.node) {
                            math.start.node = math.end.node = math.typesetRoot;
                            math.start.n = math.end.n = 0;
                        }
                        mml.nextToggleSelection();
                        math.rerender(document);
                        event.stopPropagation();
                    });
                }, {}]],
        ['tooltip', [function (node, data) {
                    var tip = node.childNodes[1];
                    if (!tip)
                        return;
                    if (tip.node.isKind('mtext')) {
                        var text = tip.node.getText();
                        node.adaptor.setAttribute(node.chtml, 'title', text);
                    }
                    else {
                        var adaptor_1 = node.adaptor;
                        var tool_1 = adaptor_1.append(node.chtml, node.html('mjx-tool', {
                            style: { bottom: node.em(-node.dy), right: node.em(-node.dx) }
                        }, [node.html('mjx-tip')]));
                        tip.toCHTML(adaptor_1.firstChild(tool_1));
                        node.setEventHandler('mouseover', function (event) {
                            data.stopTimers(node, data);
                            var timeout = setTimeout(function () { return adaptor_1.setStyle(tool_1, 'display', 'block'); }, data.postDelay);
                            data.hoverTimer.set(node, timeout);
                            event.stopPropagation();
                        });
                        node.setEventHandler('mouseout', function (event) {
                            data.stopTimers(node, data);
                            var timeout = setTimeout(function () { return adaptor_1.setStyle(tool_1, 'display', ''); }, data.clearDelay);
                            data.clearTimer.set(node, timeout);
                            event.stopPropagation();
                        });
                    }
                }, maction_js_2.TooltipData]],
        ['statusline', [function (node, data) {
                    var tip = node.childNodes[1];
                    if (!tip)
                        return;
                    if (tip.node.isKind('mtext')) {
                        var adaptor_2 = node.adaptor;
                        var text_1 = tip.node.getText();
                        adaptor_2.setAttribute(node.chtml, 'statusline', text_1);
                        node.setEventHandler('mouseover', function (event) {
                            if (data.status === null) {
                                var body = adaptor_2.body(adaptor_2.document);
                                data.status = adaptor_2.append(body, node.html('mjx-status', {}, [node.text(text_1)]));
                            }
                            event.stopPropagation();
                        });
                        node.setEventHandler('mouseout', function (event) {
                            if (data.status) {
                                adaptor_2.remove(data.status);
                                data.status = null;
                            }
                            event.stopPropagation();
                        });
                    }
                }, {
                    status: null
                }]]
    ]);
    return CHTMLmaction;
}((0, maction_js_1.CommonMactionMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmaction = CHTMLmaction;
//# sourceMappingURL=maction.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/math.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/math.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmath = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var math_js_1 = __webpack_require__(/*! ../../common/Wrappers/math.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/math.js");
var math_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/math.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/math.js");
var BBox_js_1 = __webpack_require__(/*! ../../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
var CHTMLmath = (function (_super) {
    __extends(CHTMLmath, _super);
    function CHTMLmath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmath.prototype.toCHTML = function (parent) {
        _super.prototype.toCHTML.call(this, parent);
        var chtml = this.chtml;
        var adaptor = this.adaptor;
        var display = (this.node.attributes.get('display') === 'block');
        if (display) {
            adaptor.setAttribute(chtml, 'display', 'true');
            adaptor.setAttribute(parent, 'display', 'true');
            this.handleDisplay(parent);
        }
        else {
            this.handleInline(parent);
        }
        adaptor.addClass(chtml, 'MJX-TEX');
    };
    CHTMLmath.prototype.handleDisplay = function (parent) {
        var adaptor = this.adaptor;
        var _a = __read(this.getAlignShift(), 2), align = _a[0], shift = _a[1];
        if (align !== 'center') {
            adaptor.setAttribute(parent, 'justify', align);
        }
        if (this.bbox.pwidth === BBox_js_1.BBox.fullWidth) {
            adaptor.setAttribute(parent, 'width', 'full');
            if (this.jax.table) {
                var _b = this.jax.table.getOuterBBox(), L = _b.L, w = _b.w, R = _b.R;
                if (align === 'right') {
                    R = Math.max(R || -shift, -shift);
                }
                else if (align === 'left') {
                    L = Math.max(L || shift, shift);
                }
                else if (align === 'center') {
                    w += 2 * Math.abs(shift);
                }
                var W = this.em(Math.max(0, L + w + R));
                adaptor.setStyle(parent, 'min-width', W);
                adaptor.setStyle(this.jax.table.chtml, 'min-width', W);
            }
        }
        else {
            this.setIndent(this.chtml, align, shift);
        }
    };
    CHTMLmath.prototype.handleInline = function (parent) {
        var adaptor = this.adaptor;
        var margin = adaptor.getStyle(this.chtml, 'margin-right');
        if (margin) {
            adaptor.setStyle(this.chtml, 'margin-right', '');
            adaptor.setStyle(parent, 'margin-right', margin);
            adaptor.setStyle(parent, 'width', '0');
        }
    };
    CHTMLmath.prototype.setChildPWidths = function (recompute, w, clear) {
        if (w === void 0) { w = null; }
        if (clear === void 0) { clear = true; }
        return (this.parent ? _super.prototype.setChildPWidths.call(this, recompute, w, clear) : false);
    };
    CHTMLmath.kind = math_js_2.MmlMath.prototype.kind;
    CHTMLmath.styles = {
        'mjx-math': {
            'line-height': 0,
            'text-align': 'left',
            'text-indent': 0,
            'font-style': 'normal',
            'font-weight': 'normal',
            'font-size': '100%',
            'font-size-adjust': 'none',
            'letter-spacing': 'normal',
            'border-collapse': 'collapse',
            'word-wrap': 'normal',
            'word-spacing': 'normal',
            'white-space': 'nowrap',
            'direction': 'ltr',
            'padding': '1px 0'
        },
        'mjx-container[jax="CHTML"][display="true"]': {
            display: 'block',
            'text-align': 'center',
            margin: '1em 0'
        },
        'mjx-container[jax="CHTML"][display="true"][width="full"]': {
            display: 'flex'
        },
        'mjx-container[jax="CHTML"][display="true"] mjx-math': {
            padding: 0
        },
        'mjx-container[jax="CHTML"][justify="left"]': {
            'text-align': 'left'
        },
        'mjx-container[jax="CHTML"][justify="right"]': {
            'text-align': 'right'
        }
    };
    return CHTMLmath;
}((0, math_js_1.CommonMathMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmath = CHTMLmath;
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/menclose.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/menclose.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmenclose = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var menclose_js_1 = __webpack_require__(/*! ../../common/Wrappers/menclose.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/menclose.js");
var Notation = __importStar(__webpack_require__(/*! ../Notation.js */ "./node_modules/mathjax-full/js/output/chtml/Notation.js"));
var menclose_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/menclose.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/menclose.js");
var lengths_js_1 = __webpack_require__(/*! ../../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
function Angle(x, y) {
    return Math.atan2(x, y).toFixed(3).replace(/\.?0+$/, '');
}
var ANGLE = Angle(Notation.ARROWDX, Notation.ARROWY);
var CHTMLmenclose = (function (_super) {
    __extends(CHTMLmenclose, _super);
    function CHTMLmenclose() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmenclose.prototype.toCHTML = function (parent) {
        var e_1, _a, e_2, _b;
        var adaptor = this.adaptor;
        var chtml = this.standardCHTMLnode(parent);
        var block = adaptor.append(chtml, this.html('mjx-box'));
        if (this.renderChild) {
            this.renderChild(this, block);
        }
        else {
            this.childNodes[0].toCHTML(block);
        }
        try {
            for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var name_1 = _d.value;
                var notation = this.notations[name_1];
                !notation.renderChild && notation.renderer(this, block);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var pbox = this.getPadding();
        try {
            for (var _e = __values(Notation.sideNames), _f = _e.next(); !_f.done; _f = _e.next()) {
                var name_2 = _f.value;
                var i = Notation.sideIndex[name_2];
                pbox[i] > 0 && adaptor.setStyle(block, 'padding-' + name_2, this.em(pbox[i]));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    CHTMLmenclose.prototype.arrow = function (w, a, double, offset, dist) {
        if (offset === void 0) { offset = ''; }
        if (dist === void 0) { dist = 0; }
        var W = this.getBBox().w;
        var style = { width: this.em(w) };
        if (W !== w) {
            style.left = this.em((W - w) / 2);
        }
        if (a) {
            style.transform = 'rotate(' + this.fixed(a) + 'rad)';
        }
        var arrow = this.html('mjx-arrow', { style: style }, [
            this.html('mjx-aline'), this.html('mjx-rthead'), this.html('mjx-rbhead')
        ]);
        if (double) {
            this.adaptor.append(arrow, this.html('mjx-lthead'));
            this.adaptor.append(arrow, this.html('mjx-lbhead'));
            this.adaptor.setAttribute(arrow, 'double', 'true');
        }
        this.adjustArrow(arrow, double);
        this.moveArrow(arrow, offset, dist);
        return arrow;
    };
    CHTMLmenclose.prototype.adjustArrow = function (arrow, double) {
        var _this = this;
        var t = this.thickness;
        var head = this.arrowhead;
        if (head.x === Notation.ARROWX && head.y === Notation.ARROWY &&
            head.dx === Notation.ARROWDX && t === Notation.THICKNESS)
            return;
        var _a = __read([t * head.x, t * head.y].map(function (x) { return _this.em(x); }), 2), x = _a[0], y = _a[1];
        var a = Angle(head.dx, head.y);
        var _b = __read(this.adaptor.childNodes(arrow), 5), line = _b[0], rthead = _b[1], rbhead = _b[2], lthead = _b[3], lbhead = _b[4];
        this.adjustHead(rthead, [y, '0', '1px', x], a);
        this.adjustHead(rbhead, ['1px', '0', y, x], '-' + a);
        this.adjustHead(lthead, [y, x, '1px', '0'], '-' + a);
        this.adjustHead(lbhead, ['1px', x, y, '0'], a);
        this.adjustLine(line, t, head.x, double);
    };
    CHTMLmenclose.prototype.adjustHead = function (head, border, a) {
        if (head) {
            this.adaptor.setStyle(head, 'border-width', border.join(' '));
            this.adaptor.setStyle(head, 'transform', 'skewX(' + a + 'rad)');
        }
    };
    CHTMLmenclose.prototype.adjustLine = function (line, t, x, double) {
        this.adaptor.setStyle(line, 'borderTop', this.em(t) + ' solid');
        this.adaptor.setStyle(line, 'top', this.em(-t / 2));
        this.adaptor.setStyle(line, 'right', this.em(t * (x - 1)));
        if (double) {
            this.adaptor.setStyle(line, 'left', this.em(t * (x - 1)));
        }
    };
    CHTMLmenclose.prototype.moveArrow = function (arrow, offset, d) {
        if (!d)
            return;
        var transform = this.adaptor.getStyle(arrow, 'transform');
        this.adaptor.setStyle(arrow, 'transform', "translate".concat(offset, "(").concat(this.em(-d), ")").concat((transform ? ' ' + transform : '')));
    };
    CHTMLmenclose.prototype.adjustBorder = function (node) {
        if (this.thickness !== Notation.THICKNESS) {
            this.adaptor.setStyle(node, 'borderWidth', this.em(this.thickness));
        }
        return node;
    };
    CHTMLmenclose.prototype.adjustThickness = function (shape) {
        if (this.thickness !== Notation.THICKNESS) {
            this.adaptor.setStyle(shape, 'strokeWidth', this.fixed(this.thickness));
        }
        return shape;
    };
    CHTMLmenclose.prototype.fixed = function (m, n) {
        if (n === void 0) { n = 3; }
        if (Math.abs(m) < .0006) {
            return '0';
        }
        return m.toFixed(n).replace(/\.?0+$/, '');
    };
    CHTMLmenclose.prototype.em = function (m) {
        return _super.prototype.em.call(this, m);
    };
    CHTMLmenclose.kind = menclose_js_2.MmlMenclose.prototype.kind;
    CHTMLmenclose.styles = {
        'mjx-menclose': {
            position: 'relative'
        },
        'mjx-menclose > mjx-dstrike': {
            display: 'inline-block',
            left: 0, top: 0,
            position: 'absolute',
            'border-top': Notation.SOLID,
            'transform-origin': 'top left'
        },
        'mjx-menclose > mjx-ustrike': {
            display: 'inline-block',
            left: 0, bottom: 0,
            position: 'absolute',
            'border-top': Notation.SOLID,
            'transform-origin': 'bottom left'
        },
        'mjx-menclose > mjx-hstrike': {
            'border-top': Notation.SOLID,
            position: 'absolute',
            left: 0, right: 0, bottom: '50%',
            transform: 'translateY(' + (0, lengths_js_1.em)(Notation.THICKNESS / 2) + ')'
        },
        'mjx-menclose > mjx-vstrike': {
            'border-left': Notation.SOLID,
            position: 'absolute',
            top: 0, bottom: 0, right: '50%',
            transform: 'translateX(' + (0, lengths_js_1.em)(Notation.THICKNESS / 2) + ')'
        },
        'mjx-menclose > mjx-rbox': {
            position: 'absolute',
            top: 0, bottom: 0, right: 0, left: 0,
            'border': Notation.SOLID,
            'border-radius': (0, lengths_js_1.em)(Notation.THICKNESS + Notation.PADDING)
        },
        'mjx-menclose > mjx-cbox': {
            position: 'absolute',
            top: 0, bottom: 0, right: 0, left: 0,
            'border': Notation.SOLID,
            'border-radius': '50%'
        },
        'mjx-menclose > mjx-arrow': {
            position: 'absolute',
            left: 0, bottom: '50%', height: 0, width: 0
        },
        'mjx-menclose > mjx-arrow > *': {
            display: 'block',
            position: 'absolute',
            'transform-origin': 'bottom',
            'border-left': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWX) + ' solid',
            'border-right': 0,
            'box-sizing': 'border-box'
        },
        'mjx-menclose > mjx-arrow > mjx-aline': {
            left: 0, top: (0, lengths_js_1.em)(-Notation.THICKNESS / 2),
            right: (0, lengths_js_1.em)(Notation.THICKNESS * (Notation.ARROWX - 1)), height: 0,
            'border-top': (0, lengths_js_1.em)(Notation.THICKNESS) + ' solid',
            'border-left': 0
        },
        'mjx-menclose > mjx-arrow[double] > mjx-aline': {
            left: (0, lengths_js_1.em)(Notation.THICKNESS * (Notation.ARROWX - 1)), height: 0,
        },
        'mjx-menclose > mjx-arrow > mjx-rthead': {
            transform: 'skewX(' + ANGLE + 'rad)',
            right: 0, bottom: '-1px',
            'border-bottom': '1px solid transparent',
            'border-top': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWY) + ' solid transparent'
        },
        'mjx-menclose > mjx-arrow > mjx-rbhead': {
            transform: 'skewX(-' + ANGLE + 'rad)',
            'transform-origin': 'top',
            right: 0, top: '-1px',
            'border-top': '1px solid transparent',
            'border-bottom': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWY) + ' solid transparent'
        },
        'mjx-menclose > mjx-arrow > mjx-lthead': {
            transform: 'skewX(-' + ANGLE + 'rad)',
            left: 0, bottom: '-1px',
            'border-left': 0,
            'border-right': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWX) + ' solid',
            'border-bottom': '1px solid transparent',
            'border-top': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWY) + ' solid transparent'
        },
        'mjx-menclose > mjx-arrow > mjx-lbhead': {
            transform: 'skewX(' + ANGLE + 'rad)',
            'transform-origin': 'top',
            left: 0, top: '-1px',
            'border-left': 0,
            'border-right': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWX) + ' solid',
            'border-top': '1px solid transparent',
            'border-bottom': (0, lengths_js_1.em)(Notation.THICKNESS * Notation.ARROWY) + ' solid transparent'
        },
        'mjx-menclose > dbox': {
            position: 'absolute',
            top: 0, bottom: 0, left: (0, lengths_js_1.em)(-1.5 * Notation.PADDING),
            width: (0, lengths_js_1.em)(3 * Notation.PADDING),
            border: (0, lengths_js_1.em)(Notation.THICKNESS) + ' solid',
            'border-radius': '50%',
            'clip-path': 'inset(0 0 0 ' + (0, lengths_js_1.em)(1.5 * Notation.PADDING) + ')',
            'box-sizing': 'border-box'
        }
    };
    CHTMLmenclose.notations = new Map([
        Notation.Border('top'),
        Notation.Border('right'),
        Notation.Border('bottom'),
        Notation.Border('left'),
        Notation.Border2('actuarial', 'top', 'right'),
        Notation.Border2('madruwb', 'bottom', 'right'),
        Notation.DiagonalStrike('up', 1),
        Notation.DiagonalStrike('down', -1),
        ['horizontalstrike', {
                renderer: Notation.RenderElement('hstrike', 'Y'),
                bbox: function (node) { return [0, node.padding, 0, node.padding]; }
            }],
        ['verticalstrike', {
                renderer: Notation.RenderElement('vstrike', 'X'),
                bbox: function (node) { return [node.padding, 0, node.padding, 0]; }
            }],
        ['box', {
                renderer: function (node, child) {
                    node.adaptor.setStyle(child, 'border', node.em(node.thickness) + ' solid');
                },
                bbox: Notation.fullBBox,
                border: Notation.fullBorder,
                remove: 'left right top bottom'
            }],
        ['roundedbox', {
                renderer: Notation.RenderElement('rbox'),
                bbox: Notation.fullBBox
            }],
        ['circle', {
                renderer: Notation.RenderElement('cbox'),
                bbox: Notation.fullBBox
            }],
        ['phasorangle', {
                renderer: function (node, child) {
                    var _a = node.getBBox(), h = _a.h, d = _a.d;
                    var _b = __read(node.getArgMod(1.75 * node.padding, h + d), 2), a = _b[0], W = _b[1];
                    var t = node.thickness * Math.sin(a) * .9;
                    node.adaptor.setStyle(child, 'border-bottom', node.em(node.thickness) + ' solid');
                    var strike = node.adjustBorder(node.html('mjx-ustrike', { style: {
                            width: node.em(W),
                            transform: 'translateX(' + node.em(t) + ') rotate(' + node.fixed(-a) + 'rad)',
                        } }));
                    node.adaptor.append(node.chtml, strike);
                },
                bbox: function (node) {
                    var p = node.padding / 2;
                    var t = node.thickness;
                    return [2 * p, p, p + t, 3 * p + t];
                },
                border: function (node) { return [0, 0, node.thickness, 0]; },
                remove: 'bottom'
            }],
        Notation.Arrow('up'),
        Notation.Arrow('down'),
        Notation.Arrow('left'),
        Notation.Arrow('right'),
        Notation.Arrow('updown'),
        Notation.Arrow('leftright'),
        Notation.DiagonalArrow('updiagonal'),
        Notation.DiagonalArrow('northeast'),
        Notation.DiagonalArrow('southeast'),
        Notation.DiagonalArrow('northwest'),
        Notation.DiagonalArrow('southwest'),
        Notation.DiagonalArrow('northeastsouthwest'),
        Notation.DiagonalArrow('northwestsoutheast'),
        ['longdiv', {
                renderer: function (node, child) {
                    var adaptor = node.adaptor;
                    adaptor.setStyle(child, 'border-top', node.em(node.thickness) + ' solid');
                    var arc = adaptor.append(node.chtml, node.html('dbox'));
                    var t = node.thickness;
                    var p = node.padding;
                    if (t !== Notation.THICKNESS) {
                        adaptor.setStyle(arc, 'border-width', node.em(t));
                    }
                    if (p !== Notation.PADDING) {
                        adaptor.setStyle(arc, 'left', node.em(-1.5 * p));
                        adaptor.setStyle(arc, 'width', node.em(3 * p));
                        adaptor.setStyle(arc, 'clip-path', 'inset(0 0 0 ' + node.em(1.5 * p) + ')');
                    }
                },
                bbox: function (node) {
                    var p = node.padding;
                    var t = node.thickness;
                    return [p + t, p, p, 2 * p + t / 2];
                }
            }],
        ['radical', {
                renderer: function (node, child) {
                    node.msqrt.toCHTML(child);
                    var TRBL = node.sqrtTRBL();
                    node.adaptor.setStyle(node.msqrt.chtml, 'margin', TRBL.map(function (x) { return node.em(-x); }).join(' '));
                },
                init: function (node) {
                    node.msqrt = node.createMsqrt(node.childNodes[0]);
                },
                bbox: function (node) { return node.sqrtTRBL(); },
                renderChild: true
            }]
    ]);
    return CHTMLmenclose;
}((0, menclose_js_1.CommonMencloseMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmenclose = CHTMLmenclose;
//# sourceMappingURL=menclose.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mfenced.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mfenced.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmfenced = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mfenced_js_1 = __webpack_require__(/*! ../../common/Wrappers/mfenced.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mfenced.js");
var mfenced_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mfenced.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mfenced.js");
var CHTMLmfenced = (function (_super) {
    __extends(CHTMLmfenced, _super);
    function CHTMLmfenced() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmfenced.prototype.toCHTML = function (parent) {
        var chtml = this.standardCHTMLnode(parent);
        this.mrow.toCHTML(chtml);
    };
    CHTMLmfenced.kind = mfenced_js_2.MmlMfenced.prototype.kind;
    return CHTMLmfenced;
}((0, mfenced_js_1.CommonMfencedMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmfenced = CHTMLmfenced;
//# sourceMappingURL=mfenced.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mfrac.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mfrac.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmfrac = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mfrac_js_1 = __webpack_require__(/*! ../../common/Wrappers/mfrac.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mfrac.js");
var mfrac_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mfrac.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mfrac.js");
var CHTMLmfrac = (function (_super) {
    __extends(CHTMLmfrac, _super);
    function CHTMLmfrac() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmfrac.prototype.toCHTML = function (parent) {
        this.standardCHTMLnode(parent);
        var _a = this.node.attributes.getList('linethickness', 'bevelled'), linethickness = _a.linethickness, bevelled = _a.bevelled;
        var display = this.isDisplay();
        if (bevelled) {
            this.makeBevelled(display);
        }
        else {
            var thickness = this.length2em(String(linethickness), .06);
            if (thickness === 0) {
                this.makeAtop(display);
            }
            else {
                this.makeFraction(display, thickness);
            }
        }
    };
    CHTMLmfrac.prototype.makeFraction = function (display, t) {
        var _a = this.node.attributes.getList('numalign', 'denomalign'), numalign = _a.numalign, denomalign = _a.denomalign;
        var withDelims = this.node.getProperty('withDelims');
        var attr = (display ? { type: 'd' } : {});
        var fattr = (withDelims ? __assign(__assign({}, attr), { delims: 'true' }) : __assign({}, attr));
        var nattr = (numalign !== 'center' ? { align: numalign } : {});
        var dattr = (denomalign !== 'center' ? { align: denomalign } : {});
        var dsattr = __assign({}, attr), nsattr = __assign({}, attr);
        var tex = this.font.params;
        if (t !== .06) {
            var a = tex.axis_height;
            var tEm = this.em(t);
            var _b = this.getTUV(display, t), T = _b.T, u = _b.u, v = _b.v;
            var m = (display ? this.em(3 * t) : tEm) + ' -.1em';
            attr.style = { height: tEm, 'border-top': tEm + ' solid', margin: m };
            var nh = this.em(Math.max(0, u));
            nsattr.style = { height: nh, 'vertical-align': '-' + nh };
            dsattr.style = { height: this.em(Math.max(0, v)) };
            fattr.style = { 'vertical-align': this.em(a - T) };
        }
        var num, den;
        this.adaptor.append(this.chtml, this.html('mjx-frac', fattr, [
            num = this.html('mjx-num', nattr, [this.html('mjx-nstrut', nsattr)]),
            this.html('mjx-dbox', {}, [
                this.html('mjx-dtable', {}, [
                    this.html('mjx-line', attr),
                    this.html('mjx-row', {}, [
                        den = this.html('mjx-den', dattr, [this.html('mjx-dstrut', dsattr)])
                    ])
                ])
            ])
        ]));
        this.childNodes[0].toCHTML(num);
        this.childNodes[1].toCHTML(den);
    };
    CHTMLmfrac.prototype.makeAtop = function (display) {
        var _a = this.node.attributes.getList('numalign', 'denomalign'), numalign = _a.numalign, denomalign = _a.denomalign;
        var withDelims = this.node.getProperty('withDelims');
        var attr = (display ? { type: 'd', atop: true } : { atop: true });
        var fattr = (withDelims ? __assign(__assign({}, attr), { delims: true }) : __assign({}, attr));
        var nattr = (numalign !== 'center' ? { align: numalign } : {});
        var dattr = (denomalign !== 'center' ? { align: denomalign } : {});
        var _b = this.getUVQ(display), v = _b.v, q = _b.q;
        nattr.style = { 'padding-bottom': this.em(q) };
        fattr.style = { 'vertical-align': this.em(-v) };
        var num, den;
        this.adaptor.append(this.chtml, this.html('mjx-frac', fattr, [
            num = this.html('mjx-num', nattr),
            den = this.html('mjx-den', dattr)
        ]));
        this.childNodes[0].toCHTML(num);
        this.childNodes[1].toCHTML(den);
    };
    CHTMLmfrac.prototype.makeBevelled = function (display) {
        var adaptor = this.adaptor;
        adaptor.setAttribute(this.chtml, 'bevelled', 'ture');
        var num = adaptor.append(this.chtml, this.html('mjx-num'));
        this.childNodes[0].toCHTML(num);
        this.bevel.toCHTML(this.chtml);
        var den = adaptor.append(this.chtml, this.html('mjx-den'));
        this.childNodes[1].toCHTML(den);
        var _a = this.getBevelData(display), u = _a.u, v = _a.v, delta = _a.delta, nbox = _a.nbox, dbox = _a.dbox;
        if (u) {
            adaptor.setStyle(num, 'verticalAlign', this.em(u / nbox.scale));
        }
        if (v) {
            adaptor.setStyle(den, 'verticalAlign', this.em(v / dbox.scale));
        }
        var dx = this.em(-delta / 2);
        adaptor.setStyle(this.bevel.chtml, 'marginLeft', dx);
        adaptor.setStyle(this.bevel.chtml, 'marginRight', dx);
    };
    CHTMLmfrac.kind = mfrac_js_2.MmlMfrac.prototype.kind;
    CHTMLmfrac.styles = {
        'mjx-frac': {
            display: 'inline-block',
            'vertical-align': '0.17em',
            padding: '0 .22em'
        },
        'mjx-frac[type="d"]': {
            'vertical-align': '.04em'
        },
        'mjx-frac[delims]': {
            padding: '0 .1em'
        },
        'mjx-frac[atop]': {
            padding: '0 .12em'
        },
        'mjx-frac[atop][delims]': {
            padding: '0'
        },
        'mjx-dtable': {
            display: 'inline-table',
            width: '100%'
        },
        'mjx-dtable > *': {
            'font-size': '2000%'
        },
        'mjx-dbox': {
            display: 'block',
            'font-size': '5%'
        },
        'mjx-num': {
            display: 'block',
            'text-align': 'center'
        },
        'mjx-den': {
            display: 'block',
            'text-align': 'center'
        },
        'mjx-mfrac[bevelled] > mjx-num': {
            display: 'inline-block'
        },
        'mjx-mfrac[bevelled] > mjx-den': {
            display: 'inline-block'
        },
        'mjx-den[align="right"], mjx-num[align="right"]': {
            'text-align': 'right'
        },
        'mjx-den[align="left"], mjx-num[align="left"]': {
            'text-align': 'left'
        },
        'mjx-nstrut': {
            display: 'inline-block',
            height: '.054em',
            width: 0,
            'vertical-align': '-.054em'
        },
        'mjx-nstrut[type="d"]': {
            height: '.217em',
            'vertical-align': '-.217em',
        },
        'mjx-dstrut': {
            display: 'inline-block',
            height: '.505em',
            width: 0
        },
        'mjx-dstrut[type="d"]': {
            height: '.726em',
        },
        'mjx-line': {
            display: 'block',
            'box-sizing': 'border-box',
            'min-height': '1px',
            height: '.06em',
            'border-top': '.06em solid',
            margin: '.06em -.1em',
            overflow: 'hidden'
        },
        'mjx-line[type="d"]': {
            margin: '.18em -.1em'
        }
    };
    return CHTMLmfrac;
}((0, mfrac_js_1.CommonMfracMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmfrac = CHTMLmfrac;
//# sourceMappingURL=mfrac.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mglyph.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mglyph.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmglyph = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mglyph_js_1 = __webpack_require__(/*! ../../common/Wrappers/mglyph.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mglyph.js");
var mglyph_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mglyph.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mglyph.js");
var CHTMLmglyph = (function (_super) {
    __extends(CHTMLmglyph, _super);
    function CHTMLmglyph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmglyph.prototype.toCHTML = function (parent) {
        var chtml = this.standardCHTMLnode(parent);
        if (this.charWrapper) {
            this.charWrapper.toCHTML(chtml);
            return;
        }
        var _a = this.node.attributes.getList('src', 'alt'), src = _a.src, alt = _a.alt;
        var styles = {
            width: this.em(this.width),
            height: this.em(this.height)
        };
        if (this.valign) {
            styles.verticalAlign = this.em(this.valign);
        }
        var img = this.html('img', { src: src, style: styles, alt: alt, title: alt });
        this.adaptor.append(chtml, img);
    };
    CHTMLmglyph.kind = mglyph_js_2.MmlMglyph.prototype.kind;
    CHTMLmglyph.styles = {
        'mjx-mglyph > img': {
            display: 'inline-block',
            border: 0,
            padding: 0
        }
    };
    return CHTMLmglyph;
}((0, mglyph_js_1.CommonMglyphMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmglyph = CHTMLmglyph;
//# sourceMappingURL=mglyph.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mi.js":
/*!******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mi.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmi = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mi_js_1 = __webpack_require__(/*! ../../common/Wrappers/mi.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mi.js");
var mi_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mi.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mi.js");
var CHTMLmi = (function (_super) {
    __extends(CHTMLmi, _super);
    function CHTMLmi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmi.kind = mi_js_2.MmlMi.prototype.kind;
    return CHTMLmi;
}((0, mi_js_1.CommonMiMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmi = CHTMLmi;
//# sourceMappingURL=mi.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mmultiscripts.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mmultiscripts.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmmultiscripts = void 0;
var msubsup_js_1 = __webpack_require__(/*! ./msubsup.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msubsup.js");
var mmultiscripts_js_1 = __webpack_require__(/*! ../../common/Wrappers/mmultiscripts.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mmultiscripts.js");
var mmultiscripts_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mmultiscripts.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mmultiscripts.js");
var string_js_1 = __webpack_require__(/*! ../../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
var CHTMLmmultiscripts = (function (_super) {
    __extends(CHTMLmmultiscripts, _super);
    function CHTMLmmultiscripts() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmmultiscripts.prototype.toCHTML = function (parent) {
        var chtml = this.standardCHTMLnode(parent);
        var data = this.scriptData;
        var scriptalign = this.node.getProperty('scriptalign') || 'right left';
        var _a = __read((0, string_js_1.split)(scriptalign + ' ' + scriptalign), 2), preAlign = _a[0], postAlign = _a[1];
        var sub = this.combinePrePost(data.sub, data.psub);
        var sup = this.combinePrePost(data.sup, data.psup);
        var _b = __read(this.getUVQ(sub, sup), 2), u = _b[0], v = _b[1];
        if (data.numPrescripts) {
            var scripts = this.addScripts(u, -v, true, data.psub, data.psup, this.firstPrescript, data.numPrescripts);
            preAlign !== 'right' && this.adaptor.setAttribute(scripts, 'script-align', preAlign);
        }
        this.childNodes[0].toCHTML(chtml);
        if (data.numScripts) {
            var scripts = this.addScripts(u, -v, false, data.sub, data.sup, 1, data.numScripts);
            postAlign !== 'left' && this.adaptor.setAttribute(scripts, 'script-align', postAlign);
        }
    };
    CHTMLmmultiscripts.prototype.addScripts = function (u, v, isPre, sub, sup, i, n) {
        var adaptor = this.adaptor;
        var q = (u - sup.d) + (v - sub.h);
        var U = (u < 0 && v === 0 ? sub.h + u : u);
        var rowdef = (q > 0 ? { style: { height: this.em(q) } } : {});
        var tabledef = (U ? { style: { 'vertical-align': this.em(U) } } : {});
        var supRow = this.html('mjx-row');
        var sepRow = this.html('mjx-row', rowdef);
        var subRow = this.html('mjx-row');
        var name = 'mjx-' + (isPre ? 'pre' : '') + 'scripts';
        var m = i + 2 * n;
        while (i < m) {
            this.childNodes[i++].toCHTML(adaptor.append(subRow, this.html('mjx-cell')));
            this.childNodes[i++].toCHTML(adaptor.append(supRow, this.html('mjx-cell')));
        }
        return adaptor.append(this.chtml, this.html(name, tabledef, [supRow, sepRow, subRow]));
    };
    CHTMLmmultiscripts.kind = mmultiscripts_js_2.MmlMmultiscripts.prototype.kind;
    CHTMLmmultiscripts.styles = {
        'mjx-prescripts': {
            display: 'inline-table',
            'padding-left': '.05em'
        },
        'mjx-scripts': {
            display: 'inline-table',
            'padding-right': '.05em'
        },
        'mjx-prescripts > mjx-row > mjx-cell': {
            'text-align': 'right'
        },
        '[script-align="left"] > mjx-row > mjx-cell': {
            'text-align': 'left'
        },
        '[script-align="center"] > mjx-row > mjx-cell': {
            'text-align': 'center'
        },
        '[script-align="right"] > mjx-row > mjx-cell': {
            'text-align': 'right'
        }
    };
    return CHTMLmmultiscripts;
}((0, mmultiscripts_js_1.CommonMmultiscriptsMixin)(msubsup_js_1.CHTMLmsubsup)));
exports.CHTMLmmultiscripts = CHTMLmmultiscripts;
//# sourceMappingURL=mmultiscripts.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mn.js":
/*!******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mn.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmn = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mn_js_1 = __webpack_require__(/*! ../../common/Wrappers/mn.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mn.js");
var mn_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mn.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mn.js");
var CHTMLmn = (function (_super) {
    __extends(CHTMLmn, _super);
    function CHTMLmn() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmn.kind = mn_js_2.MmlMn.prototype.kind;
    return CHTMLmn;
}((0, mn_js_1.CommonMnMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmn = CHTMLmn;
//# sourceMappingURL=mn.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mo.js":
/*!******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mo.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmo = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mo_js_1 = __webpack_require__(/*! ../../common/Wrappers/mo.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mo.js");
var mo_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mo.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mo.js");
var CHTMLmo = (function (_super) {
    __extends(CHTMLmo, _super);
    function CHTMLmo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmo.prototype.toCHTML = function (parent) {
        var e_1, _a;
        var attributes = this.node.attributes;
        var symmetric = attributes.get('symmetric') && this.stretch.dir !== 2;
        var stretchy = this.stretch.dir !== 0;
        if (stretchy && this.size === null) {
            this.getStretchedVariant([]);
        }
        var chtml = this.standardCHTMLnode(parent);
        if (stretchy && this.size < 0) {
            this.stretchHTML(chtml);
        }
        else {
            if (symmetric || attributes.get('largeop')) {
                var u = this.em(this.getCenterOffset());
                if (u !== '0') {
                    this.adaptor.setStyle(chtml, 'verticalAlign', u);
                }
            }
            if (this.node.getProperty('mathaccent')) {
                this.adaptor.setStyle(chtml, 'width', '0');
                this.adaptor.setStyle(chtml, 'margin-left', this.em(this.getAccentOffset()));
            }
            try {
                for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    child.toCHTML(chtml);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    CHTMLmo.prototype.stretchHTML = function (chtml) {
        var c = this.getText().codePointAt(0);
        this.font.delimUsage.add(c);
        this.childNodes[0].markUsed();
        var delim = this.stretch;
        var stretch = delim.stretch;
        var content = [];
        if (stretch[0]) {
            content.push(this.html('mjx-beg', {}, [this.html('mjx-c')]));
        }
        content.push(this.html('mjx-ext', {}, [this.html('mjx-c')]));
        if (stretch.length === 4) {
            content.push(this.html('mjx-mid', {}, [this.html('mjx-c')]), this.html('mjx-ext', {}, [this.html('mjx-c')]));
        }
        if (stretch[2]) {
            content.push(this.html('mjx-end', {}, [this.html('mjx-c')]));
        }
        var styles = {};
        var _a = this.bbox, h = _a.h, d = _a.d, w = _a.w;
        if (delim.dir === 1) {
            content.push(this.html('mjx-mark'));
            styles.height = this.em(h + d);
            styles.verticalAlign = this.em(-d);
        }
        else {
            styles.width = this.em(w);
        }
        var dir = mo_js_1.DirectionVH[delim.dir];
        var properties = { class: this.char(delim.c || c), style: styles };
        var html = this.html('mjx-stretchy-' + dir, properties, content);
        this.adaptor.append(chtml, html);
    };
    CHTMLmo.kind = mo_js_2.MmlMo.prototype.kind;
    CHTMLmo.styles = {
        'mjx-stretchy-h': {
            display: 'inline-table',
            width: '100%'
        },
        'mjx-stretchy-h > *': {
            display: 'table-cell',
            width: 0
        },
        'mjx-stretchy-h > * > mjx-c': {
            display: 'inline-block',
            transform: 'scalex(1.0000001)'
        },
        'mjx-stretchy-h > * > mjx-c::before': {
            display: 'inline-block',
            width: 'initial'
        },
        'mjx-stretchy-h > mjx-ext': {
            '/* IE */ overflow': 'hidden',
            '/* others */ overflow': 'clip visible',
            width: '100%'
        },
        'mjx-stretchy-h > mjx-ext > mjx-c::before': {
            transform: 'scalex(500)'
        },
        'mjx-stretchy-h > mjx-ext > mjx-c': {
            width: 0
        },
        'mjx-stretchy-h > mjx-beg > mjx-c': {
            'margin-right': '-.1em'
        },
        'mjx-stretchy-h > mjx-end > mjx-c': {
            'margin-left': '-.1em'
        },
        'mjx-stretchy-v': {
            display: 'inline-block'
        },
        'mjx-stretchy-v > *': {
            display: 'block'
        },
        'mjx-stretchy-v > mjx-beg': {
            height: 0
        },
        'mjx-stretchy-v > mjx-end > mjx-c': {
            display: 'block'
        },
        'mjx-stretchy-v > * > mjx-c': {
            transform: 'scaley(1.0000001)',
            'transform-origin': 'left center',
            overflow: 'hidden'
        },
        'mjx-stretchy-v > mjx-ext': {
            display: 'block',
            height: '100%',
            'box-sizing': 'border-box',
            border: '0px solid transparent',
            '/* IE */ overflow': 'hidden',
            '/* others */ overflow': 'visible clip',
        },
        'mjx-stretchy-v > mjx-ext > mjx-c::before': {
            width: 'initial',
            'box-sizing': 'border-box'
        },
        'mjx-stretchy-v > mjx-ext > mjx-c': {
            transform: 'scaleY(500) translateY(.075em)',
            overflow: 'visible'
        },
        'mjx-mark': {
            display: 'inline-block',
            height: '0px'
        }
    };
    return CHTMLmo;
}((0, mo_js_1.CommonMoMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmo = CHTMLmo;
//# sourceMappingURL=mo.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mpadded.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mpadded.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmpadded = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mpadded_js_1 = __webpack_require__(/*! ../../common/Wrappers/mpadded.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mpadded.js");
var mpadded_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mpadded.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mpadded.js");
var CHTMLmpadded = (function (_super) {
    __extends(CHTMLmpadded, _super);
    function CHTMLmpadded() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmpadded.prototype.toCHTML = function (parent) {
        var e_1, _a;
        var chtml = this.standardCHTMLnode(parent);
        var content = [];
        var style = {};
        var _b = __read(this.getDimens(), 9), W = _b[2], dh = _b[3], dd = _b[4], dw = _b[5], x = _b[6], y = _b[7], dx = _b[8];
        if (dw) {
            style.width = this.em(W + dw);
        }
        if (dh || dd) {
            style.margin = this.em(dh) + ' 0 ' + this.em(dd);
        }
        if (x + dx || y) {
            style.position = 'relative';
            var rbox = this.html('mjx-rbox', {
                style: { left: this.em(x + dx), top: this.em(-y), 'max-width': style.width }
            });
            if (x + dx && this.childNodes[0].getBBox().pwidth) {
                this.adaptor.setAttribute(rbox, 'width', 'full');
                this.adaptor.setStyle(rbox, 'left', this.em(x));
            }
            content.push(rbox);
        }
        chtml = this.adaptor.append(chtml, this.html('mjx-block', { style: style }, content));
        try {
            for (var _c = __values(this.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var child = _d.value;
                child.toCHTML(content[0] || chtml);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    CHTMLmpadded.kind = mpadded_js_2.MmlMpadded.prototype.kind;
    CHTMLmpadded.styles = {
        'mjx-mpadded': {
            display: 'inline-block'
        },
        'mjx-rbox': {
            display: 'inline-block',
            position: 'relative'
        }
    };
    return CHTMLmpadded;
}((0, mpadded_js_1.CommonMpaddedMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmpadded = CHTMLmpadded;
//# sourceMappingURL=mpadded.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mroot.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mroot.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmroot = void 0;
var msqrt_js_1 = __webpack_require__(/*! ./msqrt.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msqrt.js");
var mroot_js_1 = __webpack_require__(/*! ../../common/Wrappers/mroot.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mroot.js");
var mroot_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mroot.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mroot.js");
var CHTMLmroot = (function (_super) {
    __extends(CHTMLmroot, _super);
    function CHTMLmroot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmroot.prototype.addRoot = function (ROOT, root, sbox, H) {
        root.toCHTML(ROOT);
        var _a = __read(this.getRootDimens(sbox, H), 3), x = _a[0], h = _a[1], dx = _a[2];
        this.adaptor.setStyle(ROOT, 'verticalAlign', this.em(h));
        this.adaptor.setStyle(ROOT, 'width', this.em(x));
        if (dx) {
            this.adaptor.setStyle(this.adaptor.firstChild(ROOT), 'paddingLeft', this.em(dx));
        }
    };
    CHTMLmroot.kind = mroot_js_2.MmlMroot.prototype.kind;
    return CHTMLmroot;
}((0, mroot_js_1.CommonMrootMixin)(msqrt_js_1.CHTMLmsqrt)));
exports.CHTMLmroot = CHTMLmroot;
//# sourceMappingURL=mroot.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mrow.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mrow.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLinferredMrow = exports.CHTMLmrow = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mrow_js_1 = __webpack_require__(/*! ../../common/Wrappers/mrow.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mrow.js");
var mrow_js_2 = __webpack_require__(/*! ../../common/Wrappers/mrow.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mrow.js");
var mrow_js_3 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mrow.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mrow.js");
var CHTMLmrow = (function (_super) {
    __extends(CHTMLmrow, _super);
    function CHTMLmrow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmrow.prototype.toCHTML = function (parent) {
        var e_1, _a;
        var chtml = (this.node.isInferred ? (this.chtml = parent) : this.standardCHTMLnode(parent));
        var hasNegative = false;
        try {
            for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                child.toCHTML(chtml);
                if (child.bbox.w < 0) {
                    hasNegative = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (hasNegative) {
            var w = this.getBBox().w;
            if (w) {
                this.adaptor.setStyle(chtml, 'width', this.em(Math.max(0, w)));
                if (w < 0) {
                    this.adaptor.setStyle(chtml, 'marginRight', this.em(w));
                }
            }
        }
    };
    CHTMLmrow.kind = mrow_js_3.MmlMrow.prototype.kind;
    return CHTMLmrow;
}((0, mrow_js_1.CommonMrowMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmrow = CHTMLmrow;
var CHTMLinferredMrow = (function (_super) {
    __extends(CHTMLinferredMrow, _super);
    function CHTMLinferredMrow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLinferredMrow.kind = mrow_js_3.MmlInferredMrow.prototype.kind;
    return CHTMLinferredMrow;
}((0, mrow_js_2.CommonInferredMrowMixin)(CHTMLmrow)));
exports.CHTMLinferredMrow = CHTMLinferredMrow;
//# sourceMappingURL=mrow.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/ms.js":
/*!******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/ms.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLms = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var ms_js_1 = __webpack_require__(/*! ../../common/Wrappers/ms.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/ms.js");
var ms_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/ms.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/ms.js");
var CHTMLms = (function (_super) {
    __extends(CHTMLms, _super);
    function CHTMLms() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLms.kind = ms_js_2.MmlMs.prototype.kind;
    return CHTMLms;
}((0, ms_js_1.CommonMsMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLms = CHTMLms;
//# sourceMappingURL=ms.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mspace.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mspace.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmspace = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mspace_js_1 = __webpack_require__(/*! ../../common/Wrappers/mspace.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mspace.js");
var mspace_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mspace.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mspace.js");
var CHTMLmspace = (function (_super) {
    __extends(CHTMLmspace, _super);
    function CHTMLmspace() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmspace.prototype.toCHTML = function (parent) {
        var chtml = this.standardCHTMLnode(parent);
        var _a = this.getBBox(), w = _a.w, h = _a.h, d = _a.d;
        if (w < 0) {
            this.adaptor.setStyle(chtml, 'marginRight', this.em(w));
            w = 0;
        }
        if (w) {
            this.adaptor.setStyle(chtml, 'width', this.em(w));
        }
        h = Math.max(0, h + d);
        if (h) {
            this.adaptor.setStyle(chtml, 'height', this.em(Math.max(0, h)));
        }
        if (d) {
            this.adaptor.setStyle(chtml, 'verticalAlign', this.em(-d));
        }
    };
    CHTMLmspace.kind = mspace_js_2.MmlMspace.prototype.kind;
    return CHTMLmspace;
}((0, mspace_js_1.CommonMspaceMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmspace = CHTMLmspace;
//# sourceMappingURL=mspace.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msqrt.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/msqrt.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmsqrt = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var msqrt_js_1 = __webpack_require__(/*! ../../common/Wrappers/msqrt.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/msqrt.js");
var msqrt_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/msqrt.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/msqrt.js");
var CHTMLmsqrt = (function (_super) {
    __extends(CHTMLmsqrt, _super);
    function CHTMLmsqrt() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmsqrt.prototype.toCHTML = function (parent) {
        var surd = this.childNodes[this.surd];
        var base = this.childNodes[this.base];
        var sbox = surd.getBBox();
        var bbox = base.getOuterBBox();
        var _a = __read(this.getPQ(sbox), 2), q = _a[1];
        var t = this.font.params.rule_thickness;
        var H = bbox.h + q + t;
        var CHTML = this.standardCHTMLnode(parent);
        var SURD, BASE, ROOT, root;
        if (this.root != null) {
            ROOT = this.adaptor.append(CHTML, this.html('mjx-root'));
            root = this.childNodes[this.root];
        }
        var SQRT = this.adaptor.append(CHTML, this.html('mjx-sqrt', {}, [
            SURD = this.html('mjx-surd'),
            BASE = this.html('mjx-box', { style: { paddingTop: this.em(q) } })
        ]));
        this.addRoot(ROOT, root, sbox, H);
        surd.toCHTML(SURD);
        base.toCHTML(BASE);
        if (surd.size < 0) {
            this.adaptor.addClass(SQRT, 'mjx-tall');
        }
    };
    CHTMLmsqrt.prototype.addRoot = function (_ROOT, _root, _sbox, _H) {
    };
    CHTMLmsqrt.kind = msqrt_js_2.MmlMsqrt.prototype.kind;
    CHTMLmsqrt.styles = {
        'mjx-root': {
            display: 'inline-block',
            'white-space': 'nowrap'
        },
        'mjx-surd': {
            display: 'inline-block',
            'vertical-align': 'top'
        },
        'mjx-sqrt': {
            display: 'inline-block',
            'padding-top': '.07em'
        },
        'mjx-sqrt > mjx-box': {
            'border-top': '.07em solid'
        },
        'mjx-sqrt.mjx-tall > mjx-box': {
            'padding-left': '.3em',
            'margin-left': '-.3em'
        }
    };
    return CHTMLmsqrt;
}((0, msqrt_js_1.CommonMsqrtMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmsqrt = CHTMLmsqrt;
//# sourceMappingURL=msqrt.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msubsup.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/msubsup.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmsubsup = exports.CHTMLmsup = exports.CHTMLmsub = void 0;
var scriptbase_js_1 = __webpack_require__(/*! ./scriptbase.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/scriptbase.js");
var msubsup_js_1 = __webpack_require__(/*! ../../common/Wrappers/msubsup.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/msubsup.js");
var msubsup_js_2 = __webpack_require__(/*! ../../common/Wrappers/msubsup.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/msubsup.js");
var msubsup_js_3 = __webpack_require__(/*! ../../common/Wrappers/msubsup.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/msubsup.js");
var msubsup_js_4 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/msubsup.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/msubsup.js");
var CHTMLmsub = (function (_super) {
    __extends(CHTMLmsub, _super);
    function CHTMLmsub() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmsub.kind = msubsup_js_4.MmlMsub.prototype.kind;
    return CHTMLmsub;
}((0, msubsup_js_1.CommonMsubMixin)(scriptbase_js_1.CHTMLscriptbase)));
exports.CHTMLmsub = CHTMLmsub;
var CHTMLmsup = (function (_super) {
    __extends(CHTMLmsup, _super);
    function CHTMLmsup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmsup.kind = msubsup_js_4.MmlMsup.prototype.kind;
    return CHTMLmsup;
}((0, msubsup_js_2.CommonMsupMixin)(scriptbase_js_1.CHTMLscriptbase)));
exports.CHTMLmsup = CHTMLmsup;
var CHTMLmsubsup = (function (_super) {
    __extends(CHTMLmsubsup, _super);
    function CHTMLmsubsup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmsubsup.prototype.toCHTML = function (parent) {
        var adaptor = this.adaptor;
        var chtml = this.standardCHTMLnode(parent);
        var _a = __read([this.baseChild, this.supChild, this.subChild], 3), base = _a[0], sup = _a[1], sub = _a[2];
        var _b = __read(this.getUVQ(), 3), v = _b[1], q = _b[2];
        var style = { 'vertical-align': this.em(v) };
        base.toCHTML(chtml);
        var stack = adaptor.append(chtml, this.html('mjx-script', { style: style }));
        sup.toCHTML(stack);
        adaptor.append(stack, this.html('mjx-spacer', { style: { 'margin-top': this.em(q) } }));
        sub.toCHTML(stack);
        var ic = this.getAdjustedIc();
        if (ic) {
            adaptor.setStyle(sup.chtml, 'marginLeft', this.em(ic / sup.bbox.rscale));
        }
        if (this.baseRemoveIc) {
            adaptor.setStyle(stack, 'marginLeft', this.em(-this.baseIc));
        }
    };
    CHTMLmsubsup.kind = msubsup_js_4.MmlMsubsup.prototype.kind;
    CHTMLmsubsup.styles = {
        'mjx-script': {
            display: 'inline-block',
            'padding-right': '.05em',
            'padding-left': '.033em'
        },
        'mjx-script > mjx-spacer': {
            display: 'block'
        }
    };
    return CHTMLmsubsup;
}((0, msubsup_js_3.CommonMsubsupMixin)(scriptbase_js_1.CHTMLscriptbase)));
exports.CHTMLmsubsup = CHTMLmsubsup;
//# sourceMappingURL=msubsup.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mtable.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmtable = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mtable_js_1 = __webpack_require__(/*! ../../common/Wrappers/mtable.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mtable.js");
var mtable_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mtable.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mtable.js");
var string_js_1 = __webpack_require__(/*! ../../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
var CHTMLmtable = (function (_super) {
    __extends(CHTMLmtable, _super);
    function CHTMLmtable(factory, node, parent) {
        if (parent === void 0) { parent = null; }
        var _this = _super.call(this, factory, node, parent) || this;
        _this.itable = _this.html('mjx-itable');
        _this.labels = _this.html('mjx-itable');
        return _this;
    }
    CHTMLmtable.prototype.getAlignShift = function () {
        var data = _super.prototype.getAlignShift.call(this);
        if (!this.isTop) {
            data[1] = 0;
        }
        return data;
    };
    CHTMLmtable.prototype.toCHTML = function (parent) {
        var e_1, _a;
        var chtml = this.standardCHTMLnode(parent);
        this.adaptor.append(chtml, this.html('mjx-table', {}, [this.itable]));
        try {
            for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                child.toCHTML(this.itable);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.padRows();
        this.handleColumnSpacing();
        this.handleColumnLines();
        this.handleColumnWidths();
        this.handleRowSpacing();
        this.handleRowLines();
        this.handleRowHeights();
        this.handleFrame();
        this.handleWidth();
        this.handleLabels();
        this.handleAlign();
        this.handleJustify();
        this.shiftColor();
    };
    CHTMLmtable.prototype.shiftColor = function () {
        var adaptor = this.adaptor;
        var color = adaptor.getStyle(this.chtml, 'backgroundColor');
        if (color) {
            adaptor.setStyle(this.chtml, 'backgroundColor', '');
            adaptor.setStyle(this.itable, 'backgroundColor', color);
        }
    };
    CHTMLmtable.prototype.padRows = function () {
        var e_2, _a;
        var adaptor = this.adaptor;
        try {
            for (var _b = __values(adaptor.childNodes(this.itable)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                while (adaptor.childNodes(row).length < this.numCols) {
                    adaptor.append(row, this.html('mjx-mtd', { 'extra': true }));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    CHTMLmtable.prototype.handleColumnSpacing = function () {
        var e_3, _a, e_4, _b;
        var scale = (this.childNodes[0] ? 1 / this.childNodes[0].getBBox().rscale : 1);
        var spacing = this.getEmHalfSpacing(this.fSpace[0], this.cSpace, scale);
        var frame = this.frame;
        try {
            for (var _c = __values(this.tableRows), _d = _c.next(); !_d.done; _d = _c.next()) {
                var row = _d.value;
                var i = 0;
                try {
                    for (var _e = (e_4 = void 0, __values(row.tableCells)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var cell = _f.value;
                        var lspace = spacing[i++];
                        var rspace = spacing[i];
                        var styleNode = (cell ? cell.chtml : this.adaptor.childNodes(row.chtml)[i]);
                        if ((i > 1 && lspace !== '0.4em') || (frame && i === 1)) {
                            this.adaptor.setStyle(styleNode, 'paddingLeft', lspace);
                        }
                        if ((i < this.numCols && rspace !== '0.4em') || (frame && i === this.numCols)) {
                            this.adaptor.setStyle(styleNode, 'paddingRight', rspace);
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    CHTMLmtable.prototype.handleColumnLines = function () {
        var e_5, _a, e_6, _b;
        if (this.node.attributes.get('columnlines') === 'none')
            return;
        var lines = this.getColumnAttributes('columnlines');
        try {
            for (var _c = __values(this.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var row = _d.value;
                var i = 0;
                try {
                    for (var _e = (e_6 = void 0, __values(this.adaptor.childNodes(row.chtml).slice(1))), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var cell = _f.value;
                        var line = lines[i++];
                        if (line === 'none')
                            continue;
                        this.adaptor.setStyle(cell, 'borderLeft', '.07em ' + line);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    CHTMLmtable.prototype.handleColumnWidths = function () {
        var e_7, _a, e_8, _b;
        try {
            for (var _c = __values(this.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var row = _d.value;
                var i = 0;
                try {
                    for (var _e = (e_8 = void 0, __values(this.adaptor.childNodes(row.chtml))), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var cell = _f.value;
                        var w = this.cWidths[i++];
                        if (w !== null) {
                            var width = (typeof w === 'number' ? this.em(w) : w);
                            this.adaptor.setStyle(cell, 'width', width);
                            this.adaptor.setStyle(cell, 'maxWidth', width);
                            this.adaptor.setStyle(cell, 'minWidth', width);
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    CHTMLmtable.prototype.handleRowSpacing = function () {
        var e_9, _a, e_10, _b;
        var scale = (this.childNodes[0] ? 1 / this.childNodes[0].getBBox().rscale : 1);
        var spacing = this.getEmHalfSpacing(this.fSpace[1], this.rSpace, scale);
        var frame = this.frame;
        var i = 0;
        try {
            for (var _c = __values(this.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var row = _d.value;
                var tspace = spacing[i++];
                var bspace = spacing[i];
                try {
                    for (var _e = (e_10 = void 0, __values(row.childNodes)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var cell = _f.value;
                        if ((i > 1 && tspace !== '0.215em') || (frame && i === 1)) {
                            this.adaptor.setStyle(cell.chtml, 'paddingTop', tspace);
                        }
                        if ((i < this.numRows && bspace !== '0.215em') || (frame && i === this.numRows)) {
                            this.adaptor.setStyle(cell.chtml, 'paddingBottom', bspace);
                        }
                    }
                }
                catch (e_10_1) { e_10 = { error: e_10_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_10) throw e_10.error; }
                }
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_9) throw e_9.error; }
        }
    };
    CHTMLmtable.prototype.handleRowLines = function () {
        var e_11, _a, e_12, _b;
        if (this.node.attributes.get('rowlines') === 'none')
            return;
        var lines = this.getRowAttributes('rowlines');
        var i = 0;
        try {
            for (var _c = __values(this.childNodes.slice(1)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var row = _d.value;
                var line = lines[i++];
                if (line === 'none')
                    continue;
                try {
                    for (var _e = (e_12 = void 0, __values(this.adaptor.childNodes(row.chtml))), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var cell = _f.value;
                        this.adaptor.setStyle(cell, 'borderTop', '.07em ' + line);
                    }
                }
                catch (e_12_1) { e_12 = { error: e_12_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_12) throw e_12.error; }
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_11) throw e_11.error; }
        }
    };
    CHTMLmtable.prototype.handleRowHeights = function () {
        if (this.node.attributes.get('equalrows')) {
            this.handleEqualRows();
        }
    };
    CHTMLmtable.prototype.handleEqualRows = function () {
        var space = this.getRowHalfSpacing();
        var _a = this.getTableData(), H = _a.H, D = _a.D, NH = _a.NH, ND = _a.ND;
        var HD = this.getEqualRowHeight();
        for (var i = 0; i < this.numRows; i++) {
            var row = this.childNodes[i];
            this.setRowHeight(row, HD + space[i] + space[i + 1] + this.rLines[i]);
            if (HD !== NH[i] + ND[i]) {
                this.setRowBaseline(row, HD, (HD - H[i] + D[i]) / 2);
            }
        }
    };
    CHTMLmtable.prototype.setRowHeight = function (row, HD) {
        this.adaptor.setStyle(row.chtml, 'height', this.em(HD));
    };
    CHTMLmtable.prototype.setRowBaseline = function (row, HD, D) {
        var e_13, _a;
        var ralign = row.node.attributes.get('rowalign');
        try {
            for (var _b = __values(row.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var cell = _c.value;
                if (this.setCellBaseline(cell, ralign, HD, D))
                    break;
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_13) throw e_13.error; }
        }
    };
    CHTMLmtable.prototype.setCellBaseline = function (cell, ralign, HD, D) {
        var calign = cell.node.attributes.get('rowalign');
        if (calign === 'baseline' || calign === 'axis') {
            var adaptor = this.adaptor;
            var child = adaptor.lastChild(cell.chtml);
            adaptor.setStyle(child, 'height', this.em(HD));
            adaptor.setStyle(child, 'verticalAlign', this.em(-D));
            var row = cell.parent;
            if ((!row.node.isKind('mlabeledtr') || cell !== row.childNodes[0]) &&
                (ralign === 'baseline' || ralign === 'axis')) {
                return true;
            }
        }
        return false;
    };
    CHTMLmtable.prototype.handleFrame = function () {
        if (this.frame && this.fLine) {
            this.adaptor.setStyle(this.itable, 'border', '.07em ' + this.node.attributes.get('frame'));
        }
    };
    CHTMLmtable.prototype.handleWidth = function () {
        var adaptor = this.adaptor;
        var _a = this.getBBox(), w = _a.w, L = _a.L, R = _a.R;
        adaptor.setStyle(this.chtml, 'minWidth', this.em(L + w + R));
        var W = this.node.attributes.get('width');
        if ((0, string_js_1.isPercent)(W)) {
            adaptor.setStyle(this.chtml, 'width', '');
            adaptor.setAttribute(this.chtml, 'width', 'full');
        }
        else if (!this.hasLabels) {
            if (W === 'auto')
                return;
            W = this.em(this.length2em(W) + 2 * this.fLine);
        }
        var table = adaptor.firstChild(this.chtml);
        adaptor.setStyle(table, 'width', W);
        adaptor.setStyle(table, 'minWidth', this.em(w));
        if (L || R) {
            adaptor.setStyle(this.chtml, 'margin', '');
            var style = (this.node.attributes.get('data-width-includes-label') ? 'padding' : 'margin');
            if (L === R) {
                adaptor.setStyle(table, style, '0 ' + this.em(R));
            }
            else {
                adaptor.setStyle(table, style, '0 ' + this.em(R) + ' 0 ' + this.em(L));
            }
        }
        adaptor.setAttribute(this.itable, 'width', 'full');
    };
    CHTMLmtable.prototype.handleAlign = function () {
        var _a = __read(this.getAlignmentRow(), 2), align = _a[0], row = _a[1];
        if (row === null) {
            if (align !== 'axis') {
                this.adaptor.setAttribute(this.chtml, 'align', align);
            }
        }
        else {
            var y = this.getVerticalPosition(row, align);
            this.adaptor.setAttribute(this.chtml, 'align', 'top');
            this.adaptor.setStyle(this.chtml, 'verticalAlign', this.em(y));
        }
    };
    CHTMLmtable.prototype.handleJustify = function () {
        var align = this.getAlignShift()[0];
        if (align !== 'center') {
            this.adaptor.setAttribute(this.chtml, 'justify', align);
        }
    };
    CHTMLmtable.prototype.handleLabels = function () {
        if (!this.hasLabels)
            return;
        var labels = this.labels;
        var attributes = this.node.attributes;
        var adaptor = this.adaptor;
        var side = attributes.get('side');
        adaptor.setAttribute(this.chtml, 'side', side);
        adaptor.setAttribute(labels, 'align', side);
        adaptor.setStyle(labels, side, '0');
        var _a = __read(this.addLabelPadding(side), 2), align = _a[0], shift = _a[1];
        if (shift) {
            var table = adaptor.firstChild(this.chtml);
            this.setIndent(table, align, shift);
        }
        this.updateRowHeights();
        this.addLabelSpacing();
    };
    CHTMLmtable.prototype.addLabelPadding = function (side) {
        var _a = __read(this.getPadAlignShift(side), 3), align = _a[1], shift = _a[2];
        var styles = {};
        if (side === 'right' && !this.node.attributes.get('data-width-includes-label')) {
            var W = this.node.attributes.get('width');
            var _b = this.getBBox(), w = _b.w, L = _b.L, R = _b.R;
            styles.style = {
                width: ((0, string_js_1.isPercent)(W) ? 'calc(' + W + ' + ' + this.em(L + R) + ')' : this.em(L + w + R))
            };
        }
        this.adaptor.append(this.chtml, this.html('mjx-labels', styles, [this.labels]));
        return [align, shift];
    };
    CHTMLmtable.prototype.updateRowHeights = function () {
        var _a = this.getTableData(), H = _a.H, D = _a.D, NH = _a.NH, ND = _a.ND;
        var space = this.getRowHalfSpacing();
        for (var i = 0; i < this.numRows; i++) {
            var row = this.childNodes[i];
            this.setRowHeight(row, H[i] + D[i] + space[i] + space[i + 1] + this.rLines[i]);
            if (H[i] !== NH[i] || D[i] !== ND[i]) {
                this.setRowBaseline(row, H[i] + D[i], D[i]);
            }
            else if (row.node.isKind('mlabeledtr')) {
                this.setCellBaseline(row.childNodes[0], '', H[i] + D[i], D[i]);
            }
        }
    };
    CHTMLmtable.prototype.addLabelSpacing = function () {
        var adaptor = this.adaptor;
        var equal = this.node.attributes.get('equalrows');
        var _a = this.getTableData(), H = _a.H, D = _a.D;
        var HD = (equal ? this.getEqualRowHeight() : 0);
        var space = this.getRowHalfSpacing();
        var h = this.fLine;
        var current = adaptor.firstChild(this.labels);
        for (var i = 0; i < this.numRows; i++) {
            var row = this.childNodes[i];
            if (row.node.isKind('mlabeledtr')) {
                h && adaptor.insert(this.html('mjx-mtr', { style: { height: this.em(h) } }), current);
                adaptor.setStyle(current, 'height', this.em((equal ? HD : H[i] + D[i]) + space[i] + space[i + 1]));
                current = adaptor.next(current);
                h = this.rLines[i];
            }
            else {
                h += space[i] + (equal ? HD : H[i] + D[i]) + space[i + 1] + this.rLines[i];
            }
        }
    };
    CHTMLmtable.kind = mtable_js_2.MmlMtable.prototype.kind;
    CHTMLmtable.styles = {
        'mjx-mtable': {
            'vertical-align': '.25em',
            'text-align': 'center',
            'position': 'relative',
            'box-sizing': 'border-box',
            'border-spacing': 0,
            'border-collapse': 'collapse'
        },
        'mjx-mstyle[size="s"] mjx-mtable': {
            'vertical-align': '.354em'
        },
        'mjx-labels': {
            position: 'absolute',
            left: 0,
            top: 0
        },
        'mjx-table': {
            'display': 'inline-block',
            'vertical-align': '-.5ex',
            'box-sizing': 'border-box'
        },
        'mjx-table > mjx-itable': {
            'vertical-align': 'middle',
            'text-align': 'left',
            'box-sizing': 'border-box'
        },
        'mjx-labels > mjx-itable': {
            position: 'absolute',
            top: 0
        },
        'mjx-mtable[justify="left"]': {
            'text-align': 'left'
        },
        'mjx-mtable[justify="right"]': {
            'text-align': 'right'
        },
        'mjx-mtable[justify="left"][side="left"]': {
            'padding-right': '0 ! important'
        },
        'mjx-mtable[justify="left"][side="right"]': {
            'padding-left': '0 ! important'
        },
        'mjx-mtable[justify="right"][side="left"]': {
            'padding-right': '0 ! important'
        },
        'mjx-mtable[justify="right"][side="right"]': {
            'padding-left': '0 ! important'
        },
        'mjx-mtable[align]': {
            'vertical-align': 'baseline'
        },
        'mjx-mtable[align="top"] > mjx-table': {
            'vertical-align': 'top'
        },
        'mjx-mtable[align="bottom"] > mjx-table': {
            'vertical-align': 'bottom'
        },
        'mjx-mtable[side="right"] mjx-labels': {
            'min-width': '100%'
        }
    };
    return CHTMLmtable;
}((0, mtable_js_1.CommonMtableMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmtable = CHTMLmtable;
//# sourceMappingURL=mtable.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtd.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mtd.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmtd = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mtd_js_1 = __webpack_require__(/*! ../../common/Wrappers/mtd.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mtd.js");
var mtd_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mtd.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mtd.js");
var CHTMLmtd = (function (_super) {
    __extends(CHTMLmtd, _super);
    function CHTMLmtd() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmtd.prototype.toCHTML = function (parent) {
        _super.prototype.toCHTML.call(this, parent);
        var ralign = this.node.attributes.get('rowalign');
        var calign = this.node.attributes.get('columnalign');
        var palign = this.parent.node.attributes.get('rowalign');
        if (ralign !== palign) {
            this.adaptor.setAttribute(this.chtml, 'rowalign', ralign);
        }
        if (calign !== 'center' &&
            (this.parent.kind !== 'mlabeledtr' || this !== this.parent.childNodes[0] ||
                calign !== this.parent.parent.node.attributes.get('side'))) {
            this.adaptor.setStyle(this.chtml, 'textAlign', calign);
        }
        if (this.parent.parent.node.getProperty('useHeight')) {
            this.adaptor.append(this.chtml, this.html('mjx-tstrut'));
        }
    };
    CHTMLmtd.kind = mtd_js_2.MmlMtd.prototype.kind;
    CHTMLmtd.styles = {
        'mjx-mtd': {
            display: 'table-cell',
            'text-align': 'center',
            'padding': '.215em .4em'
        },
        'mjx-mtd:first-child': {
            'padding-left': 0
        },
        'mjx-mtd:last-child': {
            'padding-right': 0
        },
        'mjx-mtable > * > mjx-itable > *:first-child > mjx-mtd': {
            'padding-top': 0
        },
        'mjx-mtable > * > mjx-itable > *:last-child > mjx-mtd': {
            'padding-bottom': 0
        },
        'mjx-tstrut': {
            display: 'inline-block',
            height: '1em',
            'vertical-align': '-.25em'
        },
        'mjx-labels[align="left"] > mjx-mtr > mjx-mtd': {
            'text-align': 'left'
        },
        'mjx-labels[align="right"] > mjx-mtr > mjx-mtd': {
            'text-align': 'right'
        },
        'mjx-mtd[extra]': {
            padding: 0
        },
        'mjx-mtd[rowalign="top"]': {
            'vertical-align': 'top'
        },
        'mjx-mtd[rowalign="center"]': {
            'vertical-align': 'middle'
        },
        'mjx-mtd[rowalign="bottom"]': {
            'vertical-align': 'bottom'
        },
        'mjx-mtd[rowalign="baseline"]': {
            'vertical-align': 'baseline'
        },
        'mjx-mtd[rowalign="axis"]': {
            'vertical-align': '.25em'
        }
    };
    return CHTMLmtd;
}((0, mtd_js_1.CommonMtdMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmtd = CHTMLmtd;
//# sourceMappingURL=mtd.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtext.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mtext.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmtext = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mtext_js_1 = __webpack_require__(/*! ../../common/Wrappers/mtext.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mtext.js");
var mtext_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mtext.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mtext.js");
var CHTMLmtext = (function (_super) {
    __extends(CHTMLmtext, _super);
    function CHTMLmtext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmtext.kind = mtext_js_2.MmlMtext.prototype.kind;
    return CHTMLmtext;
}((0, mtext_js_1.CommonMtextMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmtext = CHTMLmtext;
//# sourceMappingURL=mtext.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/mtr.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/mtr.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmlabeledtr = exports.CHTMLmtr = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var mtr_js_1 = __webpack_require__(/*! ../../common/Wrappers/mtr.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mtr.js");
var mtr_js_2 = __webpack_require__(/*! ../../common/Wrappers/mtr.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/mtr.js");
var mtr_js_3 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/mtr.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mtr.js");
var CHTMLmtr = (function (_super) {
    __extends(CHTMLmtr, _super);
    function CHTMLmtr() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmtr.prototype.toCHTML = function (parent) {
        _super.prototype.toCHTML.call(this, parent);
        var align = this.node.attributes.get('rowalign');
        if (align !== 'baseline') {
            this.adaptor.setAttribute(this.chtml, 'rowalign', align);
        }
    };
    CHTMLmtr.kind = mtr_js_3.MmlMtr.prototype.kind;
    CHTMLmtr.styles = {
        'mjx-mtr': {
            display: 'table-row',
        },
        'mjx-mtr[rowalign="top"] > mjx-mtd': {
            'vertical-align': 'top'
        },
        'mjx-mtr[rowalign="center"] > mjx-mtd': {
            'vertical-align': 'middle'
        },
        'mjx-mtr[rowalign="bottom"] > mjx-mtd': {
            'vertical-align': 'bottom'
        },
        'mjx-mtr[rowalign="baseline"] > mjx-mtd': {
            'vertical-align': 'baseline'
        },
        'mjx-mtr[rowalign="axis"] > mjx-mtd': {
            'vertical-align': '.25em'
        }
    };
    return CHTMLmtr;
}((0, mtr_js_1.CommonMtrMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLmtr = CHTMLmtr;
var CHTMLmlabeledtr = (function (_super) {
    __extends(CHTMLmlabeledtr, _super);
    function CHTMLmlabeledtr() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmlabeledtr.prototype.toCHTML = function (parent) {
        _super.prototype.toCHTML.call(this, parent);
        var child = this.adaptor.firstChild(this.chtml);
        if (child) {
            this.adaptor.remove(child);
            var align = this.node.attributes.get('rowalign');
            var attr = (align !== 'baseline' && align !== 'axis' ? { rowalign: align } : {});
            var row = this.html('mjx-mtr', attr, [child]);
            this.adaptor.append(this.parent.labels, row);
        }
    };
    CHTMLmlabeledtr.prototype.markUsed = function () {
        _super.prototype.markUsed.call(this);
        this.jax.wrapperUsage.add(CHTMLmtr.kind);
    };
    CHTMLmlabeledtr.kind = mtr_js_3.MmlMlabeledtr.prototype.kind;
    CHTMLmlabeledtr.styles = {
        'mjx-mlabeledtr': {
            display: 'table-row'
        },
        'mjx-mlabeledtr[rowalign="top"] > mjx-mtd': {
            'vertical-align': 'top'
        },
        'mjx-mlabeledtr[rowalign="center"] > mjx-mtd': {
            'vertical-align': 'middle'
        },
        'mjx-mlabeledtr[rowalign="bottom"] > mjx-mtd': {
            'vertical-align': 'bottom'
        },
        'mjx-mlabeledtr[rowalign="baseline"] > mjx-mtd': {
            'vertical-align': 'baseline'
        },
        'mjx-mlabeledtr[rowalign="axis"] > mjx-mtd': {
            'vertical-align': '.25em'
        }
    };
    return CHTMLmlabeledtr;
}((0, mtr_js_2.CommonMlabeledtrMixin)(CHTMLmtr)));
exports.CHTMLmlabeledtr = CHTMLmlabeledtr;
//# sourceMappingURL=mtr.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/munderover.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/munderover.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLmunderover = exports.CHTMLmover = exports.CHTMLmunder = void 0;
var msubsup_js_1 = __webpack_require__(/*! ./msubsup.js */ "./node_modules/mathjax-full/js/output/chtml/Wrappers/msubsup.js");
var munderover_js_1 = __webpack_require__(/*! ../../common/Wrappers/munderover.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/munderover.js");
var munderover_js_2 = __webpack_require__(/*! ../../common/Wrappers/munderover.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/munderover.js");
var munderover_js_3 = __webpack_require__(/*! ../../common/Wrappers/munderover.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/munderover.js");
var munderover_js_4 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/munderover.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/munderover.js");
var CHTMLmunder = (function (_super) {
    __extends(CHTMLmunder, _super);
    function CHTMLmunder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmunder.prototype.toCHTML = function (parent) {
        if (this.hasMovableLimits()) {
            _super.prototype.toCHTML.call(this, parent);
            this.adaptor.setAttribute(this.chtml, 'limits', 'false');
            return;
        }
        this.chtml = this.standardCHTMLnode(parent);
        var base = this.adaptor.append(this.adaptor.append(this.chtml, this.html('mjx-row')), this.html('mjx-base'));
        var under = this.adaptor.append(this.adaptor.append(this.chtml, this.html('mjx-row')), this.html('mjx-under'));
        this.baseChild.toCHTML(base);
        this.scriptChild.toCHTML(under);
        var basebox = this.baseChild.getOuterBBox();
        var underbox = this.scriptChild.getOuterBBox();
        var k = this.getUnderKV(basebox, underbox)[0];
        var delta = (this.isLineBelow ? 0 : this.getDelta(true));
        this.adaptor.setStyle(under, 'paddingTop', this.em(k));
        this.setDeltaW([base, under], this.getDeltaW([basebox, underbox], [0, -delta]));
        this.adjustUnderDepth(under, underbox);
    };
    CHTMLmunder.kind = munderover_js_4.MmlMunder.prototype.kind;
    CHTMLmunder.styles = {
        'mjx-over': {
            'text-align': 'left'
        },
        'mjx-munder:not([limits="false"])': {
            display: 'inline-table',
        },
        'mjx-munder > mjx-row': {
            'text-align': 'left'
        },
        'mjx-under': {
            'padding-bottom': '.1em'
        }
    };
    return CHTMLmunder;
}((0, munderover_js_1.CommonMunderMixin)(msubsup_js_1.CHTMLmsub)));
exports.CHTMLmunder = CHTMLmunder;
var CHTMLmover = (function (_super) {
    __extends(CHTMLmover, _super);
    function CHTMLmover() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmover.prototype.toCHTML = function (parent) {
        if (this.hasMovableLimits()) {
            _super.prototype.toCHTML.call(this, parent);
            this.adaptor.setAttribute(this.chtml, 'limits', 'false');
            return;
        }
        this.chtml = this.standardCHTMLnode(parent);
        var over = this.adaptor.append(this.chtml, this.html('mjx-over'));
        var base = this.adaptor.append(this.chtml, this.html('mjx-base'));
        this.scriptChild.toCHTML(over);
        this.baseChild.toCHTML(base);
        var overbox = this.scriptChild.getOuterBBox();
        var basebox = this.baseChild.getOuterBBox();
        this.adjustBaseHeight(base, basebox);
        var k = this.getOverKU(basebox, overbox)[0];
        var delta = (this.isLineAbove ? 0 : this.getDelta());
        this.adaptor.setStyle(over, 'paddingBottom', this.em(k));
        this.setDeltaW([base, over], this.getDeltaW([basebox, overbox], [0, delta]));
        this.adjustOverDepth(over, overbox);
    };
    CHTMLmover.kind = munderover_js_4.MmlMover.prototype.kind;
    CHTMLmover.styles = {
        'mjx-mover:not([limits="false"])': {
            'padding-top': '.1em'
        },
        'mjx-mover:not([limits="false"]) > *': {
            display: 'block',
            'text-align': 'left'
        }
    };
    return CHTMLmover;
}((0, munderover_js_2.CommonMoverMixin)(msubsup_js_1.CHTMLmsup)));
exports.CHTMLmover = CHTMLmover;
var CHTMLmunderover = (function (_super) {
    __extends(CHTMLmunderover, _super);
    function CHTMLmunderover() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLmunderover.prototype.toCHTML = function (parent) {
        if (this.hasMovableLimits()) {
            _super.prototype.toCHTML.call(this, parent);
            this.adaptor.setAttribute(this.chtml, 'limits', 'false');
            return;
        }
        this.chtml = this.standardCHTMLnode(parent);
        var over = this.adaptor.append(this.chtml, this.html('mjx-over'));
        var table = this.adaptor.append(this.adaptor.append(this.chtml, this.html('mjx-box')), this.html('mjx-munder'));
        var base = this.adaptor.append(this.adaptor.append(table, this.html('mjx-row')), this.html('mjx-base'));
        var under = this.adaptor.append(this.adaptor.append(table, this.html('mjx-row')), this.html('mjx-under'));
        this.overChild.toCHTML(over);
        this.baseChild.toCHTML(base);
        this.underChild.toCHTML(under);
        var overbox = this.overChild.getOuterBBox();
        var basebox = this.baseChild.getOuterBBox();
        var underbox = this.underChild.getOuterBBox();
        this.adjustBaseHeight(base, basebox);
        var ok = this.getOverKU(basebox, overbox)[0];
        var uk = this.getUnderKV(basebox, underbox)[0];
        var delta = this.getDelta();
        this.adaptor.setStyle(over, 'paddingBottom', this.em(ok));
        this.adaptor.setStyle(under, 'paddingTop', this.em(uk));
        this.setDeltaW([base, under, over], this.getDeltaW([basebox, underbox, overbox], [0, this.isLineBelow ? 0 : -delta, this.isLineAbove ? 0 : delta]));
        this.adjustOverDepth(over, overbox);
        this.adjustUnderDepth(under, underbox);
    };
    CHTMLmunderover.prototype.markUsed = function () {
        _super.prototype.markUsed.call(this);
        this.jax.wrapperUsage.add(msubsup_js_1.CHTMLmsubsup.kind);
    };
    CHTMLmunderover.kind = munderover_js_4.MmlMunderover.prototype.kind;
    CHTMLmunderover.styles = {
        'mjx-munderover:not([limits="false"])': {
            'padding-top': '.1em'
        },
        'mjx-munderover:not([limits="false"]) > *': {
            display: 'block'
        },
    };
    return CHTMLmunderover;
}((0, munderover_js_3.CommonMunderoverMixin)(msubsup_js_1.CHTMLmsubsup)));
exports.CHTMLmunderover = CHTMLmunderover;
//# sourceMappingURL=munderover.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/scriptbase.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/scriptbase.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLscriptbase = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var scriptbase_js_1 = __webpack_require__(/*! ../../common/Wrappers/scriptbase.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/scriptbase.js");
var CHTMLscriptbase = (function (_super) {
    __extends(CHTMLscriptbase, _super);
    function CHTMLscriptbase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLscriptbase.prototype.toCHTML = function (parent) {
        this.chtml = this.standardCHTMLnode(parent);
        var _a = __read(this.getOffset(), 2), x = _a[0], v = _a[1];
        var dx = x - (this.baseRemoveIc ? this.baseIc : 0);
        var style = { 'vertical-align': this.em(v) };
        if (dx) {
            style['margin-left'] = this.em(dx);
        }
        this.baseChild.toCHTML(this.chtml);
        this.scriptChild.toCHTML(this.adaptor.append(this.chtml, this.html('mjx-script', { style: style })));
    };
    CHTMLscriptbase.prototype.setDeltaW = function (nodes, dx) {
        for (var i = 0; i < dx.length; i++) {
            if (dx[i]) {
                this.adaptor.setStyle(nodes[i], 'paddingLeft', this.em(dx[i]));
            }
        }
    };
    CHTMLscriptbase.prototype.adjustOverDepth = function (over, overbox) {
        if (overbox.d >= 0)
            return;
        this.adaptor.setStyle(over, 'marginBottom', this.em(overbox.d * overbox.rscale));
    };
    CHTMLscriptbase.prototype.adjustUnderDepth = function (under, underbox) {
        var e_1, _a;
        if (underbox.d >= 0)
            return;
        var adaptor = this.adaptor;
        var v = this.em(underbox.d);
        var box = this.html('mjx-box', { style: { 'margin-bottom': v, 'vertical-align': v } });
        try {
            for (var _b = __values(adaptor.childNodes(adaptor.firstChild(under))), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                adaptor.append(box, child);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        adaptor.append(adaptor.firstChild(under), box);
    };
    CHTMLscriptbase.prototype.adjustBaseHeight = function (base, basebox) {
        if (this.node.attributes.get('accent')) {
            var minH = this.font.params.x_height * basebox.scale;
            if (basebox.h < minH) {
                this.adaptor.setStyle(base, 'paddingTop', this.em(minH - basebox.h));
                basebox.h = minH;
            }
        }
    };
    CHTMLscriptbase.kind = 'scriptbase';
    return CHTMLscriptbase;
}((0, scriptbase_js_1.CommonScriptbaseMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLscriptbase = CHTMLscriptbase;
//# sourceMappingURL=scriptbase.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/chtml/Wrappers/semantics.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/chtml/Wrappers/semantics.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CHTMLxml = exports.CHTMLannotationXML = exports.CHTMLannotation = exports.CHTMLsemantics = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../Wrapper.js */ "./node_modules/mathjax-full/js/output/chtml/Wrapper.js");
var semantics_js_1 = __webpack_require__(/*! ../../common/Wrappers/semantics.js */ "./node_modules/mathjax-full/js/output/common/Wrappers/semantics.js");
var semantics_js_2 = __webpack_require__(/*! ../../../core/MmlTree/MmlNodes/semantics.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/semantics.js");
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var CHTMLsemantics = (function (_super) {
    __extends(CHTMLsemantics, _super);
    function CHTMLsemantics() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLsemantics.prototype.toCHTML = function (parent) {
        var chtml = this.standardCHTMLnode(parent);
        if (this.childNodes.length) {
            this.childNodes[0].toCHTML(chtml);
        }
    };
    CHTMLsemantics.kind = semantics_js_2.MmlSemantics.prototype.kind;
    return CHTMLsemantics;
}((0, semantics_js_1.CommonSemanticsMixin)(Wrapper_js_1.CHTMLWrapper)));
exports.CHTMLsemantics = CHTMLsemantics;
var CHTMLannotation = (function (_super) {
    __extends(CHTMLannotation, _super);
    function CHTMLannotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLannotation.prototype.toCHTML = function (parent) {
        _super.prototype.toCHTML.call(this, parent);
    };
    CHTMLannotation.prototype.computeBBox = function () {
        return this.bbox;
    };
    CHTMLannotation.kind = semantics_js_2.MmlAnnotation.prototype.kind;
    return CHTMLannotation;
}(Wrapper_js_1.CHTMLWrapper));
exports.CHTMLannotation = CHTMLannotation;
var CHTMLannotationXML = (function (_super) {
    __extends(CHTMLannotationXML, _super);
    function CHTMLannotationXML() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLannotationXML.kind = semantics_js_2.MmlAnnotationXML.prototype.kind;
    CHTMLannotationXML.styles = {
        'mjx-annotation-xml': {
            'font-family': 'initial',
            'line-height': 'normal'
        }
    };
    return CHTMLannotationXML;
}(Wrapper_js_1.CHTMLWrapper));
exports.CHTMLannotationXML = CHTMLannotationXML;
var CHTMLxml = (function (_super) {
    __extends(CHTMLxml, _super);
    function CHTMLxml() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CHTMLxml.prototype.toCHTML = function (parent) {
        this.chtml = this.adaptor.append(parent, this.adaptor.clone(this.node.getXML()));
    };
    CHTMLxml.prototype.computeBBox = function (bbox, _recompute) {
        if (_recompute === void 0) { _recompute = false; }
        var _a = this.jax.measureXMLnode(this.node.getXML()), w = _a.w, h = _a.h, d = _a.d;
        bbox.w = w;
        bbox.h = h;
        bbox.d = d;
    };
    CHTMLxml.prototype.getStyles = function () { };
    CHTMLxml.prototype.getScale = function () { };
    CHTMLxml.prototype.getVariant = function () { };
    CHTMLxml.kind = MmlNode_js_1.XMLNode.prototype.kind;
    CHTMLxml.autoStyle = false;
    return CHTMLxml;
}(Wrapper_js_1.CHTMLWrapper));
exports.CHTMLxml = CHTMLxml;
//# sourceMappingURL=semantics.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Notation.js":
/*!****************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Notation.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonArrow = exports.CommonDiagonalArrow = exports.CommonDiagonalStrike = exports.CommonBorder2 = exports.CommonBorder = exports.arrowBBox = exports.diagonalArrowDef = exports.arrowDef = exports.arrowBBoxW = exports.arrowBBoxHD = exports.arrowHead = exports.fullBorder = exports.fullPadding = exports.fullBBox = exports.sideNames = exports.sideIndex = exports.SOLID = exports.PADDING = exports.THICKNESS = exports.ARROWY = exports.ARROWDX = exports.ARROWX = void 0;
exports.ARROWX = 4, exports.ARROWDX = 1, exports.ARROWY = 2;
exports.THICKNESS = .067;
exports.PADDING = .2;
exports.SOLID = exports.THICKNESS + 'em solid';
exports.sideIndex = { top: 0, right: 1, bottom: 2, left: 3 };
exports.sideNames = Object.keys(exports.sideIndex);
exports.fullBBox = (function (node) { return new Array(4).fill(node.thickness + node.padding); });
exports.fullPadding = (function (node) { return new Array(4).fill(node.padding); });
exports.fullBorder = (function (node) { return new Array(4).fill(node.thickness); });
var arrowHead = function (node) {
    return Math.max(node.padding, node.thickness * (node.arrowhead.x + node.arrowhead.dx + 1));
};
exports.arrowHead = arrowHead;
var arrowBBoxHD = function (node, TRBL) {
    if (node.childNodes[0]) {
        var _a = node.childNodes[0].getBBox(), h = _a.h, d = _a.d;
        TRBL[0] = TRBL[2] = Math.max(0, node.thickness * node.arrowhead.y - (h + d) / 2);
    }
    return TRBL;
};
exports.arrowBBoxHD = arrowBBoxHD;
var arrowBBoxW = function (node, TRBL) {
    if (node.childNodes[0]) {
        var w = node.childNodes[0].getBBox().w;
        TRBL[1] = TRBL[3] = Math.max(0, node.thickness * node.arrowhead.y - w / 2);
    }
    return TRBL;
};
exports.arrowBBoxW = arrowBBoxW;
exports.arrowDef = {
    up: [-Math.PI / 2, false, true, 'verticalstrike'],
    down: [Math.PI / 2, false, true, 'verticakstrike'],
    right: [0, false, false, 'horizontalstrike'],
    left: [Math.PI, false, false, 'horizontalstrike'],
    updown: [Math.PI / 2, true, true, 'verticalstrike uparrow downarrow'],
    leftright: [0, true, false, 'horizontalstrike leftarrow rightarrow']
};
exports.diagonalArrowDef = {
    updiagonal: [-1, 0, false, 'updiagonalstrike northeastarrow'],
    northeast: [-1, 0, false, 'updiagonalstrike updiagonalarrow'],
    southeast: [1, 0, false, 'downdiagonalstrike'],
    northwest: [1, Math.PI, false, 'downdiagonalstrike'],
    southwest: [-1, Math.PI, false, 'updiagonalstrike'],
    northeastsouthwest: [-1, 0, true, 'updiagonalstrike northeastarrow updiagonalarrow southwestarrow'],
    northwestsoutheast: [1, 0, true, 'downdiagonalstrike northwestarrow southeastarrow']
};
exports.arrowBBox = {
    up: function (node) { return (0, exports.arrowBBoxW)(node, [(0, exports.arrowHead)(node), 0, node.padding, 0]); },
    down: function (node) { return (0, exports.arrowBBoxW)(node, [node.padding, 0, (0, exports.arrowHead)(node), 0]); },
    right: function (node) { return (0, exports.arrowBBoxHD)(node, [0, (0, exports.arrowHead)(node), 0, node.padding]); },
    left: function (node) { return (0, exports.arrowBBoxHD)(node, [0, node.padding, 0, (0, exports.arrowHead)(node)]); },
    updown: function (node) { return (0, exports.arrowBBoxW)(node, [(0, exports.arrowHead)(node), 0, (0, exports.arrowHead)(node), 0]); },
    leftright: function (node) { return (0, exports.arrowBBoxHD)(node, [0, (0, exports.arrowHead)(node), 0, (0, exports.arrowHead)(node)]); }
};
var CommonBorder = function (render) {
    return function (side) {
        var i = exports.sideIndex[side];
        return [side, {
                renderer: render,
                bbox: function (node) {
                    var bbox = [0, 0, 0, 0];
                    bbox[i] = node.thickness + node.padding;
                    return bbox;
                },
                border: function (node) {
                    var bbox = [0, 0, 0, 0];
                    bbox[i] = node.thickness;
                    return bbox;
                }
            }];
    };
};
exports.CommonBorder = CommonBorder;
var CommonBorder2 = function (render) {
    return function (name, side1, side2) {
        var i1 = exports.sideIndex[side1];
        var i2 = exports.sideIndex[side2];
        return [name, {
                renderer: render,
                bbox: function (node) {
                    var t = node.thickness + node.padding;
                    var bbox = [0, 0, 0, 0];
                    bbox[i1] = bbox[i2] = t;
                    return bbox;
                },
                border: function (node) {
                    var bbox = [0, 0, 0, 0];
                    bbox[i1] = bbox[i2] = node.thickness;
                    return bbox;
                },
                remove: side1 + ' ' + side2
            }];
    };
};
exports.CommonBorder2 = CommonBorder2;
var CommonDiagonalStrike = function (render) {
    return function (name) {
        var cname = 'mjx-' + name.charAt(0) + 'strike';
        return [name + 'diagonalstrike', {
                renderer: render(cname),
                bbox: exports.fullBBox
            }];
    };
};
exports.CommonDiagonalStrike = CommonDiagonalStrike;
var CommonDiagonalArrow = function (render) {
    return function (name) {
        var _a = __read(exports.diagonalArrowDef[name], 4), c = _a[0], pi = _a[1], double = _a[2], remove = _a[3];
        return [name + 'arrow', {
                renderer: function (node, _child) {
                    var _a = __read(node.arrowAW(), 2), a = _a[0], W = _a[1];
                    var arrow = node.arrow(W, c * (a - pi), double);
                    render(node, arrow);
                },
                bbox: function (node) {
                    var _a = node.arrowData(), a = _a.a, x = _a.x, y = _a.y;
                    var _b = __read([node.arrowhead.x, node.arrowhead.y, node.arrowhead.dx], 3), ax = _b[0], ay = _b[1], adx = _b[2];
                    var _c = __read(node.getArgMod(ax + adx, ay), 2), b = _c[0], ar = _c[1];
                    var dy = y + (b > a ? node.thickness * ar * Math.sin(b - a) : 0);
                    var dx = x + (b > Math.PI / 2 - a ? node.thickness * ar * Math.sin(b + a - Math.PI / 2) : 0);
                    return [dy, dx, dy, dx];
                },
                remove: remove
            }];
    };
};
exports.CommonDiagonalArrow = CommonDiagonalArrow;
var CommonArrow = function (render) {
    return function (name) {
        var _a = __read(exports.arrowDef[name], 4), angle = _a[0], double = _a[1], isVertical = _a[2], remove = _a[3];
        return [name + 'arrow', {
                renderer: function (node, _child) {
                    var _a = node.getBBox(), w = _a.w, h = _a.h, d = _a.d;
                    var _b = __read((isVertical ? [h + d, 'X'] : [w, 'Y']), 2), W = _b[0], offset = _b[1];
                    var dd = node.getOffset(offset);
                    var arrow = node.arrow(W, angle, double, offset, dd);
                    render(node, arrow);
                },
                bbox: exports.arrowBBox[name],
                remove: remove
            }];
    };
};
exports.CommonArrow = CommonArrow;
//# sourceMappingURL=Notation.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/OutputJax.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/OutputJax.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonOutputJax = void 0;
var OutputJax_js_1 = __webpack_require__(/*! ../../core/OutputJax.js */ "./node_modules/mathjax-full/js/core/OutputJax.js");
var MathItem_js_1 = __webpack_require__(/*! ../../core/MathItem.js */ "./node_modules/mathjax-full/js/core/MathItem.js");
var Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var lengths_js_1 = __webpack_require__(/*! ../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
var Styles_js_1 = __webpack_require__(/*! ../../util/Styles.js */ "./node_modules/mathjax-full/js/util/Styles.js");
var StyleList_js_1 = __webpack_require__(/*! ../../util/StyleList.js */ "./node_modules/mathjax-full/js/util/StyleList.js");
var CommonOutputJax = (function (_super) {
    __extends(CommonOutputJax, _super);
    function CommonOutputJax(options, defaultFactory, defaultFont) {
        if (options === void 0) { options = null; }
        if (defaultFactory === void 0) { defaultFactory = null; }
        if (defaultFont === void 0) { defaultFont = null; }
        var _this = this;
        var _a = __read((0, Options_js_1.separateOptions)(options, defaultFont.OPTIONS), 2), jaxOptions = _a[0], fontOptions = _a[1];
        _this = _super.call(this, jaxOptions) || this;
        _this.factory = _this.options.wrapperFactory ||
            new defaultFactory();
        _this.factory.jax = _this;
        _this.cssStyles = _this.options.cssStyles || new StyleList_js_1.CssStyles();
        _this.font = _this.options.font || new defaultFont(fontOptions);
        _this.unknownCache = new Map();
        return _this;
    }
    CommonOutputJax.prototype.typeset = function (math, html) {
        this.setDocument(html);
        var node = this.createNode();
        this.toDOM(math, node, html);
        return node;
    };
    CommonOutputJax.prototype.createNode = function () {
        var jax = this.constructor.NAME;
        return this.html('mjx-container', { 'class': 'MathJax', jax: jax });
    };
    CommonOutputJax.prototype.setScale = function (node) {
        var scale = this.math.metrics.scale * this.options.scale;
        if (scale !== 1) {
            this.adaptor.setStyle(node, 'fontSize', (0, lengths_js_1.percent)(scale));
        }
    };
    CommonOutputJax.prototype.toDOM = function (math, node, html) {
        if (html === void 0) { html = null; }
        this.setDocument(html);
        this.math = math;
        this.pxPerEm = math.metrics.ex / this.font.params.x_height;
        math.root.setTeXclass(null);
        this.setScale(node);
        this.nodeMap = new Map();
        this.container = node;
        this.processMath(math.root, node);
        this.nodeMap = null;
        this.executeFilters(this.postFilters, math, html, node);
    };
    CommonOutputJax.prototype.getBBox = function (math, html) {
        this.setDocument(html);
        this.math = math;
        math.root.setTeXclass(null);
        this.nodeMap = new Map();
        var bbox = this.factory.wrap(math.root).getOuterBBox();
        this.nodeMap = null;
        return bbox;
    };
    CommonOutputJax.prototype.getMetrics = function (html) {
        var e_1, _a;
        this.setDocument(html);
        var adaptor = this.adaptor;
        var maps = this.getMetricMaps(html);
        try {
            for (var _b = __values(html.math), _c = _b.next(); !_c.done; _c = _b.next()) {
                var math = _c.value;
                var parent_1 = adaptor.parent(math.start.node);
                if (math.state() < MathItem_js_1.STATE.METRICS && parent_1) {
                    var map = maps[math.display ? 1 : 0];
                    var _d = map.get(parent_1), em = _d.em, ex = _d.ex, containerWidth = _d.containerWidth, lineWidth = _d.lineWidth, scale = _d.scale, family = _d.family;
                    math.setMetrics(em, ex, containerWidth, lineWidth, scale);
                    if (this.options.mtextInheritFont) {
                        math.outputData.mtextFamily = family;
                    }
                    if (this.options.merrorInheritFont) {
                        math.outputData.merrorFamily = family;
                    }
                    math.state(MathItem_js_1.STATE.METRICS);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    CommonOutputJax.prototype.getMetricsFor = function (node, display) {
        var getFamily = (this.options.mtextInheritFont || this.options.merrorInheritFont);
        var test = this.getTestElement(node, display);
        var metrics = this.measureMetrics(test, getFamily);
        this.adaptor.remove(test);
        return metrics;
    };
    CommonOutputJax.prototype.getMetricMaps = function (html) {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e;
        var adaptor = this.adaptor;
        var domMaps = [new Map(), new Map()];
        try {
            for (var _f = __values(html.math), _g = _f.next(); !_g.done; _g = _f.next()) {
                var math = _g.value;
                var node = adaptor.parent(math.start.node);
                if (node && math.state() < MathItem_js_1.STATE.METRICS) {
                    var map = domMaps[math.display ? 1 : 0];
                    if (!map.has(node)) {
                        map.set(node, this.getTestElement(node, math.display));
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var getFamily = this.options.mtextInheritFont || this.options.merrorInheritFont;
        var maps = [new Map(), new Map()];
        try {
            for (var _h = __values(maps.keys()), _j = _h.next(); !_j.done; _j = _h.next()) {
                var i = _j.value;
                try {
                    for (var _k = (e_4 = void 0, __values(domMaps[i].keys())), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var node = _l.value;
                        maps[i].set(node, this.measureMetrics(domMaps[i].get(node), getFamily));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var _m = __values(maps.keys()), _o = _m.next(); !_o.done; _o = _m.next()) {
                var i = _o.value;
                try {
                    for (var _p = (e_6 = void 0, __values(domMaps[i].values())), _q = _p.next(); !_q.done; _q = _p.next()) {
                        var node = _q.value;
                        adaptor.remove(node);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return maps;
    };
    CommonOutputJax.prototype.getTestElement = function (node, display) {
        var adaptor = this.adaptor;
        if (!this.testInline) {
            this.testInline = this.html('mjx-test', { style: {
                    display: 'inline-block',
                    width: '100%',
                    'font-style': 'normal',
                    'font-weight': 'normal',
                    'font-size': '100%',
                    'font-size-adjust': 'none',
                    'text-indent': 0,
                    'text-transform': 'none',
                    'letter-spacing': 'normal',
                    'word-spacing': 'normal',
                    overflow: 'hidden',
                    height: '1px',
                    'margin-right': '-1px'
                } }, [
                this.html('mjx-left-box', { style: {
                        display: 'inline-block',
                        width: 0,
                        'float': 'left'
                    } }),
                this.html('mjx-ex-box', { style: {
                        position: 'absolute',
                        overflow: 'hidden',
                        width: '1px', height: '60ex'
                    } }),
                this.html('mjx-right-box', { style: {
                        display: 'inline-block',
                        width: 0,
                        'float': 'right'
                    } })
            ]);
            this.testDisplay = adaptor.clone(this.testInline);
            adaptor.setStyle(this.testDisplay, 'display', 'table');
            adaptor.setStyle(this.testDisplay, 'margin-right', '');
            adaptor.setStyle(adaptor.firstChild(this.testDisplay), 'display', 'none');
            var right = adaptor.lastChild(this.testDisplay);
            adaptor.setStyle(right, 'display', 'table-cell');
            adaptor.setStyle(right, 'width', '10000em');
            adaptor.setStyle(right, 'float', '');
        }
        return adaptor.append(node, adaptor.clone(display ? this.testDisplay : this.testInline));
    };
    CommonOutputJax.prototype.measureMetrics = function (node, getFamily) {
        var adaptor = this.adaptor;
        var family = (getFamily ? adaptor.fontFamily(node) : '');
        var em = adaptor.fontSize(node);
        var _a = __read(adaptor.nodeSize(adaptor.childNode(node, 1)), 2), w = _a[0], h = _a[1];
        var ex = (w ? h / 60 : em * this.options.exFactor);
        var containerWidth = (!w ? 1000000 : adaptor.getStyle(node, 'display') === 'table' ?
            adaptor.nodeSize(adaptor.lastChild(node))[0] - 1 :
            adaptor.nodeBBox(adaptor.lastChild(node)).left -
                adaptor.nodeBBox(adaptor.firstChild(node)).left - 2);
        var scale = Math.max(this.options.minScale, this.options.matchFontHeight ? ex / this.font.params.x_height / em : 1);
        var lineWidth = 1000000;
        return { em: em, ex: ex, containerWidth: containerWidth, lineWidth: lineWidth, scale: scale, family: family };
    };
    CommonOutputJax.prototype.styleSheet = function (html) {
        var e_7, _a;
        this.setDocument(html);
        this.cssStyles.clear();
        this.cssStyles.addStyles(this.constructor.commonStyles);
        if ('getStyles' in html) {
            try {
                for (var _b = __values(html.getStyles()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var styles = _c.value;
                    this.cssStyles.addStyles(styles);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
        this.addWrapperStyles(this.cssStyles);
        this.addFontStyles(this.cssStyles);
        var sheet = this.html('style', { id: 'MJX-styles' }, [this.text('\n' + this.cssStyles.cssText + '\n')]);
        return sheet;
    };
    CommonOutputJax.prototype.addFontStyles = function (styles) {
        styles.addStyles(this.font.styles);
    };
    CommonOutputJax.prototype.addWrapperStyles = function (styles) {
        var e_8, _a;
        try {
            for (var _b = __values(this.factory.getKinds()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var kind = _c.value;
                this.addClassStyles(this.factory.getNodeClass(kind), styles);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
    };
    CommonOutputJax.prototype.addClassStyles = function (CLASS, styles) {
        styles.addStyles(CLASS.styles);
    };
    CommonOutputJax.prototype.setDocument = function (html) {
        if (html) {
            this.document = html;
            this.adaptor.document = html.document;
        }
    };
    CommonOutputJax.prototype.html = function (type, def, content, ns) {
        if (def === void 0) { def = {}; }
        if (content === void 0) { content = []; }
        return this.adaptor.node(type, def, content, ns);
    };
    CommonOutputJax.prototype.text = function (text) {
        return this.adaptor.text(text);
    };
    CommonOutputJax.prototype.fixed = function (m, n) {
        if (n === void 0) { n = 3; }
        if (Math.abs(m) < .0006) {
            return '0';
        }
        return m.toFixed(n).replace(/\.?0+$/, '');
    };
    CommonOutputJax.prototype.measureText = function (text, variant, font) {
        if (font === void 0) { font = ['', false, false]; }
        var node = this.unknownText(text, variant);
        if (variant === '-explicitFont') {
            var styles = this.cssFontStyles(font);
            this.adaptor.setAttributes(node, { style: styles });
        }
        return this.measureTextNodeWithCache(node, text, variant, font);
    };
    CommonOutputJax.prototype.measureTextNodeWithCache = function (text, chars, variant, font) {
        if (font === void 0) { font = ['', false, false]; }
        if (variant === '-explicitFont') {
            variant = [font[0], font[1] ? 'T' : 'F', font[2] ? 'T' : 'F', ''].join('-');
        }
        if (!this.unknownCache.has(variant)) {
            this.unknownCache.set(variant, new Map());
        }
        var map = this.unknownCache.get(variant);
        var cached = map.get(chars);
        if (cached)
            return cached;
        var bbox = this.measureTextNode(text);
        map.set(chars, bbox);
        return bbox;
    };
    CommonOutputJax.prototype.measureXMLnode = function (xml) {
        var adaptor = this.adaptor;
        var content = this.html('mjx-xml-block', { style: { display: 'inline-block' } }, [adaptor.clone(xml)]);
        var base = this.html('mjx-baseline', { style: { display: 'inline-block', width: 0, height: 0 } });
        var style = {
            position: 'absolute',
            display: 'inline-block',
            'font-family': 'initial',
            'line-height': 'normal'
        };
        var node = this.html('mjx-measure-xml', { style: style }, [base, content]);
        adaptor.append(adaptor.parent(this.math.start.node), this.container);
        adaptor.append(this.container, node);
        var em = this.math.metrics.em * this.math.metrics.scale;
        var _a = adaptor.nodeBBox(content), left = _a.left, right = _a.right, bottom = _a.bottom, top = _a.top;
        var w = (right - left) / em;
        var h = (adaptor.nodeBBox(base).top - top) / em;
        var d = (bottom - top) / em - h;
        adaptor.remove(this.container);
        adaptor.remove(node);
        return { w: w, h: h, d: d };
    };
    CommonOutputJax.prototype.cssFontStyles = function (font, styles) {
        if (styles === void 0) { styles = {}; }
        var _a = __read(font, 3), family = _a[0], italic = _a[1], bold = _a[2];
        styles['font-family'] = this.font.getFamily(family);
        if (italic)
            styles['font-style'] = 'italic';
        if (bold)
            styles['font-weight'] = 'bold';
        return styles;
    };
    CommonOutputJax.prototype.getFontData = function (styles) {
        if (!styles) {
            styles = new Styles_js_1.Styles();
        }
        return [this.font.getFamily(styles.get('font-family')),
            styles.get('font-style') === 'italic',
            styles.get('font-weight') === 'bold'];
    };
    CommonOutputJax.NAME = 'Common';
    CommonOutputJax.OPTIONS = __assign(__assign({}, OutputJax_js_1.AbstractOutputJax.OPTIONS), { scale: 1, minScale: .5, mtextInheritFont: false, merrorInheritFont: false, mtextFont: '', merrorFont: 'serif', mathmlSpacing: false, skipAttributes: {}, exFactor: .5, displayAlign: 'center', displayIndent: '0', wrapperFactory: null, font: null, cssStyles: null });
    CommonOutputJax.commonStyles = {};
    return CommonOutputJax;
}(OutputJax_js_1.AbstractOutputJax));
exports.CommonOutputJax = CommonOutputJax;
//# sourceMappingURL=OutputJax.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrapper.js":
/*!***************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrapper.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonWrapper = void 0;
var Wrapper_js_1 = __webpack_require__(/*! ../../core/Tree/Wrapper.js */ "./node_modules/mathjax-full/js/core/Tree/Wrapper.js");
var MmlNode_js_1 = __webpack_require__(/*! ../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var string_js_1 = __webpack_require__(/*! ../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
var LENGTHS = __importStar(__webpack_require__(/*! ../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js"));
var Styles_js_1 = __webpack_require__(/*! ../../util/Styles.js */ "./node_modules/mathjax-full/js/util/Styles.js");
var BBox_js_1 = __webpack_require__(/*! ../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
var FontData_js_1 = __webpack_require__(/*! ./FontData.js */ "./node_modules/mathjax-full/js/output/common/FontData.js");
var SMALLSIZE = 2 / 18;
function MathMLSpace(script, size) {
    return (script ? size < SMALLSIZE ? 0 : SMALLSIZE : size);
}
var CommonWrapper = (function (_super) {
    __extends(CommonWrapper, _super);
    function CommonWrapper(factory, node, parent) {
        if (parent === void 0) { parent = null; }
        var _this = _super.call(this, factory, node) || this;
        _this.parent = null;
        _this.removedStyles = null;
        _this.styles = null;
        _this.variant = '';
        _this.bboxComputed = false;
        _this.stretch = FontData_js_1.NOSTRETCH;
        _this.font = null;
        _this.parent = parent;
        _this.font = factory.jax.font;
        _this.bbox = BBox_js_1.BBox.zero();
        _this.getStyles();
        _this.getVariant();
        _this.getScale();
        _this.getSpace();
        _this.childNodes = node.childNodes.map(function (child) {
            var wrapped = _this.wrap(child);
            if (wrapped.bbox.pwidth && (node.notParent || node.isKind('math'))) {
                _this.bbox.pwidth = BBox_js_1.BBox.fullWidth;
            }
            return wrapped;
        });
        return _this;
    }
    Object.defineProperty(CommonWrapper.prototype, "jax", {
        get: function () {
            return this.factory.jax;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommonWrapper.prototype, "adaptor", {
        get: function () {
            return this.factory.jax.adaptor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommonWrapper.prototype, "metrics", {
        get: function () {
            return this.factory.jax.math.metrics;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommonWrapper.prototype, "fixesPWidth", {
        get: function () {
            return !this.node.notParent && !this.node.isToken;
        },
        enumerable: false,
        configurable: true
    });
    CommonWrapper.prototype.wrap = function (node, parent) {
        if (parent === void 0) { parent = null; }
        var wrapped = this.factory.wrap(node, parent || this);
        if (parent) {
            parent.childNodes.push(wrapped);
        }
        this.jax.nodeMap.set(node, wrapped);
        return wrapped;
    };
    CommonWrapper.prototype.getBBox = function (save) {
        if (save === void 0) { save = true; }
        if (this.bboxComputed) {
            return this.bbox;
        }
        var bbox = (save ? this.bbox : BBox_js_1.BBox.zero());
        this.computeBBox(bbox);
        this.bboxComputed = save;
        return bbox;
    };
    CommonWrapper.prototype.getOuterBBox = function (save) {
        var e_1, _a;
        if (save === void 0) { save = true; }
        var bbox = this.getBBox(save);
        if (!this.styles)
            return bbox;
        var obox = new BBox_js_1.BBox();
        Object.assign(obox, bbox);
        try {
            for (var _b = __values(BBox_js_1.BBox.StyleAdjust), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), name_1 = _d[0], side = _d[1];
                var x = this.styles.get(name_1);
                if (x) {
                    obox[side] += this.length2em(x, 1, obox.rscale);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return obox;
    };
    CommonWrapper.prototype.computeBBox = function (bbox, recompute) {
        var e_2, _a;
        if (recompute === void 0) { recompute = false; }
        bbox.empty();
        try {
            for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                bbox.append(child.getOuterBBox());
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        bbox.clean();
        if (this.fixesPWidth && this.setChildPWidths(recompute)) {
            this.computeBBox(bbox, true);
        }
    };
    CommonWrapper.prototype.setChildPWidths = function (recompute, w, clear) {
        var e_3, _a;
        if (w === void 0) { w = null; }
        if (clear === void 0) { clear = true; }
        if (recompute) {
            return false;
        }
        if (clear) {
            this.bbox.pwidth = '';
        }
        var changed = false;
        try {
            for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var cbox = child.getOuterBBox();
                if (cbox.pwidth && child.setChildPWidths(recompute, w === null ? cbox.w : w, clear)) {
                    changed = true;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return changed;
    };
    CommonWrapper.prototype.invalidateBBox = function () {
        if (this.bboxComputed) {
            this.bboxComputed = false;
            if (this.parent) {
                this.parent.invalidateBBox();
            }
        }
    };
    CommonWrapper.prototype.copySkewIC = function (bbox) {
        var first = this.childNodes[0];
        if (first === null || first === void 0 ? void 0 : first.bbox.sk) {
            bbox.sk = first.bbox.sk;
        }
        if (first === null || first === void 0 ? void 0 : first.bbox.dx) {
            bbox.dx = first.bbox.dx;
        }
        var last = this.childNodes[this.childNodes.length - 1];
        if (last === null || last === void 0 ? void 0 : last.bbox.ic) {
            bbox.ic = last.bbox.ic;
            bbox.w += bbox.ic;
        }
    };
    CommonWrapper.prototype.getStyles = function () {
        var styleString = this.node.attributes.getExplicit('style');
        if (!styleString)
            return;
        var style = this.styles = new Styles_js_1.Styles(styleString);
        for (var i = 0, m = CommonWrapper.removeStyles.length; i < m; i++) {
            var id = CommonWrapper.removeStyles[i];
            if (style.get(id)) {
                if (!this.removedStyles)
                    this.removedStyles = {};
                this.removedStyles[id] = style.get(id);
                style.set(id, '');
            }
        }
    };
    CommonWrapper.prototype.getVariant = function () {
        if (!this.node.isToken)
            return;
        var attributes = this.node.attributes;
        var variant = attributes.get('mathvariant');
        if (!attributes.getExplicit('mathvariant')) {
            var values = attributes.getList('fontfamily', 'fontweight', 'fontstyle');
            if (this.removedStyles) {
                var style = this.removedStyles;
                if (style.fontFamily)
                    values.family = style.fontFamily;
                if (style.fontWeight)
                    values.weight = style.fontWeight;
                if (style.fontStyle)
                    values.style = style.fontStyle;
            }
            if (values.fontfamily)
                values.family = values.fontfamily;
            if (values.fontweight)
                values.weight = values.fontweight;
            if (values.fontstyle)
                values.style = values.fontstyle;
            if (values.weight && values.weight.match(/^\d+$/)) {
                values.weight = (parseInt(values.weight) > 600 ? 'bold' : 'normal');
            }
            if (values.family) {
                variant = this.explicitVariant(values.family, values.weight, values.style);
            }
            else {
                if (this.node.getProperty('variantForm'))
                    variant = '-tex-variant';
                variant = (CommonWrapper.BOLDVARIANTS[values.weight] || {})[variant] || variant;
                variant = (CommonWrapper.ITALICVARIANTS[values.style] || {})[variant] || variant;
            }
        }
        this.variant = variant;
    };
    CommonWrapper.prototype.explicitVariant = function (fontFamily, fontWeight, fontStyle) {
        var style = this.styles;
        if (!style)
            style = this.styles = new Styles_js_1.Styles();
        style.set('fontFamily', fontFamily);
        if (fontWeight)
            style.set('fontWeight', fontWeight);
        if (fontStyle)
            style.set('fontStyle', fontStyle);
        return '-explicitFont';
    };
    CommonWrapper.prototype.getScale = function () {
        var scale = 1, parent = this.parent;
        var pscale = (parent ? parent.bbox.scale : 1);
        var attributes = this.node.attributes;
        var scriptlevel = Math.min(attributes.get('scriptlevel'), 2);
        var fontsize = attributes.get('fontsize');
        var mathsize = (this.node.isToken || this.node.isKind('mstyle') ?
            attributes.get('mathsize') : attributes.getInherited('mathsize'));
        if (scriptlevel !== 0) {
            scale = Math.pow(attributes.get('scriptsizemultiplier'), scriptlevel);
            var scriptminsize = this.length2em(attributes.get('scriptminsize'), .8, 1);
            if (scale < scriptminsize)
                scale = scriptminsize;
        }
        if (this.removedStyles && this.removedStyles.fontSize && !fontsize) {
            fontsize = this.removedStyles.fontSize;
        }
        if (fontsize && !attributes.getExplicit('mathsize')) {
            mathsize = fontsize;
        }
        if (mathsize !== '1') {
            scale *= this.length2em(mathsize, 1, 1);
        }
        this.bbox.scale = scale;
        this.bbox.rscale = scale / pscale;
    };
    CommonWrapper.prototype.getSpace = function () {
        var isTop = this.isTopEmbellished();
        var hasSpacing = this.node.hasSpacingAttributes();
        if (this.jax.options.mathmlSpacing || hasSpacing) {
            isTop && this.getMathMLSpacing();
        }
        else {
            this.getTeXSpacing(isTop, hasSpacing);
        }
    };
    CommonWrapper.prototype.getMathMLSpacing = function () {
        var node = this.node.coreMO();
        var child = node.coreParent();
        var parent = child.parent;
        if (!parent || !parent.isKind('mrow') || parent.childNodes.length === 1)
            return;
        var attributes = node.attributes;
        var isScript = (attributes.get('scriptlevel') > 0);
        this.bbox.L = (attributes.isSet('lspace') ?
            Math.max(0, this.length2em(attributes.get('lspace'))) :
            MathMLSpace(isScript, node.lspace));
        this.bbox.R = (attributes.isSet('rspace') ?
            Math.max(0, this.length2em(attributes.get('rspace'))) :
            MathMLSpace(isScript, node.rspace));
        var n = parent.childIndex(child);
        if (n === 0)
            return;
        var prev = parent.childNodes[n - 1];
        if (!prev.isEmbellished)
            return;
        var bbox = this.jax.nodeMap.get(prev).getBBox();
        if (bbox.R) {
            this.bbox.L = Math.max(0, this.bbox.L - bbox.R);
        }
    };
    CommonWrapper.prototype.getTeXSpacing = function (isTop, hasSpacing) {
        if (!hasSpacing) {
            var space = this.node.texSpacing();
            if (space) {
                this.bbox.L = this.length2em(space);
            }
        }
        if (isTop || hasSpacing) {
            var attributes = this.node.coreMO().attributes;
            if (attributes.isSet('lspace')) {
                this.bbox.L = Math.max(0, this.length2em(attributes.get('lspace')));
            }
            if (attributes.isSet('rspace')) {
                this.bbox.R = Math.max(0, this.length2em(attributes.get('rspace')));
            }
        }
    };
    CommonWrapper.prototype.isTopEmbellished = function () {
        return (this.node.isEmbellished &&
            !(this.node.parent && this.node.parent.isEmbellished));
    };
    CommonWrapper.prototype.core = function () {
        return this.jax.nodeMap.get(this.node.core());
    };
    CommonWrapper.prototype.coreMO = function () {
        return this.jax.nodeMap.get(this.node.coreMO());
    };
    CommonWrapper.prototype.getText = function () {
        var e_4, _a;
        var text = '';
        if (this.node.isToken) {
            try {
                for (var _b = __values(this.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (child instanceof MmlNode_js_1.TextNode) {
                        text += child.getText();
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        return text;
    };
    CommonWrapper.prototype.canStretch = function (direction) {
        this.stretch = FontData_js_1.NOSTRETCH;
        if (this.node.isEmbellished) {
            var core = this.core();
            if (core && core.node !== this.node) {
                if (core.canStretch(direction)) {
                    this.stretch = core.stretch;
                }
            }
        }
        return this.stretch.dir !== 0;
    };
    CommonWrapper.prototype.getAlignShift = function () {
        var _a;
        var _b = (_a = this.node.attributes).getList.apply(_a, __spreadArray([], __read(MmlNode_js_1.indentAttributes), false)), indentalign = _b.indentalign, indentshift = _b.indentshift, indentalignfirst = _b.indentalignfirst, indentshiftfirst = _b.indentshiftfirst;
        if (indentalignfirst !== 'indentalign') {
            indentalign = indentalignfirst;
        }
        if (indentalign === 'auto') {
            indentalign = this.jax.options.displayAlign;
        }
        if (indentshiftfirst !== 'indentshift') {
            indentshift = indentshiftfirst;
        }
        if (indentshift === 'auto') {
            indentshift = this.jax.options.displayIndent;
            if (indentalign === 'right' && !indentshift.match(/^\s*0[a-z]*\s*$/)) {
                indentshift = ('-' + indentshift.trim()).replace(/^--/, '');
            }
        }
        var shift = this.length2em(indentshift, this.metrics.containerWidth);
        return [indentalign, shift];
    };
    CommonWrapper.prototype.getAlignX = function (W, bbox, align) {
        return (align === 'right' ? W - (bbox.w + bbox.R) * bbox.rscale :
            align === 'left' ? bbox.L * bbox.rscale :
                (W - bbox.w * bbox.rscale) / 2);
    };
    CommonWrapper.prototype.getAlignY = function (H, D, h, d, align) {
        return (align === 'top' ? H - h :
            align === 'bottom' ? d - D :
                align === 'center' ? ((H - h) - (D - d)) / 2 :
                    0);
    };
    CommonWrapper.prototype.getWrapWidth = function (i) {
        return this.childNodes[i].getBBox().w;
    };
    CommonWrapper.prototype.getChildAlign = function (_i) {
        return 'left';
    };
    CommonWrapper.prototype.percent = function (m) {
        return LENGTHS.percent(m);
    };
    CommonWrapper.prototype.em = function (m) {
        return LENGTHS.em(m);
    };
    CommonWrapper.prototype.px = function (m, M) {
        if (M === void 0) { M = -LENGTHS.BIGDIMEN; }
        return LENGTHS.px(m, M, this.metrics.em);
    };
    CommonWrapper.prototype.length2em = function (length, size, scale) {
        if (size === void 0) { size = 1; }
        if (scale === void 0) { scale = null; }
        if (scale === null) {
            scale = this.bbox.scale;
        }
        return LENGTHS.length2em(length, size, scale, this.jax.pxPerEm);
    };
    CommonWrapper.prototype.unicodeChars = function (text, name) {
        if (name === void 0) { name = this.variant; }
        var chars = (0, string_js_1.unicodeChars)(text);
        var variant = this.font.getVariant(name);
        if (variant && variant.chars) {
            var map_1 = variant.chars;
            chars = chars.map(function (n) { return ((map_1[n] || [])[3] || {}).smp || n; });
        }
        return chars;
    };
    CommonWrapper.prototype.remapChars = function (chars) {
        return chars;
    };
    CommonWrapper.prototype.mmlText = function (text) {
        return this.node.factory.create('text').setText(text);
    };
    CommonWrapper.prototype.mmlNode = function (kind, properties, children) {
        if (properties === void 0) { properties = {}; }
        if (children === void 0) { children = []; }
        return this.node.factory.create(kind, properties, children);
    };
    CommonWrapper.prototype.createMo = function (text) {
        var mmlFactory = this.node.factory;
        var textNode = mmlFactory.create('text').setText(text);
        var mml = mmlFactory.create('mo', { stretchy: true }, [textNode]);
        mml.inheritAttributesFrom(this.node);
        var node = this.wrap(mml);
        node.parent = this;
        return node;
    };
    CommonWrapper.prototype.getVariantChar = function (variant, n) {
        var char = this.font.getChar(variant, n) || [0, 0, 0, { unknown: true }];
        if (char.length === 3) {
            char[3] = {};
        }
        return char;
    };
    CommonWrapper.kind = 'unknown';
    CommonWrapper.styles = {};
    CommonWrapper.removeStyles = [
        'fontSize', 'fontFamily', 'fontWeight',
        'fontStyle', 'fontVariant', 'font'
    ];
    CommonWrapper.skipAttributes = {
        fontfamily: true, fontsize: true, fontweight: true, fontstyle: true,
        color: true, background: true,
        'class': true, href: true, style: true,
        xmlns: true
    };
    CommonWrapper.BOLDVARIANTS = {
        bold: {
            normal: 'bold',
            italic: 'bold-italic',
            fraktur: 'bold-fraktur',
            script: 'bold-script',
            'sans-serif': 'bold-sans-serif',
            'sans-serif-italic': 'sans-serif-bold-italic'
        },
        normal: {
            bold: 'normal',
            'bold-italic': 'italic',
            'bold-fraktur': 'fraktur',
            'bold-script': 'script',
            'bold-sans-serif': 'sans-serif',
            'sans-serif-bold-italic': 'sans-serif-italic'
        }
    };
    CommonWrapper.ITALICVARIANTS = {
        italic: {
            normal: 'italic',
            bold: 'bold-italic',
            'sans-serif': 'sans-serif-italic',
            'bold-sans-serif': 'sans-serif-bold-italic'
        },
        normal: {
            italic: 'normal',
            'bold-italic': 'bold',
            'sans-serif-italic': 'sans-serif',
            'sans-serif-bold-italic': 'bold-sans-serif'
        }
    };
    return CommonWrapper;
}(Wrapper_js_1.AbstractWrapper));
exports.CommonWrapper = CommonWrapper;
//# sourceMappingURL=Wrapper.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/WrapperFactory.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/WrapperFactory.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonWrapperFactory = void 0;
var WrapperFactory_js_1 = __webpack_require__(/*! ../../core/Tree/WrapperFactory.js */ "./node_modules/mathjax-full/js/core/Tree/WrapperFactory.js");
var CommonWrapperFactory = (function (_super) {
    __extends(CommonWrapperFactory, _super);
    function CommonWrapperFactory() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.jax = null;
        return _this;
    }
    Object.defineProperty(CommonWrapperFactory.prototype, "Wrappers", {
        get: function () {
            return this.node;
        },
        enumerable: false,
        configurable: true
    });
    CommonWrapperFactory.defaultNodes = {};
    return CommonWrapperFactory;
}(WrapperFactory_js_1.AbstractWrapperFactory));
exports.CommonWrapperFactory = CommonWrapperFactory;
//# sourceMappingURL=WrapperFactory.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/TeXAtom.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/TeXAtom.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonTeXAtomMixin = void 0;
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
function CommonTeXAtomMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            _super.prototype.computeBBox.call(this, bbox, recompute);
            if (this.childNodes[0] && this.childNodes[0].bbox.ic) {
                bbox.ic = this.childNodes[0].bbox.ic;
            }
            if (this.node.texClass === MmlNode_js_1.TEXCLASS.VCENTER) {
                var h = bbox.h, d = bbox.d;
                var a = this.font.params.axis_height;
                var dh = ((h + d) / 2 + a) - h;
                bbox.h += dh;
                bbox.d -= dh;
            }
        };
        return class_1;
    }(Base));
}
exports.CommonTeXAtomMixin = CommonTeXAtomMixin;
//# sourceMappingURL=TeXAtom.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/TextNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/TextNode.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonTextNodeMixin = void 0;
function CommonTextNodeMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            var e_1, _a;
            if (_recompute === void 0) { _recompute = false; }
            var variant = this.parent.variant;
            var text = this.node.getText();
            if (variant === '-explicitFont') {
                var font = this.jax.getFontData(this.parent.styles);
                var _b = this.jax.measureText(text, variant, font), w = _b.w, h = _b.h, d = _b.d;
                bbox.h = h;
                bbox.d = d;
                bbox.w = w;
            }
            else {
                var chars = this.remappedText(text, variant);
                bbox.empty();
                try {
                    for (var chars_1 = __values(chars), chars_1_1 = chars_1.next(); !chars_1_1.done; chars_1_1 = chars_1.next()) {
                        var char = chars_1_1.value;
                        var _c = __read(this.getVariantChar(variant, char), 4), h = _c[0], d = _c[1], w = _c[2], data = _c[3];
                        if (data.unknown) {
                            var cbox = this.jax.measureText(String.fromCodePoint(char), variant);
                            w = cbox.w;
                            h = cbox.h;
                            d = cbox.d;
                        }
                        bbox.w += w;
                        if (h > bbox.h)
                            bbox.h = h;
                        if (d > bbox.d)
                            bbox.d = d;
                        bbox.ic = data.ic || 0;
                        bbox.sk = data.sk || 0;
                        bbox.dx = data.dx || 0;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (chars_1_1 && !chars_1_1.done && (_a = chars_1.return)) _a.call(chars_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (chars.length > 1) {
                    bbox.sk = 0;
                }
                bbox.clean();
            }
        };
        class_1.prototype.remappedText = function (text, variant) {
            var c = this.parent.stretch.c;
            return (c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant)));
        };
        class_1.prototype.getStyles = function () { };
        class_1.prototype.getVariant = function () { };
        class_1.prototype.getScale = function () { };
        class_1.prototype.getSpace = function () { };
        return class_1;
    }(Base));
}
exports.CommonTextNodeMixin = CommonTextNodeMixin;
//# sourceMappingURL=TextNode.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/maction.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/maction.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMactionMixin = exports.TooltipData = void 0;
var string_js_1 = __webpack_require__(/*! ../../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
exports.TooltipData = {
    dx: '.2em',
    dy: '.1em',
    postDelay: 600,
    clearDelay: 100,
    hoverTimer: new Map(),
    clearTimer: new Map(),
    stopTimers: function (node, data) {
        if (data.clearTimer.has(node)) {
            clearTimeout(data.clearTimer.get(node));
            data.clearTimer.delete(node);
        }
        if (data.hoverTimer.has(node)) {
            clearTimeout(data.hoverTimer.get(node));
            data.hoverTimer.delete(node);
        }
    }
};
function CommonMactionMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            var actions = _this.constructor.actions;
            var action = _this.node.attributes.get('actiontype');
            var _a = __read(actions.get(action) || [(function (_node, _data) { }), {}], 2), handler = _a[0], data = _a[1];
            _this.action = handler;
            _this.data = data;
            _this.getParameters();
            return _this;
        }
        Object.defineProperty(class_1.prototype, "selected", {
            get: function () {
                var selection = this.node.attributes.get('selection');
                var i = Math.max(1, Math.min(this.childNodes.length, selection)) - 1;
                return this.childNodes[i] || this.wrap(this.node.selected);
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.getParameters = function () {
            var offsets = this.node.attributes.get('data-offsets');
            var _a = __read((0, string_js_1.split)(offsets || ''), 2), dx = _a[0], dy = _a[1];
            this.dx = this.length2em(dx || exports.TooltipData.dx);
            this.dy = this.length2em(dy || exports.TooltipData.dy);
        };
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            bbox.updateFrom(this.selected.getOuterBBox());
            this.selected.setChildPWidths(recompute);
        };
        return class_1;
    }(Base));
}
exports.CommonMactionMixin = CommonMactionMixin;
//# sourceMappingURL=maction.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/math.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/math.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMathMixin = void 0;
function CommonMathMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.getWrapWidth = function (_i) {
            return (this.parent ? this.getBBox().w : this.metrics.containerWidth / this.jax.pxPerEm);
        };
        return class_1;
    }(Base));
}
exports.CommonMathMixin = CommonMathMixin;
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/menclose.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/menclose.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMencloseMixin = void 0;
var Notation = __importStar(__webpack_require__(/*! ../Notation.js */ "./node_modules/mathjax-full/js/output/common/Notation.js"));
var string_js_1 = __webpack_require__(/*! ../../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
function CommonMencloseMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.notations = {};
            _this.renderChild = null;
            _this.msqrt = null;
            _this.padding = Notation.PADDING;
            _this.thickness = Notation.THICKNESS;
            _this.arrowhead = { x: Notation.ARROWX, y: Notation.ARROWY, dx: Notation.ARROWDX };
            _this.TRBL = [0, 0, 0, 0];
            _this.getParameters();
            _this.getNotations();
            _this.removeRedundantNotations();
            _this.initializeNotations();
            _this.TRBL = _this.getBBoxExtenders();
            return _this;
        }
        class_1.prototype.getParameters = function () {
            var attributes = this.node.attributes;
            var padding = attributes.get('data-padding');
            if (padding !== undefined) {
                this.padding = this.length2em(padding, Notation.PADDING);
            }
            var thickness = attributes.get('data-thickness');
            if (thickness !== undefined) {
                this.thickness = this.length2em(thickness, Notation.THICKNESS);
            }
            var arrowhead = attributes.get('data-arrowhead');
            if (arrowhead !== undefined) {
                var _b = __read((0, string_js_1.split)(arrowhead), 3), x = _b[0], y = _b[1], dx = _b[2];
                this.arrowhead = {
                    x: (x ? parseFloat(x) : Notation.ARROWX),
                    y: (y ? parseFloat(y) : Notation.ARROWY),
                    dx: (dx ? parseFloat(dx) : Notation.ARROWDX)
                };
            }
        };
        class_1.prototype.getNotations = function () {
            var e_1, _b;
            var Notations = this.constructor.notations;
            try {
                for (var _c = __values((0, string_js_1.split)(this.node.attributes.get('notation'))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var name_1 = _d.value;
                    var notation = Notations.get(name_1);
                    if (notation) {
                        this.notations[name_1] = notation;
                        if (notation.renderChild) {
                            this.renderChild = notation.renderer;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        class_1.prototype.removeRedundantNotations = function () {
            var e_2, _b, e_3, _c;
            try {
                for (var _d = __values(Object.keys(this.notations)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var name_2 = _e.value;
                    if (this.notations[name_2]) {
                        var remove = this.notations[name_2].remove || '';
                        try {
                            for (var _f = (e_3 = void 0, __values(remove.split(/ /))), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var notation = _g.value;
                                delete this.notations[notation];
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        class_1.prototype.initializeNotations = function () {
            var e_4, _b;
            try {
                for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var name_3 = _d.value;
                    var init = this.notations[name_3].init;
                    init && init(this);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            var _b = __read(this.TRBL, 4), T = _b[0], R = _b[1], B = _b[2], L = _b[3];
            var child = this.childNodes[0].getBBox();
            bbox.combine(child, L, 0);
            bbox.h += T;
            bbox.d += B;
            bbox.w += R;
            this.setChildPWidths(recompute);
        };
        class_1.prototype.getBBoxExtenders = function () {
            var e_5, _b;
            var TRBL = [0, 0, 0, 0];
            try {
                for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var name_4 = _d.value;
                    this.maximizeEntries(TRBL, this.notations[name_4].bbox(this));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return TRBL;
        };
        class_1.prototype.getPadding = function () {
            var e_6, _b;
            var _this = this;
            var BTRBL = [0, 0, 0, 0];
            try {
                for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var name_5 = _d.value;
                    var border = this.notations[name_5].border;
                    if (border) {
                        this.maximizeEntries(BTRBL, border(this));
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_6) throw e_6.error; }
            }
            return [0, 1, 2, 3].map(function (i) { return _this.TRBL[i] - BTRBL[i]; });
        };
        class_1.prototype.maximizeEntries = function (X, Y) {
            for (var i = 0; i < X.length; i++) {
                if (X[i] < Y[i]) {
                    X[i] = Y[i];
                }
            }
        };
        class_1.prototype.getOffset = function (direction) {
            var _b = __read(this.TRBL, 4), T = _b[0], R = _b[1], B = _b[2], L = _b[3];
            var d = (direction === 'X' ? R - L : B - T) / 2;
            return (Math.abs(d) > .001 ? d : 0);
        };
        class_1.prototype.getArgMod = function (w, h) {
            return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];
        };
        class_1.prototype.arrow = function (_w, _a, _double, _offset, _dist) {
            if (_offset === void 0) { _offset = ''; }
            if (_dist === void 0) { _dist = 0; }
            return null;
        };
        class_1.prototype.arrowData = function () {
            var _b = __read([this.padding, this.thickness], 2), p = _b[0], t = _b[1];
            var r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));
            var _c = this.childNodes[0].getBBox(), h = _c.h, d = _c.d, w = _c.w;
            var H = h + d;
            var R = Math.sqrt(H * H + w * w);
            var x = Math.max(p, r * w / R);
            var y = Math.max(p, r * H / R);
            var _d = __read(this.getArgMod(w + 2 * x, H + 2 * y), 2), a = _d[0], W = _d[1];
            return { a: a, W: W, x: x, y: y };
        };
        class_1.prototype.arrowAW = function () {
            var _b = this.childNodes[0].getBBox(), h = _b.h, d = _b.d, w = _b.w;
            var _c = __read(this.TRBL, 4), T = _c[0], R = _c[1], B = _c[2], L = _c[3];
            return this.getArgMod(L + w + R, T + h + d + B);
        };
        class_1.prototype.createMsqrt = function (child) {
            var mmlFactory = this.node.factory;
            var mml = mmlFactory.create('msqrt');
            mml.inheritAttributesFrom(this.node);
            mml.childNodes[0] = child.node;
            var node = this.wrap(mml);
            node.parent = this;
            return node;
        };
        class_1.prototype.sqrtTRBL = function () {
            var bbox = this.msqrt.getBBox();
            var cbox = this.msqrt.childNodes[0].getBBox();
            return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];
        };
        return class_1;
    }(Base));
}
exports.CommonMencloseMixin = CommonMencloseMixin;
//# sourceMappingURL=menclose.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mfenced.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mfenced.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMfencedMixin = void 0;
function CommonMfencedMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.mrow = null;
            _this.createMrow();
            _this.addMrowChildren();
            return _this;
        }
        class_1.prototype.createMrow = function () {
            var mmlFactory = this.node.factory;
            var mrow = mmlFactory.create('inferredMrow');
            mrow.inheritAttributesFrom(this.node);
            this.mrow = this.wrap(mrow);
            this.mrow.parent = this;
        };
        class_1.prototype.addMrowChildren = function () {
            var e_1, _a;
            var mfenced = this.node;
            var mrow = this.mrow;
            this.addMo(mfenced.open);
            if (this.childNodes.length) {
                mrow.childNodes.push(this.childNodes[0]);
            }
            var i = 0;
            try {
                for (var _b = __values(this.childNodes.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    this.addMo(mfenced.separators[i++]);
                    mrow.childNodes.push(child);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.addMo(mfenced.close);
            mrow.stretchChildren();
        };
        class_1.prototype.addMo = function (node) {
            if (!node)
                return;
            var mo = this.wrap(node);
            this.mrow.childNodes.push(mo);
            mo.parent = this.mrow;
        };
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            bbox.updateFrom(this.mrow.getOuterBBox());
            this.setChildPWidths(recompute);
        };
        return class_1;
    }(Base));
}
exports.CommonMfencedMixin = CommonMfencedMixin;
//# sourceMappingURL=mfenced.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mfrac.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mfrac.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMfracMixin = void 0;
function CommonMfracMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.bevel = null;
            _this.pad = (_this.node.getProperty('withDelims') ? 0 : _this.font.params.nulldelimiterspace);
            if (_this.node.attributes.get('bevelled')) {
                var H = _this.getBevelData(_this.isDisplay()).H;
                var bevel = _this.bevel = _this.createMo('/');
                bevel.node.attributes.set('symmetric', true);
                bevel.canStretch(1);
                bevel.getStretchedVariant([H], true);
            }
            return _this;
        }
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            bbox.empty();
            var _a = this.node.attributes.getList('linethickness', 'bevelled'), linethickness = _a.linethickness, bevelled = _a.bevelled;
            var display = this.isDisplay();
            var w = null;
            if (bevelled) {
                this.getBevelledBBox(bbox, display);
            }
            else {
                var thickness = this.length2em(String(linethickness), .06);
                w = -2 * this.pad;
                if (thickness === 0) {
                    this.getAtopBBox(bbox, display);
                }
                else {
                    this.getFractionBBox(bbox, display, thickness);
                    w -= .2;
                }
                w += bbox.w;
            }
            bbox.clean();
            this.setChildPWidths(recompute, w);
        };
        class_1.prototype.getFractionBBox = function (bbox, display, t) {
            var nbox = this.childNodes[0].getOuterBBox();
            var dbox = this.childNodes[1].getOuterBBox();
            var tex = this.font.params;
            var a = tex.axis_height;
            var _a = this.getTUV(display, t), T = _a.T, u = _a.u, v = _a.v;
            bbox.combine(nbox, 0, a + T + Math.max(nbox.d * nbox.rscale, u));
            bbox.combine(dbox, 0, a - T - Math.max(dbox.h * dbox.rscale, v));
            bbox.w += 2 * this.pad + .2;
        };
        class_1.prototype.getTUV = function (display, t) {
            var tex = this.font.params;
            var a = tex.axis_height;
            var T = (display ? 3.5 : 1.5) * t;
            return { T: (display ? 3.5 : 1.5) * t,
                u: (display ? tex.num1 : tex.num2) - a - T,
                v: (display ? tex.denom1 : tex.denom2) + a - T };
        };
        class_1.prototype.getAtopBBox = function (bbox, display) {
            var _a = this.getUVQ(display), u = _a.u, v = _a.v, nbox = _a.nbox, dbox = _a.dbox;
            bbox.combine(nbox, 0, u);
            bbox.combine(dbox, 0, -v);
            bbox.w += 2 * this.pad;
        };
        class_1.prototype.getUVQ = function (display) {
            var nbox = this.childNodes[0].getOuterBBox();
            var dbox = this.childNodes[1].getOuterBBox();
            var tex = this.font.params;
            var _a = __read((display ? [tex.num1, tex.denom1] : [tex.num3, tex.denom2]), 2), u = _a[0], v = _a[1];
            var p = (display ? 7 : 3) * tex.rule_thickness;
            var q = (u - nbox.d * nbox.scale) - (dbox.h * dbox.scale - v);
            if (q < p) {
                u += (p - q) / 2;
                v += (p - q) / 2;
                q = p;
            }
            return { u: u, v: v, q: q, nbox: nbox, dbox: dbox };
        };
        class_1.prototype.getBevelledBBox = function (bbox, display) {
            var _a = this.getBevelData(display), u = _a.u, v = _a.v, delta = _a.delta, nbox = _a.nbox, dbox = _a.dbox;
            var lbox = this.bevel.getOuterBBox();
            bbox.combine(nbox, 0, u);
            bbox.combine(lbox, bbox.w - delta / 2, 0);
            bbox.combine(dbox, bbox.w - delta / 2, v);
        };
        class_1.prototype.getBevelData = function (display) {
            var nbox = this.childNodes[0].getOuterBBox();
            var dbox = this.childNodes[1].getOuterBBox();
            var delta = (display ? .4 : .15);
            var H = Math.max(nbox.scale * (nbox.h + nbox.d), dbox.scale * (dbox.h + dbox.d)) + 2 * delta;
            var a = this.font.params.axis_height;
            var u = nbox.scale * (nbox.d - nbox.h) / 2 + a + delta;
            var v = dbox.scale * (dbox.d - dbox.h) / 2 + a - delta;
            return { H: H, delta: delta, u: u, v: v, nbox: nbox, dbox: dbox };
        };
        class_1.prototype.canStretch = function (_direction) {
            return false;
        };
        class_1.prototype.isDisplay = function () {
            var _a = this.node.attributes.getList('displaystyle', 'scriptlevel'), displaystyle = _a.displaystyle, scriptlevel = _a.scriptlevel;
            return displaystyle && scriptlevel === 0;
        };
        class_1.prototype.getWrapWidth = function (i) {
            var attributes = this.node.attributes;
            if (attributes.get('bevelled')) {
                return this.childNodes[i].getOuterBBox().w;
            }
            var w = this.getBBox().w;
            var thickness = this.length2em(attributes.get('linethickness'));
            return w - (thickness ? .2 : 0) - 2 * this.pad;
        };
        class_1.prototype.getChildAlign = function (i) {
            var attributes = this.node.attributes;
            return (attributes.get('bevelled') ? 'left' : attributes.get(['numalign', 'denomalign'][i]));
        };
        return class_1;
    }(Base));
}
exports.CommonMfracMixin = CommonMfracMixin;
//# sourceMappingURL=mfrac.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mglyph.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mglyph.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMglyphMixin = void 0;
function CommonMglyphMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.getParameters();
            return _this;
        }
        class_1.prototype.getParameters = function () {
            var _a = this.node.attributes.getList('width', 'height', 'valign', 'src', 'index'), width = _a.width, height = _a.height, valign = _a.valign, src = _a.src, index = _a.index;
            if (src) {
                this.width = (width === 'auto' ? 1 : this.length2em(width));
                this.height = (height === 'auto' ? 1 : this.length2em(height));
                this.valign = this.length2em(valign || '0');
            }
            else {
                var text = String.fromCodePoint(parseInt(index));
                var mmlFactory = this.node.factory;
                this.charWrapper = this.wrap(mmlFactory.create('text').setText(text));
                this.charWrapper.parent = this;
            }
        };
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            if (_recompute === void 0) { _recompute = false; }
            if (this.charWrapper) {
                bbox.updateFrom(this.charWrapper.getBBox());
            }
            else {
                bbox.w = this.width;
                bbox.h = this.height + this.valign;
                bbox.d = -this.valign;
            }
        };
        return class_1;
    }(Base));
}
exports.CommonMglyphMixin = CommonMglyphMixin;
//# sourceMappingURL=mglyph.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mi.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mi.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMiMixin = void 0;
function CommonMiMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            if (_recompute === void 0) { _recompute = false; }
            _super.prototype.computeBBox.call(this, bbox);
            this.copySkewIC(bbox);
        };
        return class_1;
    }(Base));
}
exports.CommonMiMixin = CommonMiMixin;
//# sourceMappingURL=mi.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mmultiscripts.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mmultiscripts.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMmultiscriptsMixin = exports.ScriptNames = exports.NextScript = void 0;
var BBox_js_1 = __webpack_require__(/*! ../../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
exports.NextScript = {
    base: 'subList',
    subList: 'supList',
    supList: 'subList',
    psubList: 'psupList',
    psupList: 'psubList',
};
exports.ScriptNames = ['sup', 'sup', 'psup', 'psub'];
function CommonMmultiscriptsMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.scriptData = null;
            _this.firstPrescript = 0;
            _this.getScriptData();
            return _this;
        }
        class_1.prototype.combinePrePost = function (pre, post) {
            var bbox = new BBox_js_1.BBox(pre);
            bbox.combine(post, 0, 0);
            return bbox;
        };
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            var scriptspace = this.font.params.scriptspace;
            var data = this.scriptData;
            var sub = this.combinePrePost(data.sub, data.psub);
            var sup = this.combinePrePost(data.sup, data.psup);
            var _a = __read(this.getUVQ(sub, sup), 2), u = _a[0], v = _a[1];
            bbox.empty();
            if (data.numPrescripts) {
                bbox.combine(data.psup, scriptspace, u);
                bbox.combine(data.psub, scriptspace, v);
            }
            bbox.append(data.base);
            if (data.numScripts) {
                var w = bbox.w;
                bbox.combine(data.sup, w, u);
                bbox.combine(data.sub, w, v);
                bbox.w += scriptspace;
            }
            bbox.clean();
            this.setChildPWidths(recompute);
        };
        class_1.prototype.getScriptData = function () {
            var data = this.scriptData = {
                base: null, sub: BBox_js_1.BBox.empty(), sup: BBox_js_1.BBox.empty(), psub: BBox_js_1.BBox.empty(), psup: BBox_js_1.BBox.empty(),
                numPrescripts: 0, numScripts: 0
            };
            var lists = this.getScriptBBoxLists();
            this.combineBBoxLists(data.sub, data.sup, lists.subList, lists.supList);
            this.combineBBoxLists(data.psub, data.psup, lists.psubList, lists.psupList);
            data.base = lists.base[0];
            data.numPrescripts = lists.psubList.length;
            data.numScripts = lists.subList.length;
        };
        class_1.prototype.getScriptBBoxLists = function () {
            var e_1, _a;
            var lists = {
                base: [], subList: [], supList: [], psubList: [], psupList: []
            };
            var script = 'base';
            try {
                for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (child.node.isKind('mprescripts')) {
                        script = 'psubList';
                    }
                    else {
                        lists[script].push(child.getOuterBBox());
                        script = exports.NextScript[script];
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.firstPrescript = lists.subList.length + lists.supList.length + 2;
            this.padLists(lists.subList, lists.supList);
            this.padLists(lists.psubList, lists.psupList);
            return lists;
        };
        class_1.prototype.padLists = function (list1, list2) {
            if (list1.length > list2.length) {
                list2.push(BBox_js_1.BBox.empty());
            }
        };
        class_1.prototype.combineBBoxLists = function (bbox1, bbox2, list1, list2) {
            for (var i = 0; i < list1.length; i++) {
                var _a = __read(this.getScaledWHD(list1[i]), 3), w1 = _a[0], h1 = _a[1], d1 = _a[2];
                var _b = __read(this.getScaledWHD(list2[i]), 3), w2 = _b[0], h2 = _b[1], d2 = _b[2];
                var w = Math.max(w1, w2);
                bbox1.w += w;
                bbox2.w += w;
                if (h1 > bbox1.h)
                    bbox1.h = h1;
                if (d1 > bbox1.d)
                    bbox1.d = d1;
                if (h2 > bbox2.h)
                    bbox2.h = h2;
                if (d2 > bbox2.d)
                    bbox2.d = d2;
            }
        };
        class_1.prototype.getScaledWHD = function (bbox) {
            var w = bbox.w, h = bbox.h, d = bbox.d, rscale = bbox.rscale;
            return [w * rscale, h * rscale, d * rscale];
        };
        class_1.prototype.getUVQ = function (subbox, supbox) {
            var _a;
            if (!this.UVQ) {
                var _b = __read([0, 0, 0], 3), u = _b[0], v = _b[1], q = _b[2];
                if (subbox.h === 0 && subbox.d === 0) {
                    u = this.getU();
                }
                else if (supbox.h === 0 && supbox.d === 0) {
                    u = -this.getV();
                }
                else {
                    _a = __read(_super.prototype.getUVQ.call(this, subbox, supbox), 3), u = _a[0], v = _a[1], q = _a[2];
                }
                this.UVQ = [u, v, q];
            }
            return this.UVQ;
        };
        return class_1;
    }(Base));
}
exports.CommonMmultiscriptsMixin = CommonMmultiscriptsMixin;
//# sourceMappingURL=mmultiscripts.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mn.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mn.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMnMixin = void 0;
function CommonMnMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.remapChars = function (chars) {
            if (chars.length) {
                var text = this.font.getRemappedChar('mn', chars[0]);
                if (text) {
                    var c = this.unicodeChars(text, this.variant);
                    if (c.length === 1) {
                        chars[0] = c[0];
                    }
                    else {
                        chars = c.concat(chars.slice(1));
                    }
                }
            }
            return chars;
        };
        return class_1;
    }(Base));
}
exports.CommonMnMixin = CommonMnMixin;
//# sourceMappingURL=mn.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mo.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mo.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMoMixin = exports.DirectionVH = void 0;
var BBox_js_1 = __webpack_require__(/*! ../../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
var string_js_1 = __webpack_require__(/*! ../../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
var FontData_js_1 = __webpack_require__(/*! ../FontData.js */ "./node_modules/mathjax-full/js/output/common/FontData.js");
exports.DirectionVH = (_a = {},
    _a[1] = 'v',
    _a[2] = 'h',
    _a);
function CommonMoMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.size = null;
            _this.isAccent = _this.node.isAccent;
            return _this;
        }
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            if (_recompute === void 0) { _recompute = false; }
            this.protoBBox(bbox);
            if (this.node.attributes.get('symmetric') &&
                this.stretch.dir !== 2) {
                var d = this.getCenterOffset(bbox);
                bbox.h += d;
                bbox.d -= d;
            }
            if (this.node.getProperty('mathaccent') &&
                (this.stretch.dir === 0 || this.size >= 0)) {
                bbox.w = 0;
            }
        };
        class_1.prototype.protoBBox = function (bbox) {
            var stretchy = (this.stretch.dir !== 0);
            if (stretchy && this.size === null) {
                this.getStretchedVariant([0]);
            }
            if (stretchy && this.size < 0)
                return;
            _super.prototype.computeBBox.call(this, bbox);
            this.copySkewIC(bbox);
        };
        class_1.prototype.getAccentOffset = function () {
            var bbox = BBox_js_1.BBox.empty();
            this.protoBBox(bbox);
            return -bbox.w / 2;
        };
        class_1.prototype.getCenterOffset = function (bbox) {
            if (bbox === void 0) { bbox = null; }
            if (!bbox) {
                bbox = BBox_js_1.BBox.empty();
                _super.prototype.computeBBox.call(this, bbox);
            }
            return ((bbox.h + bbox.d) / 2 + this.font.params.axis_height) - bbox.h;
        };
        class_1.prototype.getVariant = function () {
            if (this.node.attributes.get('largeop')) {
                this.variant = (this.node.attributes.get('displaystyle') ? '-largeop' : '-smallop');
                return;
            }
            if (!this.node.attributes.getExplicit('mathvariant') &&
                this.node.getProperty('pseudoscript') === false) {
                this.variant = '-tex-variant';
                return;
            }
            _super.prototype.getVariant.call(this);
        };
        class_1.prototype.canStretch = function (direction) {
            if (this.stretch.dir !== 0) {
                return this.stretch.dir === direction;
            }
            var attributes = this.node.attributes;
            if (!attributes.get('stretchy'))
                return false;
            var c = this.getText();
            if (Array.from(c).length !== 1)
                return false;
            var delim = this.font.getDelimiter(c.codePointAt(0));
            this.stretch = (delim && delim.dir === direction ? delim : FontData_js_1.NOSTRETCH);
            return this.stretch.dir !== 0;
        };
        class_1.prototype.getStretchedVariant = function (WH, exact) {
            var e_1, _a;
            if (exact === void 0) { exact = false; }
            if (this.stretch.dir !== 0) {
                var D = this.getWH(WH);
                var min = this.getSize('minsize', 0);
                var max = this.getSize('maxsize', Infinity);
                var mathaccent = this.node.getProperty('mathaccent');
                D = Math.max(min, Math.min(max, D));
                var df = this.font.params.delimiterfactor / 1000;
                var ds = this.font.params.delimitershortfall;
                var m = (min || exact ? D : mathaccent ? Math.min(D / df, D + ds) : Math.max(D * df, D - ds));
                var delim = this.stretch;
                var c = delim.c || this.getText().codePointAt(0);
                var i = 0;
                if (delim.sizes) {
                    try {
                        for (var _b = __values(delim.sizes), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var d = _c.value;
                            if (d >= m) {
                                if (mathaccent && i) {
                                    i--;
                                }
                                this.variant = this.font.getSizeVariant(c, i);
                                this.size = i;
                                if (delim.schar && delim.schar[i]) {
                                    this.stretch = __assign(__assign({}, this.stretch), { c: delim.schar[i] });
                                }
                                return;
                            }
                            i++;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                if (delim.stretch) {
                    this.size = -1;
                    this.invalidateBBox();
                    this.getStretchBBox(WH, this.checkExtendedHeight(D, delim), delim);
                }
                else {
                    this.variant = this.font.getSizeVariant(c, i - 1);
                    this.size = i - 1;
                }
            }
        };
        class_1.prototype.getSize = function (name, value) {
            var attributes = this.node.attributes;
            if (attributes.isSet(name)) {
                value = this.length2em(attributes.get(name), 1, 1);
            }
            return value;
        };
        class_1.prototype.getWH = function (WH) {
            if (WH.length === 0)
                return 0;
            if (WH.length === 1)
                return WH[0];
            var _a = __read(WH, 2), H = _a[0], D = _a[1];
            var a = this.font.params.axis_height;
            return (this.node.attributes.get('symmetric') ? 2 * Math.max(H - a, D + a) : H + D);
        };
        class_1.prototype.getStretchBBox = function (WHD, D, C) {
            var _a;
            if (C.hasOwnProperty('min') && C.min > D) {
                D = C.min;
            }
            var _b = __read(C.HDW, 3), h = _b[0], d = _b[1], w = _b[2];
            if (this.stretch.dir === 1) {
                _a = __read(this.getBaseline(WHD, D, C), 2), h = _a[0], d = _a[1];
            }
            else {
                w = D;
            }
            this.bbox.h = h;
            this.bbox.d = d;
            this.bbox.w = w;
        };
        class_1.prototype.getBaseline = function (WHD, HD, C) {
            var hasWHD = (WHD.length === 2 && WHD[0] + WHD[1] === HD);
            var symmetric = this.node.attributes.get('symmetric');
            var _a = __read((hasWHD ? WHD : [HD, 0]), 2), H = _a[0], D = _a[1];
            var _b = __read([H + D, 0], 2), h = _b[0], d = _b[1];
            if (symmetric) {
                var a = this.font.params.axis_height;
                if (hasWHD) {
                    h = 2 * Math.max(H - a, D + a);
                }
                d = h / 2 - a;
            }
            else if (hasWHD) {
                d = D;
            }
            else {
                var _c = __read((C.HDW || [.75, .25]), 2), ch = _c[0], cd = _c[1];
                d = cd * (h / (ch + cd));
            }
            return [h - d, d];
        };
        class_1.prototype.checkExtendedHeight = function (D, C) {
            if (C.fullExt) {
                var _a = __read(C.fullExt, 2), extSize = _a[0], endSize = _a[1];
                var n = Math.ceil(Math.max(0, D - endSize) / extSize);
                D = endSize + n * extSize;
            }
            return D;
        };
        class_1.prototype.remapChars = function (chars) {
            var primes = this.node.getProperty('primes');
            if (primes) {
                return (0, string_js_1.unicodeChars)(primes);
            }
            if (chars.length === 1) {
                var parent_1 = this.node.coreParent().parent;
                var isAccent = this.isAccent && !parent_1.isKind('mrow');
                var map = (isAccent ? 'accent' : 'mo');
                var text = this.font.getRemappedChar(map, chars[0]);
                if (text) {
                    chars = this.unicodeChars(text, this.variant);
                }
            }
            return chars;
        };
        return class_1;
    }(Base));
}
exports.CommonMoMixin = CommonMoMixin;
//# sourceMappingURL=mo.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mpadded.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mpadded.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMpaddedMixin = void 0;
function CommonMpaddedMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.getDimens = function () {
            var values = this.node.attributes.getList('width', 'height', 'depth', 'lspace', 'voffset');
            var bbox = this.childNodes[0].getBBox();
            var w = bbox.w, h = bbox.h, d = bbox.d;
            var W = w, H = h, D = d, x = 0, y = 0, dx = 0;
            if (values.width !== '')
                w = this.dimen(values.width, bbox, 'w', 0);
            if (values.height !== '')
                h = this.dimen(values.height, bbox, 'h', 0);
            if (values.depth !== '')
                d = this.dimen(values.depth, bbox, 'd', 0);
            if (values.voffset !== '')
                y = this.dimen(values.voffset, bbox);
            if (values.lspace !== '')
                x = this.dimen(values.lspace, bbox);
            var align = this.node.attributes.get('data-align');
            if (align) {
                dx = this.getAlignX(w, bbox, align);
            }
            return [H, D, W, h - H, d - D, w - W, x, y, dx];
        };
        class_1.prototype.dimen = function (length, bbox, d, m) {
            if (d === void 0) { d = ''; }
            if (m === void 0) { m = null; }
            length = String(length);
            var match = length.match(/width|height|depth/);
            var size = (match ? bbox[match[0].charAt(0)] :
                (d ? bbox[d] : 0));
            var dimen = (this.length2em(length, size) || 0);
            if (length.match(/^[-+]/) && d) {
                dimen += size;
            }
            if (m != null) {
                dimen = Math.max(m, dimen);
            }
            return dimen;
        };
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            var _a = __read(this.getDimens(), 6), H = _a[0], D = _a[1], W = _a[2], dh = _a[3], dd = _a[4], dw = _a[5];
            bbox.w = W + dw;
            bbox.h = H + dh;
            bbox.d = D + dd;
            this.setChildPWidths(recompute, bbox.w);
        };
        class_1.prototype.getWrapWidth = function (_i) {
            return this.getBBox().w;
        };
        class_1.prototype.getChildAlign = function (_i) {
            return this.node.attributes.get('data-align') || 'left';
        };
        return class_1;
    }(Base));
}
exports.CommonMpaddedMixin = CommonMpaddedMixin;
//# sourceMappingURL=mpadded.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mroot.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mroot.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMrootMixin = void 0;
function CommonMrootMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(class_1.prototype, "surd", {
            get: function () {
                return 2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "root", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.combineRootBBox = function (BBOX, sbox, H) {
            var bbox = this.childNodes[this.root].getOuterBBox();
            var h = this.getRootDimens(sbox, H)[1];
            BBOX.combine(bbox, 0, h);
        };
        class_1.prototype.getRootDimens = function (sbox, H) {
            var surd = this.childNodes[this.surd];
            var bbox = this.childNodes[this.root].getOuterBBox();
            var offset = (surd.size < 0 ? .5 : .6) * sbox.w;
            var w = bbox.w, rscale = bbox.rscale;
            var W = Math.max(w, offset / rscale);
            var dx = Math.max(0, W - w);
            var h = this.rootHeight(bbox, sbox, surd.size, H);
            var x = W * rscale - offset;
            return [x, h, dx];
        };
        class_1.prototype.rootHeight = function (rbox, sbox, size, H) {
            var h = sbox.h + sbox.d;
            var b = (size < 0 ? 1.9 : .55 * h) - (h - H);
            return b + Math.max(0, rbox.d * rbox.rscale);
        };
        return class_1;
    }(Base));
}
exports.CommonMrootMixin = CommonMrootMixin;
//# sourceMappingURL=mroot.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mrow.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mrow.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonInferredMrowMixin = exports.CommonMrowMixin = void 0;
var BBox_js_1 = __webpack_require__(/*! ../../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
function CommonMrowMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var e_1, _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.stretchChildren();
            try {
                for (var _b = __values(_this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (child.bbox.pwidth) {
                        _this.bbox.pwidth = BBox_js_1.BBox.fullWidth;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return _this;
        }
        Object.defineProperty(class_1.prototype, "fixesPWidth", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.stretchChildren = function () {
            var e_2, _a, e_3, _b, e_4, _c;
            var stretchy = [];
            try {
                for (var _d = __values(this.childNodes), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var child = _e.value;
                    if (child.canStretch(1)) {
                        stretchy.push(child);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var count = stretchy.length;
            var nodeCount = this.childNodes.length;
            if (count && nodeCount > 1) {
                var H = 0, D = 0;
                var all = (count > 1 && count === nodeCount);
                try {
                    for (var _f = __values(this.childNodes), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var child = _g.value;
                        var noStretch = (child.stretch.dir === 0);
                        if (all || noStretch) {
                            var _h = child.getOuterBBox(noStretch), h = _h.h, d = _h.d, rscale = _h.rscale;
                            h *= rscale;
                            d *= rscale;
                            if (h > H)
                                H = h;
                            if (d > D)
                                D = d;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                try {
                    for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {
                        var child = stretchy_1_1.value;
                        child.coreMO().getStretchedVariant([H, D]);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        };
        return class_1;
    }(Base));
}
exports.CommonMrowMixin = CommonMrowMixin;
function CommonInferredMrowMixin(Base) {
    return (function (_super) {
        __extends(class_2, _super);
        function class_2() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_2.prototype.getScale = function () {
            this.bbox.scale = this.parent.bbox.scale;
            this.bbox.rscale = 1;
        };
        return class_2;
    }(Base));
}
exports.CommonInferredMrowMixin = CommonInferredMrowMixin;
//# sourceMappingURL=mrow.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/ms.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/ms.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMsMixin = void 0;
function CommonMsMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            var attributes = _this.node.attributes;
            var quotes = attributes.getList('lquote', 'rquote');
            if (_this.variant !== 'monospace') {
                if (!attributes.isSet('lquote') && quotes.lquote === '"')
                    quotes.lquote = '\u201C';
                if (!attributes.isSet('rquote') && quotes.rquote === '"')
                    quotes.rquote = '\u201D';
            }
            _this.childNodes.unshift(_this.createText(quotes.lquote));
            _this.childNodes.push(_this.createText(quotes.rquote));
            return _this;
        }
        class_1.prototype.createText = function (text) {
            var node = this.wrap(this.mmlText(text));
            node.parent = this;
            return node;
        };
        return class_1;
    }(Base));
}
exports.CommonMsMixin = CommonMsMixin;
//# sourceMappingURL=ms.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mspace.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mspace.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMspaceMixin = void 0;
function CommonMspaceMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            if (_recompute === void 0) { _recompute = false; }
            var attributes = this.node.attributes;
            bbox.w = this.length2em(attributes.get('width'), 0);
            bbox.h = this.length2em(attributes.get('height'), 0);
            bbox.d = this.length2em(attributes.get('depth'), 0);
        };
        class_1.prototype.handleVariant = function () {
        };
        return class_1;
    }(Base));
}
exports.CommonMspaceMixin = CommonMspaceMixin;
//# sourceMappingURL=mspace.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/msqrt.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/msqrt.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMsqrtMixin = void 0;
var BBox_js_1 = __webpack_require__(/*! ../../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
function CommonMsqrtMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            var surd = _this.createMo('\u221A');
            surd.canStretch(1);
            var _a = _this.childNodes[_this.base].getOuterBBox(), h = _a.h, d = _a.d;
            var t = _this.font.params.rule_thickness;
            var p = (_this.node.attributes.get('displaystyle') ? _this.font.params.x_height : t);
            _this.surdH = h + d + 2 * t + p / 4;
            surd.getStretchedVariant([_this.surdH - d, d], true);
            return _this;
        }
        Object.defineProperty(class_1.prototype, "base", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "surd", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "root", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.createMo = function (text) {
            var node = _super.prototype.createMo.call(this, text);
            this.childNodes.push(node);
            return node;
        };
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            var surdbox = this.childNodes[this.surd].getBBox();
            var basebox = new BBox_js_1.BBox(this.childNodes[this.base].getOuterBBox());
            var q = this.getPQ(surdbox)[1];
            var t = this.font.params.rule_thickness;
            var H = basebox.h + q + t;
            var _a = __read(this.getRootDimens(surdbox, H), 1), x = _a[0];
            bbox.h = H + t;
            this.combineRootBBox(bbox, surdbox, H);
            bbox.combine(surdbox, x, H - surdbox.h);
            bbox.combine(basebox, x + surdbox.w, 0);
            bbox.clean();
            this.setChildPWidths(recompute);
        };
        class_1.prototype.combineRootBBox = function (_bbox, _sbox, _H) {
        };
        class_1.prototype.getPQ = function (sbox) {
            var t = this.font.params.rule_thickness;
            var p = (this.node.attributes.get('displaystyle') ? this.font.params.x_height : t);
            var q = (sbox.h + sbox.d > this.surdH ?
                ((sbox.h + sbox.d) - (this.surdH - 2 * t - p / 2)) / 2 :
                t + p / 4);
            return [p, q];
        };
        class_1.prototype.getRootDimens = function (_sbox, _H) {
            return [0, 0, 0, 0];
        };
        return class_1;
    }(Base));
}
exports.CommonMsqrtMixin = CommonMsqrtMixin;
//# sourceMappingURL=msqrt.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/msubsup.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/msubsup.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMsubsupMixin = exports.CommonMsupMixin = exports.CommonMsubMixin = void 0;
function CommonMsubMixin(Base) {
    var _a;
    return _a = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(class_1.prototype, "scriptChild", {
                get: function () {
                    return this.childNodes[this.node.sub];
                },
                enumerable: false,
                configurable: true
            });
            class_1.prototype.getOffset = function () {
                return [0, -this.getV()];
            };
            return class_1;
        }(Base)),
        _a.useIC = false,
        _a;
}
exports.CommonMsubMixin = CommonMsubMixin;
function CommonMsupMixin(Base) {
    return (function (_super) {
        __extends(class_2, _super);
        function class_2() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(class_2.prototype, "scriptChild", {
            get: function () {
                return this.childNodes[this.node.sup];
            },
            enumerable: false,
            configurable: true
        });
        class_2.prototype.getOffset = function () {
            var x = this.getAdjustedIc() - (this.baseRemoveIc ? 0 : this.baseIc);
            return [x, this.getU()];
        };
        return class_2;
    }(Base));
}
exports.CommonMsupMixin = CommonMsupMixin;
function CommonMsubsupMixin(Base) {
    var _a;
    return _a = (function (_super) {
            __extends(class_3, _super);
            function class_3() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.UVQ = null;
                return _this;
            }
            Object.defineProperty(class_3.prototype, "subChild", {
                get: function () {
                    return this.childNodes[this.node.sub];
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(class_3.prototype, "supChild", {
                get: function () {
                    return this.childNodes[this.node.sup];
                },
                enumerable: false,
                configurable: true
            });
            class_3.prototype.computeBBox = function (bbox, recompute) {
                if (recompute === void 0) { recompute = false; }
                var basebox = this.baseChild.getOuterBBox();
                var _a = __read([this.subChild.getOuterBBox(), this.supChild.getOuterBBox()], 2), subbox = _a[0], supbox = _a[1];
                bbox.empty();
                bbox.append(basebox);
                var w = this.getBaseWidth();
                var x = this.getAdjustedIc();
                var _b = __read(this.getUVQ(), 2), u = _b[0], v = _b[1];
                bbox.combine(subbox, w, v);
                bbox.combine(supbox, w + x, u);
                bbox.w += this.font.params.scriptspace;
                bbox.clean();
                this.setChildPWidths(recompute);
            };
            class_3.prototype.getUVQ = function (subbox, supbox) {
                if (subbox === void 0) { subbox = this.subChild.getOuterBBox(); }
                if (supbox === void 0) { supbox = this.supChild.getOuterBBox(); }
                var basebox = this.baseCore.getOuterBBox();
                if (this.UVQ)
                    return this.UVQ;
                var tex = this.font.params;
                var t = 3 * tex.rule_thickness;
                var subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub2);
                var drop = this.baseCharZero(basebox.d * this.baseScale + tex.sub_drop * subbox.rscale);
                var _a = __read([this.getU(), Math.max(drop, subscriptshift)], 2), u = _a[0], v = _a[1];
                var q = (u - supbox.d * supbox.rscale) - (subbox.h * subbox.rscale - v);
                if (q < t) {
                    v += t - q;
                    var p = (4 / 5) * tex.x_height - (u - supbox.d * supbox.rscale);
                    if (p > 0) {
                        u += p;
                        v -= p;
                    }
                }
                u = Math.max(this.length2em(this.node.attributes.get('superscriptshift'), u), u);
                v = Math.max(this.length2em(this.node.attributes.get('subscriptshift'), v), v);
                q = (u - supbox.d * supbox.rscale) - (subbox.h * subbox.rscale - v);
                this.UVQ = [u, -v, q];
                return this.UVQ;
            };
            return class_3;
        }(Base)),
        _a.useIC = false,
        _a;
}
exports.CommonMsubsupMixin = CommonMsubsupMixin;
//# sourceMappingURL=msubsup.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mtable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mtable.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMtableMixin = void 0;
var BBox_js_1 = __webpack_require__(/*! ../../../util/BBox.js */ "./node_modules/mathjax-full/js/util/BBox.js");
var string_js_1 = __webpack_require__(/*! ../../../util/string.js */ "./node_modules/mathjax-full/js/util/string.js");
var numeric_js_1 = __webpack_require__(/*! ../../../util/numeric.js */ "./node_modules/mathjax-full/js/util/numeric.js");
function CommonMtableMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.numCols = 0;
            _this.numRows = 0;
            _this.data = null;
            _this.pwidthCells = [];
            _this.pWidth = 0;
            _this.numCols = (0, numeric_js_1.max)(_this.tableRows.map(function (row) { return row.numCells; }));
            _this.numRows = _this.childNodes.length;
            _this.hasLabels = _this.childNodes.reduce(function (value, row) { return value || row.node.isKind('mlabeledtr'); }, false);
            _this.findContainer();
            _this.isTop = !_this.container || (_this.container.node.isKind('math') && !_this.container.parent);
            if (_this.isTop) {
                _this.jax.table = _this;
            }
            _this.getPercentageWidth();
            var attributes = _this.node.attributes;
            _this.frame = attributes.get('frame') !== 'none';
            _this.fLine = (_this.frame && attributes.get('frame') ? .07 : 0);
            _this.fSpace = (_this.frame ? _this.convertLengths(_this.getAttributeArray('framespacing')) : [0, 0]);
            _this.cSpace = _this.convertLengths(_this.getColumnAttributes('columnspacing'));
            _this.rSpace = _this.convertLengths(_this.getRowAttributes('rowspacing'));
            _this.cLines = _this.getColumnAttributes('columnlines').map(function (x) { return (x === 'none' ? 0 : .07); });
            _this.rLines = _this.getRowAttributes('rowlines').map(function (x) { return (x === 'none' ? 0 : .07); });
            _this.cWidths = _this.getColumnWidths();
            _this.stretchRows();
            _this.stretchColumns();
            return _this;
        }
        Object.defineProperty(class_1.prototype, "tableRows", {
            get: function () {
                return this.childNodes;
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.findContainer = function () {
            var node = this;
            var parent = node.parent;
            while (parent && (parent.node.notParent || parent.node.isKind('mrow'))) {
                node = parent;
                parent = parent.parent;
            }
            this.container = parent;
            this.containerI = node.node.childPosition();
        };
        class_1.prototype.getPercentageWidth = function () {
            if (this.hasLabels) {
                this.bbox.pwidth = BBox_js_1.BBox.fullWidth;
            }
            else {
                var width = this.node.attributes.get('width');
                if ((0, string_js_1.isPercent)(width)) {
                    this.bbox.pwidth = width;
                }
            }
        };
        class_1.prototype.stretchRows = function () {
            var equal = this.node.attributes.get('equalrows');
            var HD = (equal ? this.getEqualRowHeight() : 0);
            var _a = (equal ? this.getTableData() : { H: [0], D: [0] }), H = _a.H, D = _a.D;
            var rows = this.tableRows;
            for (var i = 0; i < this.numRows; i++) {
                var hd = (equal ? [(HD + H[i] - D[i]) / 2, (HD - H[i] + D[i]) / 2] : null);
                rows[i].stretchChildren(hd);
            }
        };
        class_1.prototype.stretchColumns = function () {
            for (var i = 0; i < this.numCols; i++) {
                var width = (typeof this.cWidths[i] === 'number' ? this.cWidths[i] : null);
                this.stretchColumn(i, width);
            }
        };
        class_1.prototype.stretchColumn = function (i, W) {
            var e_1, _a, e_2, _b, e_3, _c;
            var stretchy = [];
            try {
                for (var _d = __values(this.tableRows), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var row = _e.value;
                    var cell = row.getChild(i);
                    if (cell) {
                        var child = cell.childNodes[0];
                        if (child.stretch.dir === 0 &&
                            child.canStretch(2)) {
                            stretchy.push(child);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var count = stretchy.length;
            var nodeCount = this.childNodes.length;
            if (count && nodeCount > 1) {
                if (W === null) {
                    W = 0;
                    var all = (count > 1 && count === nodeCount);
                    try {
                        for (var _f = __values(this.tableRows), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var row = _g.value;
                            var cell = row.getChild(i);
                            if (cell) {
                                var child = cell.childNodes[0];
                                var noStretch = (child.stretch.dir === 0);
                                if (all || noStretch) {
                                    var w = child.getBBox(noStretch).w;
                                    if (w > W) {
                                        W = w;
                                    }
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                try {
                    for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {
                        var child = stretchy_1_1.value;
                        child.coreMO().getStretchedVariant([W]);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        };
        class_1.prototype.getTableData = function () {
            if (this.data) {
                return this.data;
            }
            var H = new Array(this.numRows).fill(0);
            var D = new Array(this.numRows).fill(0);
            var W = new Array(this.numCols).fill(0);
            var NH = new Array(this.numRows);
            var ND = new Array(this.numRows);
            var LW = [0];
            var rows = this.tableRows;
            for (var j = 0; j < rows.length; j++) {
                var M = 0;
                var row = rows[j];
                var align = row.node.attributes.get('rowalign');
                for (var i = 0; i < row.numCells; i++) {
                    var cell = row.getChild(i);
                    M = this.updateHDW(cell, i, j, align, H, D, W, M);
                    this.recordPWidthCell(cell, i);
                }
                NH[j] = H[j];
                ND[j] = D[j];
                if (row.labeled) {
                    M = this.updateHDW(row.childNodes[0], 0, j, align, H, D, LW, M);
                }
                this.extendHD(j, H, D, M);
                this.extendHD(j, NH, ND, M);
            }
            var L = LW[0];
            this.data = { H: H, D: D, W: W, NH: NH, ND: ND, L: L };
            return this.data;
        };
        class_1.prototype.updateHDW = function (cell, i, j, align, H, D, W, M) {
            var _a = cell.getBBox(), h = _a.h, d = _a.d, w = _a.w;
            var scale = cell.parent.bbox.rscale;
            if (cell.parent.bbox.rscale !== 1) {
                h *= scale;
                d *= scale;
                w *= scale;
            }
            if (this.node.getProperty('useHeight')) {
                if (h < .75)
                    h = .75;
                if (d < .25)
                    d = .25;
            }
            var m = 0;
            align = cell.node.attributes.get('rowalign') || align;
            if (align !== 'baseline' && align !== 'axis') {
                m = h + d;
                h = d = 0;
            }
            if (h > H[j])
                H[j] = h;
            if (d > D[j])
                D[j] = d;
            if (m > M)
                M = m;
            if (W && w > W[i])
                W[i] = w;
            return M;
        };
        class_1.prototype.extendHD = function (i, H, D, M) {
            var d = (M - (H[i] + D[i])) / 2;
            if (d < .00001)
                return;
            H[i] += d;
            D[i] += d;
        };
        class_1.prototype.recordPWidthCell = function (cell, i) {
            if (cell.childNodes[0] && cell.childNodes[0].getBBox().pwidth) {
                this.pwidthCells.push([cell, i]);
            }
        };
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            if (_recompute === void 0) { _recompute = false; }
            var _a = this.getTableData(), H = _a.H, D = _a.D;
            var height, width;
            if (this.node.attributes.get('equalrows')) {
                var HD = this.getEqualRowHeight();
                height = (0, numeric_js_1.sum)([].concat(this.rLines, this.rSpace)) + HD * this.numRows;
            }
            else {
                height = (0, numeric_js_1.sum)(H.concat(D, this.rLines, this.rSpace));
            }
            height += 2 * (this.fLine + this.fSpace[1]);
            var CW = this.getComputedWidths();
            width = (0, numeric_js_1.sum)(CW.concat(this.cLines, this.cSpace)) + 2 * (this.fLine + this.fSpace[0]);
            var w = this.node.attributes.get('width');
            if (w !== 'auto') {
                width = Math.max(this.length2em(w, 0) + 2 * this.fLine, width);
            }
            var _b = __read(this.getBBoxHD(height), 2), h = _b[0], d = _b[1];
            bbox.h = h;
            bbox.d = d;
            bbox.w = width;
            var _c = __read(this.getBBoxLR(), 2), L = _c[0], R = _c[1];
            bbox.L = L;
            bbox.R = R;
            if (!(0, string_js_1.isPercent)(w)) {
                this.setColumnPWidths();
            }
        };
        class_1.prototype.setChildPWidths = function (_recompute, cwidth, _clear) {
            var width = this.node.attributes.get('width');
            if (!(0, string_js_1.isPercent)(width))
                return false;
            if (!this.hasLabels) {
                this.bbox.pwidth = '';
                this.container.bbox.pwidth = '';
            }
            var _a = this.bbox, w = _a.w, L = _a.L, R = _a.R;
            var labelInWidth = this.node.attributes.get('data-width-includes-label');
            var W = Math.max(w, this.length2em(width, Math.max(cwidth, L + w + R))) - (labelInWidth ? L + R : 0);
            var cols = (this.node.attributes.get('equalcolumns') ?
                Array(this.numCols).fill(this.percent(1 / Math.max(1, this.numCols))) :
                this.getColumnAttributes('columnwidth', 0));
            this.cWidths = this.getColumnWidthsFixed(cols, W);
            var CW = this.getComputedWidths();
            this.pWidth = (0, numeric_js_1.sum)(CW.concat(this.cLines, this.cSpace)) + 2 * (this.fLine + this.fSpace[0]);
            if (this.isTop) {
                this.bbox.w = this.pWidth;
            }
            this.setColumnPWidths();
            if (this.pWidth !== w) {
                this.parent.invalidateBBox();
            }
            return this.pWidth !== w;
        };
        class_1.prototype.setColumnPWidths = function () {
            var e_4, _a;
            var W = this.cWidths;
            try {
                for (var _b = __values(this.pwidthCells), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), cell = _d[0], i = _d[1];
                    if (cell.setChildPWidths(false, W[i])) {
                        cell.invalidateBBox();
                        cell.getBBox();
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        class_1.prototype.getBBoxHD = function (height) {
            var _a = __read(this.getAlignmentRow(), 2), align = _a[0], row = _a[1];
            if (row === null) {
                var a = this.font.params.axis_height;
                var h2 = height / 2;
                var HD = {
                    top: [0, height],
                    center: [h2, h2],
                    bottom: [height, 0],
                    baseline: [h2, h2],
                    axis: [h2 + a, h2 - a]
                };
                return HD[align] || [h2, h2];
            }
            else {
                var y = this.getVerticalPosition(row, align);
                return [y, height - y];
            }
        };
        class_1.prototype.getBBoxLR = function () {
            if (this.hasLabels) {
                var attributes = this.node.attributes;
                var side = attributes.get('side');
                var _a = __read(this.getPadAlignShift(side), 2), pad = _a[0], align = _a[1];
                var labels = this.hasLabels && !!attributes.get('data-width-includes-label');
                if (labels && this.frame && this.fSpace[0]) {
                    pad -= this.fSpace[0];
                }
                return (align === 'center' && !labels ? [pad, pad] :
                    side === 'left' ? [pad, 0] : [0, pad]);
            }
            return [0, 0];
        };
        class_1.prototype.getPadAlignShift = function (side) {
            var L = this.getTableData().L;
            var sep = this.length2em(this.node.attributes.get('minlabelspacing'));
            var pad = L + sep;
            var _a = __read((this.styles == null ? ['', ''] :
                [this.styles.get('padding-left'), this.styles.get('padding-right')]), 2), lpad = _a[0], rpad = _a[1];
            if (lpad || rpad) {
                pad = Math.max(pad, this.length2em(lpad || '0'), this.length2em(rpad || '0'));
            }
            var _b = __read(this.getAlignShift(), 2), align = _b[0], shift = _b[1];
            if (align === side) {
                shift = (side === 'left' ? Math.max(pad, shift) - pad : Math.min(-pad, shift) + pad);
            }
            return [pad, align, shift];
        };
        class_1.prototype.getAlignShift = function () {
            return (this.isTop ? _super.prototype.getAlignShift.call(this) :
                [this.container.getChildAlign(this.containerI), 0]);
        };
        class_1.prototype.getWidth = function () {
            return this.pWidth || this.getBBox().w;
        };
        class_1.prototype.getEqualRowHeight = function () {
            var _a = this.getTableData(), H = _a.H, D = _a.D;
            var HD = Array.from(H.keys()).map(function (i) { return H[i] + D[i]; });
            return Math.max.apply(Math, HD);
        };
        class_1.prototype.getComputedWidths = function () {
            var _this = this;
            var W = this.getTableData().W;
            var CW = Array.from(W.keys()).map(function (i) {
                return (typeof _this.cWidths[i] === 'number' ? _this.cWidths[i] : W[i]);
            });
            if (this.node.attributes.get('equalcolumns')) {
                CW = Array(CW.length).fill((0, numeric_js_1.max)(CW));
            }
            return CW;
        };
        class_1.prototype.getColumnWidths = function () {
            var width = this.node.attributes.get('width');
            if (this.node.attributes.get('equalcolumns')) {
                return this.getEqualColumns(width);
            }
            var swidths = this.getColumnAttributes('columnwidth', 0);
            if (width === 'auto') {
                return this.getColumnWidthsAuto(swidths);
            }
            if ((0, string_js_1.isPercent)(width)) {
                return this.getColumnWidthsPercent(swidths);
            }
            return this.getColumnWidthsFixed(swidths, this.length2em(width));
        };
        class_1.prototype.getEqualColumns = function (width) {
            var n = Math.max(1, this.numCols);
            var cwidth;
            if (width === 'auto') {
                var W = this.getTableData().W;
                cwidth = (0, numeric_js_1.max)(W);
            }
            else if ((0, string_js_1.isPercent)(width)) {
                cwidth = this.percent(1 / n);
            }
            else {
                var w = (0, numeric_js_1.sum)([].concat(this.cLines, this.cSpace)) + 2 * this.fSpace[0];
                cwidth = Math.max(0, this.length2em(width) - w) / n;
            }
            return Array(this.numCols).fill(cwidth);
        };
        class_1.prototype.getColumnWidthsAuto = function (swidths) {
            var _this = this;
            return swidths.map(function (x) {
                if (x === 'auto' || x === 'fit')
                    return null;
                if ((0, string_js_1.isPercent)(x))
                    return x;
                return _this.length2em(x);
            });
        };
        class_1.prototype.getColumnWidthsPercent = function (swidths) {
            var _this = this;
            var hasFit = swidths.indexOf('fit') >= 0;
            var W = (hasFit ? this.getTableData() : { W: null }).W;
            return Array.from(swidths.keys()).map(function (i) {
                var x = swidths[i];
                if (x === 'fit')
                    return null;
                if (x === 'auto')
                    return (hasFit ? W[i] : null);
                if ((0, string_js_1.isPercent)(x))
                    return x;
                return _this.length2em(x);
            });
        };
        class_1.prototype.getColumnWidthsFixed = function (swidths, width) {
            var _this = this;
            var indices = Array.from(swidths.keys());
            var fit = indices.filter(function (i) { return swidths[i] === 'fit'; });
            var auto = indices.filter(function (i) { return swidths[i] === 'auto'; });
            var n = fit.length || auto.length;
            var W = (n ? this.getTableData() : { W: null }).W;
            var cwidth = width - (0, numeric_js_1.sum)([].concat(this.cLines, this.cSpace)) - 2 * this.fSpace[0];
            var dw = cwidth;
            indices.forEach(function (i) {
                var x = swidths[i];
                dw -= (x === 'fit' || x === 'auto' ? W[i] : _this.length2em(x, cwidth));
            });
            var fw = (n && dw > 0 ? dw / n : 0);
            return indices.map(function (i) {
                var x = swidths[i];
                if (x === 'fit')
                    return W[i] + fw;
                if (x === 'auto')
                    return W[i] + (fit.length === 0 ? fw : 0);
                return _this.length2em(x, cwidth);
            });
        };
        class_1.prototype.getVerticalPosition = function (i, align) {
            var equal = this.node.attributes.get('equalrows');
            var _a = this.getTableData(), H = _a.H, D = _a.D;
            var HD = (equal ? this.getEqualRowHeight() : 0);
            var space = this.getRowHalfSpacing();
            var y = this.fLine;
            for (var j = 0; j < i; j++) {
                y += space[j] + (equal ? HD : H[j] + D[j]) + space[j + 1] + this.rLines[j];
            }
            var _b = __read((equal ? [(HD + H[i] - D[i]) / 2, (HD - H[i] + D[i]) / 2] : [H[i], D[i]]), 2), h = _b[0], d = _b[1];
            var offset = {
                top: 0,
                center: space[i] + (h + d) / 2,
                bottom: space[i] + h + d + space[i + 1],
                baseline: space[i] + h,
                axis: space[i] + h - .25
            };
            y += offset[align] || 0;
            return y;
        };
        class_1.prototype.getEmHalfSpacing = function (fspace, space, scale) {
            if (scale === void 0) { scale = 1; }
            var fspaceEm = this.em(fspace * scale);
            var spaceEm = this.addEm(space, 2 / scale);
            spaceEm.unshift(fspaceEm);
            spaceEm.push(fspaceEm);
            return spaceEm;
        };
        class_1.prototype.getRowHalfSpacing = function () {
            var space = this.rSpace.map(function (x) { return x / 2; });
            space.unshift(this.fSpace[1]);
            space.push(this.fSpace[1]);
            return space;
        };
        class_1.prototype.getColumnHalfSpacing = function () {
            var space = this.cSpace.map(function (x) { return x / 2; });
            space.unshift(this.fSpace[0]);
            space.push(this.fSpace[0]);
            return space;
        };
        class_1.prototype.getAlignmentRow = function () {
            var _a = __read((0, string_js_1.split)(this.node.attributes.get('align')), 2), align = _a[0], row = _a[1];
            if (row == null)
                return [align, null];
            var i = parseInt(row);
            if (i < 0)
                i += this.numRows + 1;
            return [align, i < 1 || i > this.numRows ? null : i - 1];
        };
        class_1.prototype.getColumnAttributes = function (name, i) {
            if (i === void 0) { i = 1; }
            var n = this.numCols - i;
            var columns = this.getAttributeArray(name);
            if (columns.length === 0)
                return null;
            while (columns.length < n) {
                columns.push(columns[columns.length - 1]);
            }
            if (columns.length > n) {
                columns.splice(n);
            }
            return columns;
        };
        class_1.prototype.getRowAttributes = function (name, i) {
            if (i === void 0) { i = 1; }
            var n = this.numRows - i;
            var rows = this.getAttributeArray(name);
            if (rows.length === 0)
                return null;
            while (rows.length < n) {
                rows.push(rows[rows.length - 1]);
            }
            if (rows.length > n) {
                rows.splice(n);
            }
            return rows;
        };
        class_1.prototype.getAttributeArray = function (name) {
            var value = this.node.attributes.get(name);
            if (!value)
                return [this.node.attributes.getDefault(name)];
            return (0, string_js_1.split)(value);
        };
        class_1.prototype.addEm = function (list, n) {
            var _this = this;
            if (n === void 0) { n = 1; }
            if (!list)
                return null;
            return list.map(function (x) { return _this.em(x / n); });
        };
        class_1.prototype.convertLengths = function (list) {
            var _this = this;
            if (!list)
                return null;
            return list.map(function (x) { return _this.length2em(x); });
        };
        return class_1;
    }(Base));
}
exports.CommonMtableMixin = CommonMtableMixin;
//# sourceMappingURL=mtable.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mtd.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mtd.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMtdMixin = void 0;
function CommonMtdMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(class_1.prototype, "fixesPWidth", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.invalidateBBox = function () {
            this.bboxComputed = false;
        };
        class_1.prototype.getWrapWidth = function (_j) {
            var table = this.parent.parent;
            var row = this.parent;
            var i = this.node.childPosition() - (row.labeled ? 1 : 0);
            return (typeof (table.cWidths[i]) === 'number' ? table.cWidths[i] : table.getTableData().W[i]);
        };
        class_1.prototype.getChildAlign = function (_i) {
            return this.node.attributes.get('columnalign');
        };
        return class_1;
    }(Base));
}
exports.CommonMtdMixin = CommonMtdMixin;
//# sourceMappingURL=mtd.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mtext.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mtext.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMtextMixin = void 0;
function CommonMtextMixin(Base) {
    var _a;
    return _a = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.getVariant = function () {
                var options = this.jax.options;
                var data = this.jax.math.outputData;
                var merror = ((!!data.merrorFamily || !!options.merrorFont) && this.node.Parent.isKind('merror'));
                if (!!data.mtextFamily || !!options.mtextFont || merror) {
                    var variant = this.node.attributes.get('mathvariant');
                    var font = this.constructor.INHERITFONTS[variant] || this.jax.font.getCssFont(variant);
                    var family = font[0] || (merror ? data.merrorFamily || options.merrorFont :
                        data.mtextFamily || options.mtextFont);
                    this.variant = this.explicitVariant(family, font[2] ? 'bold' : '', font[1] ? 'italic' : '');
                    return;
                }
                _super.prototype.getVariant.call(this);
            };
            return class_1;
        }(Base)),
        _a.INHERITFONTS = {
            normal: ['', false, false],
            bold: ['', false, true],
            italic: ['', true, false],
            'bold-italic': ['', true, true]
        },
        _a;
}
exports.CommonMtextMixin = CommonMtextMixin;
//# sourceMappingURL=mtext.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/mtr.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/mtr.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMlabeledtrMixin = exports.CommonMtrMixin = void 0;
function CommonMtrMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(class_1.prototype, "fixesPWidth", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "numCells", {
            get: function () {
                return this.childNodes.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "labeled", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "tableCells", {
            get: function () {
                return this.childNodes;
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.getChild = function (i) {
            return this.childNodes[i];
        };
        class_1.prototype.getChildBBoxes = function () {
            return this.childNodes.map(function (cell) { return cell.getBBox(); });
        };
        class_1.prototype.stretchChildren = function (HD) {
            var e_1, _a, e_2, _b, e_3, _c;
            if (HD === void 0) { HD = null; }
            var stretchy = [];
            var children = (this.labeled ? this.childNodes.slice(1) : this.childNodes);
            try {
                for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                    var mtd = children_1_1.value;
                    var child = mtd.childNodes[0];
                    if (child.canStretch(1)) {
                        stretchy.push(child);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var count = stretchy.length;
            var nodeCount = this.childNodes.length;
            if (count && nodeCount > 1) {
                if (HD === null) {
                    var H = 0, D = 0;
                    var all = (count > 1 && count === nodeCount);
                    try {
                        for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
                            var mtd = children_2_1.value;
                            var child = mtd.childNodes[0];
                            var noStretch = (child.stretch.dir === 0);
                            if (all || noStretch) {
                                var _d = child.getBBox(noStretch), h = _d.h, d = _d.d;
                                if (h > H) {
                                    H = h;
                                }
                                if (d > D) {
                                    D = d;
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (children_2_1 && !children_2_1.done && (_b = children_2.return)) _b.call(children_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    HD = [H, D];
                }
                try {
                    for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {
                        var child = stretchy_1_1.value;
                        child.coreMO().getStretchedVariant(HD);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        };
        return class_1;
    }(Base));
}
exports.CommonMtrMixin = CommonMtrMixin;
function CommonMlabeledtrMixin(Base) {
    return (function (_super) {
        __extends(class_2, _super);
        function class_2() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(class_2.prototype, "numCells", {
            get: function () {
                return Math.max(0, this.childNodes.length - 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_2.prototype, "labeled", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_2.prototype, "tableCells", {
            get: function () {
                return this.childNodes.slice(1);
            },
            enumerable: false,
            configurable: true
        });
        class_2.prototype.getChild = function (i) {
            return this.childNodes[i + 1];
        };
        class_2.prototype.getChildBBoxes = function () {
            return this.childNodes.slice(1).map(function (cell) { return cell.getBBox(); });
        };
        return class_2;
    }(Base));
}
exports.CommonMlabeledtrMixin = CommonMlabeledtrMixin;
//# sourceMappingURL=mtr.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/munderover.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/munderover.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMunderoverMixin = exports.CommonMoverMixin = exports.CommonMunderMixin = void 0;
function CommonMunderMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.stretchChildren();
            return _this;
        }
        Object.defineProperty(class_1.prototype, "scriptChild", {
            get: function () {
                return this.childNodes[this.node.under];
            },
            enumerable: false,
            configurable: true
        });
        class_1.prototype.computeBBox = function (bbox, recompute) {
            if (recompute === void 0) { recompute = false; }
            if (this.hasMovableLimits()) {
                _super.prototype.computeBBox.call(this, bbox, recompute);
                return;
            }
            bbox.empty();
            var basebox = this.baseChild.getOuterBBox();
            var underbox = this.scriptChild.getOuterBBox();
            var v = this.getUnderKV(basebox, underbox)[1];
            var delta = (this.isLineBelow ? 0 : this.getDelta(true));
            var _a = __read(this.getDeltaW([basebox, underbox], [0, -delta]), 2), bw = _a[0], uw = _a[1];
            bbox.combine(basebox, bw, 0);
            bbox.combine(underbox, uw, v);
            bbox.d += this.font.params.big_op_spacing5;
            bbox.clean();
            this.setChildPWidths(recompute);
        };
        return class_1;
    }(Base));
}
exports.CommonMunderMixin = CommonMunderMixin;
function CommonMoverMixin(Base) {
    return (function (_super) {
        __extends(class_2, _super);
        function class_2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.stretchChildren();
            return _this;
        }
        Object.defineProperty(class_2.prototype, "scriptChild", {
            get: function () {
                return this.childNodes[this.node.over];
            },
            enumerable: false,
            configurable: true
        });
        class_2.prototype.computeBBox = function (bbox) {
            if (this.hasMovableLimits()) {
                _super.prototype.computeBBox.call(this, bbox);
                return;
            }
            bbox.empty();
            var basebox = this.baseChild.getOuterBBox();
            var overbox = this.scriptChild.getOuterBBox();
            if (this.node.attributes.get('accent')) {
                basebox.h = Math.max(basebox.h, this.font.params.x_height * basebox.scale);
            }
            var u = this.getOverKU(basebox, overbox)[1];
            var delta = (this.isLineAbove ? 0 : this.getDelta());
            var _a = __read(this.getDeltaW([basebox, overbox], [0, delta]), 2), bw = _a[0], ow = _a[1];
            bbox.combine(basebox, bw, 0);
            bbox.combine(overbox, ow, u);
            bbox.h += this.font.params.big_op_spacing5;
            bbox.clean();
        };
        return class_2;
    }(Base));
}
exports.CommonMoverMixin = CommonMoverMixin;
function CommonMunderoverMixin(Base) {
    return (function (_super) {
        __extends(class_3, _super);
        function class_3() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            _this.stretchChildren();
            return _this;
        }
        Object.defineProperty(class_3.prototype, "underChild", {
            get: function () {
                return this.childNodes[this.node.under];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_3.prototype, "overChild", {
            get: function () {
                return this.childNodes[this.node.over];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_3.prototype, "subChild", {
            get: function () {
                return this.underChild;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(class_3.prototype, "supChild", {
            get: function () {
                return this.overChild;
            },
            enumerable: false,
            configurable: true
        });
        class_3.prototype.computeBBox = function (bbox) {
            if (this.hasMovableLimits()) {
                _super.prototype.computeBBox.call(this, bbox);
                return;
            }
            bbox.empty();
            var overbox = this.overChild.getOuterBBox();
            var basebox = this.baseChild.getOuterBBox();
            var underbox = this.underChild.getOuterBBox();
            if (this.node.attributes.get('accent')) {
                basebox.h = Math.max(basebox.h, this.font.params.x_height * basebox.scale);
            }
            var u = this.getOverKU(basebox, overbox)[1];
            var v = this.getUnderKV(basebox, underbox)[1];
            var delta = this.getDelta();
            var _a = __read(this.getDeltaW([basebox, underbox, overbox], [0, this.isLineBelow ? 0 : -delta, this.isLineAbove ? 0 : delta]), 3), bw = _a[0], uw = _a[1], ow = _a[2];
            bbox.combine(basebox, bw, 0);
            bbox.combine(overbox, ow, u);
            bbox.combine(underbox, uw, v);
            var z = this.font.params.big_op_spacing5;
            bbox.h += z;
            bbox.d += z;
            bbox.clean();
        };
        return class_3;
    }(Base));
}
exports.CommonMunderoverMixin = CommonMunderoverMixin;
//# sourceMappingURL=munderover.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/scriptbase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/scriptbase.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonScriptbaseMixin = void 0;
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
function CommonScriptbaseMixin(Base) {
    var _a;
    return _a = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
                _this.baseScale = 1;
                _this.baseIc = 0;
                _this.baseRemoveIc = false;
                _this.baseIsChar = false;
                _this.baseHasAccentOver = null;
                _this.baseHasAccentUnder = null;
                _this.isLineAbove = false;
                _this.isLineBelow = false;
                _this.isMathAccent = false;
                var core = _this.baseCore = _this.getBaseCore();
                if (!core)
                    return _this;
                _this.setBaseAccentsFor(core);
                _this.baseScale = _this.getBaseScale();
                _this.baseIc = _this.getBaseIc();
                _this.baseIsChar = _this.isCharBase();
                _this.isMathAccent = _this.baseIsChar &&
                    (_this.scriptChild && !!_this.scriptChild.coreMO().node.getProperty('mathaccent'));
                _this.checkLineAccents();
                _this.baseRemoveIc = !_this.isLineAbove && !_this.isLineBelow &&
                    (!_this.constructor.useIC || _this.isMathAccent);
                return _this;
            }
            Object.defineProperty(class_1.prototype, "baseChild", {
                get: function () {
                    return this.childNodes[this.node.base];
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(class_1.prototype, "scriptChild", {
                get: function () {
                    return this.childNodes[1];
                },
                enumerable: false,
                configurable: true
            });
            class_1.prototype.getBaseCore = function () {
                var core = this.getSemanticBase() || this.childNodes[0];
                while (core &&
                    ((core.childNodes.length === 1 &&
                        (core.node.isKind('mrow') ||
                            (core.node.isKind('TeXAtom') && core.node.texClass !== MmlNode_js_1.TEXCLASS.VCENTER) ||
                            core.node.isKind('mstyle') || core.node.isKind('mpadded') ||
                            core.node.isKind('mphantom') || core.node.isKind('semantics'))) ||
                        (core.node.isKind('munderover') && core.isMathAccent))) {
                    this.setBaseAccentsFor(core);
                    core = core.childNodes[0];
                }
                if (!core) {
                    this.baseHasAccentOver = this.baseHasAccentUnder = false;
                }
                return core || this.childNodes[0];
            };
            class_1.prototype.setBaseAccentsFor = function (core) {
                if (core.node.isKind('munderover')) {
                    if (this.baseHasAccentOver === null) {
                        this.baseHasAccentOver = !!core.node.attributes.get('accent');
                    }
                    if (this.baseHasAccentUnder === null) {
                        this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');
                    }
                }
            };
            class_1.prototype.getSemanticBase = function () {
                var fence = this.node.attributes.getExplicit('data-semantic-fencepointer');
                return this.getBaseFence(this.baseChild, fence);
            };
            class_1.prototype.getBaseFence = function (fence, id) {
                var e_1, _a;
                if (!fence || !fence.node.attributes || !id) {
                    return null;
                }
                if (fence.node.attributes.getExplicit('data-semantic-id') === id) {
                    return fence;
                }
                try {
                    for (var _b = __values(fence.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        var result = this.getBaseFence(child, id);
                        if (result) {
                            return result;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return null;
            };
            class_1.prototype.getBaseScale = function () {
                var child = this.baseCore;
                var scale = 1;
                while (child && child !== this) {
                    var bbox = child.getOuterBBox();
                    scale *= bbox.rscale;
                    child = child.parent;
                }
                return scale;
            };
            class_1.prototype.getBaseIc = function () {
                return this.baseCore.getOuterBBox().ic * this.baseScale;
            };
            class_1.prototype.getAdjustedIc = function () {
                var bbox = this.baseCore.getOuterBBox();
                return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;
            };
            class_1.prototype.isCharBase = function () {
                var base = this.baseCore;
                return (((base.node.isKind('mo') && base.size === null) ||
                    base.node.isKind('mi') || base.node.isKind('mn')) &&
                    base.bbox.rscale === 1 && Array.from(base.getText()).length === 1);
            };
            class_1.prototype.checkLineAccents = function () {
                if (!this.node.isKind('munderover'))
                    return;
                if (this.node.isKind('mover')) {
                    this.isLineAbove = this.isLineAccent(this.scriptChild);
                }
                else if (this.node.isKind('munder')) {
                    this.isLineBelow = this.isLineAccent(this.scriptChild);
                }
                else {
                    var mml = this;
                    this.isLineAbove = this.isLineAccent(mml.overChild);
                    this.isLineBelow = this.isLineAccent(mml.underChild);
                }
            };
            class_1.prototype.isLineAccent = function (script) {
                var node = script.coreMO().node;
                return (node.isToken && node.getText() === '\u2015');
            };
            class_1.prototype.getBaseWidth = function () {
                var bbox = this.baseChild.getOuterBBox();
                return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;
            };
            class_1.prototype.computeBBox = function (bbox, recompute) {
                if (recompute === void 0) { recompute = false; }
                var w = this.getBaseWidth();
                var _a = __read(this.getOffset(), 2), x = _a[0], y = _a[1];
                bbox.append(this.baseChild.getOuterBBox());
                bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);
                bbox.w += this.font.params.scriptspace;
                bbox.clean();
                this.setChildPWidths(recompute);
            };
            class_1.prototype.getOffset = function () {
                return [0, 0];
            };
            class_1.prototype.baseCharZero = function (n) {
                var largeop = !!this.baseCore.node.attributes.get('largeop');
                var scale = this.baseScale;
                return (this.baseIsChar && !largeop && scale === 1 ? 0 : n);
            };
            class_1.prototype.getV = function () {
                var bbox = this.baseCore.getOuterBBox();
                var sbox = this.scriptChild.getOuterBBox();
                var tex = this.font.params;
                var subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);
                return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - (4 / 5) * tex.x_height);
            };
            class_1.prototype.getU = function () {
                var bbox = this.baseCore.getOuterBBox();
                var sbox = this.scriptChild.getOuterBBox();
                var tex = this.font.params;
                var attr = this.node.attributes.getList('displaystyle', 'superscriptshift');
                var prime = this.node.getProperty('texprimestyle');
                var p = prime ? tex.sup3 : (attr.displaystyle ? tex.sup1 : tex.sup2);
                var superscriptshift = this.length2em(attr.superscriptshift, p);
                return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + (1 / 4) * tex.x_height);
            };
            class_1.prototype.hasMovableLimits = function () {
                var display = this.node.attributes.get('displaystyle');
                var mo = this.baseChild.coreMO().node;
                return (!display && !!mo.attributes.get('movablelimits'));
            };
            class_1.prototype.getOverKU = function (basebox, overbox) {
                var accent = this.node.attributes.get('accent');
                var tex = this.font.params;
                var d = overbox.d * overbox.rscale;
                var t = tex.rule_thickness * tex.separation_factor;
                var delta = (this.baseHasAccentOver ? t : 0);
                var T = (this.isLineAbove ? 3 * tex.rule_thickness : t);
                var k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;
                return [k, basebox.h * basebox.rscale + k + d];
            };
            class_1.prototype.getUnderKV = function (basebox, underbox) {
                var accent = this.node.attributes.get('accentunder');
                var tex = this.font.params;
                var h = underbox.h * underbox.rscale;
                var t = tex.rule_thickness * tex.separation_factor;
                var delta = (this.baseHasAccentUnder ? t : 0);
                var T = (this.isLineBelow ? 3 * tex.rule_thickness : t);
                var k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;
                return [k, -(basebox.d * basebox.rscale + k + h)];
            };
            class_1.prototype.getDeltaW = function (boxes, delta) {
                var e_2, _a, e_3, _b;
                if (delta === void 0) { delta = [0, 0, 0]; }
                var align = this.node.attributes.get('align');
                var widths = boxes.map(function (box) { return box.w * box.rscale; });
                widths[0] -= (this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0);
                var w = Math.max.apply(Math, __spreadArray([], __read(widths), false));
                var dw = [];
                var m = 0;
                try {
                    for (var _c = __values(widths.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var i = _d.value;
                        dw[i] = (align === 'center' ? (w - widths[i]) / 2 :
                            align === 'right' ? w - widths[i] : 0) + delta[i];
                        if (dw[i] < m) {
                            m = -dw[i];
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (m) {
                    try {
                        for (var _e = __values(dw.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var i = _f.value;
                            dw[i] += m;
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
                [1, 2].map(function (i) { return dw[i] += (boxes[i] ? boxes[i].dx * boxes[0].scale : 0); });
                return dw;
            };
            class_1.prototype.getDelta = function (noskew) {
                if (noskew === void 0) { noskew = false; }
                var accent = this.node.attributes.get('accent');
                var _a = this.baseCore.getOuterBBox(), sk = _a.sk, ic = _a.ic;
                return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;
            };
            class_1.prototype.stretchChildren = function () {
                var e_4, _a, e_5, _b, e_6, _c;
                var stretchy = [];
                try {
                    for (var _d = __values(this.childNodes), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var child = _e.value;
                        if (child.canStretch(2)) {
                            stretchy.push(child);
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                var count = stretchy.length;
                var nodeCount = this.childNodes.length;
                if (count && nodeCount > 1) {
                    var W = 0;
                    var all = (count > 1 && count === nodeCount);
                    try {
                        for (var _f = __values(this.childNodes), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var child = _g.value;
                            var noStretch = (child.stretch.dir === 0);
                            if (all || noStretch) {
                                var _h = child.getOuterBBox(noStretch), w = _h.w, rscale = _h.rscale;
                                if (w * rscale > W)
                                    W = w * rscale;
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    try {
                        for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {
                            var child = stretchy_1_1.value;
                            child.coreMO().getStretchedVariant([W / child.bbox.rscale]);
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            };
            return class_1;
        }(Base)),
        _a.useIC = true,
        _a;
}
exports.CommonScriptbaseMixin = CommonScriptbaseMixin;
//# sourceMappingURL=scriptbase.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/output/common/Wrappers/semantics.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/output/common/Wrappers/semantics.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonSemanticsMixin = void 0;
function CommonSemanticsMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.computeBBox = function (bbox, _recompute) {
            if (_recompute === void 0) { _recompute = false; }
            if (this.childNodes.length) {
                var _a = this.childNodes[0].getBBox(), w = _a.w, h = _a.h, d = _a.d;
                bbox.w = w;
                bbox.h = h;
                bbox.d = d;
            }
        };
        return class_1;
    }(Base));
}
exports.CommonSemanticsMixin = CommonSemanticsMixin;
//# sourceMappingURL=semantics.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/BBox.js":
/*!***************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/BBox.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BBox = void 0;
var lengths_js_1 = __webpack_require__(/*! ./lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
var BBox = (function () {
    function BBox(def) {
        if (def === void 0) { def = { w: 0, h: -lengths_js_1.BIGDIMEN, d: -lengths_js_1.BIGDIMEN }; }
        this.w = def.w || 0;
        this.h = ('h' in def ? def.h : -lengths_js_1.BIGDIMEN);
        this.d = ('d' in def ? def.d : -lengths_js_1.BIGDIMEN);
        this.L = this.R = this.ic = this.sk = this.dx = 0;
        this.scale = this.rscale = 1;
        this.pwidth = '';
    }
    BBox.zero = function () {
        return new BBox({ h: 0, d: 0, w: 0 });
    };
    BBox.empty = function () {
        return new BBox();
    };
    BBox.prototype.empty = function () {
        this.w = 0;
        this.h = this.d = -lengths_js_1.BIGDIMEN;
        return this;
    };
    BBox.prototype.clean = function () {
        if (this.w === -lengths_js_1.BIGDIMEN)
            this.w = 0;
        if (this.h === -lengths_js_1.BIGDIMEN)
            this.h = 0;
        if (this.d === -lengths_js_1.BIGDIMEN)
            this.d = 0;
    };
    BBox.prototype.rescale = function (scale) {
        this.w *= scale;
        this.h *= scale;
        this.d *= scale;
    };
    BBox.prototype.combine = function (cbox, x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        var rscale = cbox.rscale;
        var w = x + rscale * (cbox.w + cbox.L + cbox.R);
        var h = y + rscale * cbox.h;
        var d = rscale * cbox.d - y;
        if (w > this.w)
            this.w = w;
        if (h > this.h)
            this.h = h;
        if (d > this.d)
            this.d = d;
    };
    BBox.prototype.append = function (cbox) {
        var scale = cbox.rscale;
        this.w += scale * (cbox.w + cbox.L + cbox.R);
        if (scale * cbox.h > this.h) {
            this.h = scale * cbox.h;
        }
        if (scale * cbox.d > this.d) {
            this.d = scale * cbox.d;
        }
    };
    BBox.prototype.updateFrom = function (cbox) {
        this.h = cbox.h;
        this.d = cbox.d;
        this.w = cbox.w;
        if (cbox.pwidth) {
            this.pwidth = cbox.pwidth;
        }
    };
    BBox.fullWidth = '100%';
    BBox.StyleAdjust = [
        ['borderTopWidth', 'h'],
        ['borderRightWidth', 'w'],
        ['borderBottomWidth', 'd'],
        ['borderLeftWidth', 'w', 0],
        ['paddingTop', 'h'],
        ['paddingRight', 'w'],
        ['paddingBottom', 'd'],
        ['paddingLeft', 'w', 0]
    ];
    return BBox;
}());
exports.BBox = BBox;
//# sourceMappingURL=BBox.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/FunctionList.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/FunctionList.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionList = void 0;
var PrioritizedList_js_1 = __webpack_require__(/*! ./PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var FunctionList = (function (_super) {
    __extends(FunctionList, _super);
    function FunctionList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionList.prototype.execute = function () {
        var e_1, _a;
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                var result = item.item.apply(item, __spreadArray([], __read(data), false));
                if (result === false) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    FunctionList.prototype.asyncExecute = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        var i = -1;
        var items = this.items;
        return new Promise(function (ok, fail) {
            (function execute() {
                var _a;
                while (++i < items.length) {
                    var result = (_a = items[i]).item.apply(_a, __spreadArray([], __read(data), false));
                    if (result instanceof Promise) {
                        result.then(execute).catch(function (err) { return fail(err); });
                        return;
                    }
                    if (result === false) {
                        ok(false);
                        return;
                    }
                }
                ok(true);
            })();
        });
    };
    return FunctionList;
}(PrioritizedList_js_1.PrioritizedList));
exports.FunctionList = FunctionList;
//# sourceMappingURL=FunctionList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/PrioritizedList.js":
/*!**************************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/PrioritizedList.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrioritizedList = void 0;
var PrioritizedList = (function () {
    function PrioritizedList() {
        this.items = [];
        this.items = [];
    }
    PrioritizedList.prototype[Symbol.iterator] = function () {
        var i = 0;
        var items = this.items;
        return {
            next: function () {
                return { value: items[i++], done: (i > items.length) };
            }
        };
    };
    PrioritizedList.prototype.add = function (item, priority) {
        if (priority === void 0) { priority = PrioritizedList.DEFAULTPRIORITY; }
        var i = this.items.length;
        do {
            i--;
        } while (i >= 0 && priority < this.items[i].priority);
        this.items.splice(i + 1, 0, { item: item, priority: priority });
        return item;
    };
    PrioritizedList.prototype.remove = function (item) {
        var i = this.items.length;
        do {
            i--;
        } while (i >= 0 && this.items[i].item !== item);
        if (i >= 0) {
            this.items.splice(i, 1);
        }
    };
    PrioritizedList.DEFAULTPRIORITY = 5;
    return PrioritizedList;
}());
exports.PrioritizedList = PrioritizedList;
//# sourceMappingURL=PrioritizedList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/StyleList.js":
/*!********************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/StyleList.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CssStyles = void 0;
var CssStyles = (function () {
    function CssStyles(styles) {
        if (styles === void 0) { styles = null; }
        this.styles = {};
        this.addStyles(styles);
    }
    Object.defineProperty(CssStyles.prototype, "cssText", {
        get: function () {
            return this.getStyleString();
        },
        enumerable: false,
        configurable: true
    });
    CssStyles.prototype.addStyles = function (styles) {
        var e_1, _a;
        if (!styles)
            return;
        try {
            for (var _b = __values(Object.keys(styles)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var style = _c.value;
                if (!this.styles[style]) {
                    this.styles[style] = {};
                }
                Object.assign(this.styles[style], styles[style]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    CssStyles.prototype.removeStyles = function () {
        var e_2, _a;
        var selectors = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selectors[_i] = arguments[_i];
        }
        try {
            for (var selectors_1 = __values(selectors), selectors_1_1 = selectors_1.next(); !selectors_1_1.done; selectors_1_1 = selectors_1.next()) {
                var selector = selectors_1_1.value;
                delete this.styles[selector];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (selectors_1_1 && !selectors_1_1.done && (_a = selectors_1.return)) _a.call(selectors_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    CssStyles.prototype.clear = function () {
        this.styles = {};
    };
    CssStyles.prototype.getStyleString = function () {
        return this.getStyleRules().join('\n\n');
    };
    CssStyles.prototype.getStyleRules = function () {
        var e_3, _a;
        var selectors = Object.keys(this.styles);
        var defs = new Array(selectors.length);
        var i = 0;
        try {
            for (var selectors_2 = __values(selectors), selectors_2_1 = selectors_2.next(); !selectors_2_1.done; selectors_2_1 = selectors_2.next()) {
                var selector = selectors_2_1.value;
                defs[i++] = selector + ' {\n' + this.getStyleDefString(this.styles[selector]) + '\n}';
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (selectors_2_1 && !selectors_2_1.done && (_a = selectors_2.return)) _a.call(selectors_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return defs;
    };
    CssStyles.prototype.getStyleDefString = function (styles) {
        var e_4, _a;
        var properties = Object.keys(styles);
        var values = new Array(properties.length);
        var i = 0;
        try {
            for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                var property = properties_1_1.value;
                values[i++] = '  ' + property + ': ' + styles[property] + ';';
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return)) _a.call(properties_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return values.join('\n');
    };
    return CssStyles;
}());
exports.CssStyles = CssStyles;
//# sourceMappingURL=StyleList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/Styles.js":
/*!*****************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/Styles.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Styles = void 0;
var TRBL = ['top', 'right', 'bottom', 'left'];
var WSC = ['width', 'style', 'color'];
function splitSpaces(text) {
    var parts = text.split(/((?:'[^']*'|"[^"]*"|,[\s\n]|[^\s\n])*)/g);
    var split = [];
    while (parts.length > 1) {
        parts.shift();
        split.push(parts.shift());
    }
    return split;
}
function splitTRBL(name) {
    var e_1, _a;
    var parts = splitSpaces(this.styles[name]);
    if (parts.length === 0) {
        parts.push('');
    }
    if (parts.length === 1) {
        parts.push(parts[0]);
    }
    if (parts.length === 2) {
        parts.push(parts[0]);
    }
    if (parts.length === 3) {
        parts.push(parts[1]);
    }
    try {
        for (var _b = __values(Styles.connect[name].children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            this.setStyle(this.childName(name, child), parts.shift());
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function combineTRBL(name) {
    var e_2, _a;
    var children = Styles.connect[name].children;
    var parts = [];
    try {
        for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
            var child = children_1_1.value;
            var part = this.styles[name + '-' + child];
            if (!part) {
                delete this.styles[name];
                return;
            }
            parts.push(part);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (parts[3] === parts[1]) {
        parts.pop();
        if (parts[2] === parts[0]) {
            parts.pop();
            if (parts[1] === parts[0]) {
                parts.pop();
            }
        }
    }
    this.styles[name] = parts.join(' ');
}
function splitSame(name) {
    var e_3, _a;
    try {
        for (var _b = __values(Styles.connect[name].children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            this.setStyle(this.childName(name, child), this.styles[name]);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
function combineSame(name) {
    var e_4, _a;
    var children = __spreadArray([], __read(Styles.connect[name].children), false);
    var value = this.styles[this.childName(name, children.shift())];
    try {
        for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
            var child = children_2_1.value;
            if (this.styles[this.childName(name, child)] !== value) {
                delete this.styles[name];
                return;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (children_2_1 && !children_2_1.done && (_a = children_2.return)) _a.call(children_2);
        }
        finally { if (e_4) throw e_4.error; }
    }
    this.styles[name] = value;
}
var BORDER = {
    width: /^(?:[\d.]+(?:[a-z]+)|thin|medium|thick|inherit|initial|unset)$/,
    style: /^(?:none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset|inherit|initial|unset)$/
};
function splitWSC(name) {
    var e_5, _a, e_6, _b;
    var parts = { width: '', style: '', color: '' };
    try {
        for (var _c = __values(splitSpaces(this.styles[name])), _d = _c.next(); !_d.done; _d = _c.next()) {
            var part = _d.value;
            if (part.match(BORDER.width) && parts.width === '') {
                parts.width = part;
            }
            else if (part.match(BORDER.style) && parts.style === '') {
                parts.style = part;
            }
            else {
                parts.color = part;
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_5) throw e_5.error; }
    }
    try {
        for (var _e = __values(Styles.connect[name].children), _f = _e.next(); !_f.done; _f = _e.next()) {
            var child = _f.value;
            this.setStyle(this.childName(name, child), parts[child]);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_6) throw e_6.error; }
    }
}
function combineWSC(name) {
    var e_7, _a;
    var parts = [];
    try {
        for (var _b = __values(Styles.connect[name].children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var value = this.styles[this.childName(name, child)];
            if (value) {
                parts.push(value);
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_7) throw e_7.error; }
    }
    if (parts.length) {
        this.styles[name] = parts.join(' ');
    }
    else {
        delete this.styles[name];
    }
}
var FONT = {
    style: /^(?:normal|italic|oblique|inherit|initial|unset)$/,
    variant: new RegExp('^(?:' +
        ['normal|none',
            'inherit|initial|unset',
            'common-ligatures|no-common-ligatures',
            'discretionary-ligatures|no-discretionary-ligatures',
            'historical-ligatures|no-historical-ligatures',
            'contextual|no-contextual',
            '(?:stylistic|character-variant|swash|ornaments|annotation)\\([^)]*\\)',
            'small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps',
            'lining-nums|oldstyle-nums|proportional-nums|tabular-nums',
            'diagonal-fractions|stacked-fractions',
            'ordinal|slashed-zero',
            'jis78|jis83|jis90|jis04|simplified|traditional',
            'full-width|proportional-width',
            'ruby'].join('|') + ')$'),
    weight: /^(?:normal|bold|bolder|lighter|[1-9]00|inherit|initial|unset)$/,
    stretch: new RegExp('^(?:' +
        ['normal',
            '(?:(?:ultra|extra|semi)-)?condensed',
            '(?:(?:semi|extra|ulta)-)?expanded',
            'inherit|initial|unset'].join('|') + ')$'),
    size: new RegExp('^(?:' +
        ['xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller',
            '[\d.]+%|[\d.]+[a-z]+',
            'inherit|initial|unset'].join('|') + ')' +
        '(?:\/(?:normal|[\d.\+](?:%|[a-z]+)?))?$')
};
function splitFont(name) {
    var e_8, _a, e_9, _b;
    var parts = splitSpaces(this.styles[name]);
    var value = {
        style: '', variant: [], weight: '', stretch: '',
        size: '', family: '', 'line-height': ''
    };
    try {
        for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
            var part = parts_1_1.value;
            value.family = part;
            try {
                for (var _c = (e_9 = void 0, __values(Object.keys(FONT))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var name_1 = _d.value;
                    if ((Array.isArray(value[name_1]) || value[name_1] === '') && part.match(FONT[name_1])) {
                        if (name_1 === 'size') {
                            var _e = __read(part.split(/\//), 2), size = _e[0], height = _e[1];
                            value[name_1] = size;
                            if (height) {
                                value['line-height'] = height;
                            }
                        }
                        else if (value.size === '') {
                            if (Array.isArray(value[name_1])) {
                                value[name_1].push(part);
                            }
                            else {
                                value[name_1] = part;
                            }
                        }
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_9) throw e_9.error; }
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    saveFontParts(name, value);
    delete this.styles[name];
}
function saveFontParts(name, value) {
    var e_10, _a;
    try {
        for (var _b = __values(Styles.connect[name].children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var cname = this.childName(name, child);
            if (Array.isArray(value[child])) {
                var values = value[child];
                if (values.length) {
                    this.styles[cname] = values.join(' ');
                }
            }
            else if (value[child] !== '') {
                this.styles[cname] = value[child];
            }
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_10) throw e_10.error; }
    }
}
function combineFont(_name) { }
var Styles = (function () {
    function Styles(cssText) {
        if (cssText === void 0) { cssText = ''; }
        this.parse(cssText);
    }
    Object.defineProperty(Styles.prototype, "cssText", {
        get: function () {
            var e_11, _a;
            var styles = [];
            try {
                for (var _b = __values(Object.keys(this.styles)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var name_2 = _c.value;
                    var parent_1 = this.parentName(name_2);
                    if (!this.styles[parent_1]) {
                        styles.push(name_2 + ': ' + this.styles[name_2] + ';');
                    }
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_11) throw e_11.error; }
            }
            return styles.join(' ');
        },
        enumerable: false,
        configurable: true
    });
    Styles.prototype.set = function (name, value) {
        name = this.normalizeName(name);
        this.setStyle(name, value);
        if (Styles.connect[name] && !Styles.connect[name].combine) {
            this.combineChildren(name);
            delete this.styles[name];
        }
        while (name.match(/-/)) {
            name = this.parentName(name);
            if (!Styles.connect[name])
                break;
            Styles.connect[name].combine.call(this, name);
        }
    };
    Styles.prototype.get = function (name) {
        name = this.normalizeName(name);
        return (this.styles.hasOwnProperty(name) ? this.styles[name] : '');
    };
    Styles.prototype.setStyle = function (name, value) {
        this.styles[name] = value;
        if (Styles.connect[name] && Styles.connect[name].children) {
            Styles.connect[name].split.call(this, name);
        }
        if (value === '') {
            delete this.styles[name];
        }
    };
    Styles.prototype.combineChildren = function (name) {
        var e_12, _a;
        var parent = this.parentName(name);
        try {
            for (var _b = __values(Styles.connect[name].children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var cname = this.childName(parent, child);
                Styles.connect[cname].combine.call(this, cname);
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_12) throw e_12.error; }
        }
    };
    Styles.prototype.parentName = function (name) {
        var parent = name.replace(/-[^-]*$/, '');
        return (name === parent ? '' : parent);
    };
    Styles.prototype.childName = function (name, child) {
        if (child.match(/-/)) {
            return child;
        }
        if (Styles.connect[name] && !Styles.connect[name].combine) {
            child += name.replace(/.*-/, '-');
            name = this.parentName(name);
        }
        return name + '-' + child;
    };
    Styles.prototype.normalizeName = function (name) {
        return name.replace(/[A-Z]/g, function (c) { return '-' + c.toLowerCase(); });
    };
    Styles.prototype.parse = function (cssText) {
        if (cssText === void 0) { cssText = ''; }
        var PATTERN = this.constructor.pattern;
        this.styles = {};
        var parts = cssText.replace(PATTERN.comment, '').split(PATTERN.style);
        while (parts.length > 1) {
            var _a = __read(parts.splice(0, 3), 3), space = _a[0], name_3 = _a[1], value = _a[2];
            if (space.match(/[^\s\n]/))
                return;
            this.set(name_3, value);
        }
    };
    Styles.pattern = {
        style: /([-a-z]+)[\s\n]*:[\s\n]*((?:'[^']*'|"[^"]*"|\n|.)*?)[\s\n]*(?:;|$)/g,
        comment: /\/\*[^]*?\*\//g
    };
    Styles.connect = {
        padding: {
            children: TRBL,
            split: splitTRBL,
            combine: combineTRBL
        },
        border: {
            children: TRBL,
            split: splitSame,
            combine: combineSame
        },
        'border-top': {
            children: WSC,
            split: splitWSC,
            combine: combineWSC
        },
        'border-right': {
            children: WSC,
            split: splitWSC,
            combine: combineWSC
        },
        'border-bottom': {
            children: WSC,
            split: splitWSC,
            combine: combineWSC
        },
        'border-left': {
            children: WSC,
            split: splitWSC,
            combine: combineWSC
        },
        'border-width': {
            children: TRBL,
            split: splitTRBL,
            combine: null
        },
        'border-style': {
            children: TRBL,
            split: splitTRBL,
            combine: null
        },
        'border-color': {
            children: TRBL,
            split: splitTRBL,
            combine: null
        },
        font: {
            children: ['style', 'variant', 'weight', 'stretch', 'line-height', 'size', 'family'],
            split: splitFont,
            combine: combineFont
        }
    };
    return Styles;
}());
exports.Styles = Styles;
//# sourceMappingURL=Styles.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/numeric.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/numeric.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.max = exports.sum = void 0;
function sum(A) {
    return A.reduce(function (a, b) { return a + b; }, 0);
}
exports.sum = sum;
function max(A) {
    return A.reduce(function (a, b) { return Math.max(a, b); }, 0);
}
exports.max = max;
//# sourceMappingURL=numeric.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX291dHB1dF9jaHRtbF9qcy4xYTc2ZmQxYmRmMWY1MTYyOTBmZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsbUJBQW1CLG1CQUFPLENBQUMsMEVBQW9CO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLG9GQUF5QjtBQUN6RDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6Qjs7Ozs7Ozs7OztBQ2pEYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2Qjs7Ozs7Ozs7OztBQ3JCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UscUJBQXFCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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LHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLDJEQUEyRCxTQUFTLHNCQUFzQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7QUNqaUJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBZTtBQUMxQyxlQUFlLG1CQUFPLENBQUMsa0dBQThCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCOzs7Ozs7Ozs7O0FDL0ZhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxzR0FBZ0M7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsOEdBQXlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjs7Ozs7Ozs7OztBQzlCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsNkVBQWU7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGtHQUE4QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsa0dBQThCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGtCQUFrQixJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7O0FDdEdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQjtBQUNsRSxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBYztBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyxnSEFBcUM7QUFDbkUsc0JBQXNCLG1CQUFPLENBQUMsZ0hBQXFDO0FBQ25FLHNCQUFzQixtQkFBTyxDQUFDLGdIQUFxQztBQUNuRSxzQkFBc0IsbUJBQU8sQ0FBQyx3SEFBOEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7O0FDdkphO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLGdIQUFxQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsY0FBYztBQUN6RztBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUywyQ0FBMkM7QUFDN0Y7QUFDQSxtR0FBbUcsVUFBVTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7O0FDOUdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLHNCQUFzQjtBQUNoRyxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBZTtBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyw4R0FBb0M7QUFDakUscUJBQXFCLG1CQUFPLENBQUMsc0hBQTZDO0FBQzFFLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0I7QUFDaEI7Ozs7Ozs7Ozs7QUMxRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsY0FBYztBQUNoZCxjQUFjLE1BQU0sZUFBZSxNQUFNLGNBQWM7QUFDdkQsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixhQUFhO0FBQ2IsaUJBQWlCLEtBQUs7QUFDdEIsaUJBQWlCO0FBQ2pCLGdCQUFnQixzQkFBc0IsMERBQTBEO0FBQ2hHLG1CQUFtQixzQkFBc0IseUNBQXlDO0FBQ2xGLGtCQUFrQixzQkFBc0IsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwwQkFBMEIsMkZBQTJGO0FBQ3JILDRCQUE0QiwyRkFBMkY7QUFDdkgsNkJBQTZCLDRGQUE0RjtBQUN6SCw0QkFBNEIsNEZBQTRGO0FBQ3hILDhCQUE4QiwyR0FBMkc7QUFDekksaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7Ozs7Ozs7OztBQ25LYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLHFCQUFxQixtQkFBTyxDQUFDLGlGQUF5QjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBd0I7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQXVCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDZFQUF1QjtBQUNsRCxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBc0I7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsaUZBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBLCtGQUErRixVQUFVO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQSxpR0FBaUcsVUFBVTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTLDJCQUEyQjtBQUN2RiwrQ0FBK0MsU0FBUyxnREFBZ0Q7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwrQ0FBK0MsdUpBQXVKLCtHQUErRztBQUN2VztBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2Qjs7Ozs7Ozs7OztBQzlhYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUE0QjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBK0I7QUFDMUQsa0JBQWtCLG1CQUFPLENBQUMsMkVBQXNCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLDZFQUF1QjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBc0I7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQW9CO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLCtFQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsVUFBVTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLHFFQUFxRSxVQUFVO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxVQUFVO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFVBQVU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxtQkFBbUIsbUJBQW1CO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7Ozs7Ozs7Ozs7QUN4ZWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLFdBQVc7QUFDekI7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBLFdBQVc7QUFDWDtBQUNBLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQSxXQUFXO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvT3V0cHV0SmF4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29yZS9UcmVlL1dyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9jb3JlL1RyZWUvV3JhcHBlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvTm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9UZVhBdG9tLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL1RleHROb2RlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL21hY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvbWF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tZW5jbG9zZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tZmVuY2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL21mcmFjLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL21nbHlwaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9taS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tbXVsdGlzY3JpcHRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL21uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL21vLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL21wYWRkZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvbXJvb3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvbXJvdy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tc3BhY2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvbXNxcnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvbXN1YnN1cC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tdGFibGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvbXRkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL210ZXh0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL210ci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jaHRtbC9XcmFwcGVycy9tdW5kZXJvdmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NodG1sL1dyYXBwZXJzL3NjcmlwdGJhc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY2h0bWwvV3JhcHBlcnMvc2VtYW50aWNzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9Ob3RhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vT3V0cHV0SmF4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvVGVYQXRvbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL21hY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL21lbmNsb3NlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9tZmVuY2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9tZnJhYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbWdseXBoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9taS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbW11bHRpc2NyaXB0cy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL21vLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9tcGFkZGVkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9tcm9vdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbXJvdy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL21zcGFjZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbXNxcnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL21zdWJzdXAuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9vdXRwdXQvY29tbW9uL1dyYXBwZXJzL210YWJsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbXRkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9tdGV4dC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL291dHB1dC9jb21tb24vV3JhcHBlcnMvbXRyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9tdW5kZXJvdmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9zY3JpcHRiYXNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvb3V0cHV0L2NvbW1vbi9XcmFwcGVycy9zZW1hbnRpY3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL0JCb3guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL0Z1bmN0aW9uTGlzdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3V0aWwvUHJpb3JpdGl6ZWRMaXN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9TdHlsZUxpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL1N0eWxlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3V0aWwvbnVtZXJpYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RPdXRwdXRKYXggPSB2b2lkIDA7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBGdW5jdGlvbkxpc3RfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0Z1bmN0aW9uTGlzdC5qc1wiKTtcbnZhciBBYnN0cmFjdE91dHB1dEpheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RPdXRwdXRKYXgob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLmFkYXB0b3IgPSBudWxsO1xuICAgICAgICB2YXIgQ0xBU1MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgT3B0aW9uc19qc18xLnVzZXJPcHRpb25zKSgoMCwgT3B0aW9uc19qc18xLmRlZmF1bHRPcHRpb25zKSh7fSwgQ0xBU1MuT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBvc3RGaWx0ZXJzID0gbmV3IEZ1bmN0aW9uTGlzdF9qc18xLkZ1bmN0aW9uTGlzdCgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RPdXRwdXRKYXgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdE91dHB1dEpheC5wcm90b3R5cGUuc2V0QWRhcHRvciA9IGZ1bmN0aW9uIChhZGFwdG9yKSB7XG4gICAgICAgIHRoaXMuYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgfTtcbiAgICBBYnN0cmFjdE91dHB1dEpheC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIEFic3RyYWN0T3V0cHV0SmF4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdE91dHB1dEpheC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uIChfZG9jdW1lbnQpIHtcbiAgICB9O1xuICAgIEFic3RyYWN0T3V0cHV0SmF4LnByb3RvdHlwZS5zdHlsZVNoZWV0ID0gZnVuY3Rpb24gKF9kb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0T3V0cHV0SmF4LnByb3RvdHlwZS5wYWdlRWxlbWVudHMgPSBmdW5jdGlvbiAoX2RvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RPdXRwdXRKYXgucHJvdG90eXBlLmV4ZWN1dGVGaWx0ZXJzID0gZnVuY3Rpb24gKGZpbHRlcnMsIG1hdGgsIGRvY3VtZW50LCBkYXRhKSB7XG4gICAgICAgIHZhciBhcmdzID0geyBtYXRoOiBtYXRoLCBkb2N1bWVudDogZG9jdW1lbnQsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgZmlsdGVycy5leGVjdXRlKGFyZ3MpO1xuICAgICAgICByZXR1cm4gYXJncy5kYXRhO1xuICAgIH07XG4gICAgQWJzdHJhY3RPdXRwdXRKYXguTkFNRSA9ICdnZW5lcmljJztcbiAgICBBYnN0cmFjdE91dHB1dEpheC5PUFRJT05TID0ge307XG4gICAgcmV0dXJuIEFic3RyYWN0T3V0cHV0SmF4O1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RPdXRwdXRKYXggPSBBYnN0cmFjdE91dHB1dEpheDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dHB1dEpheC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RXcmFwcGVyID0gdm9pZCAwO1xudmFyIEFic3RyYWN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RXcmFwcGVyKGZhY3RvcnksIG5vZGUpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0V3JhcHBlci5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5raW5kO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RXcmFwcGVyLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yeS53cmFwKG5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0V3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0V3JhcHBlciA9IEFic3RyYWN0V3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdyYXBwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdFdyYXBwZXJGYWN0b3J5ID0gdm9pZCAwO1xudmFyIEZhY3RvcnlfanNfMSA9IHJlcXVpcmUoXCIuL0ZhY3RvcnkuanNcIik7XG52YXIgQWJzdHJhY3RXcmFwcGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0V3JhcHBlckZhY3RvcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RXcmFwcGVyRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdFdyYXBwZXJGYWN0b3J5LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW25vZGUua2luZCwgbm9kZV0sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdFdyYXBwZXJGYWN0b3J5O1xufShGYWN0b3J5X2pzXzEuQWJzdHJhY3RGYWN0b3J5KSk7XG5leHBvcnRzLkFic3RyYWN0V3JhcHBlckZhY3RvcnkgPSBBYnN0cmFjdFdyYXBwZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V3JhcHBlckZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTCA9IHZvaWQgMDtcbnZhciBPdXRwdXRKYXhfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9PdXRwdXRKYXguanNcIik7XG52YXIgU3R5bGVMaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9TdHlsZUxpc3QuanNcIik7XG52YXIgV3JhcHBlckZhY3RvcnlfanNfMSA9IHJlcXVpcmUoXCIuL2NodG1sL1dyYXBwZXJGYWN0b3J5LmpzXCIpO1xudmFyIFVzYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9jaHRtbC9Vc2FnZS5qc1wiKTtcbnZhciB0ZXhfanNfMSA9IHJlcXVpcmUoXCIuL2NodG1sL2ZvbnRzL3RleC5qc1wiKTtcbnZhciBMRU5HVEhTID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsL2xlbmd0aHMuanNcIikpO1xudmFyIHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvc3RyaW5nLmpzXCIpO1xudmFyIENIVE1MID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIFdyYXBwZXJGYWN0b3J5X2pzXzEuQ0hUTUxXcmFwcGVyRmFjdG9yeSwgdGV4X2pzXzEuVGVYRm9udCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2h0bWxTdHlsZXMgPSBudWxsO1xuICAgICAgICBfdGhpcy5mb250LmFkYXB0aXZlQ1NTKF90aGlzLm9wdGlvbnMuYWRhcHRpdmVDU1MpO1xuICAgICAgICBfdGhpcy53cmFwcGVyVXNhZ2UgPSBuZXcgVXNhZ2VfanNfMS5Vc2FnZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENIVE1MLnByb3RvdHlwZS5lc2NhcGVkID0gZnVuY3Rpb24gKG1hdGgsIGh0bWwpIHtcbiAgICAgICAgdGhpcy5zZXREb2N1bWVudChodG1sKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHRtbCgnc3BhbicsIHt9LCBbdGhpcy50ZXh0KG1hdGgubWF0aCldKTtcbiAgICB9O1xuICAgIENIVE1MLnByb3RvdHlwZS5zdHlsZVNoZWV0ID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h0bWxTdHlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVDU1MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gbmV3IFN0eWxlTGlzdF9qc18xLkNzc1N0eWxlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkV3JhcHBlclN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9udFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5pbnNlcnRSdWxlcyh0aGlzLmNodG1sU3R5bGVzLCBzdHlsZXMuZ2V0U3R5bGVSdWxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodG1sU3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGVldCA9IHRoaXMuY2h0bWxTdHlsZXMgPSBfc3VwZXIucHJvdG90eXBlLnN0eWxlU2hlZXQuY2FsbCh0aGlzLCBodG1sKTtcbiAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZShzaGVldCwgJ2lkJywgQ0hUTUwuU1RZTEVTSEVFVElEKTtcbiAgICAgICAgdGhpcy53cmFwcGVyVXNhZ2UudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiBzaGVldDtcbiAgICB9O1xuICAgIENIVE1MLnByb3RvdHlwZS51cGRhdGVGb250U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICBzdHlsZXMuYWRkU3R5bGVzKHRoaXMuZm9udC51cGRhdGVTdHlsZXMoe30pKTtcbiAgICB9O1xuICAgIENIVE1MLnByb3RvdHlwZS5hZGRXcmFwcGVyU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWRhcHRpdmVDU1MpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuYWRkV3JhcHBlclN0eWxlcy5jYWxsKHRoaXMsIHN0eWxlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy53cmFwcGVyVXNhZ2UudXBkYXRlKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuZmFjdG9yeS5nZXROb2RlQ2xhc3Moa2luZCk7XG4gICAgICAgICAgICAgICAgd3JhcHBlciAmJiB0aGlzLmFkZENsYXNzU3R5bGVzKHdyYXBwZXIsIHN0eWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUwucHJvdG90eXBlLmFkZENsYXNzU3R5bGVzID0gZnVuY3Rpb24gKHdyYXBwZXIsIHN0eWxlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBDTEFTUyA9IHdyYXBwZXI7XG4gICAgICAgIGlmIChDTEFTUy5hdXRvU3R5bGUgJiYgQ0xBU1Mua2luZCAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICBzdHlsZXMuYWRkU3R5bGVzKChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hWydtangtJyArIENMQVNTLmtpbmRdID0ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnbGVmdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9hKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyVXNhZ2UuYWRkKENMQVNTLmtpbmQpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFkZENsYXNzU3R5bGVzLmNhbGwodGhpcywgd3JhcHBlciwgc3R5bGVzKTtcbiAgICB9O1xuICAgIENIVE1MLnByb3RvdHlwZS5wcm9jZXNzTWF0aCA9IGZ1bmN0aW9uIChtYXRoLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5LndyYXAobWF0aCkudG9DSFRNTChwYXJlbnQpO1xuICAgIH07XG4gICAgQ0hUTUwucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3NzU3R5bGVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZm9udC5jbGVhckNhY2hlKCk7XG4gICAgICAgIHRoaXMud3JhcHBlclVzYWdlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2h0bWxTdHlsZXMgPSBudWxsO1xuICAgIH07XG4gICAgQ0hUTUwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICAgIENIVE1MLnByb3RvdHlwZS51bmtub3duVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB2YXJpYW50LCB3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkgeyB3aWR0aCA9IG51bGw7IH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgICAgICB2YXIgc2NhbGUgPSAxMDAgLyB0aGlzLm1hdGgubWV0cmljcy5zY2FsZTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxMDApIHtcbiAgICAgICAgICAgIHN0eWxlc1snZm9udC1zaXplJ10gPSB0aGlzLmZpeGVkKHNjYWxlLCAxKSArICclJztcbiAgICAgICAgICAgIHN0eWxlcy5wYWRkaW5nID0gTEVOR1RIUy5lbSg3NSAvIHNjYWxlKSArICcgMCAnICsgTEVOR1RIUy5lbSgyMCAvIHNjYWxlKSArICcgMCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbnQgIT09ICctZXhwbGljaXRGb250Jykge1xuICAgICAgICAgICAgdmFyIGMgPSAoMCwgc3RyaW5nX2pzXzEudW5pY29kZUNoYXJzKSh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChjLmxlbmd0aCAhPT0gMSB8fCBjWzBdIDwgMHgxRDQwMCB8fCBjWzBdID4gMHgxRDdGRikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3NzRm9udFN0eWxlcyh0aGlzLmZvbnQuZ2V0Q3NzRm9udCh2YXJpYW50KSwgc3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5tYXRoLm1ldHJpY3M7XG4gICAgICAgICAgICBzdHlsZXMud2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogbWV0cmljcy5lbSAqIG1ldHJpY3Muc2NhbGUpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5odG1sKCdtangtdXRleHQnLCB7IHZhcmlhbnQ6IHZhcmlhbnQsIHN0eWxlOiBzdHlsZXMgfSwgW3RoaXMudGV4dCh0ZXh0KV0pO1xuICAgIH07XG4gICAgQ0hUTUwucHJvdG90eXBlLm1lYXN1cmVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh0ZXh0Tm9kZSkge1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgdmFyIHRleHQgPSBhZGFwdG9yLmNsb25lKHRleHROb2RlKTtcbiAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0ZXh0LCAnZm9udC1mYW1pbHknLCBhZGFwdG9yLmdldFN0eWxlKHRleHQsICdmb250LWZhbWlseScpLnJlcGxhY2UoL01KWFpFUk8sIC9nLCAnJykpO1xuICAgICAgICB2YXIgc3R5bGUgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCAnd2hpdGUtc3BhY2UnOiAnbm93cmFwJyB9O1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaHRtbCgnbWp4LW1lYXN1cmUtdGV4dCcsIHsgc3R5bGU6IHN0eWxlIH0sIFt0ZXh0XSk7XG4gICAgICAgIGFkYXB0b3IuYXBwZW5kKGFkYXB0b3IucGFyZW50KHRoaXMubWF0aC5zdGFydC5ub2RlKSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgICBhZGFwdG9yLmFwcGVuZCh0aGlzLmNvbnRhaW5lciwgbm9kZSk7XG4gICAgICAgIHZhciB3ID0gYWRhcHRvci5ub2RlU2l6ZSh0ZXh0LCB0aGlzLm1hdGgubWV0cmljcy5lbSlbMF0gLyB0aGlzLm1hdGgubWV0cmljcy5zY2FsZTtcbiAgICAgICAgYWRhcHRvci5yZW1vdmUodGhpcy5jb250YWluZXIpO1xuICAgICAgICBhZGFwdG9yLnJlbW92ZShub2RlKTtcbiAgICAgICAgcmV0dXJuIHsgdzogdywgaDogLjc1LCBkOiAuMiB9O1xuICAgIH07XG4gICAgQ0hUTUwuTkFNRSA9ICdDSFRNTCc7XG4gICAgQ0hUTUwuT1BUSU9OUyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBPdXRwdXRKYXhfanNfMS5Db21tb25PdXRwdXRKYXguT1BUSU9OUyksIHsgYWRhcHRpdmVDU1M6IHRydWUsIG1hdGNoRm9udEhlaWdodDogdHJ1ZSB9KTtcbiAgICBDSFRNTC5jb21tb25TdHlsZXMgPSB7XG4gICAgICAgICdtangtY29udGFpbmVyW2pheD1cIkNIVE1MXCJdJzogeyAnbGluZS1oZWlnaHQnOiAwIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzcGFjZT1cIjFcIl0nOiB7ICdtYXJnaW4tbGVmdCc6ICcuMTExZW0nIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzcGFjZT1cIjJcIl0nOiB7ICdtYXJnaW4tbGVmdCc6ICcuMTY3ZW0nIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzcGFjZT1cIjNcIl0nOiB7ICdtYXJnaW4tbGVmdCc6ICcuMjIyZW0nIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzcGFjZT1cIjRcIl0nOiB7ICdtYXJnaW4tbGVmdCc6ICcuMjc4ZW0nIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzcGFjZT1cIjVcIl0nOiB7ICdtYXJnaW4tbGVmdCc6ICcuMzMzZW0nIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtyc3BhY2U9XCIxXCJdJzogeyAnbWFyZ2luLXJpZ2h0JzogJy4xMTFlbScgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXIgW3JzcGFjZT1cIjJcIl0nOiB7ICdtYXJnaW4tcmlnaHQnOiAnLjE2N2VtJyB9LFxuICAgICAgICAnbWp4LWNvbnRhaW5lciBbcnNwYWNlPVwiM1wiXSc6IHsgJ21hcmdpbi1yaWdodCc6ICcuMjIyZW0nIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtyc3BhY2U9XCI0XCJdJzogeyAnbWFyZ2luLXJpZ2h0JzogJy4yNzhlbScgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXIgW3JzcGFjZT1cIjVcIl0nOiB7ICdtYXJnaW4tcmlnaHQnOiAnLjMzM2VtJyB9LFxuICAgICAgICAnbWp4LWNvbnRhaW5lciBbc2l6ZT1cInNcIl0nOiB7ICdmb250LXNpemUnOiAnNzAuNyUnIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzaXplPVwic3NcIl0nOiB7ICdmb250LXNpemUnOiAnNTAlJyB9LFxuICAgICAgICAnbWp4LWNvbnRhaW5lciBbc2l6ZT1cIlRuXCJdJzogeyAnZm9udC1zaXplJzogJzYwJScgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXIgW3NpemU9XCJzbVwiXSc6IHsgJ2ZvbnQtc2l6ZSc6ICc4NSUnIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzaXplPVwibGdcIl0nOiB7ICdmb250LXNpemUnOiAnMTIwJScgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXIgW3NpemU9XCJMZ1wiXSc6IHsgJ2ZvbnQtc2l6ZSc6ICcxNDQlJyB9LFxuICAgICAgICAnbWp4LWNvbnRhaW5lciBbc2l6ZT1cIkxHXCJdJzogeyAnZm9udC1zaXplJzogJzE3MyUnIH0sXG4gICAgICAgICdtangtY29udGFpbmVyIFtzaXplPVwiaGdcIl0nOiB7ICdmb250LXNpemUnOiAnMjA3JScgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXIgW3NpemU9XCJIR1wiXSc6IHsgJ2ZvbnQtc2l6ZSc6ICcyNDklJyB9LFxuICAgICAgICAnbWp4LWNvbnRhaW5lciBbd2lkdGg9XCJmdWxsXCJdJzogeyB3aWR0aDogJzEwMCUnIH0sXG4gICAgICAgICdtangtYm94JzogeyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9LFxuICAgICAgICAnbWp4LWJsb2NrJzogeyBkaXNwbGF5OiAnYmxvY2snIH0sXG4gICAgICAgICdtangtaXRhYmxlJzogeyBkaXNwbGF5OiAnaW5saW5lLXRhYmxlJyB9LFxuICAgICAgICAnbWp4LXJvdyc6IHsgZGlzcGxheTogJ3RhYmxlLXJvdycgfSxcbiAgICAgICAgJ21qeC1yb3cgPiAqJzogeyBkaXNwbGF5OiAndGFibGUtY2VsbCcgfSxcbiAgICAgICAgJ21qeC1tdGV4dCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXN0eWxlJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZXJyb3InOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgIGNvbG9yOiAncmVkJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ3llbGxvdydcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tcGhhbnRvbSc6IHtcbiAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgICAgIH0sXG4gICAgICAgICdfOjotd2Via2l0LWZ1bGwtcGFnZS1tZWRpYSwgXzpmdXR1cmUsIDpyb290IG1qeC1jb250YWluZXInOiB7XG4gICAgICAgICAgICAnd2lsbC1jaGFuZ2UnOiAnb3BhY2l0eSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUwuU1RZTEVTSEVFVElEID0gJ01KWC1DSFRNTC1zdHlsZXMnO1xuICAgIHJldHVybiBDSFRNTDtcbn0oT3V0cHV0SmF4X2pzXzEuQ29tbW9uT3V0cHV0SmF4KSk7XG5leHBvcnRzLkNIVE1MID0gQ0hUTUw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHRtbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXJyb3cgPSBleHBvcnRzLkRpYWdvbmFsQXJyb3cgPSBleHBvcnRzLkRpYWdvbmFsU3RyaWtlID0gZXhwb3J0cy5Cb3JkZXIyID0gZXhwb3J0cy5Cb3JkZXIgPSBleHBvcnRzLlJlbmRlckVsZW1lbnQgPSB2b2lkIDA7XG52YXIgTm90YXRpb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9Ob3RhdGlvbi5qc1wiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9Ob3RhdGlvbi5qc1wiKSwgZXhwb3J0cyk7XG52YXIgUmVuZGVyRWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gJyc7IH1cbiAgICByZXR1cm4gKGZ1bmN0aW9uIChub2RlLCBfY2hpbGQpIHtcbiAgICAgICAgdmFyIHNoYXBlID0gbm9kZS5hZGp1c3RCb3JkZXIobm9kZS5odG1sKCdtangtJyArIG5hbWUpKTtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIGQgPSBub2RlLmdldE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG5vZGUudGhpY2tuZXNzICE9PSBOb3RhdGlvbi5USElDS05FU1MgfHwgZCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVwiLmNvbmNhdChvZmZzZXQsIFwiKFwiKS5jb25jYXQobm9kZS5lbShub2RlLnRoaWNrbmVzcyAvIDIgLSBkKSwgXCIpXCIpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWRhcHRvci5zZXRTdHlsZShzaGFwZSwgJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5hZGFwdG9yLmFwcGVuZChub2RlLmNodG1sLCBzaGFwZSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5SZW5kZXJFbGVtZW50ID0gUmVuZGVyRWxlbWVudDtcbnZhciBCb3JkZXIgPSBmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBOb3RhdGlvbi5Db21tb25Cb3JkZXIoZnVuY3Rpb24gKG5vZGUsIGNoaWxkKSB7XG4gICAgICAgIG5vZGUuYWRhcHRvci5zZXRTdHlsZShjaGlsZCwgJ2JvcmRlci0nICsgc2lkZSwgbm9kZS5lbShub2RlLnRoaWNrbmVzcykgKyAnIHNvbGlkJyk7XG4gICAgfSkoc2lkZSk7XG59O1xuZXhwb3J0cy5Cb3JkZXIgPSBCb3JkZXI7XG52YXIgQm9yZGVyMiA9IGZ1bmN0aW9uIChuYW1lLCBzaWRlMSwgc2lkZTIpIHtcbiAgICByZXR1cm4gTm90YXRpb24uQ29tbW9uQm9yZGVyMihmdW5jdGlvbiAobm9kZSwgY2hpbGQpIHtcbiAgICAgICAgdmFyIGJvcmRlciA9IG5vZGUuZW0obm9kZS50aGlja25lc3MpICsgJyBzb2xpZCc7XG4gICAgICAgIG5vZGUuYWRhcHRvci5zZXRTdHlsZShjaGlsZCwgJ2JvcmRlci0nICsgc2lkZTEsIGJvcmRlcik7XG4gICAgICAgIG5vZGUuYWRhcHRvci5zZXRTdHlsZShjaGlsZCwgJ2JvcmRlci0nICsgc2lkZTIsIGJvcmRlcik7XG4gICAgfSkobmFtZSwgc2lkZTEsIHNpZGUyKTtcbn07XG5leHBvcnRzLkJvcmRlcjIgPSBCb3JkZXIyO1xudmFyIERpYWdvbmFsU3RyaWtlID0gZnVuY3Rpb24gKG5hbWUsIG5lZykge1xuICAgIHJldHVybiBOb3RhdGlvbi5Db21tb25EaWFnb25hbFN0cmlrZShmdW5jdGlvbiAoY25hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBfY2hpbGQpIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZS5nZXRCQm94KCksIHcgPSBfYS53LCBoID0gX2EuaCwgZCA9IF9hLmQ7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChub2RlLmdldEFyZ01vZCh3LCBoICsgZCksIDIpLCBhID0gX2JbMF0sIFcgPSBfYlsxXTtcbiAgICAgICAgdmFyIHQgPSBuZWcgKiBub2RlLnRoaWNrbmVzcyAvIDI7XG4gICAgICAgIHZhciBzdHJpa2UgPSBub2RlLmFkanVzdEJvcmRlcihub2RlLmh0bWwoY25hbWUsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5lbShXKSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoJyArIG5vZGUuZml4ZWQoLW5lZyAqIGEpICsgJ3JhZCkgdHJhbnNsYXRlWSgnICsgdCArICdlbSknLFxuICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgIG5vZGUuYWRhcHRvci5hcHBlbmQobm9kZS5jaHRtbCwgc3RyaWtlKTtcbiAgICB9OyB9KShuYW1lKTtcbn07XG5leHBvcnRzLkRpYWdvbmFsU3RyaWtlID0gRGlhZ29uYWxTdHJpa2U7XG52YXIgRGlhZ29uYWxBcnJvdyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIE5vdGF0aW9uLkNvbW1vbkRpYWdvbmFsQXJyb3coZnVuY3Rpb24gKG5vZGUsIGFycm93KSB7XG4gICAgICAgIG5vZGUuYWRhcHRvci5hcHBlbmQobm9kZS5jaHRtbCwgYXJyb3cpO1xuICAgIH0pKG5hbWUpO1xufTtcbmV4cG9ydHMuRGlhZ29uYWxBcnJvdyA9IERpYWdvbmFsQXJyb3c7XG52YXIgQXJyb3cgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBOb3RhdGlvbi5Db21tb25BcnJvdyhmdW5jdGlvbiAobm9kZSwgYXJyb3cpIHtcbiAgICAgICAgbm9kZS5hZGFwdG9yLmFwcGVuZChub2RlLmNodG1sLCBhcnJvdyk7XG4gICAgfSkobmFtZSk7XG59O1xuZXhwb3J0cy5BcnJvdyA9IEFycm93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MV3JhcHBlciA9IGV4cG9ydHMuU1BBQ0UgPSBleHBvcnRzLkZPTlRTSVpFID0gdm9pZCAwO1xudmFyIExFTkdUSFMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL3V0aWwvbGVuZ3Rocy5qc1wiKSk7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9XcmFwcGVyLmpzXCIpO1xudmFyIEJCb3hfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0JCb3guanNcIik7XG5leHBvcnRzLkZPTlRTSVpFID0ge1xuICAgICc3MC43JSc6ICdzJyxcbiAgICAnNzAlJzogJ3MnLFxuICAgICc1MCUnOiAnc3MnLFxuICAgICc2MCUnOiAnVG4nLFxuICAgICc4NSUnOiAnc20nLFxuICAgICcxMjAlJzogJ2xnJyxcbiAgICAnMTQ0JSc6ICdMZycsXG4gICAgJzE3MyUnOiAnTEcnLFxuICAgICcyMDclJzogJ2hnJyxcbiAgICAnMjQ5JSc6ICdIRydcbn07XG5leHBvcnRzLlNQQUNFID0gKF9hID0ge30sXG4gICAgX2FbTEVOR1RIUy5lbSgyIC8gMTgpXSA9ICcxJyxcbiAgICBfYVtMRU5HVEhTLmVtKDMgLyAxOCldID0gJzInLFxuICAgIF9hW0xFTkdUSFMuZW0oNCAvIDE4KV0gPSAnMycsXG4gICAgX2FbTEVOR1RIUy5lbSg1IC8gMTgpXSA9ICc0JyxcbiAgICBfYVtMRU5HVEhTLmVtKDYgLyAxOCldID0gJzUnLFxuICAgIF9hKTtcbnZhciBDSFRNTFdyYXBwZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTFdyYXBwZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxXcmFwcGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2h0bWwgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBjaHRtbCA9IHRoaXMuc3RhbmRhcmRDSFRNTG5vZGUocGFyZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5jaGlsZE5vZGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNoaWxkLnRvQ0hUTUwoY2h0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUuc3RhbmRhcmRDSFRNTG5vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMubWFya1VzZWQoKTtcbiAgICAgICAgdmFyIGNodG1sID0gdGhpcy5jcmVhdGVDSFRNTG5vZGUocGFyZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdHlsZXMoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVWYXJpYW50KCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2NhbGUoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2xvcigpO1xuICAgICAgICB0aGlzLmhhbmRsZVNwYWNlKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmhhbmRsZVBXaWR0aCgpO1xuICAgICAgICByZXR1cm4gY2h0bWw7XG4gICAgfTtcbiAgICBDSFRNTFdyYXBwZXIucHJvdG90eXBlLm1hcmtVc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmpheC53cmFwcGVyVXNhZ2UuYWRkKHRoaXMua2luZCk7XG4gICAgfTtcbiAgICBDSFRNTFdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZUNIVE1Mbm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2hyZWYnKTtcbiAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuYWRhcHRvci5hcHBlbmQocGFyZW50LCB0aGlzLmh0bWwoJ2EnLCB7IGhyZWY6IGhyZWYgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h0bWwgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKHBhcmVudCwgdGhpcy5odG1sKCdtangtJyArIHRoaXMubm9kZS5raW5kKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNodG1sO1xuICAgIH07XG4gICAgQ0hUTUxXcmFwcGVyLnByb3RvdHlwZS5oYW5kbGVTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLnN0eWxlcy5jc3NUZXh0O1xuICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICdzdHlsZScsIHN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgZmFtaWx5ID0gdGhpcy5zdHlsZXMuZ2V0KCdmb250LWZhbWlseScpO1xuICAgICAgICAgICAgaWYgKGZhbWlseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAnZm9udC1mYW1pbHknLCAnTUpYWkVSTywgJyArIGZhbWlseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUuaGFuZGxlVmFyaWFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1Rva2VuICYmIHRoaXMudmFyaWFudCAhPT0gJy1leHBsaWNpdEZvbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICdjbGFzcycsICh0aGlzLmZvbnQuZ2V0VmFyaWFudCh0aGlzLnZhcmlhbnQpIHx8IHRoaXMuZm9udC5nZXRWYXJpYW50KCdub3JtYWwnKSkuY2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUuaGFuZGxlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U2NhbGUodGhpcy5jaHRtbCwgdGhpcy5iYm94LnJzY2FsZSk7XG4gICAgfTtcbiAgICBDSFRNTFdyYXBwZXIucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gKGNodG1sLCByc2NhbGUpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gKE1hdGguYWJzKHJzY2FsZSAtIDEpIDwgLjAwMSA/IDEgOiByc2NhbGUpO1xuICAgICAgICBpZiAoY2h0bWwgJiYgc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5wZXJjZW50KHNjYWxlKTtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLkZPTlRTSVpFW3NpemVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZShjaHRtbCwgJ3NpemUnLCBleHBvcnRzLkZPTlRTSVpFW3NpemVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShjaHRtbCwgJ2ZvbnRTaXplJywgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodG1sO1xuICAgIH07XG4gICAgQ0hUTUxXcmFwcGVyLnByb3RvdHlwZS5oYW5kbGVTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFtbdGhpcy5iYm94LkwsICdzcGFjZScsICdtYXJnaW5MZWZ0J10sXG4gICAgICAgICAgICAgICAgW3RoaXMuYmJveC5SLCAncnNwYWNlJywgJ21hcmdpblJpZ2h0J11dKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kID0gX19yZWFkKGRhdGEsIDMpLCBkaW1lbiA9IF9kWzBdLCBuYW1lXzEgPSBfZFsxXSwgbWFyZ2luID0gX2RbMl07XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IHRoaXMuZW0oZGltZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0cy5TUEFDRVtzcGFjZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRBdHRyaWJ1dGUodGhpcy5jaHRtbCwgbmFtZV8xLCBleHBvcnRzLlNQQUNFW3NwYWNlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUodGhpcy5jaHRtbCwgbWFyZ2luLCBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxXcmFwcGVyLnByb3RvdHlwZS5oYW5kbGVDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLm5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIG1hdGhjb2xvciA9IGF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ21hdGhjb2xvcicpO1xuICAgICAgICB2YXIgY29sb3IgPSBhdHRyaWJ1dGVzLmdldEV4cGxpY2l0KCdjb2xvcicpO1xuICAgICAgICB2YXIgbWF0aGJhY2tncm91bmQgPSBhdHRyaWJ1dGVzLmdldEV4cGxpY2l0KCdtYXRoYmFja2dyb3VuZCcpO1xuICAgICAgICB2YXIgYmFja2dyb3VuZCA9IGF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ2JhY2tncm91bmQnKTtcbiAgICAgICAgaWYgKG1hdGhjb2xvciB8fCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKHRoaXMuY2h0bWwsICdjb2xvcicsIG1hdGhjb2xvciB8fCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGhiYWNrZ3JvdW5kIHx8IGJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAnYmFja2dyb3VuZENvbG9yJywgbWF0aGJhY2tncm91bmQgfHwgYmFja2dyb3VuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUuaGFuZGxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IGF0dHJpYnV0ZXMuZ2V0QWxsRGVmYXVsdHMoKTtcbiAgICAgICAgdmFyIHNraXAgPSBDSFRNTFdyYXBwZXIuc2tpcEF0dHJpYnV0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKGF0dHJpYnV0ZXMuZ2V0RXhwbGljaXROYW1lcygpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFtuYW1lXzJdID09PSBmYWxzZSB8fCAoIShuYW1lXzIgaW4gZGVmYXVsdHMpICYmICFza2lwW25hbWVfMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuYWRhcHRvci5oYXNBdHRyaWJ1dGUodGhpcy5jaHRtbCwgbmFtZV8yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZSh0aGlzLmNodG1sLCBuYW1lXzIsIGF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQobmFtZV8yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuZ2V0KCdjbGFzcycpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBhdHRyaWJ1dGVzLmdldCgnY2xhc3MnKS50cmltKCkuc3BsaXQoLyArLyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVzXzEgPSBfX3ZhbHVlcyhuYW1lcyksIG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpOyAhbmFtZXNfMV8xLmRvbmU7IG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzMgPSBuYW1lc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5hZGRDbGFzcyh0aGlzLmNodG1sLCBuYW1lXzMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNfMV8xICYmICFuYW1lc18xXzEuZG9uZSAmJiAoX2IgPSBuYW1lc18xLnJldHVybikpIF9iLmNhbGwobmFtZXNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxXcmFwcGVyLnByb3RvdHlwZS5oYW5kbGVQV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJib3gucHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYm94LnB3aWR0aCA9PT0gQkJveF9qc18xLkJCb3guZnVsbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZSh0aGlzLmNodG1sLCAnd2lkdGgnLCAnZnVsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKHRoaXMuY2h0bWwsICd3aWR0aCcsIHRoaXMuYmJveC5wd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTFdyYXBwZXIucHJvdG90eXBlLnNldEluZGVudCA9IGZ1bmN0aW9uIChjaHRtbCwgYWxpZ24sIHNoaWZ0KSB7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInIHx8IGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHZhciBMID0gdGhpcy5nZXRCQm94KCkuTDtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoY2h0bWwsICdtYXJnaW4tbGVmdCcsIHRoaXMuZW0oc2hpZnQgKyBMKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJyB8fCBhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdmFyIFIgPSB0aGlzLmdldEJCb3goKS5SO1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShjaHRtbCwgJ21hcmdpbi1yaWdodCcsIHRoaXMuZW0oLXNoaWZ0ICsgUikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTFdyYXBwZXIucHJvdG90eXBlLmRyYXdCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldEJCb3goKSwgdyA9IF9hLncsIGggPSBfYS5oLCBkID0gX2EuZCwgUiA9IF9hLlI7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmh0bWwoJ21qeC1ib3gnLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogLjI1LCAnbWFyZ2luLWxlZnQnOiB0aGlzLmVtKC13IC0gUilcbiAgICAgICAgICAgIH0gfSwgW1xuICAgICAgICAgICAgdGhpcy5odG1sKCdtangtYm94JywgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZW0oaCksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmVtKHcpLFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdyZWQnXG4gICAgICAgICAgICAgICAgfSB9KSxcbiAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWJveCcsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmVtKGQpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5lbSh3KSxcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1sZWZ0JzogdGhpcy5lbSgtdyksXG4gICAgICAgICAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6IHRoaXMuZW0oLWQpLFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdncmVlbidcbiAgICAgICAgICAgICAgICB9IH0pXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY2h0bWwgfHwgdGhpcy5wYXJlbnQuY2h0bWw7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5hZGFwdG9yLmdldEF0dHJpYnV0ZShub2RlLCAnc2l6ZScpO1xuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZShib3gsICdzaXplJywgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnRzaXplID0gdGhpcy5hZGFwdG9yLmdldFN0eWxlKG5vZGUsICdmb250U2l6ZScpO1xuICAgICAgICBpZiAoZm9udHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShib3gsICdmb250U2l6ZScsIGZvbnRzaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkYXB0b3IuYXBwZW5kKHRoaXMuYWRhcHRvci5wYXJlbnQobm9kZSksIGJveCk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShub2RlLCAnYmFja2dyb3VuZENvbG9yJywgJyNGRkVFMDAnKTtcbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uICh0eXBlLCBkZWYsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7IGRlZiA9IHt9OyB9XG4gICAgICAgIGlmIChjb250ZW50ID09PSB2b2lkIDApIHsgY29udGVudCA9IFtdOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmpheC5odG1sKHR5cGUsIGRlZiwgY29udGVudCk7XG4gICAgfTtcbiAgICBDSFRNTFdyYXBwZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qYXgudGV4dCh0ZXh0KTtcbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5wcm90b3R5cGUuY2hhciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQuY2hhclNlbGVjdG9yKG4pLnN1YnN0cigxKTtcbiAgICB9O1xuICAgIENIVE1MV3JhcHBlci5raW5kID0gJ3Vua25vd24nO1xuICAgIENIVE1MV3JhcHBlci5hdXRvU3R5bGUgPSB0cnVlO1xuICAgIHJldHVybiBDSFRNTFdyYXBwZXI7XG59KFdyYXBwZXJfanNfMS5Db21tb25XcmFwcGVyKSk7XG5leHBvcnRzLkNIVE1MV3JhcHBlciA9IENIVE1MV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdyYXBwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTFdyYXBwZXJGYWN0b3J5ID0gdm9pZCAwO1xudmFyIFdyYXBwZXJGYWN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1dyYXBwZXJGYWN0b3J5LmpzXCIpO1xudmFyIFdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy5qc1wiKTtcbnZhciBDSFRNTFdyYXBwZXJGYWN0b3J5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxXcmFwcGVyRmFjdG9yeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTFdyYXBwZXJGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MV3JhcHBlckZhY3RvcnkuZGVmYXVsdE5vZGVzID0gV3JhcHBlcnNfanNfMS5DSFRNTFdyYXBwZXJzO1xuICAgIHJldHVybiBDSFRNTFdyYXBwZXJGYWN0b3J5O1xufShXcmFwcGVyRmFjdG9yeV9qc18xLkNvbW1vbldyYXBwZXJGYWN0b3J5KSk7XG5leHBvcnRzLkNIVE1MV3JhcHBlckZhY3RvcnkgPSBDSFRNTFdyYXBwZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V3JhcHBlckZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MV3JhcHBlcnMgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlci5qc1wiKTtcbnZhciBtYXRoX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tYXRoLmpzXCIpO1xudmFyIG1pX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9taS5qc1wiKTtcbnZhciBtb19qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbW8uanNcIik7XG52YXIgbW5fanNfMSA9IHJlcXVpcmUoXCIuL1dyYXBwZXJzL21uLmpzXCIpO1xudmFyIG1zX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tcy5qc1wiKTtcbnZhciBtdGV4dF9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXRleHQuanNcIik7XG52YXIgbXNwYWNlX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tc3BhY2UuanNcIik7XG52YXIgbXBhZGRlZF9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXBhZGRlZC5qc1wiKTtcbnZhciBtZW5jbG9zZV9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbWVuY2xvc2UuanNcIik7XG52YXIgbXJvd19qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXJvdy5qc1wiKTtcbnZhciBtZmVuY2VkX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tZmVuY2VkLmpzXCIpO1xudmFyIG1mcmFjX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tZnJhYy5qc1wiKTtcbnZhciBtc3FydF9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXNxcnQuanNcIik7XG52YXIgbXJvb3RfanNfMSA9IHJlcXVpcmUoXCIuL1dyYXBwZXJzL21yb290LmpzXCIpO1xudmFyIG1zdWJzdXBfanNfMSA9IHJlcXVpcmUoXCIuL1dyYXBwZXJzL21zdWJzdXAuanNcIik7XG52YXIgbXVuZGVyb3Zlcl9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXVuZGVyb3Zlci5qc1wiKTtcbnZhciBtbXVsdGlzY3JpcHRzX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tbXVsdGlzY3JpcHRzLmpzXCIpO1xudmFyIG10YWJsZV9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXRhYmxlLmpzXCIpO1xudmFyIG10cl9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXRyLmpzXCIpO1xudmFyIG10ZF9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvbXRkLmpzXCIpO1xudmFyIG1hY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL1dyYXBwZXJzL21hY3Rpb24uanNcIik7XG52YXIgbWdseXBoX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9tZ2x5cGguanNcIik7XG52YXIgc2VtYW50aWNzX2pzXzEgPSByZXF1aXJlKFwiLi9XcmFwcGVycy9zZW1hbnRpY3MuanNcIik7XG52YXIgVGVYQXRvbV9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvVGVYQXRvbS5qc1wiKTtcbnZhciBUZXh0Tm9kZV9qc18xID0gcmVxdWlyZShcIi4vV3JhcHBlcnMvVGV4dE5vZGUuanNcIik7XG5leHBvcnRzLkNIVE1MV3JhcHBlcnMgPSAoX2EgPSB7fSxcbiAgICBfYVttYXRoX2pzXzEuQ0hUTUxtYXRoLmtpbmRdID0gbWF0aF9qc18xLkNIVE1MbWF0aCxcbiAgICBfYVttcm93X2pzXzEuQ0hUTUxtcm93LmtpbmRdID0gbXJvd19qc18xLkNIVE1MbXJvdyxcbiAgICBfYVttcm93X2pzXzEuQ0hUTUxpbmZlcnJlZE1yb3cua2luZF0gPSBtcm93X2pzXzEuQ0hUTUxpbmZlcnJlZE1yb3csXG4gICAgX2FbbWlfanNfMS5DSFRNTG1pLmtpbmRdID0gbWlfanNfMS5DSFRNTG1pLFxuICAgIF9hW21vX2pzXzEuQ0hUTUxtby5raW5kXSA9IG1vX2pzXzEuQ0hUTUxtbyxcbiAgICBfYVttbl9qc18xLkNIVE1MbW4ua2luZF0gPSBtbl9qc18xLkNIVE1MbW4sXG4gICAgX2FbbXNfanNfMS5DSFRNTG1zLmtpbmRdID0gbXNfanNfMS5DSFRNTG1zLFxuICAgIF9hW210ZXh0X2pzXzEuQ0hUTUxtdGV4dC5raW5kXSA9IG10ZXh0X2pzXzEuQ0hUTUxtdGV4dCxcbiAgICBfYVttc3BhY2VfanNfMS5DSFRNTG1zcGFjZS5raW5kXSA9IG1zcGFjZV9qc18xLkNIVE1MbXNwYWNlLFxuICAgIF9hW21wYWRkZWRfanNfMS5DSFRNTG1wYWRkZWQua2luZF0gPSBtcGFkZGVkX2pzXzEuQ0hUTUxtcGFkZGVkLFxuICAgIF9hW21lbmNsb3NlX2pzXzEuQ0hUTUxtZW5jbG9zZS5raW5kXSA9IG1lbmNsb3NlX2pzXzEuQ0hUTUxtZW5jbG9zZSxcbiAgICBfYVttZnJhY19qc18xLkNIVE1MbWZyYWMua2luZF0gPSBtZnJhY19qc18xLkNIVE1MbWZyYWMsXG4gICAgX2FbbXNxcnRfanNfMS5DSFRNTG1zcXJ0LmtpbmRdID0gbXNxcnRfanNfMS5DSFRNTG1zcXJ0LFxuICAgIF9hW21yb290X2pzXzEuQ0hUTUxtcm9vdC5raW5kXSA9IG1yb290X2pzXzEuQ0hUTUxtcm9vdCxcbiAgICBfYVttc3Vic3VwX2pzXzEuQ0hUTUxtc3ViLmtpbmRdID0gbXN1YnN1cF9qc18xLkNIVE1MbXN1YixcbiAgICBfYVttc3Vic3VwX2pzXzEuQ0hUTUxtc3VwLmtpbmRdID0gbXN1YnN1cF9qc18xLkNIVE1MbXN1cCxcbiAgICBfYVttc3Vic3VwX2pzXzEuQ0hUTUxtc3Vic3VwLmtpbmRdID0gbXN1YnN1cF9qc18xLkNIVE1MbXN1YnN1cCxcbiAgICBfYVttdW5kZXJvdmVyX2pzXzEuQ0hUTUxtdW5kZXIua2luZF0gPSBtdW5kZXJvdmVyX2pzXzEuQ0hUTUxtdW5kZXIsXG4gICAgX2FbbXVuZGVyb3Zlcl9qc18xLkNIVE1MbW92ZXIua2luZF0gPSBtdW5kZXJvdmVyX2pzXzEuQ0hUTUxtb3ZlcixcbiAgICBfYVttdW5kZXJvdmVyX2pzXzEuQ0hUTUxtdW5kZXJvdmVyLmtpbmRdID0gbXVuZGVyb3Zlcl9qc18xLkNIVE1MbXVuZGVyb3ZlcixcbiAgICBfYVttbXVsdGlzY3JpcHRzX2pzXzEuQ0hUTUxtbXVsdGlzY3JpcHRzLmtpbmRdID0gbW11bHRpc2NyaXB0c19qc18xLkNIVE1MbW11bHRpc2NyaXB0cyxcbiAgICBfYVttZmVuY2VkX2pzXzEuQ0hUTUxtZmVuY2VkLmtpbmRdID0gbWZlbmNlZF9qc18xLkNIVE1MbWZlbmNlZCxcbiAgICBfYVttdGFibGVfanNfMS5DSFRNTG10YWJsZS5raW5kXSA9IG10YWJsZV9qc18xLkNIVE1MbXRhYmxlLFxuICAgIF9hW210cl9qc18xLkNIVE1MbXRyLmtpbmRdID0gbXRyX2pzXzEuQ0hUTUxtdHIsXG4gICAgX2FbbXRyX2pzXzEuQ0hUTUxtbGFiZWxlZHRyLmtpbmRdID0gbXRyX2pzXzEuQ0hUTUxtbGFiZWxlZHRyLFxuICAgIF9hW210ZF9qc18xLkNIVE1MbXRkLmtpbmRdID0gbXRkX2pzXzEuQ0hUTUxtdGQsXG4gICAgX2FbbWFjdGlvbl9qc18xLkNIVE1MbWFjdGlvbi5raW5kXSA9IG1hY3Rpb25fanNfMS5DSFRNTG1hY3Rpb24sXG4gICAgX2FbbWdseXBoX2pzXzEuQ0hUTUxtZ2x5cGgua2luZF0gPSBtZ2x5cGhfanNfMS5DSFRNTG1nbHlwaCxcbiAgICBfYVtzZW1hbnRpY3NfanNfMS5DSFRNTHNlbWFudGljcy5raW5kXSA9IHNlbWFudGljc19qc18xLkNIVE1Mc2VtYW50aWNzLFxuICAgIF9hW3NlbWFudGljc19qc18xLkNIVE1MYW5ub3RhdGlvbi5raW5kXSA9IHNlbWFudGljc19qc18xLkNIVE1MYW5ub3RhdGlvbixcbiAgICBfYVtzZW1hbnRpY3NfanNfMS5DSFRNTGFubm90YXRpb25YTUwua2luZF0gPSBzZW1hbnRpY3NfanNfMS5DSFRNTGFubm90YXRpb25YTUwsXG4gICAgX2Fbc2VtYW50aWNzX2pzXzEuQ0hUTUx4bWwua2luZF0gPSBzZW1hbnRpY3NfanNfMS5DSFRNTHhtbCxcbiAgICBfYVtUZVhBdG9tX2pzXzEuQ0hUTUxUZVhBdG9tLmtpbmRdID0gVGVYQXRvbV9qc18xLkNIVE1MVGVYQXRvbSxcbiAgICBfYVtUZXh0Tm9kZV9qc18xLkNIVE1MVGV4dE5vZGUua2luZF0gPSBUZXh0Tm9kZV9qc18xLkNIVE1MVGV4dE5vZGUsXG4gICAgX2FbV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlci5raW5kXSA9IFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIsXG4gICAgX2EpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V3JhcHBlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTFRlWEF0b20gPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgVGVYQXRvbV9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9UZVhBdG9tLmpzXCIpO1xudmFyIFRlWEF0b21fanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvVGVYQXRvbS5qc1wiKTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG52YXIgQ0hUTUxUZVhBdG9tID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxUZVhBdG9tLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MVGVYQXRvbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTFRlWEF0b20ucHJvdG90eXBlLnRvQ0hUTUwgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudG9DSFRNTC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRBdHRyaWJ1dGUodGhpcy5jaHRtbCwgJ3RleGNsYXNzJywgTW1sTm9kZV9qc18xLlRFWENMQVNTTkFNRVNbdGhpcy5ub2RlLnRleENsYXNzXSk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUudGV4Q2xhc3MgPT09IE1tbE5vZGVfanNfMS5URVhDTEFTUy5WQ0VOVEVSKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuY2hpbGROb2Rlc1swXS5nZXRCQm94KCk7XG4gICAgICAgICAgICB2YXIgaCA9IGJib3guaCwgZCA9IGJib3guZDtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5mb250LnBhcmFtcy5heGlzX2hlaWdodDtcbiAgICAgICAgICAgIHZhciBkaCA9ICgoaCArIGQpIC8gMiArIGEpIC0gaDtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAndmVydGljYWxBbGlnbicsIHRoaXMuZW0oZGgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxUZVhBdG9tLmtpbmQgPSBUZVhBdG9tX2pzXzIuVGVYQXRvbS5wcm90b3R5cGUua2luZDtcbiAgICByZXR1cm4gQ0hUTUxUZVhBdG9tO1xufSgoMCwgVGVYQXRvbV9qc18xLkNvbW1vblRlWEF0b21NaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxUZVhBdG9tID0gQ0hUTUxUZVhBdG9tO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGVYQXRvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MVGV4dE5vZGUgPSB2b2lkIDA7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xudmFyIFdyYXBwZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9XcmFwcGVyLmpzXCIpO1xudmFyIFRleHROb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL1RleHROb2RlLmpzXCIpO1xudmFyIENIVE1MVGV4dE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTFRleHROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MVGV4dE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxUZXh0Tm9kZS5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHRoaXMubWFya1VzZWQoKTtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIHZhciB2YXJpYW50ID0gdGhpcy5wYXJlbnQudmFyaWFudDtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLm5vZGUuZ2V0VGV4dCgpO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2YXJpYW50ID09PSAnLWV4cGxpY2l0Rm9udCcpIHtcbiAgICAgICAgICAgIGFkYXB0b3IuYXBwZW5kKHBhcmVudCwgdGhpcy5qYXgudW5rbm93blRleHQodGV4dCwgdmFyaWFudCwgdGhpcy5nZXRCQm94KCkudykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYXJzID0gdGhpcy5yZW1hcHBlZFRleHQodGV4dCwgdmFyaWFudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJzXzEgPSBfX3ZhbHVlcyhjaGFycyksIGNoYXJzXzFfMSA9IGNoYXJzXzEubmV4dCgpOyAhY2hhcnNfMV8xLmRvbmU7IGNoYXJzXzFfMSA9IGNoYXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gY2hhcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0VmFyaWFudENoYXIodmFyaWFudCwgbilbM107XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250ID0gKGRhdGEuZiA/ICcgVEVYLScgKyBkYXRhLmYgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gKGRhdGEudW5rbm93biA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmpheC51bmtub3duVGV4dChTdHJpbmcuZnJvbUNvZGVQb2ludChuKSwgdmFyaWFudCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sKCdtangtYycsIHsgY2xhc3M6IHRoaXMuY2hhcihuKSArIGZvbnQgfSkpO1xuICAgICAgICAgICAgICAgICAgICBhZGFwdG9yLmFwcGVuZChwYXJlbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAhZGF0YS51bmtub3duICYmIHRoaXMuZm9udC5jaGFyVXNhZ2UuYWRkKFt2YXJpYW50LCBuXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyc18xXzEgJiYgIWNoYXJzXzFfMS5kb25lICYmIChfYSA9IGNoYXJzXzEucmV0dXJuKSkgX2EuY2FsbChjaGFyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTFRleHROb2RlLmtpbmQgPSBNbWxOb2RlX2pzXzEuVGV4dE5vZGUucHJvdG90eXBlLmtpbmQ7XG4gICAgQ0hUTUxUZXh0Tm9kZS5hdXRvU3R5bGUgPSBmYWxzZTtcbiAgICBDSFRNTFRleHROb2RlLnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1jJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC11dGV4dCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgcGFkZGluZzogJy43NWVtIDAgLjJlbSAwJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxUZXh0Tm9kZTtcbn0oKDAsIFRleHROb2RlX2pzXzEuQ29tbW9uVGV4dE5vZGVNaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxUZXh0Tm9kZSA9IENIVE1MVGV4dE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0Tm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbWFjdGlvbiA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtYWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21hY3Rpb24uanNcIik7XG52YXIgbWFjdGlvbl9qc18yID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tYWN0aW9uLmpzXCIpO1xudmFyIG1hY3Rpb25fanNfMyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbWFjdGlvbi5qc1wiKTtcbnZhciBDSFRNTG1hY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1hY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbWFjdGlvbi5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnNlbGVjdGVkO1xuICAgICAgICBjaGlsZC50b0NIVE1MKGNodG1sKTtcbiAgICAgICAgdGhpcy5hY3Rpb24odGhpcywgdGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIENIVE1MbWFjdGlvbi5wcm90b3R5cGUuc2V0RXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jaHRtbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgQ0hUTUxtYWN0aW9uLmtpbmQgPSBtYWN0aW9uX2pzXzMuTW1sTWFjdGlvbi5wcm90b3R5cGUua2luZDtcbiAgICBDSFRNTG1hY3Rpb24uc3R5bGVzID0ge1xuICAgICAgICAnbWp4LW1hY3Rpb24nOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1hY3Rpb24gPiBtangtdG9vbCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgYm90dG9tOiAwLCByaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAnei1pbmRleCc6IDUwMFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LXRvb2wgPiBtangtdGlwJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICBwYWRkaW5nOiAnLjJlbScsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgIzg4OCcsXG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzcwJScsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjRjhGOEY4JyxcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgJ2JveC1zaGFkb3cnOiAnMnB4IDJweCA1cHggI0FBQUFBQSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tYWN0aW9uW3RvZ2dsZV0nOiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN0YXR1cyc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgIGxlZnQ6ICcxZW0nLFxuICAgICAgICAgICAgYm90dG9tOiAnMWVtJyxcbiAgICAgICAgICAgICdtaW4td2lkdGgnOiAnMjUlJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcuMmVtIC40ZW0nLFxuICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM4ODgnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICc5MCUnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnI0Y4RjhGOCcsXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG1hY3Rpb24uYWN0aW9ucyA9IG5ldyBNYXAoW1xuICAgICAgICBbJ3RvZ2dsZScsIFtmdW5jdGlvbiAobm9kZSwgX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGFwdG9yLnNldEF0dHJpYnV0ZShub2RlLmNodG1sLCAndG9nZ2xlJywgbm9kZS5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdzZWxlY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRoID0gbm9kZS5mYWN0b3J5LmpheC5tYXRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnQgPSBub2RlLmZhY3RvcnkuamF4LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW1sID0gbm9kZS5ub2RlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEV2ZW50SGFuZGxlcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0aC5lbmQubm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGguc3RhcnQubm9kZSA9IG1hdGguZW5kLm5vZGUgPSBtYXRoLnR5cGVzZXRSb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGguc3RhcnQubiA9IG1hdGguZW5kLm4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW1sLm5leHRUb2dnbGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgucmVyZW5kZXIoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHt9XV0sXG4gICAgICAgIFsndG9vbHRpcCcsIFtmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwID0gbm9kZS5jaGlsZE5vZGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpcC5ub2RlLmlzS2luZCgnbXRleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aXAubm9kZS5nZXRUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkYXB0b3Iuc2V0QXR0cmlidXRlKG5vZGUuY2h0bWwsICd0aXRsZScsIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkYXB0b3JfMSA9IG5vZGUuYWRhcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b29sXzEgPSBhZGFwdG9yXzEuYXBwZW5kKG5vZGUuY2h0bWwsIG5vZGUuaHRtbCgnbWp4LXRvb2wnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgYm90dG9tOiBub2RlLmVtKC1ub2RlLmR5KSwgcmlnaHQ6IG5vZGUuZW0oLW5vZGUuZHgpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtub2RlLmh0bWwoJ21qeC10aXAnKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpcC50b0NIVE1MKGFkYXB0b3JfMS5maXJzdENoaWxkKHRvb2xfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRFdmVudEhhbmRsZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3RvcFRpbWVycyhub2RlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRhcHRvcl8xLnNldFN0eWxlKHRvb2xfMSwgJ2Rpc3BsYXknLCAnYmxvY2snKTsgfSwgZGF0YS5wb3N0RGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaG92ZXJUaW1lci5zZXQobm9kZSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0RXZlbnRIYW5kbGVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3RvcFRpbWVycyhub2RlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRhcHRvcl8xLnNldFN0eWxlKHRvb2xfMSwgJ2Rpc3BsYXknLCAnJyk7IH0sIGRhdGEuY2xlYXJEZWxheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jbGVhclRpbWVyLnNldChub2RlLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgbWFjdGlvbl9qc18yLlRvb2x0aXBEYXRhXV0sXG4gICAgICAgIFsnc3RhdHVzbGluZScsIFtmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwID0gbm9kZS5jaGlsZE5vZGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpcC5ub2RlLmlzS2luZCgnbXRleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkYXB0b3JfMiA9IG5vZGUuYWRhcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0XzEgPSB0aXAubm9kZS5nZXRUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGFwdG9yXzIuc2V0QXR0cmlidXRlKG5vZGUuY2h0bWwsICdzdGF0dXNsaW5lJywgdGV4dF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0RXZlbnRIYW5kbGVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhZGFwdG9yXzIuYm9keShhZGFwdG9yXzIuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IGFkYXB0b3JfMi5hcHBlbmQoYm9keSwgbm9kZS5odG1sKCdtangtc3RhdHVzJywge30sIFtub2RlLnRleHQodGV4dF8xKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0RXZlbnRIYW5kbGVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGFwdG9yXzIucmVtb3ZlKGRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGF0dXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG51bGxcbiAgICAgICAgICAgICAgICB9XV1cbiAgICBdKTtcbiAgICByZXR1cm4gQ0hUTUxtYWN0aW9uO1xufSgoMCwgbWFjdGlvbl9qc18xLkNvbW1vbk1hY3Rpb25NaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxtYWN0aW9uID0gQ0hUTUxtYWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbWF0aCA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtYXRoX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21hdGguanNcIik7XG52YXIgbWF0aF9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tYXRoLmpzXCIpO1xudmFyIEJCb3hfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL0JCb3guanNcIik7XG52YXIgQ0hUTUxtYXRoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtYXRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbWF0aCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1hdGgucHJvdG90eXBlLnRvQ0hUTUwgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudG9DSFRNTC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICAgIHZhciBjaHRtbCA9IHRoaXMuY2h0bWw7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgZGlzcGxheSA9ICh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJyk7XG4gICAgICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICAgICAgICBhZGFwdG9yLnNldEF0dHJpYnV0ZShjaHRtbCwgJ2Rpc3BsYXknLCAndHJ1ZScpO1xuICAgICAgICAgICAgYWRhcHRvci5zZXRBdHRyaWJ1dGUocGFyZW50LCAnZGlzcGxheScsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc3BsYXkocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5saW5lKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRvci5hZGRDbGFzcyhjaHRtbCwgJ01KWC1URVgnKTtcbiAgICB9O1xuICAgIENIVE1MbWF0aC5wcm90b3R5cGUuaGFuZGxlRGlzcGxheSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmdldEFsaWduU2hpZnQoKSwgMiksIGFsaWduID0gX2FbMF0sIHNoaWZ0ID0gX2FbMV07XG4gICAgICAgIGlmIChhbGlnbiAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0QXR0cmlidXRlKHBhcmVudCwgJ2p1c3RpZnknLCBhbGlnbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmJveC5wd2lkdGggPT09IEJCb3hfanNfMS5CQm94LmZ1bGxXaWR0aCkge1xuICAgICAgICAgICAgYWRhcHRvci5zZXRBdHRyaWJ1dGUocGFyZW50LCAnd2lkdGgnLCAnZnVsbCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuamF4LnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5qYXgudGFibGUuZ2V0T3V0ZXJCQm94KCksIEwgPSBfYi5MLCB3ID0gX2IudywgUiA9IF9iLlI7XG4gICAgICAgICAgICAgICAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIFIgPSBNYXRoLm1heChSIHx8IC1zaGlmdCwgLXNoaWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICBMID0gTWF0aC5tYXgoTCB8fCBzaGlmdCwgc2hpZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSAyICogTWF0aC5hYnMoc2hpZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgVyA9IHRoaXMuZW0oTWF0aC5tYXgoMCwgTCArIHcgKyBSKSk7XG4gICAgICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShwYXJlbnQsICdtaW4td2lkdGgnLCBXKTtcbiAgICAgICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHRoaXMuamF4LnRhYmxlLmNodG1sLCAnbWluLXdpZHRoJywgVyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEluZGVudCh0aGlzLmNodG1sLCBhbGlnbiwgc2hpZnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG1hdGgucHJvdG90eXBlLmhhbmRsZUlubGluZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIHZhciBtYXJnaW4gPSBhZGFwdG9yLmdldFN0eWxlKHRoaXMuY2h0bWwsICdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgaWYgKG1hcmdpbikge1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAnbWFyZ2luLXJpZ2h0JywgJycpO1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShwYXJlbnQsICdtYXJnaW4tcmlnaHQnLCBtYXJnaW4pO1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShwYXJlbnQsICd3aWR0aCcsICcwJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbWF0aC5wcm90b3R5cGUuc2V0Q2hpbGRQV2lkdGhzID0gZnVuY3Rpb24gKHJlY29tcHV0ZSwgdywgY2xlYXIpIHtcbiAgICAgICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gbnVsbDsgfVxuICAgICAgICBpZiAoY2xlYXIgPT09IHZvaWQgMCkgeyBjbGVhciA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnBhcmVudCA/IF9zdXBlci5wcm90b3R5cGUuc2V0Q2hpbGRQV2lkdGhzLmNhbGwodGhpcywgcmVjb21wdXRlLCB3LCBjbGVhcikgOiBmYWxzZSk7XG4gICAgfTtcbiAgICBDSFRNTG1hdGgua2luZCA9IG1hdGhfanNfMi5NbWxNYXRoLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbWF0aC5zdHlsZXMgPSB7XG4gICAgICAgICdtangtbWF0aCc6IHtcbiAgICAgICAgICAgICdsaW5lLWhlaWdodCc6IDAsXG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdsZWZ0JyxcbiAgICAgICAgICAgICd0ZXh0LWluZGVudCc6IDAsXG4gICAgICAgICAgICAnZm9udC1zdHlsZSc6ICdub3JtYWwnLFxuICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzEwMCUnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnbm9uZScsXG4gICAgICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICdib3JkZXItY29sbGFwc2UnOiAnY29sbGFwc2UnLFxuICAgICAgICAgICAgJ3dvcmQtd3JhcCc6ICdub3JtYWwnLFxuICAgICAgICAgICAgJ3dvcmQtc3BhY2luZyc6ICdub3JtYWwnLFxuICAgICAgICAgICAgJ3doaXRlLXNwYWNlJzogJ25vd3JhcCcsXG4gICAgICAgICAgICAnZGlyZWN0aW9uJzogJ2x0cicsXG4gICAgICAgICAgICAncGFkZGluZyc6ICcxcHggMCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXJbamF4PVwiQ0hUTUxcIl1bZGlzcGxheT1cInRydWVcIl0nOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAgIG1hcmdpbjogJzFlbSAwJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LWNvbnRhaW5lcltqYXg9XCJDSFRNTFwiXVtkaXNwbGF5PVwidHJ1ZVwiXVt3aWR0aD1cImZ1bGxcIl0nOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXJbamF4PVwiQ0hUTUxcIl1bZGlzcGxheT1cInRydWVcIl0gbWp4LW1hdGgnOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtY29udGFpbmVyW2pheD1cIkNIVE1MXCJdW2p1c3RpZnk9XCJsZWZ0XCJdJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1jb250YWluZXJbamF4PVwiQ0hUTUxcIl1banVzdGlmeT1cInJpZ2h0XCJdJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDSFRNTG1hdGg7XG59KCgwLCBtYXRoX2pzXzEuQ29tbW9uTWF0aE1peGluKShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSkpO1xuZXhwb3J0cy5DSFRNTG1hdGggPSBDSFRNTG1hdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1lbmNsb3NlID0gdm9pZCAwO1xudmFyIFdyYXBwZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9XcmFwcGVyLmpzXCIpO1xudmFyIG1lbmNsb3NlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21lbmNsb3NlLmpzXCIpO1xudmFyIE5vdGF0aW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9Ob3RhdGlvbi5qc1wiKSk7XG52YXIgbWVuY2xvc2VfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbWVuY2xvc2UuanNcIik7XG52YXIgbGVuZ3Roc19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvbGVuZ3Rocy5qc1wiKTtcbmZ1bmN0aW9uIEFuZ2xlKHgsIHkpIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih4LCB5KS50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJyk7XG59XG52YXIgQU5HTEUgPSBBbmdsZShOb3RhdGlvbi5BUlJPV0RYLCBOb3RhdGlvbi5BUlJPV1kpO1xudmFyIENIVE1MbWVuY2xvc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1lbmNsb3NlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbWVuY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtZW5jbG9zZS5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgY2h0bWwgPSB0aGlzLnN0YW5kYXJkQ0hUTUxub2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBibG9jayA9IGFkYXB0b3IuYXBwZW5kKGNodG1sLCB0aGlzLmh0bWwoJ21qeC1ib3gnKSk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlckNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkKHRoaXMsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS50b0NIVE1MKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLm5vdGF0aW9ucykpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBub3RhdGlvbiA9IHRoaXMubm90YXRpb25zW25hbWVfMV07XG4gICAgICAgICAgICAgICAgIW5vdGF0aW9uLnJlbmRlckNoaWxkICYmIG5vdGF0aW9uLnJlbmRlcmVyKHRoaXMsIGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYm94ID0gdGhpcy5nZXRQYWRkaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKE5vdGF0aW9uLnNpZGVOYW1lcyksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBOb3RhdGlvbi5zaWRlSW5kZXhbbmFtZV8yXTtcbiAgICAgICAgICAgICAgICBwYm94W2ldID4gMCAmJiBhZGFwdG9yLnNldFN0eWxlKGJsb2NrLCAncGFkZGluZy0nICsgbmFtZV8yLCB0aGlzLmVtKHBib3hbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG1lbmNsb3NlLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICh3LCBhLCBkb3VibGUsIG9mZnNldCwgZGlzdCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gJyc7IH1cbiAgICAgICAgaWYgKGRpc3QgPT09IHZvaWQgMCkgeyBkaXN0ID0gMDsgfVxuICAgICAgICB2YXIgVyA9IHRoaXMuZ2V0QkJveCgpLnc7XG4gICAgICAgIHZhciBzdHlsZSA9IHsgd2lkdGg6IHRoaXMuZW0odykgfTtcbiAgICAgICAgaWYgKFcgIT09IHcpIHtcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSB0aGlzLmVtKChXIC0gdykgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgdGhpcy5maXhlZChhKSArICdyYWQpJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyb3cgPSB0aGlzLmh0bWwoJ21qeC1hcnJvdycsIHsgc3R5bGU6IHN0eWxlIH0sIFtcbiAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWFsaW5lJyksIHRoaXMuaHRtbCgnbWp4LXJ0aGVhZCcpLCB0aGlzLmh0bWwoJ21qeC1yYmhlYWQnKVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGRvdWJsZSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLmFwcGVuZChhcnJvdywgdGhpcy5odG1sKCdtangtbHRoZWFkJykpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLmFwcGVuZChhcnJvdywgdGhpcy5odG1sKCdtangtbGJoZWFkJykpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZShhcnJvdywgJ2RvdWJsZScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGp1c3RBcnJvdyhhcnJvdywgZG91YmxlKTtcbiAgICAgICAgdGhpcy5tb3ZlQXJyb3coYXJyb3csIG9mZnNldCwgZGlzdCk7XG4gICAgICAgIHJldHVybiBhcnJvdztcbiAgICB9O1xuICAgIENIVE1MbWVuY2xvc2UucHJvdG90eXBlLmFkanVzdEFycm93ID0gZnVuY3Rpb24gKGFycm93LCBkb3VibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRoaWNrbmVzcztcbiAgICAgICAgdmFyIGhlYWQgPSB0aGlzLmFycm93aGVhZDtcbiAgICAgICAgaWYgKGhlYWQueCA9PT0gTm90YXRpb24uQVJST1dYICYmIGhlYWQueSA9PT0gTm90YXRpb24uQVJST1dZICYmXG4gICAgICAgICAgICBoZWFkLmR4ID09PSBOb3RhdGlvbi5BUlJPV0RYICYmIHQgPT09IE5vdGF0aW9uLlRISUNLTkVTUylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKFt0ICogaGVhZC54LCB0ICogaGVhZC55XS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIF90aGlzLmVtKHgpOyB9KSwgMiksIHggPSBfYVswXSwgeSA9IF9hWzFdO1xuICAgICAgICB2YXIgYSA9IEFuZ2xlKGhlYWQuZHgsIGhlYWQueSk7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZCh0aGlzLmFkYXB0b3IuY2hpbGROb2RlcyhhcnJvdyksIDUpLCBsaW5lID0gX2JbMF0sIHJ0aGVhZCA9IF9iWzFdLCByYmhlYWQgPSBfYlsyXSwgbHRoZWFkID0gX2JbM10sIGxiaGVhZCA9IF9iWzRdO1xuICAgICAgICB0aGlzLmFkanVzdEhlYWQocnRoZWFkLCBbeSwgJzAnLCAnMXB4JywgeF0sIGEpO1xuICAgICAgICB0aGlzLmFkanVzdEhlYWQocmJoZWFkLCBbJzFweCcsICcwJywgeSwgeF0sICctJyArIGEpO1xuICAgICAgICB0aGlzLmFkanVzdEhlYWQobHRoZWFkLCBbeSwgeCwgJzFweCcsICcwJ10sICctJyArIGEpO1xuICAgICAgICB0aGlzLmFkanVzdEhlYWQobGJoZWFkLCBbJzFweCcsIHgsIHksICcwJ10sIGEpO1xuICAgICAgICB0aGlzLmFkanVzdExpbmUobGluZSwgdCwgaGVhZC54LCBkb3VibGUpO1xuICAgIH07XG4gICAgQ0hUTUxtZW5jbG9zZS5wcm90b3R5cGUuYWRqdXN0SGVhZCA9IGZ1bmN0aW9uIChoZWFkLCBib3JkZXIsIGEpIHtcbiAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShoZWFkLCAnYm9yZGVyLXdpZHRoJywgYm9yZGVyLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoaGVhZCwgJ3RyYW5zZm9ybScsICdza2V3WCgnICsgYSArICdyYWQpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbWVuY2xvc2UucHJvdG90eXBlLmFkanVzdExpbmUgPSBmdW5jdGlvbiAobGluZSwgdCwgeCwgZG91YmxlKSB7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShsaW5lLCAnYm9yZGVyVG9wJywgdGhpcy5lbSh0KSArICcgc29saWQnKTtcbiAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGxpbmUsICd0b3AnLCB0aGlzLmVtKC10IC8gMikpO1xuICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUobGluZSwgJ3JpZ2h0JywgdGhpcy5lbSh0ICogKHggLSAxKSkpO1xuICAgICAgICBpZiAoZG91YmxlKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUobGluZSwgJ2xlZnQnLCB0aGlzLmVtKHQgKiAoeCAtIDEpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbWVuY2xvc2UucHJvdG90eXBlLm1vdmVBcnJvdyA9IGZ1bmN0aW9uIChhcnJvdywgb2Zmc2V0LCBkKSB7XG4gICAgICAgIGlmICghZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuYWRhcHRvci5nZXRTdHlsZShhcnJvdywgJ3RyYW5zZm9ybScpO1xuICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoYXJyb3csICd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZVwiLmNvbmNhdChvZmZzZXQsIFwiKFwiKS5jb25jYXQodGhpcy5lbSgtZCksIFwiKVwiKS5jb25jYXQoKHRyYW5zZm9ybSA/ICcgJyArIHRyYW5zZm9ybSA6ICcnKSkpO1xuICAgIH07XG4gICAgQ0hUTUxtZW5jbG9zZS5wcm90b3R5cGUuYWRqdXN0Qm9yZGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGhpY2tuZXNzICE9PSBOb3RhdGlvbi5USElDS05FU1MpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShub2RlLCAnYm9yZGVyV2lkdGgnLCB0aGlzLmVtKHRoaXMudGhpY2tuZXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBDSFRNTG1lbmNsb3NlLnByb3RvdHlwZS5hZGp1c3RUaGlja25lc3MgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGhpY2tuZXNzICE9PSBOb3RhdGlvbi5USElDS05FU1MpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShzaGFwZSwgJ3N0cm9rZVdpZHRoJywgdGhpcy5maXhlZCh0aGlzLnRoaWNrbmVzcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9O1xuICAgIENIVE1MbWVuY2xvc2UucHJvdG90eXBlLmZpeGVkID0gZnVuY3Rpb24gKG0sIG4pIHtcbiAgICAgICAgaWYgKG4gPT09IHZvaWQgMCkgeyBuID0gMzsgfVxuICAgICAgICBpZiAoTWF0aC5hYnMobSkgPCAuMDAwNikge1xuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50b0ZpeGVkKG4pLnJlcGxhY2UoL1xcLj8wKyQvLCAnJyk7XG4gICAgfTtcbiAgICBDSFRNTG1lbmNsb3NlLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVtLmNhbGwodGhpcywgbSk7XG4gICAgfTtcbiAgICBDSFRNTG1lbmNsb3NlLmtpbmQgPSBtZW5jbG9zZV9qc18yLk1tbE1lbmNsb3NlLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbWVuY2xvc2Uuc3R5bGVzID0ge1xuICAgICAgICAnbWp4LW1lbmNsb3NlJzoge1xuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZW5jbG9zZSA+IG1qeC1kc3RyaWtlJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICBsZWZ0OiAwLCB0b3A6IDAsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICdib3JkZXItdG9wJzogTm90YXRpb24uU09MSUQsXG4gICAgICAgICAgICAndHJhbnNmb3JtLW9yaWdpbic6ICd0b3AgbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZW5jbG9zZSA+IG1qeC11c3RyaWtlJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICBsZWZ0OiAwLCBib3R0b206IDAsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICdib3JkZXItdG9wJzogTm90YXRpb24uU09MSUQsXG4gICAgICAgICAgICAndHJhbnNmb3JtLW9yaWdpbic6ICdib3R0b20gbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZW5jbG9zZSA+IG1qeC1oc3RyaWtlJzoge1xuICAgICAgICAgICAgJ2JvcmRlci10b3AnOiBOb3RhdGlvbi5TT0xJRCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgbGVmdDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogJzUwJScsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKCcgKyAoMCwgbGVuZ3Roc19qc18xLmVtKShOb3RhdGlvbi5USElDS05FU1MgLyAyKSArICcpJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1lbmNsb3NlID4gbWp4LXZzdHJpa2UnOiB7XG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQnOiBOb3RhdGlvbi5TT0xJRCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAwLCBib3R0b206IDAsIHJpZ2h0OiAnNTAlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoJyArICgwLCBsZW5ndGhzX2pzXzEuZW0pKE5vdGF0aW9uLlRISUNLTkVTUyAvIDIpICsgJyknXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbWVuY2xvc2UgPiBtangtcmJveCc6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAwLCBib3R0b206IDAsIHJpZ2h0OiAwLCBsZWZ0OiAwLFxuICAgICAgICAgICAgJ2JvcmRlcic6IE5vdGF0aW9uLlNPTElELFxuICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAoMCwgbGVuZ3Roc19qc18xLmVtKShOb3RhdGlvbi5USElDS05FU1MgKyBOb3RhdGlvbi5QQURESU5HKVxuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1lbmNsb3NlID4gbWp4LWNib3gnOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogMCwgYm90dG9tOiAwLCByaWdodDogMCwgbGVmdDogMCxcbiAgICAgICAgICAgICdib3JkZXInOiBOb3RhdGlvbi5TT0xJRCxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzUwJSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZW5jbG9zZSA+IG1qeC1hcnJvdyc6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgbGVmdDogMCwgYm90dG9tOiAnNTAlJywgaGVpZ2h0OiAwLCB3aWR0aDogMFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1lbmNsb3NlID4gbWp4LWFycm93ID4gKic6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogJ2JvdHRvbScsXG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQnOiAoMCwgbGVuZ3Roc19qc18xLmVtKShOb3RhdGlvbi5USElDS05FU1MgKiBOb3RhdGlvbi5BUlJPV1gpICsgJyBzb2xpZCcsXG4gICAgICAgICAgICAnYm9yZGVyLXJpZ2h0JzogMCxcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbWVuY2xvc2UgPiBtangtYXJyb3cgPiBtangtYWxpbmUnOiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCB0b3A6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKC1Ob3RhdGlvbi5USElDS05FU1MgLyAyKSxcbiAgICAgICAgICAgIHJpZ2h0OiAoMCwgbGVuZ3Roc19qc18xLmVtKShOb3RhdGlvbi5USElDS05FU1MgKiAoTm90YXRpb24uQVJST1dYIC0gMSkpLCBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAnYm9yZGVyLXRvcCc6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKE5vdGF0aW9uLlRISUNLTkVTUykgKyAnIHNvbGlkJyxcbiAgICAgICAgICAgICdib3JkZXItbGVmdCc6IDBcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZW5jbG9zZSA+IG1qeC1hcnJvd1tkb3VibGVdID4gbWp4LWFsaW5lJzoge1xuICAgICAgICAgICAgbGVmdDogKDAsIGxlbmd0aHNfanNfMS5lbSkoTm90YXRpb24uVEhJQ0tORVNTICogKE5vdGF0aW9uLkFSUk9XWCAtIDEpKSwgaGVpZ2h0OiAwLFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1lbmNsb3NlID4gbWp4LWFycm93ID4gbWp4LXJ0aGVhZCc6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NrZXdYKCcgKyBBTkdMRSArICdyYWQpJyxcbiAgICAgICAgICAgIHJpZ2h0OiAwLCBib3R0b206ICctMXB4JyxcbiAgICAgICAgICAgICdib3JkZXItYm90dG9tJzogJzFweCBzb2xpZCB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAnYm9yZGVyLXRvcCc6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKE5vdGF0aW9uLlRISUNLTkVTUyAqIE5vdGF0aW9uLkFSUk9XWSkgKyAnIHNvbGlkIHRyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1lbmNsb3NlID4gbWp4LWFycm93ID4gbWp4LXJiaGVhZCc6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NrZXdYKC0nICsgQU5HTEUgKyAncmFkKScsXG4gICAgICAgICAgICAndHJhbnNmb3JtLW9yaWdpbic6ICd0b3AnLFxuICAgICAgICAgICAgcmlnaHQ6IDAsIHRvcDogJy0xcHgnLFxuICAgICAgICAgICAgJ2JvcmRlci10b3AnOiAnMXB4IHNvbGlkIHRyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICdib3JkZXItYm90dG9tJzogKDAsIGxlbmd0aHNfanNfMS5lbSkoTm90YXRpb24uVEhJQ0tORVNTICogTm90YXRpb24uQVJST1dZKSArICcgc29saWQgdHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbWVuY2xvc2UgPiBtangtYXJyb3cgPiBtangtbHRoZWFkJzoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2tld1goLScgKyBBTkdMRSArICdyYWQpJyxcbiAgICAgICAgICAgIGxlZnQ6IDAsIGJvdHRvbTogJy0xcHgnLFxuICAgICAgICAgICAgJ2JvcmRlci1sZWZ0JzogMCxcbiAgICAgICAgICAgICdib3JkZXItcmlnaHQnOiAoMCwgbGVuZ3Roc19qc18xLmVtKShOb3RhdGlvbi5USElDS05FU1MgKiBOb3RhdGlvbi5BUlJPV1gpICsgJyBzb2xpZCcsXG4gICAgICAgICAgICAnYm9yZGVyLWJvdHRvbSc6ICcxcHggc29saWQgdHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgJ2JvcmRlci10b3AnOiAoMCwgbGVuZ3Roc19qc18xLmVtKShOb3RhdGlvbi5USElDS05FU1MgKiBOb3RhdGlvbi5BUlJPV1kpICsgJyBzb2xpZCB0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tZW5jbG9zZSA+IG1qeC1hcnJvdyA+IG1qeC1sYmhlYWQnOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICdza2V3WCgnICsgQU5HTEUgKyAncmFkKScsXG4gICAgICAgICAgICAndHJhbnNmb3JtLW9yaWdpbic6ICd0b3AnLFxuICAgICAgICAgICAgbGVmdDogMCwgdG9wOiAnLTFweCcsXG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQnOiAwLFxuICAgICAgICAgICAgJ2JvcmRlci1yaWdodCc6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKE5vdGF0aW9uLlRISUNLTkVTUyAqIE5vdGF0aW9uLkFSUk9XWCkgKyAnIHNvbGlkJyxcbiAgICAgICAgICAgICdib3JkZXItdG9wJzogJzFweCBzb2xpZCB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAnYm9yZGVyLWJvdHRvbSc6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKE5vdGF0aW9uLlRISUNLTkVTUyAqIE5vdGF0aW9uLkFSUk9XWSkgKyAnIHNvbGlkIHRyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1lbmNsb3NlID4gZGJveCc6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKC0xLjUgKiBOb3RhdGlvbi5QQURESU5HKSxcbiAgICAgICAgICAgIHdpZHRoOiAoMCwgbGVuZ3Roc19qc18xLmVtKSgzICogTm90YXRpb24uUEFERElORyksXG4gICAgICAgICAgICBib3JkZXI6ICgwLCBsZW5ndGhzX2pzXzEuZW0pKE5vdGF0aW9uLlRISUNLTkVTUykgKyAnIHNvbGlkJyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzUwJScsXG4gICAgICAgICAgICAnY2xpcC1wYXRoJzogJ2luc2V0KDAgMCAwICcgKyAoMCwgbGVuZ3Roc19qc18xLmVtKSgxLjUgKiBOb3RhdGlvbi5QQURESU5HKSArICcpJyxcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbWVuY2xvc2Uubm90YXRpb25zID0gbmV3IE1hcChbXG4gICAgICAgIE5vdGF0aW9uLkJvcmRlcigndG9wJyksXG4gICAgICAgIE5vdGF0aW9uLkJvcmRlcigncmlnaHQnKSxcbiAgICAgICAgTm90YXRpb24uQm9yZGVyKCdib3R0b20nKSxcbiAgICAgICAgTm90YXRpb24uQm9yZGVyKCdsZWZ0JyksXG4gICAgICAgIE5vdGF0aW9uLkJvcmRlcjIoJ2FjdHVhcmlhbCcsICd0b3AnLCAncmlnaHQnKSxcbiAgICAgICAgTm90YXRpb24uQm9yZGVyMignbWFkcnV3YicsICdib3R0b20nLCAncmlnaHQnKSxcbiAgICAgICAgTm90YXRpb24uRGlhZ29uYWxTdHJpa2UoJ3VwJywgMSksXG4gICAgICAgIE5vdGF0aW9uLkRpYWdvbmFsU3RyaWtlKCdkb3duJywgLTEpLFxuICAgICAgICBbJ2hvcml6b250YWxzdHJpa2UnLCB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IE5vdGF0aW9uLlJlbmRlckVsZW1lbnQoJ2hzdHJpa2UnLCAnWScpLFxuICAgICAgICAgICAgICAgIGJib3g6IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBbMCwgbm9kZS5wYWRkaW5nLCAwLCBub2RlLnBhZGRpbmddOyB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgWyd2ZXJ0aWNhbHN0cmlrZScsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogTm90YXRpb24uUmVuZGVyRWxlbWVudCgndnN0cmlrZScsICdYJyksXG4gICAgICAgICAgICAgICAgYmJveDogZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIFtub2RlLnBhZGRpbmcsIDAsIG5vZGUucGFkZGluZywgMF07IH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICBbJ2JveCcsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogZnVuY3Rpb24gKG5vZGUsIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRhcHRvci5zZXRTdHlsZShjaGlsZCwgJ2JvcmRlcicsIG5vZGUuZW0obm9kZS50aGlja25lc3MpICsgJyBzb2xpZCcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmJveDogTm90YXRpb24uZnVsbEJCb3gsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBOb3RhdGlvbi5mdWxsQm9yZGVyLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogJ2xlZnQgcmlnaHQgdG9wIGJvdHRvbSdcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBbJ3JvdW5kZWRib3gnLCB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IE5vdGF0aW9uLlJlbmRlckVsZW1lbnQoJ3Jib3gnKSxcbiAgICAgICAgICAgICAgICBiYm94OiBOb3RhdGlvbi5mdWxsQkJveFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIFsnY2lyY2xlJywge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBOb3RhdGlvbi5SZW5kZXJFbGVtZW50KCdjYm94JyksXG4gICAgICAgICAgICAgICAgYmJveDogTm90YXRpb24uZnVsbEJCb3hcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBbJ3BoYXNvcmFuZ2xlJywge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBmdW5jdGlvbiAobm9kZSwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gbm9kZS5nZXRCQm94KCksIGggPSBfYS5oLCBkID0gX2EuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKG5vZGUuZ2V0QXJnTW9kKDEuNzUgKiBub2RlLnBhZGRpbmcsIGggKyBkKSwgMiksIGEgPSBfYlswXSwgVyA9IF9iWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5vZGUudGhpY2tuZXNzICogTWF0aC5zaW4oYSkgKiAuOTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGFwdG9yLnNldFN0eWxlKGNoaWxkLCAnYm9yZGVyLWJvdHRvbScsIG5vZGUuZW0obm9kZS50aGlja25lc3MpICsgJyBzb2xpZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaWtlID0gbm9kZS5hZGp1c3RCb3JkZXIobm9kZS5odG1sKCdtangtdXN0cmlrZScsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5lbShXKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKCcgKyBub2RlLmVtKHQpICsgJykgcm90YXRlKCcgKyBub2RlLmZpeGVkKC1hKSArICdyYWQpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFkYXB0b3IuYXBwZW5kKG5vZGUuY2h0bWwsIHN0cmlrZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYm94OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5vZGUucGFkZGluZyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbm9kZS50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAqIHAsIHAsIHAgKyB0LCAzICogcCArIHRdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gWzAsIDAsIG5vZGUudGhpY2tuZXNzLCAwXTsgfSxcbiAgICAgICAgICAgICAgICByZW1vdmU6ICdib3R0b20nXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgTm90YXRpb24uQXJyb3coJ3VwJyksXG4gICAgICAgIE5vdGF0aW9uLkFycm93KCdkb3duJyksXG4gICAgICAgIE5vdGF0aW9uLkFycm93KCdsZWZ0JyksXG4gICAgICAgIE5vdGF0aW9uLkFycm93KCdyaWdodCcpLFxuICAgICAgICBOb3RhdGlvbi5BcnJvdygndXBkb3duJyksXG4gICAgICAgIE5vdGF0aW9uLkFycm93KCdsZWZ0cmlnaHQnKSxcbiAgICAgICAgTm90YXRpb24uRGlhZ29uYWxBcnJvdygndXBkaWFnb25hbCcpLFxuICAgICAgICBOb3RhdGlvbi5EaWFnb25hbEFycm93KCdub3J0aGVhc3QnKSxcbiAgICAgICAgTm90YXRpb24uRGlhZ29uYWxBcnJvdygnc291dGhlYXN0JyksXG4gICAgICAgIE5vdGF0aW9uLkRpYWdvbmFsQXJyb3coJ25vcnRod2VzdCcpLFxuICAgICAgICBOb3RhdGlvbi5EaWFnb25hbEFycm93KCdzb3V0aHdlc3QnKSxcbiAgICAgICAgTm90YXRpb24uRGlhZ29uYWxBcnJvdygnbm9ydGhlYXN0c291dGh3ZXN0JyksXG4gICAgICAgIE5vdGF0aW9uLkRpYWdvbmFsQXJyb3coJ25vcnRod2VzdHNvdXRoZWFzdCcpLFxuICAgICAgICBbJ2xvbmdkaXYnLCB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uIChub2RlLCBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRhcHRvciA9IG5vZGUuYWRhcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShjaGlsZCwgJ2JvcmRlci10b3AnLCBub2RlLmVtKG5vZGUudGhpY2tuZXNzKSArICcgc29saWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyYyA9IGFkYXB0b3IuYXBwZW5kKG5vZGUuY2h0bWwsIG5vZGUuaHRtbCgnZGJveCcpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBub2RlLnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBub2RlLnBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICE9PSBOb3RhdGlvbi5USElDS05FU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoYXJjLCAnYm9yZGVyLXdpZHRoJywgbm9kZS5lbSh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT09IE5vdGF0aW9uLlBBRERJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoYXJjLCAnbGVmdCcsIG5vZGUuZW0oLTEuNSAqIHApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoYXJjLCAnd2lkdGgnLCBub2RlLmVtKDMgKiBwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKGFyYywgJ2NsaXAtcGF0aCcsICdpbnNldCgwIDAgMCAnICsgbm9kZS5lbSgxLjUgKiBwKSArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJib3g6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbm9kZS5wYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5vZGUudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3AgKyB0LCBwLCBwLCAyICogcCArIHQgLyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgWydyYWRpY2FsJywge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBmdW5jdGlvbiAobm9kZSwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tc3FydC50b0NIVE1MKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFRSQkwgPSBub2RlLnNxcnRUUkJMKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRhcHRvci5zZXRTdHlsZShub2RlLm1zcXJ0LmNodG1sLCAnbWFyZ2luJywgVFJCTC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIG5vZGUuZW0oLXgpOyB9KS5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tc3FydCA9IG5vZGUuY3JlYXRlTXNxcnQobm9kZS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJib3g6IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnNxcnRUUkJMKCk7IH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyQ2hpbGQ6IHRydWVcbiAgICAgICAgICAgIH1dXG4gICAgXSk7XG4gICAgcmV0dXJuIENIVE1MbWVuY2xvc2U7XG59KCgwLCBtZW5jbG9zZV9qc18xLkNvbW1vbk1lbmNsb3NlTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbWVuY2xvc2UgPSBDSFRNTG1lbmNsb3NlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVuY2xvc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1mZW5jZWQgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgbWZlbmNlZF9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tZmVuY2VkLmpzXCIpO1xudmFyIG1mZW5jZWRfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbWZlbmNlZC5qc1wiKTtcbnZhciBDSFRNTG1mZW5jZWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1mZW5jZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtZmVuY2VkKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbWZlbmNlZC5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICB0aGlzLm1yb3cudG9DSFRNTChjaHRtbCk7XG4gICAgfTtcbiAgICBDSFRNTG1mZW5jZWQua2luZCA9IG1mZW5jZWRfanNfMi5NbWxNZmVuY2VkLnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTG1mZW5jZWQ7XG59KCgwLCBtZmVuY2VkX2pzXzEuQ29tbW9uTWZlbmNlZE1peGluKShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSkpO1xuZXhwb3J0cy5DSFRNTG1mZW5jZWQgPSBDSFRNTG1mZW5jZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZmVuY2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbWZyYWMgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgbWZyYWNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbWZyYWMuanNcIik7XG52YXIgbWZyYWNfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbWZyYWMuanNcIik7XG52YXIgQ0hUTUxtZnJhYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MbWZyYWMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtZnJhYygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1mcmFjLnByb3RvdHlwZS50b0NIVE1MID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLnN0YW5kYXJkQ0hUTUxub2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldExpc3QoJ2xpbmV0aGlja25lc3MnLCAnYmV2ZWxsZWQnKSwgbGluZXRoaWNrbmVzcyA9IF9hLmxpbmV0aGlja25lc3MsIGJldmVsbGVkID0gX2EuYmV2ZWxsZWQ7XG4gICAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5pc0Rpc3BsYXkoKTtcbiAgICAgICAgaWYgKGJldmVsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1ha2VCZXZlbGxlZChkaXNwbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aGlja25lc3MgPSB0aGlzLmxlbmd0aDJlbShTdHJpbmcobGluZXRoaWNrbmVzcyksIC4wNik7XG4gICAgICAgICAgICBpZiAodGhpY2tuZXNzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlQXRvcChkaXNwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZUZyYWN0aW9uKGRpc3BsYXksIHRoaWNrbmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbWZyYWMucHJvdG90eXBlLm1ha2VGcmFjdGlvbiA9IGZ1bmN0aW9uIChkaXNwbGF5LCB0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldExpc3QoJ251bWFsaWduJywgJ2Rlbm9tYWxpZ24nKSwgbnVtYWxpZ24gPSBfYS5udW1hbGlnbiwgZGVub21hbGlnbiA9IF9hLmRlbm9tYWxpZ247XG4gICAgICAgIHZhciB3aXRoRGVsaW1zID0gdGhpcy5ub2RlLmdldFByb3BlcnR5KCd3aXRoRGVsaW1zJyk7XG4gICAgICAgIHZhciBhdHRyID0gKGRpc3BsYXkgPyB7IHR5cGU6ICdkJyB9IDoge30pO1xuICAgICAgICB2YXIgZmF0dHIgPSAod2l0aERlbGltcyA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBhdHRyKSwgeyBkZWxpbXM6ICd0cnVlJyB9KSA6IF9fYXNzaWduKHt9LCBhdHRyKSk7XG4gICAgICAgIHZhciBuYXR0ciA9IChudW1hbGlnbiAhPT0gJ2NlbnRlcicgPyB7IGFsaWduOiBudW1hbGlnbiB9IDoge30pO1xuICAgICAgICB2YXIgZGF0dHIgPSAoZGVub21hbGlnbiAhPT0gJ2NlbnRlcicgPyB7IGFsaWduOiBkZW5vbWFsaWduIH0gOiB7fSk7XG4gICAgICAgIHZhciBkc2F0dHIgPSBfX2Fzc2lnbih7fSwgYXR0ciksIG5zYXR0ciA9IF9fYXNzaWduKHt9LCBhdHRyKTtcbiAgICAgICAgdmFyIHRleCA9IHRoaXMuZm9udC5wYXJhbXM7XG4gICAgICAgIGlmICh0ICE9PSAuMDYpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGV4LmF4aXNfaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHRFbSA9IHRoaXMuZW0odCk7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLmdldFRVVihkaXNwbGF5LCB0KSwgVCA9IF9iLlQsIHUgPSBfYi51LCB2ID0gX2IudjtcbiAgICAgICAgICAgIHZhciBtID0gKGRpc3BsYXkgPyB0aGlzLmVtKDMgKiB0KSA6IHRFbSkgKyAnIC0uMWVtJztcbiAgICAgICAgICAgIGF0dHIuc3R5bGUgPSB7IGhlaWdodDogdEVtLCAnYm9yZGVyLXRvcCc6IHRFbSArICcgc29saWQnLCBtYXJnaW46IG0gfTtcbiAgICAgICAgICAgIHZhciBuaCA9IHRoaXMuZW0oTWF0aC5tYXgoMCwgdSkpO1xuICAgICAgICAgICAgbnNhdHRyLnN0eWxlID0geyBoZWlnaHQ6IG5oLCAndmVydGljYWwtYWxpZ24nOiAnLScgKyBuaCB9O1xuICAgICAgICAgICAgZHNhdHRyLnN0eWxlID0geyBoZWlnaHQ6IHRoaXMuZW0oTWF0aC5tYXgoMCwgdikpIH07XG4gICAgICAgICAgICBmYXR0ci5zdHlsZSA9IHsgJ3ZlcnRpY2FsLWFsaWduJzogdGhpcy5lbShhIC0gVCkgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtLCBkZW47XG4gICAgICAgIHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5jaHRtbCwgdGhpcy5odG1sKCdtangtZnJhYycsIGZhdHRyLCBbXG4gICAgICAgICAgICBudW0gPSB0aGlzLmh0bWwoJ21qeC1udW0nLCBuYXR0ciwgW3RoaXMuaHRtbCgnbWp4LW5zdHJ1dCcsIG5zYXR0cildKSxcbiAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWRib3gnLCB7fSwgW1xuICAgICAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWR0YWJsZScsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWxpbmUnLCBhdHRyKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sKCdtangtcm93Jywge30sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbiA9IHRoaXMuaHRtbCgnbWp4LWRlbicsIGRhdHRyLCBbdGhpcy5odG1sKCdtangtZHN0cnV0JywgZHNhdHRyKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pKTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLnRvQ0hUTUwobnVtKTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzFdLnRvQ0hUTUwoZGVuKTtcbiAgICB9O1xuICAgIENIVE1MbWZyYWMucHJvdG90eXBlLm1ha2VBdG9wID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0TGlzdCgnbnVtYWxpZ24nLCAnZGVub21hbGlnbicpLCBudW1hbGlnbiA9IF9hLm51bWFsaWduLCBkZW5vbWFsaWduID0gX2EuZGVub21hbGlnbjtcbiAgICAgICAgdmFyIHdpdGhEZWxpbXMgPSB0aGlzLm5vZGUuZ2V0UHJvcGVydHkoJ3dpdGhEZWxpbXMnKTtcbiAgICAgICAgdmFyIGF0dHIgPSAoZGlzcGxheSA/IHsgdHlwZTogJ2QnLCBhdG9wOiB0cnVlIH0gOiB7IGF0b3A6IHRydWUgfSk7XG4gICAgICAgIHZhciBmYXR0ciA9ICh3aXRoRGVsaW1zID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGF0dHIpLCB7IGRlbGltczogdHJ1ZSB9KSA6IF9fYXNzaWduKHt9LCBhdHRyKSk7XG4gICAgICAgIHZhciBuYXR0ciA9IChudW1hbGlnbiAhPT0gJ2NlbnRlcicgPyB7IGFsaWduOiBudW1hbGlnbiB9IDoge30pO1xuICAgICAgICB2YXIgZGF0dHIgPSAoZGVub21hbGlnbiAhPT0gJ2NlbnRlcicgPyB7IGFsaWduOiBkZW5vbWFsaWduIH0gOiB7fSk7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuZ2V0VVZRKGRpc3BsYXkpLCB2ID0gX2IudiwgcSA9IF9iLnE7XG4gICAgICAgIG5hdHRyLnN0eWxlID0geyAncGFkZGluZy1ib3R0b20nOiB0aGlzLmVtKHEpIH07XG4gICAgICAgIGZhdHRyLnN0eWxlID0geyAndmVydGljYWwtYWxpZ24nOiB0aGlzLmVtKC12KSB9O1xuICAgICAgICB2YXIgbnVtLCBkZW47XG4gICAgICAgIHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5jaHRtbCwgdGhpcy5odG1sKCdtangtZnJhYycsIGZhdHRyLCBbXG4gICAgICAgICAgICBudW0gPSB0aGlzLmh0bWwoJ21qeC1udW0nLCBuYXR0ciksXG4gICAgICAgICAgICBkZW4gPSB0aGlzLmh0bWwoJ21qeC1kZW4nLCBkYXR0cilcbiAgICAgICAgXSkpO1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0udG9DSFRNTChudW0pO1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMV0udG9DSFRNTChkZW4pO1xuICAgIH07XG4gICAgQ0hUTUxtZnJhYy5wcm90b3R5cGUubWFrZUJldmVsbGVkID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIGFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICdiZXZlbGxlZCcsICd0dXJlJyk7XG4gICAgICAgIHZhciBudW0gPSBhZGFwdG9yLmFwcGVuZCh0aGlzLmNodG1sLCB0aGlzLmh0bWwoJ21qeC1udW0nKSk7XG4gICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS50b0NIVE1MKG51bSk7XG4gICAgICAgIHRoaXMuYmV2ZWwudG9DSFRNTCh0aGlzLmNodG1sKTtcbiAgICAgICAgdmFyIGRlbiA9IGFkYXB0b3IuYXBwZW5kKHRoaXMuY2h0bWwsIHRoaXMuaHRtbCgnbWp4LWRlbicpKTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzFdLnRvQ0hUTUwoZGVuKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRCZXZlbERhdGEoZGlzcGxheSksIHUgPSBfYS51LCB2ID0gX2EudiwgZGVsdGEgPSBfYS5kZWx0YSwgbmJveCA9IF9hLm5ib3gsIGRib3ggPSBfYS5kYm94O1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShudW0sICd2ZXJ0aWNhbEFsaWduJywgdGhpcy5lbSh1IC8gbmJveC5zY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKGRlbiwgJ3ZlcnRpY2FsQWxpZ24nLCB0aGlzLmVtKHYgLyBkYm94LnNjYWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR4ID0gdGhpcy5lbSgtZGVsdGEgLyAyKTtcbiAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLmJldmVsLmNodG1sLCAnbWFyZ2luTGVmdCcsIGR4KTtcbiAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLmJldmVsLmNodG1sLCAnbWFyZ2luUmlnaHQnLCBkeCk7XG4gICAgfTtcbiAgICBDSFRNTG1mcmFjLmtpbmQgPSBtZnJhY19qc18yLk1tbE1mcmFjLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbWZyYWMuc3R5bGVzID0ge1xuICAgICAgICAnbWp4LWZyYWMnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICcwLjE3ZW0nLFxuICAgICAgICAgICAgcGFkZGluZzogJzAgLjIyZW0nXG4gICAgICAgIH0sXG4gICAgICAgICdtangtZnJhY1t0eXBlPVwiZFwiXSc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICcuMDRlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1mcmFjW2RlbGltc10nOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAnMCAuMWVtJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LWZyYWNbYXRvcF0nOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAnMCAuMTJlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1mcmFjW2F0b3BdW2RlbGltc10nOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAnMCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1kdGFibGUnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLXRhYmxlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1kdGFibGUgPiAqJzoge1xuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcyMDAwJSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1kYm94Jzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdmb250LXNpemUnOiAnNSUnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbnVtJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcidcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1kZW4nOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1mcmFjW2JldmVsbGVkXSA+IG1qeC1udW0nOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1mcmFjW2JldmVsbGVkXSA+IG1qeC1kZW4nOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LWRlblthbGlnbj1cInJpZ2h0XCJdLCBtangtbnVtW2FsaWduPVwicmlnaHRcIl0nOiB7XG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdyaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1kZW5bYWxpZ249XCJsZWZ0XCJdLCBtangtbnVtW2FsaWduPVwibGVmdFwiXSc6IHtcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2xlZnQnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbnN0cnV0Jzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICBoZWlnaHQ6ICcuMDU0ZW0nLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAnLS4wNTRlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1uc3RydXRbdHlwZT1cImRcIl0nOiB7XG4gICAgICAgICAgICBoZWlnaHQ6ICcuMjE3ZW0nLFxuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJy0uMjE3ZW0nLFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LWRzdHJ1dCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgaGVpZ2h0OiAnLjUwNWVtJyxcbiAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtZHN0cnV0W3R5cGU9XCJkXCJdJzoge1xuICAgICAgICAgICAgaGVpZ2h0OiAnLjcyNmVtJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1saW5lJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgJ21pbi1oZWlnaHQnOiAnMXB4JyxcbiAgICAgICAgICAgIGhlaWdodDogJy4wNmVtJyxcbiAgICAgICAgICAgICdib3JkZXItdG9wJzogJy4wNmVtIHNvbGlkJyxcbiAgICAgICAgICAgIG1hcmdpbjogJy4wNmVtIC0uMWVtJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LWxpbmVbdHlwZT1cImRcIl0nOiB7XG4gICAgICAgICAgICBtYXJnaW46ICcuMThlbSAtLjFlbSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENIVE1MbWZyYWM7XG59KCgwLCBtZnJhY19qc18xLkNvbW1vbk1mcmFjTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbWZyYWMgPSBDSFRNTG1mcmFjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWZyYWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1nbHlwaCA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtZ2x5cGhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbWdseXBoLmpzXCIpO1xudmFyIG1nbHlwaF9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tZ2x5cGguanNcIik7XG52YXIgQ0hUTUxtZ2x5cGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1nbHlwaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG1nbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1nbHlwaC5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5jaGFyV3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5jaGFyV3JhcHBlci50b0NIVE1MKGNodG1sKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXRMaXN0KCdzcmMnLCAnYWx0JyksIHNyYyA9IF9hLnNyYywgYWx0ID0gX2EuYWx0O1xuICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuZW0odGhpcy53aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZW0odGhpcy5oZWlnaHQpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnZhbGlnbikge1xuICAgICAgICAgICAgc3R5bGVzLnZlcnRpY2FsQWxpZ24gPSB0aGlzLmVtKHRoaXMudmFsaWduKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1nID0gdGhpcy5odG1sKCdpbWcnLCB7IHNyYzogc3JjLCBzdHlsZTogc3R5bGVzLCBhbHQ6IGFsdCwgdGl0bGU6IGFsdCB9KTtcbiAgICAgICAgdGhpcy5hZGFwdG9yLmFwcGVuZChjaHRtbCwgaW1nKTtcbiAgICB9O1xuICAgIENIVE1MbWdseXBoLmtpbmQgPSBtZ2x5cGhfanNfMi5NbWxNZ2x5cGgucHJvdG90eXBlLmtpbmQ7XG4gICAgQ0hUTUxtZ2x5cGguc3R5bGVzID0ge1xuICAgICAgICAnbWp4LW1nbHlwaCA+IGltZyc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxtZ2x5cGg7XG59KCgwLCBtZ2x5cGhfanNfMS5Db21tb25NZ2x5cGhNaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxtZ2x5cGggPSBDSFRNTG1nbHlwaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1nbHlwaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbWkgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgbWlfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbWkuanNcIik7XG52YXIgbWlfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbWkuanNcIik7XG52YXIgQ0hUTUxtaSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MbWksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtaSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1pLmtpbmQgPSBtaV9qc18yLk1tbE1pLnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTG1pO1xufSgoMCwgbWlfanNfMS5Db21tb25NaU1peGluKShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSkpO1xuZXhwb3J0cy5DSFRNTG1pID0gQ0hUTUxtaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hUTUxtbXVsdGlzY3JpcHRzID0gdm9pZCAwO1xudmFyIG1zdWJzdXBfanNfMSA9IHJlcXVpcmUoXCIuL21zdWJzdXAuanNcIik7XG52YXIgbW11bHRpc2NyaXB0c19qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tbXVsdGlzY3JpcHRzLmpzXCIpO1xudmFyIG1tdWx0aXNjcmlwdHNfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbW11bHRpc2NyaXB0cy5qc1wiKTtcbnZhciBzdHJpbmdfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL3N0cmluZy5qc1wiKTtcbnZhciBDSFRNTG1tdWx0aXNjcmlwdHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1tdWx0aXNjcmlwdHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtbXVsdGlzY3JpcHRzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbW11bHRpc2NyaXB0cy5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2NyaXB0RGF0YTtcbiAgICAgICAgdmFyIHNjcmlwdGFsaWduID0gdGhpcy5ub2RlLmdldFByb3BlcnR5KCdzY3JpcHRhbGlnbicpIHx8ICdyaWdodCBsZWZ0JztcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKCgwLCBzdHJpbmdfanNfMS5zcGxpdCkoc2NyaXB0YWxpZ24gKyAnICcgKyBzY3JpcHRhbGlnbiksIDIpLCBwcmVBbGlnbiA9IF9hWzBdLCBwb3N0QWxpZ24gPSBfYVsxXTtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMuY29tYmluZVByZVBvc3QoZGF0YS5zdWIsIGRhdGEucHN1Yik7XG4gICAgICAgIHZhciBzdXAgPSB0aGlzLmNvbWJpbmVQcmVQb3N0KGRhdGEuc3VwLCBkYXRhLnBzdXApO1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQodGhpcy5nZXRVVlEoc3ViLCBzdXApLCAyKSwgdSA9IF9iWzBdLCB2ID0gX2JbMV07XG4gICAgICAgIGlmIChkYXRhLm51bVByZXNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gdGhpcy5hZGRTY3JpcHRzKHUsIC12LCB0cnVlLCBkYXRhLnBzdWIsIGRhdGEucHN1cCwgdGhpcy5maXJzdFByZXNjcmlwdCwgZGF0YS5udW1QcmVzY3JpcHRzKTtcbiAgICAgICAgICAgIHByZUFsaWduICE9PSAncmlnaHQnICYmIHRoaXMuYWRhcHRvci5zZXRBdHRyaWJ1dGUoc2NyaXB0cywgJ3NjcmlwdC1hbGlnbicsIHByZUFsaWduKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0udG9DSFRNTChjaHRtbCk7XG4gICAgICAgIGlmIChkYXRhLm51bVNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gdGhpcy5hZGRTY3JpcHRzKHUsIC12LCBmYWxzZSwgZGF0YS5zdWIsIGRhdGEuc3VwLCAxLCBkYXRhLm51bVNjcmlwdHMpO1xuICAgICAgICAgICAgcG9zdEFsaWduICE9PSAnbGVmdCcgJiYgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZShzY3JpcHRzLCAnc2NyaXB0LWFsaWduJywgcG9zdEFsaWduKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtbXVsdGlzY3JpcHRzLnByb3RvdHlwZS5hZGRTY3JpcHRzID0gZnVuY3Rpb24gKHUsIHYsIGlzUHJlLCBzdWIsIHN1cCwgaSwgbikge1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgdmFyIHEgPSAodSAtIHN1cC5kKSArICh2IC0gc3ViLmgpO1xuICAgICAgICB2YXIgVSA9ICh1IDwgMCAmJiB2ID09PSAwID8gc3ViLmggKyB1IDogdSk7XG4gICAgICAgIHZhciByb3dkZWYgPSAocSA+IDAgPyB7IHN0eWxlOiB7IGhlaWdodDogdGhpcy5lbShxKSB9IH0gOiB7fSk7XG4gICAgICAgIHZhciB0YWJsZWRlZiA9IChVID8geyBzdHlsZTogeyAndmVydGljYWwtYWxpZ24nOiB0aGlzLmVtKFUpIH0gfSA6IHt9KTtcbiAgICAgICAgdmFyIHN1cFJvdyA9IHRoaXMuaHRtbCgnbWp4LXJvdycpO1xuICAgICAgICB2YXIgc2VwUm93ID0gdGhpcy5odG1sKCdtangtcm93Jywgcm93ZGVmKTtcbiAgICAgICAgdmFyIHN1YlJvdyA9IHRoaXMuaHRtbCgnbWp4LXJvdycpO1xuICAgICAgICB2YXIgbmFtZSA9ICdtangtJyArIChpc1ByZSA/ICdwcmUnIDogJycpICsgJ3NjcmlwdHMnO1xuICAgICAgICB2YXIgbSA9IGkgKyAyICogbjtcbiAgICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbaSsrXS50b0NIVE1MKGFkYXB0b3IuYXBwZW5kKHN1YlJvdywgdGhpcy5odG1sKCdtangtY2VsbCcpKSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbaSsrXS50b0NIVE1MKGFkYXB0b3IuYXBwZW5kKHN1cFJvdywgdGhpcy5odG1sKCdtangtY2VsbCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkYXB0b3IuYXBwZW5kKHRoaXMuY2h0bWwsIHRoaXMuaHRtbChuYW1lLCB0YWJsZWRlZiwgW3N1cFJvdywgc2VwUm93LCBzdWJSb3ddKSk7XG4gICAgfTtcbiAgICBDSFRNTG1tdWx0aXNjcmlwdHMua2luZCA9IG1tdWx0aXNjcmlwdHNfanNfMi5NbWxNbXVsdGlzY3JpcHRzLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbW11bHRpc2NyaXB0cy5zdHlsZXMgPSB7XG4gICAgICAgICdtangtcHJlc2NyaXB0cyc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtdGFibGUnLFxuICAgICAgICAgICAgJ3BhZGRpbmctbGVmdCc6ICcuMDVlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1zY3JpcHRzJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS10YWJsZScsXG4gICAgICAgICAgICAncGFkZGluZy1yaWdodCc6ICcuMDVlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1wcmVzY3JpcHRzID4gbWp4LXJvdyA+IG1qeC1jZWxsJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAncmlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgICdbc2NyaXB0LWFsaWduPVwibGVmdFwiXSA+IG1qeC1yb3cgPiBtangtY2VsbCc6IHtcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2xlZnQnXG4gICAgICAgIH0sXG4gICAgICAgICdbc2NyaXB0LWFsaWduPVwiY2VudGVyXCJdID4gbWp4LXJvdyA+IG1qeC1jZWxsJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJ1xuICAgICAgICB9LFxuICAgICAgICAnW3NjcmlwdC1hbGlnbj1cInJpZ2h0XCJdID4gbWp4LXJvdyA+IG1qeC1jZWxsJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDSFRNTG1tdWx0aXNjcmlwdHM7XG59KCgwLCBtbXVsdGlzY3JpcHRzX2pzXzEuQ29tbW9uTW11bHRpc2NyaXB0c01peGluKShtc3Vic3VwX2pzXzEuQ0hUTUxtc3Vic3VwKSkpO1xuZXhwb3J0cy5DSFRNTG1tdWx0aXNjcmlwdHMgPSBDSFRNTG1tdWx0aXNjcmlwdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tbXVsdGlzY3JpcHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hUTUxtbiA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtbl9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tbi5qc1wiKTtcbnZhciBtbl9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tbi5qc1wiKTtcbnZhciBDSFRNTG1uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG1uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbW4ua2luZCA9IG1uX2pzXzIuTW1sTW4ucHJvdG90eXBlLmtpbmQ7XG4gICAgcmV0dXJuIENIVE1MbW47XG59KCgwLCBtbl9qc18xLkNvbW1vbk1uTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbW4gPSBDSFRNTG1uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1vID0gdm9pZCAwO1xudmFyIFdyYXBwZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9XcmFwcGVyLmpzXCIpO1xudmFyIG1vX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21vLmpzXCIpO1xudmFyIG1vX2pzXzIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGVzL21vLmpzXCIpO1xudmFyIENIVE1MbW8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1vLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbW8oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtby5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzeW1tZXRyaWMgPSBhdHRyaWJ1dGVzLmdldCgnc3ltbWV0cmljJykgJiYgdGhpcy5zdHJldGNoLmRpciAhPT0gMjtcbiAgICAgICAgdmFyIHN0cmV0Y2h5ID0gdGhpcy5zdHJldGNoLmRpciAhPT0gMDtcbiAgICAgICAgaWYgKHN0cmV0Y2h5ICYmIHRoaXMuc2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHJldGNoZWRWYXJpYW50KFtdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2h0bWwgPSB0aGlzLnN0YW5kYXJkQ0hUTUxub2RlKHBhcmVudCk7XG4gICAgICAgIGlmIChzdHJldGNoeSAmJiB0aGlzLnNpemUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmV0Y2hIVE1MKGNodG1sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1tZXRyaWMgfHwgYXR0cmlidXRlcy5nZXQoJ2xhcmdlb3AnKSkge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gdGhpcy5lbSh0aGlzLmdldENlbnRlck9mZnNldCgpKTtcbiAgICAgICAgICAgICAgICBpZiAodSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShjaHRtbCwgJ3ZlcnRpY2FsQWxpZ24nLCB1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLmdldFByb3BlcnR5KCdtYXRoYWNjZW50JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2h0bWwsICd3aWR0aCcsICcwJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGNodG1sLCAnbWFyZ2luLWxlZnQnLCB0aGlzLmVtKHRoaXMuZ2V0QWNjZW50T2Zmc2V0KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50b0NIVE1MKGNodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbW8ucHJvdG90eXBlLnN0cmV0Y2hIVE1MID0gZnVuY3Rpb24gKGNodG1sKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5nZXRUZXh0KCkuY29kZVBvaW50QXQoMCk7XG4gICAgICAgIHRoaXMuZm9udC5kZWxpbVVzYWdlLmFkZChjKTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLm1hcmtVc2VkKCk7XG4gICAgICAgIHZhciBkZWxpbSA9IHRoaXMuc3RyZXRjaDtcbiAgICAgICAgdmFyIHN0cmV0Y2ggPSBkZWxpbS5zdHJldGNoO1xuICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICBpZiAoc3RyZXRjaFswXSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHRoaXMuaHRtbCgnbWp4LWJlZycsIHt9LCBbdGhpcy5odG1sKCdtangtYycpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQucHVzaCh0aGlzLmh0bWwoJ21qeC1leHQnLCB7fSwgW3RoaXMuaHRtbCgnbWp4LWMnKV0pKTtcbiAgICAgICAgaWYgKHN0cmV0Y2gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2godGhpcy5odG1sKCdtangtbWlkJywge30sIFt0aGlzLmh0bWwoJ21qeC1jJyldKSwgdGhpcy5odG1sKCdtangtZXh0Jywge30sIFt0aGlzLmh0bWwoJ21qeC1jJyldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmV0Y2hbMl0pIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh0aGlzLmh0bWwoJ21qeC1lbmQnLCB7fSwgW3RoaXMuaHRtbCgnbWp4LWMnKV0pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGVzID0ge307XG4gICAgICAgIHZhciBfYSA9IHRoaXMuYmJveCwgaCA9IF9hLmgsIGQgPSBfYS5kLCB3ID0gX2EudztcbiAgICAgICAgaWYgKGRlbGltLmRpciA9PT0gMSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHRoaXMuaHRtbCgnbWp4LW1hcmsnKSk7XG4gICAgICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gdGhpcy5lbShoICsgZCk7XG4gICAgICAgICAgICBzdHlsZXMudmVydGljYWxBbGlnbiA9IHRoaXMuZW0oLWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzLndpZHRoID0gdGhpcy5lbSh3KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0gbW9fanNfMS5EaXJlY3Rpb25WSFtkZWxpbS5kaXJdO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgY2xhc3M6IHRoaXMuY2hhcihkZWxpbS5jIHx8IGMpLCBzdHlsZTogc3R5bGVzIH07XG4gICAgICAgIHZhciBodG1sID0gdGhpcy5odG1sKCdtangtc3RyZXRjaHktJyArIGRpciwgcHJvcGVydGllcywgY29udGVudCk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5hcHBlbmQoY2h0bWwsIGh0bWwpO1xuICAgIH07XG4gICAgQ0hUTUxtby5raW5kID0gbW9fanNfMi5NbWxNby5wcm90b3R5cGUua2luZDtcbiAgICBDSFRNTG1vLnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1zdHJldGNoeS1oJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS10YWJsZScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktaCA+IConOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUtY2VsbCcsXG4gICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN0cmV0Y2h5LWggPiAqID4gbWp4LWMnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxleCgxLjAwMDAwMDEpJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN0cmV0Y2h5LWggPiAqID4gbWp4LWM6OmJlZm9yZSc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgd2lkdGg6ICdpbml0aWFsJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN0cmV0Y2h5LWggPiBtangtZXh0Jzoge1xuICAgICAgICAgICAgJy8qIElFICovIG92ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnLyogb3RoZXJzICovIG92ZXJmbG93JzogJ2NsaXAgdmlzaWJsZScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktaCA+IG1qeC1leHQgPiBtangtYzo6YmVmb3JlJzoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGV4KDUwMCknXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktaCA+IG1qeC1leHQgPiBtangtYyc6IHtcbiAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktaCA+IG1qeC1iZWcgPiBtangtYyc6IHtcbiAgICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiAnLS4xZW0nXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktaCA+IG1qeC1lbmQgPiBtangtYyc6IHtcbiAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6ICctLjFlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1zdHJldGNoeS12Jzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1zdHJldGNoeS12ID4gKic6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1zdHJldGNoeS12ID4gbWp4LWJlZyc6IHtcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN0cmV0Y2h5LXYgPiBtangtZW5kID4gbWp4LWMnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktdiA+ICogPiBtangtYyc6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxleSgxLjAwMDAwMDEpJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogJ2xlZnQgY2VudGVyJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN0cmV0Y2h5LXYgPiBtangtZXh0Jzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICBib3JkZXI6ICcwcHggc29saWQgdHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgJy8qIElFICovIG92ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnLyogb3RoZXJzICovIG92ZXJmbG93JzogJ3Zpc2libGUgY2xpcCcsXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktdiA+IG1qeC1leHQgPiBtangtYzo6YmVmb3JlJzoge1xuICAgICAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3RyZXRjaHktdiA+IG1qeC1leHQgPiBtangtYyc6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWSg1MDApIHRyYW5zbGF0ZVkoLjA3NWVtKScsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbWFyayc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMHB4J1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxtbztcbn0oKDAsIG1vX2pzXzEuQ29tbW9uTW9NaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxtbyA9IENIVE1MbW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbXBhZGRlZCA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtcGFkZGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21wYWRkZWQuanNcIik7XG52YXIgbXBhZGRlZF9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tcGFkZGVkLmpzXCIpO1xudmFyIENIVE1MbXBhZGRlZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MbXBhZGRlZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG1wYWRkZWQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtcGFkZGVkLnByb3RvdHlwZS50b0NIVE1MID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKHRoaXMuZ2V0RGltZW5zKCksIDkpLCBXID0gX2JbMl0sIGRoID0gX2JbM10sIGRkID0gX2JbNF0sIGR3ID0gX2JbNV0sIHggPSBfYls2XSwgeSA9IF9iWzddLCBkeCA9IF9iWzhdO1xuICAgICAgICBpZiAoZHcpIHtcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gdGhpcy5lbShXICsgZHcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaCB8fCBkZCkge1xuICAgICAgICAgICAgc3R5bGUubWFyZ2luID0gdGhpcy5lbShkaCkgKyAnIDAgJyArIHRoaXMuZW0oZGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ICsgZHggfHwgeSkge1xuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgdmFyIHJib3ggPSB0aGlzLmh0bWwoJ21qeC1yYm94Jywge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7IGxlZnQ6IHRoaXMuZW0oeCArIGR4KSwgdG9wOiB0aGlzLmVtKC15KSwgJ21heC13aWR0aCc6IHN0eWxlLndpZHRoIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHggKyBkeCAmJiB0aGlzLmNoaWxkTm9kZXNbMF0uZ2V0QkJveCgpLnB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRBdHRyaWJ1dGUocmJveCwgJ3dpZHRoJywgJ2Z1bGwnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUocmJveCwgJ2xlZnQnLCB0aGlzLmVtKHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChyYm94KTtcbiAgICAgICAgfVxuICAgICAgICBjaHRtbCA9IHRoaXMuYWRhcHRvci5hcHBlbmQoY2h0bWwsIHRoaXMuaHRtbCgnbWp4LWJsb2NrJywgeyBzdHlsZTogc3R5bGUgfSwgY29udGVudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgY2hpbGQudG9DSFRNTChjb250ZW50WzBdIHx8IGNodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG1wYWRkZWQua2luZCA9IG1wYWRkZWRfanNfMi5NbWxNcGFkZGVkLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbXBhZGRlZC5zdHlsZXMgPSB7XG4gICAgICAgICdtangtbXBhZGRlZCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgIH0sXG4gICAgICAgICdtangtcmJveCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENIVE1MbXBhZGRlZDtcbn0oKDAsIG1wYWRkZWRfanNfMS5Db21tb25NcGFkZGVkTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbXBhZGRlZCA9IENIVE1MbXBhZGRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1wYWRkZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1yb290ID0gdm9pZCAwO1xudmFyIG1zcXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9tc3FydC5qc1wiKTtcbnZhciBtcm9vdF9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tcm9vdC5qc1wiKTtcbnZhciBtcm9vdF9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tcm9vdC5qc1wiKTtcbnZhciBDSFRNTG1yb290ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtcm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG1yb290KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbXJvb3QucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoUk9PVCwgcm9vdCwgc2JveCwgSCkge1xuICAgICAgICByb290LnRvQ0hUTUwoUk9PVCk7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmdldFJvb3REaW1lbnMoc2JveCwgSCksIDMpLCB4ID0gX2FbMF0sIGggPSBfYVsxXSwgZHggPSBfYVsyXTtcbiAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKFJPT1QsICd2ZXJ0aWNhbEFsaWduJywgdGhpcy5lbShoKSk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShST09ULCAnd2lkdGgnLCB0aGlzLmVtKHgpKTtcbiAgICAgICAgaWYgKGR4KSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUodGhpcy5hZGFwdG9yLmZpcnN0Q2hpbGQoUk9PVCksICdwYWRkaW5nTGVmdCcsIHRoaXMuZW0oZHgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtcm9vdC5raW5kID0gbXJvb3RfanNfMi5NbWxNcm9vdC5wcm90b3R5cGUua2luZDtcbiAgICByZXR1cm4gQ0hUTUxtcm9vdDtcbn0oKDAsIG1yb290X2pzXzEuQ29tbW9uTXJvb3RNaXhpbikobXNxcnRfanNfMS5DSFRNTG1zcXJ0KSkpO1xuZXhwb3J0cy5DSFRNTG1yb290ID0gQ0hUTUxtcm9vdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1yb290LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hUTUxpbmZlcnJlZE1yb3cgPSBleHBvcnRzLkNIVE1MbXJvdyA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtcm93X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21yb3cuanNcIik7XG52YXIgbXJvd19qc18yID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tcm93LmpzXCIpO1xudmFyIG1yb3dfanNfMyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbXJvdy5qc1wiKTtcbnZhciBDSFRNTG1yb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1yb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtcm93KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbXJvdy5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBjaHRtbCA9ICh0aGlzLm5vZGUuaXNJbmZlcnJlZCA/ICh0aGlzLmNodG1sID0gcGFyZW50KSA6IHRoaXMuc3RhbmRhcmRDSFRNTG5vZGUocGFyZW50KSk7XG4gICAgICAgIHZhciBoYXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgY2hpbGQudG9DSFRNTChjaHRtbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmJib3gudyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmdldEJCb3goKS53O1xuICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2h0bWwsICd3aWR0aCcsIHRoaXMuZW0oTWF0aC5tYXgoMCwgdykpKTtcbiAgICAgICAgICAgICAgICBpZiAodyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGNodG1sLCAnbWFyZ2luUmlnaHQnLCB0aGlzLmVtKHcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXJvdy5raW5kID0gbXJvd19qc18zLk1tbE1yb3cucHJvdG90eXBlLmtpbmQ7XG4gICAgcmV0dXJuIENIVE1MbXJvdztcbn0oKDAsIG1yb3dfanNfMS5Db21tb25Ncm93TWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbXJvdyA9IENIVE1MbXJvdztcbnZhciBDSFRNTGluZmVycmVkTXJvdyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MaW5mZXJyZWRNcm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MaW5mZXJyZWRNcm93KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MaW5mZXJyZWRNcm93LmtpbmQgPSBtcm93X2pzXzMuTW1sSW5mZXJyZWRNcm93LnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTGluZmVycmVkTXJvdztcbn0oKDAsIG1yb3dfanNfMi5Db21tb25JbmZlcnJlZE1yb3dNaXhpbikoQ0hUTUxtcm93KSkpO1xuZXhwb3J0cy5DSFRNTGluZmVycmVkTXJvdyA9IENIVE1MaW5mZXJyZWRNcm93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXJvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbXMgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgbXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbXMuanNcIik7XG52YXIgbXNfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbXMuanNcIik7XG52YXIgQ0hUTUxtcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MbXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1zLmtpbmQgPSBtc19qc18yLk1tbE1zLnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTG1zO1xufSgoMCwgbXNfanNfMS5Db21tb25Nc01peGluKShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSkpO1xuZXhwb3J0cy5DSFRNTG1zID0gQ0hUTUxtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hUTUxtc3BhY2UgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgbXNwYWNlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21zcGFjZS5qc1wiKTtcbnZhciBtc3BhY2VfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbXNwYWNlLmpzXCIpO1xudmFyIENIVE1MbXNwYWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtc3BhY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtc3BhY2UucHJvdG90eXBlLnRvQ0hUTUwgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBjaHRtbCA9IHRoaXMuc3RhbmRhcmRDSFRNTG5vZGUocGFyZW50KTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRCQm94KCksIHcgPSBfYS53LCBoID0gX2EuaCwgZCA9IF9hLmQ7XG4gICAgICAgIGlmICh3IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGNodG1sLCAnbWFyZ2luUmlnaHQnLCB0aGlzLmVtKHcpKTtcbiAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2h0bWwsICd3aWR0aCcsIHRoaXMuZW0odykpO1xuICAgICAgICB9XG4gICAgICAgIGggPSBNYXRoLm1heCgwLCBoICsgZCk7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2h0bWwsICdoZWlnaHQnLCB0aGlzLmVtKE1hdGgubWF4KDAsIGgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShjaHRtbCwgJ3ZlcnRpY2FsQWxpZ24nLCB0aGlzLmVtKC1kKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXNwYWNlLmtpbmQgPSBtc3BhY2VfanNfMi5NbWxNc3BhY2UucHJvdG90eXBlLmtpbmQ7XG4gICAgcmV0dXJuIENIVE1MbXNwYWNlO1xufSgoMCwgbXNwYWNlX2pzXzEuQ29tbW9uTXNwYWNlTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbXNwYWNlID0gQ0hUTUxtc3BhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc3BhY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1zcXJ0ID0gdm9pZCAwO1xudmFyIFdyYXBwZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9XcmFwcGVyLmpzXCIpO1xudmFyIG1zcXJ0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21zcXJ0LmpzXCIpO1xudmFyIG1zcXJ0X2pzXzIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGVzL21zcXJ0LmpzXCIpO1xudmFyIENIVE1MbXNxcnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1zcXJ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbXNxcnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtc3FydC5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIHN1cmQgPSB0aGlzLmNoaWxkTm9kZXNbdGhpcy5zdXJkXTtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmNoaWxkTm9kZXNbdGhpcy5iYXNlXTtcbiAgICAgICAgdmFyIHNib3ggPSBzdXJkLmdldEJCb3goKTtcbiAgICAgICAgdmFyIGJib3ggPSBiYXNlLmdldE91dGVyQkJveCgpO1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5nZXRQUShzYm94KSwgMiksIHEgPSBfYVsxXTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmZvbnQucGFyYW1zLnJ1bGVfdGhpY2tuZXNzO1xuICAgICAgICB2YXIgSCA9IGJib3guaCArIHEgKyB0O1xuICAgICAgICB2YXIgQ0hUTUwgPSB0aGlzLnN0YW5kYXJkQ0hUTUxub2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBTVVJELCBCQVNFLCBST09ULCByb290O1xuICAgICAgICBpZiAodGhpcy5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIFJPT1QgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKENIVE1MLCB0aGlzLmh0bWwoJ21qeC1yb290JykpO1xuICAgICAgICAgICAgcm9vdCA9IHRoaXMuY2hpbGROb2Rlc1t0aGlzLnJvb3RdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBTUVJUID0gdGhpcy5hZGFwdG9yLmFwcGVuZChDSFRNTCwgdGhpcy5odG1sKCdtangtc3FydCcsIHt9LCBbXG4gICAgICAgICAgICBTVVJEID0gdGhpcy5odG1sKCdtangtc3VyZCcpLFxuICAgICAgICAgICAgQkFTRSA9IHRoaXMuaHRtbCgnbWp4LWJveCcsIHsgc3R5bGU6IHsgcGFkZGluZ1RvcDogdGhpcy5lbShxKSB9IH0pXG4gICAgICAgIF0pKTtcbiAgICAgICAgdGhpcy5hZGRSb290KFJPT1QsIHJvb3QsIHNib3gsIEgpO1xuICAgICAgICBzdXJkLnRvQ0hUTUwoU1VSRCk7XG4gICAgICAgIGJhc2UudG9DSFRNTChCQVNFKTtcbiAgICAgICAgaWYgKHN1cmQuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5hZGRDbGFzcyhTUVJULCAnbWp4LXRhbGwnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtc3FydC5wcm90b3R5cGUuYWRkUm9vdCA9IGZ1bmN0aW9uIChfUk9PVCwgX3Jvb3QsIF9zYm94LCBfSCkge1xuICAgIH07XG4gICAgQ0hUTUxtc3FydC5raW5kID0gbXNxcnRfanNfMi5NbWxNc3FydC5wcm90b3R5cGUua2luZDtcbiAgICBDSFRNTG1zcXJ0LnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1yb290Jzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAnd2hpdGUtc3BhY2UnOiAnbm93cmFwJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXN1cmQnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3FydCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgJ3BhZGRpbmctdG9wJzogJy4wN2VtJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXNxcnQgPiBtangtYm94Jzoge1xuICAgICAgICAgICAgJ2JvcmRlci10b3AnOiAnLjA3ZW0gc29saWQnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtc3FydC5tangtdGFsbCA+IG1qeC1ib3gnOiB7XG4gICAgICAgICAgICAncGFkZGluZy1sZWZ0JzogJy4zZW0nLFxuICAgICAgICAgICAgJ21hcmdpbi1sZWZ0JzogJy0uM2VtJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxtc3FydDtcbn0oKDAsIG1zcXJ0X2pzXzEuQ29tbW9uTXNxcnRNaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxtc3FydCA9IENIVE1MbXNxcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc3FydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbXN1YnN1cCA9IGV4cG9ydHMuQ0hUTUxtc3VwID0gZXhwb3J0cy5DSFRNTG1zdWIgPSB2b2lkIDA7XG52YXIgc2NyaXB0YmFzZV9qc18xID0gcmVxdWlyZShcIi4vc2NyaXB0YmFzZS5qc1wiKTtcbnZhciBtc3Vic3VwX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL21zdWJzdXAuanNcIik7XG52YXIgbXN1YnN1cF9qc18yID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tc3Vic3VwLmpzXCIpO1xudmFyIG1zdWJzdXBfanNfMyA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbXN1YnN1cC5qc1wiKTtcbnZhciBtc3Vic3VwX2pzXzQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGVzL21zdWJzdXAuanNcIik7XG52YXIgQ0hUTUxtc3ViID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtc3ViLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbXN1YigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1zdWIua2luZCA9IG1zdWJzdXBfanNfNC5NbWxNc3ViLnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTG1zdWI7XG59KCgwLCBtc3Vic3VwX2pzXzEuQ29tbW9uTXN1Yk1peGluKShzY3JpcHRiYXNlX2pzXzEuQ0hUTUxzY3JpcHRiYXNlKSkpO1xuZXhwb3J0cy5DSFRNTG1zdWIgPSBDSFRNTG1zdWI7XG52YXIgQ0hUTUxtc3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtc3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbXN1cCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1zdXAua2luZCA9IG1zdWJzdXBfanNfNC5NbWxNc3VwLnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTG1zdXA7XG59KCgwLCBtc3Vic3VwX2pzXzIuQ29tbW9uTXN1cE1peGluKShzY3JpcHRiYXNlX2pzXzEuQ0hUTUxzY3JpcHRiYXNlKSkpO1xuZXhwb3J0cy5DSFRNTG1zdXAgPSBDSFRNTG1zdXA7XG52YXIgQ0hUTUxtc3Vic3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtc3Vic3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MbXN1YnN1cCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1zdWJzdXAucHJvdG90eXBlLnRvQ0hUTUwgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgY2h0bWwgPSB0aGlzLnN0YW5kYXJkQ0hUTUxub2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChbdGhpcy5iYXNlQ2hpbGQsIHRoaXMuc3VwQ2hpbGQsIHRoaXMuc3ViQ2hpbGRdLCAzKSwgYmFzZSA9IF9hWzBdLCBzdXAgPSBfYVsxXSwgc3ViID0gX2FbMl07XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZCh0aGlzLmdldFVWUSgpLCAzKSwgdiA9IF9iWzFdLCBxID0gX2JbMl07XG4gICAgICAgIHZhciBzdHlsZSA9IHsgJ3ZlcnRpY2FsLWFsaWduJzogdGhpcy5lbSh2KSB9O1xuICAgICAgICBiYXNlLnRvQ0hUTUwoY2h0bWwpO1xuICAgICAgICB2YXIgc3RhY2sgPSBhZGFwdG9yLmFwcGVuZChjaHRtbCwgdGhpcy5odG1sKCdtangtc2NyaXB0JywgeyBzdHlsZTogc3R5bGUgfSkpO1xuICAgICAgICBzdXAudG9DSFRNTChzdGFjayk7XG4gICAgICAgIGFkYXB0b3IuYXBwZW5kKHN0YWNrLCB0aGlzLmh0bWwoJ21qeC1zcGFjZXInLCB7IHN0eWxlOiB7ICdtYXJnaW4tdG9wJzogdGhpcy5lbShxKSB9IH0pKTtcbiAgICAgICAgc3ViLnRvQ0hUTUwoc3RhY2spO1xuICAgICAgICB2YXIgaWMgPSB0aGlzLmdldEFkanVzdGVkSWMoKTtcbiAgICAgICAgaWYgKGljKSB7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHN1cC5jaHRtbCwgJ21hcmdpbkxlZnQnLCB0aGlzLmVtKGljIC8gc3VwLmJib3gucnNjYWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFzZVJlbW92ZUljKSB7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHN0YWNrLCAnbWFyZ2luTGVmdCcsIHRoaXMuZW0oLXRoaXMuYmFzZUljKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXN1YnN1cC5raW5kID0gbXN1YnN1cF9qc180Lk1tbE1zdWJzdXAucHJvdG90eXBlLmtpbmQ7XG4gICAgQ0hUTUxtc3Vic3VwLnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1zY3JpcHQnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogJy4wNWVtJyxcbiAgICAgICAgICAgICdwYWRkaW5nLWxlZnQnOiAnLjAzM2VtJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LXNjcmlwdCA+IG1qeC1zcGFjZXInOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDSFRNTG1zdWJzdXA7XG59KCgwLCBtc3Vic3VwX2pzXzMuQ29tbW9uTXN1YnN1cE1peGluKShzY3JpcHRiYXNlX2pzXzEuQ0hUTUxzY3JpcHRiYXNlKSkpO1xuZXhwb3J0cy5DSFRNTG1zdWJzdXAgPSBDSFRNTG1zdWJzdXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc3Vic3VwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hUTUxtdGFibGUgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgbXRhYmxlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL210YWJsZS5qc1wiKTtcbnZhciBtdGFibGVfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbXRhYmxlLmpzXCIpO1xudmFyIHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvc3RyaW5nLmpzXCIpO1xudmFyIENIVE1MbXRhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtdGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtdGFibGUoZmFjdG9yeSwgbm9kZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUsIHBhcmVudCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXRhYmxlID0gX3RoaXMuaHRtbCgnbWp4LWl0YWJsZScpO1xuICAgICAgICBfdGhpcy5sYWJlbHMgPSBfdGhpcy5odG1sKCdtangtaXRhYmxlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtdGFibGUucHJvdG90eXBlLmdldEFsaWduU2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBbGlnblNoaWZ0LmNhbGwodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1RvcCkge1xuICAgICAgICAgICAgZGF0YVsxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBjaHRtbCA9IHRoaXMuc3RhbmRhcmRDSFRNTG5vZGUocGFyZW50KTtcbiAgICAgICAgdGhpcy5hZGFwdG9yLmFwcGVuZChjaHRtbCwgdGhpcy5odG1sKCdtangtdGFibGUnLCB7fSwgW3RoaXMuaXRhYmxlXSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgY2hpbGQudG9DSFRNTCh0aGlzLml0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZFJvd3MoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2x1bW5TcGFjaW5nKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29sdW1uTGluZXMoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2x1bW5XaWR0aHMoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3dTcGFjaW5nKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUm93TGluZXMoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3dIZWlnaHRzKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRnJhbWUoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVXaWR0aCgpO1xuICAgICAgICB0aGlzLmhhbmRsZUxhYmVscygpO1xuICAgICAgICB0aGlzLmhhbmRsZUFsaWduKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlSnVzdGlmeSgpO1xuICAgICAgICB0aGlzLnNoaWZ0Q29sb3IoKTtcbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS5zaGlmdENvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgdmFyIGNvbG9yID0gYWRhcHRvci5nZXRTdHlsZSh0aGlzLmNodG1sLCAnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAnYmFja2dyb3VuZENvbG9yJywgJycpO1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLml0YWJsZSwgJ2JhY2tncm91bmRDb2xvcicsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtdGFibGUucHJvdG90eXBlLnBhZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoYWRhcHRvci5jaGlsZE5vZGVzKHRoaXMuaXRhYmxlKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGFkYXB0b3IuY2hpbGROb2Rlcyhyb3cpLmxlbmd0aCA8IHRoaXMubnVtQ29scykge1xuICAgICAgICAgICAgICAgICAgICBhZGFwdG9yLmFwcGVuZChyb3csIHRoaXMuaHRtbCgnbWp4LW10ZCcsIHsgJ2V4dHJhJzogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS5oYW5kbGVDb2x1bW5TcGFjaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8zLCBfYSwgZV80LCBfYjtcbiAgICAgICAgdmFyIHNjYWxlID0gKHRoaXMuY2hpbGROb2Rlc1swXSA/IDEgLyB0aGlzLmNoaWxkTm9kZXNbMF0uZ2V0QkJveCgpLnJzY2FsZSA6IDEpO1xuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuZ2V0RW1IYWxmU3BhY2luZyh0aGlzLmZTcGFjZVswXSwgdGhpcy5jU3BhY2UsIHNjYWxlKTtcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy50YWJsZVJvd3MpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzQgPSB2b2lkIDAsIF9fdmFsdWVzKHJvdy50YWJsZUNlbGxzKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbHNwYWNlID0gc3BhY2luZ1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJzcGFjZSA9IHNwYWNpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVOb2RlID0gKGNlbGwgPyBjZWxsLmNodG1sIDogdGhpcy5hZGFwdG9yLmNoaWxkTm9kZXMocm93LmNodG1sKVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkgPiAxICYmIGxzcGFjZSAhPT0gJzAuNGVtJykgfHwgKGZyYW1lICYmIGkgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKHN0eWxlTm9kZSwgJ3BhZGRpbmdMZWZ0JywgbHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaSA8IHRoaXMubnVtQ29scyAmJiByc3BhY2UgIT09ICcwLjRlbScpIHx8IChmcmFtZSAmJiBpID09PSB0aGlzLm51bUNvbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKHN0eWxlTm9kZSwgJ3BhZGRpbmdSaWdodCcsIHJzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS5oYW5kbGVDb2x1bW5MaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfNSwgX2EsIGVfNiwgX2I7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2NvbHVtbmxpbmVzJykgPT09ICdub25lJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5nZXRDb2x1bW5BdHRyaWJ1dGVzKCdjb2x1bW5saW5lcycpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzYgPSB2b2lkIDAsIF9fdmFsdWVzKHRoaXMuYWRhcHRvci5jaGlsZE5vZGVzKHJvdy5jaHRtbCkuc2xpY2UoMSkpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSAnbm9uZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2VsbCwgJ2JvcmRlckxlZnQnLCAnLjA3ZW0gJyArIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuaGFuZGxlQ29sdW1uV2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV83LCBfYSwgZV84LCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5jaGlsZE5vZGVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAoZV84ID0gdm9pZCAwLCBfX3ZhbHVlcyh0aGlzLmFkYXB0b3IuY2hpbGROb2Rlcyhyb3cuY2h0bWwpKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHRoaXMuY1dpZHRoc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSAodHlwZW9mIHcgPT09ICdudW1iZXInID8gdGhpcy5lbSh3KSA6IHcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShjZWxsLCAnd2lkdGgnLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGNlbGwsICdtYXhXaWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2VsbCwgJ21pbldpZHRoJywgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzhfMSkgeyBlXzggPSB7IGVycm9yOiBlXzhfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV83XzEpIHsgZV83ID0geyBlcnJvcjogZV83XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuaGFuZGxlUm93U3BhY2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfOSwgX2EsIGVfMTAsIF9iO1xuICAgICAgICB2YXIgc2NhbGUgPSAodGhpcy5jaGlsZE5vZGVzWzBdID8gMSAvIHRoaXMuY2hpbGROb2Rlc1swXS5nZXRCQm94KCkucnNjYWxlIDogMSk7XG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5nZXRFbUhhbGZTcGFjaW5nKHRoaXMuZlNwYWNlWzFdLCB0aGlzLnJTcGFjZSwgc2NhbGUpO1xuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMuY2hpbGROb2RlcyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHRzcGFjZSA9IHNwYWNpbmdbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgYnNwYWNlID0gc3BhY2luZ1tpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzEwID0gdm9pZCAwLCBfX3ZhbHVlcyhyb3cuY2hpbGROb2RlcykpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpID4gMSAmJiB0c3BhY2UgIT09ICcwLjIxNWVtJykgfHwgKGZyYW1lICYmIGkgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGNlbGwuY2h0bWwsICdwYWRkaW5nVG9wJywgdHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaSA8IHRoaXMubnVtUm93cyAmJiBic3BhY2UgIT09ICcwLjIxNWVtJykgfHwgKGZyYW1lICYmIGkgPT09IHRoaXMubnVtUm93cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoY2VsbC5jaHRtbCwgJ3BhZGRpbmdCb3R0b20nLCBic3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzEwXzEpIHsgZV8xMCA9IHsgZXJyb3I6IGVfMTBfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEwKSB0aHJvdyBlXzEwLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzlfMSkgeyBlXzkgPSB7IGVycm9yOiBlXzlfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOSkgdGhyb3cgZV85LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS5oYW5kbGVSb3dMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMTEsIF9hLCBlXzEyLCBfYjtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgncm93bGluZXMnKSA9PT0gJ25vbmUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmdldFJvd0F0dHJpYnV0ZXMoJ3Jvd2xpbmVzJyk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5jaGlsZE5vZGVzLnNsaWNlKDEpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgPT09ICdub25lJylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAoZV8xMiA9IHZvaWQgMCwgX192YWx1ZXModGhpcy5hZGFwdG9yLmNoaWxkTm9kZXMocm93LmNodG1sKSkpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKGNlbGwsICdib3JkZXJUb3AnLCAnLjA3ZW0gJyArIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzEyXzEpIHsgZV8xMiA9IHsgZXJyb3I6IGVfMTJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzExXzEpIHsgZV8xMSA9IHsgZXJyb3I6IGVfMTFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtdGFibGUucHJvdG90eXBlLmhhbmRsZVJvd0hlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2VxdWFscm93cycpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVxdWFsUm93cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuaGFuZGxlRXF1YWxSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3BhY2UgPSB0aGlzLmdldFJvd0hhbGZTcGFjaW5nKCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0VGFibGVEYXRhKCksIEggPSBfYS5ILCBEID0gX2EuRCwgTkggPSBfYS5OSCwgTkQgPSBfYS5ORDtcbiAgICAgICAgdmFyIEhEID0gdGhpcy5nZXRFcXVhbFJvd0hlaWdodCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtUm93czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5zZXRSb3dIZWlnaHQocm93LCBIRCArIHNwYWNlW2ldICsgc3BhY2VbaSArIDFdICsgdGhpcy5yTGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKEhEICE9PSBOSFtpXSArIE5EW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb3dCYXNlbGluZShyb3csIEhELCAoSEQgLSBIW2ldICsgRFtpXSkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtdGFibGUucHJvdG90eXBlLnNldFJvd0hlaWdodCA9IGZ1bmN0aW9uIChyb3csIEhEKSB7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShyb3cuY2h0bWwsICdoZWlnaHQnLCB0aGlzLmVtKEhEKSk7XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuc2V0Um93QmFzZWxpbmUgPSBmdW5jdGlvbiAocm93LCBIRCwgRCkge1xuICAgICAgICB2YXIgZV8xMywgX2E7XG4gICAgICAgIHZhciByYWxpZ24gPSByb3cubm9kZS5hdHRyaWJ1dGVzLmdldCgncm93YWxpZ24nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMocm93LmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXRDZWxsQmFzZWxpbmUoY2VsbCwgcmFsaWduLCBIRCwgRCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzEzXzEpIHsgZV8xMyA9IHsgZXJyb3I6IGVfMTNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTMpIHRocm93IGVfMTMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtdGFibGUucHJvdG90eXBlLnNldENlbGxCYXNlbGluZSA9IGZ1bmN0aW9uIChjZWxsLCByYWxpZ24sIEhELCBEKSB7XG4gICAgICAgIHZhciBjYWxpZ24gPSBjZWxsLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3Jvd2FsaWduJyk7XG4gICAgICAgIGlmIChjYWxpZ24gPT09ICdiYXNlbGluZScgfHwgY2FsaWduID09PSAnYXhpcycpIHtcbiAgICAgICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gYWRhcHRvci5sYXN0Q2hpbGQoY2VsbC5jaHRtbCk7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKGNoaWxkLCAnaGVpZ2h0JywgdGhpcy5lbShIRCkpO1xuICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShjaGlsZCwgJ3ZlcnRpY2FsQWxpZ24nLCB0aGlzLmVtKC1EKSk7XG4gICAgICAgICAgICB2YXIgcm93ID0gY2VsbC5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoKCFyb3cubm9kZS5pc0tpbmQoJ21sYWJlbGVkdHInKSB8fCBjZWxsICE9PSByb3cuY2hpbGROb2Rlc1swXSkgJiZcbiAgICAgICAgICAgICAgICAocmFsaWduID09PSAnYmFzZWxpbmUnIHx8IHJhbGlnbiA9PT0gJ2F4aXMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS5oYW5kbGVGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWUgJiYgdGhpcy5mTGluZSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKHRoaXMuaXRhYmxlLCAnYm9yZGVyJywgJy4wN2VtICcgKyB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2ZyYW1lJykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuaGFuZGxlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldEJCb3goKSwgdyA9IF9hLncsIEwgPSBfYS5MLCBSID0gX2EuUjtcbiAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAnbWluV2lkdGgnLCB0aGlzLmVtKEwgKyB3ICsgUikpO1xuICAgICAgICB2YXIgVyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnd2lkdGgnKTtcbiAgICAgICAgaWYgKCgwLCBzdHJpbmdfanNfMS5pc1BlcmNlbnQpKFcpKSB7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHRoaXMuY2h0bWwsICd3aWR0aCcsICcnKTtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICd3aWR0aCcsICdmdWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTGFiZWxzKSB7XG4gICAgICAgICAgICBpZiAoVyA9PT0gJ2F1dG8nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFcgPSB0aGlzLmVtKHRoaXMubGVuZ3RoMmVtKFcpICsgMiAqIHRoaXMuZkxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWJsZSA9IGFkYXB0b3IuZmlyc3RDaGlsZCh0aGlzLmNodG1sKTtcbiAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0YWJsZSwgJ3dpZHRoJywgVyk7XG4gICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUodGFibGUsICdtaW5XaWR0aCcsIHRoaXMuZW0odykpO1xuICAgICAgICBpZiAoTCB8fCBSKSB7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHRoaXMuY2h0bWwsICdtYXJnaW4nLCAnJyk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSAodGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdkYXRhLXdpZHRoLWluY2x1ZGVzLWxhYmVsJykgPyAncGFkZGluZycgOiAnbWFyZ2luJyk7XG4gICAgICAgICAgICBpZiAoTCA9PT0gUikge1xuICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUodGFibGUsIHN0eWxlLCAnMCAnICsgdGhpcy5lbShSKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHRhYmxlLCBzdHlsZSwgJzAgJyArIHRoaXMuZW0oUikgKyAnIDAgJyArIHRoaXMuZW0oTCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuaXRhYmxlLCAnd2lkdGgnLCAnZnVsbCcpO1xuICAgIH07XG4gICAgQ0hUTUxtdGFibGUucHJvdG90eXBlLmhhbmRsZUFsaWduID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5nZXRBbGlnbm1lbnRSb3coKSwgMiksIGFsaWduID0gX2FbMF0sIHJvdyA9IF9hWzFdO1xuICAgICAgICBpZiAocm93ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYWxpZ24gIT09ICdheGlzJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRBdHRyaWJ1dGUodGhpcy5jaHRtbCwgJ2FsaWduJywgYWxpZ24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmdldFZlcnRpY2FsUG9zaXRpb24ocm93LCBhbGlnbik7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICdhbGlnbicsICd0b3AnKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZSh0aGlzLmNodG1sLCAndmVydGljYWxBbGlnbicsIHRoaXMuZW0oeSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuaGFuZGxlSnVzdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsaWduID0gdGhpcy5nZXRBbGlnblNoaWZ0KClbMF07XG4gICAgICAgIGlmIChhbGlnbiAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRBdHRyaWJ1dGUodGhpcy5jaHRtbCwgJ2p1c3RpZnknLCBhbGlnbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS5oYW5kbGVMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNMYWJlbHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLm5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIHZhciBzaWRlID0gYXR0cmlidXRlcy5nZXQoJ3NpZGUnKTtcbiAgICAgICAgYWRhcHRvci5zZXRBdHRyaWJ1dGUodGhpcy5jaHRtbCwgJ3NpZGUnLCBzaWRlKTtcbiAgICAgICAgYWRhcHRvci5zZXRBdHRyaWJ1dGUobGFiZWxzLCAnYWxpZ24nLCBzaWRlKTtcbiAgICAgICAgYWRhcHRvci5zZXRTdHlsZShsYWJlbHMsIHNpZGUsICcwJyk7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmFkZExhYmVsUGFkZGluZyhzaWRlKSwgMiksIGFsaWduID0gX2FbMF0sIHNoaWZ0ID0gX2FbMV07XG4gICAgICAgIGlmIChzaGlmdCkge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gYWRhcHRvci5maXJzdENoaWxkKHRoaXMuY2h0bWwpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbmRlbnQodGFibGUsIGFsaWduLCBzaGlmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVSb3dIZWlnaHRzKCk7XG4gICAgICAgIHRoaXMuYWRkTGFiZWxTcGFjaW5nKCk7XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuYWRkTGFiZWxQYWRkaW5nID0gZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHRoaXMuZ2V0UGFkQWxpZ25TaGlmdChzaWRlKSwgMyksIGFsaWduID0gX2FbMV0sIHNoaWZ0ID0gX2FbMl07XG4gICAgICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcgJiYgIXRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnZGF0YS13aWR0aC1pbmNsdWRlcy1sYWJlbCcpKSB7XG4gICAgICAgICAgICB2YXIgVyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnd2lkdGgnKTtcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMuZ2V0QkJveCgpLCB3ID0gX2IudywgTCA9IF9iLkwsIFIgPSBfYi5SO1xuICAgICAgICAgICAgc3R5bGVzLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAoKDAsIHN0cmluZ19qc18xLmlzUGVyY2VudCkoVykgPyAnY2FsYygnICsgVyArICcgKyAnICsgdGhpcy5lbShMICsgUikgKyAnKScgOiB0aGlzLmVtKEwgKyB3ICsgUikpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5jaHRtbCwgdGhpcy5odG1sKCdtangtbGFiZWxzJywgc3R5bGVzLCBbdGhpcy5sYWJlbHNdKSk7XG4gICAgICAgIHJldHVybiBbYWxpZ24sIHNoaWZ0XTtcbiAgICB9O1xuICAgIENIVE1MbXRhYmxlLnByb3RvdHlwZS51cGRhdGVSb3dIZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFRhYmxlRGF0YSgpLCBIID0gX2EuSCwgRCA9IF9hLkQsIE5IID0gX2EuTkgsIE5EID0gX2EuTkQ7XG4gICAgICAgIHZhciBzcGFjZSA9IHRoaXMuZ2V0Um93SGFsZlNwYWNpbmcoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuc2V0Um93SGVpZ2h0KHJvdywgSFtpXSArIERbaV0gKyBzcGFjZVtpXSArIHNwYWNlW2kgKyAxXSArIHRoaXMuckxpbmVzW2ldKTtcbiAgICAgICAgICAgIGlmIChIW2ldICE9PSBOSFtpXSB8fCBEW2ldICE9PSBORFtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um93QmFzZWxpbmUocm93LCBIW2ldICsgRFtpXSwgRFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb3cubm9kZS5pc0tpbmQoJ21sYWJlbGVkdHInKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2VsbEJhc2VsaW5lKHJvdy5jaGlsZE5vZGVzWzBdLCAnJywgSFtpXSArIERbaV0sIERbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG10YWJsZS5wcm90b3R5cGUuYWRkTGFiZWxTcGFjaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgdmFyIGVxdWFsID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdlcXVhbHJvd3MnKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUYWJsZURhdGEoKSwgSCA9IF9hLkgsIEQgPSBfYS5EO1xuICAgICAgICB2YXIgSEQgPSAoZXF1YWwgPyB0aGlzLmdldEVxdWFsUm93SGVpZ2h0KCkgOiAwKTtcbiAgICAgICAgdmFyIHNwYWNlID0gdGhpcy5nZXRSb3dIYWxmU3BhY2luZygpO1xuICAgICAgICB2YXIgaCA9IHRoaXMuZkxpbmU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gYWRhcHRvci5maXJzdENoaWxkKHRoaXMubGFiZWxzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChyb3cubm9kZS5pc0tpbmQoJ21sYWJlbGVkdHInKSkge1xuICAgICAgICAgICAgICAgIGggJiYgYWRhcHRvci5pbnNlcnQodGhpcy5odG1sKCdtangtbXRyJywgeyBzdHlsZTogeyBoZWlnaHQ6IHRoaXMuZW0oaCkgfSB9KSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShjdXJyZW50LCAnaGVpZ2h0JywgdGhpcy5lbSgoZXF1YWwgPyBIRCA6IEhbaV0gKyBEW2ldKSArIHNwYWNlW2ldICsgc3BhY2VbaSArIDFdKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGFkYXB0b3IubmV4dChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBoID0gdGhpcy5yTGluZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoICs9IHNwYWNlW2ldICsgKGVxdWFsID8gSEQgOiBIW2ldICsgRFtpXSkgKyBzcGFjZVtpICsgMV0gKyB0aGlzLnJMaW5lc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtdGFibGUua2luZCA9IG10YWJsZV9qc18yLk1tbE10YWJsZS5wcm90b3R5cGUua2luZDtcbiAgICBDSFRNTG10YWJsZS5zdHlsZXMgPSB7XG4gICAgICAgICdtangtbXRhYmxlJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJy4yNWVtJyxcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAncG9zaXRpb24nOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICAnYm9yZGVyLXNwYWNpbmcnOiAwLFxuICAgICAgICAgICAgJ2JvcmRlci1jb2xsYXBzZSc6ICdjb2xsYXBzZSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tc3R5bGVbc2l6ZT1cInNcIl0gbWp4LW10YWJsZSc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICcuMzU0ZW0nXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbGFiZWxzJzoge1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtdGFibGUnOiB7XG4gICAgICAgICAgICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJy0uNWV4JyxcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtdGFibGUgPiBtangtaXRhYmxlJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ21pZGRsZScsXG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdsZWZ0JyxcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbGFiZWxzID4gbWp4LWl0YWJsZSc6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRhYmxlW2p1c3RpZnk9XCJsZWZ0XCJdJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGFibGVbanVzdGlmeT1cInJpZ2h0XCJdJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAncmlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRhYmxlW2p1c3RpZnk9XCJsZWZ0XCJdW3NpZGU9XCJsZWZ0XCJdJzoge1xuICAgICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAnMCAhIGltcG9ydGFudCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGFibGVbanVzdGlmeT1cImxlZnRcIl1bc2lkZT1cInJpZ2h0XCJdJzoge1xuICAgICAgICAgICAgJ3BhZGRpbmctbGVmdCc6ICcwICEgaW1wb3J0YW50J1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10YWJsZVtqdXN0aWZ5PVwicmlnaHRcIl1bc2lkZT1cImxlZnRcIl0nOiB7XG4gICAgICAgICAgICAncGFkZGluZy1yaWdodCc6ICcwICEgaW1wb3J0YW50J1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10YWJsZVtqdXN0aWZ5PVwicmlnaHRcIl1bc2lkZT1cInJpZ2h0XCJdJzoge1xuICAgICAgICAgICAgJ3BhZGRpbmctbGVmdCc6ICcwICEgaW1wb3J0YW50J1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10YWJsZVthbGlnbl0nOiB7XG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAnYmFzZWxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRhYmxlW2FsaWduPVwidG9wXCJdID4gbWp4LXRhYmxlJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ3RvcCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGFibGVbYWxpZ249XCJib3R0b21cIl0gPiBtangtdGFibGUnOiB7XG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAnYm90dG9tJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10YWJsZVtzaWRlPVwicmlnaHRcIl0gbWp4LWxhYmVscyc6IHtcbiAgICAgICAgICAgICdtaW4td2lkdGgnOiAnMTAwJSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENIVE1MbXRhYmxlO1xufSgoMCwgbXRhYmxlX2pzXzEuQ29tbW9uTXRhYmxlTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbXRhYmxlID0gQ0hUTUxtdGFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG10ZCA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtdGRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbXRkLmpzXCIpO1xudmFyIG10ZF9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tdGQuanNcIik7XG52YXIgQ0hUTUxtdGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG10ZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG10ZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG10ZC5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS50b0NIVE1MLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgICAgdmFyIHJhbGlnbiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgncm93YWxpZ24nKTtcbiAgICAgICAgdmFyIGNhbGlnbiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnY29sdW1uYWxpZ24nKTtcbiAgICAgICAgdmFyIHBhbGlnbiA9IHRoaXMucGFyZW50Lm5vZGUuYXR0cmlidXRlcy5nZXQoJ3Jvd2FsaWduJyk7XG4gICAgICAgIGlmIChyYWxpZ24gIT09IHBhbGlnbikge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZSh0aGlzLmNodG1sLCAncm93YWxpZ24nLCByYWxpZ24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxpZ24gIT09ICdjZW50ZXInICYmXG4gICAgICAgICAgICAodGhpcy5wYXJlbnQua2luZCAhPT0gJ21sYWJlbGVkdHInIHx8IHRoaXMgIT09IHRoaXMucGFyZW50LmNoaWxkTm9kZXNbMF0gfHxcbiAgICAgICAgICAgICAgICBjYWxpZ24gIT09IHRoaXMucGFyZW50LnBhcmVudC5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdzaWRlJykpKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUodGhpcy5jaHRtbCwgJ3RleHRBbGlnbicsIGNhbGlnbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnBhcmVudC5ub2RlLmdldFByb3BlcnR5KCd1c2VIZWlnaHQnKSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLmFwcGVuZCh0aGlzLmNodG1sLCB0aGlzLmh0bWwoJ21qeC10c3RydXQnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1MbXRkLmtpbmQgPSBtdGRfanNfMi5NbWxNdGQucHJvdG90eXBlLmtpbmQ7XG4gICAgQ0hUTUxtdGQuc3R5bGVzID0ge1xuICAgICAgICAnbWp4LW10ZCc6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAncGFkZGluZyc6ICcuMjE1ZW0gLjRlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGQ6Zmlyc3QtY2hpbGQnOiB7XG4gICAgICAgICAgICAncGFkZGluZy1sZWZ0JzogMFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10ZDpsYXN0LWNoaWxkJzoge1xuICAgICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRhYmxlID4gKiA+IG1qeC1pdGFibGUgPiAqOmZpcnN0LWNoaWxkID4gbWp4LW10ZCc6IHtcbiAgICAgICAgICAgICdwYWRkaW5nLXRvcCc6IDBcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGFibGUgPiAqID4gbWp4LWl0YWJsZSA+ICo6bGFzdC1jaGlsZCA+IG1qeC1tdGQnOiB7XG4gICAgICAgICAgICAncGFkZGluZy1ib3R0b20nOiAwXG4gICAgICAgIH0sXG4gICAgICAgICdtangtdHN0cnV0Jzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJy0uMjVlbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1sYWJlbHNbYWxpZ249XCJsZWZ0XCJdID4gbWp4LW10ciA+IG1qeC1tdGQnOiB7XG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdsZWZ0J1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LWxhYmVsc1thbGlnbj1cInJpZ2h0XCJdID4gbWp4LW10ciA+IG1qeC1tdGQnOiB7XG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdyaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGRbZXh0cmFdJzoge1xuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10ZFtyb3dhbGlnbj1cInRvcFwiXSc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRkW3Jvd2FsaWduPVwiY2VudGVyXCJdJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ21pZGRsZSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdGRbcm93YWxpZ249XCJib3R0b21cIl0nOiB7XG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAnYm90dG9tJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10ZFtyb3dhbGlnbj1cImJhc2VsaW5lXCJdJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ2Jhc2VsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10ZFtyb3dhbGlnbj1cImF4aXNcIl0nOiB7XG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAnLjI1ZW0nXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDSFRNTG10ZDtcbn0oKDAsIG10ZF9qc18xLkNvbW1vbk10ZE1peGluKShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSkpO1xuZXhwb3J0cy5DSFRNTG10ZCA9IENIVE1MbXRkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXRkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hUTUxtdGV4dCA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vV3JhcHBlci5qc1wiKTtcbnZhciBtdGV4dF9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tdGV4dC5qc1wiKTtcbnZhciBtdGV4dF9qc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tdGV4dC5qc1wiKTtcbnZhciBDSFRNTG10ZXh0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtdGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG10ZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbXRleHQua2luZCA9IG10ZXh0X2pzXzIuTW1sTXRleHQucHJvdG90eXBlLmtpbmQ7XG4gICAgcmV0dXJuIENIVE1MbXRleHQ7XG59KCgwLCBtdGV4dF9qc18xLkNvbW1vbk10ZXh0TWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1MbXRleHQgPSBDSFRNTG10ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTG1sYWJlbGVkdHIgPSBleHBvcnRzLkNIVE1MbXRyID0gdm9pZCAwO1xudmFyIFdyYXBwZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9XcmFwcGVyLmpzXCIpO1xudmFyIG10cl9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tdHIuanNcIik7XG52YXIgbXRyX2pzXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL210ci5qc1wiKTtcbnZhciBtdHJfanNfMyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvbXRyLmpzXCIpO1xudmFyIENIVE1MbXRyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxtdHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtdHIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxtdHIucHJvdG90eXBlLnRvQ0hUTUwgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudG9DSFRNTC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICAgIHZhciBhbGlnbiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgncm93YWxpZ24nKTtcbiAgICAgICAgaWYgKGFsaWduICE9PSAnYmFzZWxpbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICdyb3dhbGlnbicsIGFsaWduKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0hUTUxtdHIua2luZCA9IG10cl9qc18zLk1tbE10ci5wcm90b3R5cGUua2luZDtcbiAgICBDSFRNTG10ci5zdHlsZXMgPSB7XG4gICAgICAgICdtangtbXRyJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ3RhYmxlLXJvdycsXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRyW3Jvd2FsaWduPVwidG9wXCJdID4gbWp4LW10ZCc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRyW3Jvd2FsaWduPVwiY2VudGVyXCJdID4gbWp4LW10ZCc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICdtaWRkbGUnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRyW3Jvd2FsaWduPVwiYm90dG9tXCJdID4gbWp4LW10ZCc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICdib3R0b20nXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbXRyW3Jvd2FsaWduPVwiYmFzZWxpbmVcIl0gPiBtangtbXRkJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ2Jhc2VsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW10cltyb3dhbGlnbj1cImF4aXNcIl0gPiBtangtbXRkJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJy4yNWVtJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxtdHI7XG59KCgwLCBtdHJfanNfMS5Db21tb25NdHJNaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxtdHIgPSBDSFRNTG10cjtcbnZhciBDSFRNTG1sYWJlbGVkdHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG1sYWJlbGVkdHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtbGFiZWxlZHRyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbWxhYmVsZWR0ci5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS50b0NIVE1MLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5hZGFwdG9yLmZpcnN0Q2hpbGQodGhpcy5jaHRtbCk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3Jvd2FsaWduJyk7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IChhbGlnbiAhPT0gJ2Jhc2VsaW5lJyAmJiBhbGlnbiAhPT0gJ2F4aXMnID8geyByb3dhbGlnbjogYWxpZ24gfSA6IHt9KTtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmh0bWwoJ21qeC1tdHInLCBhdHRyLCBbY2hpbGRdKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5wYXJlbnQubGFiZWxzLCByb3cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTG1sYWJlbGVkdHIucHJvdG90eXBlLm1hcmtVc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuamF4LndyYXBwZXJVc2FnZS5hZGQoQ0hUTUxtdHIua2luZCk7XG4gICAgfTtcbiAgICBDSFRNTG1sYWJlbGVkdHIua2luZCA9IG10cl9qc18zLk1tbE1sYWJlbGVkdHIucHJvdG90eXBlLmtpbmQ7XG4gICAgQ0hUTUxtbGFiZWxlZHRyLnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1tbGFiZWxlZHRyJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ3RhYmxlLXJvdydcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tbGFiZWxlZHRyW3Jvd2FsaWduPVwidG9wXCJdID4gbWp4LW10ZCc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnXG4gICAgICAgIH0sXG4gICAgICAgICdtangtbWxhYmVsZWR0cltyb3dhbGlnbj1cImNlbnRlclwiXSA+IG1qeC1tdGQnOiB7XG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAnbWlkZGxlJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1sYWJlbGVkdHJbcm93YWxpZ249XCJib3R0b21cIl0gPiBtangtbXRkJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ2JvdHRvbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tbGFiZWxlZHRyW3Jvd2FsaWduPVwiYmFzZWxpbmVcIl0gPiBtangtbXRkJzoge1xuICAgICAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogJ2Jhc2VsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1sYWJlbGVkdHJbcm93YWxpZ249XCJheGlzXCJdID4gbWp4LW10ZCc6IHtcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICcuMjVlbSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENIVE1MbWxhYmVsZWR0cjtcbn0oKDAsIG10cl9qc18yLkNvbW1vbk1sYWJlbGVkdHJNaXhpbikoQ0hUTUxtdHIpKSk7XG5leHBvcnRzLkNIVE1MbWxhYmVsZWR0ciA9IENIVE1MbWxhYmVsZWR0cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW10ci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MbXVuZGVyb3ZlciA9IGV4cG9ydHMuQ0hUTUxtb3ZlciA9IGV4cG9ydHMuQ0hUTUxtdW5kZXIgPSB2b2lkIDA7XG52YXIgbXN1YnN1cF9qc18xID0gcmVxdWlyZShcIi4vbXN1YnN1cC5qc1wiKTtcbnZhciBtdW5kZXJvdmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL211bmRlcm92ZXIuanNcIik7XG52YXIgbXVuZGVyb3Zlcl9qc18yID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9tdW5kZXJvdmVyLmpzXCIpO1xudmFyIG11bmRlcm92ZXJfanNfMyA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vV3JhcHBlcnMvbXVuZGVyb3Zlci5qc1wiKTtcbnZhciBtdW5kZXJvdmVyX2pzXzQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGVzL211bmRlcm92ZXIuanNcIik7XG52YXIgQ0hUTUxtdW5kZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG11bmRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTG11bmRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG11bmRlci5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTW92YWJsZUxpbWl0cygpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnRvQ0hUTUwuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZSh0aGlzLmNodG1sLCAnbGltaXRzJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHRtbCA9IHRoaXMuc3RhbmRhcmRDSFRNTG5vZGUocGFyZW50KTtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5jaHRtbCwgdGhpcy5odG1sKCdtangtcm93JykpLCB0aGlzLmh0bWwoJ21qeC1iYXNlJykpO1xuICAgICAgICB2YXIgdW5kZXIgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5jaHRtbCwgdGhpcy5odG1sKCdtangtcm93JykpLCB0aGlzLmh0bWwoJ21qeC11bmRlcicpKTtcbiAgICAgICAgdGhpcy5iYXNlQ2hpbGQudG9DSFRNTChiYXNlKTtcbiAgICAgICAgdGhpcy5zY3JpcHRDaGlsZC50b0NIVE1MKHVuZGVyKTtcbiAgICAgICAgdmFyIGJhc2Vib3ggPSB0aGlzLmJhc2VDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgdmFyIHVuZGVyYm94ID0gdGhpcy5zY3JpcHRDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgdmFyIGsgPSB0aGlzLmdldFVuZGVyS1YoYmFzZWJveCwgdW5kZXJib3gpWzBdO1xuICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5pc0xpbmVCZWxvdyA/IDAgOiB0aGlzLmdldERlbHRhKHRydWUpKTtcbiAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKHVuZGVyLCAncGFkZGluZ1RvcCcsIHRoaXMuZW0oaykpO1xuICAgICAgICB0aGlzLnNldERlbHRhVyhbYmFzZSwgdW5kZXJdLCB0aGlzLmdldERlbHRhVyhbYmFzZWJveCwgdW5kZXJib3hdLCBbMCwgLWRlbHRhXSkpO1xuICAgICAgICB0aGlzLmFkanVzdFVuZGVyRGVwdGgodW5kZXIsIHVuZGVyYm94KTtcbiAgICB9O1xuICAgIENIVE1MbXVuZGVyLmtpbmQgPSBtdW5kZXJvdmVyX2pzXzQuTW1sTXVuZGVyLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbXVuZGVyLnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1vdmVyJzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdW5kZXI6bm90KFtsaW1pdHM9XCJmYWxzZVwiXSknOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLXRhYmxlJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC1tdW5kZXIgPiBtangtcm93Jzoge1xuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJ21qeC11bmRlcic6IHtcbiAgICAgICAgICAgICdwYWRkaW5nLWJvdHRvbSc6ICcuMWVtJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxtdW5kZXI7XG59KCgwLCBtdW5kZXJvdmVyX2pzXzEuQ29tbW9uTXVuZGVyTWl4aW4pKG1zdWJzdXBfanNfMS5DSFRNTG1zdWIpKSk7XG5leHBvcnRzLkNIVE1MbXVuZGVyID0gQ0hUTUxtdW5kZXI7XG52YXIgQ0hUTUxtb3ZlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MbW92ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtb3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTG1vdmVyLnByb3RvdHlwZS50b0NIVE1MID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5oYXNNb3ZhYmxlTGltaXRzKCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudG9DSFRNTC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlKHRoaXMuY2h0bWwsICdsaW1pdHMnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICB2YXIgb3ZlciA9IHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5jaHRtbCwgdGhpcy5odG1sKCdtangtb3ZlcicpKTtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKHRoaXMuY2h0bWwsIHRoaXMuaHRtbCgnbWp4LWJhc2UnKSk7XG4gICAgICAgIHRoaXMuc2NyaXB0Q2hpbGQudG9DSFRNTChvdmVyKTtcbiAgICAgICAgdGhpcy5iYXNlQ2hpbGQudG9DSFRNTChiYXNlKTtcbiAgICAgICAgdmFyIG92ZXJib3ggPSB0aGlzLnNjcmlwdENoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICB2YXIgYmFzZWJveCA9IHRoaXMuYmFzZUNoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICB0aGlzLmFkanVzdEJhc2VIZWlnaHQoYmFzZSwgYmFzZWJveCk7XG4gICAgICAgIHZhciBrID0gdGhpcy5nZXRPdmVyS1UoYmFzZWJveCwgb3ZlcmJveClbMF07XG4gICAgICAgIHZhciBkZWx0YSA9ICh0aGlzLmlzTGluZUFib3ZlID8gMCA6IHRoaXMuZ2V0RGVsdGEoKSk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShvdmVyLCAncGFkZGluZ0JvdHRvbScsIHRoaXMuZW0oaykpO1xuICAgICAgICB0aGlzLnNldERlbHRhVyhbYmFzZSwgb3Zlcl0sIHRoaXMuZ2V0RGVsdGFXKFtiYXNlYm94LCBvdmVyYm94XSwgWzAsIGRlbHRhXSkpO1xuICAgICAgICB0aGlzLmFkanVzdE92ZXJEZXB0aChvdmVyLCBvdmVyYm94KTtcbiAgICB9O1xuICAgIENIVE1MbW92ZXIua2luZCA9IG11bmRlcm92ZXJfanNfNC5NbWxNb3Zlci5wcm90b3R5cGUua2luZDtcbiAgICBDSFRNTG1vdmVyLnN0eWxlcyA9IHtcbiAgICAgICAgJ21qeC1tb3Zlcjpub3QoW2xpbWl0cz1cImZhbHNlXCJdKSc6IHtcbiAgICAgICAgICAgICdwYWRkaW5nLXRvcCc6ICcuMWVtJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW1vdmVyOm5vdChbbGltaXRzPVwiZmFsc2VcIl0pID4gKic6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdsZWZ0J1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxtb3Zlcjtcbn0oKDAsIG11bmRlcm92ZXJfanNfMi5Db21tb25Nb3Zlck1peGluKShtc3Vic3VwX2pzXzEuQ0hUTUxtc3VwKSkpO1xuZXhwb3J0cy5DSFRNTG1vdmVyID0gQ0hUTUxtb3ZlcjtcbnZhciBDSFRNTG11bmRlcm92ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDSFRNTG11bmRlcm92ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0hUTUxtdW5kZXJvdmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MbXVuZGVyb3Zlci5wcm90b3R5cGUudG9DSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTW92YWJsZUxpbWl0cygpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnRvQ0hUTUwuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnNldEF0dHJpYnV0ZSh0aGlzLmNodG1sLCAnbGltaXRzJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHRtbCA9IHRoaXMuc3RhbmRhcmRDSFRNTG5vZGUocGFyZW50KTtcbiAgICAgICAgdmFyIG92ZXIgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKHRoaXMuY2h0bWwsIHRoaXMuaHRtbCgnbWp4LW92ZXInKSk7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuYWRhcHRvci5hcHBlbmQodGhpcy5hZGFwdG9yLmFwcGVuZCh0aGlzLmNodG1sLCB0aGlzLmh0bWwoJ21qeC1ib3gnKSksIHRoaXMuaHRtbCgnbWp4LW11bmRlcicpKTtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmFkYXB0b3IuYXBwZW5kKHRoaXMuYWRhcHRvci5hcHBlbmQodGFibGUsIHRoaXMuaHRtbCgnbWp4LXJvdycpKSwgdGhpcy5odG1sKCdtangtYmFzZScpKTtcbiAgICAgICAgdmFyIHVuZGVyID0gdGhpcy5hZGFwdG9yLmFwcGVuZCh0aGlzLmFkYXB0b3IuYXBwZW5kKHRhYmxlLCB0aGlzLmh0bWwoJ21qeC1yb3cnKSksIHRoaXMuaHRtbCgnbWp4LXVuZGVyJykpO1xuICAgICAgICB0aGlzLm92ZXJDaGlsZC50b0NIVE1MKG92ZXIpO1xuICAgICAgICB0aGlzLmJhc2VDaGlsZC50b0NIVE1MKGJhc2UpO1xuICAgICAgICB0aGlzLnVuZGVyQ2hpbGQudG9DSFRNTCh1bmRlcik7XG4gICAgICAgIHZhciBvdmVyYm94ID0gdGhpcy5vdmVyQ2hpbGQuZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgIHZhciBiYXNlYm94ID0gdGhpcy5iYXNlQ2hpbGQuZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgIHZhciB1bmRlcmJveCA9IHRoaXMudW5kZXJDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgdGhpcy5hZGp1c3RCYXNlSGVpZ2h0KGJhc2UsIGJhc2Vib3gpO1xuICAgICAgICB2YXIgb2sgPSB0aGlzLmdldE92ZXJLVShiYXNlYm94LCBvdmVyYm94KVswXTtcbiAgICAgICAgdmFyIHVrID0gdGhpcy5nZXRVbmRlcktWKGJhc2Vib3gsIHVuZGVyYm94KVswXTtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUob3ZlciwgJ3BhZGRpbmdCb3R0b20nLCB0aGlzLmVtKG9rKSk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZSh1bmRlciwgJ3BhZGRpbmdUb3AnLCB0aGlzLmVtKHVrKSk7XG4gICAgICAgIHRoaXMuc2V0RGVsdGFXKFtiYXNlLCB1bmRlciwgb3Zlcl0sIHRoaXMuZ2V0RGVsdGFXKFtiYXNlYm94LCB1bmRlcmJveCwgb3ZlcmJveF0sIFswLCB0aGlzLmlzTGluZUJlbG93ID8gMCA6IC1kZWx0YSwgdGhpcy5pc0xpbmVBYm92ZSA/IDAgOiBkZWx0YV0pKTtcbiAgICAgICAgdGhpcy5hZGp1c3RPdmVyRGVwdGgob3Zlciwgb3ZlcmJveCk7XG4gICAgICAgIHRoaXMuYWRqdXN0VW5kZXJEZXB0aCh1bmRlciwgdW5kZXJib3gpO1xuICAgIH07XG4gICAgQ0hUTUxtdW5kZXJvdmVyLnByb3RvdHlwZS5tYXJrVXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5tYXJrVXNlZC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmpheC53cmFwcGVyVXNhZ2UuYWRkKG1zdWJzdXBfanNfMS5DSFRNTG1zdWJzdXAua2luZCk7XG4gICAgfTtcbiAgICBDSFRNTG11bmRlcm92ZXIua2luZCA9IG11bmRlcm92ZXJfanNfNC5NbWxNdW5kZXJvdmVyLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MbXVuZGVyb3Zlci5zdHlsZXMgPSB7XG4gICAgICAgICdtangtbXVuZGVyb3Zlcjpub3QoW2xpbWl0cz1cImZhbHNlXCJdKSc6IHtcbiAgICAgICAgICAgICdwYWRkaW5nLXRvcCc6ICcuMWVtJ1xuICAgICAgICB9LFxuICAgICAgICAnbWp4LW11bmRlcm92ZXI6bm90KFtsaW1pdHM9XCJmYWxzZVwiXSkgPiAqJzoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIENIVE1MbXVuZGVyb3Zlcjtcbn0oKDAsIG11bmRlcm92ZXJfanNfMy5Db21tb25NdW5kZXJvdmVyTWl4aW4pKG1zdWJzdXBfanNfMS5DSFRNTG1zdWJzdXApKSk7XG5leHBvcnRzLkNIVE1MbXVuZGVyb3ZlciA9IENIVE1MbXVuZGVyb3Zlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bmRlcm92ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSFRNTHNjcmlwdGJhc2UgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgc2NyaXB0YmFzZV9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9XcmFwcGVycy9zY3JpcHRiYXNlLmpzXCIpO1xudmFyIENIVE1Mc2NyaXB0YmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1Mc2NyaXB0YmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTHNjcmlwdGJhc2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxzY3JpcHRiYXNlLnByb3RvdHlwZS50b0NIVE1MID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLmNodG1sID0gdGhpcy5zdGFuZGFyZENIVE1Mbm9kZShwYXJlbnQpO1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5nZXRPZmZzZXQoKSwgMiksIHggPSBfYVswXSwgdiA9IF9hWzFdO1xuICAgICAgICB2YXIgZHggPSB4IC0gKHRoaXMuYmFzZVJlbW92ZUljID8gdGhpcy5iYXNlSWMgOiAwKTtcbiAgICAgICAgdmFyIHN0eWxlID0geyAndmVydGljYWwtYWxpZ24nOiB0aGlzLmVtKHYpIH07XG4gICAgICAgIGlmIChkeCkge1xuICAgICAgICAgICAgc3R5bGVbJ21hcmdpbi1sZWZ0J10gPSB0aGlzLmVtKGR4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhc2VDaGlsZC50b0NIVE1MKHRoaXMuY2h0bWwpO1xuICAgICAgICB0aGlzLnNjcmlwdENoaWxkLnRvQ0hUTUwodGhpcy5hZGFwdG9yLmFwcGVuZCh0aGlzLmNodG1sLCB0aGlzLmh0bWwoJ21qeC1zY3JpcHQnLCB7IHN0eWxlOiBzdHlsZSB9KSkpO1xuICAgIH07XG4gICAgQ0hUTUxzY3JpcHRiYXNlLnByb3RvdHlwZS5zZXREZWx0YVcgPSBmdW5jdGlvbiAobm9kZXMsIGR4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkeFtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShub2Rlc1tpXSwgJ3BhZGRpbmdMZWZ0JywgdGhpcy5lbShkeFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTHNjcmlwdGJhc2UucHJvdG90eXBlLmFkanVzdE92ZXJEZXB0aCA9IGZ1bmN0aW9uIChvdmVyLCBvdmVyYm94KSB7XG4gICAgICAgIGlmIChvdmVyYm94LmQgPj0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hZGFwdG9yLnNldFN0eWxlKG92ZXIsICdtYXJnaW5Cb3R0b20nLCB0aGlzLmVtKG92ZXJib3guZCAqIG92ZXJib3gucnNjYWxlKSk7XG4gICAgfTtcbiAgICBDSFRNTHNjcmlwdGJhc2UucHJvdG90eXBlLmFkanVzdFVuZGVyRGVwdGggPSBmdW5jdGlvbiAodW5kZXIsIHVuZGVyYm94KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAodW5kZXJib3guZCA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmVtKHVuZGVyYm94LmQpO1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5odG1sKCdtangtYm94JywgeyBzdHlsZTogeyAnbWFyZ2luLWJvdHRvbSc6IHYsICd2ZXJ0aWNhbC1hbGlnbic6IHYgfSB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoYWRhcHRvci5jaGlsZE5vZGVzKGFkYXB0b3IuZmlyc3RDaGlsZCh1bmRlcikpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGFkYXB0b3IuYXBwZW5kKGJveCwgY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRvci5hcHBlbmQoYWRhcHRvci5maXJzdENoaWxkKHVuZGVyKSwgYm94KTtcbiAgICB9O1xuICAgIENIVE1Mc2NyaXB0YmFzZS5wcm90b3R5cGUuYWRqdXN0QmFzZUhlaWdodCA9IGZ1bmN0aW9uIChiYXNlLCBiYXNlYm94KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2FjY2VudCcpKSB7XG4gICAgICAgICAgICB2YXIgbWluSCA9IHRoaXMuZm9udC5wYXJhbXMueF9oZWlnaHQgKiBiYXNlYm94LnNjYWxlO1xuICAgICAgICAgICAgaWYgKGJhc2Vib3guaCA8IG1pbkgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0U3R5bGUoYmFzZSwgJ3BhZGRpbmdUb3AnLCB0aGlzLmVtKG1pbkggLSBiYXNlYm94LmgpKTtcbiAgICAgICAgICAgICAgICBiYXNlYm94LmggPSBtaW5IO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDSFRNTHNjcmlwdGJhc2Uua2luZCA9ICdzY3JpcHRiYXNlJztcbiAgICByZXR1cm4gQ0hUTUxzY3JpcHRiYXNlO1xufSgoMCwgc2NyaXB0YmFzZV9qc18xLkNvbW1vblNjcmlwdGJhc2VNaXhpbikoV3JhcHBlcl9qc18xLkNIVE1MV3JhcHBlcikpKTtcbmV4cG9ydHMuQ0hUTUxzY3JpcHRiYXNlID0gQ0hUTUxzY3JpcHRiYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyaXB0YmFzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIVE1MeG1sID0gZXhwb3J0cy5DSFRNTGFubm90YXRpb25YTUwgPSBleHBvcnRzLkNIVE1MYW5ub3RhdGlvbiA9IGV4cG9ydHMuQ0hUTUxzZW1hbnRpY3MgPSB2b2lkIDA7XG52YXIgV3JhcHBlcl9qc18xID0gcmVxdWlyZShcIi4uL1dyYXBwZXIuanNcIik7XG52YXIgc2VtYW50aWNzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1dyYXBwZXJzL3NlbWFudGljcy5qc1wiKTtcbnZhciBzZW1hbnRpY3NfanNfMiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZXMvc2VtYW50aWNzLmpzXCIpO1xudmFyIE1tbE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZS5qc1wiKTtcbnZhciBDSFRNTHNlbWFudGljcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1Mc2VtYW50aWNzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1Mc2VtYW50aWNzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1Mc2VtYW50aWNzLnByb3RvdHlwZS50b0NIVE1MID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgY2h0bWwgPSB0aGlzLnN0YW5kYXJkQ0hUTUxub2RlKHBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0udG9DSFRNTChjaHRtbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENIVE1Mc2VtYW50aWNzLmtpbmQgPSBzZW1hbnRpY3NfanNfMi5NbWxTZW1hbnRpY3MucHJvdG90eXBlLmtpbmQ7XG4gICAgcmV0dXJuIENIVE1Mc2VtYW50aWNzO1xufSgoMCwgc2VtYW50aWNzX2pzXzEuQ29tbW9uU2VtYW50aWNzTWl4aW4pKFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKSk7XG5leHBvcnRzLkNIVE1Mc2VtYW50aWNzID0gQ0hUTUxzZW1hbnRpY3M7XG52YXIgQ0hUTUxhbm5vdGF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ0hUTUxhbm5vdGF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MYW5ub3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDSFRNTGFubm90YXRpb24ucHJvdG90eXBlLnRvQ0hUTUwgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudG9DSFRNTC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgfTtcbiAgICBDSFRNTGFubm90YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYm94O1xuICAgIH07XG4gICAgQ0hUTUxhbm5vdGF0aW9uLmtpbmQgPSBzZW1hbnRpY3NfanNfMi5NbWxBbm5vdGF0aW9uLnByb3RvdHlwZS5raW5kO1xuICAgIHJldHVybiBDSFRNTGFubm90YXRpb247XG59KFdyYXBwZXJfanNfMS5DSFRNTFdyYXBwZXIpKTtcbmV4cG9ydHMuQ0hUTUxhbm5vdGF0aW9uID0gQ0hUTUxhbm5vdGF0aW9uO1xudmFyIENIVE1MYW5ub3RhdGlvblhNTCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MYW5ub3RhdGlvblhNTCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDSFRNTGFubm90YXRpb25YTUwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ0hUTUxhbm5vdGF0aW9uWE1MLmtpbmQgPSBzZW1hbnRpY3NfanNfMi5NbWxBbm5vdGF0aW9uWE1MLnByb3RvdHlwZS5raW5kO1xuICAgIENIVE1MYW5ub3RhdGlvblhNTC5zdHlsZXMgPSB7XG4gICAgICAgICdtangtYW5ub3RhdGlvbi14bWwnOiB7XG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnaW5pdGlhbCcsXG4gICAgICAgICAgICAnbGluZS1oZWlnaHQnOiAnbm9ybWFsJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0hUTUxhbm5vdGF0aW9uWE1MO1xufShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSk7XG5leHBvcnRzLkNIVE1MYW5ub3RhdGlvblhNTCA9IENIVE1MYW5ub3RhdGlvblhNTDtcbnZhciBDSFRNTHhtbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENIVE1MeG1sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENIVE1MeG1sKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENIVE1MeG1sLnByb3RvdHlwZS50b0NIVE1MID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLmNodG1sID0gdGhpcy5hZGFwdG9yLmFwcGVuZChwYXJlbnQsIHRoaXMuYWRhcHRvci5jbG9uZSh0aGlzLm5vZGUuZ2V0WE1MKCkpKTtcbiAgICB9O1xuICAgIENIVE1MeG1sLnByb3RvdHlwZS5jb21wdXRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCBfcmVjb21wdXRlKSB7XG4gICAgICAgIGlmIChfcmVjb21wdXRlID09PSB2b2lkIDApIHsgX3JlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuamF4Lm1lYXN1cmVYTUxub2RlKHRoaXMubm9kZS5nZXRYTUwoKSksIHcgPSBfYS53LCBoID0gX2EuaCwgZCA9IF9hLmQ7XG4gICAgICAgIGJib3gudyA9IHc7XG4gICAgICAgIGJib3guaCA9IGg7XG4gICAgICAgIGJib3guZCA9IGQ7XG4gICAgfTtcbiAgICBDSFRNTHhtbC5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENIVE1MeG1sLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDSFRNTHhtbC5wcm90b3R5cGUuZ2V0VmFyaWFudCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDSFRNTHhtbC5raW5kID0gTW1sTm9kZV9qc18xLlhNTE5vZGUucHJvdG90eXBlLmtpbmQ7XG4gICAgQ0hUTUx4bWwuYXV0b1N0eWxlID0gZmFsc2U7XG4gICAgcmV0dXJuIENIVE1MeG1sO1xufShXcmFwcGVyX2pzXzEuQ0hUTUxXcmFwcGVyKSk7XG5leHBvcnRzLkNIVE1MeG1sID0gQ0hUTUx4bWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1hbnRpY3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbkFycm93ID0gZXhwb3J0cy5Db21tb25EaWFnb25hbEFycm93ID0gZXhwb3J0cy5Db21tb25EaWFnb25hbFN0cmlrZSA9IGV4cG9ydHMuQ29tbW9uQm9yZGVyMiA9IGV4cG9ydHMuQ29tbW9uQm9yZGVyID0gZXhwb3J0cy5hcnJvd0JCb3ggPSBleHBvcnRzLmRpYWdvbmFsQXJyb3dEZWYgPSBleHBvcnRzLmFycm93RGVmID0gZXhwb3J0cy5hcnJvd0JCb3hXID0gZXhwb3J0cy5hcnJvd0JCb3hIRCA9IGV4cG9ydHMuYXJyb3dIZWFkID0gZXhwb3J0cy5mdWxsQm9yZGVyID0gZXhwb3J0cy5mdWxsUGFkZGluZyA9IGV4cG9ydHMuZnVsbEJCb3ggPSBleHBvcnRzLnNpZGVOYW1lcyA9IGV4cG9ydHMuc2lkZUluZGV4ID0gZXhwb3J0cy5TT0xJRCA9IGV4cG9ydHMuUEFERElORyA9IGV4cG9ydHMuVEhJQ0tORVNTID0gZXhwb3J0cy5BUlJPV1kgPSBleHBvcnRzLkFSUk9XRFggPSBleHBvcnRzLkFSUk9XWCA9IHZvaWQgMDtcbmV4cG9ydHMuQVJST1dYID0gNCwgZXhwb3J0cy5BUlJPV0RYID0gMSwgZXhwb3J0cy5BUlJPV1kgPSAyO1xuZXhwb3J0cy5USElDS05FU1MgPSAuMDY3O1xuZXhwb3J0cy5QQURESU5HID0gLjI7XG5leHBvcnRzLlNPTElEID0gZXhwb3J0cy5USElDS05FU1MgKyAnZW0gc29saWQnO1xuZXhwb3J0cy5zaWRlSW5kZXggPSB7IHRvcDogMCwgcmlnaHQ6IDEsIGJvdHRvbTogMiwgbGVmdDogMyB9O1xuZXhwb3J0cy5zaWRlTmFtZXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLnNpZGVJbmRleCk7XG5leHBvcnRzLmZ1bGxCQm94ID0gKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBuZXcgQXJyYXkoNCkuZmlsbChub2RlLnRoaWNrbmVzcyArIG5vZGUucGFkZGluZyk7IH0pO1xuZXhwb3J0cy5mdWxsUGFkZGluZyA9IChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbmV3IEFycmF5KDQpLmZpbGwobm9kZS5wYWRkaW5nKTsgfSk7XG5leHBvcnRzLmZ1bGxCb3JkZXIgPSAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKG5vZGUudGhpY2tuZXNzKTsgfSk7XG52YXIgYXJyb3dIZWFkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobm9kZS5wYWRkaW5nLCBub2RlLnRoaWNrbmVzcyAqIChub2RlLmFycm93aGVhZC54ICsgbm9kZS5hcnJvd2hlYWQuZHggKyAxKSk7XG59O1xuZXhwb3J0cy5hcnJvd0hlYWQgPSBhcnJvd0hlYWQ7XG52YXIgYXJyb3dCQm94SEQgPSBmdW5jdGlvbiAobm9kZSwgVFJCTCkge1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZS5jaGlsZE5vZGVzWzBdLmdldEJCb3goKSwgaCA9IF9hLmgsIGQgPSBfYS5kO1xuICAgICAgICBUUkJMWzBdID0gVFJCTFsyXSA9IE1hdGgubWF4KDAsIG5vZGUudGhpY2tuZXNzICogbm9kZS5hcnJvd2hlYWQueSAtIChoICsgZCkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFRSQkw7XG59O1xuZXhwb3J0cy5hcnJvd0JCb3hIRCA9IGFycm93QkJveEhEO1xudmFyIGFycm93QkJveFcgPSBmdW5jdGlvbiAobm9kZSwgVFJCTCkge1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgdmFyIHcgPSBub2RlLmNoaWxkTm9kZXNbMF0uZ2V0QkJveCgpLnc7XG4gICAgICAgIFRSQkxbMV0gPSBUUkJMWzNdID0gTWF0aC5tYXgoMCwgbm9kZS50aGlja25lc3MgKiBub2RlLmFycm93aGVhZC55IC0gdyAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gVFJCTDtcbn07XG5leHBvcnRzLmFycm93QkJveFcgPSBhcnJvd0JCb3hXO1xuZXhwb3J0cy5hcnJvd0RlZiA9IHtcbiAgICB1cDogWy1NYXRoLlBJIC8gMiwgZmFsc2UsIHRydWUsICd2ZXJ0aWNhbHN0cmlrZSddLFxuICAgIGRvd246IFtNYXRoLlBJIC8gMiwgZmFsc2UsIHRydWUsICd2ZXJ0aWNha3N0cmlrZSddLFxuICAgIHJpZ2h0OiBbMCwgZmFsc2UsIGZhbHNlLCAnaG9yaXpvbnRhbHN0cmlrZSddLFxuICAgIGxlZnQ6IFtNYXRoLlBJLCBmYWxzZSwgZmFsc2UsICdob3Jpem9udGFsc3RyaWtlJ10sXG4gICAgdXBkb3duOiBbTWF0aC5QSSAvIDIsIHRydWUsIHRydWUsICd2ZXJ0aWNhbHN0cmlrZSB1cGFycm93IGRvd25hcnJvdyddLFxuICAgIGxlZnRyaWdodDogWzAsIHRydWUsIGZhbHNlLCAnaG9yaXpvbnRhbHN0cmlrZSBsZWZ0YXJyb3cgcmlnaHRhcnJvdyddXG59O1xuZXhwb3J0cy5kaWFnb25hbEFycm93RGVmID0ge1xuICAgIHVwZGlhZ29uYWw6IFstMSwgMCwgZmFsc2UsICd1cGRpYWdvbmFsc3RyaWtlIG5vcnRoZWFzdGFycm93J10sXG4gICAgbm9ydGhlYXN0OiBbLTEsIDAsIGZhbHNlLCAndXBkaWFnb25hbHN0cmlrZSB1cGRpYWdvbmFsYXJyb3cnXSxcbiAgICBzb3V0aGVhc3Q6IFsxLCAwLCBmYWxzZSwgJ2Rvd25kaWFnb25hbHN0cmlrZSddLFxuICAgIG5vcnRod2VzdDogWzEsIE1hdGguUEksIGZhbHNlLCAnZG93bmRpYWdvbmFsc3RyaWtlJ10sXG4gICAgc291dGh3ZXN0OiBbLTEsIE1hdGguUEksIGZhbHNlLCAndXBkaWFnb25hbHN0cmlrZSddLFxuICAgIG5vcnRoZWFzdHNvdXRod2VzdDogWy0xLCAwLCB0cnVlLCAndXBkaWFnb25hbHN0cmlrZSBub3J0aGVhc3RhcnJvdyB1cGRpYWdvbmFsYXJyb3cgc291dGh3ZXN0YXJyb3cnXSxcbiAgICBub3J0aHdlc3Rzb3V0aGVhc3Q6IFsxLCAwLCB0cnVlLCAnZG93bmRpYWdvbmFsc3RyaWtlIG5vcnRod2VzdGFycm93IHNvdXRoZWFzdGFycm93J11cbn07XG5leHBvcnRzLmFycm93QkJveCA9IHtcbiAgICB1cDogZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICgwLCBleHBvcnRzLmFycm93QkJveFcpKG5vZGUsIFsoMCwgZXhwb3J0cy5hcnJvd0hlYWQpKG5vZGUpLCAwLCBub2RlLnBhZGRpbmcsIDBdKTsgfSxcbiAgICBkb3duOiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIGV4cG9ydHMuYXJyb3dCQm94Vykobm9kZSwgW25vZGUucGFkZGluZywgMCwgKDAsIGV4cG9ydHMuYXJyb3dIZWFkKShub2RlKSwgMF0pOyB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIGV4cG9ydHMuYXJyb3dCQm94SEQpKG5vZGUsIFswLCAoMCwgZXhwb3J0cy5hcnJvd0hlYWQpKG5vZGUpLCAwLCBub2RlLnBhZGRpbmddKTsgfSxcbiAgICBsZWZ0OiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIGV4cG9ydHMuYXJyb3dCQm94SEQpKG5vZGUsIFswLCBub2RlLnBhZGRpbmcsIDAsICgwLCBleHBvcnRzLmFycm93SGVhZCkobm9kZSldKTsgfSxcbiAgICB1cGRvd246IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoMCwgZXhwb3J0cy5hcnJvd0JCb3hXKShub2RlLCBbKDAsIGV4cG9ydHMuYXJyb3dIZWFkKShub2RlKSwgMCwgKDAsIGV4cG9ydHMuYXJyb3dIZWFkKShub2RlKSwgMF0pOyB9LFxuICAgIGxlZnRyaWdodDogZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICgwLCBleHBvcnRzLmFycm93QkJveEhEKShub2RlLCBbMCwgKDAsIGV4cG9ydHMuYXJyb3dIZWFkKShub2RlKSwgMCwgKDAsIGV4cG9ydHMuYXJyb3dIZWFkKShub2RlKV0pOyB9XG59O1xudmFyIENvbW1vbkJvcmRlciA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgdmFyIGkgPSBleHBvcnRzLnNpZGVJbmRleFtzaWRlXTtcbiAgICAgICAgcmV0dXJuIFtzaWRlLCB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJlbmRlcixcbiAgICAgICAgICAgICAgICBiYm94OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmJveCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgYmJveFtpXSA9IG5vZGUudGhpY2tuZXNzICsgbm9kZS5wYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvcmRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJib3ggPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICAgICAgICAgIGJib3hbaV0gPSBub2RlLnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgfTtcbn07XG5leHBvcnRzLkNvbW1vbkJvcmRlciA9IENvbW1vbkJvcmRlcjtcbnZhciBDb21tb25Cb3JkZXIyID0gZnVuY3Rpb24gKHJlbmRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgc2lkZTEsIHNpZGUyKSB7XG4gICAgICAgIHZhciBpMSA9IGV4cG9ydHMuc2lkZUluZGV4W3NpZGUxXTtcbiAgICAgICAgdmFyIGkyID0gZXhwb3J0cy5zaWRlSW5kZXhbc2lkZTJdO1xuICAgICAgICByZXR1cm4gW25hbWUsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyLFxuICAgICAgICAgICAgICAgIGJib3g6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbm9kZS50aGlja25lc3MgKyBub2RlLnBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYm94ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICBiYm94W2kxXSA9IGJib3hbaTJdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib3JkZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYm94ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICBiYm94W2kxXSA9IGJib3hbaTJdID0gbm9kZS50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYm94O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBzaWRlMSArICcgJyArIHNpZGUyXG4gICAgICAgICAgICB9XTtcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29tbW9uQm9yZGVyMiA9IENvbW1vbkJvcmRlcjI7XG52YXIgQ29tbW9uRGlhZ29uYWxTdHJpa2UgPSBmdW5jdGlvbiAocmVuZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBjbmFtZSA9ICdtangtJyArIG5hbWUuY2hhckF0KDApICsgJ3N0cmlrZSc7XG4gICAgICAgIHJldHVybiBbbmFtZSArICdkaWFnb25hbHN0cmlrZScsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyKGNuYW1lKSxcbiAgICAgICAgICAgICAgICBiYm94OiBleHBvcnRzLmZ1bGxCQm94XG4gICAgICAgICAgICB9XTtcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29tbW9uRGlhZ29uYWxTdHJpa2UgPSBDb21tb25EaWFnb25hbFN0cmlrZTtcbnZhciBDb21tb25EaWFnb25hbEFycm93ID0gZnVuY3Rpb24gKHJlbmRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZXhwb3J0cy5kaWFnb25hbEFycm93RGVmW25hbWVdLCA0KSwgYyA9IF9hWzBdLCBwaSA9IF9hWzFdLCBkb3VibGUgPSBfYVsyXSwgcmVtb3ZlID0gX2FbM107XG4gICAgICAgIHJldHVybiBbbmFtZSArICdhcnJvdycsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogZnVuY3Rpb24gKG5vZGUsIF9jaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQobm9kZS5hcnJvd0FXKCksIDIpLCBhID0gX2FbMF0sIFcgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycm93ID0gbm9kZS5hcnJvdyhXLCBjICogKGEgLSBwaSksIGRvdWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihub2RlLCBhcnJvdyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYm94OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBub2RlLmFycm93RGF0YSgpLCBhID0gX2EuYSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoW25vZGUuYXJyb3doZWFkLngsIG5vZGUuYXJyb3doZWFkLnksIG5vZGUuYXJyb3doZWFkLmR4XSwgMyksIGF4ID0gX2JbMF0sIGF5ID0gX2JbMV0sIGFkeCA9IF9iWzJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBfX3JlYWQobm9kZS5nZXRBcmdNb2QoYXggKyBhZHgsIGF5KSwgMiksIGIgPSBfY1swXSwgYXIgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0geSArIChiID4gYSA/IG5vZGUudGhpY2tuZXNzICogYXIgKiBNYXRoLnNpbihiIC0gYSkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0geCArIChiID4gTWF0aC5QSSAvIDIgLSBhID8gbm9kZS50aGlja25lc3MgKiBhciAqIE1hdGguc2luKGIgKyBhIC0gTWF0aC5QSSAvIDIpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZHksIGR4LCBkeSwgZHhdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmVcbiAgICAgICAgICAgIH1dO1xuICAgIH07XG59O1xuZXhwb3J0cy5Db21tb25EaWFnb25hbEFycm93ID0gQ29tbW9uRGlhZ29uYWxBcnJvdztcbnZhciBDb21tb25BcnJvdyA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGV4cG9ydHMuYXJyb3dEZWZbbmFtZV0sIDQpLCBhbmdsZSA9IF9hWzBdLCBkb3VibGUgPSBfYVsxXSwgaXNWZXJ0aWNhbCA9IF9hWzJdLCByZW1vdmUgPSBfYVszXTtcbiAgICAgICAgcmV0dXJuIFtuYW1lICsgJ2Fycm93Jywge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBmdW5jdGlvbiAobm9kZSwgX2NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IG5vZGUuZ2V0QkJveCgpLCB3ID0gX2EudywgaCA9IF9hLmgsIGQgPSBfYS5kO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoKGlzVmVydGljYWwgPyBbaCArIGQsICdYJ10gOiBbdywgJ1knXSksIDIpLCBXID0gX2JbMF0sIG9mZnNldCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGQgPSBub2RlLmdldE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBub2RlLmFycm93KFcsIGFuZ2xlLCBkb3VibGUsIG9mZnNldCwgZGQpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIobm9kZSwgYXJyb3cpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmJveDogZXhwb3J0cy5hcnJvd0JCb3hbbmFtZV0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmVcbiAgICAgICAgICAgIH1dO1xuICAgIH07XG59O1xuZXhwb3J0cy5Db21tb25BcnJvdyA9IENvbW1vbkFycm93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uT3V0cHV0SmF4ID0gdm9pZCAwO1xudmFyIE91dHB1dEpheF9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvT3V0cHV0SmF4LmpzXCIpO1xudmFyIE1hdGhJdGVtX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9NYXRoSXRlbS5qc1wiKTtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xudmFyIGxlbmd0aHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xlbmd0aHMuanNcIik7XG52YXIgU3R5bGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHlsZXMuanNcIik7XG52YXIgU3R5bGVMaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHlsZUxpc3QuanNcIik7XG52YXIgQ29tbW9uT3V0cHV0SmF4ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbW9uT3V0cHV0SmF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbW1vbk91dHB1dEpheChvcHRpb25zLCBkZWZhdWx0RmFjdG9yeSwgZGVmYXVsdEZvbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgICAgICBpZiAoZGVmYXVsdEZhY3RvcnkgPT09IHZvaWQgMCkgeyBkZWZhdWx0RmFjdG9yeSA9IG51bGw7IH1cbiAgICAgICAgaWYgKGRlZmF1bHRGb250ID09PSB2b2lkIDApIHsgZGVmYXVsdEZvbnQgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCgoMCwgT3B0aW9uc19qc18xLnNlcGFyYXRlT3B0aW9ucykob3B0aW9ucywgZGVmYXVsdEZvbnQuT1BUSU9OUyksIDIpLCBqYXhPcHRpb25zID0gX2FbMF0sIGZvbnRPcHRpb25zID0gX2FbMV07XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgamF4T3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZmFjdG9yeSA9IF90aGlzLm9wdGlvbnMud3JhcHBlckZhY3RvcnkgfHxcbiAgICAgICAgICAgIG5ldyBkZWZhdWx0RmFjdG9yeSgpO1xuICAgICAgICBfdGhpcy5mYWN0b3J5LmpheCA9IF90aGlzO1xuICAgICAgICBfdGhpcy5jc3NTdHlsZXMgPSBfdGhpcy5vcHRpb25zLmNzc1N0eWxlcyB8fCBuZXcgU3R5bGVMaXN0X2pzXzEuQ3NzU3R5bGVzKCk7XG4gICAgICAgIF90aGlzLmZvbnQgPSBfdGhpcy5vcHRpb25zLmZvbnQgfHwgbmV3IGRlZmF1bHRGb250KGZvbnRPcHRpb25zKTtcbiAgICAgICAgX3RoaXMudW5rbm93bkNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUudHlwZXNldCA9IGZ1bmN0aW9uIChtYXRoLCBodG1sKSB7XG4gICAgICAgIHRoaXMuc2V0RG9jdW1lbnQoaHRtbCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG4gICAgICAgIHRoaXMudG9ET00obWF0aCwgbm9kZSwgaHRtbCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgamF4ID0gdGhpcy5jb25zdHJ1Y3Rvci5OQU1FO1xuICAgICAgICByZXR1cm4gdGhpcy5odG1sKCdtangtY29udGFpbmVyJywgeyAnY2xhc3MnOiAnTWF0aEpheCcsIGpheDogamF4IH0pO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMubWF0aC5tZXRyaWNzLnNjYWxlICogdGhpcy5vcHRpb25zLnNjYWxlO1xuICAgICAgICBpZiAoc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zZXRTdHlsZShub2RlLCAnZm9udFNpemUnLCAoMCwgbGVuZ3Roc19qc18xLnBlcmNlbnQpKHNjYWxlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUudG9ET00gPSBmdW5jdGlvbiAobWF0aCwgbm9kZSwgaHRtbCkge1xuICAgICAgICBpZiAoaHRtbCA9PT0gdm9pZCAwKSB7IGh0bWwgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuc2V0RG9jdW1lbnQoaHRtbCk7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHRoaXMucHhQZXJFbSA9IG1hdGgubWV0cmljcy5leCAvIHRoaXMuZm9udC5wYXJhbXMueF9oZWlnaHQ7XG4gICAgICAgIG1hdGgucm9vdC5zZXRUZVhjbGFzcyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRTY2FsZShub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgIHRoaXMucHJvY2Vzc01hdGgobWF0aC5yb290LCBub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5leGVjdXRlRmlsdGVycyh0aGlzLnBvc3RGaWx0ZXJzLCBtYXRoLCBodG1sLCBub2RlKTtcbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUuZ2V0QkJveCA9IGZ1bmN0aW9uIChtYXRoLCBodG1sKSB7XG4gICAgICAgIHRoaXMuc2V0RG9jdW1lbnQoaHRtbCk7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIG1hdGgucm9vdC5zZXRUZVhjbGFzcyhudWxsKTtcbiAgICAgICAgdGhpcy5ub2RlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZmFjdG9yeS53cmFwKG1hdGgucm9vdCkuZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgIHRoaXMubm9kZU1hcCA9IG51bGw7XG4gICAgICAgIHJldHVybiBiYm94O1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHRoaXMuc2V0RG9jdW1lbnQoaHRtbCk7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgbWFwcyA9IHRoaXMuZ2V0TWV0cmljTWFwcyhodG1sKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoaHRtbC5tYXRoKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRoID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gYWRhcHRvci5wYXJlbnQobWF0aC5zdGFydC5ub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0aC5zdGF0ZSgpIDwgTWF0aEl0ZW1fanNfMS5TVEFURS5NRVRSSUNTICYmIHBhcmVudF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBtYXBzW21hdGguZGlzcGxheSA/IDEgOiAwXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kID0gbWFwLmdldChwYXJlbnRfMSksIGVtID0gX2QuZW0sIGV4ID0gX2QuZXgsIGNvbnRhaW5lcldpZHRoID0gX2QuY29udGFpbmVyV2lkdGgsIGxpbmVXaWR0aCA9IF9kLmxpbmVXaWR0aCwgc2NhbGUgPSBfZC5zY2FsZSwgZmFtaWx5ID0gX2QuZmFtaWx5O1xuICAgICAgICAgICAgICAgICAgICBtYXRoLnNldE1ldHJpY3MoZW0sIGV4LCBjb250YWluZXJXaWR0aCwgbGluZVdpZHRoLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubXRleHRJbmhlcml0Rm9udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0aC5vdXRwdXREYXRhLm10ZXh0RmFtaWx5ID0gZmFtaWx5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWVycm9ySW5oZXJpdEZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgub3V0cHV0RGF0YS5tZXJyb3JGYW1pbHkgPSBmYW1pbHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0aC5zdGF0ZShNYXRoSXRlbV9qc18xLlNUQVRFLk1FVFJJQ1MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tb25PdXRwdXRKYXgucHJvdG90eXBlLmdldE1ldHJpY3NGb3IgPSBmdW5jdGlvbiAobm9kZSwgZGlzcGxheSkge1xuICAgICAgICB2YXIgZ2V0RmFtaWx5ID0gKHRoaXMub3B0aW9ucy5tdGV4dEluaGVyaXRGb250IHx8IHRoaXMub3B0aW9ucy5tZXJyb3JJbmhlcml0Rm9udCk7XG4gICAgICAgIHZhciB0ZXN0ID0gdGhpcy5nZXRUZXN0RWxlbWVudChub2RlLCBkaXNwbGF5KTtcbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLm1lYXN1cmVNZXRyaWNzKHRlc3QsIGdldEZhbWlseSk7XG4gICAgICAgIHRoaXMuYWRhcHRvci5yZW1vdmUodGVzdCk7XG4gICAgICAgIHJldHVybiBtZXRyaWNzO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5nZXRNZXRyaWNNYXBzID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgdmFyIGVfMiwgX2EsIGVfMywgX2IsIGVfNCwgX2MsIGVfNSwgX2QsIGVfNiwgX2U7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgZG9tTWFwcyA9IFtuZXcgTWFwKCksIG5ldyBNYXAoKV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZiA9IF9fdmFsdWVzKGh0bWwubWF0aCksIF9nID0gX2YubmV4dCgpOyAhX2cuZG9uZTsgX2cgPSBfZi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0aCA9IF9nLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gYWRhcHRvci5wYXJlbnQobWF0aC5zdGFydC5ub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBtYXRoLnN0YXRlKCkgPCBNYXRoSXRlbV9qc18xLlNUQVRFLk1FVFJJQ1MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IGRvbU1hcHNbbWF0aC5kaXNwbGF5ID8gMSA6IDBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zZXQobm9kZSwgdGhpcy5nZXRUZXN0RWxlbWVudChub2RlLCBtYXRoLmRpc3BsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYSA9IF9mLnJldHVybikpIF9hLmNhbGwoX2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRGYW1pbHkgPSB0aGlzLm9wdGlvbnMubXRleHRJbmhlcml0Rm9udCB8fCB0aGlzLm9wdGlvbnMubWVycm9ySW5oZXJpdEZvbnQ7XG4gICAgICAgIHZhciBtYXBzID0gW25ldyBNYXAoKSwgbmV3IE1hcCgpXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9oID0gX192YWx1ZXMobWFwcy5rZXlzKCkpLCBfaiA9IF9oLm5leHQoKTsgIV9qLmRvbmU7IF9qID0gX2gubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBfai52YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IChlXzQgPSB2b2lkIDAsIF9fdmFsdWVzKGRvbU1hcHNbaV0ua2V5cygpKSksIF9sID0gX2submV4dCgpOyAhX2wuZG9uZTsgX2wgPSBfay5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX2wudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBzW2ldLnNldChub2RlLCB0aGlzLm1lYXN1cmVNZXRyaWNzKGRvbU1hcHNbaV0uZ2V0KG5vZGUpLCBnZXRGYW1pbHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9sICYmICFfbC5kb25lICYmIChfYyA9IF9rLnJldHVybikpIF9jLmNhbGwoX2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfaiAmJiAhX2ouZG9uZSAmJiAoX2IgPSBfaC5yZXR1cm4pKSBfYi5jYWxsKF9oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX20gPSBfX3ZhbHVlcyhtYXBzLmtleXMoKSksIF9vID0gX20ubmV4dCgpOyAhX28uZG9uZTsgX28gPSBfbS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IF9vLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9wID0gKGVfNiA9IHZvaWQgMCwgX192YWx1ZXMoZG9tTWFwc1tpXS52YWx1ZXMoKSkpLCBfcSA9IF9wLm5leHQoKTsgIV9xLmRvbmU7IF9xID0gX3AubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRvci5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfNl8xKSB7IGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcSAmJiAhX3EuZG9uZSAmJiAoX2UgPSBfcC5yZXR1cm4pKSBfZS5jYWxsKF9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX28gJiYgIV9vLmRvbmUgJiYgKF9kID0gX20ucmV0dXJuKSkgX2QuY2FsbChfbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfTtcbiAgICBDb21tb25PdXRwdXRKYXgucHJvdG90eXBlLmdldFRlc3RFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIGlmICghdGhpcy50ZXN0SW5saW5lKSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RJbmxpbmUgPSB0aGlzLmh0bWwoJ21qeC10ZXN0JywgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICdmb250LXNpemUtYWRqdXN0JzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1pbmRlbnQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICdsZXR0ZXItc3BhY2luZyc6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgICAgICAnd29yZC1zcGFjaW5nJzogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6ICctMXB4J1xuICAgICAgICAgICAgICAgIH0gfSwgW1xuICAgICAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWxlZnQtYm94JywgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCc6ICdsZWZ0J1xuICAgICAgICAgICAgICAgICAgICB9IH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LWV4LWJveCcsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxcHgnLCBoZWlnaHQ6ICc2MGV4J1xuICAgICAgICAgICAgICAgICAgICB9IH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuaHRtbCgnbWp4LXJpZ2h0LWJveCcsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQnOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgICAgIH0gfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy50ZXN0RGlzcGxheSA9IGFkYXB0b3IuY2xvbmUodGhpcy50ZXN0SW5saW5lKTtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUodGhpcy50ZXN0RGlzcGxheSwgJ2Rpc3BsYXknLCAndGFibGUnKTtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUodGhpcy50ZXN0RGlzcGxheSwgJ21hcmdpbi1yaWdodCcsICcnKTtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoYWRhcHRvci5maXJzdENoaWxkKHRoaXMudGVzdERpc3BsYXkpLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBhZGFwdG9yLmxhc3RDaGlsZCh0aGlzLnRlc3REaXNwbGF5KTtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUocmlnaHQsICdkaXNwbGF5JywgJ3RhYmxlLWNlbGwnKTtcbiAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUocmlnaHQsICd3aWR0aCcsICcxMDAwMGVtJyk7XG4gICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHJpZ2h0LCAnZmxvYXQnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkYXB0b3IuYXBwZW5kKG5vZGUsIGFkYXB0b3IuY2xvbmUoZGlzcGxheSA/IHRoaXMudGVzdERpc3BsYXkgOiB0aGlzLnRlc3RJbmxpbmUpKTtcbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUubWVhc3VyZU1ldHJpY3MgPSBmdW5jdGlvbiAobm9kZSwgZ2V0RmFtaWx5KSB7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB2YXIgZmFtaWx5ID0gKGdldEZhbWlseSA/IGFkYXB0b3IuZm9udEZhbWlseShub2RlKSA6ICcnKTtcbiAgICAgICAgdmFyIGVtID0gYWRhcHRvci5mb250U2l6ZShub2RlKTtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGFkYXB0b3Iubm9kZVNpemUoYWRhcHRvci5jaGlsZE5vZGUobm9kZSwgMSkpLCAyKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgICAgIHZhciBleCA9ICh3ID8gaCAvIDYwIDogZW0gKiB0aGlzLm9wdGlvbnMuZXhGYWN0b3IpO1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSAoIXcgPyAxMDAwMDAwIDogYWRhcHRvci5nZXRTdHlsZShub2RlLCAnZGlzcGxheScpID09PSAndGFibGUnID9cbiAgICAgICAgICAgIGFkYXB0b3Iubm9kZVNpemUoYWRhcHRvci5sYXN0Q2hpbGQobm9kZSkpWzBdIC0gMSA6XG4gICAgICAgICAgICBhZGFwdG9yLm5vZGVCQm94KGFkYXB0b3IubGFzdENoaWxkKG5vZGUpKS5sZWZ0IC1cbiAgICAgICAgICAgICAgICBhZGFwdG9yLm5vZGVCQm94KGFkYXB0b3IuZmlyc3RDaGlsZChub2RlKSkubGVmdCAtIDIpO1xuICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXRjaEZvbnRIZWlnaHQgPyBleCAvIHRoaXMuZm9udC5wYXJhbXMueF9oZWlnaHQgLyBlbSA6IDEpO1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gMTAwMDAwMDtcbiAgICAgICAgcmV0dXJuIHsgZW06IGVtLCBleDogZXgsIGNvbnRhaW5lcldpZHRoOiBjb250YWluZXJXaWR0aCwgbGluZVdpZHRoOiBsaW5lV2lkdGgsIHNjYWxlOiBzY2FsZSwgZmFtaWx5OiBmYW1pbHkgfTtcbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUuc3R5bGVTaGVldCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHZhciBlXzcsIF9hO1xuICAgICAgICB0aGlzLnNldERvY3VtZW50KGh0bWwpO1xuICAgICAgICB0aGlzLmNzc1N0eWxlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNzc1N0eWxlcy5hZGRTdHlsZXModGhpcy5jb25zdHJ1Y3Rvci5jb21tb25TdHlsZXMpO1xuICAgICAgICBpZiAoJ2dldFN0eWxlcycgaW4gaHRtbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGh0bWwuZ2V0U3R5bGVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3NTdHlsZXMuYWRkU3R5bGVzKHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkV3JhcHBlclN0eWxlcyh0aGlzLmNzc1N0eWxlcyk7XG4gICAgICAgIHRoaXMuYWRkRm9udFN0eWxlcyh0aGlzLmNzc1N0eWxlcyk7XG4gICAgICAgIHZhciBzaGVldCA9IHRoaXMuaHRtbCgnc3R5bGUnLCB7IGlkOiAnTUpYLXN0eWxlcycgfSwgW3RoaXMudGV4dCgnXFxuJyArIHRoaXMuY3NzU3R5bGVzLmNzc1RleHQgKyAnXFxuJyldKTtcbiAgICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5hZGRGb250U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICBzdHlsZXMuYWRkU3R5bGVzKHRoaXMuZm9udC5zdHlsZXMpO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5hZGRXcmFwcGVyU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB2YXIgZV84LCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5mYWN0b3J5LmdldEtpbmRzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsYXNzU3R5bGVzKHRoaXMuZmFjdG9yeS5nZXROb2RlQ2xhc3Moa2luZCksIHN0eWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfOF8xKSB7IGVfOCA9IHsgZXJyb3I6IGVfOF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV84KSB0aHJvdyBlXzguZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5hZGRDbGFzc1N0eWxlcyA9IGZ1bmN0aW9uIChDTEFTUywgc3R5bGVzKSB7XG4gICAgICAgIHN0eWxlcy5hZGRTdHlsZXMoQ0xBU1Muc3R5bGVzKTtcbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IGh0bWw7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3IuZG9jdW1lbnQgPSBodG1sLmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tb25PdXRwdXRKYXgucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbiAodHlwZSwgZGVmLCBjb250ZW50LCBucykge1xuICAgICAgICBpZiAoZGVmID09PSB2b2lkIDApIHsgZGVmID0ge307IH1cbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gW107IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRvci5ub2RlKHR5cGUsIGRlZiwgY29udGVudCwgbnMpO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRvci50ZXh0KHRleHQpO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5maXhlZCA9IGZ1bmN0aW9uIChtLCBuKSB7XG4gICAgICAgIGlmIChuID09PSB2b2lkIDApIHsgbiA9IDM7IH1cbiAgICAgICAgaWYgKE1hdGguYWJzKG0pIDwgLjAwMDYpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udG9GaXhlZChuKS5yZXBsYWNlKC9cXC4/MCskLywgJycpO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB2YXJpYW50LCBmb250KSB7XG4gICAgICAgIGlmIChmb250ID09PSB2b2lkIDApIHsgZm9udCA9IFsnJywgZmFsc2UsIGZhbHNlXTsgfVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMudW5rbm93blRleHQodGV4dCwgdmFyaWFudCk7XG4gICAgICAgIGlmICh2YXJpYW50ID09PSAnLWV4cGxpY2l0Rm9udCcpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmNzc0ZvbnRTdHlsZXMoZm9udCk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlcyhub2RlLCB7IHN0eWxlOiBzdHlsZXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVhc3VyZVRleHROb2RlV2l0aENhY2hlKG5vZGUsIHRleHQsIHZhcmlhbnQsIGZvbnQpO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5tZWFzdXJlVGV4dE5vZGVXaXRoQ2FjaGUgPSBmdW5jdGlvbiAodGV4dCwgY2hhcnMsIHZhcmlhbnQsIGZvbnQpIHtcbiAgICAgICAgaWYgKGZvbnQgPT09IHZvaWQgMCkgeyBmb250ID0gWycnLCBmYWxzZSwgZmFsc2VdOyB9XG4gICAgICAgIGlmICh2YXJpYW50ID09PSAnLWV4cGxpY2l0Rm9udCcpIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSBbZm9udFswXSwgZm9udFsxXSA/ICdUJyA6ICdGJywgZm9udFsyXSA/ICdUJyA6ICdGJywgJyddLmpvaW4oJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudW5rbm93bkNhY2hlLmhhcyh2YXJpYW50KSkge1xuICAgICAgICAgICAgdGhpcy51bmtub3duQ2FjaGUuc2V0KHZhcmlhbnQsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMudW5rbm93bkNhY2hlLmdldCh2YXJpYW50KTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IG1hcC5nZXQoY2hhcnMpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLm1lYXN1cmVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgbWFwLnNldChjaGFycywgYmJveCk7XG4gICAgICAgIHJldHVybiBiYm94O1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5tZWFzdXJlWE1Mbm9kZSA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5odG1sKCdtangteG1sLWJsb2NrJywgeyBzdHlsZTogeyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9IH0sIFthZGFwdG9yLmNsb25lKHhtbCldKTtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmh0bWwoJ21qeC1iYXNlbGluZScsIHsgc3R5bGU6IHsgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSB9KTtcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdpbml0aWFsJyxcbiAgICAgICAgICAgICdsaW5lLWhlaWdodCc6ICdub3JtYWwnXG4gICAgICAgIH07XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5odG1sKCdtangtbWVhc3VyZS14bWwnLCB7IHN0eWxlOiBzdHlsZSB9LCBbYmFzZSwgY29udGVudF0pO1xuICAgICAgICBhZGFwdG9yLmFwcGVuZChhZGFwdG9yLnBhcmVudCh0aGlzLm1hdGguc3RhcnQubm9kZSksIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgYWRhcHRvci5hcHBlbmQodGhpcy5jb250YWluZXIsIG5vZGUpO1xuICAgICAgICB2YXIgZW0gPSB0aGlzLm1hdGgubWV0cmljcy5lbSAqIHRoaXMubWF0aC5tZXRyaWNzLnNjYWxlO1xuICAgICAgICB2YXIgX2EgPSBhZGFwdG9yLm5vZGVCQm94KGNvbnRlbnQpLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tLCB0b3AgPSBfYS50b3A7XG4gICAgICAgIHZhciB3ID0gKHJpZ2h0IC0gbGVmdCkgLyBlbTtcbiAgICAgICAgdmFyIGggPSAoYWRhcHRvci5ub2RlQkJveChiYXNlKS50b3AgLSB0b3ApIC8gZW07XG4gICAgICAgIHZhciBkID0gKGJvdHRvbSAtIHRvcCkgLyBlbSAtIGg7XG4gICAgICAgIGFkYXB0b3IucmVtb3ZlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgYWRhcHRvci5yZW1vdmUobm9kZSk7XG4gICAgICAgIHJldHVybiB7IHc6IHcsIGg6IGgsIGQ6IGQgfTtcbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5wcm90b3R5cGUuY3NzRm9udFN0eWxlcyA9IGZ1bmN0aW9uIChmb250LCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IHt9OyB9XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChmb250LCAzKSwgZmFtaWx5ID0gX2FbMF0sIGl0YWxpYyA9IF9hWzFdLCBib2xkID0gX2FbMl07XG4gICAgICAgIHN0eWxlc1snZm9udC1mYW1pbHknXSA9IHRoaXMuZm9udC5nZXRGYW1pbHkoZmFtaWx5KTtcbiAgICAgICAgaWYgKGl0YWxpYylcbiAgICAgICAgICAgIHN0eWxlc1snZm9udC1zdHlsZSddID0gJ2l0YWxpYyc7XG4gICAgICAgIGlmIChib2xkKVxuICAgICAgICAgICAgc3R5bGVzWydmb250LXdlaWdodCddID0gJ2JvbGQnO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gICAgQ29tbW9uT3V0cHV0SmF4LnByb3RvdHlwZS5nZXRGb250RGF0YSA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgICAgICAgIHN0eWxlcyA9IG5ldyBTdHlsZXNfanNfMS5TdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMuZm9udC5nZXRGYW1pbHkoc3R5bGVzLmdldCgnZm9udC1mYW1pbHknKSksXG4gICAgICAgICAgICBzdHlsZXMuZ2V0KCdmb250LXN0eWxlJykgPT09ICdpdGFsaWMnLFxuICAgICAgICAgICAgc3R5bGVzLmdldCgnZm9udC13ZWlnaHQnKSA9PT0gJ2JvbGQnXTtcbiAgICB9O1xuICAgIENvbW1vbk91dHB1dEpheC5OQU1FID0gJ0NvbW1vbic7XG4gICAgQ29tbW9uT3V0cHV0SmF4Lk9QVElPTlMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgT3V0cHV0SmF4X2pzXzEuQWJzdHJhY3RPdXRwdXRKYXguT1BUSU9OUyksIHsgc2NhbGU6IDEsIG1pblNjYWxlOiAuNSwgbXRleHRJbmhlcml0Rm9udDogZmFsc2UsIG1lcnJvckluaGVyaXRGb250OiBmYWxzZSwgbXRleHRGb250OiAnJywgbWVycm9yRm9udDogJ3NlcmlmJywgbWF0aG1sU3BhY2luZzogZmFsc2UsIHNraXBBdHRyaWJ1dGVzOiB7fSwgZXhGYWN0b3I6IC41LCBkaXNwbGF5QWxpZ246ICdjZW50ZXInLCBkaXNwbGF5SW5kZW50OiAnMCcsIHdyYXBwZXJGYWN0b3J5OiBudWxsLCBmb250OiBudWxsLCBjc3NTdHlsZXM6IG51bGwgfSk7XG4gICAgQ29tbW9uT3V0cHV0SmF4LmNvbW1vblN0eWxlcyA9IHt9O1xuICAgIHJldHVybiBDb21tb25PdXRwdXRKYXg7XG59KE91dHB1dEpheF9qc18xLkFic3RyYWN0T3V0cHV0SmF4KSk7XG5leHBvcnRzLkNvbW1vbk91dHB1dEpheCA9IENvbW1vbk91dHB1dEpheDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dHB1dEpheC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uV3JhcHBlciA9IHZvaWQgMDtcbnZhciBXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9UcmVlL1dyYXBwZXIuanNcIik7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xudmFyIHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3RyaW5nLmpzXCIpO1xudmFyIExFTkdUSFMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL3V0aWwvbGVuZ3Rocy5qc1wiKSk7XG52YXIgU3R5bGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHlsZXMuanNcIik7XG52YXIgQkJveF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvQkJveC5qc1wiKTtcbnZhciBGb250RGF0YV9qc18xID0gcmVxdWlyZShcIi4vRm9udERhdGEuanNcIik7XG52YXIgU01BTExTSVpFID0gMiAvIDE4O1xuZnVuY3Rpb24gTWF0aE1MU3BhY2Uoc2NyaXB0LCBzaXplKSB7XG4gICAgcmV0dXJuIChzY3JpcHQgPyBzaXplIDwgU01BTExTSVpFID8gMCA6IFNNQUxMU0laRSA6IHNpemUpO1xufVxudmFyIENvbW1vbldyYXBwZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21tb25XcmFwcGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbW1vbldyYXBwZXIoZmFjdG9yeSwgbm9kZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlbW92ZWRTdHlsZXMgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBudWxsO1xuICAgICAgICBfdGhpcy52YXJpYW50ID0gJyc7XG4gICAgICAgIF90aGlzLmJib3hDb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zdHJldGNoID0gRm9udERhdGFfanNfMS5OT1NUUkVUQ0g7XG4gICAgICAgIF90aGlzLmZvbnQgPSBudWxsO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLmZvbnQgPSBmYWN0b3J5LmpheC5mb250O1xuICAgICAgICBfdGhpcy5iYm94ID0gQkJveF9qc18xLkJCb3guemVybygpO1xuICAgICAgICBfdGhpcy5nZXRTdHlsZXMoKTtcbiAgICAgICAgX3RoaXMuZ2V0VmFyaWFudCgpO1xuICAgICAgICBfdGhpcy5nZXRTY2FsZSgpO1xuICAgICAgICBfdGhpcy5nZXRTcGFjZSgpO1xuICAgICAgICBfdGhpcy5jaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gX3RoaXMud3JhcChjaGlsZCk7XG4gICAgICAgICAgICBpZiAod3JhcHBlZC5iYm94LnB3aWR0aCAmJiAobm9kZS5ub3RQYXJlbnQgfHwgbm9kZS5pc0tpbmQoJ21hdGgnKSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iYm94LnB3aWR0aCA9IEJCb3hfanNfMS5CQm94LmZ1bGxXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbW9uV3JhcHBlci5wcm90b3R5cGUsIFwiamF4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWN0b3J5LmpheDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tb25XcmFwcGVyLnByb3RvdHlwZSwgXCJhZGFwdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWN0b3J5LmpheC5hZGFwdG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1vbldyYXBwZXIucHJvdG90eXBlLCBcIm1ldHJpY3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY3RvcnkuamF4Lm1hdGgubWV0cmljcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tb25XcmFwcGVyLnByb3RvdHlwZSwgXCJmaXhlc1BXaWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5vZGUubm90UGFyZW50ICYmICF0aGlzLm5vZGUuaXNUb2tlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHZhciB3cmFwcGVkID0gdGhpcy5mYWN0b3J5LndyYXAobm9kZSwgcGFyZW50IHx8IHRoaXMpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGROb2Rlcy5wdXNoKHdyYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuamF4Lm5vZGVNYXAuc2V0KG5vZGUsIHdyYXBwZWQpO1xuICAgICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbiAoc2F2ZSkge1xuICAgICAgICBpZiAoc2F2ZSA9PT0gdm9pZCAwKSB7IHNhdmUgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aGlzLmJib3hDb21wdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmJveDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmJveCA9IChzYXZlID8gdGhpcy5iYm94IDogQkJveF9qc18xLkJCb3guemVybygpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQkJveChiYm94KTtcbiAgICAgICAgdGhpcy5iYm94Q29tcHV0ZWQgPSBzYXZlO1xuICAgICAgICByZXR1cm4gYmJveDtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmdldE91dGVyQkJveCA9IGZ1bmN0aW9uIChzYXZlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAoc2F2ZSA9PT0gdm9pZCAwKSB7IHNhdmUgPSB0cnVlOyB9XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KHNhdmUpO1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGVzKVxuICAgICAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICAgIHZhciBvYm94ID0gbmV3IEJCb3hfanNfMS5CQm94KCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob2JveCwgYmJveCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKEJCb3hfanNfMS5CQm94LlN0eWxlQWRqdXN0KSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZChfYy52YWx1ZSwgMiksIG5hbWVfMSA9IF9kWzBdLCBzaWRlID0gX2RbMV07XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLnN0eWxlcy5nZXQobmFtZV8xKTtcbiAgICAgICAgICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBvYm94W3NpZGVdICs9IHRoaXMubGVuZ3RoMmVtKHgsIDEsIG9ib3gucnNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JveDtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHJlY29tcHV0ZSkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgaWYgKHJlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IHJlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgIGJib3guZW1wdHkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5jaGlsZE5vZGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJib3guYXBwZW5kKGNoaWxkLmdldE91dGVyQkJveCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGJib3guY2xlYW4oKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZXNQV2lkdGggJiYgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQkJveChiYm94LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuc2V0Q2hpbGRQV2lkdGhzID0gZnVuY3Rpb24gKHJlY29tcHV0ZSwgdywgY2xlYXIpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIGlmICh3ID09PSB2b2lkIDApIHsgdyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGNsZWFyID09PSB2b2lkIDApIHsgY2xlYXIgPSB0cnVlOyB9XG4gICAgICAgIGlmIChyZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmJveC5wd2lkdGggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGNib3ggPSBjaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgICAgICBpZiAoY2JveC5wd2lkdGggJiYgY2hpbGQuc2V0Q2hpbGRQV2lkdGhzKHJlY29tcHV0ZSwgdyA9PT0gbnVsbCA/IGNib3gudyA6IHcsIGNsZWFyKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmludmFsaWRhdGVCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5iYm94Q29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmJveENvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnZhbGlkYXRlQkJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5jb3B5U2tld0lDID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBpZiAoZmlyc3QgPT09IG51bGwgfHwgZmlyc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0LmJib3guc2spIHtcbiAgICAgICAgICAgIGJib3guc2sgPSBmaXJzdC5iYm94LnNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3QuYmJveC5keCkge1xuICAgICAgICAgICAgYmJveC5keCA9IGZpcnN0LmJib3guZHg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmNoaWxkTm9kZXNbdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmJib3guaWMpIHtcbiAgICAgICAgICAgIGJib3guaWMgPSBsYXN0LmJib3guaWM7XG4gICAgICAgICAgICBiYm94LncgKz0gYmJveC5pYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGVTdHJpbmcgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXRFeHBsaWNpdCgnc3R5bGUnKTtcbiAgICAgICAgaWYgKCFzdHlsZVN0cmluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZXMgPSBuZXcgU3R5bGVzX2pzXzEuU3R5bGVzKHN0eWxlU3RyaW5nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG0gPSBDb21tb25XcmFwcGVyLnJlbW92ZVN0eWxlcy5sZW5ndGg7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IENvbW1vbldyYXBwZXIucmVtb3ZlU3R5bGVzW2ldO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmdldChpZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVtb3ZlZFN0eWxlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkU3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkU3R5bGVzW2lkXSA9IHN0eWxlLmdldChpZCk7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0KGlkLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmdldFZhcmlhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2RlLmlzVG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciB2YXJpYW50ID0gYXR0cmlidXRlcy5nZXQoJ21hdGh2YXJpYW50Jyk7XG4gICAgICAgIGlmICghYXR0cmlidXRlcy5nZXRFeHBsaWNpdCgnbWF0aHZhcmlhbnQnKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGF0dHJpYnV0ZXMuZ2V0TGlzdCgnZm9udGZhbWlseScsICdmb250d2VpZ2h0JywgJ2ZvbnRzdHlsZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlZFN0eWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMucmVtb3ZlZFN0eWxlcztcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuZm9udEZhbWlseSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmZvbnRXZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy53ZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5mb250U3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zdHlsZSA9IHN0eWxlLmZvbnRTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMuZm9udGZhbWlseSlcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZmFtaWx5ID0gdmFsdWVzLmZvbnRmYW1pbHk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmZvbnR3ZWlnaHQpXG4gICAgICAgICAgICAgICAgdmFsdWVzLndlaWdodCA9IHZhbHVlcy5mb250d2VpZ2h0O1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5mb250c3R5bGUpXG4gICAgICAgICAgICAgICAgdmFsdWVzLnN0eWxlID0gdmFsdWVzLmZvbnRzdHlsZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMud2VpZ2h0ICYmIHZhbHVlcy53ZWlnaHQubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLndlaWdodCA9IChwYXJzZUludCh2YWx1ZXMud2VpZ2h0KSA+IDYwMCA/ICdib2xkJyA6ICdub3JtYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMuZmFtaWx5KSB7XG4gICAgICAgICAgICAgICAgdmFyaWFudCA9IHRoaXMuZXhwbGljaXRWYXJpYW50KHZhbHVlcy5mYW1pbHksIHZhbHVlcy53ZWlnaHQsIHZhbHVlcy5zdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlLmdldFByb3BlcnR5KCd2YXJpYW50Rm9ybScpKVxuICAgICAgICAgICAgICAgICAgICB2YXJpYW50ID0gJy10ZXgtdmFyaWFudCc7XG4gICAgICAgICAgICAgICAgdmFyaWFudCA9IChDb21tb25XcmFwcGVyLkJPTERWQVJJQU5UU1t2YWx1ZXMud2VpZ2h0XSB8fCB7fSlbdmFyaWFudF0gfHwgdmFyaWFudDtcbiAgICAgICAgICAgICAgICB2YXJpYW50ID0gKENvbW1vbldyYXBwZXIuSVRBTElDVkFSSUFOVFNbdmFsdWVzLnN0eWxlXSB8fCB7fSlbdmFyaWFudF0gfHwgdmFyaWFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhcmlhbnQgPSB2YXJpYW50O1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuZXhwbGljaXRWYXJpYW50ID0gZnVuY3Rpb24gKGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRTdHlsZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlcztcbiAgICAgICAgaWYgKCFzdHlsZSlcbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5zdHlsZXMgPSBuZXcgU3R5bGVzX2pzXzEuU3R5bGVzKCk7XG4gICAgICAgIHN0eWxlLnNldCgnZm9udEZhbWlseScsIGZvbnRGYW1pbHkpO1xuICAgICAgICBpZiAoZm9udFdlaWdodClcbiAgICAgICAgICAgIHN0eWxlLnNldCgnZm9udFdlaWdodCcsIGZvbnRXZWlnaHQpO1xuICAgICAgICBpZiAoZm9udFN0eWxlKVxuICAgICAgICAgICAgc3R5bGUuc2V0KCdmb250U3R5bGUnLCBmb250U3R5bGUpO1xuICAgICAgICByZXR1cm4gJy1leHBsaWNpdEZvbnQnO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IDEsIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgcHNjYWxlID0gKHBhcmVudCA/IHBhcmVudC5iYm94LnNjYWxlIDogMSk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzY3JpcHRsZXZlbCA9IE1hdGgubWluKGF0dHJpYnV0ZXMuZ2V0KCdzY3JpcHRsZXZlbCcpLCAyKTtcbiAgICAgICAgdmFyIGZvbnRzaXplID0gYXR0cmlidXRlcy5nZXQoJ2ZvbnRzaXplJyk7XG4gICAgICAgIHZhciBtYXRoc2l6ZSA9ICh0aGlzLm5vZGUuaXNUb2tlbiB8fCB0aGlzLm5vZGUuaXNLaW5kKCdtc3R5bGUnKSA/XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmdldCgnbWF0aHNpemUnKSA6IGF0dHJpYnV0ZXMuZ2V0SW5oZXJpdGVkKCdtYXRoc2l6ZScpKTtcbiAgICAgICAgaWYgKHNjcmlwdGxldmVsICE9PSAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IE1hdGgucG93KGF0dHJpYnV0ZXMuZ2V0KCdzY3JpcHRzaXplbXVsdGlwbGllcicpLCBzY3JpcHRsZXZlbCk7XG4gICAgICAgICAgICB2YXIgc2NyaXB0bWluc2l6ZSA9IHRoaXMubGVuZ3RoMmVtKGF0dHJpYnV0ZXMuZ2V0KCdzY3JpcHRtaW5zaXplJyksIC44LCAxKTtcbiAgICAgICAgICAgIGlmIChzY2FsZSA8IHNjcmlwdG1pbnNpemUpXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBzY3JpcHRtaW5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZWRTdHlsZXMgJiYgdGhpcy5yZW1vdmVkU3R5bGVzLmZvbnRTaXplICYmICFmb250c2l6ZSkge1xuICAgICAgICAgICAgZm9udHNpemUgPSB0aGlzLnJlbW92ZWRTdHlsZXMuZm9udFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRzaXplICYmICFhdHRyaWJ1dGVzLmdldEV4cGxpY2l0KCdtYXRoc2l6ZScpKSB7XG4gICAgICAgICAgICBtYXRoc2l6ZSA9IGZvbnRzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRoc2l6ZSAhPT0gJzEnKSB7XG4gICAgICAgICAgICBzY2FsZSAqPSB0aGlzLmxlbmd0aDJlbShtYXRoc2l6ZSwgMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYm94LnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuYmJveC5yc2NhbGUgPSBzY2FsZSAvIHBzY2FsZTtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmdldFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNUb3AgPSB0aGlzLmlzVG9wRW1iZWxsaXNoZWQoKTtcbiAgICAgICAgdmFyIGhhc1NwYWNpbmcgPSB0aGlzLm5vZGUuaGFzU3BhY2luZ0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuamF4Lm9wdGlvbnMubWF0aG1sU3BhY2luZyB8fCBoYXNTcGFjaW5nKSB7XG4gICAgICAgICAgICBpc1RvcCAmJiB0aGlzLmdldE1hdGhNTFNwYWNpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VGVYU3BhY2luZyhpc1RvcCwgaGFzU3BhY2luZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmdldE1hdGhNTFNwYWNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLmNvcmVNTygpO1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNvcmVQYXJlbnQoKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5pc0tpbmQoJ21yb3cnKSB8fCBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgaXNTY3JpcHQgPSAoYXR0cmlidXRlcy5nZXQoJ3NjcmlwdGxldmVsJykgPiAwKTtcbiAgICAgICAgdGhpcy5iYm94LkwgPSAoYXR0cmlidXRlcy5pc1NldCgnbHNwYWNlJykgP1xuICAgICAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgyZW0oYXR0cmlidXRlcy5nZXQoJ2xzcGFjZScpKSkgOlxuICAgICAgICAgICAgTWF0aE1MU3BhY2UoaXNTY3JpcHQsIG5vZGUubHNwYWNlKSk7XG4gICAgICAgIHRoaXMuYmJveC5SID0gKGF0dHJpYnV0ZXMuaXNTZXQoJ3JzcGFjZScpID9cbiAgICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoMmVtKGF0dHJpYnV0ZXMuZ2V0KCdyc3BhY2UnKSkpIDpcbiAgICAgICAgICAgIE1hdGhNTFNwYWNlKGlzU2NyaXB0LCBub2RlLnJzcGFjZSkpO1xuICAgICAgICB2YXIgbiA9IHBhcmVudC5jaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwcmV2ID0gcGFyZW50LmNoaWxkTm9kZXNbbiAtIDFdO1xuICAgICAgICBpZiAoIXByZXYuaXNFbWJlbGxpc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmpheC5ub2RlTWFwLmdldChwcmV2KS5nZXRCQm94KCk7XG4gICAgICAgIGlmIChiYm94LlIpIHtcbiAgICAgICAgICAgIHRoaXMuYmJveC5MID0gTWF0aC5tYXgoMCwgdGhpcy5iYm94LkwgLSBiYm94LlIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5nZXRUZVhTcGFjaW5nID0gZnVuY3Rpb24gKGlzVG9wLCBoYXNTcGFjaW5nKSB7XG4gICAgICAgIGlmICghaGFzU3BhY2luZykge1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gdGhpcy5ub2RlLnRleFNwYWNpbmcoKTtcbiAgICAgICAgICAgIGlmIChzcGFjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmJveC5MID0gdGhpcy5sZW5ndGgyZW0oc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RvcCB8fCBoYXNTcGFjaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5jb3JlTU8oKS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaXNTZXQoJ2xzcGFjZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYm94LkwgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aDJlbShhdHRyaWJ1dGVzLmdldCgnbHNwYWNlJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmlzU2V0KCdyc3BhY2UnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmJveC5SID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgyZW0oYXR0cmlidXRlcy5nZXQoJ3JzcGFjZScpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmlzVG9wRW1iZWxsaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ub2RlLmlzRW1iZWxsaXNoZWQgJiZcbiAgICAgICAgICAgICEodGhpcy5ub2RlLnBhcmVudCAmJiB0aGlzLm5vZGUucGFyZW50LmlzRW1iZWxsaXNoZWQpKTtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmNvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpheC5ub2RlTWFwLmdldCh0aGlzLm5vZGUuY29yZSgpKTtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmNvcmVNTyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuamF4Lm5vZGVNYXAuZ2V0KHRoaXMubm9kZS5jb3JlTU8oKSk7XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV80LCBfYTtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1Rva2VuKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5ub2RlLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBNbWxOb2RlX2pzXzEuVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gY2hpbGQuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuY2FuU3RyZXRjaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zdHJldGNoID0gRm9udERhdGFfanNfMS5OT1NUUkVUQ0g7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNFbWJlbGxpc2hlZCkge1xuICAgICAgICAgICAgdmFyIGNvcmUgPSB0aGlzLmNvcmUoKTtcbiAgICAgICAgICAgIGlmIChjb3JlICYmIGNvcmUubm9kZSAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvcmUuY2FuU3RyZXRjaChkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZXRjaCA9IGNvcmUuc3RyZXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZXRjaC5kaXIgIT09IDA7XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5nZXRBbGlnblNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IChfYSA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzKS5nZXRMaXN0LmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoTW1sTm9kZV9qc18xLmluZGVudEF0dHJpYnV0ZXMpLCBmYWxzZSkpLCBpbmRlbnRhbGlnbiA9IF9iLmluZGVudGFsaWduLCBpbmRlbnRzaGlmdCA9IF9iLmluZGVudHNoaWZ0LCBpbmRlbnRhbGlnbmZpcnN0ID0gX2IuaW5kZW50YWxpZ25maXJzdCwgaW5kZW50c2hpZnRmaXJzdCA9IF9iLmluZGVudHNoaWZ0Zmlyc3Q7XG4gICAgICAgIGlmIChpbmRlbnRhbGlnbmZpcnN0ICE9PSAnaW5kZW50YWxpZ24nKSB7XG4gICAgICAgICAgICBpbmRlbnRhbGlnbiA9IGluZGVudGFsaWduZmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudGFsaWduID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGluZGVudGFsaWduID0gdGhpcy5qYXgub3B0aW9ucy5kaXNwbGF5QWxpZ247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudHNoaWZ0Zmlyc3QgIT09ICdpbmRlbnRzaGlmdCcpIHtcbiAgICAgICAgICAgIGluZGVudHNoaWZ0ID0gaW5kZW50c2hpZnRmaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZW50c2hpZnQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgaW5kZW50c2hpZnQgPSB0aGlzLmpheC5vcHRpb25zLmRpc3BsYXlJbmRlbnQ7XG4gICAgICAgICAgICBpZiAoaW5kZW50YWxpZ24gPT09ICdyaWdodCcgJiYgIWluZGVudHNoaWZ0Lm1hdGNoKC9eXFxzKjBbYS16XSpcXHMqJC8pKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50c2hpZnQgPSAoJy0nICsgaW5kZW50c2hpZnQudHJpbSgpKS5yZXBsYWNlKC9eLS0vLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGgyZW0oaW5kZW50c2hpZnQsIHRoaXMubWV0cmljcy5jb250YWluZXJXaWR0aCk7XG4gICAgICAgIHJldHVybiBbaW5kZW50YWxpZ24sIHNoaWZ0XTtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmdldEFsaWduWCA9IGZ1bmN0aW9uIChXLCBiYm94LCBhbGlnbikge1xuICAgICAgICByZXR1cm4gKGFsaWduID09PSAncmlnaHQnID8gVyAtIChiYm94LncgKyBiYm94LlIpICogYmJveC5yc2NhbGUgOlxuICAgICAgICAgICAgYWxpZ24gPT09ICdsZWZ0JyA/IGJib3guTCAqIGJib3gucnNjYWxlIDpcbiAgICAgICAgICAgICAgICAoVyAtIGJib3gudyAqIGJib3gucnNjYWxlKSAvIDIpO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuZ2V0QWxpZ25ZID0gZnVuY3Rpb24gKEgsIEQsIGgsIGQsIGFsaWduKSB7XG4gICAgICAgIHJldHVybiAoYWxpZ24gPT09ICd0b3AnID8gSCAtIGggOlxuICAgICAgICAgICAgYWxpZ24gPT09ICdib3R0b20nID8gZCAtIEQgOlxuICAgICAgICAgICAgICAgIGFsaWduID09PSAnY2VudGVyJyA/ICgoSCAtIGgpIC0gKEQgLSBkKSkgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgMCk7XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5nZXRXcmFwV2lkdGggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzW2ldLmdldEJCb3goKS53O1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2hpbGRBbGlnbiA9IGZ1bmN0aW9uIChfaSkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUucGVyY2VudCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBMRU5HVEhTLnBlcmNlbnQobSk7XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBMRU5HVEhTLmVtKG0pO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUucHggPSBmdW5jdGlvbiAobSwgTSkge1xuICAgICAgICBpZiAoTSA9PT0gdm9pZCAwKSB7IE0gPSAtTEVOR1RIUy5CSUdESU1FTjsgfVxuICAgICAgICByZXR1cm4gTEVOR1RIUy5weChtLCBNLCB0aGlzLm1ldHJpY3MuZW0pO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUubGVuZ3RoMmVtID0gZnVuY3Rpb24gKGxlbmd0aCwgc2l6ZSwgc2NhbGUpIHtcbiAgICAgICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMTsgfVxuICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKHNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHRoaXMuYmJveC5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEVOR1RIUy5sZW5ndGgyZW0obGVuZ3RoLCBzaXplLCBzY2FsZSwgdGhpcy5qYXgucHhQZXJFbSk7XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS51bmljb2RlQ2hhcnMgPSBmdW5jdGlvbiAodGV4dCwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSB0aGlzLnZhcmlhbnQ7IH1cbiAgICAgICAgdmFyIGNoYXJzID0gKDAsIHN0cmluZ19qc18xLnVuaWNvZGVDaGFycykodGV4dCk7XG4gICAgICAgIHZhciB2YXJpYW50ID0gdGhpcy5mb250LmdldFZhcmlhbnQobmFtZSk7XG4gICAgICAgIGlmICh2YXJpYW50ICYmIHZhcmlhbnQuY2hhcnMpIHtcbiAgICAgICAgICAgIHZhciBtYXBfMSA9IHZhcmlhbnQuY2hhcnM7XG4gICAgICAgICAgICBjaGFycyA9IGNoYXJzLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gKChtYXBfMVtuXSB8fCBbXSlbM10gfHwge30pLnNtcCB8fCBuOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLnByb3RvdHlwZS5yZW1hcENoYXJzID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIHJldHVybiBjaGFycztcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLm1tbFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmZhY3RvcnkuY3JlYXRlKCd0ZXh0Jykuc2V0VGV4dCh0ZXh0KTtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLm1tbE5vZGUgPSBmdW5jdGlvbiAoa2luZCwgcHJvcGVydGllcywgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMgPT09IHZvaWQgMCkgeyBwcm9wZXJ0aWVzID0ge307IH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmZhY3RvcnkuY3JlYXRlKGtpbmQsIHByb3BlcnRpZXMsIGNoaWxkcmVuKTtcbiAgICB9O1xuICAgIENvbW1vbldyYXBwZXIucHJvdG90eXBlLmNyZWF0ZU1vID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIG1tbEZhY3RvcnkgPSB0aGlzLm5vZGUuZmFjdG9yeTtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbW1sRmFjdG9yeS5jcmVhdGUoJ3RleHQnKS5zZXRUZXh0KHRleHQpO1xuICAgICAgICB2YXIgbW1sID0gbW1sRmFjdG9yeS5jcmVhdGUoJ21vJywgeyBzdHJldGNoeTogdHJ1ZSB9LCBbdGV4dE5vZGVdKTtcbiAgICAgICAgbW1sLmluaGVyaXRBdHRyaWJ1dGVzRnJvbSh0aGlzLm5vZGUpO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMud3JhcChtbWwpO1xuICAgICAgICBub2RlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5wcm90b3R5cGUuZ2V0VmFyaWFudENoYXIgPSBmdW5jdGlvbiAodmFyaWFudCwgbikge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuZm9udC5nZXRDaGFyKHZhcmlhbnQsIG4pIHx8IFswLCAwLCAwLCB7IHVua25vd246IHRydWUgfV07XG4gICAgICAgIGlmIChjaGFyLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgY2hhclszXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyO1xuICAgIH07XG4gICAgQ29tbW9uV3JhcHBlci5raW5kID0gJ3Vua25vd24nO1xuICAgIENvbW1vbldyYXBwZXIuc3R5bGVzID0ge307XG4gICAgQ29tbW9uV3JhcHBlci5yZW1vdmVTdHlsZXMgPSBbXG4gICAgICAgICdmb250U2l6ZScsICdmb250RmFtaWx5JywgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgJ2ZvbnQnXG4gICAgXTtcbiAgICBDb21tb25XcmFwcGVyLnNraXBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBmb250ZmFtaWx5OiB0cnVlLCBmb250c2l6ZTogdHJ1ZSwgZm9udHdlaWdodDogdHJ1ZSwgZm9udHN0eWxlOiB0cnVlLFxuICAgICAgICBjb2xvcjogdHJ1ZSwgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgJ2NsYXNzJzogdHJ1ZSwgaHJlZjogdHJ1ZSwgc3R5bGU6IHRydWUsXG4gICAgICAgIHhtbG5zOiB0cnVlXG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLkJPTERWQVJJQU5UUyA9IHtcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgICAgbm9ybWFsOiAnYm9sZCcsXG4gICAgICAgICAgICBpdGFsaWM6ICdib2xkLWl0YWxpYycsXG4gICAgICAgICAgICBmcmFrdHVyOiAnYm9sZC1mcmFrdHVyJyxcbiAgICAgICAgICAgIHNjcmlwdDogJ2JvbGQtc2NyaXB0JyxcbiAgICAgICAgICAgICdzYW5zLXNlcmlmJzogJ2JvbGQtc2Fucy1zZXJpZicsXG4gICAgICAgICAgICAnc2Fucy1zZXJpZi1pdGFsaWMnOiAnc2Fucy1zZXJpZi1ib2xkLWl0YWxpYydcbiAgICAgICAgfSxcbiAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICBib2xkOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICdib2xkLWl0YWxpYyc6ICdpdGFsaWMnLFxuICAgICAgICAgICAgJ2JvbGQtZnJha3R1cic6ICdmcmFrdHVyJyxcbiAgICAgICAgICAgICdib2xkLXNjcmlwdCc6ICdzY3JpcHQnLFxuICAgICAgICAgICAgJ2JvbGQtc2Fucy1zZXJpZic6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgICdzYW5zLXNlcmlmLWJvbGQtaXRhbGljJzogJ3NhbnMtc2VyaWYtaXRhbGljJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tb25XcmFwcGVyLklUQUxJQ1ZBUklBTlRTID0ge1xuICAgICAgICBpdGFsaWM6IHtcbiAgICAgICAgICAgIG5vcm1hbDogJ2l0YWxpYycsXG4gICAgICAgICAgICBib2xkOiAnYm9sZC1pdGFsaWMnLFxuICAgICAgICAgICAgJ3NhbnMtc2VyaWYnOiAnc2Fucy1zZXJpZi1pdGFsaWMnLFxuICAgICAgICAgICAgJ2JvbGQtc2Fucy1zZXJpZic6ICdzYW5zLXNlcmlmLWJvbGQtaXRhbGljJ1xuICAgICAgICB9LFxuICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgIGl0YWxpYzogJ25vcm1hbCcsXG4gICAgICAgICAgICAnYm9sZC1pdGFsaWMnOiAnYm9sZCcsXG4gICAgICAgICAgICAnc2Fucy1zZXJpZi1pdGFsaWMnOiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICAnc2Fucy1zZXJpZi1ib2xkLWl0YWxpYyc6ICdib2xkLXNhbnMtc2VyaWYnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21tb25XcmFwcGVyO1xufShXcmFwcGVyX2pzXzEuQWJzdHJhY3RXcmFwcGVyKSk7XG5leHBvcnRzLkNvbW1vbldyYXBwZXIgPSBDb21tb25XcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V3JhcHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbldyYXBwZXJGYWN0b3J5ID0gdm9pZCAwO1xudmFyIFdyYXBwZXJGYWN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9UcmVlL1dyYXBwZXJGYWN0b3J5LmpzXCIpO1xudmFyIENvbW1vbldyYXBwZXJGYWN0b3J5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbW9uV3JhcHBlckZhY3RvcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tbW9uV3JhcHBlckZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5qYXggPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tb25XcmFwcGVyRmFjdG9yeS5wcm90b3R5cGUsIFwiV3JhcHBlcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb21tb25XcmFwcGVyRmFjdG9yeS5kZWZhdWx0Tm9kZXMgPSB7fTtcbiAgICByZXR1cm4gQ29tbW9uV3JhcHBlckZhY3Rvcnk7XG59KFdyYXBwZXJGYWN0b3J5X2pzXzEuQWJzdHJhY3RXcmFwcGVyRmFjdG9yeSkpO1xuZXhwb3J0cy5Db21tb25XcmFwcGVyRmFjdG9yeSA9IENvbW1vbldyYXBwZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V3JhcHBlckZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25UZVhBdG9tTWl4aW4gPSB2b2lkIDA7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xuZnVuY3Rpb24gQ29tbW9uVGVYQXRvbU1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY29tcHV0ZUJCb3ggPSBmdW5jdGlvbiAoYmJveCwgcmVjb21wdXRlKSB7XG4gICAgICAgICAgICBpZiAocmVjb21wdXRlID09PSB2b2lkIDApIHsgcmVjb21wdXRlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuY29tcHV0ZUJCb3guY2FsbCh0aGlzLCBiYm94LCByZWNvbXB1dGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGROb2Rlc1swXSAmJiB0aGlzLmNoaWxkTm9kZXNbMF0uYmJveC5pYykge1xuICAgICAgICAgICAgICAgIGJib3guaWMgPSB0aGlzLmNoaWxkTm9kZXNbMF0uYmJveC5pYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUudGV4Q2xhc3MgPT09IE1tbE5vZGVfanNfMS5URVhDTEFTUy5WQ0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBiYm94LmgsIGQgPSBiYm94LmQ7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmZvbnQucGFyYW1zLmF4aXNfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBkaCA9ICgoaCArIGQpIC8gMiArIGEpIC0gaDtcbiAgICAgICAgICAgICAgICBiYm94LmggKz0gZGg7XG4gICAgICAgICAgICAgICAgYmJveC5kIC09IGRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uVGVYQXRvbU1peGluID0gQ29tbW9uVGVYQXRvbU1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGVYQXRvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vblRleHROb2RlTWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25UZXh0Tm9kZU1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY29tcHV0ZUJCb3ggPSBmdW5jdGlvbiAoYmJveCwgX3JlY29tcHV0ZSkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBpZiAoX3JlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IF9yZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHZhcmlhbnQgPSB0aGlzLnBhcmVudC52YXJpYW50O1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLm5vZGUuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgaWYgKHZhcmlhbnQgPT09ICctZXhwbGljaXRGb250Jykge1xuICAgICAgICAgICAgICAgIHZhciBmb250ID0gdGhpcy5qYXguZ2V0Rm9udERhdGEodGhpcy5wYXJlbnQuc3R5bGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSB0aGlzLmpheC5tZWFzdXJlVGV4dCh0ZXh0LCB2YXJpYW50LCBmb250KSwgdyA9IF9iLncsIGggPSBfYi5oLCBkID0gX2IuZDtcbiAgICAgICAgICAgICAgICBiYm94LmggPSBoO1xuICAgICAgICAgICAgICAgIGJib3guZCA9IGQ7XG4gICAgICAgICAgICAgICAgYmJveC53ID0gdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGFycyA9IHRoaXMucmVtYXBwZWRUZXh0KHRleHQsIHZhcmlhbnQpO1xuICAgICAgICAgICAgICAgIGJib3guZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyc18xID0gX192YWx1ZXMoY2hhcnMpLCBjaGFyc18xXzEgPSBjaGFyc18xLm5leHQoKTsgIWNoYXJzXzFfMS5kb25lOyBjaGFyc18xXzEgPSBjaGFyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBjaGFyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBfX3JlYWQodGhpcy5nZXRWYXJpYW50Q2hhcih2YXJpYW50LCBjaGFyKSwgNCksIGggPSBfY1swXSwgZCA9IF9jWzFdLCB3ID0gX2NbMl0sIGRhdGEgPSBfY1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2JveCA9IHRoaXMuamF4Lm1lYXN1cmVUZXh0KFN0cmluZy5mcm9tQ29kZVBvaW50KGNoYXIpLCB2YXJpYW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ID0gY2JveC53O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBjYm94Lmg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGNib3guZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3gudyArPSB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPiBiYm94LmgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5oID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID4gYmJveC5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmljID0gZGF0YS5pYyB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5zayA9IGRhdGEuc2sgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZHggPSBkYXRhLmR4IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyc18xXzEgJiYgIWNoYXJzXzFfMS5kb25lICYmIChfYSA9IGNoYXJzXzEucmV0dXJuKSkgX2EuY2FsbChjaGFyc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJib3guc2sgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYm94LmNsZWFuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnJlbWFwcGVkVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB2YXJpYW50KSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMucGFyZW50LnN0cmV0Y2guYztcbiAgICAgICAgICAgIHJldHVybiAoYyA/IFtjXSA6IHRoaXMucGFyZW50LnJlbWFwQ2hhcnModGhpcy51bmljb2RlQ2hhcnModGV4dCwgdmFyaWFudCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRWYXJpYW50ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0U3BhY2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25UZXh0Tm9kZU1peGluID0gQ29tbW9uVGV4dE5vZGVNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHROb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTWFjdGlvbk1peGluID0gZXhwb3J0cy5Ub29sdGlwRGF0YSA9IHZvaWQgMDtcbnZhciBzdHJpbmdfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL3N0cmluZy5qc1wiKTtcbmV4cG9ydHMuVG9vbHRpcERhdGEgPSB7XG4gICAgZHg6ICcuMmVtJyxcbiAgICBkeTogJy4xZW0nLFxuICAgIHBvc3REZWxheTogNjAwLFxuICAgIGNsZWFyRGVsYXk6IDEwMCxcbiAgICBob3ZlclRpbWVyOiBuZXcgTWFwKCksXG4gICAgY2xlYXJUaW1lcjogbmV3IE1hcCgpLFxuICAgIHN0b3BUaW1lcnM6IGZ1bmN0aW9uIChub2RlLCBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmNsZWFyVGltZXIuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGF0YS5jbGVhclRpbWVyLmdldChub2RlKSk7XG4gICAgICAgICAgICBkYXRhLmNsZWFyVGltZXIuZGVsZXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmhvdmVyVGltZXIuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGF0YS5ob3ZlclRpbWVyLmdldChub2RlKSk7XG4gICAgICAgICAgICBkYXRhLmhvdmVyVGltZXIuZGVsZXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIENvbW1vbk1hY3Rpb25NaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5hY3Rpb25zO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF90aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2FjdGlvbnR5cGUnKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChhY3Rpb25zLmdldChhY3Rpb24pIHx8IFsoZnVuY3Rpb24gKF9ub2RlLCBfZGF0YSkgeyB9KSwge31dLCAyKSwgaGFuZGxlciA9IF9hWzBdLCBkYXRhID0gX2FbMV07XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb24gPSBoYW5kbGVyO1xuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBfdGhpcy5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3NlbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gTWF0aC5tYXgoMSwgTWF0aC5taW4odGhpcy5jaGlsZE5vZGVzLmxlbmd0aCwgc2VsZWN0aW9uKSkgLSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXNbaV0gfHwgdGhpcy53cmFwKHRoaXMubm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnZGF0YS1vZmZzZXRzJyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoKDAsIHN0cmluZ19qc18xLnNwbGl0KShvZmZzZXRzIHx8ICcnKSwgMiksIGR4ID0gX2FbMF0sIGR5ID0gX2FbMV07XG4gICAgICAgICAgICB0aGlzLmR4ID0gdGhpcy5sZW5ndGgyZW0oZHggfHwgZXhwb3J0cy5Ub29sdGlwRGF0YS5keCk7XG4gICAgICAgICAgICB0aGlzLmR5ID0gdGhpcy5sZW5ndGgyZW0oZHkgfHwgZXhwb3J0cy5Ub29sdGlwRGF0YS5keSk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHJlY29tcHV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IHJlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBiYm94LnVwZGF0ZUZyb20odGhpcy5zZWxlY3RlZC5nZXRPdXRlckJCb3goKSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnNldENoaWxkUFdpZHRocyhyZWNvbXB1dGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uTWFjdGlvbk1peGluID0gQ29tbW9uTWFjdGlvbk1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk1hdGhNaXhpbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIENvbW1vbk1hdGhNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFdyYXBXaWR0aCA9IGZ1bmN0aW9uIChfaSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnBhcmVudCA/IHRoaXMuZ2V0QkJveCgpLncgOiB0aGlzLm1ldHJpY3MuY29udGFpbmVyV2lkdGggLyB0aGlzLmpheC5weFBlckVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk1hdGhNaXhpbiA9IENvbW1vbk1hdGhNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk1lbmNsb3NlTWl4aW4gPSB2b2lkIDA7XG52YXIgTm90YXRpb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL05vdGF0aW9uLmpzXCIpKTtcbnZhciBzdHJpbmdfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL3N0cmluZy5qc1wiKTtcbmZ1bmN0aW9uIENvbW1vbk1lbmNsb3NlTWl4aW4oQmFzZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLm5vdGF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMubXNxcnQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucGFkZGluZyA9IE5vdGF0aW9uLlBBRERJTkc7XG4gICAgICAgICAgICBfdGhpcy50aGlja25lc3MgPSBOb3RhdGlvbi5USElDS05FU1M7XG4gICAgICAgICAgICBfdGhpcy5hcnJvd2hlYWQgPSB7IHg6IE5vdGF0aW9uLkFSUk9XWCwgeTogTm90YXRpb24uQVJST1dZLCBkeDogTm90YXRpb24uQVJST1dEWCB9O1xuICAgICAgICAgICAgX3RoaXMuVFJCTCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIF90aGlzLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIF90aGlzLmdldE5vdGF0aW9ucygpO1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlUmVkdW5kYW50Tm90YXRpb25zKCk7XG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsaXplTm90YXRpb25zKCk7XG4gICAgICAgICAgICBfdGhpcy5UUkJMID0gX3RoaXMuZ2V0QkJveEV4dGVuZGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBhdHRyaWJ1dGVzLmdldCgnZGF0YS1wYWRkaW5nJyk7XG4gICAgICAgICAgICBpZiAocGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gdGhpcy5sZW5ndGgyZW0ocGFkZGluZywgTm90YXRpb24uUEFERElORyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gYXR0cmlidXRlcy5nZXQoJ2RhdGEtdGhpY2tuZXNzJyk7XG4gICAgICAgICAgICBpZiAodGhpY2tuZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHRoaXMubGVuZ3RoMmVtKHRoaWNrbmVzcywgTm90YXRpb24uVEhJQ0tORVNTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcnJvd2hlYWQgPSBhdHRyaWJ1dGVzLmdldCgnZGF0YS1hcnJvd2hlYWQnKTtcbiAgICAgICAgICAgIGlmIChhcnJvd2hlYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZCgoMCwgc3RyaW5nX2pzXzEuc3BsaXQpKGFycm93aGVhZCksIDMpLCB4ID0gX2JbMF0sIHkgPSBfYlsxXSwgZHggPSBfYlsyXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFycm93aGVhZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogKHggPyBwYXJzZUZsb2F0KHgpIDogTm90YXRpb24uQVJST1dYKSxcbiAgICAgICAgICAgICAgICAgICAgeTogKHkgPyBwYXJzZUZsb2F0KHkpIDogTm90YXRpb24uQVJST1dZKSxcbiAgICAgICAgICAgICAgICAgICAgZHg6IChkeCA/IHBhcnNlRmxvYXQoZHgpIDogTm90YXRpb24uQVJST1dEWClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXROb3RhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYjtcbiAgICAgICAgICAgIHZhciBOb3RhdGlvbnMgPSB0aGlzLmNvbnN0cnVjdG9yLm5vdGF0aW9ucztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcygoMCwgc3RyaW5nX2pzXzEuc3BsaXQpKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnbm90YXRpb24nKSkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGF0aW9uID0gTm90YXRpb25zLmdldChuYW1lXzEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YXRpb25zW25hbWVfMV0gPSBub3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RhdGlvbi5yZW5kZXJDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGQgPSBub3RhdGlvbi5yZW5kZXJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9iID0gX2MucmV0dXJuKSkgX2IuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUucmVtb3ZlUmVkdW5kYW50Tm90YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMiwgX2IsIGVfMywgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gX192YWx1ZXMoT2JqZWN0LmtleXModGhpcy5ub3RhdGlvbnMpKSwgX2UgPSBfZC5uZXh0KCk7ICFfZS5kb25lOyBfZSA9IF9kLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gX2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vdGF0aW9uc1tuYW1lXzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlID0gdGhpcy5ub3RhdGlvbnNbbmFtZV8yXS5yZW1vdmUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gKGVfMyA9IHZvaWQgMCwgX192YWx1ZXMocmVtb3ZlLnNwbGl0KC8gLykpKSwgX2cgPSBfZi5uZXh0KCk7ICFfZy5kb25lOyBfZyA9IF9mLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90YXRpb24gPSBfZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubm90YXRpb25zW25vdGF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYyA9IF9mLnJldHVybikpIF9jLmNhbGwoX2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9lICYmICFfZS5kb25lICYmIChfYiA9IF9kLnJldHVybikpIF9iLmNhbGwoX2QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmluaXRpYWxpemVOb3RhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZV80LCBfYjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLm5vdGF0aW9ucykpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzMgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLm5vdGF0aW9uc1tuYW1lXzNdLmluaXQ7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgJiYgaW5pdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jLnJldHVybikpIF9iLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHJlY29tcHV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IHJlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQodGhpcy5UUkJMLCA0KSwgVCA9IF9iWzBdLCBSID0gX2JbMV0sIEIgPSBfYlsyXSwgTCA9IF9iWzNdO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZE5vZGVzWzBdLmdldEJCb3goKTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShjaGlsZCwgTCwgMCk7XG4gICAgICAgICAgICBiYm94LmggKz0gVDtcbiAgICAgICAgICAgIGJib3guZCArPSBCO1xuICAgICAgICAgICAgYmJveC53ICs9IFI7XG4gICAgICAgICAgICB0aGlzLnNldENoaWxkUFdpZHRocyhyZWNvbXB1dGUpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRCQm94RXh0ZW5kZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfNSwgX2I7XG4gICAgICAgICAgICB2YXIgVFJCTCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLm5vdGF0aW9ucykpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzQgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZUVudHJpZXMoVFJCTCwgdGhpcy5ub3RhdGlvbnNbbmFtZV80XS5iYm94KHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jLnJldHVybikpIF9iLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVFJCTDtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzYsIF9iO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBCVFJCTCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLm5vdGF0aW9ucykpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzUgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlciA9IHRoaXMubm90YXRpb25zW25hbWVfNV0uYm9yZGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heGltaXplRW50cmllcyhCVFJCTCwgYm9yZGVyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9iID0gX2MucmV0dXJuKSkgX2IuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMCwgMSwgMiwgM10ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBfdGhpcy5UUkJMW2ldIC0gQlRSQkxbaV07IH0pO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5tYXhpbWl6ZUVudHJpZXMgPSBmdW5jdGlvbiAoWCwgWSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBYLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFhbaV0gPCBZW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIFhbaV0gPSBZW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHRoaXMuVFJCTCwgNCksIFQgPSBfYlswXSwgUiA9IF9iWzFdLCBCID0gX2JbMl0sIEwgPSBfYlszXTtcbiAgICAgICAgICAgIHZhciBkID0gKGRpcmVjdGlvbiA9PT0gJ1gnID8gUiAtIEwgOiBCIC0gVCkgLyAyO1xuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyhkKSA+IC4wMDEgPyBkIDogMCk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEFyZ01vZCA9IGZ1bmN0aW9uICh3LCBoKSB7XG4gICAgICAgICAgICByZXR1cm4gW01hdGguYXRhbjIoaCwgdyksIE1hdGguc3FydCh3ICogdyArIGggKiBoKV07XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFycm93ID0gZnVuY3Rpb24gKF93LCBfYSwgX2RvdWJsZSwgX29mZnNldCwgX2Rpc3QpIHtcbiAgICAgICAgICAgIGlmIChfb2Zmc2V0ID09PSB2b2lkIDApIHsgX29mZnNldCA9ICcnOyB9XG4gICAgICAgICAgICBpZiAoX2Rpc3QgPT09IHZvaWQgMCkgeyBfZGlzdCA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5hcnJvd0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoW3RoaXMucGFkZGluZywgdGhpcy50aGlja25lc3NdLCAyKSwgcCA9IF9iWzBdLCB0ID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgciA9IHQgKiAodGhpcy5hcnJvd2hlYWQueCArIE1hdGgubWF4KDEsIHRoaXMuYXJyb3doZWFkLmR4KSk7XG4gICAgICAgICAgICB2YXIgX2MgPSB0aGlzLmNoaWxkTm9kZXNbMF0uZ2V0QkJveCgpLCBoID0gX2MuaCwgZCA9IF9jLmQsIHcgPSBfYy53O1xuICAgICAgICAgICAgdmFyIEggPSBoICsgZDtcbiAgICAgICAgICAgIHZhciBSID0gTWF0aC5zcXJ0KEggKiBIICsgdyAqIHcpO1xuICAgICAgICAgICAgdmFyIHggPSBNYXRoLm1heChwLCByICogdyAvIFIpO1xuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLm1heChwLCByICogSCAvIFIpO1xuICAgICAgICAgICAgdmFyIF9kID0gX19yZWFkKHRoaXMuZ2V0QXJnTW9kKHcgKyAyICogeCwgSCArIDIgKiB5KSwgMiksIGEgPSBfZFswXSwgVyA9IF9kWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogYSwgVzogVywgeDogeCwgeTogeSB9O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5hcnJvd0FXID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5jaGlsZE5vZGVzWzBdLmdldEJCb3goKSwgaCA9IF9iLmgsIGQgPSBfYi5kLCB3ID0gX2IudztcbiAgICAgICAgICAgIHZhciBfYyA9IF9fcmVhZCh0aGlzLlRSQkwsIDQpLCBUID0gX2NbMF0sIFIgPSBfY1sxXSwgQiA9IF9jWzJdLCBMID0gX2NbM107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBcmdNb2QoTCArIHcgKyBSLCBUICsgaCArIGQgKyBCKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY3JlYXRlTXNxcnQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBtbWxGYWN0b3J5ID0gdGhpcy5ub2RlLmZhY3Rvcnk7XG4gICAgICAgICAgICB2YXIgbW1sID0gbW1sRmFjdG9yeS5jcmVhdGUoJ21zcXJ0Jyk7XG4gICAgICAgICAgICBtbWwuaW5oZXJpdEF0dHJpYnV0ZXNGcm9tKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBtbWwuY2hpbGROb2Rlc1swXSA9IGNoaWxkLm5vZGU7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMud3JhcChtbWwpO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNxcnRUUkJMID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLm1zcXJ0LmdldEJCb3goKTtcbiAgICAgICAgICAgIHZhciBjYm94ID0gdGhpcy5tc3FydC5jaGlsZE5vZGVzWzBdLmdldEJCb3goKTtcbiAgICAgICAgICAgIHJldHVybiBbYmJveC5oIC0gY2JveC5oLCAwLCBiYm94LmQgLSBjYm94LmQsIGJib3gudyAtIGNib3gud107XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NZW5jbG9zZU1peGluID0gQ29tbW9uTWVuY2xvc2VNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbmNsb3NlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTWZlbmNlZE1peGluID0gdm9pZCAwO1xuZnVuY3Rpb24gQ29tbW9uTWZlbmNlZE1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5tcm93ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmNyZWF0ZU1yb3coKTtcbiAgICAgICAgICAgIF90aGlzLmFkZE1yb3dDaGlsZHJlbigpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNyZWF0ZU1yb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW1sRmFjdG9yeSA9IHRoaXMubm9kZS5mYWN0b3J5O1xuICAgICAgICAgICAgdmFyIG1yb3cgPSBtbWxGYWN0b3J5LmNyZWF0ZSgnaW5mZXJyZWRNcm93Jyk7XG4gICAgICAgICAgICBtcm93LmluaGVyaXRBdHRyaWJ1dGVzRnJvbSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgdGhpcy5tcm93ID0gdGhpcy53cmFwKG1yb3cpO1xuICAgICAgICAgICAgdGhpcy5tcm93LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFkZE1yb3dDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdmFyIG1mZW5jZWQgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICB2YXIgbXJvdyA9IHRoaXMubXJvdztcbiAgICAgICAgICAgIHRoaXMuYWRkTW8obWZlbmNlZC5vcGVuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbXJvdy5jaGlsZE5vZGVzLnB1c2godGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMuc2xpY2UoMSkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1vKG1mZW5jZWQuc2VwYXJhdG9yc1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgbXJvdy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkTW8obWZlbmNlZC5jbG9zZSk7XG4gICAgICAgICAgICBtcm93LnN0cmV0Y2hDaGlsZHJlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5hZGRNbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG1vID0gdGhpcy53cmFwKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5tcm93LmNoaWxkTm9kZXMucHVzaChtbyk7XG4gICAgICAgICAgICBtby5wYXJlbnQgPSB0aGlzLm1yb3c7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHJlY29tcHV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IHJlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBiYm94LnVwZGF0ZUZyb20odGhpcy5tcm93LmdldE91dGVyQkJveCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2hpbGRQV2lkdGhzKHJlY29tcHV0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NZmVuY2VkTWl4aW4gPSBDb21tb25NZmVuY2VkTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZmVuY2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTWZyYWNNaXhpbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIENvbW1vbk1mcmFjTWl4aW4oQmFzZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmJldmVsID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnBhZCA9IChfdGhpcy5ub2RlLmdldFByb3BlcnR5KCd3aXRoRGVsaW1zJykgPyAwIDogX3RoaXMuZm9udC5wYXJhbXMubnVsbGRlbGltaXRlcnNwYWNlKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdiZXZlbGxlZCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIEggPSBfdGhpcy5nZXRCZXZlbERhdGEoX3RoaXMuaXNEaXNwbGF5KCkpLkg7XG4gICAgICAgICAgICAgICAgdmFyIGJldmVsID0gX3RoaXMuYmV2ZWwgPSBfdGhpcy5jcmVhdGVNbygnLycpO1xuICAgICAgICAgICAgICAgIGJldmVsLm5vZGUuYXR0cmlidXRlcy5zZXQoJ3N5bW1ldHJpYycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJldmVsLmNhblN0cmV0Y2goMSk7XG4gICAgICAgICAgICAgICAgYmV2ZWwuZ2V0U3RyZXRjaGVkVmFyaWFudChbSF0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHJlY29tcHV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IHJlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBiYm94LmVtcHR5KCk7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXRMaXN0KCdsaW5ldGhpY2tuZXNzJywgJ2JldmVsbGVkJyksIGxpbmV0aGlja25lc3MgPSBfYS5saW5ldGhpY2tuZXNzLCBiZXZlbGxlZCA9IF9hLmJldmVsbGVkO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLmlzRGlzcGxheSgpO1xuICAgICAgICAgICAgdmFyIHcgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJldmVsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCZXZlbGxlZEJCb3goYmJveCwgZGlzcGxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gdGhpcy5sZW5ndGgyZW0oU3RyaW5nKGxpbmV0aGlja25lc3MpLCAuMDYpO1xuICAgICAgICAgICAgICAgIHcgPSAtMiAqIHRoaXMucGFkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlja25lc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRBdG9wQkJveChiYm94LCBkaXNwbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RnJhY3Rpb25CQm94KGJib3gsIGRpc3BsYXksIHRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHcgLT0gLjI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcgKz0gYmJveC53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmJveC5jbGVhbigpO1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlLCB3KTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0RnJhY3Rpb25CQm94ID0gZnVuY3Rpb24gKGJib3gsIGRpc3BsYXksIHQpIHtcbiAgICAgICAgICAgIHZhciBuYm94ID0gdGhpcy5jaGlsZE5vZGVzWzBdLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgdmFyIGRib3ggPSB0aGlzLmNoaWxkTm9kZXNbMV0uZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5mb250LnBhcmFtcztcbiAgICAgICAgICAgIHZhciBhID0gdGV4LmF4aXNfaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUVVYoZGlzcGxheSwgdCksIFQgPSBfYS5ULCB1ID0gX2EudSwgdiA9IF9hLnY7XG4gICAgICAgICAgICBiYm94LmNvbWJpbmUobmJveCwgMCwgYSArIFQgKyBNYXRoLm1heChuYm94LmQgKiBuYm94LnJzY2FsZSwgdSkpO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKGRib3gsIDAsIGEgLSBUIC0gTWF0aC5tYXgoZGJveC5oICogZGJveC5yc2NhbGUsIHYpKTtcbiAgICAgICAgICAgIGJib3gudyArPSAyICogdGhpcy5wYWQgKyAuMjtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0VFVWID0gZnVuY3Rpb24gKGRpc3BsYXksIHQpIHtcbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmZvbnQucGFyYW1zO1xuICAgICAgICAgICAgdmFyIGEgPSB0ZXguYXhpc19oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgVCA9IChkaXNwbGF5ID8gMy41IDogMS41KSAqIHQ7XG4gICAgICAgICAgICByZXR1cm4geyBUOiAoZGlzcGxheSA/IDMuNSA6IDEuNSkgKiB0LFxuICAgICAgICAgICAgICAgIHU6IChkaXNwbGF5ID8gdGV4Lm51bTEgOiB0ZXgubnVtMikgLSBhIC0gVCxcbiAgICAgICAgICAgICAgICB2OiAoZGlzcGxheSA/IHRleC5kZW5vbTEgOiB0ZXguZGVub20yKSArIGEgLSBUIH07XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEF0b3BCQm94ID0gZnVuY3Rpb24gKGJib3gsIGRpc3BsYXkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0VVZRKGRpc3BsYXkpLCB1ID0gX2EudSwgdiA9IF9hLnYsIG5ib3ggPSBfYS5uYm94LCBkYm94ID0gX2EuZGJveDtcbiAgICAgICAgICAgIGJib3guY29tYmluZShuYm94LCAwLCB1KTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShkYm94LCAwLCAtdik7XG4gICAgICAgICAgICBiYm94LncgKz0gMiAqIHRoaXMucGFkO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRVVlEgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgICAgICAgdmFyIG5ib3ggPSB0aGlzLmNoaWxkTm9kZXNbMF0uZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgICAgICB2YXIgZGJveCA9IHRoaXMuY2hpbGROb2Rlc1sxXS5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmZvbnQucGFyYW1zO1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKChkaXNwbGF5ID8gW3RleC5udW0xLCB0ZXguZGVub20xXSA6IFt0ZXgubnVtMywgdGV4LmRlbm9tMl0pLCAyKSwgdSA9IF9hWzBdLCB2ID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgcCA9IChkaXNwbGF5ID8gNyA6IDMpICogdGV4LnJ1bGVfdGhpY2tuZXNzO1xuICAgICAgICAgICAgdmFyIHEgPSAodSAtIG5ib3guZCAqIG5ib3guc2NhbGUpIC0gKGRib3guaCAqIGRib3guc2NhbGUgLSB2KTtcbiAgICAgICAgICAgIGlmIChxIDwgcCkge1xuICAgICAgICAgICAgICAgIHUgKz0gKHAgLSBxKSAvIDI7XG4gICAgICAgICAgICAgICAgdiArPSAocCAtIHEpIC8gMjtcbiAgICAgICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHU6IHUsIHY6IHYsIHE6IHEsIG5ib3g6IG5ib3gsIGRib3g6IGRib3ggfTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0QmV2ZWxsZWRCQm94ID0gZnVuY3Rpb24gKGJib3gsIGRpc3BsYXkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0QmV2ZWxEYXRhKGRpc3BsYXkpLCB1ID0gX2EudSwgdiA9IF9hLnYsIGRlbHRhID0gX2EuZGVsdGEsIG5ib3ggPSBfYS5uYm94LCBkYm94ID0gX2EuZGJveDtcbiAgICAgICAgICAgIHZhciBsYm94ID0gdGhpcy5iZXZlbC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShuYm94LCAwLCB1KTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShsYm94LCBiYm94LncgLSBkZWx0YSAvIDIsIDApO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKGRib3gsIGJib3gudyAtIGRlbHRhIC8gMiwgdik7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEJldmVsRGF0YSA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgICAgICB2YXIgbmJveCA9IHRoaXMuY2hpbGROb2Rlc1swXS5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgIHZhciBkYm94ID0gdGhpcy5jaGlsZE5vZGVzWzFdLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gKGRpc3BsYXkgPyAuNCA6IC4xNSk7XG4gICAgICAgICAgICB2YXIgSCA9IE1hdGgubWF4KG5ib3guc2NhbGUgKiAobmJveC5oICsgbmJveC5kKSwgZGJveC5zY2FsZSAqIChkYm94LmggKyBkYm94LmQpKSArIDIgKiBkZWx0YTtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5mb250LnBhcmFtcy5heGlzX2hlaWdodDtcbiAgICAgICAgICAgIHZhciB1ID0gbmJveC5zY2FsZSAqIChuYm94LmQgLSBuYm94LmgpIC8gMiArIGEgKyBkZWx0YTtcbiAgICAgICAgICAgIHZhciB2ID0gZGJveC5zY2FsZSAqIChkYm94LmQgLSBkYm94LmgpIC8gMiArIGEgLSBkZWx0YTtcbiAgICAgICAgICAgIHJldHVybiB7IEg6IEgsIGRlbHRhOiBkZWx0YSwgdTogdSwgdjogdiwgbmJveDogbmJveCwgZGJveDogZGJveCB9O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jYW5TdHJldGNoID0gZnVuY3Rpb24gKF9kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaXNEaXNwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0TGlzdCgnZGlzcGxheXN0eWxlJywgJ3NjcmlwdGxldmVsJyksIGRpc3BsYXlzdHlsZSA9IF9hLmRpc3BsYXlzdHlsZSwgc2NyaXB0bGV2ZWwgPSBfYS5zY3JpcHRsZXZlbDtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5c3R5bGUgJiYgc2NyaXB0bGV2ZWwgPT09IDA7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFdyYXBXaWR0aCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuZ2V0KCdiZXZlbGxlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1tpXS5nZXRPdXRlckJCb3goKS53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmdldEJCb3goKS53O1xuICAgICAgICAgICAgdmFyIHRoaWNrbmVzcyA9IHRoaXMubGVuZ3RoMmVtKGF0dHJpYnV0ZXMuZ2V0KCdsaW5ldGhpY2tuZXNzJykpO1xuICAgICAgICAgICAgcmV0dXJuIHcgLSAodGhpY2tuZXNzID8gLjIgOiAwKSAtIDIgKiB0aGlzLnBhZDtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0Q2hpbGRBbGlnbiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgcmV0dXJuIChhdHRyaWJ1dGVzLmdldCgnYmV2ZWxsZWQnKSA/ICdsZWZ0JyA6IGF0dHJpYnV0ZXMuZ2V0KFsnbnVtYWxpZ24nLCAnZGVub21hbGlnbiddW2ldKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NZnJhY01peGluID0gQ29tbW9uTWZyYWNNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1mcmFjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTWdseXBoTWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25NZ2x5cGhNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXRMaXN0KCd3aWR0aCcsICdoZWlnaHQnLCAndmFsaWduJywgJ3NyYycsICdpbmRleCcpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQsIHZhbGlnbiA9IF9hLnZhbGlnbiwgc3JjID0gX2Euc3JjLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAod2lkdGggPT09ICdhdXRvJyA/IDEgOiB0aGlzLmxlbmd0aDJlbSh3aWR0aCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKGhlaWdodCA9PT0gJ2F1dG8nID8gMSA6IHRoaXMubGVuZ3RoMmVtKGhlaWdodCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWduID0gdGhpcy5sZW5ndGgyZW0odmFsaWduIHx8ICcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGluZGV4KSk7XG4gICAgICAgICAgICAgICAgdmFyIG1tbEZhY3RvcnkgPSB0aGlzLm5vZGUuZmFjdG9yeTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJXcmFwcGVyID0gdGhpcy53cmFwKG1tbEZhY3RvcnkuY3JlYXRlKCd0ZXh0Jykuc2V0VGV4dCh0ZXh0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyV3JhcHBlci5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21wdXRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCBfcmVjb21wdXRlKSB7XG4gICAgICAgICAgICBpZiAoX3JlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IF9yZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhcldyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBiYm94LnVwZGF0ZUZyb20odGhpcy5jaGFyV3JhcHBlci5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmJveC53ID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICBiYm94LmggPSB0aGlzLmhlaWdodCArIHRoaXMudmFsaWduO1xuICAgICAgICAgICAgICAgIGJib3guZCA9IC10aGlzLnZhbGlnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk1nbHlwaE1peGluID0gQ29tbW9uTWdseXBoTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZ2x5cGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25NaU1peGluID0gdm9pZCAwO1xuZnVuY3Rpb24gQ29tbW9uTWlNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIF9yZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChfcmVjb21wdXRlID09PSB2b2lkIDApIHsgX3JlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNvbXB1dGVCQm94LmNhbGwodGhpcywgYmJveCk7XG4gICAgICAgICAgICB0aGlzLmNvcHlTa2V3SUMoYmJveCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NaU1peGluID0gQ29tbW9uTWlNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTW11bHRpc2NyaXB0c01peGluID0gZXhwb3J0cy5TY3JpcHROYW1lcyA9IGV4cG9ydHMuTmV4dFNjcmlwdCA9IHZvaWQgMDtcbnZhciBCQm94X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9CQm94LmpzXCIpO1xuZXhwb3J0cy5OZXh0U2NyaXB0ID0ge1xuICAgIGJhc2U6ICdzdWJMaXN0JyxcbiAgICBzdWJMaXN0OiAnc3VwTGlzdCcsXG4gICAgc3VwTGlzdDogJ3N1Ykxpc3QnLFxuICAgIHBzdWJMaXN0OiAncHN1cExpc3QnLFxuICAgIHBzdXBMaXN0OiAncHN1Ykxpc3QnLFxufTtcbmV4cG9ydHMuU2NyaXB0TmFtZXMgPSBbJ3N1cCcsICdzdXAnLCAncHN1cCcsICdwc3ViJ107XG5mdW5jdGlvbiBDb21tb25NbXVsdGlzY3JpcHRzTWl4aW4oQmFzZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnNjcmlwdERhdGEgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuZmlyc3RQcmVzY3JpcHQgPSAwO1xuICAgICAgICAgICAgX3RoaXMuZ2V0U2NyaXB0RGF0YSgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbWJpbmVQcmVQb3N0ID0gZnVuY3Rpb24gKHByZSwgcG9zdCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSBuZXcgQkJveF9qc18xLkJCb3gocHJlKTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShwb3N0LCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBiYm94O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21wdXRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCByZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChyZWNvbXB1dGUgPT09IHZvaWQgMCkgeyByZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHNjcmlwdHNwYWNlID0gdGhpcy5mb250LnBhcmFtcy5zY3JpcHRzcGFjZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5zY3JpcHREYXRhO1xuICAgICAgICAgICAgdmFyIHN1YiA9IHRoaXMuY29tYmluZVByZVBvc3QoZGF0YS5zdWIsIGRhdGEucHN1Yik7XG4gICAgICAgICAgICB2YXIgc3VwID0gdGhpcy5jb21iaW5lUHJlUG9zdChkYXRhLnN1cCwgZGF0YS5wc3VwKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmdldFVWUShzdWIsIHN1cCksIDIpLCB1ID0gX2FbMF0sIHYgPSBfYVsxXTtcbiAgICAgICAgICAgIGJib3guZW1wdHkoKTtcbiAgICAgICAgICAgIGlmIChkYXRhLm51bVByZXNjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICBiYm94LmNvbWJpbmUoZGF0YS5wc3VwLCBzY3JpcHRzcGFjZSwgdSk7XG4gICAgICAgICAgICAgICAgYmJveC5jb21iaW5lKGRhdGEucHN1Yiwgc2NyaXB0c3BhY2UsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmJveC5hcHBlbmQoZGF0YS5iYXNlKTtcbiAgICAgICAgICAgIGlmIChkYXRhLm51bVNjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGJib3gudztcbiAgICAgICAgICAgICAgICBiYm94LmNvbWJpbmUoZGF0YS5zdXAsIHcsIHUpO1xuICAgICAgICAgICAgICAgIGJib3guY29tYmluZShkYXRhLnN1Yiwgdywgdik7XG4gICAgICAgICAgICAgICAgYmJveC53ICs9IHNjcmlwdHNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmJveC5jbGVhbigpO1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0U2NyaXB0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5zY3JpcHREYXRhID0ge1xuICAgICAgICAgICAgICAgIGJhc2U6IG51bGwsIHN1YjogQkJveF9qc18xLkJCb3guZW1wdHkoKSwgc3VwOiBCQm94X2pzXzEuQkJveC5lbXB0eSgpLCBwc3ViOiBCQm94X2pzXzEuQkJveC5lbXB0eSgpLCBwc3VwOiBCQm94X2pzXzEuQkJveC5lbXB0eSgpLFxuICAgICAgICAgICAgICAgIG51bVByZXNjcmlwdHM6IDAsIG51bVNjcmlwdHM6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbGlzdHMgPSB0aGlzLmdldFNjcmlwdEJCb3hMaXN0cygpO1xuICAgICAgICAgICAgdGhpcy5jb21iaW5lQkJveExpc3RzKGRhdGEuc3ViLCBkYXRhLnN1cCwgbGlzdHMuc3ViTGlzdCwgbGlzdHMuc3VwTGlzdCk7XG4gICAgICAgICAgICB0aGlzLmNvbWJpbmVCQm94TGlzdHMoZGF0YS5wc3ViLCBkYXRhLnBzdXAsIGxpc3RzLnBzdWJMaXN0LCBsaXN0cy5wc3VwTGlzdCk7XG4gICAgICAgICAgICBkYXRhLmJhc2UgPSBsaXN0cy5iYXNlWzBdO1xuICAgICAgICAgICAgZGF0YS5udW1QcmVzY3JpcHRzID0gbGlzdHMucHN1Ykxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YS5udW1TY3JpcHRzID0gbGlzdHMuc3ViTGlzdC5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFNjcmlwdEJCb3hMaXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdmFyIGxpc3RzID0ge1xuICAgICAgICAgICAgICAgIGJhc2U6IFtdLCBzdWJMaXN0OiBbXSwgc3VwTGlzdDogW10sIHBzdWJMaXN0OiBbXSwgcHN1cExpc3Q6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNjcmlwdCA9ICdiYXNlJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZS5pc0tpbmQoJ21wcmVzY3JpcHRzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9ICdwc3ViTGlzdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0c1tzY3JpcHRdLnB1c2goY2hpbGQuZ2V0T3V0ZXJCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZXhwb3J0cy5OZXh0U2NyaXB0W3NjcmlwdF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcnN0UHJlc2NyaXB0ID0gbGlzdHMuc3ViTGlzdC5sZW5ndGggKyBsaXN0cy5zdXBMaXN0Lmxlbmd0aCArIDI7XG4gICAgICAgICAgICB0aGlzLnBhZExpc3RzKGxpc3RzLnN1Ykxpc3QsIGxpc3RzLnN1cExpc3QpO1xuICAgICAgICAgICAgdGhpcy5wYWRMaXN0cyhsaXN0cy5wc3ViTGlzdCwgbGlzdHMucHN1cExpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5wYWRMaXN0cyA9IGZ1bmN0aW9uIChsaXN0MSwgbGlzdDIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0MS5sZW5ndGggPiBsaXN0Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsaXN0Mi5wdXNoKEJCb3hfanNfMS5CQm94LmVtcHR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21iaW5lQkJveExpc3RzID0gZnVuY3Rpb24gKGJib3gxLCBiYm94MiwgbGlzdDEsIGxpc3QyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHRoaXMuZ2V0U2NhbGVkV0hEKGxpc3QxW2ldKSwgMyksIHcxID0gX2FbMF0sIGgxID0gX2FbMV0sIGQxID0gX2FbMl07XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHRoaXMuZ2V0U2NhbGVkV0hEKGxpc3QyW2ldKSwgMyksIHcyID0gX2JbMF0sIGgyID0gX2JbMV0sIGQyID0gX2JbMl07XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBNYXRoLm1heCh3MSwgdzIpO1xuICAgICAgICAgICAgICAgIGJib3gxLncgKz0gdztcbiAgICAgICAgICAgICAgICBiYm94Mi53ICs9IHc7XG4gICAgICAgICAgICAgICAgaWYgKGgxID4gYmJveDEuaClcbiAgICAgICAgICAgICAgICAgICAgYmJveDEuaCA9IGgxO1xuICAgICAgICAgICAgICAgIGlmIChkMSA+IGJib3gxLmQpXG4gICAgICAgICAgICAgICAgICAgIGJib3gxLmQgPSBkMTtcbiAgICAgICAgICAgICAgICBpZiAoaDIgPiBiYm94Mi5oKVxuICAgICAgICAgICAgICAgICAgICBiYm94Mi5oID0gaDI7XG4gICAgICAgICAgICAgICAgaWYgKGQyID4gYmJveDIuZClcbiAgICAgICAgICAgICAgICAgICAgYmJveDIuZCA9IGQyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRTY2FsZWRXSEQgPSBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICAgICAgdmFyIHcgPSBiYm94LncsIGggPSBiYm94LmgsIGQgPSBiYm94LmQsIHJzY2FsZSA9IGJib3gucnNjYWxlO1xuICAgICAgICAgICAgcmV0dXJuIFt3ICogcnNjYWxlLCBoICogcnNjYWxlLCBkICogcnNjYWxlXTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0VVZRID0gZnVuY3Rpb24gKHN1YmJveCwgc3VwYm94KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXRoaXMuVVZRKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKFswLCAwLCAwXSwgMyksIHUgPSBfYlswXSwgdiA9IF9iWzFdLCBxID0gX2JbMl07XG4gICAgICAgICAgICAgICAgaWYgKHN1YmJveC5oID09PSAwICYmIHN1YmJveC5kID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHUgPSB0aGlzLmdldFUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3VwYm94LmggPT09IDAgJiYgc3VwYm94LmQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdSA9IC10aGlzLmdldFYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9hID0gX19yZWFkKF9zdXBlci5wcm90b3R5cGUuZ2V0VVZRLmNhbGwodGhpcywgc3ViYm94LCBzdXBib3gpLCAzKSwgdSA9IF9hWzBdLCB2ID0gX2FbMV0sIHEgPSBfYVsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5VVlEgPSBbdSwgdiwgcV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VVlE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NbXVsdGlzY3JpcHRzTWl4aW4gPSBDb21tb25NbXVsdGlzY3JpcHRzTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tbXVsdGlzY3JpcHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTW5NaXhpbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIENvbW1vbk1uTWl4aW4oQmFzZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5yZW1hcENoYXJzID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmZvbnQuZ2V0UmVtYXBwZWRDaGFyKCdtbicsIGNoYXJzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMudW5pY29kZUNoYXJzKHRleHQsIHRoaXMudmFyaWFudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNbMF0gPSBjWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBjLmNvbmNhdChjaGFycy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25Nbk1peGluID0gQ29tbW9uTW5NaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk1vTWl4aW4gPSBleHBvcnRzLkRpcmVjdGlvblZIID0gdm9pZCAwO1xudmFyIEJCb3hfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL0JCb3guanNcIik7XG52YXIgc3RyaW5nX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9zdHJpbmcuanNcIik7XG52YXIgRm9udERhdGFfanNfMSA9IHJlcXVpcmUoXCIuLi9Gb250RGF0YS5qc1wiKTtcbmV4cG9ydHMuRGlyZWN0aW9uVkggPSAoX2EgPSB7fSxcbiAgICBfYVsxXSA9ICd2JyxcbiAgICBfYVsyXSA9ICdoJyxcbiAgICBfYSk7XG5mdW5jdGlvbiBDb21tb25Nb01peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zaXplID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmlzQWNjZW50ID0gX3RoaXMubm9kZS5pc0FjY2VudDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21wdXRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCBfcmVjb21wdXRlKSB7XG4gICAgICAgICAgICBpZiAoX3JlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IF9yZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdGhpcy5wcm90b0JCb3goYmJveCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdzeW1tZXRyaWMnKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZXRjaC5kaXIgIT09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZ2V0Q2VudGVyT2Zmc2V0KGJib3gpO1xuICAgICAgICAgICAgICAgIGJib3guaCArPSBkO1xuICAgICAgICAgICAgICAgIGJib3guZCAtPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5nZXRQcm9wZXJ0eSgnbWF0aGFjY2VudCcpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc3RyZXRjaC5kaXIgPT09IDAgfHwgdGhpcy5zaXplID49IDApKSB7XG4gICAgICAgICAgICAgICAgYmJveC53ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUucHJvdG9CQm94ID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICAgICAgICAgIHZhciBzdHJldGNoeSA9ICh0aGlzLnN0cmV0Y2guZGlyICE9PSAwKTtcbiAgICAgICAgICAgIGlmIChzdHJldGNoeSAmJiB0aGlzLnNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0cmV0Y2hlZFZhcmlhbnQoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJldGNoeSAmJiB0aGlzLnNpemUgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuY29tcHV0ZUJCb3guY2FsbCh0aGlzLCBiYm94KTtcbiAgICAgICAgICAgIHRoaXMuY29weVNrZXdJQyhiYm94KTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0QWNjZW50T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSBCQm94X2pzXzEuQkJveC5lbXB0eSgpO1xuICAgICAgICAgICAgdGhpcy5wcm90b0JCb3goYmJveCk7XG4gICAgICAgICAgICByZXR1cm4gLWJib3gudyAvIDI7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIChiYm94KSB7XG4gICAgICAgICAgICBpZiAoYmJveCA9PT0gdm9pZCAwKSB7IGJib3ggPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoIWJib3gpIHtcbiAgICAgICAgICAgICAgICBiYm94ID0gQkJveF9qc18xLkJCb3guZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNvbXB1dGVCQm94LmNhbGwodGhpcywgYmJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKChiYm94LmggKyBiYm94LmQpIC8gMiArIHRoaXMuZm9udC5wYXJhbXMuYXhpc19oZWlnaHQpIC0gYmJveC5oO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRWYXJpYW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnbGFyZ2VvcCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYW50ID0gKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnZGlzcGxheXN0eWxlJykgPyAnLWxhcmdlb3AnIDogJy1zbWFsbG9wJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXRFeHBsaWNpdCgnbWF0aHZhcmlhbnQnKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5nZXRQcm9wZXJ0eSgncHNldWRvc2NyaXB0JykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYW50ID0gJy10ZXgtdmFyaWFudCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5nZXRWYXJpYW50LmNhbGwodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNhblN0cmV0Y2ggPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJldGNoLmRpciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmV0Y2guZGlyID09PSBkaXJlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmdldCgnc3RyZXRjaHknKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmZyb20oYykubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkZWxpbSA9IHRoaXMuZm9udC5nZXREZWxpbWl0ZXIoYy5jb2RlUG9pbnRBdCgwKSk7XG4gICAgICAgICAgICB0aGlzLnN0cmV0Y2ggPSAoZGVsaW0gJiYgZGVsaW0uZGlyID09PSBkaXJlY3Rpb24gPyBkZWxpbSA6IEZvbnREYXRhX2pzXzEuTk9TVFJFVENIKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmV0Y2guZGlyICE9PSAwO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRTdHJldGNoZWRWYXJpYW50ID0gZnVuY3Rpb24gKFdILCBleGFjdCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBpZiAoZXhhY3QgPT09IHZvaWQgMCkgeyBleGFjdCA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJldGNoLmRpciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBEID0gdGhpcy5nZXRXSChXSCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMuZ2V0U2l6ZSgnbWluc2l6ZScsIDApO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLmdldFNpemUoJ21heHNpemUnLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGhhY2NlbnQgPSB0aGlzLm5vZGUuZ2V0UHJvcGVydHkoJ21hdGhhY2NlbnQnKTtcbiAgICAgICAgICAgICAgICBEID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIEQpKTtcbiAgICAgICAgICAgICAgICB2YXIgZGYgPSB0aGlzLmZvbnQucGFyYW1zLmRlbGltaXRlcmZhY3RvciAvIDEwMDA7XG4gICAgICAgICAgICAgICAgdmFyIGRzID0gdGhpcy5mb250LnBhcmFtcy5kZWxpbWl0ZXJzaG9ydGZhbGw7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSAobWluIHx8IGV4YWN0ID8gRCA6IG1hdGhhY2NlbnQgPyBNYXRoLm1pbihEIC8gZGYsIEQgKyBkcykgOiBNYXRoLm1heChEICogZGYsIEQgLSBkcykpO1xuICAgICAgICAgICAgICAgIHZhciBkZWxpbSA9IHRoaXMuc3RyZXRjaDtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGRlbGltLmMgfHwgdGhpcy5nZXRUZXh0KCkuY29kZVBvaW50QXQoMCk7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkZWxpbS5zaXplcykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhkZWxpbS5zaXplcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID49IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhhY2NlbnQgJiYgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFudCA9IHRoaXMuZm9udC5nZXRTaXplVmFyaWFudChjLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltLnNjaGFyICYmIGRlbGltLnNjaGFyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmV0Y2ggPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5zdHJldGNoKSwgeyBjOiBkZWxpbS5zY2hhcltpXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWxpbS5zdHJldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGVCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U3RyZXRjaEJCb3goV0gsIHRoaXMuY2hlY2tFeHRlbmRlZEhlaWdodChELCBkZWxpbSksIGRlbGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFudCA9IHRoaXMuZm9udC5nZXRTaXplVmFyaWFudChjLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLm5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmlzU2V0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmxlbmd0aDJlbShhdHRyaWJ1dGVzLmdldChuYW1lKSwgMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFdIID0gZnVuY3Rpb24gKFdIKSB7XG4gICAgICAgICAgICBpZiAoV0gubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKFdILmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gV0hbMF07XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoV0gsIDIpLCBIID0gX2FbMF0sIEQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5mb250LnBhcmFtcy5heGlzX2hlaWdodDtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdzeW1tZXRyaWMnKSA/IDIgKiBNYXRoLm1heChIIC0gYSwgRCArIGEpIDogSCArIEQpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRTdHJldGNoQkJveCA9IGZ1bmN0aW9uIChXSEQsIEQsIEMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChDLmhhc093blByb3BlcnR5KCdtaW4nKSAmJiBDLm1pbiA+IEQpIHtcbiAgICAgICAgICAgICAgICBEID0gQy5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoQy5IRFcsIDMpLCBoID0gX2JbMF0sIGQgPSBfYlsxXSwgdyA9IF9iWzJdO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZXRjaC5kaXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBfYSA9IF9fcmVhZCh0aGlzLmdldEJhc2VsaW5lKFdIRCwgRCwgQyksIDIpLCBoID0gX2FbMF0sIGQgPSBfYVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSBEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYm94LmggPSBoO1xuICAgICAgICAgICAgdGhpcy5iYm94LmQgPSBkO1xuICAgICAgICAgICAgdGhpcy5iYm94LncgPSB3O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRCYXNlbGluZSA9IGZ1bmN0aW9uIChXSEQsIEhELCBDKSB7XG4gICAgICAgICAgICB2YXIgaGFzV0hEID0gKFdIRC5sZW5ndGggPT09IDIgJiYgV0hEWzBdICsgV0hEWzFdID09PSBIRCk7XG4gICAgICAgICAgICB2YXIgc3ltbWV0cmljID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdzeW1tZXRyaWMnKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCgoaGFzV0hEID8gV0hEIDogW0hELCAwXSksIDIpLCBIID0gX2FbMF0sIEQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChbSCArIEQsIDBdLCAyKSwgaCA9IF9iWzBdLCBkID0gX2JbMV07XG4gICAgICAgICAgICBpZiAoc3ltbWV0cmljKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmZvbnQucGFyYW1zLmF4aXNfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChoYXNXSEQpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IDIgKiBNYXRoLm1heChIIC0gYSwgRCArIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkID0gaCAvIDIgLSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzV0hEKSB7XG4gICAgICAgICAgICAgICAgZCA9IEQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBfX3JlYWQoKEMuSERXIHx8IFsuNzUsIC4yNV0pLCAyKSwgY2ggPSBfY1swXSwgY2QgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICBkID0gY2QgKiAoaCAvIChjaCArIGNkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2ggLSBkLCBkXTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2hlY2tFeHRlbmRlZEhlaWdodCA9IGZ1bmN0aW9uIChELCBDKSB7XG4gICAgICAgICAgICBpZiAoQy5mdWxsRXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKEMuZnVsbEV4dCwgMiksIGV4dFNpemUgPSBfYVswXSwgZW5kU2l6ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHZhciBuID0gTWF0aC5jZWlsKE1hdGgubWF4KDAsIEQgLSBlbmRTaXplKSAvIGV4dFNpemUpO1xuICAgICAgICAgICAgICAgIEQgPSBlbmRTaXplICsgbiAqIGV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRDtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUucmVtYXBDaGFycyA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgICAgdmFyIHByaW1lcyA9IHRoaXMubm9kZS5nZXRQcm9wZXJ0eSgncHJpbWVzJyk7XG4gICAgICAgICAgICBpZiAocHJpbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdfanNfMS51bmljb2RlQ2hhcnMpKHByaW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5ub2RlLmNvcmVQYXJlbnQoKS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGlzQWNjZW50ID0gdGhpcy5pc0FjY2VudCAmJiAhcGFyZW50XzEuaXNLaW5kKCdtcm93Jyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IChpc0FjY2VudCA/ICdhY2NlbnQnIDogJ21vJyk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmZvbnQuZ2V0UmVtYXBwZWRDaGFyKG1hcCwgY2hhcnNbMF0pO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzID0gdGhpcy51bmljb2RlQ2hhcnModGV4dCwgdGhpcy52YXJpYW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25Nb01peGluID0gQ29tbW9uTW9NaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTXBhZGRlZE1peGluID0gdm9pZCAwO1xuZnVuY3Rpb24gQ29tbW9uTXBhZGRlZE1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0RGltZW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldExpc3QoJ3dpZHRoJywgJ2hlaWdodCcsICdkZXB0aCcsICdsc3BhY2UnLCAndm9mZnNldCcpO1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmNoaWxkTm9kZXNbMF0uZ2V0QkJveCgpO1xuICAgICAgICAgICAgdmFyIHcgPSBiYm94LncsIGggPSBiYm94LmgsIGQgPSBiYm94LmQ7XG4gICAgICAgICAgICB2YXIgVyA9IHcsIEggPSBoLCBEID0gZCwgeCA9IDAsIHkgPSAwLCBkeCA9IDA7XG4gICAgICAgICAgICBpZiAodmFsdWVzLndpZHRoICE9PSAnJylcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5kaW1lbih2YWx1ZXMud2lkdGgsIGJib3gsICd3JywgMCk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmhlaWdodCAhPT0gJycpXG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuZGltZW4odmFsdWVzLmhlaWdodCwgYmJveCwgJ2gnLCAwKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuZGVwdGggIT09ICcnKVxuICAgICAgICAgICAgICAgIGQgPSB0aGlzLmRpbWVuKHZhbHVlcy5kZXB0aCwgYmJveCwgJ2QnLCAwKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMudm9mZnNldCAhPT0gJycpXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZGltZW4odmFsdWVzLnZvZmZzZXQsIGJib3gpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5sc3BhY2UgIT09ICcnKVxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmRpbWVuKHZhbHVlcy5sc3BhY2UsIGJib3gpO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdkYXRhLWFsaWduJyk7XG4gICAgICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgICAgICBkeCA9IHRoaXMuZ2V0QWxpZ25YKHcsIGJib3gsIGFsaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbSCwgRCwgVywgaCAtIEgsIGQgLSBELCB3IC0gVywgeCwgeSwgZHhdO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kaW1lbiA9IGZ1bmN0aW9uIChsZW5ndGgsIGJib3gsIGQsIG0pIHtcbiAgICAgICAgICAgIGlmIChkID09PSB2b2lkIDApIHsgZCA9ICcnOyB9XG4gICAgICAgICAgICBpZiAobSA9PT0gdm9pZCAwKSB7IG0gPSBudWxsOyB9XG4gICAgICAgICAgICBsZW5ndGggPSBTdHJpbmcobGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxlbmd0aC5tYXRjaCgvd2lkdGh8aGVpZ2h0fGRlcHRoLyk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IChtYXRjaCA/IGJib3hbbWF0Y2hbMF0uY2hhckF0KDApXSA6XG4gICAgICAgICAgICAgICAgKGQgPyBiYm94W2RdIDogMCkpO1xuICAgICAgICAgICAgdmFyIGRpbWVuID0gKHRoaXMubGVuZ3RoMmVtKGxlbmd0aCwgc2l6ZSkgfHwgMCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoLm1hdGNoKC9eWy0rXS8pICYmIGQpIHtcbiAgICAgICAgICAgICAgICBkaW1lbiArPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpbWVuID0gTWF0aC5tYXgobSwgZGltZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpbWVuO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21wdXRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCByZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChyZWNvbXB1dGUgPT09IHZvaWQgMCkgeyByZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHRoaXMuZ2V0RGltZW5zKCksIDYpLCBIID0gX2FbMF0sIEQgPSBfYVsxXSwgVyA9IF9hWzJdLCBkaCA9IF9hWzNdLCBkZCA9IF9hWzRdLCBkdyA9IF9hWzVdO1xuICAgICAgICAgICAgYmJveC53ID0gVyArIGR3O1xuICAgICAgICAgICAgYmJveC5oID0gSCArIGRoO1xuICAgICAgICAgICAgYmJveC5kID0gRCArIGRkO1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlLCBiYm94LncpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRXcmFwV2lkdGggPSBmdW5jdGlvbiAoX2kpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKS53O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRDaGlsZEFsaWduID0gZnVuY3Rpb24gKF9pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdkYXRhLWFsaWduJykgfHwgJ2xlZnQnO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uTXBhZGRlZE1peGluID0gQ29tbW9uTXBhZGRlZE1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXBhZGRlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk1yb290TWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25Ncm9vdE1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInN1cmRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21iaW5lUm9vdEJCb3ggPSBmdW5jdGlvbiAoQkJPWCwgc2JveCwgSCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmNoaWxkTm9kZXNbdGhpcy5yb290XS5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgIHZhciBoID0gdGhpcy5nZXRSb290RGltZW5zKHNib3gsIEgpWzFdO1xuICAgICAgICAgICAgQkJPWC5jb21iaW5lKGJib3gsIDAsIGgpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRSb290RGltZW5zID0gZnVuY3Rpb24gKHNib3gsIEgpIHtcbiAgICAgICAgICAgIHZhciBzdXJkID0gdGhpcy5jaGlsZE5vZGVzW3RoaXMuc3VyZF07XG4gICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuY2hpbGROb2Rlc1t0aGlzLnJvb3RdLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IChzdXJkLnNpemUgPCAwID8gLjUgOiAuNikgKiBzYm94Lnc7XG4gICAgICAgICAgICB2YXIgdyA9IGJib3gudywgcnNjYWxlID0gYmJveC5yc2NhbGU7XG4gICAgICAgICAgICB2YXIgVyA9IE1hdGgubWF4KHcsIG9mZnNldCAvIHJzY2FsZSk7XG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLm1heCgwLCBXIC0gdyk7XG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMucm9vdEhlaWdodChiYm94LCBzYm94LCBzdXJkLnNpemUsIEgpO1xuICAgICAgICAgICAgdmFyIHggPSBXICogcnNjYWxlIC0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIFt4LCBoLCBkeF07XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnJvb3RIZWlnaHQgPSBmdW5jdGlvbiAocmJveCwgc2JveCwgc2l6ZSwgSCkge1xuICAgICAgICAgICAgdmFyIGggPSBzYm94LmggKyBzYm94LmQ7XG4gICAgICAgICAgICB2YXIgYiA9IChzaXplIDwgMCA/IDEuOSA6IC41NSAqIGgpIC0gKGggLSBIKTtcbiAgICAgICAgICAgIHJldHVybiBiICsgTWF0aC5tYXgoMCwgcmJveC5kICogcmJveC5yc2NhbGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uTXJvb3RNaXhpbiA9IENvbW1vbk1yb290TWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tcm9vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbkluZmVycmVkTXJvd01peGluID0gZXhwb3J0cy5Db21tb25Ncm93TWl4aW4gPSB2b2lkIDA7XG52YXIgQkJveF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvQkJveC5qc1wiKTtcbmZ1bmN0aW9uIENvbW1vbk1yb3dNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zdHJldGNoQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5jaGlsZE5vZGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmJib3gucHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5iYm94LnB3aWR0aCA9IEJCb3hfanNfMS5CQm94LmZ1bGxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJmaXhlc1BXaWR0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnN0cmV0Y2hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzIsIF9hLCBlXzMsIF9iLCBlXzQsIF9jO1xuICAgICAgICAgICAgdmFyIHN0cmV0Y2h5ID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gX192YWx1ZXModGhpcy5jaGlsZE5vZGVzKSwgX2UgPSBfZC5uZXh0KCk7ICFfZS5kb25lOyBfZSA9IF9kLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNhblN0cmV0Y2goMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmV0Y2h5LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZSAmJiAhX2UuZG9uZSAmJiAoX2EgPSBfZC5yZXR1cm4pKSBfYS5jYWxsKF9kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvdW50ID0gc3RyZXRjaHkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG5vZGVDb3VudCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY291bnQgJiYgbm9kZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBIID0gMCwgRCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGFsbCA9IChjb3VudCA+IDEgJiYgY291bnQgPT09IG5vZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyh0aGlzLmNoaWxkTm9kZXMpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub1N0cmV0Y2ggPSAoY2hpbGQuc3RyZXRjaC5kaXIgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbCB8fCBub1N0cmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ggPSBjaGlsZC5nZXRPdXRlckJCb3gobm9TdHJldGNoKSwgaCA9IF9oLmgsIGQgPSBfaC5kLCByc2NhbGUgPSBfaC5yc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCAqPSByc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCAqPSByc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPiBIKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IEQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEQgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzdHJldGNoeV8xID0gX192YWx1ZXMoc3RyZXRjaHkpLCBzdHJldGNoeV8xXzEgPSBzdHJldGNoeV8xLm5leHQoKTsgIXN0cmV0Y2h5XzFfMS5kb25lOyBzdHJldGNoeV8xXzEgPSBzdHJldGNoeV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc3RyZXRjaHlfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29yZU1PKCkuZ2V0U3RyZXRjaGVkVmFyaWFudChbSCwgRF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZXRjaHlfMV8xICYmICFzdHJldGNoeV8xXzEuZG9uZSAmJiAoX2MgPSBzdHJldGNoeV8xLnJldHVybikpIF9jLmNhbGwoc3RyZXRjaHlfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk1yb3dNaXhpbiA9IENvbW1vbk1yb3dNaXhpbjtcbmZ1bmN0aW9uIENvbW1vbkluZmVycmVkTXJvd01peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMi5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJib3guc2NhbGUgPSB0aGlzLnBhcmVudC5iYm94LnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5iYm94LnJzY2FsZSA9IDE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18yO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25JbmZlcnJlZE1yb3dNaXhpbiA9IENvbW1vbkluZmVycmVkTXJvd01peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXJvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk1zTWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25Nc01peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IF90aGlzLm5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIHZhciBxdW90ZXMgPSBhdHRyaWJ1dGVzLmdldExpc3QoJ2xxdW90ZScsICdycXVvdGUnKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy52YXJpYW50ICE9PSAnbW9ub3NwYWNlJykge1xuICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5pc1NldCgnbHF1b3RlJykgJiYgcXVvdGVzLmxxdW90ZSA9PT0gJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVzLmxxdW90ZSA9ICdcXHUyMDFDJztcbiAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuaXNTZXQoJ3JxdW90ZScpICYmIHF1b3Rlcy5ycXVvdGUgPT09ICdcIicpXG4gICAgICAgICAgICAgICAgICAgIHF1b3Rlcy5ycXVvdGUgPSAnXFx1MjAxRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jaGlsZE5vZGVzLnVuc2hpZnQoX3RoaXMuY3JlYXRlVGV4dChxdW90ZXMubHF1b3RlKSk7XG4gICAgICAgICAgICBfdGhpcy5jaGlsZE5vZGVzLnB1c2goX3RoaXMuY3JlYXRlVGV4dChxdW90ZXMucnF1b3RlKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMud3JhcCh0aGlzLm1tbFRleHQodGV4dCkpO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25Nc01peGluID0gQ29tbW9uTXNNaXhpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTXNwYWNlTWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25Nc3BhY2VNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIF9yZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChfcmVjb21wdXRlID09PSB2b2lkIDApIHsgX3JlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgYmJveC53ID0gdGhpcy5sZW5ndGgyZW0oYXR0cmlidXRlcy5nZXQoJ3dpZHRoJyksIDApO1xuICAgICAgICAgICAgYmJveC5oID0gdGhpcy5sZW5ndGgyZW0oYXR0cmlidXRlcy5nZXQoJ2hlaWdodCcpLCAwKTtcbiAgICAgICAgICAgIGJib3guZCA9IHRoaXMubGVuZ3RoMmVtKGF0dHJpYnV0ZXMuZ2V0KCdkZXB0aCcpLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFuZGxlVmFyaWFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk1zcGFjZU1peGluID0gQ29tbW9uTXNwYWNlTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc3BhY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25Nc3FydE1peGluID0gdm9pZCAwO1xudmFyIEJCb3hfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL0JCb3guanNcIik7XG5mdW5jdGlvbiBDb21tb25Nc3FydE1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3VyZCA9IF90aGlzLmNyZWF0ZU1vKCdcXHUyMjFBJyk7XG4gICAgICAgICAgICBzdXJkLmNhblN0cmV0Y2goMSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5jaGlsZE5vZGVzW190aGlzLmJhc2VdLmdldE91dGVyQkJveCgpLCBoID0gX2EuaCwgZCA9IF9hLmQ7XG4gICAgICAgICAgICB2YXIgdCA9IF90aGlzLmZvbnQucGFyYW1zLnJ1bGVfdGhpY2tuZXNzO1xuICAgICAgICAgICAgdmFyIHAgPSAoX3RoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnZGlzcGxheXN0eWxlJykgPyBfdGhpcy5mb250LnBhcmFtcy54X2hlaWdodCA6IHQpO1xuICAgICAgICAgICAgX3RoaXMuc3VyZEggPSBoICsgZCArIDIgKiB0ICsgcCAvIDQ7XG4gICAgICAgICAgICBzdXJkLmdldFN0cmV0Y2hlZFZhcmlhbnQoW190aGlzLnN1cmRIIC0gZCwgZF0sIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJiYXNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic3VyZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNyZWF0ZU1vID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3N1cGVyLnByb3RvdHlwZS5jcmVhdGVNby5jYWxsKHRoaXMsIHRleHQpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY29tcHV0ZUJCb3ggPSBmdW5jdGlvbiAoYmJveCwgcmVjb21wdXRlKSB7XG4gICAgICAgICAgICBpZiAocmVjb21wdXRlID09PSB2b2lkIDApIHsgcmVjb21wdXRlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHZhciBzdXJkYm94ID0gdGhpcy5jaGlsZE5vZGVzW3RoaXMuc3VyZF0uZ2V0QkJveCgpO1xuICAgICAgICAgICAgdmFyIGJhc2Vib3ggPSBuZXcgQkJveF9qc18xLkJCb3godGhpcy5jaGlsZE5vZGVzW3RoaXMuYmFzZV0uZ2V0T3V0ZXJCQm94KCkpO1xuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmdldFBRKHN1cmRib3gpWzFdO1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmZvbnQucGFyYW1zLnJ1bGVfdGhpY2tuZXNzO1xuICAgICAgICAgICAgdmFyIEggPSBiYXNlYm94LmggKyBxICsgdDtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmdldFJvb3REaW1lbnMoc3VyZGJveCwgSCksIDEpLCB4ID0gX2FbMF07XG4gICAgICAgICAgICBiYm94LmggPSBIICsgdDtcbiAgICAgICAgICAgIHRoaXMuY29tYmluZVJvb3RCQm94KGJib3gsIHN1cmRib3gsIEgpO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKHN1cmRib3gsIHgsIEggLSBzdXJkYm94LmgpO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKGJhc2Vib3gsIHggKyBzdXJkYm94LncsIDApO1xuICAgICAgICAgICAgYmJveC5jbGVhbigpO1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY29tYmluZVJvb3RCQm94ID0gZnVuY3Rpb24gKF9iYm94LCBfc2JveCwgX0gpIHtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0UFEgPSBmdW5jdGlvbiAoc2JveCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmZvbnQucGFyYW1zLnJ1bGVfdGhpY2tuZXNzO1xuICAgICAgICAgICAgdmFyIHAgPSAodGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdkaXNwbGF5c3R5bGUnKSA/IHRoaXMuZm9udC5wYXJhbXMueF9oZWlnaHQgOiB0KTtcbiAgICAgICAgICAgIHZhciBxID0gKHNib3guaCArIHNib3guZCA+IHRoaXMuc3VyZEggP1xuICAgICAgICAgICAgICAgICgoc2JveC5oICsgc2JveC5kKSAtICh0aGlzLnN1cmRIIC0gMiAqIHQgLSBwIC8gMikpIC8gMiA6XG4gICAgICAgICAgICAgICAgdCArIHAgLyA0KTtcbiAgICAgICAgICAgIHJldHVybiBbcCwgcV07XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFJvb3REaW1lbnMgPSBmdW5jdGlvbiAoX3Nib3gsIF9IKSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uTXNxcnRNaXhpbiA9IENvbW1vbk1zcXJ0TWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc3FydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk1zdWJzdXBNaXhpbiA9IGV4cG9ydHMuQ29tbW9uTXN1cE1peGluID0gZXhwb3J0cy5Db21tb25Nc3ViTWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25Nc3ViTWl4aW4oQmFzZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzY3JpcHRDaGlsZFwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXNbdGhpcy5ub2RlLnN1Yl07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgLXRoaXMuZ2V0VigpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICAgICAgfShCYXNlKSksXG4gICAgICAgIF9hLnVzZUlDID0gZmFsc2UsXG4gICAgICAgIF9hO1xufVxuZXhwb3J0cy5Db21tb25Nc3ViTWl4aW4gPSBDb21tb25Nc3ViTWl4aW47XG5mdW5jdGlvbiBDb21tb25Nc3VwTWl4aW4oQmFzZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMi5wcm90b3R5cGUsIFwic2NyaXB0Q2hpbGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1t0aGlzLm5vZGUuc3VwXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY2xhc3NfMi5wcm90b3R5cGUuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmdldEFkanVzdGVkSWMoKSAtICh0aGlzLmJhc2VSZW1vdmVJYyA/IDAgOiB0aGlzLmJhc2VJYyk7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHRoaXMuZ2V0VSgpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzI7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk1zdXBNaXhpbiA9IENvbW1vbk1zdXBNaXhpbjtcbmZ1bmN0aW9uIENvbW1vbk1zdWJzdXBNaXhpbihCYXNlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMywgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuVVZRID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMy5wcm90b3R5cGUsIFwic3ViQ2hpbGRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzW3RoaXMubm9kZS5zdWJdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18zLnByb3RvdHlwZSwgXCJzdXBDaGlsZFwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXNbdGhpcy5ub2RlLnN1cF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xhc3NfMy5wcm90b3R5cGUuY29tcHV0ZUJCb3ggPSBmdW5jdGlvbiAoYmJveCwgcmVjb21wdXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29tcHV0ZSA9PT0gdm9pZCAwKSB7IHJlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgdmFyIGJhc2Vib3ggPSB0aGlzLmJhc2VDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoW3RoaXMuc3ViQ2hpbGQuZ2V0T3V0ZXJCQm94KCksIHRoaXMuc3VwQ2hpbGQuZ2V0T3V0ZXJCQm94KCldLCAyKSwgc3ViYm94ID0gX2FbMF0sIHN1cGJveCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGJib3guZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBiYm94LmFwcGVuZChiYXNlYm94KTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHRoaXMuZ2V0QmFzZVdpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmdldEFkanVzdGVkSWMoKTtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQodGhpcy5nZXRVVlEoKSwgMiksIHUgPSBfYlswXSwgdiA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIGJib3guY29tYmluZShzdWJib3gsIHcsIHYpO1xuICAgICAgICAgICAgICAgIGJib3guY29tYmluZShzdXBib3gsIHcgKyB4LCB1KTtcbiAgICAgICAgICAgICAgICBiYm94LncgKz0gdGhpcy5mb250LnBhcmFtcy5zY3JpcHRzcGFjZTtcbiAgICAgICAgICAgICAgICBiYm94LmNsZWFuKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGFzc18zLnByb3RvdHlwZS5nZXRVVlEgPSBmdW5jdGlvbiAoc3ViYm94LCBzdXBib3gpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViYm94ID09PSB2b2lkIDApIHsgc3ViYm94ID0gdGhpcy5zdWJDaGlsZC5nZXRPdXRlckJCb3goKTsgfVxuICAgICAgICAgICAgICAgIGlmIChzdXBib3ggPT09IHZvaWQgMCkgeyBzdXBib3ggPSB0aGlzLnN1cENoaWxkLmdldE91dGVyQkJveCgpOyB9XG4gICAgICAgICAgICAgICAgdmFyIGJhc2Vib3ggPSB0aGlzLmJhc2VDb3JlLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLlVWUSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVVZRO1xuICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmZvbnQucGFyYW1zO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gMyAqIHRleC5ydWxlX3RoaWNrbmVzcztcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0c2hpZnQgPSB0aGlzLmxlbmd0aDJlbSh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3N1YnNjcmlwdHNoaWZ0JyksIHRleC5zdWIyKTtcbiAgICAgICAgICAgICAgICB2YXIgZHJvcCA9IHRoaXMuYmFzZUNoYXJaZXJvKGJhc2Vib3guZCAqIHRoaXMuYmFzZVNjYWxlICsgdGV4LnN1Yl9kcm9wICogc3ViYm94LnJzY2FsZSk7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKFt0aGlzLmdldFUoKSwgTWF0aC5tYXgoZHJvcCwgc3Vic2NyaXB0c2hpZnQpXSwgMiksIHUgPSBfYVswXSwgdiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHZhciBxID0gKHUgLSBzdXBib3guZCAqIHN1cGJveC5yc2NhbGUpIC0gKHN1YmJveC5oICogc3ViYm94LnJzY2FsZSAtIHYpO1xuICAgICAgICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2ICs9IHQgLSBxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9ICg0IC8gNSkgKiB0ZXgueF9oZWlnaHQgLSAodSAtIHN1cGJveC5kICogc3VwYm94LnJzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdSArPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiAtPSBwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHUgPSBNYXRoLm1heCh0aGlzLmxlbmd0aDJlbSh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3N1cGVyc2NyaXB0c2hpZnQnKSwgdSksIHUpO1xuICAgICAgICAgICAgICAgIHYgPSBNYXRoLm1heCh0aGlzLmxlbmd0aDJlbSh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3N1YnNjcmlwdHNoaWZ0JyksIHYpLCB2KTtcbiAgICAgICAgICAgICAgICBxID0gKHUgLSBzdXBib3guZCAqIHN1cGJveC5yc2NhbGUpIC0gKHN1YmJveC5oICogc3ViYm94LnJzY2FsZSAtIHYpO1xuICAgICAgICAgICAgICAgIHRoaXMuVVZRID0gW3UsIC12LCBxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VVlE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzM7XG4gICAgICAgIH0oQmFzZSkpLFxuICAgICAgICBfYS51c2VJQyA9IGZhbHNlLFxuICAgICAgICBfYTtcbn1cbmV4cG9ydHMuQ29tbW9uTXN1YnN1cE1peGluID0gQ29tbW9uTXN1YnN1cE1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXN1YnN1cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbk10YWJsZU1peGluID0gdm9pZCAwO1xudmFyIEJCb3hfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL0JCb3guanNcIik7XG52YXIgc3RyaW5nX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9zdHJpbmcuanNcIik7XG52YXIgbnVtZXJpY19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvbnVtZXJpYy5qc1wiKTtcbmZ1bmN0aW9uIENvbW1vbk10YWJsZU1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5udW1Db2xzID0gMDtcbiAgICAgICAgICAgIF90aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5wd2lkdGhDZWxscyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMucFdpZHRoID0gMDtcbiAgICAgICAgICAgIF90aGlzLm51bUNvbHMgPSAoMCwgbnVtZXJpY19qc18xLm1heCkoX3RoaXMudGFibGVSb3dzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3cubnVtQ2VsbHM7IH0pKTtcbiAgICAgICAgICAgIF90aGlzLm51bVJvd3MgPSBfdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIF90aGlzLmhhc0xhYmVscyA9IF90aGlzLmNoaWxkTm9kZXMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgcm93KSB7IHJldHVybiB2YWx1ZSB8fCByb3cubm9kZS5pc0tpbmQoJ21sYWJlbGVkdHInKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgX3RoaXMuZmluZENvbnRhaW5lcigpO1xuICAgICAgICAgICAgX3RoaXMuaXNUb3AgPSAhX3RoaXMuY29udGFpbmVyIHx8IChfdGhpcy5jb250YWluZXIubm9kZS5pc0tpbmQoJ21hdGgnKSAmJiAhX3RoaXMuY29udGFpbmVyLnBhcmVudCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNUb3ApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5qYXgudGFibGUgPSBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmdldFBlcmNlbnRhZ2VXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBfdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBfdGhpcy5mcmFtZSA9IGF0dHJpYnV0ZXMuZ2V0KCdmcmFtZScpICE9PSAnbm9uZSc7XG4gICAgICAgICAgICBfdGhpcy5mTGluZSA9IChfdGhpcy5mcmFtZSAmJiBhdHRyaWJ1dGVzLmdldCgnZnJhbWUnKSA/IC4wNyA6IDApO1xuICAgICAgICAgICAgX3RoaXMuZlNwYWNlID0gKF90aGlzLmZyYW1lID8gX3RoaXMuY29udmVydExlbmd0aHMoX3RoaXMuZ2V0QXR0cmlidXRlQXJyYXkoJ2ZyYW1lc3BhY2luZycpKSA6IFswLCAwXSk7XG4gICAgICAgICAgICBfdGhpcy5jU3BhY2UgPSBfdGhpcy5jb252ZXJ0TGVuZ3RocyhfdGhpcy5nZXRDb2x1bW5BdHRyaWJ1dGVzKCdjb2x1bW5zcGFjaW5nJykpO1xuICAgICAgICAgICAgX3RoaXMuclNwYWNlID0gX3RoaXMuY29udmVydExlbmd0aHMoX3RoaXMuZ2V0Um93QXR0cmlidXRlcygncm93c3BhY2luZycpKTtcbiAgICAgICAgICAgIF90aGlzLmNMaW5lcyA9IF90aGlzLmdldENvbHVtbkF0dHJpYnV0ZXMoJ2NvbHVtbmxpbmVzJykubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAoeCA9PT0gJ25vbmUnID8gMCA6IC4wNyk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuckxpbmVzID0gX3RoaXMuZ2V0Um93QXR0cmlidXRlcygncm93bGluZXMnKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh4ID09PSAnbm9uZScgPyAwIDogLjA3KTsgfSk7XG4gICAgICAgICAgICBfdGhpcy5jV2lkdGhzID0gX3RoaXMuZ2V0Q29sdW1uV2lkdGhzKCk7XG4gICAgICAgICAgICBfdGhpcy5zdHJldGNoUm93cygpO1xuICAgICAgICAgICAgX3RoaXMuc3RyZXRjaENvbHVtbnMoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwidGFibGVSb3dzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZpbmRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIChwYXJlbnQubm9kZS5ub3RQYXJlbnQgfHwgcGFyZW50Lm5vZGUuaXNLaW5kKCdtcm93JykpKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckkgPSBub2RlLm5vZGUuY2hpbGRQb3NpdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRQZXJjZW50YWdlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJib3gucHdpZHRoID0gQkJveF9qc18xLkJCb3guZnVsbFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCd3aWR0aCcpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgc3RyaW5nX2pzXzEuaXNQZXJjZW50KSh3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYm94LnB3aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc3RyZXRjaFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXF1YWwgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2VxdWFscm93cycpO1xuICAgICAgICAgICAgdmFyIEhEID0gKGVxdWFsID8gdGhpcy5nZXRFcXVhbFJvd0hlaWdodCgpIDogMCk7XG4gICAgICAgICAgICB2YXIgX2EgPSAoZXF1YWwgPyB0aGlzLmdldFRhYmxlRGF0YSgpIDogeyBIOiBbMF0sIEQ6IFswXSB9KSwgSCA9IF9hLkgsIEQgPSBfYS5EO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLnRhYmxlUm93cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1Sb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGQgPSAoZXF1YWwgPyBbKEhEICsgSFtpXSAtIERbaV0pIC8gMiwgKEhEIC0gSFtpXSArIERbaV0pIC8gMl0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICByb3dzW2ldLnN0cmV0Y2hDaGlsZHJlbihoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnN0cmV0Y2hDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUNvbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9ICh0eXBlb2YgdGhpcy5jV2lkdGhzW2ldID09PSAnbnVtYmVyJyA/IHRoaXMuY1dpZHRoc1tpXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZXRjaENvbHVtbihpLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnN0cmV0Y2hDb2x1bW4gPSBmdW5jdGlvbiAoaSwgVykge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2IsIGVfMywgX2M7XG4gICAgICAgICAgICB2YXIgc3RyZXRjaHkgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSBfX3ZhbHVlcyh0aGlzLnRhYmxlUm93cyksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5nZXRDaGlsZChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNlbGwuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5zdHJldGNoLmRpciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmNhblN0cmV0Y2goMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJldGNoeS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2UgJiYgIV9lLmRvbmUgJiYgKF9hID0gX2QucmV0dXJuKSkgX2EuY2FsbChfZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb3VudCA9IHN0cmV0Y2h5Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBub2RlQ291bnQgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvdW50ICYmIG5vZGVDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoVyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBXID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbCA9IChjb3VudCA+IDEgJiYgY291bnQgPT09IG5vZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IF9fdmFsdWVzKHRoaXMudGFibGVSb3dzKSwgX2cgPSBfZi5uZXh0KCk7ICFfZy5kb25lOyBfZyA9IF9mLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBfZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5nZXRDaGlsZChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjZWxsLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub1N0cmV0Y2ggPSAoY2hpbGQuc3RyZXRjaC5kaXIgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsIHx8IG5vU3RyZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBjaGlsZC5nZXRCQm94KG5vU3RyZXRjaCkudztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ID4gVykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFcgPSB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3RyZXRjaHlfMSA9IF9fdmFsdWVzKHN0cmV0Y2h5KSwgc3RyZXRjaHlfMV8xID0gc3RyZXRjaHlfMS5uZXh0KCk7ICFzdHJldGNoeV8xXzEuZG9uZTsgc3RyZXRjaHlfMV8xID0gc3RyZXRjaHlfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0cmV0Y2h5XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvcmVNTygpLmdldFN0cmV0Y2hlZFZhcmlhbnQoW1ddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2h5XzFfMSAmJiAhc3RyZXRjaHlfMV8xLmRvbmUgJiYgKF9jID0gc3RyZXRjaHlfMS5yZXR1cm4pKSBfYy5jYWxsKHN0cmV0Y2h5XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFRhYmxlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEggPSBuZXcgQXJyYXkodGhpcy5udW1Sb3dzKS5maWxsKDApO1xuICAgICAgICAgICAgdmFyIEQgPSBuZXcgQXJyYXkodGhpcy5udW1Sb3dzKS5maWxsKDApO1xuICAgICAgICAgICAgdmFyIFcgPSBuZXcgQXJyYXkodGhpcy5udW1Db2xzKS5maWxsKDApO1xuICAgICAgICAgICAgdmFyIE5IID0gbmV3IEFycmF5KHRoaXMubnVtUm93cyk7XG4gICAgICAgICAgICB2YXIgTkQgPSBuZXcgQXJyYXkodGhpcy5udW1Sb3dzKTtcbiAgICAgICAgICAgIHZhciBMVyA9IFswXTtcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy50YWJsZVJvd3M7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgTSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHJvd3Nbal07XG4gICAgICAgICAgICAgICAgdmFyIGFsaWduID0gcm93Lm5vZGUuYXR0cmlidXRlcy5nZXQoJ3Jvd2FsaWduJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cubnVtQ2VsbHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5nZXRDaGlsZChpKTtcbiAgICAgICAgICAgICAgICAgICAgTSA9IHRoaXMudXBkYXRlSERXKGNlbGwsIGksIGosIGFsaWduLCBILCBELCBXLCBNKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRQV2lkdGhDZWxsKGNlbGwsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBOSFtqXSA9IEhbal07XG4gICAgICAgICAgICAgICAgTkRbal0gPSBEW2pdO1xuICAgICAgICAgICAgICAgIGlmIChyb3cubGFiZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBNID0gdGhpcy51cGRhdGVIRFcocm93LmNoaWxkTm9kZXNbMF0sIDAsIGosIGFsaWduLCBILCBELCBMVywgTSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kSEQoaiwgSCwgRCwgTSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRIRChqLCBOSCwgTkQsIE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEwgPSBMV1swXTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHsgSDogSCwgRDogRCwgVzogVywgTkg6IE5ILCBORDogTkQsIEw6IEwgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnVwZGF0ZUhEVyA9IGZ1bmN0aW9uIChjZWxsLCBpLCBqLCBhbGlnbiwgSCwgRCwgVywgTSkge1xuICAgICAgICAgICAgdmFyIF9hID0gY2VsbC5nZXRCQm94KCksIGggPSBfYS5oLCBkID0gX2EuZCwgdyA9IF9hLnc7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBjZWxsLnBhcmVudC5iYm94LnJzY2FsZTtcbiAgICAgICAgICAgIGlmIChjZWxsLnBhcmVudC5iYm94LnJzY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGggKj0gc2NhbGU7XG4gICAgICAgICAgICAgICAgZCAqPSBzY2FsZTtcbiAgICAgICAgICAgICAgICB3ICo9IHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5nZXRQcm9wZXJ0eSgndXNlSGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaCA8IC43NSlcbiAgICAgICAgICAgICAgICAgICAgaCA9IC43NTtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IC4yNSlcbiAgICAgICAgICAgICAgICAgICAgZCA9IC4yNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtID0gMDtcbiAgICAgICAgICAgIGFsaWduID0gY2VsbC5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdyb3dhbGlnbicpIHx8IGFsaWduO1xuICAgICAgICAgICAgaWYgKGFsaWduICE9PSAnYmFzZWxpbmUnICYmIGFsaWduICE9PSAnYXhpcycpIHtcbiAgICAgICAgICAgICAgICBtID0gaCArIGQ7XG4gICAgICAgICAgICAgICAgaCA9IGQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGggPiBIW2pdKVxuICAgICAgICAgICAgICAgIEhbal0gPSBoO1xuICAgICAgICAgICAgaWYgKGQgPiBEW2pdKVxuICAgICAgICAgICAgICAgIERbal0gPSBkO1xuICAgICAgICAgICAgaWYgKG0gPiBNKVxuICAgICAgICAgICAgICAgIE0gPSBtO1xuICAgICAgICAgICAgaWYgKFcgJiYgdyA+IFdbaV0pXG4gICAgICAgICAgICAgICAgV1tpXSA9IHc7XG4gICAgICAgICAgICByZXR1cm4gTTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZXh0ZW5kSEQgPSBmdW5jdGlvbiAoaSwgSCwgRCwgTSkge1xuICAgICAgICAgICAgdmFyIGQgPSAoTSAtIChIW2ldICsgRFtpXSkpIC8gMjtcbiAgICAgICAgICAgIGlmIChkIDwgLjAwMDAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIEhbaV0gKz0gZDtcbiAgICAgICAgICAgIERbaV0gKz0gZDtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUucmVjb3JkUFdpZHRoQ2VsbCA9IGZ1bmN0aW9uIChjZWxsLCBpKSB7XG4gICAgICAgICAgICBpZiAoY2VsbC5jaGlsZE5vZGVzWzBdICYmIGNlbGwuY2hpbGROb2Rlc1swXS5nZXRCQm94KCkucHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wd2lkdGhDZWxscy5wdXNoKFtjZWxsLCBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIF9yZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChfcmVjb21wdXRlID09PSB2b2lkIDApIHsgX3JlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFRhYmxlRGF0YSgpLCBIID0gX2EuSCwgRCA9IF9hLkQ7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0LCB3aWR0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2VxdWFscm93cycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIEhEID0gdGhpcy5nZXRFcXVhbFJvd0hlaWdodCgpO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9ICgwLCBudW1lcmljX2pzXzEuc3VtKShbXS5jb25jYXQodGhpcy5yTGluZXMsIHRoaXMuclNwYWNlKSkgKyBIRCAqIHRoaXMubnVtUm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9ICgwLCBudW1lcmljX2pzXzEuc3VtKShILmNvbmNhdChELCB0aGlzLnJMaW5lcywgdGhpcy5yU3BhY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlaWdodCArPSAyICogKHRoaXMuZkxpbmUgKyB0aGlzLmZTcGFjZVsxXSk7XG4gICAgICAgICAgICB2YXIgQ1cgPSB0aGlzLmdldENvbXB1dGVkV2lkdGhzKCk7XG4gICAgICAgICAgICB3aWR0aCA9ICgwLCBudW1lcmljX2pzXzEuc3VtKShDVy5jb25jYXQodGhpcy5jTGluZXMsIHRoaXMuY1NwYWNlKSkgKyAyICogKHRoaXMuZkxpbmUgKyB0aGlzLmZTcGFjZVswXSk7XG4gICAgICAgICAgICB2YXIgdyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmICh3ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoMmVtKHcsIDApICsgMiAqIHRoaXMuZkxpbmUsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZCh0aGlzLmdldEJCb3hIRChoZWlnaHQpLCAyKSwgaCA9IF9iWzBdLCBkID0gX2JbMV07XG4gICAgICAgICAgICBiYm94LmggPSBoO1xuICAgICAgICAgICAgYmJveC5kID0gZDtcbiAgICAgICAgICAgIGJib3gudyA9IHdpZHRoO1xuICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKHRoaXMuZ2V0QkJveExSKCksIDIpLCBMID0gX2NbMF0sIFIgPSBfY1sxXTtcbiAgICAgICAgICAgIGJib3guTCA9IEw7XG4gICAgICAgICAgICBiYm94LlIgPSBSO1xuICAgICAgICAgICAgaWYgKCEoMCwgc3RyaW5nX2pzXzEuaXNQZXJjZW50KSh3KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29sdW1uUFdpZHRocygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXRDaGlsZFBXaWR0aHMgPSBmdW5jdGlvbiAoX3JlY29tcHV0ZSwgY3dpZHRoLCBfY2xlYXIpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmICghKDAsIHN0cmluZ19qc18xLmlzUGVyY2VudCkod2lkdGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJib3gucHdpZHRoID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYmJveC5wd2lkdGggPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuYmJveCwgdyA9IF9hLncsIEwgPSBfYS5MLCBSID0gX2EuUjtcbiAgICAgICAgICAgIHZhciBsYWJlbEluV2lkdGggPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2RhdGEtd2lkdGgtaW5jbHVkZXMtbGFiZWwnKTtcbiAgICAgICAgICAgIHZhciBXID0gTWF0aC5tYXgodywgdGhpcy5sZW5ndGgyZW0od2lkdGgsIE1hdGgubWF4KGN3aWR0aCwgTCArIHcgKyBSKSkpIC0gKGxhYmVsSW5XaWR0aCA/IEwgKyBSIDogMCk7XG4gICAgICAgICAgICB2YXIgY29scyA9ICh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2VxdWFsY29sdW1ucycpID9cbiAgICAgICAgICAgICAgICBBcnJheSh0aGlzLm51bUNvbHMpLmZpbGwodGhpcy5wZXJjZW50KDEgLyBNYXRoLm1heCgxLCB0aGlzLm51bUNvbHMpKSkgOlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29sdW1uQXR0cmlidXRlcygnY29sdW1ud2lkdGgnLCAwKSk7XG4gICAgICAgICAgICB0aGlzLmNXaWR0aHMgPSB0aGlzLmdldENvbHVtbldpZHRoc0ZpeGVkKGNvbHMsIFcpO1xuICAgICAgICAgICAgdmFyIENXID0gdGhpcy5nZXRDb21wdXRlZFdpZHRocygpO1xuICAgICAgICAgICAgdGhpcy5wV2lkdGggPSAoMCwgbnVtZXJpY19qc18xLnN1bSkoQ1cuY29uY2F0KHRoaXMuY0xpbmVzLCB0aGlzLmNTcGFjZSkpICsgMiAqICh0aGlzLmZMaW5lICsgdGhpcy5mU3BhY2VbMF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJib3gudyA9IHRoaXMucFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDb2x1bW5QV2lkdGhzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wV2lkdGggIT09IHcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnZhbGlkYXRlQkJveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucFdpZHRoICE9PSB3O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXRDb2x1bW5QV2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgICAgICB2YXIgVyA9IHRoaXMuY1dpZHRocztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnB3aWR0aENlbGxzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2QgPSBfX3JlYWQoX2MudmFsdWUsIDIpLCBjZWxsID0gX2RbMF0sIGkgPSBfZFsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuc2V0Q2hpbGRQV2lkdGhzKGZhbHNlLCBXW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5pbnZhbGlkYXRlQkJveCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEJCb3hIRCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmdldEFsaWdubWVudFJvdygpLCAyKSwgYWxpZ24gPSBfYVswXSwgcm93ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmZvbnQucGFyYW1zLmF4aXNfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBoMiA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIEhEID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IFswLCBoZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFtoMiwgaDJdLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IFtoZWlnaHQsIDBdLFxuICAgICAgICAgICAgICAgICAgICBiYXNlbGluZTogW2gyLCBoMl0sXG4gICAgICAgICAgICAgICAgICAgIGF4aXM6IFtoMiArIGEsIGgyIC0gYV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBIRFthbGlnbl0gfHwgW2gyLCBoMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0VmVydGljYWxQb3NpdGlvbihyb3csIGFsaWduKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ksIGhlaWdodCAtIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRCQm94TFIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIHZhciBzaWRlID0gYXR0cmlidXRlcy5nZXQoJ3NpZGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5nZXRQYWRBbGlnblNoaWZ0KHNpZGUpLCAyKSwgcGFkID0gX2FbMF0sIGFsaWduID0gX2FbMV07XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMuaGFzTGFiZWxzICYmICEhYXR0cmlidXRlcy5nZXQoJ2RhdGEtd2lkdGgtaW5jbHVkZXMtbGFiZWwnKTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxzICYmIHRoaXMuZnJhbWUgJiYgdGhpcy5mU3BhY2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkIC09IHRoaXMuZlNwYWNlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGFsaWduID09PSAnY2VudGVyJyAmJiAhbGFiZWxzID8gW3BhZCwgcGFkXSA6XG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPT09ICdsZWZ0JyA/IFtwYWQsIDBdIDogWzAsIHBhZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0UGFkQWxpZ25TaGlmdCA9IGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICB2YXIgTCA9IHRoaXMuZ2V0VGFibGVEYXRhKCkuTDtcbiAgICAgICAgICAgIHZhciBzZXAgPSB0aGlzLmxlbmd0aDJlbSh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ21pbmxhYmVsc3BhY2luZycpKTtcbiAgICAgICAgICAgIHZhciBwYWQgPSBMICsgc2VwO1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKCh0aGlzLnN0eWxlcyA9PSBudWxsID8gWycnLCAnJ10gOlxuICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5nZXQoJ3BhZGRpbmctbGVmdCcpLCB0aGlzLnN0eWxlcy5nZXQoJ3BhZGRpbmctcmlnaHQnKV0pLCAyKSwgbHBhZCA9IF9hWzBdLCBycGFkID0gX2FbMV07XG4gICAgICAgICAgICBpZiAobHBhZCB8fCBycGFkKSB7XG4gICAgICAgICAgICAgICAgcGFkID0gTWF0aC5tYXgocGFkLCB0aGlzLmxlbmd0aDJlbShscGFkIHx8ICcwJyksIHRoaXMubGVuZ3RoMmVtKHJwYWQgfHwgJzAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQodGhpcy5nZXRBbGlnblNoaWZ0KCksIDIpLCBhbGlnbiA9IF9iWzBdLCBzaGlmdCA9IF9iWzFdO1xuICAgICAgICAgICAgaWYgKGFsaWduID09PSBzaWRlKSB7XG4gICAgICAgICAgICAgICAgc2hpZnQgPSAoc2lkZSA9PT0gJ2xlZnQnID8gTWF0aC5tYXgocGFkLCBzaGlmdCkgLSBwYWQgOiBNYXRoLm1pbigtcGFkLCBzaGlmdCkgKyBwYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtwYWQsIGFsaWduLCBzaGlmdF07XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEFsaWduU2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNUb3AgPyBfc3VwZXIucHJvdG90eXBlLmdldEFsaWduU2hpZnQuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgICAgICAgW3RoaXMuY29udGFpbmVyLmdldENoaWxkQWxpZ24odGhpcy5jb250YWluZXJJKSwgMF0pO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBXaWR0aCB8fCB0aGlzLmdldEJCb3goKS53O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRFcXVhbFJvd0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0VGFibGVEYXRhKCksIEggPSBfYS5ILCBEID0gX2EuRDtcbiAgICAgICAgICAgIHZhciBIRCA9IEFycmF5LmZyb20oSC5rZXlzKCkpLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gSFtpXSArIERbaV07IH0pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIEhEKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRXaWR0aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIFcgPSB0aGlzLmdldFRhYmxlRGF0YSgpLlc7XG4gICAgICAgICAgICB2YXIgQ1cgPSBBcnJheS5mcm9tKFcua2V5cygpKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBfdGhpcy5jV2lkdGhzW2ldID09PSAnbnVtYmVyJyA/IF90aGlzLmNXaWR0aHNbaV0gOiBXW2ldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnZXF1YWxjb2x1bW5zJykpIHtcbiAgICAgICAgICAgICAgICBDVyA9IEFycmF5KENXLmxlbmd0aCkuZmlsbCgoMCwgbnVtZXJpY19qc18xLm1heCkoQ1cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDVztcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0Q29sdW1uV2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnZXF1YWxjb2x1bW5zJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFcXVhbENvbHVtbnMod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN3aWR0aHMgPSB0aGlzLmdldENvbHVtbkF0dHJpYnV0ZXMoJ2NvbHVtbndpZHRoJywgMCk7XG4gICAgICAgICAgICBpZiAod2lkdGggPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbldpZHRoc0F1dG8oc3dpZHRocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIHN0cmluZ19qc18xLmlzUGVyY2VudCkod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uV2lkdGhzUGVyY2VudChzd2lkdGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbldpZHRoc0ZpeGVkKHN3aWR0aHMsIHRoaXMubGVuZ3RoMmVtKHdpZHRoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEVxdWFsQ29sdW1ucyA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICAgICAgdmFyIG4gPSBNYXRoLm1heCgxLCB0aGlzLm51bUNvbHMpO1xuICAgICAgICAgICAgdmFyIGN3aWR0aDtcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgdmFyIFcgPSB0aGlzLmdldFRhYmxlRGF0YSgpLlc7XG4gICAgICAgICAgICAgICAgY3dpZHRoID0gKDAsIG51bWVyaWNfanNfMS5tYXgpKFcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHN0cmluZ19qc18xLmlzUGVyY2VudCkod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgY3dpZHRoID0gdGhpcy5wZXJjZW50KDEgLyBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gKDAsIG51bWVyaWNfanNfMS5zdW0pKFtdLmNvbmNhdCh0aGlzLmNMaW5lcywgdGhpcy5jU3BhY2UpKSArIDIgKiB0aGlzLmZTcGFjZVswXTtcbiAgICAgICAgICAgICAgICBjd2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aDJlbSh3aWR0aCkgLSB3KSAvIG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkodGhpcy5udW1Db2xzKS5maWxsKGN3aWR0aCk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldENvbHVtbldpZHRoc0F1dG8gPSBmdW5jdGlvbiAoc3dpZHRocykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBzd2lkdGhzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSAnYXV0bycgfHwgeCA9PT0gJ2ZpdCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgc3RyaW5nX2pzXzEuaXNQZXJjZW50KSh4KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxlbmd0aDJlbSh4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRDb2x1bW5XaWR0aHNQZXJjZW50ID0gZnVuY3Rpb24gKHN3aWR0aHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaGFzRml0ID0gc3dpZHRocy5pbmRleE9mKCdmaXQnKSA+PSAwO1xuICAgICAgICAgICAgdmFyIFcgPSAoaGFzRml0ID8gdGhpcy5nZXRUYWJsZURhdGEoKSA6IHsgVzogbnVsbCB9KS5XO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3dpZHRocy5rZXlzKCkpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc3dpZHRoc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gJ2ZpdCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaGFzRml0ID8gV1tpXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgc3RyaW5nX2pzXzEuaXNQZXJjZW50KSh4KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxlbmd0aDJlbSh4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRDb2x1bW5XaWR0aHNGaXhlZCA9IGZ1bmN0aW9uIChzd2lkdGhzLCB3aWR0aCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gQXJyYXkuZnJvbShzd2lkdGhzLmtleXMoKSk7XG4gICAgICAgICAgICB2YXIgZml0ID0gaW5kaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHN3aWR0aHNbaV0gPT09ICdmaXQnOyB9KTtcbiAgICAgICAgICAgIHZhciBhdXRvID0gaW5kaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHN3aWR0aHNbaV0gPT09ICdhdXRvJzsgfSk7XG4gICAgICAgICAgICB2YXIgbiA9IGZpdC5sZW5ndGggfHwgYXV0by5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgVyA9IChuID8gdGhpcy5nZXRUYWJsZURhdGEoKSA6IHsgVzogbnVsbCB9KS5XO1xuICAgICAgICAgICAgdmFyIGN3aWR0aCA9IHdpZHRoIC0gKDAsIG51bWVyaWNfanNfMS5zdW0pKFtdLmNvbmNhdCh0aGlzLmNMaW5lcywgdGhpcy5jU3BhY2UpKSAtIDIgKiB0aGlzLmZTcGFjZVswXTtcbiAgICAgICAgICAgIHZhciBkdyA9IGN3aWR0aDtcbiAgICAgICAgICAgIGluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc3dpZHRoc1tpXTtcbiAgICAgICAgICAgICAgICBkdyAtPSAoeCA9PT0gJ2ZpdCcgfHwgeCA9PT0gJ2F1dG8nID8gV1tpXSA6IF90aGlzLmxlbmd0aDJlbSh4LCBjd2lkdGgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGZ3ID0gKG4gJiYgZHcgPiAwID8gZHcgLyBuIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN3aWR0aHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHggPT09ICdmaXQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gV1tpXSArIGZ3O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBXW2ldICsgKGZpdC5sZW5ndGggPT09IDAgPyBmdyA6IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5sZW5ndGgyZW0oeCwgY3dpZHRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRWZXJ0aWNhbFBvc2l0aW9uID0gZnVuY3Rpb24gKGksIGFsaWduKSB7XG4gICAgICAgICAgICB2YXIgZXF1YWwgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2VxdWFscm93cycpO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUYWJsZURhdGEoKSwgSCA9IF9hLkgsIEQgPSBfYS5EO1xuICAgICAgICAgICAgdmFyIEhEID0gKGVxdWFsID8gdGhpcy5nZXRFcXVhbFJvd0hlaWdodCgpIDogMCk7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSB0aGlzLmdldFJvd0hhbGZTcGFjaW5nKCk7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuZkxpbmU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgIHkgKz0gc3BhY2Vbal0gKyAoZXF1YWwgPyBIRCA6IEhbal0gKyBEW2pdKSArIHNwYWNlW2ogKyAxXSArIHRoaXMuckxpbmVzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKChlcXVhbCA/IFsoSEQgKyBIW2ldIC0gRFtpXSkgLyAyLCAoSEQgLSBIW2ldICsgRFtpXSkgLyAyXSA6IFtIW2ldLCBEW2ldXSksIDIpLCBoID0gX2JbMF0sIGQgPSBfYlsxXTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGNlbnRlcjogc3BhY2VbaV0gKyAoaCArIGQpIC8gMixcbiAgICAgICAgICAgICAgICBib3R0b206IHNwYWNlW2ldICsgaCArIGQgKyBzcGFjZVtpICsgMV0sXG4gICAgICAgICAgICAgICAgYmFzZWxpbmU6IHNwYWNlW2ldICsgaCxcbiAgICAgICAgICAgICAgICBheGlzOiBzcGFjZVtpXSArIGggLSAuMjVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB5ICs9IG9mZnNldFthbGlnbl0gfHwgMDtcbiAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRFbUhhbGZTcGFjaW5nID0gZnVuY3Rpb24gKGZzcGFjZSwgc3BhY2UsIHNjYWxlKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICAgICAgICAgIHZhciBmc3BhY2VFbSA9IHRoaXMuZW0oZnNwYWNlICogc2NhbGUpO1xuICAgICAgICAgICAgdmFyIHNwYWNlRW0gPSB0aGlzLmFkZEVtKHNwYWNlLCAyIC8gc2NhbGUpO1xuICAgICAgICAgICAgc3BhY2VFbS51bnNoaWZ0KGZzcGFjZUVtKTtcbiAgICAgICAgICAgIHNwYWNlRW0ucHVzaChmc3BhY2VFbSk7XG4gICAgICAgICAgICByZXR1cm4gc3BhY2VFbTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0Um93SGFsZlNwYWNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSB0aGlzLnJTcGFjZS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggLyAyOyB9KTtcbiAgICAgICAgICAgIHNwYWNlLnVuc2hpZnQodGhpcy5mU3BhY2VbMV0pO1xuICAgICAgICAgICAgc3BhY2UucHVzaCh0aGlzLmZTcGFjZVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gc3BhY2U7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldENvbHVtbkhhbGZTcGFjaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gdGhpcy5jU3BhY2UubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IC8gMjsgfSk7XG4gICAgICAgICAgICBzcGFjZS51bnNoaWZ0KHRoaXMuZlNwYWNlWzBdKTtcbiAgICAgICAgICAgIHNwYWNlLnB1c2godGhpcy5mU3BhY2VbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHNwYWNlO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRBbGlnbm1lbnRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoKDAsIHN0cmluZ19qc18xLnNwbGl0KSh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2FsaWduJykpLCAyKSwgYWxpZ24gPSBfYVswXSwgcm93ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAocm93ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbGlnbiwgbnVsbF07XG4gICAgICAgICAgICB2YXIgaSA9IHBhcnNlSW50KHJvdyk7XG4gICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgICAgaSArPSB0aGlzLm51bVJvd3MgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIFthbGlnbiwgaSA8IDEgfHwgaSA+IHRoaXMubnVtUm93cyA/IG51bGwgOiBpIC0gMV07XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldENvbHVtbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMTsgfVxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm51bUNvbHMgLSBpO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmdldEF0dHJpYnV0ZUFycmF5KG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGNvbHVtbnMubGVuZ3RoIDwgbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMuc3BsaWNlKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFJvd0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMTsgfVxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm51bVJvd3MgLSBpO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLmdldEF0dHJpYnV0ZUFycmF5KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHJvd3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKHJvd3MubGVuZ3RoIDwgbikge1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3dzW3Jvd3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gbikge1xuICAgICAgICAgICAgICAgIHJvd3Muc3BsaWNlKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEF0dHJpYnV0ZUFycmF5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXREZWZhdWx0KG5hbWUpXTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgc3RyaW5nX2pzXzEuc3BsaXQpKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYWRkRW0gPSBmdW5jdGlvbiAobGlzdCwgbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChuID09PSB2b2lkIDApIHsgbiA9IDE7IH1cbiAgICAgICAgICAgIGlmICghbGlzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuZW0oeCAvIG4pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY29udmVydExlbmd0aHMgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghbGlzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMubGVuZ3RoMmVtKHgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk10YWJsZU1peGluID0gQ29tbW9uTXRhYmxlTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25NdGRNaXhpbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIENvbW1vbk10ZE1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcImZpeGVzUFdpZHRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaW52YWxpZGF0ZUJCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJib3hDb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRXcmFwV2lkdGggPSBmdW5jdGlvbiAoX2opIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMucGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5ub2RlLmNoaWxkUG9zaXRpb24oKSAtIChyb3cubGFiZWxlZCA/IDEgOiAwKTtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mICh0YWJsZS5jV2lkdGhzW2ldKSA9PT0gJ251bWJlcicgPyB0YWJsZS5jV2lkdGhzW2ldIDogdGFibGUuZ2V0VGFibGVEYXRhKCkuV1tpXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldENoaWxkQWxpZ24gPSBmdW5jdGlvbiAoX2kpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2NvbHVtbmFsaWduJyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NdGRNaXhpbiA9IENvbW1vbk10ZE1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXRkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTXRleHRNaXhpbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIENvbW1vbk10ZXh0TWl4aW4oQmFzZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFZhcmlhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmpheC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5qYXgubWF0aC5vdXRwdXREYXRhO1xuICAgICAgICAgICAgICAgIHZhciBtZXJyb3IgPSAoKCEhZGF0YS5tZXJyb3JGYW1pbHkgfHwgISFvcHRpb25zLm1lcnJvckZvbnQpICYmIHRoaXMubm9kZS5QYXJlbnQuaXNLaW5kKCdtZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEhZGF0YS5tdGV4dEZhbWlseSB8fCAhIW9wdGlvbnMubXRleHRGb250IHx8IG1lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFudCA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnbWF0aHZhcmlhbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnQgPSB0aGlzLmNvbnN0cnVjdG9yLklOSEVSSVRGT05UU1t2YXJpYW50XSB8fCB0aGlzLmpheC5mb250LmdldENzc0ZvbnQodmFyaWFudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYW1pbHkgPSBmb250WzBdIHx8IChtZXJyb3IgPyBkYXRhLm1lcnJvckZhbWlseSB8fCBvcHRpb25zLm1lcnJvckZvbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tdGV4dEZhbWlseSB8fCBvcHRpb25zLm10ZXh0Rm9udCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFudCA9IHRoaXMuZXhwbGljaXRWYXJpYW50KGZhbWlseSwgZm9udFsyXSA/ICdib2xkJyA6ICcnLCBmb250WzFdID8gJ2l0YWxpYycgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5nZXRWYXJpYW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICAgIH0oQmFzZSkpLFxuICAgICAgICBfYS5JTkhFUklURk9OVFMgPSB7XG4gICAgICAgICAgICBub3JtYWw6IFsnJywgZmFsc2UsIGZhbHNlXSxcbiAgICAgICAgICAgIGJvbGQ6IFsnJywgZmFsc2UsIHRydWVdLFxuICAgICAgICAgICAgaXRhbGljOiBbJycsIHRydWUsIGZhbHNlXSxcbiAgICAgICAgICAgICdib2xkLWl0YWxpYyc6IFsnJywgdHJ1ZSwgdHJ1ZV1cbiAgICAgICAgfSxcbiAgICAgICAgX2E7XG59XG5leHBvcnRzLkNvbW1vbk10ZXh0TWl4aW4gPSBDb21tb25NdGV4dE1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25NbGFiZWxlZHRyTWl4aW4gPSBleHBvcnRzLkNvbW1vbk10ck1peGluID0gdm9pZCAwO1xuZnVuY3Rpb24gQ29tbW9uTXRyTWl4aW4oQmFzZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwiZml4ZXNQV2lkdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwibnVtQ2VsbHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJsYWJlbGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInRhYmxlQ2VsbHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0Q2hpbGRCQm94ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gY2VsbC5nZXRCQm94KCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zdHJldGNoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoSEQpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jO1xuICAgICAgICAgICAgaWYgKEhEID09PSB2b2lkIDApIHsgSEQgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgc3RyZXRjaHkgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9ICh0aGlzLmxhYmVsZWQgPyB0aGlzLmNoaWxkTm9kZXMuc2xpY2UoMSkgOiB0aGlzLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGlsZHJlbl8xID0gX192YWx1ZXMoY2hpbGRyZW4pLCBjaGlsZHJlbl8xXzEgPSBjaGlsZHJlbl8xLm5leHQoKTsgIWNoaWxkcmVuXzFfMS5kb25lOyBjaGlsZHJlbl8xXzEgPSBjaGlsZHJlbl8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXRkID0gY2hpbGRyZW5fMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBtdGQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNhblN0cmV0Y2goMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmV0Y2h5LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbl8xXzEgJiYgIWNoaWxkcmVuXzFfMS5kb25lICYmIChfYSA9IGNoaWxkcmVuXzEucmV0dXJuKSkgX2EuY2FsbChjaGlsZHJlbl8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvdW50ID0gc3RyZXRjaHkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG5vZGVDb3VudCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY291bnQgJiYgbm9kZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChIRCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgSCA9IDAsIEQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsID0gKGNvdW50ID4gMSAmJiBjb3VudCA9PT0gbm9kZUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkcmVuXzIgPSBfX3ZhbHVlcyhjaGlsZHJlbiksIGNoaWxkcmVuXzJfMSA9IGNoaWxkcmVuXzIubmV4dCgpOyAhY2hpbGRyZW5fMl8xLmRvbmU7IGNoaWxkcmVuXzJfMSA9IGNoaWxkcmVuXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG10ZCA9IGNoaWxkcmVuXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBtdGQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9TdHJldGNoID0gKGNoaWxkLnN0cmV0Y2guZGlyID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsIHx8IG5vU3RyZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2QgPSBjaGlsZC5nZXRCQm94KG5vU3RyZXRjaCksIGggPSBfZC5oLCBkID0gX2QuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPiBIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEQgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5fMl8xICYmICFjaGlsZHJlbl8yXzEuZG9uZSAmJiAoX2IgPSBjaGlsZHJlbl8yLnJldHVybikpIF9iLmNhbGwoY2hpbGRyZW5fMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSEQgPSBbSCwgRF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHN0cmV0Y2h5XzEgPSBfX3ZhbHVlcyhzdHJldGNoeSksIHN0cmV0Y2h5XzFfMSA9IHN0cmV0Y2h5XzEubmV4dCgpOyAhc3RyZXRjaHlfMV8xLmRvbmU7IHN0cmV0Y2h5XzFfMSA9IHN0cmV0Y2h5XzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBzdHJldGNoeV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb3JlTU8oKS5nZXRTdHJldGNoZWRWYXJpYW50KEhEKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2h5XzFfMSAmJiAhc3RyZXRjaHlfMV8xLmRvbmUgJiYgKF9jID0gc3RyZXRjaHlfMS5yZXR1cm4pKSBfYy5jYWxsKHN0cmV0Y2h5XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25NdHJNaXhpbiA9IENvbW1vbk10ck1peGluO1xuZnVuY3Rpb24gQ29tbW9uTWxhYmVsZWR0ck1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzIucHJvdG90eXBlLCBcIm51bUNlbGxzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18yLnByb3RvdHlwZSwgXCJsYWJlbGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMi5wcm90b3R5cGUsIFwidGFibGVDZWxsc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjbGFzc18yLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzW2kgKyAxXTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMi5wcm90b3R5cGUuZ2V0Q2hpbGRCQm94ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gY2VsbC5nZXRCQm94KCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMjtcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uTWxhYmVsZWR0ck1peGluID0gQ29tbW9uTWxhYmVsZWR0ck1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXRyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uTXVuZGVyb3Zlck1peGluID0gZXhwb3J0cy5Db21tb25Nb3Zlck1peGluID0gZXhwb3J0cy5Db21tb25NdW5kZXJNaXhpbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIENvbW1vbk11bmRlck1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zdHJldGNoQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2NyaXB0Q2hpbGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1t0aGlzLm5vZGUudW5kZXJdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jb21wdXRlQkJveCA9IGZ1bmN0aW9uIChiYm94LCByZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChyZWNvbXB1dGUgPT09IHZvaWQgMCkgeyByZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTW92YWJsZUxpbWl0cygpKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jb21wdXRlQkJveC5jYWxsKHRoaXMsIGJib3gsIHJlY29tcHV0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmJveC5lbXB0eSgpO1xuICAgICAgICAgICAgdmFyIGJhc2Vib3ggPSB0aGlzLmJhc2VDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgIHZhciB1bmRlcmJveCA9IHRoaXMuc2NyaXB0Q2hpbGQuZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0VW5kZXJLVihiYXNlYm94LCB1bmRlcmJveClbMV07XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5pc0xpbmVCZWxvdyA/IDAgOiB0aGlzLmdldERlbHRhKHRydWUpKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLmdldERlbHRhVyhbYmFzZWJveCwgdW5kZXJib3hdLCBbMCwgLWRlbHRhXSksIDIpLCBidyA9IF9hWzBdLCB1dyA9IF9hWzFdO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKGJhc2Vib3gsIGJ3LCAwKTtcbiAgICAgICAgICAgIGJib3guY29tYmluZSh1bmRlcmJveCwgdXcsIHYpO1xuICAgICAgICAgICAgYmJveC5kICs9IHRoaXMuZm9udC5wYXJhbXMuYmlnX29wX3NwYWNpbmc1O1xuICAgICAgICAgICAgYmJveC5jbGVhbigpO1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZFBXaWR0aHMocmVjb21wdXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShCYXNlKSk7XG59XG5leHBvcnRzLkNvbW1vbk11bmRlck1peGluID0gQ29tbW9uTXVuZGVyTWl4aW47XG5mdW5jdGlvbiBDb21tb25Nb3Zlck1peGluKEJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzIoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zdHJldGNoQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMi5wcm90b3R5cGUsIFwic2NyaXB0Q2hpbGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1t0aGlzLm5vZGUub3Zlcl07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNsYXNzXzIucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc01vdmFibGVMaW1pdHMoKSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuY29tcHV0ZUJCb3guY2FsbCh0aGlzLCBiYm94KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYm94LmVtcHR5KCk7XG4gICAgICAgICAgICB2YXIgYmFzZWJveCA9IHRoaXMuYmFzZUNoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgdmFyIG92ZXJib3ggPSB0aGlzLnNjcmlwdENoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnYWNjZW50JykpIHtcbiAgICAgICAgICAgICAgICBiYXNlYm94LmggPSBNYXRoLm1heChiYXNlYm94LmgsIHRoaXMuZm9udC5wYXJhbXMueF9oZWlnaHQgKiBiYXNlYm94LnNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5nZXRPdmVyS1UoYmFzZWJveCwgb3ZlcmJveClbMV07XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5pc0xpbmVBYm92ZSA/IDAgOiB0aGlzLmdldERlbHRhKCkpO1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHRoaXMuZ2V0RGVsdGFXKFtiYXNlYm94LCBvdmVyYm94XSwgWzAsIGRlbHRhXSksIDIpLCBidyA9IF9hWzBdLCBvdyA9IF9hWzFdO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKGJhc2Vib3gsIGJ3LCAwKTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShvdmVyYm94LCBvdywgdSk7XG4gICAgICAgICAgICBiYm94LmggKz0gdGhpcy5mb250LnBhcmFtcy5iaWdfb3Bfc3BhY2luZzU7XG4gICAgICAgICAgICBiYm94LmNsZWFuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18yO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25Nb3Zlck1peGluID0gQ29tbW9uTW92ZXJNaXhpbjtcbmZ1bmN0aW9uIENvbW1vbk11bmRlcm92ZXJNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18zLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18zKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuc3RyZXRjaENoaWxkcmVuKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzMucHJvdG90eXBlLCBcInVuZGVyQ2hpbGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlc1t0aGlzLm5vZGUudW5kZXJdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMy5wcm90b3R5cGUsIFwib3ZlckNoaWxkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXNbdGhpcy5ub2RlLm92ZXJdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMy5wcm90b3R5cGUsIFwic3ViQ2hpbGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5kZXJDaGlsZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzMucHJvdG90eXBlLCBcInN1cENoaWxkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJDaGlsZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY2xhc3NfMy5wcm90b3R5cGUuY29tcHV0ZUJCb3ggPSBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTW92YWJsZUxpbWl0cygpKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jb21wdXRlQkJveC5jYWxsKHRoaXMsIGJib3gpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJib3guZW1wdHkoKTtcbiAgICAgICAgICAgIHZhciBvdmVyYm94ID0gdGhpcy5vdmVyQ2hpbGQuZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgICAgICB2YXIgYmFzZWJveCA9IHRoaXMuYmFzZUNoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgdmFyIHVuZGVyYm94ID0gdGhpcy51bmRlckNoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldCgnYWNjZW50JykpIHtcbiAgICAgICAgICAgICAgICBiYXNlYm94LmggPSBNYXRoLm1heChiYXNlYm94LmgsIHRoaXMuZm9udC5wYXJhbXMueF9oZWlnaHQgKiBiYXNlYm94LnNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5nZXRPdmVyS1UoYmFzZWJveCwgb3ZlcmJveClbMV07XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0VW5kZXJLVihiYXNlYm94LCB1bmRlcmJveClbMV07XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5nZXREZWx0YVcoW2Jhc2Vib3gsIHVuZGVyYm94LCBvdmVyYm94XSwgWzAsIHRoaXMuaXNMaW5lQmVsb3cgPyAwIDogLWRlbHRhLCB0aGlzLmlzTGluZUFib3ZlID8gMCA6IGRlbHRhXSksIDMpLCBidyA9IF9hWzBdLCB1dyA9IF9hWzFdLCBvdyA9IF9hWzJdO1xuICAgICAgICAgICAgYmJveC5jb21iaW5lKGJhc2Vib3gsIGJ3LCAwKTtcbiAgICAgICAgICAgIGJib3guY29tYmluZShvdmVyYm94LCBvdywgdSk7XG4gICAgICAgICAgICBiYm94LmNvbWJpbmUodW5kZXJib3gsIHV3LCB2KTtcbiAgICAgICAgICAgIHZhciB6ID0gdGhpcy5mb250LnBhcmFtcy5iaWdfb3Bfc3BhY2luZzU7XG4gICAgICAgICAgICBiYm94LmggKz0gejtcbiAgICAgICAgICAgIGJib3guZCArPSB6O1xuICAgICAgICAgICAgYmJveC5jbGVhbigpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMztcbiAgICB9KEJhc2UpKTtcbn1cbmV4cG9ydHMuQ29tbW9uTXVuZGVyb3Zlck1peGluID0gQ29tbW9uTXVuZGVyb3Zlck1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVuZGVyb3Zlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vblNjcmlwdGJhc2VNaXhpbiA9IHZvaWQgMDtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG5mdW5jdGlvbiBDb21tb25TY3JpcHRiYXNlTWl4aW4oQmFzZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmFzZVNjYWxlID0gMTtcbiAgICAgICAgICAgICAgICBfdGhpcy5iYXNlSWMgPSAwO1xuICAgICAgICAgICAgICAgIF90aGlzLmJhc2VSZW1vdmVJYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLmJhc2VJc0NoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5iYXNlSGFzQWNjZW50T3ZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmFzZUhhc0FjY2VudFVuZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0xpbmVBYm92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLmlzTGluZUJlbG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNNYXRoQWNjZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNvcmUgPSBfdGhpcy5iYXNlQ29yZSA9IF90aGlzLmdldEJhc2VDb3JlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3JlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0QmFzZUFjY2VudHNGb3IoY29yZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmFzZVNjYWxlID0gX3RoaXMuZ2V0QmFzZVNjYWxlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmFzZUljID0gX3RoaXMuZ2V0QmFzZUljKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmFzZUlzQ2hhciA9IF90aGlzLmlzQ2hhckJhc2UoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc01hdGhBY2NlbnQgPSBfdGhpcy5iYXNlSXNDaGFyICYmXG4gICAgICAgICAgICAgICAgICAgIChfdGhpcy5zY3JpcHRDaGlsZCAmJiAhIV90aGlzLnNjcmlwdENoaWxkLmNvcmVNTygpLm5vZGUuZ2V0UHJvcGVydHkoJ21hdGhhY2NlbnQnKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tMaW5lQWNjZW50cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJhc2VSZW1vdmVJYyA9ICFfdGhpcy5pc0xpbmVBYm92ZSAmJiAhX3RoaXMuaXNMaW5lQmVsb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFfdGhpcy5jb25zdHJ1Y3Rvci51c2VJQyB8fCBfdGhpcy5pc01hdGhBY2NlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJiYXNlQ2hpbGRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzW3RoaXMubm9kZS5iYXNlXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2NyaXB0Q2hpbGRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzWzFdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEJhc2VDb3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb3JlID0gdGhpcy5nZXRTZW1hbnRpY0Jhc2UoKSB8fCB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKChjb3JlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29yZS5ub2RlLmlzS2luZCgnbXJvdycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcmUubm9kZS5pc0tpbmQoJ1RlWEF0b20nKSAmJiBjb3JlLm5vZGUudGV4Q2xhc3MgIT09IE1tbE5vZGVfanNfMS5URVhDTEFTUy5WQ0VOVEVSKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUubm9kZS5pc0tpbmQoJ21zdHlsZScpIHx8IGNvcmUubm9kZS5pc0tpbmQoJ21wYWRkZWQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUubm9kZS5pc0tpbmQoJ21waGFudG9tJykgfHwgY29yZS5ub2RlLmlzS2luZCgnc2VtYW50aWNzJykpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvcmUubm9kZS5pc0tpbmQoJ211bmRlcm92ZXInKSAmJiBjb3JlLmlzTWF0aEFjY2VudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QmFzZUFjY2VudHNGb3IoY29yZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcmUgPSBjb3JlLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29yZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhc2VIYXNBY2NlbnRPdmVyID0gdGhpcy5iYXNlSGFzQWNjZW50VW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUgfHwgdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldEJhc2VBY2NlbnRzRm9yID0gZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29yZS5ub2RlLmlzS2luZCgnbXVuZGVyb3ZlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VIYXNBY2NlbnRPdmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhc2VIYXNBY2NlbnRPdmVyID0gISFjb3JlLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2FjY2VudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VIYXNBY2NlbnRVbmRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXNlSGFzQWNjZW50VW5kZXIgPSAhIWNvcmUubm9kZS5hdHRyaWJ1dGVzLmdldCgnYWNjZW50dW5kZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRTZW1hbnRpY0Jhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlbmNlID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ2RhdGEtc2VtYW50aWMtZmVuY2Vwb2ludGVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzZUZlbmNlKHRoaXMuYmFzZUNoaWxkLCBmZW5jZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0QmFzZUZlbmNlID0gZnVuY3Rpb24gKGZlbmNlLCBpZCkge1xuICAgICAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgICAgIGlmICghZmVuY2UgfHwgIWZlbmNlLm5vZGUuYXR0cmlidXRlcyB8fCAhaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmZW5jZS5ub2RlLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ2RhdGEtc2VtYW50aWMtaWQnKSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGZlbmNlLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldEJhc2VGZW5jZShjaGlsZCwgaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEJhc2VTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmJhc2VDb3JlO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYm94ID0gY2hpbGQuZ2V0T3V0ZXJCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlICo9IGJib3gucnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEJhc2VJYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29yZS5nZXRPdXRlckJCb3goKS5pYyAqIHRoaXMuYmFzZVNjYWxlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEFkanVzdGVkSWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmJhc2VDb3JlLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYmJveC5pYyA/IDEuMDUgKiBiYm94LmljICsgLjA1IDogMCkgKiB0aGlzLmJhc2VTY2FsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5pc0NoYXJCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlQ29yZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCgoYmFzZS5ub2RlLmlzS2luZCgnbW8nKSAmJiBiYXNlLnNpemUgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJhc2Uubm9kZS5pc0tpbmQoJ21pJykgfHwgYmFzZS5ub2RlLmlzS2luZCgnbW4nKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5iYm94LnJzY2FsZSA9PT0gMSAmJiBBcnJheS5mcm9tKGJhc2UuZ2V0VGV4dCgpKS5sZW5ndGggPT09IDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNoZWNrTGluZUFjY2VudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5vZGUuaXNLaW5kKCdtdW5kZXJvdmVyJykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlLmlzS2luZCgnbW92ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTGluZUFib3ZlID0gdGhpcy5pc0xpbmVBY2NlbnQodGhpcy5zY3JpcHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubm9kZS5pc0tpbmQoJ211bmRlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMaW5lQmVsb3cgPSB0aGlzLmlzTGluZUFjY2VudCh0aGlzLnNjcmlwdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtbWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTGluZUFib3ZlID0gdGhpcy5pc0xpbmVBY2NlbnQobW1sLm92ZXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMaW5lQmVsb3cgPSB0aGlzLmlzTGluZUFjY2VudChtbWwudW5kZXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmlzTGluZUFjY2VudCA9IGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNjcmlwdC5jb3JlTU8oKS5ub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZS5pc1Rva2VuICYmIG5vZGUuZ2V0VGV4dCgpID09PSAnXFx1MjAxNScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldEJhc2VXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuYmFzZUNoaWxkLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYm94LncgKiBiYm94LnJzY2FsZSAtICh0aGlzLmJhc2VSZW1vdmVJYyA/IHRoaXMuYmFzZUljIDogMCkgKyB0aGlzLmZvbnQucGFyYW1zLmV4dHJhX2ljO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIHJlY29tcHV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvbXB1dGUgPT09IHZvaWQgMCkgeyByZWNvbXB1dGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIHZhciB3ID0gdGhpcy5nZXRCYXNlV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5nZXRPZmZzZXQoKSwgMiksIHggPSBfYVswXSwgeSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGJib3guYXBwZW5kKHRoaXMuYmFzZUNoaWxkLmdldE91dGVyQkJveCgpKTtcbiAgICAgICAgICAgICAgICBiYm94LmNvbWJpbmUodGhpcy5zY3JpcHRDaGlsZC5nZXRPdXRlckJCb3goKSwgdyArIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJib3gudyArPSB0aGlzLmZvbnQucGFyYW1zLnNjcmlwdHNwYWNlO1xuICAgICAgICAgICAgICAgIGJib3guY2xlYW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENoaWxkUFdpZHRocyhyZWNvbXB1dGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmJhc2VDaGFyWmVybyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhcmdlb3AgPSAhIXRoaXMuYmFzZUNvcmUubm9kZS5hdHRyaWJ1dGVzLmdldCgnbGFyZ2VvcCcpO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYmFzZVNjYWxlO1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5iYXNlSXNDaGFyICYmICFsYXJnZW9wICYmIHNjYWxlID09PSAxID8gMCA6IG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmJhc2VDb3JlLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgICAgIHZhciBzYm94ID0gdGhpcy5zY3JpcHRDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5mb250LnBhcmFtcztcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0c2hpZnQgPSB0aGlzLmxlbmd0aDJlbSh0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ3N1YnNjcmlwdHNoaWZ0JyksIHRleC5zdWIxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5iYXNlQ2hhclplcm8oYmJveC5kICogdGhpcy5iYXNlU2NhbGUgKyB0ZXguc3ViX2Ryb3AgKiBzYm94LnJzY2FsZSksIHN1YnNjcmlwdHNoaWZ0LCBzYm94LmggKiBzYm94LnJzY2FsZSAtICg0IC8gNSkgKiB0ZXgueF9oZWlnaHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmJhc2VDb3JlLmdldE91dGVyQkJveCgpO1xuICAgICAgICAgICAgICAgIHZhciBzYm94ID0gdGhpcy5zY3JpcHRDaGlsZC5nZXRPdXRlckJCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5mb250LnBhcmFtcztcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzLmdldExpc3QoJ2Rpc3BsYXlzdHlsZScsICdzdXBlcnNjcmlwdHNoaWZ0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHByaW1lID0gdGhpcy5ub2RlLmdldFByb3BlcnR5KCd0ZXhwcmltZXN0eWxlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwcmltZSA/IHRleC5zdXAzIDogKGF0dHIuZGlzcGxheXN0eWxlID8gdGV4LnN1cDEgOiB0ZXguc3VwMik7XG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyc2NyaXB0c2hpZnQgPSB0aGlzLmxlbmd0aDJlbShhdHRyLnN1cGVyc2NyaXB0c2hpZnQsIHApO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmJhc2VDaGFyWmVybyhiYm94LmggKiB0aGlzLmJhc2VTY2FsZSAtIHRleC5zdXBfZHJvcCAqIHNib3gucnNjYWxlKSwgc3VwZXJzY3JpcHRzaGlmdCwgc2JveC5kICogc2JveC5yc2NhbGUgKyAoMSAvIDQpICogdGV4LnhfaGVpZ2h0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXNNb3ZhYmxlTGltaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdkaXNwbGF5c3R5bGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgbW8gPSB0aGlzLmJhc2VDaGlsZC5jb3JlTU8oKS5ub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoIWRpc3BsYXkgJiYgISFtby5hdHRyaWJ1dGVzLmdldCgnbW92YWJsZWxpbWl0cycpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRPdmVyS1UgPSBmdW5jdGlvbiAoYmFzZWJveCwgb3ZlcmJveCkge1xuICAgICAgICAgICAgICAgIHZhciBhY2NlbnQgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2FjY2VudCcpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmZvbnQucGFyYW1zO1xuICAgICAgICAgICAgICAgIHZhciBkID0gb3ZlcmJveC5kICogb3ZlcmJveC5yc2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0ZXgucnVsZV90aGlja25lc3MgKiB0ZXguc2VwYXJhdGlvbl9mYWN0b3I7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gKHRoaXMuYmFzZUhhc0FjY2VudE92ZXIgPyB0IDogMCk7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAodGhpcy5pc0xpbmVBYm92ZSA/IDMgKiB0ZXgucnVsZV90aGlja25lc3MgOiB0KTtcbiAgICAgICAgICAgICAgICB2YXIgayA9IChhY2NlbnQgPyBUIDogTWF0aC5tYXgodGV4LmJpZ19vcF9zcGFjaW5nMSwgdGV4LmJpZ19vcF9zcGFjaW5nMyAtIE1hdGgubWF4KDAsIGQpKSkgLSBkZWx0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2ssIGJhc2Vib3guaCAqIGJhc2Vib3gucnNjYWxlICsgayArIGRdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFVuZGVyS1YgPSBmdW5jdGlvbiAoYmFzZWJveCwgdW5kZXJib3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjZW50ID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdhY2NlbnR1bmRlcicpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmZvbnQucGFyYW1zO1xuICAgICAgICAgICAgICAgIHZhciBoID0gdW5kZXJib3guaCAqIHVuZGVyYm94LnJzY2FsZTtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRleC5ydWxlX3RoaWNrbmVzcyAqIHRleC5zZXBhcmF0aW9uX2ZhY3RvcjtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5iYXNlSGFzQWNjZW50VW5kZXIgPyB0IDogMCk7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAodGhpcy5pc0xpbmVCZWxvdyA/IDMgKiB0ZXgucnVsZV90aGlja25lc3MgOiB0KTtcbiAgICAgICAgICAgICAgICB2YXIgayA9IChhY2NlbnQgPyBUIDogTWF0aC5tYXgodGV4LmJpZ19vcF9zcGFjaW5nMiwgdGV4LmJpZ19vcF9zcGFjaW5nNCAtIGgpKSAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBbaywgLShiYXNlYm94LmQgKiBiYXNlYm94LnJzY2FsZSArIGsgKyBoKV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0RGVsdGFXID0gZnVuY3Rpb24gKGJveGVzLCBkZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBlXzIsIF9hLCBlXzMsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7IGRlbHRhID0gWzAsIDAsIDBdOyB9XG4gICAgICAgICAgICAgICAgdmFyIGFsaWduID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMuZ2V0KCdhbGlnbicpO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aHMgPSBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCkgeyByZXR1cm4gYm94LncgKiBib3gucnNjYWxlOyB9KTtcbiAgICAgICAgICAgICAgICB3aWR0aHNbMF0gLT0gKHRoaXMuYmFzZVJlbW92ZUljICYmICF0aGlzLmJhc2VDb3JlLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2xhcmdlb3AnKSA/IHRoaXMuYmFzZUljIDogMCk7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQod2lkdGhzKSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB2YXIgZHcgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh3aWR0aHMua2V5cygpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR3W2ldID0gKGFsaWduID09PSAnY2VudGVyJyA/ICh3IC0gd2lkdGhzW2ldKSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduID09PSAncmlnaHQnID8gdyAtIHdpZHRoc1tpXSA6IDApICsgZGVsdGFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHdbaV0gPCBtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IC1kd1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMoZHcua2V5cygpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHdbaV0gKz0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFsxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGR3W2ldICs9IChib3hlc1tpXSA/IGJveGVzW2ldLmR4ICogYm94ZXNbMF0uc2NhbGUgOiAwKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR3O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldERlbHRhID0gZnVuY3Rpb24gKG5vc2tldykge1xuICAgICAgICAgICAgICAgIGlmIChub3NrZXcgPT09IHZvaWQgMCkgeyBub3NrZXcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIHZhciBhY2NlbnQgPSB0aGlzLm5vZGUuYXR0cmlidXRlcy5nZXQoJ2FjY2VudCcpO1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuYmFzZUNvcmUuZ2V0T3V0ZXJCQm94KCksIHNrID0gX2Euc2ssIGljID0gX2EuaWM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoYWNjZW50ICYmICFub3NrZXcgPyBzayA6IDApICsgdGhpcy5mb250LnNrZXdJY0ZhY3RvciAqIGljKSAqIHRoaXMuYmFzZVNjYWxlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnN0cmV0Y2hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZV80LCBfYSwgZV81LCBfYiwgZV82LCBfYztcbiAgICAgICAgICAgICAgICB2YXIgc3RyZXRjaHkgPSBbXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IF9fdmFsdWVzKHRoaXMuY2hpbGROb2RlcyksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNhblN0cmV0Y2goMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJldGNoeS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9lICYmICFfZS5kb25lICYmIChfYSA9IF9kLnJldHVybikpIF9hLmNhbGwoX2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gc3RyZXRjaHkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBub2RlQ291bnQgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCAmJiBub2RlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBXID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbCA9IChjb3VudCA+IDEgJiYgY291bnQgPT09IG5vZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IF9fdmFsdWVzKHRoaXMuY2hpbGROb2RlcyksIF9nID0gX2YubmV4dCgpOyAhX2cuZG9uZTsgX2cgPSBfZi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9TdHJldGNoID0gKGNoaWxkLnN0cmV0Y2guZGlyID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsIHx8IG5vU3RyZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ggPSBjaGlsZC5nZXRPdXRlckJCb3gobm9TdHJldGNoKSwgdyA9IF9oLncsIHJzY2FsZSA9IF9oLnJzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgKiByc2NhbGUgPiBXKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVyA9IHcgKiByc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHN0cmV0Y2h5XzEgPSBfX3ZhbHVlcyhzdHJldGNoeSksIHN0cmV0Y2h5XzFfMSA9IHN0cmV0Y2h5XzEubmV4dCgpOyAhc3RyZXRjaHlfMV8xLmRvbmU7IHN0cmV0Y2h5XzFfMSA9IHN0cmV0Y2h5XzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc3RyZXRjaHlfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvcmVNTygpLmdldFN0cmV0Y2hlZFZhcmlhbnQoW1cgLyBjaGlsZC5iYm94LnJzY2FsZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZXRjaHlfMV8xICYmICFzdHJldGNoeV8xXzEuZG9uZSAmJiAoX2MgPSBzdHJldGNoeV8xLnJldHVybikpIF9jLmNhbGwoc3RyZXRjaHlfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICAgIH0oQmFzZSkpLFxuICAgICAgICBfYS51c2VJQyA9IHRydWUsXG4gICAgICAgIF9hO1xufVxuZXhwb3J0cy5Db21tb25TY3JpcHRiYXNlTWl4aW4gPSBDb21tb25TY3JpcHRiYXNlTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHRiYXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uU2VtYW50aWNzTWl4aW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBDb21tb25TZW1hbnRpY3NNaXhpbihCYXNlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXB1dGVCQm94ID0gZnVuY3Rpb24gKGJib3gsIF9yZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmIChfcmVjb21wdXRlID09PSB2b2lkIDApIHsgX3JlY29tcHV0ZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuY2hpbGROb2Rlc1swXS5nZXRCQm94KCksIHcgPSBfYS53LCBoID0gX2EuaCwgZCA9IF9hLmQ7XG4gICAgICAgICAgICAgICAgYmJveC53ID0gdztcbiAgICAgICAgICAgICAgICBiYm94LmggPSBoO1xuICAgICAgICAgICAgICAgIGJib3guZCA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZSkpO1xufVxuZXhwb3J0cy5Db21tb25TZW1hbnRpY3NNaXhpbiA9IENvbW1vblNlbWFudGljc01peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtYW50aWNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CQm94ID0gdm9pZCAwO1xudmFyIGxlbmd0aHNfanNfMSA9IHJlcXVpcmUoXCIuL2xlbmd0aHMuanNcIik7XG52YXIgQkJveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQkJveChkZWYpIHtcbiAgICAgICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7IGRlZiA9IHsgdzogMCwgaDogLWxlbmd0aHNfanNfMS5CSUdESU1FTiwgZDogLWxlbmd0aHNfanNfMS5CSUdESU1FTiB9OyB9XG4gICAgICAgIHRoaXMudyA9IGRlZi53IHx8IDA7XG4gICAgICAgIHRoaXMuaCA9ICgnaCcgaW4gZGVmID8gZGVmLmggOiAtbGVuZ3Roc19qc18xLkJJR0RJTUVOKTtcbiAgICAgICAgdGhpcy5kID0gKCdkJyBpbiBkZWYgPyBkZWYuZCA6IC1sZW5ndGhzX2pzXzEuQklHRElNRU4pO1xuICAgICAgICB0aGlzLkwgPSB0aGlzLlIgPSB0aGlzLmljID0gdGhpcy5zayA9IHRoaXMuZHggPSAwO1xuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5yc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLnB3aWR0aCA9ICcnO1xuICAgIH1cbiAgICBCQm94Lnplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQkJveCh7IGg6IDAsIGQ6IDAsIHc6IDAgfSk7XG4gICAgfTtcbiAgICBCQm94LmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJCb3goKTtcbiAgICB9O1xuICAgIEJCb3gucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICB0aGlzLmggPSB0aGlzLmQgPSAtbGVuZ3Roc19qc18xLkJJR0RJTUVOO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJCb3gucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53ID09PSAtbGVuZ3Roc19qc18xLkJJR0RJTUVOKVxuICAgICAgICAgICAgdGhpcy53ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaCA9PT0gLWxlbmd0aHNfanNfMS5CSUdESU1FTilcbiAgICAgICAgICAgIHRoaXMuaCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmQgPT09IC1sZW5ndGhzX2pzXzEuQklHRElNRU4pXG4gICAgICAgICAgICB0aGlzLmQgPSAwO1xuICAgIH07XG4gICAgQkJveC5wcm90b3R5cGUucmVzY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICB0aGlzLncgKj0gc2NhbGU7XG4gICAgICAgIHRoaXMuaCAqPSBzY2FsZTtcbiAgICAgICAgdGhpcy5kICo9IHNjYWxlO1xuICAgIH07XG4gICAgQkJveC5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChjYm94LCB4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHsgeCA9IDA7IH1cbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkgeyB5ID0gMDsgfVxuICAgICAgICB2YXIgcnNjYWxlID0gY2JveC5yc2NhbGU7XG4gICAgICAgIHZhciB3ID0geCArIHJzY2FsZSAqIChjYm94LncgKyBjYm94LkwgKyBjYm94LlIpO1xuICAgICAgICB2YXIgaCA9IHkgKyByc2NhbGUgKiBjYm94Lmg7XG4gICAgICAgIHZhciBkID0gcnNjYWxlICogY2JveC5kIC0geTtcbiAgICAgICAgaWYgKHcgPiB0aGlzLncpXG4gICAgICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICBpZiAoaCA+IHRoaXMuaClcbiAgICAgICAgICAgIHRoaXMuaCA9IGg7XG4gICAgICAgIGlmIChkID4gdGhpcy5kKVxuICAgICAgICAgICAgdGhpcy5kID0gZDtcbiAgICB9O1xuICAgIEJCb3gucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChjYm94KSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGNib3gucnNjYWxlO1xuICAgICAgICB0aGlzLncgKz0gc2NhbGUgKiAoY2JveC53ICsgY2JveC5MICsgY2JveC5SKTtcbiAgICAgICAgaWYgKHNjYWxlICogY2JveC5oID4gdGhpcy5oKSB7XG4gICAgICAgICAgICB0aGlzLmggPSBzY2FsZSAqIGNib3guaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGUgKiBjYm94LmQgPiB0aGlzLmQpIHtcbiAgICAgICAgICAgIHRoaXMuZCA9IHNjYWxlICogY2JveC5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCQm94LnByb3RvdHlwZS51cGRhdGVGcm9tID0gZnVuY3Rpb24gKGNib3gpIHtcbiAgICAgICAgdGhpcy5oID0gY2JveC5oO1xuICAgICAgICB0aGlzLmQgPSBjYm94LmQ7XG4gICAgICAgIHRoaXMudyA9IGNib3gudztcbiAgICAgICAgaWYgKGNib3gucHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnB3aWR0aCA9IGNib3gucHdpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCQm94LmZ1bGxXaWR0aCA9ICcxMDAlJztcbiAgICBCQm94LlN0eWxlQWRqdXN0ID0gW1xuICAgICAgICBbJ2JvcmRlclRvcFdpZHRoJywgJ2gnXSxcbiAgICAgICAgWydib3JkZXJSaWdodFdpZHRoJywgJ3cnXSxcbiAgICAgICAgWydib3JkZXJCb3R0b21XaWR0aCcsICdkJ10sXG4gICAgICAgIFsnYm9yZGVyTGVmdFdpZHRoJywgJ3cnLCAwXSxcbiAgICAgICAgWydwYWRkaW5nVG9wJywgJ2gnXSxcbiAgICAgICAgWydwYWRkaW5nUmlnaHQnLCAndyddLFxuICAgICAgICBbJ3BhZGRpbmdCb3R0b20nLCAnZCddLFxuICAgICAgICBbJ3BhZGRpbmdMZWZ0JywgJ3cnLCAwXVxuICAgIF07XG4gICAgcmV0dXJuIEJCb3g7XG59KCkpO1xuZXhwb3J0cy5CQm94ID0gQkJveDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJCb3guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GdW5jdGlvbkxpc3QgPSB2b2lkIDA7XG52YXIgUHJpb3JpdGl6ZWRMaXN0X2pzXzEgPSByZXF1aXJlKFwiLi9Qcmlvcml0aXplZExpc3QuanNcIik7XG52YXIgRnVuY3Rpb25MaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBGdW5jdGlvbkxpc3QucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZGF0YVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlbS5pdGVtLmFwcGx5KGl0ZW0sIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkYXRhKSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBGdW5jdGlvbkxpc3QucHJvdG90eXBlLmFzeW5jRXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRhdGFbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKG9rLCBmYWlsKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKF9hID0gaXRlbXNbaV0pLml0ZW0uYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkYXRhKSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKGV4ZWN1dGUpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGZhaWwoZXJyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvayh0cnVlKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uTGlzdDtcbn0oUHJpb3JpdGl6ZWRMaXN0X2pzXzEuUHJpb3JpdGl6ZWRMaXN0KSk7XG5leHBvcnRzLkZ1bmN0aW9uTGlzdCA9IEZ1bmN0aW9uTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJpb3JpdGl6ZWRMaXN0ID0gdm9pZCAwO1xudmFyIFByaW9yaXRpemVkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpb3JpdGl6ZWRMaXN0KCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgUHJpb3JpdGl6ZWRMaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW1zW2krK10sIGRvbmU6IChpID4gaXRlbXMubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgUHJpb3JpdGl6ZWRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSBQcmlvcml0aXplZExpc3QuREVGQVVMVFBSSU9SSVRZOyB9XG4gICAgICAgIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfSB3aGlsZSAoaSA+PSAwICYmIHByaW9yaXR5IDwgdGhpcy5pdGVtc1tpXS5wcmlvcml0eSk7XG4gICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGkgKyAxLCAwLCB7IGl0ZW06IGl0ZW0sIHByaW9yaXR5OiBwcmlvcml0eSB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcbiAgICBQcmlvcml0aXplZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfSB3aGlsZSAoaSA+PSAwICYmIHRoaXMuaXRlbXNbaV0uaXRlbSAhPT0gaXRlbSk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0aXplZExpc3QuREVGQVVMVFBSSU9SSVRZID0gNTtcbiAgICByZXR1cm4gUHJpb3JpdGl6ZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuUHJpb3JpdGl6ZWRMaXN0ID0gUHJpb3JpdGl6ZWRMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpb3JpdGl6ZWRMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Dc3NTdHlsZXMgPSB2b2lkIDA7XG52YXIgQ3NzU3R5bGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgIHRoaXMuYWRkU3R5bGVzKHN0eWxlcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDc3NTdHlsZXMucHJvdG90eXBlLCBcImNzc1RleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlU3RyaW5nKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDc3NTdHlsZXMucHJvdG90eXBlLmFkZFN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmICghc3R5bGVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdHlsZXMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZXNbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW3N0eWxlXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuc3R5bGVzW3N0eWxlXSwgc3R5bGVzW3N0eWxlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3NzU3R5bGVzLnByb3RvdHlwZS5yZW1vdmVTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBzZWxlY3RvcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgc2VsZWN0b3JzXzEgPSBfX3ZhbHVlcyhzZWxlY3RvcnMpLCBzZWxlY3RvcnNfMV8xID0gc2VsZWN0b3JzXzEubmV4dCgpOyAhc2VsZWN0b3JzXzFfMS5kb25lOyBzZWxlY3RvcnNfMV8xID0gc2VsZWN0b3JzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbc2VsZWN0b3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzXzFfMSAmJiAhc2VsZWN0b3JzXzFfMS5kb25lICYmIChfYSA9IHNlbGVjdG9yc18xLnJldHVybikpIF9hLmNhbGwoc2VsZWN0b3JzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDc3NTdHlsZXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgIH07XG4gICAgQ3NzU3R5bGVzLnByb3RvdHlwZS5nZXRTdHlsZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVSdWxlcygpLmpvaW4oJ1xcblxcbicpO1xuICAgIH07XG4gICAgQ3NzU3R5bGVzLnByb3RvdHlwZS5nZXRTdHlsZVJ1bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKHRoaXMuc3R5bGVzKTtcbiAgICAgICAgdmFyIGRlZnMgPSBuZXcgQXJyYXkoc2VsZWN0b3JzLmxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHNlbGVjdG9yc18yID0gX192YWx1ZXMoc2VsZWN0b3JzKSwgc2VsZWN0b3JzXzJfMSA9IHNlbGVjdG9yc18yLm5leHQoKTsgIXNlbGVjdG9yc18yXzEuZG9uZTsgc2VsZWN0b3JzXzJfMSA9IHNlbGVjdG9yc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgZGVmc1tpKytdID0gc2VsZWN0b3IgKyAnIHtcXG4nICsgdGhpcy5nZXRTdHlsZURlZlN0cmluZyh0aGlzLnN0eWxlc1tzZWxlY3Rvcl0pICsgJ1xcbn0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzXzJfMSAmJiAhc2VsZWN0b3JzXzJfMS5kb25lICYmIChfYSA9IHNlbGVjdG9yc18yLnJldHVybikpIF9hLmNhbGwoc2VsZWN0b3JzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZzO1xuICAgIH07XG4gICAgQ3NzU3R5bGVzLnByb3RvdHlwZS5nZXRTdHlsZURlZlN0cmluZyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShwcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnRpZXNfMSA9IF9fdmFsdWVzKHByb3BlcnRpZXMpLCBwcm9wZXJ0aWVzXzFfMSA9IHByb3BlcnRpZXNfMS5uZXh0KCk7ICFwcm9wZXJ0aWVzXzFfMS5kb25lOyBwcm9wZXJ0aWVzXzFfMSA9IHByb3BlcnRpZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaSsrXSA9ICcgICcgKyBwcm9wZXJ0eSArICc6ICcgKyBzdHlsZXNbcHJvcGVydHldICsgJzsnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc18xXzEgJiYgIXByb3BlcnRpZXNfMV8xLmRvbmUgJiYgKF9hID0gcHJvcGVydGllc18xLnJldHVybikpIF9hLmNhbGwocHJvcGVydGllc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1N0eWxlcztcbn0oKSk7XG5leHBvcnRzLkNzc1N0eWxlcyA9IENzc1N0eWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0eWxlTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3R5bGVzID0gdm9pZCAwO1xudmFyIFRSQkwgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xudmFyIFdTQyA9IFsnd2lkdGgnLCAnc3R5bGUnLCAnY29sb3InXTtcbmZ1bmN0aW9uIHNwbGl0U3BhY2VzKHRleHQpIHtcbiAgICB2YXIgcGFydHMgPSB0ZXh0LnNwbGl0KC8oKD86J1teJ10qJ3xcIlteXCJdKlwifCxbXFxzXFxuXXxbXlxcc1xcbl0pKikvZyk7XG4gICAgdmFyIHNwbGl0ID0gW107XG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgc3BsaXQucHVzaChwYXJ0cy5zaGlmdCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0O1xufVxuZnVuY3Rpb24gc3BsaXRUUkJMKG5hbWUpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgcGFydHMgPSBzcGxpdFNwYWNlcyh0aGlzLnN0eWxlc1tuYW1lXSk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICB9XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhcnRzWzBdKTtcbiAgICB9XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhcnRzWzBdKTtcbiAgICB9XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhcnRzWzFdKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhTdHlsZXMuY29ubmVjdFtuYW1lXS5jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh0aGlzLmNoaWxkTmFtZShuYW1lLCBjaGlsZCksIHBhcnRzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVUUkJMKG5hbWUpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICB2YXIgY2hpbGRyZW4gPSBTdHlsZXMuY29ubmVjdFtuYW1lXS5jaGlsZHJlbjtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbl8xID0gX192YWx1ZXMoY2hpbGRyZW4pLCBjaGlsZHJlbl8xXzEgPSBjaGlsZHJlbl8xLm5leHQoKTsgIWNoaWxkcmVuXzFfMS5kb25lOyBjaGlsZHJlbl8xXzEgPSBjaGlsZHJlbl8xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5fMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHBhcnQgPSB0aGlzLnN0eWxlc1tuYW1lICsgJy0nICsgY2hpbGRdO1xuICAgICAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbl8xXzEgJiYgIWNoaWxkcmVuXzFfMS5kb25lICYmIChfYSA9IGNoaWxkcmVuXzEucmV0dXJuKSkgX2EuY2FsbChjaGlsZHJlbl8xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1szXSA9PT0gcGFydHNbMV0pIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIGlmIChwYXJ0c1syXSA9PT0gcGFydHNbMF0pIHtcbiAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSBwYXJ0c1swXSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3R5bGVzW25hbWVdID0gcGFydHMuam9pbignICcpO1xufVxuZnVuY3Rpb24gc3BsaXRTYW1lKG5hbWUpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFN0eWxlcy5jb25uZWN0W25hbWVdLmNoaWxkcmVuKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKHRoaXMuY2hpbGROYW1lKG5hbWUsIGNoaWxkKSwgdGhpcy5zdHlsZXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVTYW1lKG5hbWUpIHtcbiAgICB2YXIgZV80LCBfYTtcbiAgICB2YXIgY2hpbGRyZW4gPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoU3R5bGVzLmNvbm5lY3RbbmFtZV0uY2hpbGRyZW4pLCBmYWxzZSk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdHlsZXNbdGhpcy5jaGlsZE5hbWUobmFtZSwgY2hpbGRyZW4uc2hpZnQoKSldO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuXzIgPSBfX3ZhbHVlcyhjaGlsZHJlbiksIGNoaWxkcmVuXzJfMSA9IGNoaWxkcmVuXzIubmV4dCgpOyAhY2hpbGRyZW5fMl8xLmRvbmU7IGNoaWxkcmVuXzJfMSA9IGNoaWxkcmVuXzIubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbl8yXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZXNbdGhpcy5jaGlsZE5hbWUobmFtZSwgY2hpbGQpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5fMl8xICYmICFjaGlsZHJlbl8yXzEuZG9uZSAmJiAoX2EgPSBjaGlsZHJlbl8yLnJldHVybikpIF9hLmNhbGwoY2hpbGRyZW5fMik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgIH1cbiAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHZhbHVlO1xufVxudmFyIEJPUkRFUiA9IHtcbiAgICB3aWR0aDogL14oPzpbXFxkLl0rKD86W2Etel0rKXx0aGlufG1lZGl1bXx0aGlja3xpbmhlcml0fGluaXRpYWx8dW5zZXQpJC8sXG4gICAgc3R5bGU6IC9eKD86bm9uZXxoaWRkZW58ZG90dGVkfGRhc2hlZHxzb2xpZHxkb3VibGV8Z3Jvb3ZlfHJpZGdlfGluc2V0fG91dHNldHxpbmhlcml0fGluaXRpYWx8dW5zZXQpJC9cbn07XG5mdW5jdGlvbiBzcGxpdFdTQyhuYW1lKSB7XG4gICAgdmFyIGVfNSwgX2EsIGVfNiwgX2I7XG4gICAgdmFyIHBhcnRzID0geyB3aWR0aDogJycsIHN0eWxlOiAnJywgY29sb3I6ICcnIH07XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhzcGxpdFNwYWNlcyh0aGlzLnN0eWxlc1tuYW1lXSkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHBhcnQubWF0Y2goQk9SREVSLndpZHRoKSAmJiBwYXJ0cy53aWR0aCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy53aWR0aCA9IHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0Lm1hdGNoKEJPUkRFUi5zdHlsZSkgJiYgcGFydHMuc3R5bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMuc3R5bGUgPSBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydHMuY29sb3IgPSBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKFN0eWxlcy5jb25uZWN0W25hbWVdLmNoaWxkcmVuKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2YudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKHRoaXMuY2hpbGROYW1lKG5hbWUsIGNoaWxkKSwgcGFydHNbY2hpbGRdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21iaW5lV1NDKG5hbWUpIHtcbiAgICB2YXIgZV83LCBfYTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFN0eWxlcy5jb25uZWN0W25hbWVdLmNoaWxkcmVuKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlc1t0aGlzLmNoaWxkTmFtZShuYW1lLCBjaGlsZCldO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNykgdGhyb3cgZV83LmVycm9yOyB9XG4gICAgfVxuICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBwYXJ0cy5qb2luKCcgJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbmFtZV07XG4gICAgfVxufVxudmFyIEZPTlQgPSB7XG4gICAgc3R5bGU6IC9eKD86bm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXR8aW5pdGlhbHx1bnNldCkkLyxcbiAgICB2YXJpYW50OiBuZXcgUmVnRXhwKCdeKD86JyArXG4gICAgICAgIFsnbm9ybWFsfG5vbmUnLFxuICAgICAgICAgICAgJ2luaGVyaXR8aW5pdGlhbHx1bnNldCcsXG4gICAgICAgICAgICAnY29tbW9uLWxpZ2F0dXJlc3xuby1jb21tb24tbGlnYXR1cmVzJyxcbiAgICAgICAgICAgICdkaXNjcmV0aW9uYXJ5LWxpZ2F0dXJlc3xuby1kaXNjcmV0aW9uYXJ5LWxpZ2F0dXJlcycsXG4gICAgICAgICAgICAnaGlzdG9yaWNhbC1saWdhdHVyZXN8bm8taGlzdG9yaWNhbC1saWdhdHVyZXMnLFxuICAgICAgICAgICAgJ2NvbnRleHR1YWx8bm8tY29udGV4dHVhbCcsXG4gICAgICAgICAgICAnKD86c3R5bGlzdGljfGNoYXJhY3Rlci12YXJpYW50fHN3YXNofG9ybmFtZW50c3xhbm5vdGF0aW9uKVxcXFwoW14pXSpcXFxcKScsXG4gICAgICAgICAgICAnc21hbGwtY2Fwc3xhbGwtc21hbGwtY2Fwc3xwZXRpdGUtY2Fwc3xhbGwtcGV0aXRlLWNhcHN8dW5pY2FzZXx0aXRsaW5nLWNhcHMnLFxuICAgICAgICAgICAgJ2xpbmluZy1udW1zfG9sZHN0eWxlLW51bXN8cHJvcG9ydGlvbmFsLW51bXN8dGFidWxhci1udW1zJyxcbiAgICAgICAgICAgICdkaWFnb25hbC1mcmFjdGlvbnN8c3RhY2tlZC1mcmFjdGlvbnMnLFxuICAgICAgICAgICAgJ29yZGluYWx8c2xhc2hlZC16ZXJvJyxcbiAgICAgICAgICAgICdqaXM3OHxqaXM4M3xqaXM5MHxqaXMwNHxzaW1wbGlmaWVkfHRyYWRpdGlvbmFsJyxcbiAgICAgICAgICAgICdmdWxsLXdpZHRofHByb3BvcnRpb25hbC13aWR0aCcsXG4gICAgICAgICAgICAncnVieSddLmpvaW4oJ3wnKSArICcpJCcpLFxuICAgIHdlaWdodDogL14oPzpub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnxbMS05XTAwfGluaGVyaXR8aW5pdGlhbHx1bnNldCkkLyxcbiAgICBzdHJldGNoOiBuZXcgUmVnRXhwKCdeKD86JyArXG4gICAgICAgIFsnbm9ybWFsJyxcbiAgICAgICAgICAgICcoPzooPzp1bHRyYXxleHRyYXxzZW1pKS0pP2NvbmRlbnNlZCcsXG4gICAgICAgICAgICAnKD86KD86c2VtaXxleHRyYXx1bHRhKS0pP2V4cGFuZGVkJyxcbiAgICAgICAgICAgICdpbmhlcml0fGluaXRpYWx8dW5zZXQnXS5qb2luKCd8JykgKyAnKSQnKSxcbiAgICBzaXplOiBuZXcgUmVnRXhwKCdeKD86JyArXG4gICAgICAgIFsneHgtc21hbGx8eC1zbWFsbHxzbWFsbHxtZWRpdW18bGFyZ2V8eC1sYXJnZXx4eC1sYXJnZXxsYXJnZXJ8c21hbGxlcicsXG4gICAgICAgICAgICAnW1xcZC5dKyV8W1xcZC5dK1thLXpdKycsXG4gICAgICAgICAgICAnaW5oZXJpdHxpbml0aWFsfHVuc2V0J10uam9pbignfCcpICsgJyknICtcbiAgICAgICAgJyg/OlxcLyg/Om5vcm1hbHxbXFxkLlxcK10oPzolfFthLXpdKyk/KSk/JCcpXG59O1xuZnVuY3Rpb24gc3BsaXRGb250KG5hbWUpIHtcbiAgICB2YXIgZV84LCBfYSwgZV85LCBfYjtcbiAgICB2YXIgcGFydHMgPSBzcGxpdFNwYWNlcyh0aGlzLnN0eWxlc1tuYW1lXSk7XG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBzdHlsZTogJycsIHZhcmlhbnQ6IFtdLCB3ZWlnaHQ6ICcnLCBzdHJldGNoOiAnJyxcbiAgICAgICAgc2l6ZTogJycsIGZhbWlseTogJycsICdsaW5lLWhlaWdodCc6ICcnXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBwYXJ0c18xID0gX192YWx1ZXMocGFydHMpLCBwYXJ0c18xXzEgPSBwYXJ0c18xLm5leHQoKTsgIXBhcnRzXzFfMS5kb25lOyBwYXJ0c18xXzEgPSBwYXJ0c18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c18xXzEudmFsdWU7XG4gICAgICAgICAgICB2YWx1ZS5mYW1pbHkgPSBwYXJ0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IChlXzkgPSB2b2lkIDAsIF9fdmFsdWVzKE9iamVjdC5rZXlzKEZPTlQpKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKEFycmF5LmlzQXJyYXkodmFsdWVbbmFtZV8xXSkgfHwgdmFsdWVbbmFtZV8xXSA9PT0gJycpICYmIHBhcnQubWF0Y2goRk9OVFtuYW1lXzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVfMSA9PT0gJ3NpemUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lID0gX19yZWFkKHBhcnQuc3BsaXQoL1xcLy8pLCAyKSwgc2l6ZSA9IF9lWzBdLCBoZWlnaHQgPSBfZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtuYW1lXzFdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWydsaW5lLWhlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnNpemUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbbmFtZV8xXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbbmFtZV8xXS5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbbmFtZV8xXSA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfOV8xKSB7IGVfOSA9IHsgZXJyb3I6IGVfOV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2IgPSBfYy5yZXR1cm4pKSBfYi5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzhfMSkgeyBlXzggPSB7IGVycm9yOiBlXzhfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocGFydHNfMV8xICYmICFwYXJ0c18xXzEuZG9uZSAmJiAoX2EgPSBwYXJ0c18xLnJldHVybikpIF9hLmNhbGwocGFydHNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjsgfVxuICAgIH1cbiAgICBzYXZlRm9udFBhcnRzKG5hbWUsIHZhbHVlKTtcbiAgICBkZWxldGUgdGhpcy5zdHlsZXNbbmFtZV07XG59XG5mdW5jdGlvbiBzYXZlRm9udFBhcnRzKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGVfMTAsIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoU3R5bGVzLmNvbm5lY3RbbmFtZV0uY2hpbGRyZW4pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjbmFtZSA9IHRoaXMuY2hpbGROYW1lKG5hbWUsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlW2NoaWxkXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWVbY2hpbGRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2NuYW1lXSA9IHZhbHVlcy5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVbY2hpbGRdICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2NuYW1lXSA9IHZhbHVlW2NoaWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xMF8xKSB7IGVfMTAgPSB7IGVycm9yOiBlXzEwXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMCkgdGhyb3cgZV8xMC5lcnJvcjsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVGb250KF9uYW1lKSB7IH1cbnZhciBTdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlcyhjc3NUZXh0KSB7XG4gICAgICAgIGlmIChjc3NUZXh0ID09PSB2b2lkIDApIHsgY3NzVGV4dCA9ICcnOyB9XG4gICAgICAgIHRoaXMucGFyc2UoY3NzVGV4dCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZXMucHJvdG90eXBlLCBcImNzc1RleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzExLCBfYTtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLnN0eWxlcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5wYXJlbnROYW1lKG5hbWVfMik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZXNbcGFyZW50XzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChuYW1lXzIgKyAnOiAnICsgdGhpcy5zdHlsZXNbbmFtZV8yXSArICc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xMV8xKSB7IGVfMTEgPSB7IGVycm9yOiBlXzExXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXMuam9pbignICcpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3R5bGVzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMubm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChTdHlsZXMuY29ubmVjdFtuYW1lXSAmJiAhU3R5bGVzLmNvbm5lY3RbbmFtZV0uY29tYmluZSkge1xuICAgICAgICAgICAgdGhpcy5jb21iaW5lQ2hpbGRyZW4obmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5hbWUubWF0Y2goLy0vKSkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMucGFyZW50TmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmICghU3R5bGVzLmNvbm5lY3RbbmFtZV0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBTdHlsZXMuY29ubmVjdFtuYW1lXS5jb21iaW5lLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0eWxlcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMubm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXMuc3R5bGVzW25hbWVdIDogJycpO1xuICAgIH07XG4gICAgU3R5bGVzLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAoU3R5bGVzLmNvbm5lY3RbbmFtZV0gJiYgU3R5bGVzLmNvbm5lY3RbbmFtZV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIFN0eWxlcy5jb25uZWN0W25hbWVdLnNwbGl0LmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHlsZXMucHJvdG90eXBlLmNvbWJpbmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBlXzEyLCBfYTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50TmFtZShuYW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoU3R5bGVzLmNvbm5lY3RbbmFtZV0uY2hpbGRyZW4pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGNuYW1lID0gdGhpcy5jaGlsZE5hbWUocGFyZW50LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgU3R5bGVzLmNvbm5lY3RbY25hbWVdLmNvbWJpbmUuY2FsbCh0aGlzLCBjbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMTJfMSkgeyBlXzEyID0geyBlcnJvcjogZV8xMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMikgdGhyb3cgZV8xMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHlsZXMucHJvdG90eXBlLnBhcmVudE5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gbmFtZS5yZXBsYWNlKC8tW14tXSokLywgJycpO1xuICAgICAgICByZXR1cm4gKG5hbWUgPT09IHBhcmVudCA/ICcnIDogcGFyZW50KTtcbiAgICB9O1xuICAgIFN0eWxlcy5wcm90b3R5cGUuY2hpbGROYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5tYXRjaCgvLS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0eWxlcy5jb25uZWN0W25hbWVdICYmICFTdHlsZXMuY29ubmVjdFtuYW1lXS5jb21iaW5lKSB7XG4gICAgICAgICAgICBjaGlsZCArPSBuYW1lLnJlcGxhY2UoLy4qLS8sICctJyk7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5wYXJlbnROYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lICsgJy0nICsgY2hpbGQ7XG4gICAgfTtcbiAgICBTdHlsZXMucHJvdG90eXBlLm5vcm1hbGl6ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gJy0nICsgYy50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICB9O1xuICAgIFN0eWxlcy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICBpZiAoY3NzVGV4dCA9PT0gdm9pZCAwKSB7IGNzc1RleHQgPSAnJzsgfVxuICAgICAgICB2YXIgUEFUVEVSTiA9IHRoaXMuY29uc3RydWN0b3IucGF0dGVybjtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIHBhcnRzID0gY3NzVGV4dC5yZXBsYWNlKFBBVFRFUk4uY29tbWVudCwgJycpLnNwbGl0KFBBVFRFUk4uc3R5bGUpO1xuICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHBhcnRzLnNwbGljZSgwLCAzKSwgMyksIHNwYWNlID0gX2FbMF0sIG5hbWVfMyA9IF9hWzFdLCB2YWx1ZSA9IF9hWzJdO1xuICAgICAgICAgICAgaWYgKHNwYWNlLm1hdGNoKC9bXlxcc1xcbl0vKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNldChuYW1lXzMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R5bGVzLnBhdHRlcm4gPSB7XG4gICAgICAgIHN0eWxlOiAvKFstYS16XSspW1xcc1xcbl0qOltcXHNcXG5dKigoPzonW14nXSonfFwiW15cIl0qXCJ8XFxufC4pKj8pW1xcc1xcbl0qKD86O3wkKS9nLFxuICAgICAgICBjb21tZW50OiAvXFwvXFwqW15dKj9cXCpcXC8vZ1xuICAgIH07XG4gICAgU3R5bGVzLmNvbm5lY3QgPSB7XG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBUUkJMLFxuICAgICAgICAgICAgc3BsaXQ6IHNwbGl0VFJCTCxcbiAgICAgICAgICAgIGNvbWJpbmU6IGNvbWJpbmVUUkJMXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgY2hpbGRyZW46IFRSQkwsXG4gICAgICAgICAgICBzcGxpdDogc3BsaXRTYW1lLFxuICAgICAgICAgICAgY29tYmluZTogY29tYmluZVNhbWVcbiAgICAgICAgfSxcbiAgICAgICAgJ2JvcmRlci10b3AnOiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogV1NDLFxuICAgICAgICAgICAgc3BsaXQ6IHNwbGl0V1NDLFxuICAgICAgICAgICAgY29tYmluZTogY29tYmluZVdTQ1xuICAgICAgICB9LFxuICAgICAgICAnYm9yZGVyLXJpZ2h0Jzoge1xuICAgICAgICAgICAgY2hpbGRyZW46IFdTQyxcbiAgICAgICAgICAgIHNwbGl0OiBzcGxpdFdTQyxcbiAgICAgICAgICAgIGNvbWJpbmU6IGNvbWJpbmVXU0NcbiAgICAgICAgfSxcbiAgICAgICAgJ2JvcmRlci1ib3R0b20nOiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogV1NDLFxuICAgICAgICAgICAgc3BsaXQ6IHNwbGl0V1NDLFxuICAgICAgICAgICAgY29tYmluZTogY29tYmluZVdTQ1xuICAgICAgICB9LFxuICAgICAgICAnYm9yZGVyLWxlZnQnOiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogV1NDLFxuICAgICAgICAgICAgc3BsaXQ6IHNwbGl0V1NDLFxuICAgICAgICAgICAgY29tYmluZTogY29tYmluZVdTQ1xuICAgICAgICB9LFxuICAgICAgICAnYm9yZGVyLXdpZHRoJzoge1xuICAgICAgICAgICAgY2hpbGRyZW46IFRSQkwsXG4gICAgICAgICAgICBzcGxpdDogc3BsaXRUUkJMLFxuICAgICAgICAgICAgY29tYmluZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAnYm9yZGVyLXN0eWxlJzoge1xuICAgICAgICAgICAgY2hpbGRyZW46IFRSQkwsXG4gICAgICAgICAgICBzcGxpdDogc3BsaXRUUkJMLFxuICAgICAgICAgICAgY29tYmluZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAnYm9yZGVyLWNvbG9yJzoge1xuICAgICAgICAgICAgY2hpbGRyZW46IFRSQkwsXG4gICAgICAgICAgICBzcGxpdDogc3BsaXRUUkJMLFxuICAgICAgICAgICAgY29tYmluZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBmb250OiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogWydzdHlsZScsICd2YXJpYW50JywgJ3dlaWdodCcsICdzdHJldGNoJywgJ2xpbmUtaGVpZ2h0JywgJ3NpemUnLCAnZmFtaWx5J10sXG4gICAgICAgICAgICBzcGxpdDogc3BsaXRGb250LFxuICAgICAgICAgICAgY29tYmluZTogY29tYmluZUZvbnRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlcztcbn0oKSk7XG5leHBvcnRzLlN0eWxlcyA9IFN0eWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0eWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWF4ID0gZXhwb3J0cy5zdW0gPSB2b2lkIDA7XG5mdW5jdGlvbiBzdW0oQSkge1xuICAgIHJldHVybiBBLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xufVxuZXhwb3J0cy5zdW0gPSBzdW07XG5mdW5jdGlvbiBtYXgoQSkge1xuICAgIHJldHVybiBBLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5tYXgoYSwgYik7IH0sIDApO1xufVxuZXhwb3J0cy5tYXggPSBtYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1lcmljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==