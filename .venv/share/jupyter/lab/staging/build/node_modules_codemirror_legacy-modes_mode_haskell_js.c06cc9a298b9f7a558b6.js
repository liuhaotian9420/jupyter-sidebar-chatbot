"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_haskell_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/haskell.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haskell.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   haskell: () => (/* binding */ haskell)
/* harmony export */ });
function switchState(source, setState, f) {
  setState(f);
  return f(source, setState);
}

// These should all be Unicode extended, as per the Haskell 2010 report
var smallRE = /[a-z_]/;
var largeRE = /[A-Z]/;
var digitRE = /\d/;
var hexitRE = /[0-9A-Fa-f]/;
var octitRE = /[0-7]/;
var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
var specialRE = /[(),;[\]`{}]/;
var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

function normal(source, setState) {
  if (source.eatWhile(whiteCharRE)) {
    return null;
  }

  var ch = source.next();
  if (specialRE.test(ch)) {
    if (ch == '{' && source.eat('-')) {
      var t = "comment";
      if (source.eat('#')) {
        t = "meta";
      }
      return switchState(source, setState, ncomment(t, 1));
    }
    return null;
  }

  if (ch == '\'') {
    if (source.eat('\\')) {
      source.next();  // should handle other escapes here
    }
    else {
      source.next();
    }
    if (source.eat('\'')) {
      return "string";
    }
    return "error";
  }

  if (ch == '"') {
    return switchState(source, setState, stringLiteral);
  }

  if (largeRE.test(ch)) {
    source.eatWhile(idRE);
    if (source.eat('.')) {
      return "qualifier";
    }
    return "type";
  }

  if (smallRE.test(ch)) {
    source.eatWhile(idRE);
    return "variable";
  }

  if (digitRE.test(ch)) {
    if (ch == '0') {
      if (source.eat(/[xX]/)) {
        source.eatWhile(hexitRE); // should require at least 1
        return "integer";
      }
      if (source.eat(/[oO]/)) {
        source.eatWhile(octitRE); // should require at least 1
        return "number";
      }
    }
    source.eatWhile(digitRE);
    var t = "number";
    if (source.match(/^\.\d+/)) {
      t = "number";
    }
    if (source.eat(/[eE]/)) {
      t = "number";
      source.eat(/[-+]/);
      source.eatWhile(digitRE); // should require at least 1
    }
    return t;
  }

  if (ch == "." && source.eat("."))
    return "keyword";

  if (symbolRE.test(ch)) {
    if (ch == '-' && source.eat(/-/)) {
      source.eatWhile(/-/);
      if (!source.eat(symbolRE)) {
        source.skipToEnd();
        return "comment";
      }
    }
    source.eatWhile(symbolRE);
    return "variable"
  }

  return "error";
}

function ncomment(type, nest) {
  if (nest == 0) {
    return normal;
  }
  return function(source, setState) {
    var currNest = nest;
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '{' && source.eat('-')) {
        ++currNest;
      }
      else if (ch == '-' && source.eat('}')) {
        --currNest;
        if (currNest == 0) {
          setState(normal);
          return type;
        }
      }
    }
    setState(ncomment(type, currNest));
    return type;
  };
}

function stringLiteral(source, setState) {
  while (!source.eol()) {
    var ch = source.next();
    if (ch == '"') {
      setState(normal);
      return "string";
    }
    if (ch == '\\') {
      if (source.eol() || source.eat(whiteCharRE)) {
        setState(stringGap);
        return "string";
      }
      if (source.eat('&')) {
      }
      else {
        source.next(); // should handle other escapes here
      }
    }
  }
  setState(normal);
  return "error";
}

function stringGap(source, setState) {
  if (source.eat('\\')) {
    return switchState(source, setState, stringLiteral);
  }
  source.next();
  setState(normal);
  return "error";
}


var wellKnownWords = (function() {
  var wkw = {};
  function setType(t) {
    return function () {
      for (var i = 0; i < arguments.length; i++)
        wkw[arguments[i]] = t;
    };
  }

  setType("keyword")(
    "case", "class", "data", "default", "deriving", "do", "else", "foreign",
    "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
    "module", "newtype", "of", "then", "type", "where", "_");

  setType("keyword")(
    "\.\.", ":", "::", "=", "\\", "<-", "->", "@", "~", "=>");

  setType("builtin")(
    "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<*", "<=",
    "<$>", "<*>", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*",
    "*>", "**");

  setType("builtin")(
    "Applicative", "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum",
    "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor",
    "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
    "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
    "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
    "String", "True");

  setType("builtin")(
    "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
    "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
    "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
    "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
    "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
    "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
    "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
    "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
    "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
    "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
    "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
    "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
    "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
    "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
    "otherwise", "pi", "pred", "print", "product", "properFraction", "pure",
    "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
    "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
    "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
    "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
    "sequence", "sequence_", "show", "showChar", "showList", "showParen",
    "showString", "shows", "showsPrec", "significand", "signum", "sin",
    "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
    "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
    "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
    "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
    "zip3", "zipWith", "zipWith3");

  return wkw;
})();

const haskell = {
  name: "haskell",
  startState: function ()  { return { f: normal }; },
  copyState:  function (s) { return { f: s.f }; },

  token: function(stream, state) {
    var t = state.f(stream, function(s) { state.f = s; });
    var w = stream.current();
    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
  },

  languageData: {
    commentTokens: {line: "--", block: {open: "{-", close: "-}"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfaGFza2VsbF9qcy5jMDZjYzlhMjk4YjlmN2E1NThiNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBLDZCQUE2QixTQUFTLGNBQWM7QUFDcEQsNkJBQTZCLFNBQVMsV0FBVzs7QUFFakQ7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IsUUFBUSxjQUFjO0FBQzlEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGFza2VsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBmKSB7XG4gIHNldFN0YXRlKGYpO1xuICByZXR1cm4gZihzb3VyY2UsIHNldFN0YXRlKTtcbn1cblxuLy8gVGhlc2Ugc2hvdWxkIGFsbCBiZSBVbmljb2RlIGV4dGVuZGVkLCBhcyBwZXIgdGhlIEhhc2tlbGwgMjAxMCByZXBvcnRcbnZhciBzbWFsbFJFID0gL1thLXpfXS87XG52YXIgbGFyZ2VSRSA9IC9bQS1aXS87XG52YXIgZGlnaXRSRSA9IC9cXGQvO1xudmFyIGhleGl0UkUgPSAvWzAtOUEtRmEtZl0vO1xudmFyIG9jdGl0UkUgPSAvWzAtN10vO1xudmFyIGlkUkUgPSAvW2Etel9BLVowLTknXFx4YTEtXFx1ZmZmZl0vO1xudmFyIHN5bWJvbFJFID0gL1stISMkJSYqKy5cXC88PT4/QFxcXFxefH46XS87XG52YXIgc3BlY2lhbFJFID0gL1soKSw7W1xcXWB7fV0vO1xudmFyIHdoaXRlQ2hhclJFID0gL1sgXFx0XFx2XFxmXS87IC8vIG5ld2xpbmVzIGFyZSBoYW5kbGVkIGluIHRva2VuaXplclxuXG5mdW5jdGlvbiBub3JtYWwoc291cmNlLCBzZXRTdGF0ZSkge1xuICBpZiAoc291cmNlLmVhdFdoaWxlKHdoaXRlQ2hhclJFKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgaWYgKHNwZWNpYWxSRS50ZXN0KGNoKSkge1xuICAgIGlmIChjaCA9PSAneycgJiYgc291cmNlLmVhdCgnLScpKSB7XG4gICAgICB2YXIgdCA9IFwiY29tbWVudFwiO1xuICAgICAgaWYgKHNvdXJjZS5lYXQoJyMnKSkge1xuICAgICAgICB0ID0gXCJtZXRhXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgbmNvbW1lbnQodCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjaCA9PSAnXFwnJykge1xuICAgIGlmIChzb3VyY2UuZWF0KCdcXFxcJykpIHtcbiAgICAgIHNvdXJjZS5uZXh0KCk7ICAvLyBzaG91bGQgaGFuZGxlIG90aGVyIGVzY2FwZXMgaGVyZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNvdXJjZS5uZXh0KCk7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuZWF0KCdcXCcnKSkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIHJldHVybiBcImVycm9yXCI7XG4gIH1cblxuICBpZiAoY2ggPT0gJ1wiJykge1xuICAgIHJldHVybiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBzdHJpbmdMaXRlcmFsKTtcbiAgfVxuXG4gIGlmIChsYXJnZVJFLnRlc3QoY2gpKSB7XG4gICAgc291cmNlLmVhdFdoaWxlKGlkUkUpO1xuICAgIGlmIChzb3VyY2UuZWF0KCcuJykpIHtcbiAgICAgIHJldHVybiBcInF1YWxpZmllclwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJ0eXBlXCI7XG4gIH1cblxuICBpZiAoc21hbGxSRS50ZXN0KGNoKSkge1xuICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gJzAnKSB7XG4gICAgICBpZiAoc291cmNlLmVhdCgvW3hYXS8pKSB7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShoZXhpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICByZXR1cm4gXCJpbnRlZ2VyXCI7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmVhdCgvW29PXS8pKSB7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShvY3RpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlLmVhdFdoaWxlKGRpZ2l0UkUpO1xuICAgIHZhciB0ID0gXCJudW1iZXJcIjtcbiAgICBpZiAoc291cmNlLm1hdGNoKC9eXFwuXFxkKy8pKSB7XG4gICAgICB0ID0gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5lYXQoL1tlRV0vKSkge1xuICAgICAgdCA9IFwibnVtYmVyXCI7XG4gICAgICBzb3VyY2UuZWF0KC9bLStdLyk7XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoZGlnaXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICBpZiAoY2ggPT0gXCIuXCIgJiYgc291cmNlLmVhdChcIi5cIikpXG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gIGlmIChzeW1ib2xSRS50ZXN0KGNoKSkge1xuICAgIGlmIChjaCA9PSAnLScgJiYgc291cmNlLmVhdCgvLS8pKSB7XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoLy0vKTtcbiAgICAgIGlmICghc291cmNlLmVhdChzeW1ib2xSRSkpIHtcbiAgICAgICAgc291cmNlLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5lYXRXaGlsZShzeW1ib2xSRSk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIlxuICB9XG5cbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuZnVuY3Rpb24gbmNvbW1lbnQodHlwZSwgbmVzdCkge1xuICBpZiAobmVzdCA9PSAwKSB7XG4gICAgcmV0dXJuIG5vcm1hbDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBzZXRTdGF0ZSkge1xuICAgIHZhciBjdXJyTmVzdCA9IG5lc3Q7XG4gICAgd2hpbGUgKCFzb3VyY2UuZW9sKCkpIHtcbiAgICAgIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSkge1xuICAgICAgICArK2N1cnJOZXN0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2ggPT0gJy0nICYmIHNvdXJjZS5lYXQoJ30nKSkge1xuICAgICAgICAtLWN1cnJOZXN0O1xuICAgICAgICBpZiAoY3Vyck5lc3QgPT0gMCkge1xuICAgICAgICAgIHNldFN0YXRlKG5vcm1hbCk7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RhdGUobmNvbW1lbnQodHlwZSwgY3Vyck5lc3QpKTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nTGl0ZXJhbChzb3VyY2UsIHNldFN0YXRlKSB7XG4gIHdoaWxlICghc291cmNlLmVvbCgpKSB7XG4gICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1xcXFwnKSB7XG4gICAgICBpZiAoc291cmNlLmVvbCgpIHx8IHNvdXJjZS5lYXQod2hpdGVDaGFyUkUpKSB7XG4gICAgICAgIHNldFN0YXRlKHN0cmluZ0dhcCk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5lYXQoJyYnKSkge1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNvdXJjZS5uZXh0KCk7IC8vIHNob3VsZCBoYW5kbGUgb3RoZXIgZXNjYXBlcyBoZXJlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFN0YXRlKG5vcm1hbCk7XG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0dhcChzb3VyY2UsIHNldFN0YXRlKSB7XG4gIGlmIChzb3VyY2UuZWF0KCdcXFxcJykpIHtcbiAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gIH1cbiAgc291cmNlLm5leHQoKTtcbiAgc2V0U3RhdGUobm9ybWFsKTtcbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuXG52YXIgd2VsbEtub3duV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB3a3cgPSB7fTtcbiAgZnVuY3Rpb24gc2V0VHlwZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB3a3dbYXJndW1lbnRzW2ldXSA9IHQ7XG4gICAgfTtcbiAgfVxuXG4gIHNldFR5cGUoXCJrZXl3b3JkXCIpKFxuICAgIFwiY2FzZVwiLCBcImNsYXNzXCIsIFwiZGF0YVwiLCBcImRlZmF1bHRcIiwgXCJkZXJpdmluZ1wiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZvcmVpZ25cIixcbiAgICBcImlmXCIsIFwiaW1wb3J0XCIsIFwiaW5cIiwgXCJpbmZpeFwiLCBcImluZml4bFwiLCBcImluZml4clwiLCBcImluc3RhbmNlXCIsIFwibGV0XCIsXG4gICAgXCJtb2R1bGVcIiwgXCJuZXd0eXBlXCIsIFwib2ZcIiwgXCJ0aGVuXCIsIFwidHlwZVwiLCBcIndoZXJlXCIsIFwiX1wiKTtcblxuICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICBcIlxcLlxcLlwiLCBcIjpcIiwgXCI6OlwiLCBcIj1cIiwgXCJcXFxcXCIsIFwiPC1cIiwgXCItPlwiLCBcIkBcIiwgXCJ+XCIsIFwiPT5cIik7XG5cbiAgc2V0VHlwZShcImJ1aWx0aW5cIikoXG4gICAgXCIhIVwiLCBcIiQhXCIsIFwiJFwiLCBcIiYmXCIsIFwiK1wiLCBcIisrXCIsIFwiLVwiLCBcIi5cIiwgXCIvXCIsIFwiLz1cIiwgXCI8XCIsIFwiPCpcIiwgXCI8PVwiLFxuICAgIFwiPCQ+XCIsIFwiPCo+XCIsIFwiPTw8XCIsIFwiPT1cIiwgXCI+XCIsIFwiPj1cIiwgXCI+PlwiLCBcIj4+PVwiLCBcIl5cIiwgXCJeXlwiLCBcInx8XCIsIFwiKlwiLFxuICAgIFwiKj5cIiwgXCIqKlwiKTtcblxuICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICBcIkFwcGxpY2F0aXZlXCIsIFwiQm9vbFwiLCBcIkJvdW5kZWRcIiwgXCJDaGFyXCIsIFwiRG91YmxlXCIsIFwiRVFcIiwgXCJFaXRoZXJcIiwgXCJFbnVtXCIsXG4gICAgXCJFcVwiLCBcIkZhbHNlXCIsIFwiRmlsZVBhdGhcIiwgXCJGbG9hdFwiLCBcIkZsb2F0aW5nXCIsIFwiRnJhY3Rpb25hbFwiLCBcIkZ1bmN0b3JcIixcbiAgICBcIkdUXCIsIFwiSU9cIiwgXCJJT0Vycm9yXCIsIFwiSW50XCIsIFwiSW50ZWdlclwiLCBcIkludGVncmFsXCIsIFwiSnVzdFwiLCBcIkxUXCIsIFwiTGVmdFwiLFxuICAgIFwiTWF5YmVcIiwgXCJNb25hZFwiLCBcIk5vdGhpbmdcIiwgXCJOdW1cIiwgXCJPcmRcIiwgXCJPcmRlcmluZ1wiLCBcIlJhdGlvbmFsXCIsIFwiUmVhZFwiLFxuICAgIFwiUmVhZFNcIiwgXCJSZWFsXCIsIFwiUmVhbEZsb2F0XCIsIFwiUmVhbEZyYWNcIiwgXCJSaWdodFwiLCBcIlNob3dcIiwgXCJTaG93U1wiLFxuICAgIFwiU3RyaW5nXCIsIFwiVHJ1ZVwiKTtcblxuICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICBcImFic1wiLCBcImFjb3NcIiwgXCJhY29zaFwiLCBcImFsbFwiLCBcImFuZFwiLCBcImFueVwiLCBcImFwcGVuZEZpbGVcIiwgXCJhc1R5cGVPZlwiLFxuICAgIFwiYXNpblwiLCBcImFzaW5oXCIsIFwiYXRhblwiLCBcImF0YW4yXCIsIFwiYXRhbmhcIiwgXCJicmVha1wiLCBcImNhdGNoXCIsIFwiY2VpbGluZ1wiLFxuICAgIFwiY29tcGFyZVwiLCBcImNvbmNhdFwiLCBcImNvbmNhdE1hcFwiLCBcImNvbnN0XCIsIFwiY29zXCIsIFwiY29zaFwiLCBcImN1cnJ5XCIsXG4gICAgXCJjeWNsZVwiLCBcImRlY29kZUZsb2F0XCIsIFwiZGl2XCIsIFwiZGl2TW9kXCIsIFwiZHJvcFwiLCBcImRyb3BXaGlsZVwiLCBcImVpdGhlclwiLFxuICAgIFwiZWxlbVwiLCBcImVuY29kZUZsb2F0XCIsIFwiZW51bUZyb21cIiwgXCJlbnVtRnJvbVRoZW5cIiwgXCJlbnVtRnJvbVRoZW5Ub1wiLFxuICAgIFwiZW51bUZyb21Ub1wiLCBcImVycm9yXCIsIFwiZXZlblwiLCBcImV4cFwiLCBcImV4cG9uZW50XCIsIFwiZmFpbFwiLCBcImZpbHRlclwiLFxuICAgIFwiZmxpcFwiLCBcImZsb2F0RGlnaXRzXCIsIFwiZmxvYXRSYWRpeFwiLCBcImZsb2F0UmFuZ2VcIiwgXCJmbG9vclwiLCBcImZtYXBcIixcbiAgICBcImZvbGRsXCIsIFwiZm9sZGwxXCIsIFwiZm9sZHJcIiwgXCJmb2xkcjFcIiwgXCJmcm9tRW51bVwiLCBcImZyb21JbnRlZ2VyXCIsXG4gICAgXCJmcm9tSW50ZWdyYWxcIiwgXCJmcm9tUmF0aW9uYWxcIiwgXCJmc3RcIiwgXCJnY2RcIiwgXCJnZXRDaGFyXCIsIFwiZ2V0Q29udGVudHNcIixcbiAgICBcImdldExpbmVcIiwgXCJoZWFkXCIsIFwiaWRcIiwgXCJpbml0XCIsIFwiaW50ZXJhY3RcIiwgXCJpb0Vycm9yXCIsIFwiaXNEZW5vcm1hbGl6ZWRcIixcbiAgICBcImlzSUVFRVwiLCBcImlzSW5maW5pdGVcIiwgXCJpc05hTlwiLCBcImlzTmVnYXRpdmVaZXJvXCIsIFwiaXRlcmF0ZVwiLCBcImxhc3RcIixcbiAgICBcImxjbVwiLCBcImxlbmd0aFwiLCBcImxleFwiLCBcImxpbmVzXCIsIFwibG9nXCIsIFwibG9nQmFzZVwiLCBcImxvb2t1cFwiLCBcIm1hcFwiLFxuICAgIFwibWFwTVwiLCBcIm1hcE1fXCIsIFwibWF4XCIsIFwibWF4Qm91bmRcIiwgXCJtYXhpbXVtXCIsIFwibWF5YmVcIiwgXCJtaW5cIiwgXCJtaW5Cb3VuZFwiLFxuICAgIFwibWluaW11bVwiLCBcIm1vZFwiLCBcIm5lZ2F0ZVwiLCBcIm5vdFwiLCBcIm5vdEVsZW1cIiwgXCJudWxsXCIsIFwib2RkXCIsIFwib3JcIixcbiAgICBcIm90aGVyd2lzZVwiLCBcInBpXCIsIFwicHJlZFwiLCBcInByaW50XCIsIFwicHJvZHVjdFwiLCBcInByb3BlckZyYWN0aW9uXCIsIFwicHVyZVwiLFxuICAgIFwicHV0Q2hhclwiLCBcInB1dFN0clwiLCBcInB1dFN0ckxuXCIsIFwicXVvdFwiLCBcInF1b3RSZW1cIiwgXCJyZWFkXCIsIFwicmVhZEZpbGVcIixcbiAgICBcInJlYWRJT1wiLCBcInJlYWRMaXN0XCIsIFwicmVhZExuXCIsIFwicmVhZFBhcmVuXCIsIFwicmVhZHNcIiwgXCJyZWFkc1ByZWNcIixcbiAgICBcInJlYWxUb0ZyYWNcIiwgXCJyZWNpcFwiLCBcInJlbVwiLCBcInJlcGVhdFwiLCBcInJlcGxpY2F0ZVwiLCBcInJldHVyblwiLCBcInJldmVyc2VcIixcbiAgICBcInJvdW5kXCIsIFwic2NhbGVGbG9hdFwiLCBcInNjYW5sXCIsIFwic2NhbmwxXCIsIFwic2NhbnJcIiwgXCJzY2FucjFcIiwgXCJzZXFcIixcbiAgICBcInNlcXVlbmNlXCIsIFwic2VxdWVuY2VfXCIsIFwic2hvd1wiLCBcInNob3dDaGFyXCIsIFwic2hvd0xpc3RcIiwgXCJzaG93UGFyZW5cIixcbiAgICBcInNob3dTdHJpbmdcIiwgXCJzaG93c1wiLCBcInNob3dzUHJlY1wiLCBcInNpZ25pZmljYW5kXCIsIFwic2lnbnVtXCIsIFwic2luXCIsXG4gICAgXCJzaW5oXCIsIFwic25kXCIsIFwic3BhblwiLCBcInNwbGl0QXRcIiwgXCJzcXJ0XCIsIFwic3VidHJhY3RcIiwgXCJzdWNjXCIsIFwic3VtXCIsXG4gICAgXCJ0YWlsXCIsIFwidGFrZVwiLCBcInRha2VXaGlsZVwiLCBcInRhblwiLCBcInRhbmhcIiwgXCJ0b0VudW1cIiwgXCJ0b0ludGVnZXJcIixcbiAgICBcInRvUmF0aW9uYWxcIiwgXCJ0cnVuY2F0ZVwiLCBcInVuY3VycnlcIiwgXCJ1bmRlZmluZWRcIiwgXCJ1bmxpbmVzXCIsIFwidW50aWxcIixcbiAgICBcInVud29yZHNcIiwgXCJ1bnppcFwiLCBcInVuemlwM1wiLCBcInVzZXJFcnJvclwiLCBcIndvcmRzXCIsIFwid3JpdGVGaWxlXCIsIFwiemlwXCIsXG4gICAgXCJ6aXAzXCIsIFwiemlwV2l0aFwiLCBcInppcFdpdGgzXCIpO1xuXG4gIHJldHVybiB3a3c7XG59KSgpO1xuXG5leHBvcnQgY29uc3QgaGFza2VsbCA9IHtcbiAgbmFtZTogXCJoYXNrZWxsXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpICB7IHJldHVybiB7IGY6IG5vcm1hbCB9OyB9LFxuICBjb3B5U3RhdGU6ICBmdW5jdGlvbiAocykgeyByZXR1cm4geyBmOiBzLmYgfTsgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuZihzdHJlYW0sIGZ1bmN0aW9uKHMpIHsgc3RhdGUuZiA9IHM7IH0pO1xuICAgIHZhciB3ID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICByZXR1cm4gd2VsbEtub3duV29yZHMuaGFzT3duUHJvcGVydHkodykgPyB3ZWxsS25vd25Xb3Jkc1t3XSA6IHQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLS1cIiwgYmxvY2s6IHtvcGVuOiBcInstXCIsIGNsb3NlOiBcIi19XCJ9fVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9