"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_yacas_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/yacas.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/yacas.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   yacas: () => (/* binding */ yacas)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var bodiedOps = words("Assert BackQuote D Defun Deriv For ForEach FromFile " +
                      "FromString Function Integrate InverseTaylor Limit " +
                      "LocalSymbols Macro MacroRule MacroRulePattern " +
                      "NIntegrate Rule RulePattern Subst TD TExplicitSum " +
                      "TSum Taylor Taylor1 Taylor2 Taylor3 ToFile " +
                      "ToStdout ToString TraceRule Until While");

// patterns
var pFloatForm  = "(?:(?:\\.\\d+|\\d+\\.\\d*|\\d+)(?:[eE][+-]?\\d+)?)";
var pIdentifier = "(?:[a-zA-Z\\$'][a-zA-Z0-9\\$']*)";

// regular expressions
var reFloatForm    = new RegExp(pFloatForm);
var reIdentifier   = new RegExp(pIdentifier);
var rePattern      = new RegExp(pIdentifier + "?_" + pIdentifier);
var reFunctionLike = new RegExp(pIdentifier + "\\s*\\(");

function tokenBase(stream, state) {
  var ch;

  // get next character
  ch = stream.next();

  // string
  if (ch === '"') {
    state.tokenize = tokenString;
    return state.tokenize(stream, state);
  }

  // comment
  if (ch === '/') {
    if (stream.eat('*')) {
      state.tokenize = tokenComment;
      return state.tokenize(stream, state);
    }
    if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
  }

  // go back one character
  stream.backUp(1);

  // update scope info
  var m = stream.match(/^(\w+)\s*\(/, false);
  if (m !== null && bodiedOps.hasOwnProperty(m[1]))
    state.scopes.push('bodied');

  var scope = currentScope(state);

  if (scope === 'bodied' && ch === '[')
    state.scopes.pop();

  if (ch === '[' || ch === '{' || ch === '(')
    state.scopes.push(ch);

  scope = currentScope(state);

  if (scope === '[' && ch === ']' ||
      scope === '{' && ch === '}' ||
      scope === '(' && ch === ')')
    state.scopes.pop();

  if (ch === ';') {
    while (scope === 'bodied') {
      state.scopes.pop();
      scope = currentScope(state);
    }
  }

  // look for ordered rules
  if (stream.match(/\d+ *#/, true, false)) {
    return 'qualifier';
  }

  // look for numbers
  if (stream.match(reFloatForm, true, false)) {
    return 'number';
  }

  // look for placeholders
  if (stream.match(rePattern, true, false)) {
    return 'variableName.special';
  }

  // match all braces separately
  if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
    return 'bracket';
  }

  // literals looking like function calls
  if (stream.match(reFunctionLike, true, false)) {
    stream.backUp(1);
    return 'variableName.function';
  }

  // all other identifiers
  if (stream.match(reIdentifier, true, false)) {
    return 'variable';
  }

  // operators; note that operators like @@ or /; are matched separately for each symbol.
  if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%|#)/, true, false)) {
    return 'operator';
  }

  // everything else is an error
  return 'error';
}

function tokenString(stream, state) {
  var next, end = false, escaped = false;
  while ((next = stream.next()) != null) {
    if (next === '"' && !escaped) {
      end = true;
      break;
    }
    escaped = !escaped && next === '\\';
  }
  if (end && !escaped) {
    state.tokenize = tokenBase;
  }
  return 'string';
};

function tokenComment(stream, state) {
  var prev, next;
  while((next = stream.next()) != null) {
    if (prev === '*' && next === '/') {
      state.tokenize = tokenBase;
      break;
    }
    prev = next;
  }
  return 'comment';
}

function currentScope(state) {
  var scope = null;
  if (state.scopes.length > 0)
    scope = state.scopes[state.scopes.length - 1];
  return scope;
}

const yacas = {
  name: "yacas",
  startState: function() {
    return {
      tokenize: tokenBase,
      scopes: []
    };
  },
  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    return state.tokenize(stream, state);
  },
  indent: function(state, textAfter, cx) {
    if (state.tokenize !== tokenBase && state.tokenize !== null)
      return null;

    var delta = 0;
    if (textAfter === ']' || textAfter === '];' ||
        textAfter === '}' || textAfter === '};' ||
        textAfter === ');')
      delta = -1;

    return (state.scopes.length + delta) * cx.unit;
  },

  languageData: {
    electricInput: /[{}\[\]()\;]/,
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfeWFjYXNfanMuZWEyYjk1NjNhZDljNTY2MzViMTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0NBQWtDO0FBQ2xELHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUMsd0JBQXdCLHNCQUFzQjtBQUM5Qyx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0Isb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3lhY2FzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBib2RpZWRPcHMgPSB3b3JkcyhcIkFzc2VydCBCYWNrUXVvdGUgRCBEZWZ1biBEZXJpdiBGb3IgRm9yRWFjaCBGcm9tRmlsZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJGcm9tU3RyaW5nIEZ1bmN0aW9uIEludGVncmF0ZSBJbnZlcnNlVGF5bG9yIExpbWl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIkxvY2FsU3ltYm9scyBNYWNybyBNYWNyb1J1bGUgTWFjcm9SdWxlUGF0dGVybiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJOSW50ZWdyYXRlIFJ1bGUgUnVsZVBhdHRlcm4gU3Vic3QgVEQgVEV4cGxpY2l0U3VtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIlRTdW0gVGF5bG9yIFRheWxvcjEgVGF5bG9yMiBUYXlsb3IzIFRvRmlsZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJUb1N0ZG91dCBUb1N0cmluZyBUcmFjZVJ1bGUgVW50aWwgV2hpbGVcIik7XG5cbi8vIHBhdHRlcm5zXG52YXIgcEZsb2F0Rm9ybSAgPSBcIig/Oig/OlxcXFwuXFxcXGQrfFxcXFxkK1xcXFwuXFxcXGQqfFxcXFxkKykoPzpbZUVdWystXT9cXFxcZCspPylcIjtcbnZhciBwSWRlbnRpZmllciA9IFwiKD86W2EtekEtWlxcXFwkJ11bYS16QS1aMC05XFxcXCQnXSopXCI7XG5cbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbnZhciByZUZsb2F0Rm9ybSAgICA9IG5ldyBSZWdFeHAocEZsb2F0Rm9ybSk7XG52YXIgcmVJZGVudGlmaWVyICAgPSBuZXcgUmVnRXhwKHBJZGVudGlmaWVyKTtcbnZhciByZVBhdHRlcm4gICAgICA9IG5ldyBSZWdFeHAocElkZW50aWZpZXIgKyBcIj9fXCIgKyBwSWRlbnRpZmllcik7XG52YXIgcmVGdW5jdGlvbkxpa2UgPSBuZXcgUmVnRXhwKHBJZGVudGlmaWVyICsgXCJcXFxccypcXFxcKFwiKTtcblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIC8vIGdldCBuZXh0IGNoYXJhY3RlclxuICBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgLy8gc3RyaW5nXG4gIGlmIChjaCA9PT0gJ1wiJykge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmc7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gY29tbWVudFxuICBpZiAoY2ggPT09ICcvJykge1xuICAgIGlmIChzdHJlYW0uZWF0KCcqJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cblxuICAvLyBnbyBiYWNrIG9uZSBjaGFyYWN0ZXJcbiAgc3RyZWFtLmJhY2tVcCgxKTtcblxuICAvLyB1cGRhdGUgc2NvcGUgaW5mb1xuICB2YXIgbSA9IHN0cmVhbS5tYXRjaCgvXihcXHcrKVxccypcXCgvLCBmYWxzZSk7XG4gIGlmIChtICE9PSBudWxsICYmIGJvZGllZE9wcy5oYXNPd25Qcm9wZXJ0eShtWzFdKSlcbiAgICBzdGF0ZS5zY29wZXMucHVzaCgnYm9kaWVkJyk7XG5cbiAgdmFyIHNjb3BlID0gY3VycmVudFNjb3BlKHN0YXRlKTtcblxuICBpZiAoc2NvcGUgPT09ICdib2RpZWQnICYmIGNoID09PSAnWycpXG4gICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuXG4gIGlmIChjaCA9PT0gJ1snIHx8IGNoID09PSAneycgfHwgY2ggPT09ICcoJylcbiAgICBzdGF0ZS5zY29wZXMucHVzaChjaCk7XG5cbiAgc2NvcGUgPSBjdXJyZW50U2NvcGUoc3RhdGUpO1xuXG4gIGlmIChzY29wZSA9PT0gJ1snICYmIGNoID09PSAnXScgfHxcbiAgICAgIHNjb3BlID09PSAneycgJiYgY2ggPT09ICd9JyB8fFxuICAgICAgc2NvcGUgPT09ICcoJyAmJiBjaCA9PT0gJyknKVxuICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcblxuICBpZiAoY2ggPT09ICc7Jykge1xuICAgIHdoaWxlIChzY29wZSA9PT0gJ2JvZGllZCcpIHtcbiAgICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcbiAgICAgIHNjb3BlID0gY3VycmVudFNjb3BlKHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICAvLyBsb29rIGZvciBvcmRlcmVkIHJ1bGVzXG4gIGlmIChzdHJlYW0ubWF0Y2goL1xcZCsgKiMvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJ3F1YWxpZmllcic7XG4gIH1cblxuICAvLyBsb29rIGZvciBudW1iZXJzXG4gIGlmIChzdHJlYW0ubWF0Y2gocmVGbG9hdEZvcm0sIHRydWUsIGZhbHNlKSkge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuXG4gIC8vIGxvb2sgZm9yIHBsYWNlaG9sZGVyc1xuICBpZiAoc3RyZWFtLm1hdGNoKHJlUGF0dGVybiwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgcmV0dXJuICd2YXJpYWJsZU5hbWUuc3BlY2lhbCc7XG4gIH1cblxuICAvLyBtYXRjaCBhbGwgYnJhY2VzIHNlcGFyYXRlbHlcbiAgaWYgKHN0cmVhbS5tYXRjaCgvKD86XFxbfFxcXXx7fH18XFwofFxcKSkvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJ2JyYWNrZXQnO1xuICB9XG5cbiAgLy8gbGl0ZXJhbHMgbG9va2luZyBsaWtlIGZ1bmN0aW9uIGNhbGxzXG4gIGlmIChzdHJlYW0ubWF0Y2gocmVGdW5jdGlvbkxpa2UsIHRydWUsIGZhbHNlKSkge1xuICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgcmV0dXJuICd2YXJpYWJsZU5hbWUuZnVuY3Rpb24nO1xuICB9XG5cbiAgLy8gYWxsIG90aGVyIGlkZW50aWZpZXJzXG4gIGlmIChzdHJlYW0ubWF0Y2gocmVJZGVudGlmaWVyLCB0cnVlLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJ3ZhcmlhYmxlJztcbiAgfVxuXG4gIC8vIG9wZXJhdG9yczsgbm90ZSB0aGF0IG9wZXJhdG9ycyBsaWtlIEBAIG9yIC87IGFyZSBtYXRjaGVkIHNlcGFyYXRlbHkgZm9yIGVhY2ggc3ltYm9sLlxuICBpZiAoc3RyZWFtLm1hdGNoKC8oPzpcXFxcfFxcK3xcXC18XFwqfFxcL3wsfDt8XFwufDp8QHx+fD18Pnw8fCZ8XFx8fF98YHwnfFxcXnxcXD98IXwlfCMpLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgcmV0dXJuICdvcGVyYXRvcic7XG4gIH1cblxuICAvLyBldmVyeXRoaW5nIGVsc2UgaXMgYW4gZXJyb3JcbiAgcmV0dXJuICdlcnJvcic7XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5leHQsIGVuZCA9IGZhbHNlLCBlc2NhcGVkID0gZmFsc2U7XG4gIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmV4dCA9PT0gJ1wiJyAmJiAhZXNjYXBlZCkge1xuICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PT0gJ1xcXFwnO1xuICB9XG4gIGlmIChlbmQgJiYgIWVzY2FwZWQpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgfVxuICByZXR1cm4gJ3N0cmluZyc7XG59O1xuXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgcHJldiwgbmV4dDtcbiAgd2hpbGUoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKHByZXYgPT09ICcqJyAmJiBuZXh0ID09PSAnLycpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXYgPSBuZXh0O1xuICB9XG4gIHJldHVybiAnY29tbWVudCc7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRTY29wZShzdGF0ZSkge1xuICB2YXIgc2NvcGUgPSBudWxsO1xuICBpZiAoc3RhdGUuc2NvcGVzLmxlbmd0aCA+IDApXG4gICAgc2NvcGUgPSBzdGF0ZS5zY29wZXNbc3RhdGUuc2NvcGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc2NvcGU7XG59XG5cbmV4cG9ydCBjb25zdCB5YWNhcyA9IHtcbiAgbmFtZTogXCJ5YWNhc1wiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIHNjb3BlczogW11cbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9LFxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgaWYgKHN0YXRlLnRva2VuaXplICE9PSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhciBkZWx0YSA9IDA7XG4gICAgaWYgKHRleHRBZnRlciA9PT0gJ10nIHx8IHRleHRBZnRlciA9PT0gJ107JyB8fFxuICAgICAgICB0ZXh0QWZ0ZXIgPT09ICd9JyB8fCB0ZXh0QWZ0ZXIgPT09ICd9OycgfHxcbiAgICAgICAgdGV4dEFmdGVyID09PSAnKTsnKVxuICAgICAgZGVsdGEgPSAtMTtcblxuICAgIHJldHVybiAoc3RhdGUuc2NvcGVzLmxlbmd0aCArIGRlbHRhKSAqIGN4LnVuaXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgZWxlY3RyaWNJbnB1dDogL1t7fVxcW1xcXSgpXFw7XS8sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLy9cIiwgYmxvY2s6IHtvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCJ9fVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9