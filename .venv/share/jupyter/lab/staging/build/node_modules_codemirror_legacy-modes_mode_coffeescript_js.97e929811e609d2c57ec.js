"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_coffeescript_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/coffeescript.js":
/*!********************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/coffeescript.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coffeeScript: () => (/* binding */ coffeeScript)
/* harmony export */ });
var ERRORCLASS = "error";

function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b");
}

var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

var wordOperators = wordRegexp(["and", "or", "not",
                                "is", "isnt", "in",
                                "instanceof", "typeof"]);
var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                      "switch", "try", "catch", "finally", "class"];
var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                      "do", "in", "of", "new", "return", "then",
                      "this", "@", "throw", "when", "until", "extends"];

var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

indentKeywords = wordRegexp(indentKeywords);


var stringPrefixes = /^('{3}|\"{3}|['\"])/;
var regexPrefixes = /^(\/{3}|\/)/;
var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
var constants = wordRegexp(commonConstants);

// Tokenizers
function tokenBase(stream, state) {
  // Handle scope changes
  if (stream.sol()) {
    if (state.scope.align === null) state.scope.align = false;
    var scopeOffset = state.scope.offset;
    if (stream.eatSpace()) {
      var lineOffset = stream.indentation();
      if (lineOffset > scopeOffset && state.scope.type == "coffee") {
        return "indent";
      } else if (lineOffset < scopeOffset) {
        return "dedent";
      }
      return null;
    } else {
      if (scopeOffset > 0) {
        dedent(stream, state);
      }
    }
  }
  if (stream.eatSpace()) {
    return null;
  }

  var ch = stream.peek();

  // Handle docco title comment (single line)
  if (stream.match("####")) {
    stream.skipToEnd();
    return "comment";
  }

  // Handle multi line comments
  if (stream.match("###")) {
    state.tokenize = longComment;
    return state.tokenize(stream, state);
  }

  // Single line comment
  if (ch === "#") {
    stream.skipToEnd();
    return "comment";
  }

  // Handle number literals
  if (stream.match(/^-?[0-9\.]/, false)) {
    var floatLiteral = false;
    // Floats
    if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
      floatLiteral = true;
    }
    if (stream.match(/^-?\d+\.\d*/)) {
      floatLiteral = true;
    }
    if (stream.match(/^-?\.\d+/)) {
      floatLiteral = true;
    }

    if (floatLiteral) {
      // prevent from getting extra . on 1..
      if (stream.peek() == "."){
        stream.backUp(1);
      }
      return "number";
    }
    // Integers
    var intLiteral = false;
    // Hex
    if (stream.match(/^-?0x[0-9a-f]+/i)) {
      intLiteral = true;
    }
    // Decimal
    if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
      intLiteral = true;
    }
    // Zero by itself with no other piece of number.
    if (stream.match(/^-?0(?![\dx])/i)) {
      intLiteral = true;
    }
    if (intLiteral) {
      return "number";
    }
  }

  // Handle strings
  if (stream.match(stringPrefixes)) {
    state.tokenize = tokenFactory(stream.current(), false, "string");
    return state.tokenize(stream, state);
  }
  // Handle regex literals
  if (stream.match(regexPrefixes)) {
    if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
      state.tokenize = tokenFactory(stream.current(), true, "string.special");
      return state.tokenize(stream, state);
    } else {
      stream.backUp(1);
    }
  }



  // Handle operators and delimiters
  if (stream.match(operators) || stream.match(wordOperators)) {
    return "operator";
  }
  if (stream.match(delimiters)) {
    return "punctuation";
  }

  if (stream.match(constants)) {
    return "atom";
  }

  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
    return "property";
  }

  if (stream.match(keywords)) {
    return "keyword";
  }

  if (stream.match(identifiers)) {
    return "variable";
  }

  // Handle non-detected items
  stream.next();
  return ERRORCLASS;
}

function tokenFactory(delimiter, singleline, outclass) {
  return function(stream, state) {
    while (!stream.eol()) {
      stream.eatWhile(/[^'"\/\\]/);
      if (stream.eat("\\")) {
        stream.next();
        if (singleline && stream.eol()) {
          return outclass;
        }
      } else if (stream.match(delimiter)) {
        state.tokenize = tokenBase;
        return outclass;
      } else {
        stream.eat(/['"\/]/);
      }
    }
    if (singleline) {
      state.tokenize = tokenBase;
    }
    return outclass;
  };
}

function longComment(stream, state) {
  while (!stream.eol()) {
    stream.eatWhile(/[^#]/);
    if (stream.match("###")) {
      state.tokenize = tokenBase;
      break;
    }
    stream.eatWhile("#");
  }
  return "comment";
}

function indent(stream, state, type = "coffee") {
  var offset = 0, align = false, alignOffset = null;
  for (var scope = state.scope; scope; scope = scope.prev) {
    if (scope.type === "coffee" || scope.type == "}") {
      offset = scope.offset + stream.indentUnit;
      break;
    }
  }
  if (type !== "coffee") {
    align = null;
    alignOffset = stream.column() + stream.current().length;
  } else if (state.scope.align) {
    state.scope.align = false;
  }
  state.scope = {
    offset: offset,
    type: type,
    prev: state.scope,
    align: align,
    alignOffset: alignOffset
  };
}

function dedent(stream, state) {
  if (!state.scope.prev) return;
  if (state.scope.type === "coffee") {
    var _indent = stream.indentation();
    var matched = false;
    for (var scope = state.scope; scope; scope = scope.prev) {
      if (_indent === scope.offset) {
        matched = true;
        break;
      }
    }
    if (!matched) {
      return true;
    }
    while (state.scope.prev && state.scope.offset !== _indent) {
      state.scope = state.scope.prev;
    }
    return false;
  } else {
    state.scope = state.scope.prev;
    return false;
  }
}

function tokenLexer(stream, state) {
  var style = state.tokenize(stream, state);
  var current = stream.current();

  // Handle scope changes.
  if (current === "return") {
    state.dedent = true;
  }
  if (((current === "->" || current === "=>") && stream.eol())
      || style === "indent") {
    indent(stream, state);
  }
  var delimiter_index = "[({".indexOf(current);
  if (delimiter_index !== -1) {
    indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
  }
  if (indentKeywords.exec(current)){
    indent(stream, state);
  }
  if (current == "then"){
    dedent(stream, state);
  }


  if (style === "dedent") {
    if (dedent(stream, state)) {
      return ERRORCLASS;
    }
  }
  delimiter_index = "])}".indexOf(current);
  if (delimiter_index !== -1) {
    while (state.scope.type == "coffee" && state.scope.prev)
      state.scope = state.scope.prev;
    if (state.scope.type == current)
      state.scope = state.scope.prev;
  }
  if (state.dedent && stream.eol()) {
    if (state.scope.type == "coffee" && state.scope.prev)
      state.scope = state.scope.prev;
    state.dedent = false;
  }

  return style == "indent" || style == "dedent" ? null : style;
}

const coffeeScript = {
  name: "coffeescript",
  startState: function() {
    return {
      tokenize: tokenBase,
      scope: {offset: 0, type:"coffee", prev: null, align: false},
      prop: false,
      dedent: 0
    };
  },

  token: function(stream, state) {
    var fillAlign = state.scope.align === null && state.scope;
    if (fillAlign && stream.sol()) fillAlign.align = false;

    var style = tokenLexer(stream, state);
    if (style && style != "comment") {
      if (fillAlign) fillAlign.align = true;
      state.prop = style == "punctuation" && stream.current() == "."
    }

    return style;
  },

  indent: function(state, text) {
    if (state.tokenize != tokenBase) return 0;
    var scope = state.scope;
    var closer = text && "])}".indexOf(text.charAt(0)) > -1;
    if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
    var closes = closer && scope.type === text.charAt(0);
    if (scope.align)
      return scope.alignOffset - (closes ? 1 : 0);
    else
      return (closes ? scope.prev : scope).offset;
  },

  languageData: {
    commentTokens: {line: "#"}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfY29mZmVlc2NyaXB0X2pzLjk3ZTkyOTgxMWU2MDlkMmM1N2VjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLDBCQUEwQixFQUFFLElBQUksRUFBRTtBQUNsQywwQkFBMEIsRUFBRTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQW1EO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvY29mZmVlc2NyaXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFUlJPUkNMQVNTID0gXCJlcnJvclwiO1xuXG5mdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xufVxuXG52YXIgb3BlcmF0b3JzID0gL14oPzotPnw9PnxcXCtbKz1dP3wtW1xcLT1dP3xcXCpbXFwqPV0/fFxcL1tcXC89XT98Wz0hXT18PFs+PF0/PT98Pj4/PT98JT0/fCY9P3xcXHw9P3xcXF49P3xcXH58IXxcXD98KG9yfGFuZHxcXHxcXHx8JiZ8XFw/KT0pLztcbnZhciBkZWxpbWl0ZXJzID0gL14oPzpbKClcXFtcXF17fSw6YD07XXxcXC5cXC4/XFwuPykvO1xudmFyIGlkZW50aWZpZXJzID0gL15bX0EtWmEteiRdW19BLVphLXokMC05XSovO1xudmFyIGF0UHJvcCA9IC9eQFtfQS1aYS16JF1bX0EtWmEteiQwLTldKi87XG5cbnZhciB3b3JkT3BlcmF0b3JzID0gd29yZFJlZ2V4cChbXCJhbmRcIiwgXCJvclwiLCBcIm5vdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlzXCIsIFwiaXNudFwiLCBcImluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiXSk7XG52YXIgaW5kZW50S2V5d29yZHMgPSBbXCJmb3JcIiwgXCJ3aGlsZVwiLCBcImxvb3BcIiwgXCJpZlwiLCBcInVubGVzc1wiLCBcImVsc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInN3aXRjaFwiLCBcInRyeVwiLCBcImNhdGNoXCIsIFwiZmluYWxseVwiLCBcImNsYXNzXCJdO1xudmFyIGNvbW1vbktleXdvcmRzID0gW1wiYnJlYWtcIiwgXCJieVwiLCBcImNvbnRpbnVlXCIsIFwiZGVidWdnZXJcIiwgXCJkZWxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImRvXCIsIFwiaW5cIiwgXCJvZlwiLCBcIm5ld1wiLCBcInJldHVyblwiLCBcInRoZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcInRoaXNcIiwgXCJAXCIsIFwidGhyb3dcIiwgXCJ3aGVuXCIsIFwidW50aWxcIiwgXCJleHRlbmRzXCJdO1xuXG52YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKGluZGVudEtleXdvcmRzLmNvbmNhdChjb21tb25LZXl3b3JkcykpO1xuXG5pbmRlbnRLZXl3b3JkcyA9IHdvcmRSZWdleHAoaW5kZW50S2V5d29yZHMpO1xuXG5cbnZhciBzdHJpbmdQcmVmaXhlcyA9IC9eKCd7M318XFxcInszfXxbJ1xcXCJdKS87XG52YXIgcmVnZXhQcmVmaXhlcyA9IC9eKFxcL3szfXxcXC8pLztcbnZhciBjb21tb25Db25zdGFudHMgPSBbXCJJbmZpbml0eVwiLCBcIk5hTlwiLCBcInVuZGVmaW5lZFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJvblwiLCBcIm9mZlwiLCBcInllc1wiLCBcIm5vXCJdO1xudmFyIGNvbnN0YW50cyA9IHdvcmRSZWdleHAoY29tbW9uQ29uc3RhbnRzKTtcblxuLy8gVG9rZW5pemVyc1xuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gSGFuZGxlIHNjb3BlIGNoYW5nZXNcbiAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgIGlmIChzdGF0ZS5zY29wZS5hbGlnbiA9PT0gbnVsbCkgc3RhdGUuc2NvcGUuYWxpZ24gPSBmYWxzZTtcbiAgICB2YXIgc2NvcGVPZmZzZXQgPSBzdGF0ZS5zY29wZS5vZmZzZXQ7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICB2YXIgbGluZU9mZnNldCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgaWYgKGxpbmVPZmZzZXQgPiBzY29wZU9mZnNldCAmJiBzdGF0ZS5zY29wZS50eXBlID09IFwiY29mZmVlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW5kZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGxpbmVPZmZzZXQgPCBzY29wZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gXCJkZWRlbnRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2NvcGVPZmZzZXQgPiAwKSB7XG4gICAgICAgIGRlZGVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gIC8vIEhhbmRsZSBkb2NjbyB0aXRsZSBjb21tZW50IChzaW5nbGUgbGluZSlcbiAgaWYgKHN0cmVhbS5tYXRjaChcIiMjIyNcIikpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIG11bHRpIGxpbmUgY29tbWVudHNcbiAgaWYgKHN0cmVhbS5tYXRjaChcIiMjI1wiKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gbG9uZ0NvbW1lbnQ7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gU2luZ2xlIGxpbmUgY29tbWVudFxuICBpZiAoY2ggPT09IFwiI1wiKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBudW1iZXIgbGl0ZXJhbHNcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/WzAtOVxcLl0vLCBmYWxzZSkpIHtcbiAgICB2YXIgZmxvYXRMaXRlcmFsID0gZmFsc2U7XG4gICAgLy8gRmxvYXRzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/XFxkKlxcLlxcZCsoZVtcXCtcXC1dP1xcZCspPy9pKSkge1xuICAgICAgZmxvYXRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/XFxkK1xcLlxcZCovKSkge1xuICAgICAgZmxvYXRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/XFwuXFxkKy8pKSB7XG4gICAgICBmbG9hdExpdGVyYWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmbG9hdExpdGVyYWwpIHtcbiAgICAgIC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIGV4dHJhIC4gb24gMS4uXG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIi5cIil7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gSW50ZWdlcnNcbiAgICB2YXIgaW50TGl0ZXJhbCA9IGZhbHNlO1xuICAgIC8vIEhleFxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tPzB4WzAtOWEtZl0rL2kpKSB7XG4gICAgICBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRGVjaW1hbFxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tP1sxLTldXFxkKihlW1xcK1xcLV0/XFxkKyk/LykpIHtcbiAgICAgIGludExpdGVyYWwgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBaZXJvIGJ5IGl0c2VsZiB3aXRoIG5vIG90aGVyIHBpZWNlIG9mIG51bWJlci5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT8wKD8hW1xcZHhdKS9pKSkge1xuICAgICAgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbnRMaXRlcmFsKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgc3RyaW5nc1xuICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ1ByZWZpeGVzKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5GYWN0b3J5KHN0cmVhbS5jdXJyZW50KCksIGZhbHNlLCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgLy8gSGFuZGxlIHJlZ2V4IGxpdGVyYWxzXG4gIGlmIChzdHJlYW0ubWF0Y2gocmVnZXhQcmVmaXhlcykpIHtcbiAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSAhPSBcIi9cIiB8fCBzdHJlYW0ubWF0Y2goL14uKlxcLy8sIGZhbHNlKSkgeyAvLyBwcmV2ZW50IGhpZ2hsaWdodCBvZiBkaXZpc2lvblxuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSwgdHJ1ZSwgXCJzdHJpbmcuc3BlY2lhbFwiKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgLy8gSGFuZGxlIG9wZXJhdG9ycyBhbmQgZGVsaW1pdGVyc1xuICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9ycykgfHwgc3RyZWFtLm1hdGNoKHdvcmRPcGVyYXRvcnMpKSB7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcnMpKSB7XG4gICAgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goY29uc3RhbnRzKSkge1xuICAgIHJldHVybiBcImF0b21cIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goYXRQcm9wKSB8fCBzdGF0ZS5wcm9wICYmIHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHtcbiAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cblxuICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gIHN0cmVhbS5uZXh0KCk7XG4gIHJldHVybiBFUlJPUkNMQVNTO1xufVxuXG5mdW5jdGlvbiB0b2tlbkZhY3RvcnkoZGVsaW1pdGVyLCBzaW5nbGVsaW5lLCBvdXRjbGFzcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJ1wiXFwvXFxcXF0vKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiXFxcXFwiKSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoc2luZ2xlbGluZSAmJiBzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICByZXR1cm4gb3V0Y2xhc3M7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBvdXRjbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1snXCJcXC9dLyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaW5nbGVsaW5lKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGNsYXNzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsb25nQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXiNdLyk7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChcIiMjI1wiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKFwiI1wiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIGluZGVudChzdHJlYW0sIHN0YXRlLCB0eXBlID0gXCJjb2ZmZWVcIikge1xuICB2YXIgb2Zmc2V0ID0gMCwgYWxpZ24gPSBmYWxzZSwgYWxpZ25PZmZzZXQgPSBudWxsO1xuICBmb3IgKHZhciBzY29wZSA9IHN0YXRlLnNjb3BlOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7XG4gICAgaWYgKHNjb3BlLnR5cGUgPT09IFwiY29mZmVlXCIgfHwgc2NvcGUudHlwZSA9PSBcIn1cIikge1xuICAgICAgb2Zmc2V0ID0gc2NvcGUub2Zmc2V0ICsgc3RyZWFtLmluZGVudFVuaXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgIT09IFwiY29mZmVlXCIpIHtcbiAgICBhbGlnbiA9IG51bGw7XG4gICAgYWxpZ25PZmZzZXQgPSBzdHJlYW0uY29sdW1uKCkgKyBzdHJlYW0uY3VycmVudCgpLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zY29wZS5hbGlnbikge1xuICAgIHN0YXRlLnNjb3BlLmFsaWduID0gZmFsc2U7XG4gIH1cbiAgc3RhdGUuc2NvcGUgPSB7XG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwcmV2OiBzdGF0ZS5zY29wZSxcbiAgICBhbGlnbjogYWxpZ24sXG4gICAgYWxpZ25PZmZzZXQ6IGFsaWduT2Zmc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuc2NvcGUucHJldikgcmV0dXJuO1xuICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PT0gXCJjb2ZmZWVcIikge1xuICAgIHZhciBfaW5kZW50ID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBzY29wZSA9IHN0YXRlLnNjb3BlOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7XG4gICAgICBpZiAoX2luZGVudCA9PT0gc2NvcGUub2Zmc2V0KSB7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2hpbGUgKHN0YXRlLnNjb3BlLnByZXYgJiYgc3RhdGUuc2NvcGUub2Zmc2V0ICE9PSBfaW5kZW50KSB7XG4gICAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgdmFyIGN1cnJlbnQgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzLlxuICBpZiAoY3VycmVudCA9PT0gXCJyZXR1cm5cIikge1xuICAgIHN0YXRlLmRlZGVudCA9IHRydWU7XG4gIH1cbiAgaWYgKCgoY3VycmVudCA9PT0gXCItPlwiIHx8IGN1cnJlbnQgPT09IFwiPT5cIikgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgfHwgc3R5bGUgPT09IFwiaW5kZW50XCIpIHtcbiAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgdmFyIGRlbGltaXRlcl9pbmRleCA9IFwiWyh7XCIuaW5kZXhPZihjdXJyZW50KTtcbiAgaWYgKGRlbGltaXRlcl9pbmRleCAhPT0gLTEpIHtcbiAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSwgXCJdKX1cIi5zbGljZShkZWxpbWl0ZXJfaW5kZXgsIGRlbGltaXRlcl9pbmRleCsxKSk7XG4gIH1cbiAgaWYgKGluZGVudEtleXdvcmRzLmV4ZWMoY3VycmVudCkpe1xuICAgIGluZGVudChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBpZiAoY3VycmVudCA9PSBcInRoZW5cIil7XG4gICAgZGVkZW50KHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cblxuICBpZiAoc3R5bGUgPT09IFwiZGVkZW50XCIpIHtcbiAgICBpZiAoZGVkZW50KHN0cmVhbSwgc3RhdGUpKSB7XG4gICAgICByZXR1cm4gRVJST1JDTEFTUztcbiAgICB9XG4gIH1cbiAgZGVsaW1pdGVyX2luZGV4ID0gXCJdKX1cIi5pbmRleE9mKGN1cnJlbnQpO1xuICBpZiAoZGVsaW1pdGVyX2luZGV4ICE9PSAtMSkge1xuICAgIHdoaWxlIChzdGF0ZS5zY29wZS50eXBlID09IFwiY29mZmVlXCIgJiYgc3RhdGUuc2NvcGUucHJldilcbiAgICAgIHN0YXRlLnNjb3BlID0gc3RhdGUuc2NvcGUucHJldjtcbiAgICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PSBjdXJyZW50KVxuICAgICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICB9XG4gIGlmIChzdGF0ZS5kZWRlbnQgJiYgc3RyZWFtLmVvbCgpKSB7XG4gICAgaWYgKHN0YXRlLnNjb3BlLnR5cGUgPT0gXCJjb2ZmZWVcIiAmJiBzdGF0ZS5zY29wZS5wcmV2KVxuICAgICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICAgIHN0YXRlLmRlZGVudCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlID09IFwiaW5kZW50XCIgfHwgc3R5bGUgPT0gXCJkZWRlbnRcIiA/IG51bGwgOiBzdHlsZTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvZmZlZVNjcmlwdCA9IHtcbiAgbmFtZTogXCJjb2ZmZWVzY3JpcHRcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBzY29wZToge29mZnNldDogMCwgdHlwZTpcImNvZmZlZVwiLCBwcmV2OiBudWxsLCBhbGlnbjogZmFsc2V9LFxuICAgICAgcHJvcDogZmFsc2UsXG4gICAgICBkZWRlbnQ6IDBcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGZpbGxBbGlnbiA9IHN0YXRlLnNjb3BlLmFsaWduID09PSBudWxsICYmIHN0YXRlLnNjb3BlO1xuICAgIGlmIChmaWxsQWxpZ24gJiYgc3RyZWFtLnNvbCgpKSBmaWxsQWxpZ24uYWxpZ24gPSBmYWxzZTtcblxuICAgIHZhciBzdHlsZSA9IHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0eWxlICYmIHN0eWxlICE9IFwiY29tbWVudFwiKSB7XG4gICAgICBpZiAoZmlsbEFsaWduKSBmaWxsQWxpZ24uYWxpZ24gPSB0cnVlO1xuICAgICAgc3RhdGUucHJvcCA9IHN0eWxlID09IFwicHVuY3R1YXRpb25cIiAmJiBzdHJlYW0uY3VycmVudCgpID09IFwiLlwiXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHQpIHtcbiAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICB2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZTtcbiAgICB2YXIgY2xvc2VyID0gdGV4dCAmJiBcIl0pfVwiLmluZGV4T2YodGV4dC5jaGFyQXQoMCkpID4gLTE7XG4gICAgaWYgKGNsb3Nlcikgd2hpbGUgKHNjb3BlLnR5cGUgPT0gXCJjb2ZmZWVcIiAmJiBzY29wZS5wcmV2KSBzY29wZSA9IHNjb3BlLnByZXY7XG4gICAgdmFyIGNsb3NlcyA9IGNsb3NlciAmJiBzY29wZS50eXBlID09PSB0ZXh0LmNoYXJBdCgwKTtcbiAgICBpZiAoc2NvcGUuYWxpZ24pXG4gICAgICByZXR1cm4gc2NvcGUuYWxpZ25PZmZzZXQgLSAoY2xvc2VzID8gMSA6IDApO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAoY2xvc2VzID8gc2NvcGUucHJldiA6IHNjb3BlKS5vZmZzZXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9