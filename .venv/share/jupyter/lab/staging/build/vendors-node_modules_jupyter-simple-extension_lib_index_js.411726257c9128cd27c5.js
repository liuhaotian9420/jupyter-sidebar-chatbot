"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/api-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/api-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: icons_1.extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/globals.js":
/*!**************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/globals.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/icons.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/icons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Import the main CSS file
__webpack_require__(/*! ../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/markdown-config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/markdown-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = text.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks, handle list items
        return line.replace(/([^\n\s])-\s/g, '$1\n- ');
    });
    return processedLines.join('\n');
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
/**
 * Manages the state and interactions of the multi-level popup menu.
 */
class PopupMenuManager {
    constructor(docManager, widgetNode, callbacks) {
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        this.currentNotebook = null;
        this.selectedMenuItemIndex = -1; // Track currently selected menu item
        this.currentDirectoryItems = null; // Cache for directory items
        this.docManager = docManager;
        this.widgetNode = widgetNode;
        this.callbacks = callbacks;
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        // Attach to the widget node instead of the body
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Create search input
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search...';
        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling
        this.searchInput.addEventListener('input', () => this.updateMenuItemsUI()); // Change listener to call the targeted update function
        this.searchInput.addEventListener('keydown', (event) => {
            // Only stop specific keys needed to prevent menu interaction
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Escape', 'Tab'].includes(event.key)) {
                // Stop propagation so the main handler doesn't also act on these
                console.log('POPUP (Search Input Listener): Stopping propagation for key:', event.key);
                event.stopPropagation();
                // We will handle these keys in the main handler based on target check
            }
            // Allow default behavior (like Backspace) by *not* stopping propagation for other keys
        });
        // Create a dedicated container for the menu items
        this.itemsContainer = document.createElement('div');
        this.itemsContainer.className = 'jp-llm-ext-popup-menu-items-container';
        document.addEventListener('click', this.handleDocumentClick.bind(this), true);
        // Add keyboard event listener for navigation
        document.addEventListener('keydown', this.handleKeyDown.bind(this), true);
        if (globals_1.globals.notebookTracker) {
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            globals_1.globals.notebookTracker.currentChanged.connect((_, notebook) => {
                this.currentNotebook = notebook;
            });
        }
    }
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);
        document.removeEventListener('keydown', this.handleKeyDown.bind(this), true);
        // Remove from widgetNode if attached
        if (this.popupMenuContainer.parentNode === this.widgetNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
    handleDocumentClick(event) {
        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');
            if (atButton && atButton.contains(event.target)) {
                console.log('POPUP: Click was on the @ button, not hiding.');
                return;
            }
            console.log('POPUP: Click detected outside the menu.');
            this.hidePopupMenu();
        }
    }
    async showPopupMenu(x, y) {
        console.log(`POPUP: Showing menu at (${x}, ${y})`);
        if (this.popupMenuContainer.style.display === 'none') {
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
            this.searchInput.value = ''; // Clear search on show
            this.currentDirectoryItems = null; // Clear cache on show
            await this.setCurrentDirectoryPath();
        }
        await this.renderMenuContent();
        // Ensure it's attached to the widget node if somehow detached
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Position the popup menu - place it above the trigger point
        this.popupMenuContainer.style.position = 'absolute';
        this.popupMenuContainer.style.left = `${x}px`;
        // Show the menu first so we can calculate its height
        this.popupMenuContainer.style.display = 'block';
        // Get the actual height after rendering
        const menuHeight = this.popupMenuContainer.offsetHeight;
        // Add a small gap (10px) between the bottom of the menu and the trigger point
        const gap = 10;
        // Position above the cursor/button (y - menuHeight - gap)
        this.popupMenuContainer.style.top = `${Math.max(0, y - menuHeight - gap)}px`;
        // Focus the search input if we are in file/directory view, otherwise focus the first item
        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0); // Focus search input
            this.selectedMenuItemIndex = -1; // Don't select an item if search is focused
        }
        else {
            // Reset and select the first menu item for top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => {
                this.selectNextMenuItem();
            }, 0);
        }
    }
    hidePopupMenu() {
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding menu.');
            this.popupMenuContainer.style.display = 'none';
            // No need to explicitly remove from widgetNode unless causing issues
            // If performance becomes an issue with many menus, consider removing/re-adding
            // if (this.popupMenuContainer.parentNode === this.widgetNode) {
            //     this.widgetNode.removeChild(this.popupMenuContainer);
            // }
        }
    }
    async renderMenuContent() {
        console.log(`POPUP: Rendering full menu content for level: ${this.currentMenuLevel}, path: ${this.currentMenuPath}`);
        this.popupMenuContainer.innerHTML = '';
        this.currentDirectoryItems = null; // Clear cache when re-rendering structure
        if (this.menuHistory.length > 0) {
            const backButton = this.createMenuItem('← Back', 'navigate-back', '', '');
            this.popupMenuContainer.appendChild(backButton);
        }
        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
            // Add search input
            this.popupMenuContainer.appendChild(this.searchInput);
            // Add path indicator
            const pathIndicator = document.createElement('div');
            pathIndicator.className = 'jp-llm-ext-popup-menu-path';
            pathIndicator.textContent = `Path: ${this.currentMenuPath || '/'}`;
            this.popupMenuContainer.appendChild(pathIndicator);
            // Add the container for list items
            this.popupMenuContainer.appendChild(this.itemsContainer);
            // Fetch initial items and populate the items container
            await this.fetchAndPopulateMenuItems();
        }
        else if (this.currentMenuLevel === 'top') {
            this.renderTopLevelItems();
        }
        // Re-apply selection highlight after rendering
        this.updateSelectionHighlight();
    }
    renderTopLevelItems() {
        this.itemsContainer.innerHTML = ''; // Ensure items container is clear
        const topLevelCommands = [
            { label: 'Code', description: 'Insert selected code or current cell', actionId: 'insert-code' },
            { label: 'Cell', description: 'Insert current cell content', actionId: 'insert-cell' },
            { label: 'File', description: 'Browse and insert file path', actionId: 'browse-files' },
            { label: 'Directory', description: 'Browse and insert directory path', actionId: 'browse-directories' }
        ];
        topLevelCommands.forEach(cmd => {
            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);
            this.itemsContainer.appendChild(item);
        });
    }
    /** Fetches directory contents if needed and populates the items container */
    async fetchAndPopulateMenuItems() {
        var _a, _b;
        console.log(`POPUP: Fetching/Populating items. Cached: ${!!this.currentDirectoryItems}`);
        this.itemsContainer.innerHTML = ''; // Clear previous items
        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        this.itemsContainer.appendChild(loadingItem);
        try {
            // Fetch if cache is empty
            if (!this.currentDirectoryItems) {
                // Removed unused filterType declaration
                // Fetch all initially for filtering, or apply server-side filter if API supports it
                this.currentDirectoryItems = await this.listCurrentDirectoryContents(this.currentMenuPath); // Fetch all initially
                console.log(`POPUP: Fetched ${(_b = (_a = this.currentDirectoryItems) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0} items for ${this.currentMenuPath}`);
            }
            // Remove loading indicator
            if (this.itemsContainer.contains(loadingItem)) {
                this.itemsContainer.removeChild(loadingItem);
            }
            // Populate UI based on current cache and search term
            this.updateMenuItemsUI();
        }
        catch (error) {
            if (this.itemsContainer.contains(loadingItem)) {
                this.itemsContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.itemsContainer.appendChild(errorItem); // Add error to items container
            console.error('POPUP: Error fetching directory contents:', error);
            this.currentDirectoryItems = null; // Clear cache on error
        }
        // Reset selection after fetching/re-populating
        this.selectedMenuItemIndex = -1;
        this.updateSelectionHighlight();
    }
    /** Updates only the list items in the itemsContainer based on search */
    updateMenuItemsUI() {
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        console.log(`POPUP: Updating UI for search term: "${searchTerm}"`);
        // Clear only the items container
        this.itemsContainer.innerHTML = '';
        if (!this.currentDirectoryItems) {
            console.log('POPUP: No directory items cached, cannot update UI.');
            // Optionally show a message or try fetching again
            const errorItem = this.createMenuItem(`No items loaded`, 'empty', '', '');
            this.itemsContainer.appendChild(errorItem);
            return;
        }
        const currentLevelFilterType = this.currentMenuLevel === 'files' ? 'file' : 'directory'; // Use this for "No X found" message
        // Filter cached items based on search term first
        const searchFilteredContents = this.currentDirectoryItems.filter(item => {
            return item.name.toLowerCase().includes(searchTerm);
        });
        // Filter again based *strictly* on the level's primary type + directories if browsing files
        const finalFilteredContents = searchFilteredContents.filter(item => {
            if (this.currentMenuLevel === 'files') {
                // Keep files that match search, and directories that match search
                return item.type === 'file' || item.type === 'directory';
            }
            else { // 'directories'
                // Keep only directories that match search
                return item.type === 'directory';
            }
        });
        if (finalFilteredContents.length > 0) {
            finalFilteredContents.forEach(item => {
                const itemName = item.name;
                const itemType = item.type;
                const itemPath = item.path;
                const icon = itemType === 'directory' ? '📁' : '📄';
                let actionId;
                if (itemType === 'directory') {
                    // If viewing 'files', clicking dir navigates. If viewing 'dirs', clicking dir selects.
                    actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';
                }
                else { // itemType === 'file'
                    // Can only select a file if we are in 'files' mode.
                    actionId = this.currentMenuLevel === 'files' ? 'select-file' : 'invalid-action'; // Should not happen if filtering is correct
                }
                if (actionId !== 'invalid-action') {
                    const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath);
                    this.itemsContainer.appendChild(menuItem); // Append to items container
                }
            });
        }
        else {
            // Use currentLevelFilterType for the message
            const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${currentLevelFilterType}s found`, 'empty', '', '');
            emptyItem.style.pointerEvents = 'none';
            this.itemsContainer.appendChild(emptyItem); // Append to items container
        }
        // Reset selection highlight as items changed
        this.selectedMenuItemIndex = -1;
        this.updateSelectionHighlight();
    }
    createMenuItem(text, actionId, path = '', description = '') {
        const item = document.createElement('div');
        item.className = 'jp-llm-ext-popup-menu-item';
        item.dataset.actionId = actionId;
        if (path) {
            item.dataset.path = path;
        }
        item.onclick = (event) => this.handleMenuClick(event);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = text;
        item.appendChild(labelSpan);
        if (description) {
            labelSpan.style.fontWeight = 'bold';
            const descSpan = document.createElement('span');
            descSpan.textContent = description;
            descSpan.style.display = 'block';
            descSpan.style.fontSize = '0.8em';
            descSpan.style.color = 'var(--jp-ui-font-color2)';
            item.appendChild(descSpan);
        }
        return item;
    }
    async handleMenuClick(event) {
        const target = event.currentTarget;
        const actionId = target.dataset.actionId;
        const path = target.dataset.path || '';
        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);
        switch (actionId) {
            case 'navigate-back':
                this.navigateBackMenu();
                break;
            case 'insert-code': {
                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;
                if (selectedText) {
                    this.callbacks.insertCode(selectedText);
                    this.hidePopupMenu();
                }
                else {
                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                    if (cellContent) {
                        this.callbacks.insertCode(cellContent);
                        this.hidePopupMenu();
                    }
                    else {
                        // Maybe provide feedback?
                        console.log('POPUP: No code/cell selected to insert.');
                    }
                }
                break;
            }
            case 'insert-cell': {
                const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                if (cellContent) {
                    this.callbacks.insertCell(cellContent);
                    this.hidePopupMenu();
                }
                else {
                    console.log('POPUP: No cell content to insert.');
                }
                break;
            }
            case 'browse-files':
                await this.navigateMenu('files', this.currentMenuPath || '');
                // Don't clear search here, navigation handles focus/render
                break;
            case 'browse-directories':
                await this.navigateMenu('directories', this.currentMenuPath || '');
                // Don't clear search here
                break;
            case 'select-file':
                if (path && this.currentMenuLevel === 'files') { // Ensure we are in the right mode
                    this.callbacks.insertFilePath(path);
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: File selected but path is missing or not in file mode.');
                }
                break;
            case 'select-directory-navigate': // Navigate into dir when in file view
                if (path) {
                    await this.navigateMenu('files', path); // Navigate deeper, still looking for files
                }
                else {
                    console.error('POPUP: Directory selected for navigation but path is missing.');
                }
                break;
            case 'select-directory-callback': // Select dir when in directory view
                if (path && this.currentMenuLevel === 'directories') { // Ensure we are in the right mode
                    this.callbacks.insertDirectoryPath(path); // Use the callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected for callback but path is missing or not in directory mode.');
                }
                break;
            case 'loading':
            case 'empty':
            case 'error':
                break;
            default:
                console.warn('Unknown or invalid menu action:', actionId);
                // this.hidePopupMenu(); // Maybe don't hide on unknown action
                break;
        }
        event.stopPropagation(); // Stop propagation after handling click
    }
    async navigateMenu(level, path) {
        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);
        // Only push history if we are actually moving to a new state
        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {
            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
        }
        this.currentMenuLevel = level;
        this.currentMenuPath = path;
        this.searchInput.value = ''; // Clear search on explicit navigation
        this.currentDirectoryItems = null; // Clear cache for new directory
        // Render the new view structure (will fetch items)
        await this.renderMenuContent();
        // Focus search input after navigating to file/dir view
        if (level === 'files' || level === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0);
        }
        // Selection is handled by renderMenuContent/fetchAndPopulate
    }
    navigateBackMenu() {
        const previousState = this.menuHistory.pop();
        if (previousState) {
            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);
            this.currentMenuLevel = previousState.level;
            this.currentMenuPath = previousState.path;
            this.searchInput.value = ''; // Clear search on back navigation too? Or keep it? Let's clear.
            this.currentDirectoryItems = null; // Clear cache when going back
            this.renderMenuContent().then(() => {
                // Focus search input if going back to file/dir view
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    setTimeout(() => this.searchInput.focus(), 0);
                }
                else {
                    // Select first item if going back to top level
                    this.selectedMenuItemIndex = -1;
                    setTimeout(() => this.selectNextMenuItem(), 0);
                }
            });
        }
        else {
            console.log('POPUP: Already at the top level.');
            // Don't hide here, maybe user hit backspace accidentally
            // this.hidePopupMenu();
        }
    }
    async listCurrentDirectoryContents(basePath) {
        console.log(`POPUP: Listing directory contents for path: '${basePath}'`);
        try {
            const effectivePath = basePath === '/' ? '' : basePath;
            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;
            const contents = await this.docManager.services.contents.get(pathForApi || '');
            if (contents.type === 'directory') {
                let items = contents.content.map((item) => ({
                    name: item.name,
                    path: item.path,
                    type: item.type === 'directory' ? 'directory' : 'file'
                }));
                items = items.filter((item) => item.type === 'file' || item.type === 'directory');
                console.log(`POPUP: Raw directory items for '${basePath}':`, items.length);
                return items.sort((a, b) => {
                    if (a.type === 'directory' && b.type !== 'directory')
                        return -1;
                    if (a.type !== 'directory' && b.type === 'directory')
                        return 1;
                    return a.name.localeCompare(b.name);
                });
            }
            else {
                console.error('Path is not a directory:', basePath);
                return []; // Return empty array instead of null for consistency
            }
        }
        catch (error) {
            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);
            return []; // Return empty array on error
        }
    }
    async setCurrentDirectoryPath() {
        var _a;
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            this.currentMenuPath = '';
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                dirPath = this.getParentDirectory(path);
                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);
            }
        }
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            if (typeof notebookPath === 'string') {
                dirPath = this.getParentDirectory(notebookPath);
                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);
            }
        }
        if (dirPath === null) {
            try {
                const leftWidgets = Array.from(app.shell.widgets('left'));
                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
                if (fileBrowserWidget && ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path)) {
                    dirPath = fileBrowserWidget.model.path;
                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);
                }
                else {
                    console.log('POPUP: File browser widget path not directly accessible.');
                }
            }
            catch (e) {
                console.warn('POPUP: Could not get path from file browser.', e);
            }
        }
        if (dirPath === null) {
            dirPath = '';
            console.log('POPUP: Falling back to server root path.');
        }
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);
    }
    getParentDirectory(path) {
        if (!path)
            return '';
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));
        if (lastSlash === -1)
            return ''; // No directory part, likely root or just a filename
        return path.substring(0, lastSlash);
    }
    /**
     * Handle keyboard navigation when the popup menu is shown
     */
    handleKeyDown(event) {
        if (this.popupMenuContainer.style.display === 'none') {
            return; // Menu not visible
        }
        // --- Check if the event target is the search input FIRST ---
        if (event.target === this.searchInput) {
            console.log(`POPUP KeyDown (Target Search): Key='${event.key}'`);
            switch (event.key) {
                case 'Escape':
                    event.preventDefault(); // Prevent default Esc behavior (like clearing input)
                    // Stop propagation handled by input's listener, but do it again just in case
                    event.stopPropagation();
                    this.hidePopupMenu();
                    break;
                case 'Enter':
                    event.preventDefault(); // Prevent form submission
                    event.stopPropagation();
                    // Maybe select first item?
                    const menuItemsForEnter = this.getMenuItems();
                    if (menuItemsForEnter.length > 0) {
                        this.selectedMenuItemIndex = 0; // Select first
                        this.updateSelectionHighlight();
                        menuItemsForEnter[0].click(); // Activate first item
                    }
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    event.preventDefault(); // Prevent cursor move in input
                    event.stopPropagation();
                    this.searchInput.blur(); // Move focus away
                    if (event.key === 'ArrowDown') {
                        this.selectNextMenuItem(); // Select first item
                    }
                    else {
                        this.selectPreviousMenuItem(); // Select last item
                    }
                    break;
                case 'Tab':
                    // Allow default tab behavior *or* implement custom cycle
                    event.preventDefault(); // Prevent default tab
                    event.stopPropagation();
                    // Tab moves focus to the first menu item
                    this.searchInput.blur();
                    this.selectNextMenuItem(); // Selects first
                    // Optionally focus the item visually:
                    // this.getMenuItems()[this.selectedMenuItemIndex]?.focus();
                    break;
                default:
                    // Allow Backspace, letters, etc. - DO NOTHING HERE
                    // Let the browser handle the input field editing.
                    // The 'input' event listener will handle re-filtering the list.
                    console.log(`POPUP KeyDown (Target Search): Allowing default for key '${event.key}'`);
                    // Crucially, DO NOT stopPropagation or preventDefault
                    break;
            }
            // Handled or allowed default, return from main handler
            return;
        }
        // --- If the event target is NOT the search input ---
        console.log(`POPUP KeyDown (Target Menu): Key='${event.key}'`);
        const menuItems = this.getMenuItems();
        switch (event.key) {
            case 'ArrowDown':
            case 'ArrowUp': // Consolidate arrow handling
                if (menuItems.length > 0) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.key === 'ArrowDown')
                        this.selectNextMenuItem();
                    else
                        this.selectPreviousMenuItem();
                }
                break;
            case 'Backspace':
                if (this.menuHistory.length > 0) {
                    event.preventDefault(); // Prevent default only if navigating
                    event.stopPropagation();
                    this.navigateBackMenu();
                }
                else {
                    // At top level, DO NOTHING - allow backspace to potentially affect chat input
                    console.log('POPUP KeyDown (Target Menu): Allowing Backspace at top level.');
                }
                break;
            case 'Enter':
                if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {
                    event.preventDefault();
                    event.stopPropagation();
                    console.log(`POPUP KeyDown (Target Menu): Clicking item ${this.selectedMenuItemIndex}`);
                    menuItems[this.selectedMenuItemIndex].click();
                }
                break;
            case 'Tab':
                event.preventDefault(); // Prevent default tab
                event.stopPropagation();
                // If in file/dir view, Tab from menu moves to search input
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    this.deselectAllMenuItems();
                    this.searchInput.focus();
                }
                else {
                    // From top-level menu, maybe close? Or cycle? Let's close.
                    this.hidePopupMenu();
                }
                break;
            case 'Escape':
                event.preventDefault();
                event.stopPropagation();
                this.hidePopupMenu();
                break;
            default:
                // If typing a character and in file/dir view, focus search
                if ((this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') &&
                    event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.searchInput.focus();
                    // Append character and trigger input event
                    this.searchInput.value += event.key;
                    this.searchInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
                break;
        }
    }
    updateSelectionHighlight() {
        const menuItems = this.getMenuItems();
        console.log(`POPUP updateSelectionHighlight: Highlighting index ${this.selectedMenuItemIndex} among ${menuItems.length} items.`);
        menuItems.forEach((item, index) => {
            if (index === this.selectedMenuItemIndex) {
                if (!item.classList.contains('selected')) {
                    item.classList.add('selected');
                    console.log(`POPUP updateSelectionHighlight: Added 'selected' to item ${index}`);
                    // Ensure item is visible
                    item.scrollIntoView({ block: 'nearest' });
                }
            }
            else {
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    console.log(`POPUP updateSelectionHighlight: Removed 'selected' from item ${index}`);
                }
            }
        });
    }
    deselectAllMenuItems() {
        const menuItems = this.getMenuItems();
        menuItems.forEach(item => item.classList.remove('selected'));
        this.selectedMenuItemIndex = -1;
    }
    selectNextMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectNext: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the next item or loop back to the first
        this.selectedMenuItemIndex = (this.selectedMenuItemIndex + 1) % menuItems.length;
        console.log(`POPUP selectNext: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    selectPreviousMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectPrevious: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the previous item or loop to the last
        this.selectedMenuItemIndex = this.selectedMenuItemIndex <= 0 ?
            menuItems.length - 1 : this.selectedMenuItemIndex - 1;
        console.log(`POPUP selectPrevious: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    /**
     * Get all interactive menu items from the items container
     */
    getMenuItems() {
        // Query only within the specific items container
        const items = Array.from(this.itemsContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));
        return items.filter(item => {
            const actionId = item.dataset.actionId;
            // Filter out non-interactive items
            return actionId && actionId !== 'loading' && actionId !== 'empty' && actionId !== 'error';
        });
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
const markdown_config_1 = __webpack_require__(/*! ./markdown-config */ "./node_modules/jupyter-simple-extension/lib/markdown-config.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js");
// Configure marked with our settings
(0, markdown_config_1.configureMarked)();
/**
 * Main sidebar widget for the AI chat interface
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    constructor(docManager) {
        super();
        this.isMarkdownMode = false;
        this.isInputExpanded = false;
        this.chatHistory = [];
        this.currentChatId = '';
        this.isHistoryViewActive = false;
        /**
         * Handles keyboard shortcuts
         */
        this.handleKeyDown = (event) => {
            var _a, _b;
            // Check for @ key (for context menu) - changed from Ctrl+@
            if (event.key === '@') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Only show menu if input field is focused
                if (document.activeElement === this.inputField) {
                    // Get cursor position in input field
                    const cursorPosition = this.inputField.selectionStart || 0;
                    const textBeforeCursor = this.inputField.value.substring(0, cursorPosition);
                    // Calculate position to show menu
                    const inputRect = this.inputField.getBoundingClientRect();
                    const lineHeight = parseInt(window.getComputedStyle(this.inputField).lineHeight) || 20;
                    // Count newlines before cursor to determine vertical position
                    const linesBeforeCursor = (textBeforeCursor.match(/\n/g) || []).length;
                    // Calculate cursor position within current line
                    const lastNewline = textBeforeCursor.lastIndexOf('\n');
                    const charsInCurrentLine = lastNewline === -1 ? cursorPosition : cursorPosition - lastNewline - 1;
                    // Estimate horizontal position (using average character width)
                    const charWidth = 8; // Approximate width of a character in pixels
                    const horizontalOffset = charsInCurrentLine * charWidth;
                    // Calculate positions
                    const left = inputRect.left + horizontalOffset;
                    // Calculate the cursor's vertical position
                    const cursorTop = inputRect.top + (linesBeforeCursor * lineHeight);
                    console.log(`Showing popup at cursor position: (${left}, ${cursorTop})`);
                    // Insert @ symbol at cursor position
                    const newValue = this.inputField.value.substring(0, cursorPosition) +
                        '@' +
                        this.inputField.value.substring(cursorPosition);
                    this.inputField.value = newValue;
                    // Move cursor after the @ symbol
                    this.inputField.selectionStart = cursorPosition + 1;
                    this.inputField.selectionEnd = cursorPosition + 1;
                    // Show the popup menu above the cursor position
                    this.popupMenuManager.showPopupMenu(left + 60, cursorTop - 20);
                    this.showKeyboardShortcutIndicator('Context menu opened');
                }
            }
            // Check for Ctrl+L (for selected code)
            else if (event.ctrlKey && event.key.toLowerCase() === 'l') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Get the current active cell
                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
                if (!cell || !cell.editor) {
                    return;
                }
                try {
                    // Get the CodeMirror editor instance
                    const editor = cell.editor;
                    const view = editor.editor;
                    if (!view) {
                        return;
                    }
                    // Check if there's a selection
                    const state = view.state;
                    const selection = state.selection;
                    if (!selection.main.empty) {
                        // If there's a selection, use @code
                        const from = selection.main.from;
                        const to = selection.main.to;
                        const selectedText = state.doc.sliceString(from, to);
                        this.appendToInput(`@code ${selectedText}`);
                        this.showKeyboardShortcutIndicator('Selected code inserted');
                    }
                    else {
                        // If no selection, use @cell
                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();
                        if (cellContext) {
                            this.appendToInput(`@cell ${cellContext.text}`);
                            this.showKeyboardShortcutIndicator('Cell content inserted');
                        }
                    }
                    // Ensure the sidebar is visible and focused
                    if (this.isHidden) {
                        this.show();
                    }
                    this.inputField.focus();
                }
                catch (error) {
                    console.error('Error handling keyboard shortcut:', error);
                }
            }
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        // Add the main CSS class for styling
        this.addClass('jp-llm-ext-sidebar');
        // Initialize API client
        this.apiClient = new api_client_1.ApiClient();
        // Initialize container elements before creating layout
        this.messageContainer = document.createElement('div');
        this.inputField = document.createElement('textarea');
        this.titleInput = document.createElement('input');
        this.historyContainer = document.createElement('div');
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'jp-llm-ext-keyboard-shortcut-indicator';
        this.node.appendChild(this.keyboardShortcutIndicator);
        // Create settings modal
        this.settingsModalContainer = this.createSettingsModal();
        this.node.appendChild(this.settingsModalContainer);
        // Instantiate the PopupMenuManager with callbacks
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {
            insertCode: (code) => this.appendToInput(`code ${code}`),
            insertCell: (content) => this.appendToInput(`cell ${content}`),
            insertFilePath: (path) => this.appendToInput(`file ${path}`),
            insertDirectoryPath: (path) => this.appendToInput(`directory ${path}`), // If needed
            getSelectedText: () => this.getSelectedText(),
            getCurrentCellContent: () => this.getCurrentCellContent(),
        });
        // Create a new chat on start
        this.createNewChat();
        this.node.appendChild(this.createLayout());
        // Pop-up menu will be attached to document.body when shown
        // Add keyboard shortcut listener
        document.addEventListener('keydown', this.handleKeyDown);
    }
    /**
     * Shows a visual indicator for keyboard shortcuts
     */
    showKeyboardShortcutIndicator(text) {
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Hide after 1 second
        setTimeout(() => {
            this.keyboardShortcutIndicator.classList.remove('visible');
        }, 1000);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        // Remove keyboard shortcut listener
        document.removeEventListener('keydown', this.handleKeyDown);
        // Remove keyboard shortcut indicator
        if (this.keyboardShortcutIndicator.parentNode) {
            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);
        }
        // Dispose the popup menu manager
        if (this.popupMenuManager) {
            this.popupMenuManager.dispose();
        }
        super.dispose();
    }
    /**
     * Creates the main layout for the sidebar
     */
    createLayout() {
        // Create the main container
        const mainContent = document.createElement('div');
        // The main class 'jp-llm-ext-sidebar' is added to this.node in the constructor
        // This container can have its own class if needed for further nesting/styling
        mainContent.className = 'jp-llm-ext-content-wrapper';
        // Create title input container
        const titleContainer = document.createElement('div');
        titleContainer.className = 'jp-llm-ext-title-container';
        // Set up title input
        this.titleInput.className = 'chat-title-input'; // Assuming this is styled correctly in CSS
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat';
        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());
        titleContainer.appendChild(this.titleInput);
        // Create New Chat & History buttons
        const newChatButton = document.createElement('button');
        newChatButton.className = 'jp-Button jp-llm-ext-action-button';
        newChatButton.textContent = '+ New Chat';
        newChatButton.title = 'Start a new chat';
        newChatButton.addEventListener('click', () => this.createNewChat());
        const historyButton = document.createElement('button');
        historyButton.className = 'jp-Button jp-llm-ext-action-button';
        historyButton.textContent = 'History';
        historyButton.title = 'View chat history';
        historyButton.addEventListener('click', () => this.toggleHistoryView());
        // Configure message container
        this.messageContainer.className = 'jp-llm-ext-message-container';
        // Configure history container
        this.historyContainer.className = 'jp-llm-ext-history-container';
        this.historyContainer.style.display = 'none';
        // Configure input field (directly used later)
        this.inputField.placeholder = 'Ask me anything...';
        this.inputField.rows = 1;
        this.inputField.className = 'jp-llm-ext-input-field'; // Add class for styling
        // Add keypress listener to input field
        this.inputField.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.handleSendMessage();
            }
        });
        // Create send button container (directly used later)
        const inputActionsContainer = document.createElement('div');
        inputActionsContainer.className = 'jp-llm-ext-input-actions-container';
        // Create send button
        const sendButton = document.createElement('button');
        sendButton.className = 'jp-Button jp-llm-ext-send-button';
        sendButton.textContent = 'Send';
        sendButton.addEventListener('click', () => this.handleSendMessage());
        inputActionsContainer.appendChild(sendButton);
        // Create controls container (Markdown toggle, @, etc.) (directly used later)
        const controlsContainer = this.createControlsContainer();
        // Create the new bottom bar container with three rows
        const bottomBarContainer = document.createElement('div');
        bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';
        this.bottomBarContainer = bottomBarContainer;
        // First row: Controls (Markdown toggle and action buttons)
        const topRow = document.createElement('div');
        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';
        topRow.appendChild(controlsContainer);
        // Second row: Input field
        const middleRow = document.createElement('div');
        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';
        middleRow.appendChild(this.inputField);
        // Third row: Action buttons (Send, New Chat, History)
        const bottomRow = document.createElement('div');
        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';
        // Add all buttons to bottom row
        bottomRow.appendChild(sendButton);
        bottomRow.appendChild(newChatButton);
        bottomRow.appendChild(historyButton);
        // Add all rows to the bottom bar container
        bottomBarContainer.appendChild(topRow);
        bottomBarContainer.appendChild(middleRow);
        bottomBarContainer.appendChild(bottomRow);
        // Assemble all main components
        mainContent.appendChild(titleContainer);
        mainContent.appendChild(this.messageContainer);
        mainContent.appendChild(this.historyContainer);
        mainContent.appendChild(bottomBarContainer);
        return mainContent;
    }
    /**
     * Creates a new chat session
     */
    createNewChat() {
        // Generate a unique ID for the chat
        const chatId = `chat-${Date.now()}`;
        // Create a new chat item
        const newChat = {
            id: chatId,
            title: 'New Chat',
            messages: []
        };
        // Add to history
        this.chatHistory.push(newChat);
        // Set as current chat
        this.currentChatId = chatId;
        // Update title input
        this.titleInput.value = newChat.title;
        // Clear message container
        if (this.messageContainer) {
            this.messageContainer.innerHTML = '';
        }
        // Hide history if it's visible
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Toggles between chat view and history view
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Show history view, hide message view and bottom bar
            this.messageContainer.style.display = 'none';
            this.historyContainer.style.display = 'block';
            this.bottomBarContainer.style.display = 'none'; // Use class property directly
            this.titleInput.style.display = 'none';
            // Populate history
            this.renderChatHistory();
        }
        else {
            // Show message view and bottom bar, hide history view
            this.messageContainer.style.display = 'block';
            this.historyContainer.style.display = 'none';
            this.bottomBarContainer.style.display = 'flex'; // Use class property directly
            this.titleInput.style.display = 'block';
        }
    }
    /**
     * Renders the chat history in the history container
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = '';
        if (this.chatHistory.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'jp-llm-ext-empty-history-message';
            emptyMessage.textContent = 'No chat history yet';
            this.historyContainer.appendChild(emptyMessage);
            return;
        }
        // Create a list of chat history items
        this.chatHistory.forEach(chat => {
            const historyItem = document.createElement('div');
            historyItem.className = 'jp-llm-ext-history-item';
            if (chat.id === this.currentChatId) {
                historyItem.classList.add('jp-llm-ext-active');
            }
            // Add title
            const title = document.createElement('div');
            title.className = 'jp-llm-ext-history-title';
            title.textContent = chat.title;
            // Add message preview
            const preview = document.createElement('div');
            preview.className = 'jp-llm-ext-history-preview';
            const lastMessage = chat.messages[chat.messages.length - 1];
            preview.textContent = lastMessage
                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`
                : 'Empty chat';
            // Add click event
            historyItem.addEventListener('click', () => this.loadChat(chat.id));
            historyItem.appendChild(title);
            historyItem.appendChild(preview);
            this.historyContainer.appendChild(historyItem);
        });
    }
    /**
     * Loads a chat from history
     */
    loadChat(chatId) {
        const chat = this.chatHistory.find(c => c.id === chatId);
        if (!chat)
            return;
        // Set as current chat
        this.currentChatId = chatId;
        // Update title
        this.titleInput.value = chat.title;
        // Clear and re-populate message container
        this.messageContainer.innerHTML = '';
        chat.messages.forEach(msg => {
            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);
        });
        // Switch back to chat view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Updates the title of the current chat
     */
    updateCurrentChatTitle() {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            chat.title = this.titleInput.value;
        }
    }
    /**
     * Creates the controls container with toggles and action buttons
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'jp-llm-ext-controls-container';
        // Create markdown toggle container
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'jp-llm-ext-toggle-container';
        // Create markdown toggle
        const markdownToggle = document.createElement('input');
        markdownToggle.type = 'checkbox';
        markdownToggle.id = 'markdown-toggle';
        // markdownToggle.style.marginRight = '5px'; // Style via CSS
        markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            this.inputField.placeholder = this.isMarkdownMode ?
                'Write markdown here...\n\n# Example heading\n- List item\n\n```code block```' :
                'Ask me anything...';
        });
        // Create toggle label
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        // toggleLabel.style.fontSize = '12px'; // Style via CSS
        // Add toggle elements to container
        toggleContainer.appendChild(markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // Create action buttons container (@, expand, settings)
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';
        // Create all action buttons
        const buttons = [
            {
                text: '@',
                title: 'Insert context (@)',
                action: (event) => {
                    // Get the button's position
                    const targetButton = event.currentTarget;
                    const rect = targetButton.getBoundingClientRect();
                    // Show the popup menu above the button's top edge
                    this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);
                    event.preventDefault();
                    event.stopPropagation();
                }
            },
            { text: '⤢', title: 'Expand input', action: () => this.toggleInputExpansion(actionButtonsContainer.children[3]) },
            { text: '⚙️', title: 'Settings', action: (event) => { event.preventDefault(); event.stopPropagation(); this.showSettingsModal(); } },
        ];
        // Add all buttons to the container
        buttons.forEach(button => {
            const btn = this.createButton(button.text, button.title);
            btn.addEventListener('click', (e) => button.action(e));
            actionButtonsContainer.appendChild(btn);
        });
        // Add toggle and action buttons to the controls container
        // controlsContainer is now just for these inline controls, above the input field
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field
     */
    toggleInputExpansion(button) {
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            // Adjust height based on a class or CSS variable instead of fixed pixels if possible
            this.inputField.style.height = '200px';
            this.inputField.style.resize = 'vertical';
            button.textContent = '⤡';
            button.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = ''; // Reset height
            this.inputField.style.resize = 'none';
            this.inputField.rows = 1; // Ensure it collapses back to 1 row height
            button.textContent = '⤢';
            button.title = 'Expand input';
        }
    }
    /**
     * Helper function to create a button with given text and tooltip
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        button.className = 'jp-Button jp-llm-ext-action-button';
        return button;
    }
    /**
     * Handles sending a message from the input field
     */
    handleSendMessage() {
        const message = this.inputField.value.trim();
        if (message) {
            // Add user message to UI
            this.addMessage(message, 'user', this.isMarkdownMode);
            this.inputField.value = '';
            this.inputField.rows = 1; // Reset rows after sending
            this.inputField.style.height = ''; // Reset height after sending
            // Reset expanded state if needed after sending
            if (this.isInputExpanded) {
                // Find the expand button to reset its state if needed (this might need adjustment based on final structure)
                const expandButton = this.node.querySelector('.jp-llm-ext-action-buttons-container button[title*="Collapse"]');
                if (expandButton) {
                    this.toggleInputExpansion(expandButton); // Collapse after sending
                }
                else {
                    this.inputField.style.height = ''; // Fallback reset
                    this.inputField.rows = 1;
                }
            }
            // Create a temporary message container for the bot's streaming response
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'jp-llm-ext-bot-message';
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            botMessageDiv.appendChild(markdownIndicator);
            // Create separate divs for streaming text and final markdown
            const streamingDiv = document.createElement('div');
            streamingDiv.className = 'streaming-content';
            streamingDiv.style.whiteSpace = 'pre-wrap';
            streamingDiv.style.fontFamily = 'monospace';
            streamingDiv.style.fontSize = '0.9em';
            botMessageDiv.appendChild(streamingDiv);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            contentDiv.style.display = 'none'; // Initially hidden
            botMessageDiv.appendChild(contentDiv);
            this.messageContainer.appendChild(botMessageDiv);
            // Variable to collect the complete response
            let completeResponse = '';
            // Get cell context if available
            const cellContext = globals_1.globals.cellContextTracker ?
                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;
            // Stream response from API
            this.apiClient.streamChat(message, { cellContext }, 
            // On each chunk received
            (chunk) => {
                completeResponse += chunk;
                streamingDiv.textContent = completeResponse;
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On complete
            () => {
                // Hide streaming div, show markdown div
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                // Pre-process and render markdown
                try {
                    // Pre-process the markdown to fix any issues with code blocks
                    const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
                    // Parse and sanitize
                    const rawHtml = marked_1.marked.parse(processedMarkdown);
                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                    // Apply the HTML with proper code block styling
                    contentDiv.innerHTML = sanitizedHtml;
                    // Add syntax highlighting classes to code blocks
                    const codeBlocks = contentDiv.querySelectorAll('pre code');
                    codeBlocks.forEach(block => {
                        var _a;
                        block.classList.add('jp-RenderedText');
                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                    });
                    // Add action buttons to the bot message
                    console.log('Adding action buttons to streamed bot message');
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'jp-llm-ext-message-actions';
                    actionsDiv.style.display = 'flex'; // Ensure display is set
                    // Copy button with icon
                    const copyButton = document.createElement('button');
                    copyButton.className = 'jp-llm-ext-message-action-button';
                    copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    copyButton.title = 'Copy message to clipboard';
                    copyButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.copyMessageToClipboard(completeResponse);
                    });
                    actionsDiv.appendChild(copyButton);
                    // Add to button with icon
                    const addToButton = document.createElement('button');
                    addToButton.className = 'jp-llm-ext-message-action-button';
                    addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                    addToButton.title = 'Add message to current cell';
                    addToButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.addMessageToCell(completeResponse);
                    });
                    actionsDiv.appendChild(addToButton);
                    // Add buttons to message
                    botMessageDiv.appendChild(actionsDiv);
                    console.log('Action buttons added to bot message:', actionsDiv);
                }
                catch (error) {
                    contentDiv.textContent = completeResponse;
                    console.error('Failed to render markdown:', error);
                }
                // Save to chat history
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages.push({
                        text: completeResponse,
                        sender: 'bot',
                        isMarkdown: true
                    });
                }
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On error
            (error) => {
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                contentDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                console.error('API Error:', error);
            });
        }
    }
    /**
     * Adds a message to the chat interface
     */
    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {
        console.log('Adding message:', { sender, isMarkdown }); // Debug log
        const messageDiv = document.createElement('div');
        messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';
        // Add message content
        if (isMarkdown || sender === 'bot') {
            // Bot messages are always rendered as markdown
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            messageDiv.appendChild(markdownIndicator);
            // Create a container for the rendered markdown
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            try {
                // Pre-process the markdown text
                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
                // Parse and render markdown
                const rawHtml = marked_1.marked.parse(processedText);
                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                contentDiv.innerHTML = sanitizedHtml;
                // Add syntax highlighting classes to code blocks
                const codeBlocks = contentDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    var _a;
                    block.classList.add('jp-RenderedText');
                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                });
            }
            catch (error) {
                contentDiv.textContent = text;
                console.error('Failed to render markdown:', error);
            }
            messageDiv.appendChild(contentDiv);
            // Add action buttons for bot messages
            if (sender === 'bot') {
                console.log('Adding action buttons to bot message'); // Debug log
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'jp-llm-ext-message-actions';
                // Copy button with icon
                const copyButton = document.createElement('button');
                copyButton.className = 'jp-llm-ext-message-action-button';
                copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                copyButton.title = 'Copy message to clipboard';
                copyButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.copyMessageToClipboard(text);
                });
                actionsDiv.appendChild(copyButton);
                // Add to button with icon
                const addToButton = document.createElement('button');
                addToButton.className = 'jp-llm-ext-message-action-button';
                addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                addToButton.title = 'Add message to current cell';
                addToButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.addMessageToCell(text);
                });
                actionsDiv.appendChild(addToButton);
                // Add buttons to message
                messageDiv.appendChild(actionsDiv);
                console.log('Action buttons added to message:', actionsDiv); // Debug log
            }
        }
        else {
            messageDiv.textContent = text;
        }
        this.messageContainer.appendChild(messageDiv);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        // Save to chat history
        if (saveToHistory) {
            const chat = this.chatHistory.find(c => c.id === this.currentChatId);
            if (chat) {
                chat.messages.push({
                    text,
                    sender,
                    isMarkdown: isMarkdown || sender === 'bot'
                });
            }
        }
    }
    /**
     * Copies message content to clipboard
     */
    copyMessageToClipboard(text) {
        try {
            navigator.clipboard.writeText(text).then(() => {
                console.log('Content copied to clipboard');
                // Find the button element that was clicked
                const buttons = document.querySelectorAll('.jp-llm-ext-message-action-button');
                let clickedButton = null;
                for (let i = 0; i < buttons.length; i++) {
                    const button = buttons[i];
                    if (button.title === 'Copy message to clipboard' && button === document.activeElement) {
                        clickedButton = button;
                        break;
                    }
                }
                // Show visual feedback if we found the button
                if (clickedButton) {
                    const originalHTML = clickedButton.innerHTML;
                    clickedButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                    setTimeout(() => {
                        clickedButton.innerHTML = originalHTML;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        catch (error) {
            console.error('Error copying to clipboard:', error);
        }
    }
    /**
     * Adds message content to the current cell
     */
    addMessageToCell(text) {
        var _a;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell || !cell.editor) {
            return;
        }
        try {
            const editor = cell.editor;
            const view = editor.editor;
            if (!view) {
                return;
            }
            // Get current cursor position
            const state = view.state;
            const selection = state.selection;
            const cursorPos = selection.main.head;
            // Insert newline and message content at cursor position
            const transaction = state.update({
                changes: {
                    from: cursorPos,
                    insert: `\n${text}`
                },
                selection: { anchor: cursorPos + text.length + 1 }
            });
            view.dispatch(transaction);
        }
        catch (error) {
            console.error('Error adding message to cell:', error);
        }
    }
    /**
     * Gets the currently selected text from the active notebook cell.
     * (Helper for PopupMenuManager callback)
     */
    getSelectedText() {
        var _a, _b, _c;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (cell === null || cell === void 0 ? void 0 : cell.editor) {
            const editor = cell.editor; // IEditor
            // Access CodeMirror editor instance if possible
            const cmEditor = editor.editor;
            if (cmEditor && cmEditor.state) {
                const state = cmEditor.state;
                const selection = state.selection.main; // Get the main selection
                if (selection.empty) {
                    return null; // No text selected
                }
                return state.doc.sliceString(selection.from, selection.to);
            }
            console.warn("Could not access CodeMirror state to get selection.");
            // Avoid using getRange as it's confirmed not to exist on IEditor
            return null;
        }
        else {
            // Attempt to get selection from document if no notebook active (e.g., text editor)
            const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
            if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {
                const editor = activeWidget.content.editor;
                const cmEditor = editor.editor;
                if (cmEditor && cmEditor.state) {
                    const state = cmEditor.state;
                    const selection = state.selection.main;
                    if (selection.empty) {
                        return null;
                    }
                    return state.doc.sliceString(selection.from, selection.to);
                }
                console.warn("Could not access CodeMirror state for non-notebook editor selection.");
                return null; // Avoid getRange
            }
        }
        return null;
    }
    /**
     * Gets the content of the currently active notebook cell.
     * (Helper for PopupMenuManager callback)
     */
    getCurrentCellContent() {
        var _a, _b, _c;
        const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {
            // Try using sharedModel first (more robust)
            if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {
                return activeCell.model.sharedModel.getSource();
            }
            // Fallback: Try using toJSON().source
            const cellJson = activeCell.model.toJSON();
            if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {
                return cellJson.source;
            }
            else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {
                // If source is an array of strings, join them
                return cellJson.source.join('\n');
            }
            console.warn("Could not get cell content via model.value.text or toJSON().source");
            return null;
        }
        // Fallback for non-notebook editors if needed
        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
        if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {
            return activeWidget.content.model.value.text;
        }
        return null;
    }
    /**
     * Appends text to the input field with proper spacing
     */
    appendToInput(text) {
        try {
            const currentValue = this.inputField.value;
            if (currentValue) {
                // add a space between the current value and the new text
                this.inputField.value = `${currentValue}${text}`;
            }
            else {
                this.inputField.value = text;
            }
            // Focus the input field and move cursor to end
            this.inputField.focus();
            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    // Settings modal methods
    createSettingsModal() {
        const modal = document.createElement('div');
        modal.className = 'jp-llm-ext-settings-modal';
        modal.style.display = 'none'; // Keep this inline style for toggling visibility
        const content = document.createElement('div');
        content.className = 'jp-llm-ext-settings-content';
        const title = document.createElement('h2');
        title.className = 'jp-llm-ext-settings-title';
        title.textContent = 'Settings';
        content.appendChild(title);
        const form = document.createElement('form');
        form.className = 'jp-llm-ext-settings-form';
        // Provider selection
        const providerLabel = document.createElement('label');
        providerLabel.className = 'jp-llm-ext-settings-label';
        providerLabel.textContent = 'API Provider:';
        form.appendChild(providerLabel);
        const providerSelect = document.createElement('select');
        providerSelect.className = 'jp-llm-ext-settings-select';
        providerSelect.id = 'settings-provider';
        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            providerSelect.appendChild(option);
        });
        form.appendChild(providerSelect);
        // API Key input
        const apiKeyLabel = document.createElement('label');
        apiKeyLabel.className = 'jp-llm-ext-settings-label';
        apiKeyLabel.textContent = 'API Key:';
        form.appendChild(apiKeyLabel);
        const apiKeyInput = document.createElement('input');
        apiKeyInput.className = 'jp-llm-ext-settings-input';
        apiKeyInput.type = 'password';
        apiKeyInput.id = 'settings-api-key';
        form.appendChild(apiKeyInput);
        // API URL input
        const apiUrlLabel = document.createElement('label');
        apiUrlLabel.className = 'jp-llm-ext-settings-label';
        apiUrlLabel.textContent = 'API URL (optional):';
        form.appendChild(apiUrlLabel);
        const apiUrlInput = document.createElement('input');
        apiUrlInput.className = 'jp-llm-ext-settings-input';
        apiUrlInput.type = 'text';
        apiUrlInput.id = 'settings-api-url';
        form.appendChild(apiUrlInput);
        // Rules input
        const rulesLabel = document.createElement('label');
        rulesLabel.className = 'jp-llm-ext-settings-label';
        rulesLabel.textContent = 'Custom Rules (optional):';
        form.appendChild(rulesLabel);
        const rulesInput = document.createElement('textarea');
        rulesInput.className = 'jp-llm-ext-settings-textarea';
        rulesInput.id = 'settings-rules';
        form.appendChild(rulesInput);
        // Buttons container
        const btnContainer = document.createElement('div');
        btnContainer.className = 'jp-llm-ext-settings-buttons';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Add this line
            const provider = document.getElementById('settings-provider').value;
            const key = document.getElementById('settings-api-key').value;
            const url = document.getElementById('settings-api-url').value;
            const rules = document.getElementById('settings-rules').value;
            console.log('Settings saved:', { provider, key, url, rules });
            this.hideSettingsModal();
            this.popSaveSuccess();
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Add this line
            this.hideSettingsModal();
        });
        btnContainer.appendChild(saveBtn);
        btnContainer.appendChild(cancelBtn);
        form.appendChild(btnContainer);
        content.appendChild(form);
        modal.appendChild(content);
        return modal;
    }
    showSettingsModal() {
        this.settingsModalContainer.style.display = 'flex';
    }
    hideSettingsModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    popSaveSuccess() {
        const successMessage = document.createElement('div');
        successMessage.className = 'jp-llm-ext-settings-success-message';
        successMessage.textContent = 'Settings saved successfully';
        this.settingsModalContainer.appendChild(successMessage);
        setTimeout(() => {
            successMessage.remove();
        }, 3000);
    }
}
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy40MTE3MjYyNTdjOTEyOGNkMjdjNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7OztBQ3JFSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0NBQWtDLEVBQUUsMENBQTBDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvYXBpLWNsaWVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jZWxsLWNvbnRleHQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9nbG9iYWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2ljb25zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL21hcmtkb3duLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9wb3B1cC1tZW51LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvc2lkZWJhci13aWRnZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbi8qKlxuICogQVBJIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZCBMTE0gc2VydmljZVxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJykge1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYSBjaGF0IHJlc3BvbnNlIGZyb20gdGhlIG1vY2sgTExNXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIHVzZXIgbWVzc2FnZSB0byBzZW5kXG4gICAgICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBvbkNodW5rIENhbGxiYWNrIGZvciBlYWNoIHRleHQgY2h1bmsgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gb25Db21wbGV0ZSBDYWxsYmFjayB3aGVuIHN0cmVhbWluZyBpcyBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSBvbkVycm9yIENhbGxiYWNrIGZvciBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW1DaGF0KG1lc3NhZ2UsIGNvbnRleHQgPSBudWxsLCBvbkNodW5rLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vY2hhdGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhZGFibGVTdHJlYW0gbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdXAgc3RyZWFtIHJlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZTogcmVhZGVyRG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBkb25lID0gcmVhZGVyRG9uZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06ICFkb25lIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGhlYWx0aCBjaGVjayBmb3IgdGhlIEFQSVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIEFQSSBpcyBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vaGVhbHRoYCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFwaUNsaWVudCA9IEFwaUNsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSB2b2lkIDA7XG4vKipcbiAqIFRyYWNrcyBjZWxsIGNvbnRleHQgYW5kIGN1cnNvciBwb3NpdGlvbiB3aXRoaW4gSnVweXRlciBub3RlYm9va3NcbiAqL1xuY2xhc3MgQ2VsbENvbnRleHRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGVkaXRvciBldmVudHMgKGtleWRvd24sIG1vdXNldXApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUVkaXRvckV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbCBmcm9tIHRoZSB0cmFja2VyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGlubmVyIEVkaXRvclZpZXcgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYW5kIHN0b3JlIHRoZSBjdXJzb3IgY29udGV4dFxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gdGhpcy5nZXRDbUNvbnRleHQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZWRpdG9yIGV2ZW50IGhhbmRsZXI6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG4gICAgICAgIHRoaXMuc2V0dXBUcmFja2VycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGhhcyBiZWVuIGRpc3Bvc2VkXG4gICAgICovXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IHRyYWNrZXJzXG4gICAgICovXG4gICAgc2V0dXBUcmFja2VycygpIHtcbiAgICAgICAgLy8gSGFuZGxlIGFjdGl2ZSBjZWxsIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIC8vIEhhbmRsZSBub3RlYm9vayBjaGFuZ2VzXG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmNvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAqL1xuICAgIGhhbmRsZU5vdGVib29rQ2hhbmdlKHRyYWNrZXIsIHBhbmVsKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmIChwYW5lbCAmJiBwYW5lbC5jb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gcGFuZWwuY29udGVudC5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENlbGxMaXN0ZW5lcnModHJhY2tlciwgY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgc2V0dXBDZWxsTGlzdGVuZXJzKF90cmFja2VyLCBjZWxsKSB7XG4gICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKGNlbGwuZWRpdG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxOb2RlID0gY2VsbC5ub2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvck5vZGUgPSBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtRWRpdG9yJykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUucXVlcnlTZWxlY3RvcignLmpwLUlucHV0QXJlYS1lZGl0b3InKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gZWRpdG9yTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyBmb3Iga2V5IGFuZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY2FwdHVyZSBpbW1lZGlhdGUgY29udGV4dCBpZiBFZGl0b3JWaWV3IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gY2VsbC5lZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZXR0aW5nIHVwIGNlbGwgbGlzdGVuZXJzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBhY3RpdmUgY2VsbFxuICAgICAqL1xuICAgIGNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbnRleHQgaW5mb3JtYXRpb24gZnJvbSBDb2RlTWlycm9yIEVkaXRvclZpZXdcbiAgICAgKi9cbiAgICBnZXRDbUNvbnRleHQodmlldykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIGNvbnN0IGZ1bGxUZXh0ID0gc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGluZTogbGluZS5udW1iZXIgLSAxLFxuICAgICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBsaW5lLmZyb20sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0UmFkaXVzID0gMTAwO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIG9mZnNldCAtIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihmdWxsVGV4dC5sZW5ndGgsIG9mZnNldCArIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBjb250ZXh0QmVmb3JlOiBmdWxsVGV4dC5zdWJzdHJpbmcoc3RhcnQsIG9mZnNldCksXG4gICAgICAgICAgICBjb250ZXh0QWZ0ZXI6IGZ1bGxUZXh0LnN1YnN0cmluZyhvZmZzZXQsIGVuZClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBjZWxsIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2VsbENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDZWxsQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgYWxsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGxDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5zZXR1cENlbGxMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuaGFuZGxlTm90ZWJvb2tDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2VsbENvbnRleHRUcmFja2VyID0gQ2VsbENvbnRleHRUcmFja2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2lzdGVyQ29tbWFuZHMgPSByZWdpc3RlckNvbW1hbmRzO1xuY29uc3QgaWNvbnNfMSA9IHJlcXVpcmUoXCIuL2ljb25zXCIpO1xuLyoqXG4gKiBSZWdpc3RlcnMgY29tbWFuZHMgZm9yIHRoZSBleHRlbnNpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcyhhcHAsIHBhbGV0dGUsIGxhdW5jaGVyLCBzaWRlYmFyV2lkZ2V0KSB7XG4gICAgLy8gQWRkIGNvbW1hbmQgdG8gdG9nZ2xlIHRoZSBzaWRlYmFyXG4gICAgYXBwLmNvbW1hbmRzLmFkZENvbW1hbmQoJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLCB7XG4gICAgICAgIGxhYmVsOiAnVG9nZ2xlIEFJIEFzc2lzdGFudCBTaWRlYmFyJyxcbiAgICAgICAgaWNvbjogaWNvbnNfMS5leHRlbnNpb25JY29uLFxuICAgICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2lkZWJhcldpZGdldC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgc2lkZWJhcldpZGdldC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwLnNoZWxsLmFkZChzaWRlYmFyV2lkZ2V0LCAnbGVmdCcsIHsgcmFuazogOTk5OSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgY29tbWFuZCBwYWxldHRlXG4gICAgcGFsZXR0ZS5hZGRJdGVtKHtcbiAgICAgICAgY29tbWFuZDogJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLFxuICAgICAgICBjYXRlZ29yeTogJ0V4dGVuc2lvbidcbiAgICB9KTtcbiAgICAvLyBBZGQgYSBsYXVuY2hlciBpdGVtXG4gICAgbGF1bmNoZXIuYWRkKHtcbiAgICAgICAgY29tbWFuZDogJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLFxuICAgICAgICBjYXRlZ29yeTogJ090aGVyJyxcbiAgICAgICAgcmFuazogOTk5OVxuICAgIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdsb2JhbHMgPSB2b2lkIDA7XG5leHBvcnRzLmluaXRHbG9iYWxzID0gaW5pdEdsb2JhbHM7XG4vKipcbiAqIEdsb2JhbCByZWZlcmVuY2VzIHRvIGtleSBjb21wb25lbnRzIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmdsb2JhbHMgPSB7fTtcbi8qKlxuICogSW5pdGlhbGl6ZSBnbG9iYWwgcmVmZXJlbmNlc1xuICovXG5mdW5jdGlvbiBpbml0R2xvYmFscyhhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgIGV4cG9ydHMuZ2xvYmFscy5hcHAgPSBhcHA7XG4gICAgZXhwb3J0cy5nbG9iYWxzLm5vdGVib29rVHJhY2tlciA9IG5vdGVib29rVHJhY2tlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbnNpb25JY29uID0gdm9pZCAwO1xuY29uc3QgdWlfY29tcG9uZW50c18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL3VpLWNvbXBvbmVudHNcIik7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJY29uIERlZmluaXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IGljb25TdmdTdHIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwiYmkgYmktY2hhdC1sZWZ0LXRleHRcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+JyArXG4gICAgJzxwYXRoIGQ9XCJNMTQgMWExIDEgMCAwIDEgMSAxdjhhMSAxIDAgMCAxLTEgMUg0LjQxNEEyIDIgMCAwIDAgMyAxMS41ODZsLTIgMlYyYTEgMSAwIDAgMSAxLTFoMTJ6TTIgMGEyIDIgMCAwIDAtMiAydjEyLjc5M2EuNS41IDAgMCAwIC44NTQuMzUzbDIuODUzLTIuODUzQTEgMSAwIDAgMSA0LjQxNCAxMkgxNGEyIDIgMCAwIDAgMi0yVjJhMiAyIDAgMCAwLTItMkgyelwiLz4nICtcbiAgICAnPHBhdGggZD1cIk0zIDMuNWEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlhLjUuNSAwIDAgMS0uNS0uNXpNMyA2YS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOUEuNS41IDAgMCAxIDMgNnptMCAyLjVhLjUuNSAwIDAgMSAuNS0uNWg1YS41LjUgMCAwIDEgMCAxaC01YS41LjUgMCAwIDEtLjUtLjV6XCIvPicgK1xuICAgICc8L3N2Zz4nO1xuLyoqXG4gKiBJY29uIGZvciB0aGUgQUkgQXNzaXN0YW50IGV4dGVuc2lvblxuICovXG5leHBvcnRzLmV4dGVuc2lvbkljb24gPSBuZXcgdWlfY29tcG9uZW50c18xLkxhYkljb24oe1xuICAgIG5hbWU6ICdzaW1wbGU6aWNvbicsXG4gICAgc3Znc3RyOiBpY29uU3ZnU3RyXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcGlDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBsYXVuY2hlcl8xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2xhdW5jaGVyXCIpO1xuY29uc3QgYXBwdXRpbHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9hcHB1dGlsc1wiKTtcbmNvbnN0IG5vdGVib29rXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbm90ZWJvb2tcIik7XG5jb25zdCBkb2NtYW5hZ2VyXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvZG9jbWFuYWdlclwiKTtcbmNvbnN0IHNpZGViYXJfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9zaWRlYmFyLXdpZGdldFwiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIi4vY29tbWFuZHNcIik7XG5jb25zdCBjZWxsX2NvbnRleHRfdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vY2VsbC1jb250ZXh0LXRyYWNrZXJcIik7XG4vLyBpbXBvcnQgeyBBcGlDbGllbnQgfSBmcm9tICcuL2FwaS1jbGllbnQnO1xuLy8gSW1wb3J0IHRoZSBtYWluIENTUyBmaWxlXG5yZXF1aXJlKFwiLi4vc3R5bGUvaW5kZXguY3NzXCIpO1xuLy8gRXhwb3J0IEFwaUNsaWVudCBmb3IgdXNlIGJ5IG90aGVyIGNvbXBvbmVudHNcbnZhciBhcGlfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hcGktY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBpQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcGlfY2xpZW50XzEuQXBpQ2xpZW50OyB9IH0pO1xuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBkYXRhIGZvciB0aGUganVweXRlci1zaW1wbGUtZXh0ZW5zaW9uIGV4dGVuc2lvbi5cbiAqL1xuY29uc3QgcGx1Z2luID0ge1xuICAgIGlkOiAnanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uOnBsdWdpbicsXG4gICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbbGF1bmNoZXJfMS5JTGF1bmNoZXIsIGFwcHV0aWxzXzEuSUNvbW1hbmRQYWxldHRlLCBub3RlYm9va18xLklOb3RlYm9va1RyYWNrZXIsIGRvY21hbmFnZXJfMS5JRG9jdW1lbnRNYW5hZ2VyXSxcbiAgICBhY3RpdmF0ZTogKGp1cHl0ZXJBcHAsIGxhdW5jaGVyLCBwYWxldHRlLCB0cmFja2VyLCBkb2NNYW5hZ2VyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKdXB5dGVyTGFiIGV4dGVuc2lvbiBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gaXMgYWN0aXZhdGVkIScpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzXG4gICAgICAgICgwLCBnbG9iYWxzXzEuaW5pdEdsb2JhbHMpKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNlbGwgY29udGV4dCB0cmFja2VyXG4gICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlciA9IG5ldyBjZWxsX2NvbnRleHRfdHJhY2tlcl8xLkNlbGxDb250ZXh0VHJhY2tlcihqdXB5dGVyQXBwLCB0cmFja2VyKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgc2lkZWJhciB3aWRnZXRcbiAgICAgICAgY29uc3Qgc2lkZWJhcldpZGdldCA9IG5ldyBzaWRlYmFyX3dpZGdldF8xLlNpbXBsZVNpZGViYXJXaWRnZXQoZG9jTWFuYWdlcik7XG4gICAgICAgIGp1cHl0ZXJBcHAuc2hlbGwuYWRkKHNpZGViYXJXaWRnZXQsICdsZWZ0JywgeyByYW5rOiA5OTk5IH0pO1xuICAgICAgICAvLyBSZWdpc3RlciBjb21tYW5kc1xuICAgICAgICAoMCwgY29tbWFuZHNfMS5yZWdpc3RlckNvbW1hbmRzKShqdXB5dGVyQXBwLCBwYWxldHRlLCBsYXVuY2hlciwgc2lkZWJhcldpZGdldCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBsdWdpbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25maWd1cmVNYXJrZWQgPSBjb25maWd1cmVNYXJrZWQ7XG5leHBvcnRzLnByZXByb2Nlc3NNYXJrZG93biA9IHByZXByb2Nlc3NNYXJrZG93bjtcbmNvbnN0IG1hcmtlZF8xID0gcmVxdWlyZShcIm1hcmtlZFwiKTtcbi8qKlxuICogQ29uZmlndXJlIG1hcmtlZCB3aXRoIGJldHRlciByZW5kZXJpbmcgb3B0aW9ucyBmb3IgY29kZSBibG9ja3NcbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlTWFya2VkKCkge1xuICAgIC8vIENvbmZpZ3VyZSBtYXJrZWQgb3B0aW9uc1xuICAgIG1hcmtlZF8xLm1hcmtlZC5zZXRPcHRpb25zKHtcbiAgICAgICAgZ2ZtOiB0cnVlLCAvLyBFbmFibGUgR2l0SHViIEZsYXZvcmVkIE1hcmtkb3duXG4gICAgICAgIGJyZWFrczogdHJ1ZSwgLy8gQWRkIDxicj4gb24gc2luZ2xlIGxpbmUgYnJlYWtzXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSwgLy8gQ29uZm9ybSB0byBvcmlnaW5hbCBtYXJrZG93biBzcGVjXG4gICAgICAgIGFzeW5jOiBmYWxzZSwgLy8gRGlzYWJsZSBhc3luYyByZW5kZXJpbmdcbiAgICAgICAgc2lsZW50OiBmYWxzZSAvLyBFbmFibGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgfSk7XG59XG4vKipcbiAqIFByZS1wcm9jZXNzIG1hcmtkb3duIHRleHQgdG8gZml4IGNvbW1vbiBpc3N1ZXMgd2l0aCBzdHJlYW1pbmcgY29udGVudFxuICovXG5mdW5jdGlvbiBwcmVwcm9jZXNzTWFya2Rvd24odGV4dCkge1xuICAgIC8vIEhhbmRsZSBjb2RlIGJsb2NrcyBmaXJzdFxuICAgIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgcHJvY2Vzc2VkTGluZXMgPSBsaW5lcy5tYXAoKGxpbmUsIGkpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGUgYmxvY2sgbWFya2Vyc1xuICAgICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgnYGBgJykpIHtcbiAgICAgICAgICAgIGluQ29kZUJsb2NrID0gIWluQ29kZUJsb2NrO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgbGFuZ3VhZ2Ugc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGluIGEgY29kZSBibG9jaywgcHJlc2VydmUgdGhlIGxpbmUgYXMgaXNcbiAgICAgICAgaWYgKGluQ29kZUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXRzaWRlIGNvZGUgYmxvY2tzLCBoYW5kbGUgbGlzdCBpdGVtc1xuICAgICAgICByZXR1cm4gbGluZS5yZXBsYWNlKC8oW15cXG5cXHNdKS1cXHMvZywgJyQxXFxuLSAnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvY2Vzc2VkTGluZXMuam9pbignXFxuJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBpbnRlcmFjdGlvbnMgb2YgdGhlIG11bHRpLWxldmVsIHBvcHVwIG1lbnUuXG4gKi9cbmNsYXNzIFBvcHVwTWVudU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIsIHdpZGdldE5vZGUsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgdGhpcy5tZW51SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnROb3RlYm9vayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFRyYWNrIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51IGl0ZW1cbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0b3J5SXRlbXMgPSBudWxsOyAvLyBDYWNoZSBmb3IgZGlyZWN0b3J5IGl0ZW1zXG4gICAgICAgIHRoaXMuZG9jTWFuYWdlciA9IGRvY01hbmFnZXI7XG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZSA9IHdpZGdldE5vZGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIEF0dGFjaCB0byB0aGUgd2lkZ2V0IG5vZGUgaW5zdGVhZCBvZiB0aGUgYm9keVxuICAgICAgICB0aGlzLndpZGdldE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICAvLyBDcmVhdGUgc2VhcmNoIGlucHV0XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQucGxhY2Vob2xkZXIgPSAnU2VhcmNoLi4uJztcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LXNlYXJjaCc7IC8vIEFkZCBjbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4gdGhpcy51cGRhdGVNZW51SXRlbXNVSSgpKTsgLy8gQ2hhbmdlIGxpc3RlbmVyIHRvIGNhbGwgdGhlIHRhcmdldGVkIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc3RvcCBzcGVjaWZpYyBrZXlzIG5lZWRlZCB0byBwcmV2ZW50IG1lbnUgaW50ZXJhY3Rpb25cbiAgICAgICAgICAgIGlmIChbJ0Fycm93VXAnLCAnQXJyb3dEb3duJywgJ0VudGVyJywgJ0VzY2FwZScsICdUYWInXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcCBwcm9wYWdhdGlvbiBzbyB0aGUgbWFpbiBoYW5kbGVyIGRvZXNuJ3QgYWxzbyBhY3Qgb24gdGhlc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgKFNlYXJjaCBJbnB1dCBMaXN0ZW5lcik6IFN0b3BwaW5nIHByb3BhZ2F0aW9uIGZvciBrZXk6JywgZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGhhbmRsZSB0aGVzZSBrZXlzIGluIHRoZSBtYWluIGhhbmRsZXIgYmFzZWQgb24gdGFyZ2V0IGNoZWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGxvdyBkZWZhdWx0IGJlaGF2aW9yIChsaWtlIEJhY2tzcGFjZSkgYnkgKm5vdCogc3RvcHBpbmcgcHJvcGFnYXRpb24gZm9yIG90aGVyIGtleXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZGljYXRlZCBjb250YWluZXIgZm9yIHRoZSBtZW51IGl0ZW1zXG4gICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pdGVtc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW1zLWNvbnRhaW5lcic7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAvLyBBZGQga2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXIgZm9yIG5hdmlnYXRpb25cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgaWYgKGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5jb25uZWN0KChfLCBub3RlYm9vaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gd2lkZ2V0Tm9kZSBpZiBhdHRhY2hlZFxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgIXRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0QnV0dG9uID0gdGhpcy53aWRnZXROb2RlLnF1ZXJ5U2VsZWN0b3IoJyNqcC1sbG0tZXh0LWF0LWJ1dHRvbicpO1xuICAgICAgICAgICAgaWYgKGF0QnV0dG9uICYmIGF0QnV0dG9uLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IENsaWNrIHdhcyBvbiB0aGUgQCBidXR0b24sIG5vdCBoaWRpbmcuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBDbGljayBkZXRlY3RlZCBvdXRzaWRlIHRoZSBtZW51LicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hvd1BvcHVwTWVudSh4LCB5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogU2hvd2luZyBtZW51IGF0ICgke3h9LCAke3l9KWApO1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5ID0gW107XG4gICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlID0gJyc7IC8vIENsZWFyIHNlYXJjaCBvbiBzaG93XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3RvcnlJdGVtcyA9IG51bGw7IC8vIENsZWFyIGNhY2hlIG9uIHNob3dcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudERpcmVjdG9yeVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgIC8vIEVuc3VyZSBpdCdzIGF0dGFjaGVkIHRvIHRoZSB3aWRnZXQgbm9kZSBpZiBzb21laG93IGRldGFjaGVkXG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBwb3B1cCBtZW51IC0gcGxhY2UgaXQgYWJvdmUgdGhlIHRyaWdnZXIgcG9pbnRcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgICAgIC8vIFNob3cgdGhlIG1lbnUgZmlyc3Qgc28gd2UgY2FuIGNhbGN1bGF0ZSBpdHMgaGVpZ2h0XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCBoZWlnaHQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IG1lbnVIZWlnaHQgPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIEFkZCBhIHNtYWxsIGdhcCAoMTBweCkgYmV0d2VlbiB0aGUgYm90dG9tIG9mIHRoZSBtZW51IGFuZCB0aGUgdHJpZ2dlciBwb2ludFxuICAgICAgICBjb25zdCBnYXAgPSAxMDtcbiAgICAgICAgLy8gUG9zaXRpb24gYWJvdmUgdGhlIGN1cnNvci9idXR0b24gKHkgLSBtZW51SGVpZ2h0IC0gZ2FwKVxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHtNYXRoLm1heCgwLCB5IC0gbWVudUhlaWdodCAtIGdhcCl9cHhgO1xuICAgICAgICAvLyBGb2N1cyB0aGUgc2VhcmNoIGlucHV0IGlmIHdlIGFyZSBpbiBmaWxlL2RpcmVjdG9yeSB2aWV3LCBvdGhlcndpc2UgZm9jdXMgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpLCAwKTsgLy8gRm9jdXMgc2VhcmNoIGlucHV0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBEb24ndCBzZWxlY3QgYW4gaXRlbSBpZiBzZWFyY2ggaXMgZm9jdXNlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgYW5kIHNlbGVjdCB0aGUgZmlyc3QgbWVudSBpdGVtIGZvciB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGlkZVBvcHVwTWVudSgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBIaWRpbmcgbWVudS4nKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGV4cGxpY2l0bHkgcmVtb3ZlIGZyb20gd2lkZ2V0Tm9kZSB1bmxlc3MgY2F1c2luZyBpc3N1ZXNcbiAgICAgICAgICAgIC8vIElmIHBlcmZvcm1hbmNlIGJlY29tZXMgYW4gaXNzdWUgd2l0aCBtYW55IG1lbnVzLCBjb25zaWRlciByZW1vdmluZy9yZS1hZGRpbmdcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0aGlzLndpZGdldE5vZGUpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLndpZGdldE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlbmRlck1lbnVDb250ZW50KCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFJlbmRlcmluZyBmdWxsIG1lbnUgY29udGVudCBmb3IgbGV2ZWw6ICR7dGhpcy5jdXJyZW50TWVudUxldmVsfSwgcGF0aDogJHt0aGlzLmN1cnJlbnRNZW51UGF0aH1gKTtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuY3VycmVudERpcmVjdG9yeUl0ZW1zID0gbnVsbDsgLy8gQ2xlYXIgY2FjaGUgd2hlbiByZS1yZW5kZXJpbmcgc3RydWN0dXJlXG4gICAgICAgIGlmICh0aGlzLm1lbnVIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tCdXR0b24gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCfihpAgQmFjaycsICduYXZpZ2F0ZS1iYWNrJywgJycsICcnKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGJhY2tCdXR0b24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7XG4gICAgICAgICAgICAvLyBBZGQgc2VhcmNoIGlucHV0XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNlYXJjaElucHV0KTtcbiAgICAgICAgICAgIC8vIEFkZCBwYXRoIGluZGljYXRvclxuICAgICAgICAgICAgY29uc3QgcGF0aEluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcGF0aEluZGljYXRvci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LXBhdGgnO1xuICAgICAgICAgICAgcGF0aEluZGljYXRvci50ZXh0Q29udGVudCA9IGBQYXRoOiAke3RoaXMuY3VycmVudE1lbnVQYXRoIHx8ICcvJ31gO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQocGF0aEluZGljYXRvcik7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGNvbnRhaW5lciBmb3IgbGlzdCBpdGVtc1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5pdGVtc0NvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBGZXRjaCBpbml0aWFsIGl0ZW1zIGFuZCBwb3B1bGF0ZSB0aGUgaXRlbXMgY29udGFpbmVyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoQW5kUG9wdWxhdGVNZW51SXRlbXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRvcExldmVsSXRlbXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZS1hcHBseSBzZWxlY3Rpb24gaGlnaGxpZ2h0IGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgIH1cbiAgICByZW5kZXJUb3BMZXZlbEl0ZW1zKCkge1xuICAgICAgICB0aGlzLml0ZW1zQ29udGFpbmVyLmlubmVySFRNTCA9ICcnOyAvLyBFbnN1cmUgaXRlbXMgY29udGFpbmVyIGlzIGNsZWFyXG4gICAgICAgIGNvbnN0IHRvcExldmVsQ29tbWFuZHMgPSBbXG4gICAgICAgICAgICB7IGxhYmVsOiAnQ29kZScsIGRlc2NyaXB0aW9uOiAnSW5zZXJ0IHNlbGVjdGVkIGNvZGUgb3IgY3VycmVudCBjZWxsJywgYWN0aW9uSWQ6ICdpbnNlcnQtY29kZScgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdDZWxsJywgZGVzY3JpcHRpb246ICdJbnNlcnQgY3VycmVudCBjZWxsIGNvbnRlbnQnLCBhY3Rpb25JZDogJ2luc2VydC1jZWxsJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0ZpbGUnLCBkZXNjcmlwdGlvbjogJ0Jyb3dzZSBhbmQgaW5zZXJ0IGZpbGUgcGF0aCcsIGFjdGlvbklkOiAnYnJvd3NlLWZpbGVzJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0RpcmVjdG9yeScsIGRlc2NyaXB0aW9uOiAnQnJvd3NlIGFuZCBpbnNlcnQgZGlyZWN0b3J5IHBhdGgnLCBhY3Rpb25JZDogJ2Jyb3dzZS1kaXJlY3RvcmllcycgfVxuICAgICAgICBdO1xuICAgICAgICB0b3BMZXZlbENvbW1hbmRzLmZvckVhY2goY21kID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGNtZC5sYWJlbCwgY21kLmFjdGlvbklkLCAnJywgY21kLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogRmV0Y2hlcyBkaXJlY3RvcnkgY29udGVudHMgaWYgbmVlZGVkIGFuZCBwb3B1bGF0ZXMgdGhlIGl0ZW1zIGNvbnRhaW5lciAqL1xuICAgIGFzeW5jIGZldGNoQW5kUG9wdWxhdGVNZW51SXRlbXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogRmV0Y2hpbmcvUG9wdWxhdGluZyBpdGVtcy4gQ2FjaGVkOiAkeyEhdGhpcy5jdXJyZW50RGlyZWN0b3J5SXRlbXN9YCk7XG4gICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIuaW5uZXJIVE1MID0gJyc7IC8vIENsZWFyIHByZXZpb3VzIGl0ZW1zXG4gICAgICAgIGNvbnN0IGxvYWRpbmdJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTG9hZGluZy4uLicsICdsb2FkaW5nJywgJycsICcnKTtcbiAgICAgICAgbG9hZGluZ0l0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgdGhpcy5pdGVtc0NvbnRhaW5lci5hcHBlbmRDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGZXRjaCBpZiBjYWNoZSBpcyBlbXB0eVxuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnREaXJlY3RvcnlJdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZWQgdW51c2VkIGZpbHRlclR5cGUgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBhbGwgaW5pdGlhbGx5IGZvciBmaWx0ZXJpbmcsIG9yIGFwcGx5IHNlcnZlci1zaWRlIGZpbHRlciBpZiBBUEkgc3VwcG9ydHMgaXRcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3RvcnlJdGVtcyA9IGF3YWl0IHRoaXMubGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyh0aGlzLmN1cnJlbnRNZW51UGF0aCk7IC8vIEZldGNoIGFsbCBpbml0aWFsbHlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IEZldGNoZWQgJHsoX2IgPSAoX2EgPSB0aGlzLmN1cnJlbnREaXJlY3RvcnlJdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMH0gaXRlbXMgZm9yICR7dGhpcy5jdXJyZW50TWVudVBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zQ29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgVUkgYmFzZWQgb24gY3VycmVudCBjYWNoZSBhbmQgc2VhcmNoIHRlcm1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudUl0ZW1zVUkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zQ29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShgRXJyb3I6ICR7ZXJyb3J9YCwgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLml0ZW1zQ29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7IC8vIEFkZCBlcnJvciB0byBpdGVtcyBjb250YWluZXJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBFcnJvciBmZXRjaGluZyBkaXJlY3RvcnkgY29udGVudHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0b3J5SXRlbXMgPSBudWxsOyAvLyBDbGVhciBjYWNoZSBvbiBlcnJvclxuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHNlbGVjdGlvbiBhZnRlciBmZXRjaGluZy9yZS1wb3B1bGF0aW5nXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgfVxuICAgIC8qKiBVcGRhdGVzIG9ubHkgdGhlIGxpc3QgaXRlbXMgaW4gdGhlIGl0ZW1zQ29udGFpbmVyIGJhc2VkIG9uIHNlYXJjaCAqL1xuICAgIHVwZGF0ZU1lbnVJdGVtc1VJKCkge1xuICAgICAgICBjb25zdCBzZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBVcGRhdGluZyBVSSBmb3Igc2VhcmNoIHRlcm06IFwiJHtzZWFyY2hUZXJtfVwiYCk7XG4gICAgICAgIC8vIENsZWFyIG9ubHkgdGhlIGl0ZW1zIGNvbnRhaW5lclxuICAgICAgICB0aGlzLml0ZW1zQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudERpcmVjdG9yeUl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IE5vIGRpcmVjdG9yeSBpdGVtcyBjYWNoZWQsIGNhbm5vdCB1cGRhdGUgVUkuJyk7XG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IHNob3cgYSBtZXNzYWdlIG9yIHRyeSBmZXRjaGluZyBhZ2FpblxuICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShgTm8gaXRlbXMgbG9hZGVkYCwgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZXJyb3JJdGVtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50TGV2ZWxGaWx0ZXJUeXBlID0gdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSc7IC8vIFVzZSB0aGlzIGZvciBcIk5vIFggZm91bmRcIiBtZXNzYWdlXG4gICAgICAgIC8vIEZpbHRlciBjYWNoZWQgaXRlbXMgYmFzZWQgb24gc2VhcmNoIHRlcm0gZmlyc3RcbiAgICAgICAgY29uc3Qgc2VhcmNoRmlsdGVyZWRDb250ZW50cyA9IHRoaXMuY3VycmVudERpcmVjdG9yeUl0ZW1zLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpbHRlciBhZ2FpbiBiYXNlZCAqc3RyaWN0bHkqIG9uIHRoZSBsZXZlbCdzIHByaW1hcnkgdHlwZSArIGRpcmVjdG9yaWVzIGlmIGJyb3dzaW5nIGZpbGVzXG4gICAgICAgIGNvbnN0IGZpbmFsRmlsdGVyZWRDb250ZW50cyA9IHNlYXJjaEZpbHRlcmVkQ29udGVudHMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJykge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgZmlsZXMgdGhhdCBtYXRjaCBzZWFyY2gsIGFuZCBkaXJlY3RvcmllcyB0aGF0IG1hdGNoIHNlYXJjaFxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09ICdmaWxlJyB8fCBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vICdkaXJlY3RvcmllcydcbiAgICAgICAgICAgICAgICAvLyBLZWVwIG9ubHkgZGlyZWN0b3JpZXMgdGhhdCBtYXRjaCBzZWFyY2hcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSAnZGlyZWN0b3J5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaW5hbEZpbHRlcmVkQ29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmluYWxGaWx0ZXJlZENvbnRlbnRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVBhdGggPSBpdGVtLnBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5JyA/ICfwn5OBJyA6ICfwn5OEJztcbiAgICAgICAgICAgICAgICBsZXQgYWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2aWV3aW5nICdmaWxlcycsIGNsaWNraW5nIGRpciBuYXZpZ2F0ZXMuIElmIHZpZXdpbmcgJ2RpcnMnLCBjbGlja2luZyBkaXIgc2VsZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWQgPSB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgPyAnc2VsZWN0LWRpcmVjdG9yeS1uYXZpZ2F0ZScgOiAnc2VsZWN0LWRpcmVjdG9yeS1jYWxsYmFjayc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpdGVtVHlwZSA9PT0gJ2ZpbGUnXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbiBvbmx5IHNlbGVjdCBhIGZpbGUgaWYgd2UgYXJlIGluICdmaWxlcycgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWQgPSB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgPyAnc2VsZWN0LWZpbGUnIDogJ2ludmFsaWQtYWN0aW9uJzsgLy8gU2hvdWxkIG5vdCBoYXBwZW4gaWYgZmlsdGVyaW5nIGlzIGNvcnJlY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbklkICE9PSAnaW52YWxpZC1hY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShgJHtpY29ufSAke2l0ZW1OYW1lfWAsIGFjdGlvbklkLCBpdGVtUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIuYXBwZW5kQ2hpbGQobWVudUl0ZW0pOyAvLyBBcHBlbmQgdG8gaXRlbXMgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgY3VycmVudExldmVsRmlsdGVyVHlwZSBmb3IgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oc2VhcmNoVGVybSA/ICdObyBtYXRjaGVzIGZvdW5kJyA6IGBObyAke2N1cnJlbnRMZXZlbEZpbHRlclR5cGV9cyBmb3VuZGAsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTsgLy8gQXBwZW5kIHRvIGl0ZW1zIGNvbnRhaW5lclxuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHNlbGVjdGlvbiBoaWdobGlnaHQgYXMgaXRlbXMgY2hhbmdlZFxuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgIH1cbiAgICBjcmVhdGVNZW51SXRlbSh0ZXh0LCBhY3Rpb25JZCwgcGF0aCA9ICcnLCBkZXNjcmlwdGlvbiA9ICcnKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaXRlbS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0nO1xuICAgICAgICBpdGVtLmRhdGFzZXQuYWN0aW9uSWQgPSBhY3Rpb25JZDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGl0ZW0uZGF0YXNldC5wYXRoID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLm9uY2xpY2sgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTWVudUNsaWNrKGV2ZW50KTtcbiAgICAgICAgY29uc3QgbGFiZWxTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBsYWJlbFNwYW4udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGxhYmVsU3Bhbik7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgbGFiZWxTcGFuLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgICAgICAgICBjb25zdCBkZXNjU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGRlc2NTcGFuLnRleHRDb250ZW50ID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICBkZXNjU3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIGRlc2NTcGFuLnN0eWxlLmZvbnRTaXplID0gJzAuOGVtJztcbiAgICAgICAgICAgIGRlc2NTcGFuLnN0eWxlLmNvbG9yID0gJ3ZhcigtLWpwLXVpLWZvbnQtY29sb3IyKSc7XG4gICAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGRlc2NTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTWVudUNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGFjdGlvbklkID0gdGFyZ2V0LmRhdGFzZXQuYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0YXJnZXQuZGF0YXNldC5wYXRoIHx8ICcnO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IE1lbnUgaXRlbSBjbGlja2VkLiBBY3Rpb246ICR7YWN0aW9uSWR9LCBQYXRoOiAke3BhdGh9YCk7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ25hdmlnYXRlLWJhY2snOlxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVCYWNrTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0LWNvZGUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5jYWxsYmFja3MuZ2V0U2VsZWN0ZWRUZXh0ID8gdGhpcy5jYWxsYmFja3MuZ2V0U2VsZWN0ZWRUZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShzZWxlY3RlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZW50ID0gdGhpcy5jYWxsYmFja3MuZ2V0Q3VycmVudENlbGxDb250ZW50ID8gdGhpcy5jYWxsYmFja3MuZ2V0Q3VycmVudENlbGxDb250ZW50KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUoY2VsbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBwcm92aWRlIGZlZWRiYWNrP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBObyBjb2RlL2NlbGwgc2VsZWN0ZWQgdG8gaW5zZXJ0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0LWNlbGwnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSB0aGlzLmNhbGxiYWNrcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQgPyB0aGlzLmNhbGxiYWNrcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENlbGwoY2VsbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogTm8gY2VsbCBjb250ZW50IHRvIGluc2VydC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdicm93c2UtZmlsZXMnOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmF2aWdhdGVNZW51KCdmaWxlcycsIHRoaXMuY3VycmVudE1lbnVQYXRoIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBjbGVhciBzZWFyY2ggaGVyZSwgbmF2aWdhdGlvbiBoYW5kbGVzIGZvY3VzL3JlbmRlclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWRpcmVjdG9yaWVzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnZGlyZWN0b3JpZXMnLCB0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2xlYXIgc2VhcmNoIGhlcmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1maWxlJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycpIHsgLy8gRW5zdXJlIHdlIGFyZSBpbiB0aGUgcmlnaHQgbW9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRGaWxlUGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRmlsZSBzZWxlY3RlZCBidXQgcGF0aCBpcyBtaXNzaW5nIG9yIG5vdCBpbiBmaWxlIG1vZGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZWN0LWRpcmVjdG9yeS1uYXZpZ2F0ZSc6IC8vIE5hdmlnYXRlIGludG8gZGlyIHdoZW4gaW4gZmlsZSB2aWV3XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2ZpbGVzJywgcGF0aCk7IC8vIE5hdmlnYXRlIGRlZXBlciwgc3RpbGwgbG9va2luZyBmb3IgZmlsZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIG5hdmlnYXRpb24gYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJzogLy8gU2VsZWN0IGRpciB3aGVuIGluIGRpcmVjdG9yeSB2aWV3XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggJiYgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7IC8vIEVuc3VyZSB3ZSBhcmUgaW4gdGhlIHJpZ2h0IG1vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0RGlyZWN0b3J5UGF0aChwYXRoKTsgLy8gVXNlIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIGNhbGxiYWNrIGJ1dCBwYXRoIGlzIG1pc3Npbmcgb3Igbm90IGluIGRpcmVjdG9yeSBtb2RlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZW1wdHknOlxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Vua25vd24gb3IgaW52YWxpZCBtZW51IGFjdGlvbjonLCBhY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5oaWRlUG9wdXBNZW51KCk7IC8vIE1heWJlIGRvbid0IGhpZGUgb24gdW5rbm93biBhY3Rpb25cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gU3RvcCBwcm9wYWdhdGlvbiBhZnRlciBoYW5kbGluZyBjbGlja1xuICAgIH1cbiAgICBhc3luYyBuYXZpZ2F0ZU1lbnUobGV2ZWwsIHBhdGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIHRvIGxldmVsOiAke2xldmVsfSwgcGF0aDogJHtwYXRofWApO1xuICAgICAgICAvLyBPbmx5IHB1c2ggaGlzdG9yeSBpZiB3ZSBhcmUgYWN0dWFsbHkgbW92aW5nIHRvIGEgbmV3IHN0YXRlXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09IGxldmVsIHx8IHRoaXMuY3VycmVudE1lbnVQYXRoICE9PSBwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5LnB1c2goeyBsZXZlbDogdGhpcy5jdXJyZW50TWVudUxldmVsLCBwYXRoOiB0aGlzLmN1cnJlbnRNZW51UGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlID0gJyc7IC8vIENsZWFyIHNlYXJjaCBvbiBleHBsaWNpdCBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMuY3VycmVudERpcmVjdG9yeUl0ZW1zID0gbnVsbDsgLy8gQ2xlYXIgY2FjaGUgZm9yIG5ldyBkaXJlY3RvcnlcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBuZXcgdmlldyBzdHJ1Y3R1cmUgKHdpbGwgZmV0Y2ggaXRlbXMpXG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKTtcbiAgICAgICAgLy8gRm9jdXMgc2VhcmNoIGlucHV0IGFmdGVyIG5hdmlnYXRpbmcgdG8gZmlsZS9kaXIgdmlld1xuICAgICAgICBpZiAobGV2ZWwgPT09ICdmaWxlcycgfHwgbGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWxlY3Rpb24gaXMgaGFuZGxlZCBieSByZW5kZXJNZW51Q29udGVudC9mZXRjaEFuZFBvcHVsYXRlXG4gICAgfVxuICAgIG5hdmlnYXRlQmFja01lbnUoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLm1lbnVIaXN0b3J5LnBvcCgpO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIGJhY2sgdG8gbGV2ZWw6ICR7cHJldmlvdXNTdGF0ZS5sZXZlbH0sIHBhdGg6ICR7cHJldmlvdXNTdGF0ZS5wYXRofWApO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gcHJldmlvdXNTdGF0ZS5sZXZlbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gcHJldmlvdXNTdGF0ZS5wYXRoO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBDbGVhciBzZWFyY2ggb24gYmFjayBuYXZpZ2F0aW9uIHRvbz8gT3Iga2VlcCBpdD8gTGV0J3MgY2xlYXIuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3RvcnlJdGVtcyA9IG51bGw7IC8vIENsZWFyIGNhY2hlIHdoZW4gZ29pbmcgYmFja1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBpZiBnb2luZyBiYWNrIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgZmlyc3QgaXRlbSBpZiBnb2luZyBiYWNrIHRvIHRvcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBBbHJlYWR5IGF0IHRoZSB0b3AgbGV2ZWwuJyk7XG4gICAgICAgICAgICAvLyBEb24ndCBoaWRlIGhlcmUsIG1heWJlIHVzZXIgaGl0IGJhY2tzcGFjZSBhY2NpZGVudGFsbHlcbiAgICAgICAgICAgIC8vIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RDdXJyZW50RGlyZWN0b3J5Q29udGVudHMoYmFzZVBhdGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBMaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50cyBmb3IgcGF0aDogJyR7YmFzZVBhdGh9J2ApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZWZmZWN0aXZlUGF0aCA9IGJhc2VQYXRoID09PSAnLycgPyAnJyA6IGJhc2VQYXRoO1xuICAgICAgICAgICAgY29uc3QgcGF0aEZvckFwaSA9IGVmZmVjdGl2ZVBhdGguZW5kc1dpdGgoJy8nKSAmJiBlZmZlY3RpdmVQYXRoLmxlbmd0aCA+IDEgPyBlZmZlY3RpdmVQYXRoLnNsaWNlKDAsIC0xKSA6IGVmZmVjdGl2ZVBhdGg7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHRoaXMuZG9jTWFuYWdlci5zZXJ2aWNlcy5jb250ZW50cy5nZXQocGF0aEZvckFwaSB8fCAnJyk7XG4gICAgICAgICAgICBpZiAoY29udGVudHMudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBjb250ZW50cy5jb250ZW50Lm1hcCgoaXRlbSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSA9PT0gJ2RpcmVjdG9yeScgPyAnZGlyZWN0b3J5JyA6ICdmaWxlJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnZmlsZScgfHwgaXRlbS50eXBlID09PSAnZGlyZWN0b3J5Jyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBSYXcgZGlyZWN0b3J5IGl0ZW1zIGZvciAnJHtiYXNlUGF0aH0nOmAsIGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEudHlwZSA9PT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlICE9PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEudHlwZSAhPT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlID09PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BhdGggaXMgbm90IGEgZGlyZWN0b3J5OicsIGJhc2VQYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIG51bGwgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQT1BVUDogRXJyb3IgbGlzdGluZyBkaXJlY3RvcnkgY29udGVudHMgZm9yICcke2Jhc2VQYXRofSc6YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgb24gZXJyb3JcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGlyUGF0aCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcDtcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBBcHBsaWNhdGlvbiByZWZlcmVuY2Ugbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2hlbGxXaWRnZXQgPSBhcHAuc2hlbGwuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRTaGVsbFdpZGdldCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGV4dCA9IHRoaXMuZG9jTWFuYWdlci5jb250ZXh0Rm9yV2lkZ2V0KGN1cnJlbnRTaGVsbFdpZGdldCk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aWRnZXRDb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgZGlyUGF0aCA9IHRoaXMuZ2V0UGFyZW50RGlyZWN0b3J5KHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGN1cnJlbnQgd2lkZ2V0IGNvbnRleHQ6ICR7cGF0aH0gLT4gJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsICYmIHRoaXMuY3VycmVudE5vdGVib29rICYmIHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rUGF0aCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90ZWJvb2tQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSB0aGlzLmdldFBhcmVudERpcmVjdG9yeShub3RlYm9va1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGFjdGl2ZSBub3RlYm9vazogJHtub3RlYm9va1BhdGh9IC0+ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0V2lkZ2V0cyA9IEFycmF5LmZyb20oYXBwLnNoZWxsLndpZGdldHMoJ2xlZnQnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUJyb3dzZXJXaWRnZXQgPSBsZWZ0V2lkZ2V0cy5maW5kKHdpZGdldCA9PiB3aWRnZXQuaWQgPT09ICdmaWxlYnJvd3NlcicpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlQnJvd3NlcldpZGdldCAmJiAoKF9hID0gZmlsZUJyb3dzZXJXaWRnZXQubW9kZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJQYXRoID0gZmlsZUJyb3dzZXJXaWRnZXQubW9kZWwucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBQYXRoIGZyb20gZmlsZSBicm93c2VyIHdpZGdldCBtb2RlbDogJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGaWxlIGJyb3dzZXIgd2lkZ2V0IHBhdGggbm90IGRpcmVjdGx5IGFjY2Vzc2libGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BPUFVQOiBDb3VsZCBub3QgZ2V0IHBhdGggZnJvbSBmaWxlIGJyb3dzZXIuJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpclBhdGggPSAnJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRmFsbGluZyBiYWNrIHRvIHNlcnZlciByb290IHBhdGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBkaXJQYXRoO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IEluaXRpYWwgY3VycmVudCBtZW51IHBhdGggc2V0IHRvOiAnJHt0aGlzLmN1cnJlbnRNZW51UGF0aH0nYCk7XG4gICAgfVxuICAgIGdldFBhcmVudERpcmVjdG9yeShwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gTWF0aC5tYXgocGF0aC5sYXN0SW5kZXhPZignLycpLCBwYXRoLmxhc3RJbmRleE9mKCdcXFxcXFxcXCcpKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vIE5vIGRpcmVjdG9yeSBwYXJ0LCBsaWtlbHkgcm9vdCBvciBqdXN0IGEgZmlsZW5hbWVcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXlib2FyZCBuYXZpZ2F0aW9uIHdoZW4gdGhlIHBvcHVwIG1lbnUgaXMgc2hvd25cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gTWVudSBub3QgdmlzaWJsZVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLSBDaGVjayBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIHRoZSBzZWFyY2ggaW5wdXQgRklSU1QgLS0tXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuc2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBLZXlEb3duIChUYXJnZXQgU2VhcmNoKTogS2V5PScke2V2ZW50LmtleX0nYCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBFc2MgYmVoYXZpb3IgKGxpa2UgY2xlYXJpbmcgaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgcHJvcGFnYXRpb24gaGFuZGxlZCBieSBpbnB1dCdzIGxpc3RlbmVyLCBidXQgZG8gaXQgYWdhaW4ganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgc2VsZWN0IGZpcnN0IGl0ZW0/XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtc0ZvckVudGVyID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtc0ZvckVudGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gMDsgLy8gU2VsZWN0IGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW1zRm9yRW50ZXJbMF0uY2xpY2soKTsgLy8gQWN0aXZhdGUgZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgY3Vyc29yIG1vdmUgaW4gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYmx1cigpOyAvLyBNb3ZlIGZvY3VzIGF3YXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCk7IC8vIFNlbGVjdCBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzTWVudUl0ZW0oKTsgLy8gU2VsZWN0IGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGRlZmF1bHQgdGFiIGJlaGF2aW9yICpvciogaW1wbGVtZW50IGN1c3RvbSBjeWNsZVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgdGFiXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUYWIgbW92ZXMgZm9jdXMgdG8gdGhlIGZpcnN0IG1lbnUgaXRlbVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKTsgLy8gU2VsZWN0cyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IGZvY3VzIHRoZSBpdGVtIHZpc3VhbGx5OlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmdldE1lbnVJdGVtcygpW3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4XT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgQmFja3NwYWNlLCBsZXR0ZXJzLCBldGMuIC0gRE8gTk9USElORyBIRVJFXG4gICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgYnJvd3NlciBoYW5kbGUgdGhlIGlucHV0IGZpZWxkIGVkaXRpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSAnaW5wdXQnIGV2ZW50IGxpc3RlbmVyIHdpbGwgaGFuZGxlIHJlLWZpbHRlcmluZyB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIEtleURvd24gKFRhcmdldCBTZWFyY2gpOiBBbGxvd2luZyBkZWZhdWx0IGZvciBrZXkgJyR7ZXZlbnQua2V5fSdgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3J1Y2lhbGx5LCBETyBOT1Qgc3RvcFByb3BhZ2F0aW9uIG9yIHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlZCBvciBhbGxvd2VkIGRlZmF1bHQsIHJldHVybiBmcm9tIG1haW4gaGFuZGxlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLSBJZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIE5PVCB0aGUgc2VhcmNoIGlucHV0IC0tLVxuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgS2V5RG93biAoVGFyZ2V0IE1lbnUpOiBLZXk9JyR7ZXZlbnQua2V5fSdgKTtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzogLy8gQ29uc29saWRhdGUgYXJyb3cgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91c01lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW51SGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBvbmx5IGlmIG5hdmlnYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVCYWNrTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdG9wIGxldmVsLCBETyBOT1RISU5HIC0gYWxsb3cgYmFja3NwYWNlIHRvIHBvdGVudGlhbGx5IGFmZmVjdCBjaGF0IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChUYXJnZXQgTWVudSk6IEFsbG93aW5nIEJhY2tzcGFjZSBhdCB0b3AgbGV2ZWwuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA+PSAwICYmIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IDwgbWVudUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIEtleURvd24gKFRhcmdldCBNZW51KTogQ2xpY2tpbmcgaXRlbSAke3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXNbdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXhdLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgdGFiXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW4gZmlsZS9kaXIgdmlldywgVGFiIGZyb20gbWVudSBtb3ZlcyB0byBzZWFyY2ggaW5wdXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0QWxsTWVudUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZyb20gdG9wLWxldmVsIG1lbnUsIG1heWJlIGNsb3NlPyBPciBjeWNsZT8gTGV0J3MgY2xvc2UuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWYgdHlwaW5nIGEgY2hhcmFjdGVyIGFuZCBpbiBmaWxlL2RpciB2aWV3LCBmb2N1cyBzZWFyY2hcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmtleS5sZW5ndGggPT09IDEgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgY2hhcmFjdGVyIGFuZCB0cmlnZ2VyIGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgKz0gZXZlbnQua2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodDogSGlnaGxpZ2h0aW5nIGluZGV4ICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9IGFtb25nICR7bWVudUl0ZW1zLmxlbmd0aH0gaXRlbXMuYCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0OiBBZGRlZCAnc2VsZWN0ZWQnIHRvIGl0ZW0gJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGl0ZW0gaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICduZWFyZXN0JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0OiBSZW1vdmVkICdzZWxlY3RlZCcgZnJvbSBpdGVtICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzZWxlY3RBbGxNZW51SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICB9XG4gICAgc2VsZWN0TmV4dE1lbnVJdGVtKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBpZiAoIW1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBzZWxlY3ROZXh0OiBObyBpdGVtcyB0byBzZWxlY3QuJyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBFbnN1cmUgaW5kZXggaXMgcmVzZXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4O1xuICAgICAgICAvLyBEZXNlbGVjdCBjdXJyZW50IGZpcnN0IGlzIGhhbmRsZWQgYnkgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0XG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgaXRlbSBvciBsb29wIGJhY2sgdG8gdGhlIGZpcnN0XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ICsgMSkgJSBtZW51SXRlbXMubGVuZ3RoO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgc2VsZWN0TmV4dDogSW5kZXggY2hhbmdlZCBmcm9tICR7b2xkSW5kZXh9IHRvICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgfVxuICAgIHNlbGVjdFByZXZpb3VzTWVudUl0ZW0oKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIGlmICghbWVudUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIHNlbGVjdFByZXZpb3VzOiBObyBpdGVtcyB0byBzZWxlY3QuJyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBFbnN1cmUgaW5kZXggaXMgcmVzZXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4O1xuICAgICAgICAvLyBEZXNlbGVjdCBjdXJyZW50IGZpcnN0IGlzIGhhbmRsZWQgYnkgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0XG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIHByZXZpb3VzIGl0ZW0gb3IgbG9vcCB0byB0aGUgbGFzdFxuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IDw9IDAgP1xuICAgICAgICAgICAgbWVudUl0ZW1zLmxlbmd0aCAtIDEgOiB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCAtIDE7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBzZWxlY3RQcmV2aW91czogSW5kZXggY2hhbmdlZCBmcm9tICR7b2xkSW5kZXh9IHRvICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgaW50ZXJhY3RpdmUgbWVudSBpdGVtcyBmcm9tIHRoZSBpdGVtcyBjb250YWluZXJcbiAgICAgKi9cbiAgICBnZXRNZW51SXRlbXMoKSB7XG4gICAgICAgIC8vIFF1ZXJ5IG9ubHkgd2l0aGluIHRoZSBzcGVjaWZpYyBpdGVtcyBjb250YWluZXJcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHRoaXMuaXRlbXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmpwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJykpO1xuICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uSWQgPSBpdGVtLmRhdGFzZXQuYWN0aW9uSWQ7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IG5vbi1pbnRlcmFjdGl2ZSBpdGVtc1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbklkICYmIGFjdGlvbklkICE9PSAnbG9hZGluZycgJiYgYWN0aW9uSWQgIT09ICdlbXB0eScgJiYgYWN0aW9uSWQgIT09ICdlcnJvcic7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IFBvcHVwTWVudU1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlU2lkZWJhcldpZGdldCA9IHZvaWQgMDtcbmNvbnN0IHdpZGdldHNfMSA9IHJlcXVpcmUoXCJAbHVtaW5vL3dpZGdldHNcIik7XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG5jb25zdCBkb21wdXJpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tcHVyaWZ5XCIpKTtcbmNvbnN0IGljb25zXzEgPSByZXF1aXJlKFwiLi9pY29uc1wiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5jb25zdCBhcGlfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hcGktY2xpZW50XCIpO1xuY29uc3QgbWFya2Rvd25fY29uZmlnXzEgPSByZXF1aXJlKFwiLi9tYXJrZG93bi1jb25maWdcIik7XG5jb25zdCBwb3B1cF9tZW51X21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3BvcHVwLW1lbnUtbWFuYWdlclwiKTtcbi8vIENvbmZpZ3VyZSBtYXJrZWQgd2l0aCBvdXIgc2V0dGluZ3NcbigwLCBtYXJrZG93bl9jb25maWdfMS5jb25maWd1cmVNYXJrZWQpKCk7XG4vKipcbiAqIE1haW4gc2lkZWJhciB3aWRnZXQgZm9yIHRoZSBBSSBjaGF0IGludGVyZmFjZVxuICovXG5jbGFzcyBTaW1wbGVTaWRlYmFyV2lkZ2V0IGV4dGVuZHMgd2lkZ2V0c18xLldpZGdldCB7XG4gICAgY29uc3RydWN0b3IoZG9jTWFuYWdlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzTWFya2Rvd25Nb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhdElkID0gJyc7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBrZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBAIGtleSAoZm9yIGNvbnRleHQgbWVudSkgLSBjaGFuZ2VkIGZyb20gQ3RybCtAXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBzaG93IG1lbnUgaWYgaW5wdXQgZmllbGQgaXMgZm9jdXNlZFxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmlucHV0RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnNvciBwb3NpdGlvbiBpbiBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuaW5wdXRGaWVsZC5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlLnN1YnN0cmluZygwLCBjdXJzb3JQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiB0byBzaG93IG1lbnVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRSZWN0ID0gdGhpcy5pbnB1dEZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5pbnB1dEZpZWxkKS5saW5lSGVpZ2h0KSB8fCAyMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgbmV3bGluZXMgYmVmb3JlIGN1cnNvciB0byBkZXRlcm1pbmUgdmVydGljYWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXNCZWZvcmVDdXJzb3IgPSAodGV4dEJlZm9yZUN1cnNvci5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjdXJzb3IgcG9zaXRpb24gd2l0aGluIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TmV3bGluZSA9IHRleHRCZWZvcmVDdXJzb3IubGFzdEluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyc0luQ3VycmVudExpbmUgPSBsYXN0TmV3bGluZSA9PT0gLTEgPyBjdXJzb3JQb3NpdGlvbiA6IGN1cnNvclBvc2l0aW9uIC0gbGFzdE5ld2xpbmUgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBob3Jpem9udGFsIHBvc2l0aW9uICh1c2luZyBhdmVyYWdlIGNoYXJhY3RlciB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcldpZHRoID0gODsgLy8gQXBwcm94aW1hdGUgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXQgPSBjaGFyc0luQ3VycmVudExpbmUgKiBjaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlucHV0UmVjdC5sZWZ0ICsgaG9yaXpvbnRhbE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjdXJzb3IncyB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3JUb3AgPSBpbnB1dFJlY3QudG9wICsgKGxpbmVzQmVmb3JlQ3Vyc29yICogbGluZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTaG93aW5nIHBvcHVwIGF0IGN1cnNvciBwb3NpdGlvbjogKCR7bGVmdH0sICR7Y3Vyc29yVG9wfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IEAgc3ltYm9sIGF0IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZS5zdWJzdHJpbmcoMCwgY3Vyc29yUG9zaXRpb24pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdAJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUuc3Vic3RyaW5nKGN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIHRoZSBAIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc2VsZWN0aW9uU3RhcnQgPSBjdXJzb3JQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZWxlY3Rpb25FbmQgPSBjdXJzb3JQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHBvcHVwIG1lbnUgYWJvdmUgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuc2hvd1BvcHVwTWVudShsZWZ0ICsgNjAsIGN1cnNvclRvcCAtIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignQ29udGV4dCBtZW51IG9wZW5lZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBDdHJsK0wgKGZvciBzZWxlY3RlZCBjb2RlKVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24ubWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHNlbGVjdGlvbiwgdXNlIEBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gc2VsZWN0aW9uLm1haW4uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gc2VsZWN0aW9uLm1haW4udG87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY29kZSAke3NlbGVjdGVkVGV4dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IoJ1NlbGVjdGVkIGNvZGUgaW5zZXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHNlbGVjdGlvbiwgdXNlIEBjZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29udGV4dCA9IChfYiA9IGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldEN1cnJlbnRDZWxsQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY2VsbCAke2NlbGxDb250ZXh0LnRleHR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignQ2VsbCBjb250ZW50IGluc2VydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWRlYmFyIGlzIHZpc2libGUgYW5kIGZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcga2V5Ym9hcmQgc2hvcnRjdXQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICAgICAgdGhpcy5pZCA9ICdzaW1wbGUtc2lkZWJhcic7XG4gICAgICAgIHRoaXMudGl0bGUubGFiZWwgPSAnJztcbiAgICAgICAgdGhpcy50aXRsZS5jYXB0aW9uID0gJ0FJIENoYXQgSW50ZXJmYWNlJztcbiAgICAgICAgdGhpcy50aXRsZS5pY29uID0gaWNvbnNfMS5leHRlbnNpb25JY29uO1xuICAgICAgICB0aGlzLnRpdGxlLmNsb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gQWRkIHRoZSBtYWluIENTUyBjbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1sbG0tZXh0LXNpZGViYXInKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBBUEkgY2xpZW50XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IGFwaV9jbGllbnRfMS5BcGlDbGllbnQoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjb250YWluZXIgZWxlbWVudHMgYmVmb3JlIGNyZWF0aW5nIGxheW91dFxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGhpcy50aXRsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQta2V5Ym9hcmQtc2hvcnRjdXQtaW5kaWNhdG9yJztcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcik7XG4gICAgICAgIC8vIENyZWF0ZSBzZXR0aW5ncyBtb2RhbFxuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIgPSB0aGlzLmNyZWF0ZVNldHRpbmdzTW9kYWwoKTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lcik7XG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBQb3B1cE1lbnVNYW5hZ2VyIHdpdGggY2FsbGJhY2tzXG4gICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlciA9IG5ldyBwb3B1cF9tZW51X21hbmFnZXJfMS5Qb3B1cE1lbnVNYW5hZ2VyKHRoaXMuZG9jTWFuYWdlciwgdGhpcy5ub2RlLCB7XG4gICAgICAgICAgICBpbnNlcnRDb2RlOiAoY29kZSkgPT4gdGhpcy5hcHBlbmRUb0lucHV0KGBjb2RlICR7Y29kZX1gKSxcbiAgICAgICAgICAgIGluc2VydENlbGw6IChjb250ZW50KSA9PiB0aGlzLmFwcGVuZFRvSW5wdXQoYGNlbGwgJHtjb250ZW50fWApLFxuICAgICAgICAgICAgaW5zZXJ0RmlsZVBhdGg6IChwYXRoKSA9PiB0aGlzLmFwcGVuZFRvSW5wdXQoYGZpbGUgJHtwYXRofWApLFxuICAgICAgICAgICAgaW5zZXJ0RGlyZWN0b3J5UGF0aDogKHBhdGgpID0+IHRoaXMuYXBwZW5kVG9JbnB1dChgZGlyZWN0b3J5ICR7cGF0aH1gKSwgLy8gSWYgbmVlZGVkXG4gICAgICAgICAgICBnZXRTZWxlY3RlZFRleHQ6ICgpID0+IHRoaXMuZ2V0U2VsZWN0ZWRUZXh0KCksXG4gICAgICAgICAgICBnZXRDdXJyZW50Q2VsbENvbnRlbnQ6ICgpID0+IHRoaXMuZ2V0Q3VycmVudENlbGxDb250ZW50KCksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2hhdCBvbiBzdGFydFxuICAgICAgICB0aGlzLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGF5b3V0KCkpO1xuICAgICAgICAvLyBQb3AtdXAgbWVudSB3aWxsIGJlIGF0dGFjaGVkIHRvIGRvY3VtZW50LmJvZHkgd2hlbiBzaG93blxuICAgICAgICAvLyBBZGQga2V5Ym9hcmQgc2hvcnRjdXQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgdmlzdWFsIGluZGljYXRvciBmb3Iga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IodGV4dCkge1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyBIaWRlIGFmdGVyIDEgc2Vjb25kXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyBSZW1vdmUga2V5Ym9hcmQgc2hvcnRjdXQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIC8vIFJlbW92ZSBrZXlib2FyZCBzaG9ydGN1dCBpbmRpY2F0b3JcbiAgICAgICAgaWYgKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2UgdGhlIHBvcHVwIG1lbnUgbWFuYWdlclxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVNYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbWFpbiBsYXlvdXQgZm9yIHRoZSBzaWRlYmFyXG4gICAgICovXG4gICAgY3JlYXRlTGF5b3V0KCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIG1haW4gY29udGFpbmVyXG4gICAgICAgIGNvbnN0IG1haW5Db250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIFRoZSBtYWluIGNsYXNzICdqcC1sbG0tZXh0LXNpZGViYXInIGlzIGFkZGVkIHRvIHRoaXMubm9kZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgLy8gVGhpcyBjb250YWluZXIgY2FuIGhhdmUgaXRzIG93biBjbGFzcyBpZiBuZWVkZWQgZm9yIGZ1cnRoZXIgbmVzdGluZy9zdHlsaW5nXG4gICAgICAgIG1haW5Db250ZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbnRlbnQtd3JhcHBlcic7XG4gICAgICAgIC8vIENyZWF0ZSB0aXRsZSBpbnB1dCBjb250YWluZXJcbiAgICAgICAgY29uc3QgdGl0bGVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdGl0bGUtY29udGFpbmVyJztcbiAgICAgICAgLy8gU2V0IHVwIHRpdGxlIGlucHV0XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5jbGFzc05hbWUgPSAnY2hhdC10aXRsZS1pbnB1dCc7IC8vIEFzc3VtaW5nIHRoaXMgaXMgc3R5bGVkIGNvcnJlY3RseSBpbiBDU1NcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5wbGFjZWhvbGRlciA9ICdDaGF0IHRpdGxlJztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnZhbHVlID0gJ05ldyBDaGF0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHRoaXMudXBkYXRlQ3VycmVudENoYXRUaXRsZSgpKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZUlucHV0KTtcbiAgICAgICAgLy8gQ3JlYXRlIE5ldyBDaGF0ICYgSGlzdG9yeSBidXR0b25zXG4gICAgICAgIGNvbnN0IG5ld0NoYXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIG5ld0NoYXRCdXR0b24udGV4dENvbnRlbnQgPSAnKyBOZXcgQ2hhdCc7XG4gICAgICAgIG5ld0NoYXRCdXR0b24udGl0bGUgPSAnU3RhcnQgYSBuZXcgY2hhdCc7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmNyZWF0ZU5ld0NoYXQoKSk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGhpc3RvcnlCdXR0b24udGV4dENvbnRlbnQgPSAnSGlzdG9yeSc7XG4gICAgICAgIGhpc3RvcnlCdXR0b24udGl0bGUgPSAnVmlldyBjaGF0IGhpc3RvcnknO1xuICAgICAgICBoaXN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy50b2dnbGVIaXN0b3J5VmlldygpKTtcbiAgICAgICAgLy8gQ29uZmlndXJlIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1jb250YWluZXInO1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gQ29uZmlndXJlIGlucHV0IGZpZWxkIChkaXJlY3RseSB1c2VkIGxhdGVyKVxuICAgICAgICB0aGlzLmlucHV0RmllbGQucGxhY2Vob2xkZXIgPSAnQXNrIG1lIGFueXRoaW5nLi4uJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJvd3MgPSAxO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtZmllbGQnOyAvLyBBZGQgY2xhc3MgZm9yIHN0eWxpbmdcbiAgICAgICAgLy8gQWRkIGtleXByZXNzIGxpc3RlbmVyIHRvIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBzZW5kIGJ1dHRvbiBjb250YWluZXIgKGRpcmVjdGx5IHVzZWQgbGF0ZXIpXG4gICAgICAgIGNvbnN0IGlucHV0QWN0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpbnB1dEFjdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtYWN0aW9ucy1jb250YWluZXInO1xuICAgICAgICAvLyBDcmVhdGUgc2VuZCBidXR0b25cbiAgICAgICAgY29uc3Qgc2VuZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBzZW5kQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1zZW5kLWJ1dHRvbic7XG4gICAgICAgIHNlbmRCdXR0b24udGV4dENvbnRlbnQgPSAnU2VuZCc7XG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKCkpO1xuICAgICAgICBpbnB1dEFjdGlvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VuZEJ1dHRvbik7XG4gICAgICAgIC8vIENyZWF0ZSBjb250cm9scyBjb250YWluZXIgKE1hcmtkb3duIHRvZ2dsZSwgQCwgZXRjLikgKGRpcmVjdGx5IHVzZWQgbGF0ZXIpXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBib3R0b20gYmFyIGNvbnRhaW5lciB3aXRoIHRocmVlIHJvd3NcbiAgICAgICAgY29uc3QgYm90dG9tQmFyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMuYm90dG9tQmFyQ29udGFpbmVyID0gYm90dG9tQmFyQ29udGFpbmVyO1xuICAgICAgICAvLyBGaXJzdCByb3c6IENvbnRyb2xzIChNYXJrZG93biB0b2dnbGUgYW5kIGFjdGlvbiBidXR0b25zKVxuICAgICAgICBjb25zdCB0b3BSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9wUm93LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtY29udHJvbHMtcm93JztcbiAgICAgICAgdG9wUm93LmFwcGVuZENoaWxkKGNvbnRyb2xzQ29udGFpbmVyKTtcbiAgICAgICAgLy8gU2Vjb25kIHJvdzogSW5wdXQgZmllbGRcbiAgICAgICAgY29uc3QgbWlkZGxlUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1pZGRsZVJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWlucHV0LXJvdyc7XG4gICAgICAgIG1pZGRsZVJvdy5hcHBlbmRDaGlsZCh0aGlzLmlucHV0RmllbGQpO1xuICAgICAgICAvLyBUaGlyZCByb3c6IEFjdGlvbiBidXR0b25zIChTZW5kLCBOZXcgQ2hhdCwgSGlzdG9yeSlcbiAgICAgICAgY29uc3QgYm90dG9tUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJvdHRvbVJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWJ1dHRvbnMtcm93JztcbiAgICAgICAgLy8gQWRkIGFsbCBidXR0b25zIHRvIGJvdHRvbSByb3dcbiAgICAgICAgYm90dG9tUm93LmFwcGVuZENoaWxkKHNlbmRCdXR0b24pO1xuICAgICAgICBib3R0b21Sb3cuYXBwZW5kQ2hpbGQobmV3Q2hhdEJ1dHRvbik7XG4gICAgICAgIGJvdHRvbVJvdy5hcHBlbmRDaGlsZChoaXN0b3J5QnV0dG9uKTtcbiAgICAgICAgLy8gQWRkIGFsbCByb3dzIHRvIHRoZSBib3R0b20gYmFyIGNvbnRhaW5lclxuICAgICAgICBib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQodG9wUm93KTtcbiAgICAgICAgYm90dG9tQmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKG1pZGRsZVJvdyk7XG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChib3R0b21Sb3cpO1xuICAgICAgICAvLyBBc3NlbWJsZSBhbGwgbWFpbiBjb21wb25lbnRzXG4gICAgICAgIG1haW5Db250ZW50LmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5tZXNzYWdlQ29udGFpbmVyKTtcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5oaXN0b3J5Q29udGFpbmVyKTtcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQoYm90dG9tQmFyQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG1haW5Db250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvblxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQoKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgY2hhdFxuICAgICAgICBjb25zdCBjaGF0SWQgPSBgY2hhdC0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgaXRlbVxuICAgICAgICBjb25zdCBuZXdDaGF0ID0ge1xuICAgICAgICAgICAgaWQ6IGNoYXRJZCxcbiAgICAgICAgICAgIHRpdGxlOiAnTmV3IENoYXQnLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgLy8gU2V0IGFzIGN1cnJlbnQgY2hhdFxuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aXRsZSBpbnB1dFxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBuZXdDaGF0LnRpdGxlO1xuICAgICAgICAvLyBDbGVhciBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlkZSBoaXN0b3J5IGlmIGl0J3MgdmlzaWJsZVxuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBiZXR3ZWVuIGNoYXQgdmlldyBhbmQgaGlzdG9yeSB2aWV3XG4gICAgICovXG4gICAgdG9nZ2xlSGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9ICF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmU7XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFNob3cgaGlzdG9yeSB2aWV3LCBoaWRlIG1lc3NhZ2UgdmlldyBhbmQgYm90dG9tIGJhclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBVc2UgY2xhc3MgcHJvcGVydHkgZGlyZWN0bHlcbiAgICAgICAgICAgIHRoaXMudGl0bGVJbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgaGlzdG9yeVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGF0SGlzdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdyBtZXNzYWdlIHZpZXcgYW5kIGJvdHRvbSBiYXIsIGhpZGUgaGlzdG9yeSB2aWV3XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIFVzZSBjbGFzcyBwcm9wZXJ0eSBkaXJlY3RseVxuICAgICAgICAgICAgdGhpcy50aXRsZUlucHV0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNoYXQgaGlzdG9yeSBpbiB0aGUgaGlzdG9yeSBjb250YWluZXJcbiAgICAgKi9cbiAgICByZW5kZXJDaGF0SGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5jaGF0SGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZW1wdHlNZXNzYWdlLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWVtcHR5LWhpc3RvcnktbWVzc2FnZSc7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UudGV4dENvbnRlbnQgPSAnTm8gY2hhdCBoaXN0b3J5IHlldCc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGNoYXQgaGlzdG9yeSBpdGVtc1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5LmZvckVhY2goY2hhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtJztcbiAgICAgICAgICAgIGlmIChjaGF0LmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5SXRlbS5jbGFzc0xpc3QuYWRkKCdqcC1sbG0tZXh0LWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRpdGxlXG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGl0bGUuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS10aXRsZSc7XG4gICAgICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IGNoYXQudGl0bGU7XG4gICAgICAgICAgICAvLyBBZGQgbWVzc2FnZSBwcmV2aWV3XG4gICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktcHJldmlldyc7XG4gICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IGNoYXQubWVzc2FnZXNbY2hhdC5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHByZXZpZXcudGV4dENvbnRlbnQgPSBsYXN0TWVzc2FnZVxuICAgICAgICAgICAgICAgID8gYCR7bGFzdE1lc3NhZ2UudGV4dC5zdWJzdHJpbmcoMCwgNDApfSR7bGFzdE1lc3NhZ2UudGV4dC5sZW5ndGggPiA0MCA/ICcuLi4nIDogJyd9YFxuICAgICAgICAgICAgICAgIDogJ0VtcHR5IGNoYXQnO1xuICAgICAgICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMubG9hZENoYXQoY2hhdC5pZCkpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uYXBwZW5kQ2hpbGQocHJldmlldyk7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQoaGlzdG9yeUl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBjaGF0IGZyb20gaGlzdG9yeVxuICAgICAqL1xuICAgIGxvYWRDaGF0KGNoYXRJZCkge1xuICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gY2hhdElkKTtcbiAgICAgICAgaWYgKCFjaGF0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZXQgYXMgY3VycmVudCBjaGF0XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9IGNoYXRJZDtcbiAgICAgICAgLy8gVXBkYXRlIHRpdGxlXG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC52YWx1ZSA9IGNoYXQudGl0bGU7XG4gICAgICAgIC8vIENsZWFyIGFuZCByZS1wb3B1bGF0ZSBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGNoYXQubWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1zZy50ZXh0LCBtc2cuc2VuZGVyLCBtc2cuaXNNYXJrZG93biwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3dpdGNoIGJhY2sgdG8gY2hhdCB2aWV3XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSGlzdG9yeVZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBjaGF0XG4gICAgICovXG4gICAgdXBkYXRlQ3VycmVudENoYXRUaXRsZSgpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICBjaGF0LnRpdGxlID0gdGhpcy50aXRsZUlucHV0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGNvbnRyb2xzIGNvbnRhaW5lciB3aXRoIHRvZ2dsZXMgYW5kIGFjdGlvbiBidXR0b25zXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJvbHNDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRyb2xzQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbnRyb2xzLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZG93biB0b2dnbGUgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHRvZ2dsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdG9nZ2xlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZG93biB0b2dnbGVcbiAgICAgICAgY29uc3QgbWFya2Rvd25Ub2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBtYXJrZG93blRvZ2dsZS50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuaWQgPSAnbWFya2Rvd24tdG9nZ2xlJztcbiAgICAgICAgLy8gbWFya2Rvd25Ub2dnbGUuc3R5bGUubWFyZ2luUmlnaHQgPSAnNXB4JzsgLy8gU3R5bGUgdmlhIENTU1xuICAgICAgICBtYXJrZG93blRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlzTWFya2Rvd25Nb2RlID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucGxhY2Vob2xkZXIgPSB0aGlzLmlzTWFya2Rvd25Nb2RlID9cbiAgICAgICAgICAgICAgICAnV3JpdGUgbWFya2Rvd24gaGVyZS4uLlxcblxcbiMgRXhhbXBsZSBoZWFkaW5nXFxuLSBMaXN0IGl0ZW1cXG5cXG5gYGBjb2RlIGJsb2NrYGBgJyA6XG4gICAgICAgICAgICAgICAgJ0FzayBtZSBhbnl0aGluZy4uLic7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgdG9nZ2xlIGxhYmVsXG4gICAgICAgIGNvbnN0IHRvZ2dsZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdG9nZ2xlTGFiZWwuaHRtbEZvciA9ICdtYXJrZG93bi10b2dnbGUnO1xuICAgICAgICB0b2dnbGVMYWJlbC50ZXh0Q29udGVudCA9ICdNYXJrZG93biBtb2RlJztcbiAgICAgICAgLy8gdG9nZ2xlTGFiZWwuc3R5bGUuZm9udFNpemUgPSAnMTJweCc7IC8vIFN0eWxlIHZpYSBDU1NcbiAgICAgICAgLy8gQWRkIHRvZ2dsZSBlbGVtZW50cyB0byBjb250YWluZXJcbiAgICAgICAgdG9nZ2xlQ29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmtkb3duVG9nZ2xlKTtcbiAgICAgICAgdG9nZ2xlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRvZ2dsZUxhYmVsKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFjdGlvbiBidXR0b25zIGNvbnRhaW5lciAoQCwgZXhwYW5kLCBzZXR0aW5ncylcbiAgICAgICAgY29uc3QgYWN0aW9uQnV0dG9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWFjdGlvbi1idXR0b25zLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBhbGwgYWN0aW9uIGJ1dHRvbnNcbiAgICAgICAgY29uc3QgYnV0dG9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnQCcsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJbnNlcnQgY29udGV4dCAoQCknLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYnV0dG9uJ3MgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnV0dG9uID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRhcmdldEJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgcG9wdXAgbWVudSBhYm92ZSB0aGUgYnV0dG9uJ3MgdG9wIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUocmVjdC5sZWZ0ICsgNjAsIHJlY3QudG9wIC0gMjApO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0ZXh0OiAn4qSiJywgdGl0bGU6ICdFeHBhbmQgaW5wdXQnLCBhY3Rpb246ICgpID0+IHRoaXMudG9nZ2xlSW5wdXRFeHBhbnNpb24oYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5jaGlsZHJlblszXSkgfSxcbiAgICAgICAgICAgIHsgdGV4dDogJ+Kame+4jycsIHRpdGxlOiAnU2V0dGluZ3MnLCBhY3Rpb246IChldmVudCkgPT4geyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgdGhpcy5zaG93U2V0dGluZ3NNb2RhbCgpOyB9IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vIEFkZCBhbGwgYnV0dG9ucyB0byB0aGUgY29udGFpbmVyXG4gICAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICAgICAgY29uc3QgYnRuID0gdGhpcy5jcmVhdGVCdXR0b24oYnV0dG9uLnRleHQsIGJ1dHRvbi50aXRsZSk7XG4gICAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gYnV0dG9uLmFjdGlvbihlKSk7XG4gICAgICAgICAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ0bik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgdG9nZ2xlIGFuZCBhY3Rpb24gYnV0dG9ucyB0byB0aGUgY29udHJvbHMgY29udGFpbmVyXG4gICAgICAgIC8vIGNvbnRyb2xzQ29udGFpbmVyIGlzIG5vdyBqdXN0IGZvciB0aGVzZSBpbmxpbmUgY29udHJvbHMsIGFib3ZlIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0b2dnbGVDb250YWluZXIpO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b25zQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzQ29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgdG9nZ2xlSW5wdXRFeHBhbnNpb24oYnV0dG9uKSB7XG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gIXRoaXMuaXNJbnB1dEV4cGFuZGVkO1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0RXhwYW5kZWQpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBoZWlnaHQgYmFzZWQgb24gYSBjbGFzcyBvciBDU1MgdmFyaWFibGUgaW5zdGVhZCBvZiBmaXhlZCBwaXhlbHMgaWYgcG9zc2libGVcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSAn4qShJztcbiAgICAgICAgICAgIGJ1dHRvbi50aXRsZSA9ICdDb2xsYXBzZSBpbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJyc7IC8vIFJlc2V0IGhlaWdodFxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5yb3dzID0gMTsgLy8gRW5zdXJlIGl0IGNvbGxhcHNlcyBiYWNrIHRvIDEgcm93IGhlaWdodFxuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gJ+Kkoic7XG4gICAgICAgICAgICBidXR0b24udGl0bGUgPSAnRXhwYW5kIGlucHV0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYnV0dG9uIHdpdGggZ2l2ZW4gdGV4dCBhbmQgdG9vbHRpcFxuICAgICAqL1xuICAgIGNyZWF0ZUJ1dHRvbih0ZXh0LCB0b29sdGlwKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICBidXR0b24udGl0bGUgPSB0b29sdGlwO1xuICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nO1xuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNlbmRpbmcgYSBtZXNzYWdlIGZyb20gdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgaGFuZGxlU2VuZE1lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmlucHV0RmllbGQudmFsdWUudHJpbSgpO1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gQWRkIHVzZXIgbWVzc2FnZSB0byBVSVxuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2UsICd1c2VyJywgdGhpcy5pc01hcmtkb3duTW9kZSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5yb3dzID0gMTsgLy8gUmVzZXQgcm93cyBhZnRlciBzZW5kaW5nXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJyc7IC8vIFJlc2V0IGhlaWdodCBhZnRlciBzZW5kaW5nXG4gICAgICAgICAgICAvLyBSZXNldCBleHBhbmRlZCBzdGF0ZSBpZiBuZWVkZWQgYWZ0ZXIgc2VuZGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZXhwYW5kIGJ1dHRvbiB0byByZXNldCBpdHMgc3RhdGUgaWYgbmVlZGVkICh0aGlzIG1pZ2h0IG5lZWQgYWRqdXN0bWVudCBiYXNlZCBvbiBmaW5hbCBzdHJ1Y3R1cmUpXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kQnV0dG9uID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LWFjdGlvbi1idXR0b25zLWNvbnRhaW5lciBidXR0b25bdGl0bGUqPVwiQ29sbGFwc2VcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlSW5wdXRFeHBhbnNpb24oZXhwYW5kQnV0dG9uKTsgLy8gQ29sbGFwc2UgYWZ0ZXIgc2VuZGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcnOyAvLyBGYWxsYmFjayByZXNldFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucm93cyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG1lc3NhZ2UgY29udGFpbmVyIGZvciB0aGUgYm90J3Mgc3RyZWFtaW5nIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBib3RNZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBib3RNZXNzYWdlRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdC1tZXNzYWdlJztcbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci50ZXh0Q29udGVudCA9IFwiTURcIjtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdtYXJrZG93bi1pbmRpY2F0b3InO1xuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChtYXJrZG93bkluZGljYXRvcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc2VwYXJhdGUgZGl2cyBmb3Igc3RyZWFtaW5nIHRleHQgYW5kIGZpbmFsIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBzdHJlYW1pbmdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5jbGFzc05hbWUgPSAnc3RyZWFtaW5nLWNvbnRlbnQnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnbW9ub3NwYWNlJztcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5mb250U2l6ZSA9ICcwLjllbSc7XG4gICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pdGlhbGx5IGhpZGRlblxuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RNZXNzYWdlRGl2KTtcbiAgICAgICAgICAgIC8vIFZhcmlhYmxlIHRvIGNvbGxlY3QgdGhlIGNvbXBsZXRlIHJlc3BvbnNlXG4gICAgICAgICAgICBsZXQgY29tcGxldGVSZXNwb25zZSA9ICcnO1xuICAgICAgICAgICAgLy8gR2V0IGNlbGwgY29udGV4dCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyID9cbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIuZ2V0Q3VycmVudENlbGxDb250ZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgLy8gU3RyZWFtIHJlc3BvbnNlIGZyb20gQVBJXG4gICAgICAgICAgICB0aGlzLmFwaUNsaWVudC5zdHJlYW1DaGF0KG1lc3NhZ2UsIHsgY2VsbENvbnRleHQgfSwgXG4gICAgICAgICAgICAvLyBPbiBlYWNoIGNodW5rIHJlY2VpdmVkXG4gICAgICAgICAgICAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi50ZXh0Q29udGVudCA9IGNvbXBsZXRlUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIE9uIGNvbXBsZXRlXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IG1hcmtkb3duIGRpdlxuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgLy8gUHJlLXByb2Nlc3MgYW5kIHJlbmRlciBtYXJrZG93blxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBtYXJrZG93biB0byBmaXggYW55IGlzc3VlcyB3aXRoIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZE1hcmtkb3duID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCBzYW5pdGl6ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdIdG1sID0gbWFya2VkXzEubWFya2VkLnBhcnNlKHByb2Nlc3NlZE1hcmtkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBIVE1MIHdpdGggcHJvcGVyIGNvZGUgYmxvY2sgc3R5bGluZ1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IHNhbml0aXplZEh0bWw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzeW50YXggaGlnaGxpZ2h0aW5nIGNsYXNzZXMgdG8gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkVGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYmxvY2sucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIHRvIHRoZSBib3QgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFjdGlvbiBidXR0b25zIHRvIHN0cmVhbWVkIGJvdCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbnMnO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIEVuc3VyZSBkaXNwbGF5IGlzIHNldFxuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGJ1dHRvbiB3aXRoIGljb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkKGNvbXBsZXRlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChjb3B5QnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGJ1dHRvbiB3aXRoIGljb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkVG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2VUb0NlbGwoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbnMgdG8gbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbnMgYWRkZWQgdG8gYm90IG1lc3NhZ2U6JywgYWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gY29tcGxldGVSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciBtYXJrZG93bjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdG8gY2hhdCBoaXN0b3J5XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbXBsZXRlUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6ICdib3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNYXJrZG93bjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIE9uIGVycm9yXG4gICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJlcnJvci1tZXNzYWdlXCI+RXJyb3I6ICR7ZXJyb3IubWVzc2FnZX08L2Rpdj5gO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgY2hhdCBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKHRleHQsIHNlbmRlciwgaXNNYXJrZG93biA9IGZhbHNlLCBzYXZlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIG1lc3NhZ2U6JywgeyBzZW5kZXIsIGlzTWFya2Rvd24gfSk7IC8vIERlYnVnIGxvZ1xuICAgICAgICBjb25zdCBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gc2VuZGVyID09PSAndXNlcicgPyAnanAtbGxtLWV4dC11c2VyLW1lc3NhZ2UnIDogJ2pwLWxsbS1leHQtYm90LW1lc3NhZ2UnO1xuICAgICAgICAvLyBBZGQgbWVzc2FnZSBjb250ZW50XG4gICAgICAgIGlmIChpc01hcmtkb3duIHx8IHNlbmRlciA9PT0gJ2JvdCcpIHtcbiAgICAgICAgICAgIC8vIEJvdCBtZXNzYWdlcyBhcmUgYWx3YXlzIHJlbmRlcmVkIGFzIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBtYXJrZG93bkluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IudGV4dENvbnRlbnQgPSBcIk1EXCI7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci5jbGFzc05hbWUgPSAnbWFya2Rvd24taW5kaWNhdG9yJztcbiAgICAgICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciB0aGUgcmVuZGVyZWQgbWFya2Rvd25cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ21hcmtkb3duLWNvbnRlbnQnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBQcmUtcHJvY2VzcyB0aGUgbWFya2Rvd24gdGV4dFxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbmQgcmVuZGVyIG1hcmtkb3duXG4gICAgICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRIdG1sID0gZG9tcHVyaWZ5XzEuZGVmYXVsdC5zYW5pdGl6ZShyYXdIdG1sKTtcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IHNhbml0aXplZEh0bWw7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHN5bnRheCBoaWdobGlnaHRpbmcgY2xhc3NlcyB0byBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVCbG9ja3MgPSBjb250ZW50RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyk7XG4gICAgICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBibG9jay5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZFRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gYmxvY2sucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciBtYXJrZG93bjonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgICAgICAgICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIGZvciBib3QgbWVzc2FnZXNcbiAgICAgICAgICAgIGlmIChzZW5kZXIgPT09ICdib3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBhY3Rpb24gYnV0dG9ucyB0byBib3QgbWVzc2FnZScpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbnMnO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgY29weUJ1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxyZWN0IHg9XCI5XCIgeT1cIjlcIiB3aWR0aD1cIjEzXCIgaGVpZ2h0PVwiMTNcIiByeD1cIjJcIiByeT1cIjJcIj48L3JlY3Q+PHBhdGggZD1cIk01IDE1SDRhMiAyIDAgMCAxLTItMlY0YTIgMiAwIDAgMSAyLTJoOWEyIDIgMCAwIDEgMiAydjFcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLnRpdGxlID0gJ0NvcHkgbWVzc2FnZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29weU1lc3NhZ2VUb0NsaXBib2FyZCh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkVG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlwiPjwvcGF0aD48cmVjdCB4PVwiOFwiIHk9XCIyXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMVwiIHJ5PVwiMVwiPjwvcmVjdD48cGF0aCBkPVwiTTEyIDExdjZcIj48L3BhdGg+PHBhdGggZD1cIk05IDE0aDZcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2VUb0NlbGwodGV4dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRUb0J1dHRvbik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbnMgdG8gbWVzc2FnZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoYWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FjdGlvbiBidXR0b25zIGFkZGVkIHRvIG1lc3NhZ2U6JywgYWN0aW9uc0Rpdik7IC8vIERlYnVnIGxvZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZURpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKG1lc3NhZ2VEaXYpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgLy8gU2F2ZSB0byBjaGF0IGhpc3RvcnlcbiAgICAgICAgaWYgKHNhdmVUb0hpc3RvcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgICAgICAgICAgaWYgKGNoYXQpIHtcbiAgICAgICAgICAgICAgICBjaGF0Lm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzTWFya2Rvd246IGlzTWFya2Rvd24gfHwgc2VuZGVyID09PSAnYm90J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBtZXNzYWdlIGNvbnRlbnQgdG8gY2xpcGJvYXJkXG4gICAgICovXG4gICAgY29weU1lc3NhZ2VUb0NsaXBib2FyZCh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29udGVudCBjb3BpZWQgdG8gY2xpcGJvYXJkJyk7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYnV0dG9uIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbi1idXR0b24nKTtcbiAgICAgICAgICAgICAgICBsZXQgY2xpY2tlZEJ1dHRvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24udGl0bGUgPT09ICdDb3B5IG1lc3NhZ2UgdG8gY2xpcGJvYXJkJyAmJiBidXR0b24gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWRCdXR0b24gPSBidXR0b247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaG93IHZpc3VhbCBmZWVkYmFjayBpZiB3ZSBmb3VuZCB0aGUgYnV0dG9uXG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrZWRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIVE1MID0gY2xpY2tlZEJ1dHRvbi5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWRCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTIwIDZMOSAxN2wtNS01XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tlZEJ1dHRvbi5pbm5lckhUTUwgPSBvcmlnaW5hbEhUTUw7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvcHkgdGV4dDogJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29weWluZyB0byBjbGlwYm9hcmQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbWVzc2FnZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IGNlbGxcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlVG9DZWxsKHRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JQb3MgPSBzZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IG5ld2xpbmUgYW5kIG1lc3NhZ2UgY29udGVudCBhdCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGN1cnNvclBvcyxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0OiBgXFxuJHt0ZXh0fWBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGN1cnNvclBvcyArIHRleHQubGVuZ3RoICsgMSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG1lc3NhZ2UgdG8gY2VsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgZnJvbSB0aGUgYWN0aXZlIG5vdGVib29rIGNlbGwuXG4gICAgICogKEhlbHBlciBmb3IgUG9wdXBNZW51TWFuYWdlciBjYWxsYmFjaylcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKGNlbGwgPT09IG51bGwgfHwgY2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yOyAvLyBJRWRpdG9yXG4gICAgICAgICAgICAvLyBBY2Nlc3MgQ29kZU1pcnJvciBlZGl0b3IgaW5zdGFuY2UgaWYgcG9zc2libGVcbiAgICAgICAgICAgIGNvbnN0IGNtRWRpdG9yID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgIGlmIChjbUVkaXRvciAmJiBjbUVkaXRvci5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY21FZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLm1haW47IC8vIEdldCB0aGUgbWFpbiBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBObyB0ZXh0IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgYWNjZXNzIENvZGVNaXJyb3Igc3RhdGUgdG8gZ2V0IHNlbGVjdGlvbi5cIik7XG4gICAgICAgICAgICAvLyBBdm9pZCB1c2luZyBnZXRSYW5nZSBhcyBpdCdzIGNvbmZpcm1lZCBub3QgdG8gZXhpc3Qgb24gSUVkaXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBzZWxlY3Rpb24gZnJvbSBkb2N1bWVudCBpZiBubyBub3RlYm9vayBhY3RpdmUgKGUuZy4sIHRleHQgZWRpdG9yKVxuICAgICAgICAgICAgY29uc3QgYWN0aXZlV2lkZ2V0ID0gKF9jID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuYXBwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hlbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50V2lkZ2V0O1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVdpZGdldCAmJiAnY29udGVudCcgaW4gYWN0aXZlV2lkZ2V0ICYmIGFjdGl2ZVdpZGdldC5jb250ZW50LmVkaXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVdpZGdldC5jb250ZW50LmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBjbUVkaXRvciA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICAgICAgaWYgKGNtRWRpdG9yICYmIGNtRWRpdG9yLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY21FZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgYWNjZXNzIENvZGVNaXJyb3Igc3RhdGUgZm9yIG5vbi1ub3RlYm9vayBlZGl0b3Igc2VsZWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gQXZvaWQgZ2V0UmFuZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBub3RlYm9vayBjZWxsLlxuICAgICAqIChIZWxwZXIgZm9yIFBvcHVwTWVudU1hbmFnZXIgY2FsbGJhY2spXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENlbGxDb250ZW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYWN0aXZlQ2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgICAgIGlmIChhY3RpdmVDZWxsID09PSBudWxsIHx8IGFjdGl2ZUNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUNlbGwubW9kZWwpIHtcbiAgICAgICAgICAgIC8vIFRyeSB1c2luZyBzaGFyZWRNb2RlbCBmaXJzdCAobW9yZSByb2J1c3QpXG4gICAgICAgICAgICBpZiAoYWN0aXZlQ2VsbC5tb2RlbC5zaGFyZWRNb2RlbCAmJiB0eXBlb2YgYWN0aXZlQ2VsbC5tb2RlbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aXZlQ2VsbC5tb2RlbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBUcnkgdXNpbmcgdG9KU09OKCkuc291cmNlXG4gICAgICAgICAgICBjb25zdCBjZWxsSnNvbiA9IGFjdGl2ZUNlbGwubW9kZWwudG9KU09OKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbEpzb24uc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvdXJjZSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCBqb2luIHRoZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbEpzb24uc291cmNlLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGdldCBjZWxsIGNvbnRlbnQgdmlhIG1vZGVsLnZhbHVlLnRleHQgb3IgdG9KU09OKCkuc291cmNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1ub3RlYm9vayBlZGl0b3JzIGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBhY3RpdmVXaWRnZXQgPSAoX2MgPSAoX2IgPSBnbG9iYWxzXzEuZ2xvYmFscy5hcHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGVsbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgIGlmIChhY3RpdmVXaWRnZXQgJiYgJ2NvbnRlbnQnIGluIGFjdGl2ZVdpZGdldCAmJiBhY3RpdmVXaWRnZXQuY29udGVudC5tb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVdpZGdldC5jb250ZW50Lm1vZGVsLnZhbHVlLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGV4dCB0byB0aGUgaW5wdXQgZmllbGQgd2l0aCBwcm9wZXIgc3BhY2luZ1xuICAgICAqL1xuICAgIGFwcGVuZFRvSW5wdXQodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhIHNwYWNlIGJldHdlZW4gdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IGAke2N1cnJlbnRWYWx1ZX0ke3RleHR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb2N1cyB0aGUgaW5wdXQgZmllbGQgYW5kIG1vdmUgY3Vyc29yIHRvIGVuZFxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5pbnB1dEZpZWxkLnZhbHVlLmxlbmd0aCwgdGhpcy5pbnB1dEZpZWxkLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBlbmRpbmcgdG8gaW5wdXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNldHRpbmdzIG1vZGFsIG1ldGhvZHNcbiAgICBjcmVhdGVTZXR0aW5nc01vZGFsKCkge1xuICAgICAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtb2RhbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1tb2RhbCc7XG4gICAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEtlZXAgdGhpcyBpbmxpbmUgc3R5bGUgZm9yIHRvZ2dsaW5nIHZpc2liaWxpdHlcbiAgICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWNvbnRlbnQnO1xuICAgICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG4gICAgICAgIHRpdGxlLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLXRpdGxlJztcbiAgICAgICAgdGl0bGUudGV4dENvbnRlbnQgPSAnU2V0dGluZ3MnO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICAgICAgZm9ybS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1mb3JtJztcbiAgICAgICAgLy8gUHJvdmlkZXIgc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBwcm92aWRlckxhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICAgICAgcHJvdmlkZXJMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgUHJvdmlkZXI6JztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChwcm92aWRlckxhYmVsKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJTZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgcHJvdmlkZXJTZWxlY3QuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3Mtc2VsZWN0JztcbiAgICAgICAgcHJvdmlkZXJTZWxlY3QuaWQgPSAnc2V0dGluZ3MtcHJvdmlkZXInO1xuICAgICAgICBbJ09wZW5BSScsICdIdWdnaW5nRmFjZScsICdMb2NhbCddLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0O1xuICAgICAgICAgICAgb3B0aW9uLnRleHRDb250ZW50ID0gb3B0O1xuICAgICAgICAgICAgcHJvdmlkZXJTZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQocHJvdmlkZXJTZWxlY3QpO1xuICAgICAgICAvLyBBUEkgS2V5IGlucHV0XG4gICAgICAgIGNvbnN0IGFwaUtleUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgYXBpS2V5TGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgICAgICBhcGlLZXlMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgS2V5Oic7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpS2V5TGFiZWwpO1xuICAgICAgICBjb25zdCBhcGlLZXlJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGFwaUtleUlucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWlucHV0JztcbiAgICAgICAgYXBpS2V5SW5wdXQudHlwZSA9ICdwYXNzd29yZCc7XG4gICAgICAgIGFwaUtleUlucHV0LmlkID0gJ3NldHRpbmdzLWFwaS1rZXknO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGFwaUtleUlucHV0KTtcbiAgICAgICAgLy8gQVBJIFVSTCBpbnB1dFxuICAgICAgICBjb25zdCBhcGlVcmxMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGFwaVVybExhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICAgICAgYXBpVXJsTGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIFVSTCAob3B0aW9uYWwpOic7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpVXJsTGFiZWwpO1xuICAgICAgICBjb25zdCBhcGlVcmxJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGFwaVVybElucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWlucHV0JztcbiAgICAgICAgYXBpVXJsSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgYXBpVXJsSW5wdXQuaWQgPSAnc2V0dGluZ3MtYXBpLXVybCc7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpVXJsSW5wdXQpO1xuICAgICAgICAvLyBSdWxlcyBpbnB1dFxuICAgICAgICBjb25zdCBydWxlc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgcnVsZXNMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgICAgIHJ1bGVzTGFiZWwudGV4dENvbnRlbnQgPSAnQ3VzdG9tIFJ1bGVzIChvcHRpb25hbCk6JztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChydWxlc0xhYmVsKTtcbiAgICAgICAgY29uc3QgcnVsZXNJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgIHJ1bGVzSW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtdGV4dGFyZWEnO1xuICAgICAgICBydWxlc0lucHV0LmlkID0gJ3NldHRpbmdzLXJ1bGVzJztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChydWxlc0lucHV0KTtcbiAgICAgICAgLy8gQnV0dG9ucyBjb250YWluZXJcbiAgICAgICAgY29uc3QgYnRuQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJ0bkNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1idXR0b25zJztcbiAgICAgICAgY29uc3Qgc2F2ZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBzYXZlQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWJ1dHRvbiBqcC1sbG0tZXh0LXNldHRpbmdzLXNhdmUtYnV0dG9uJztcbiAgICAgICAgc2F2ZUJ0bi50ZXh0Q29udGVudCA9ICdTYXZlJztcbiAgICAgICAgc2F2ZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gQWRkIHRoaXMgbGluZVxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcHJvdmlkZXInKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1hcGkta2V5JykudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtYXBpLXVybCcpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcnVsZXMnKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5ncyBzYXZlZDonLCB7IHByb3ZpZGVyLCBrZXksIHVybCwgcnVsZXMgfSk7XG4gICAgICAgICAgICB0aGlzLmhpZGVTZXR0aW5nc01vZGFsKCk7XG4gICAgICAgICAgICB0aGlzLnBvcFNhdmVTdWNjZXNzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY2FuY2VsQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWJ1dHRvbiBqcC1sbG0tZXh0LXNldHRpbmdzLWNhbmNlbC1idXR0b24nO1xuICAgICAgICBjYW5jZWxCdG4udGV4dENvbnRlbnQgPSAnQ2FuY2VsJztcbiAgICAgICAgY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBBZGQgdGhpcyBsaW5lXG4gICAgICAgICAgICB0aGlzLmhpZGVTZXR0aW5nc01vZGFsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoc2F2ZUJ0bik7XG4gICAgICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW5jZWxCdG4pO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGJ0bkNvbnRhaW5lcik7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbW9kYWw7XG4gICAgfVxuICAgIHNob3dTZXR0aW5nc01vZGFsKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9XG4gICAgaGlkZVNldHRpbmdzTW9kYWwoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBwb3BTYXZlU3VjY2VzcygpIHtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc01lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3VjY2Vzc01lc3NhZ2UuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3Mtc3VjY2Vzcy1tZXNzYWdlJztcbiAgICAgICAgc3VjY2Vzc01lc3NhZ2UudGV4dENvbnRlbnQgPSAnU2V0dGluZ3Mgc2F2ZWQgc3VjY2Vzc2Z1bGx5JztcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLmFwcGVuZENoaWxkKHN1Y2Nlc3NNZXNzYWdlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzTWVzc2FnZS5yZW1vdmUoKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVTaWRlYmFyV2lkZ2V0ID0gU2ltcGxlU2lkZWJhcldpZGdldDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==