"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_eiffel_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/eiffel.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/eiffel.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eiffel: () => (/* binding */ eiffel)
/* harmony export */ });
function wordObj(words) {
  var o = {};
  for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
  return o;
}
var keywords = wordObj([
  'note',
  'across',
  'when',
  'variant',
  'until',
  'unique',
  'undefine',
  'then',
  'strip',
  'select',
  'retry',
  'rescue',
  'require',
  'rename',
  'reference',
  'redefine',
  'prefix',
  'once',
  'old',
  'obsolete',
  'loop',
  'local',
  'like',
  'is',
  'inspect',
  'infix',
  'include',
  'if',
  'frozen',
  'from',
  'external',
  'export',
  'ensure',
  'end',
  'elseif',
  'else',
  'do',
  'creation',
  'create',
  'check',
  'alias',
  'agent',
  'separate',
  'invariant',
  'inherit',
  'indexing',
  'feature',
  'expanded',
  'deferred',
  'class',
  'Void',
  'True',
  'Result',
  'Precursor',
  'False',
  'Current',
  'create',
  'attached',
  'detachable',
  'as',
  'and',
  'implies',
  'not',
  'or'
]);
var operators = wordObj([":=", "and then","and", "or","<<",">>"]);

function chain(newtok, stream, state) {
  state.tokenize.push(newtok);
  return newtok(stream, state);
}

function tokenBase(stream, state) {
  if (stream.eatSpace()) return null;
  var ch = stream.next();
  if (ch == '"'||ch == "'") {
    return chain(readQuoted(ch, "string"), stream, state);
  } else if (ch == "-"&&stream.eat("-")) {
    stream.skipToEnd();
    return "comment";
  } else if (ch == ":"&&stream.eat("=")) {
    return "operator";
  } else if (/[0-9]/.test(ch)) {
    stream.eatWhile(/[xXbBCc0-9\.]/);
    stream.eat(/[\?\!]/);
    return "variable";
  } else if (/[a-zA-Z_0-9]/.test(ch)) {
    stream.eatWhile(/[a-zA-Z_0-9]/);
    stream.eat(/[\?\!]/);
    return "variable";
  } else if (/[=+\-\/*^%<>~]/.test(ch)) {
    stream.eatWhile(/[=+\-\/*^%<>~]/);
    return "operator";
  } else {
    return null;
  }
}

function readQuoted(quote, style,  unescaped) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && (unescaped || !escaped)) {
        state.tokenize.pop();
        break;
      }
      escaped = !escaped && ch == "%";
    }
    return style;
  };
}

const eiffel = {
  name: "eiffel",
  startState: function() {
    return {tokenize: [tokenBase]};
  },

  token: function(stream, state) {
    var style = state.tokenize[state.tokenize.length-1](stream, state);
    if (style == "variable") {
      var word = stream.current();
      style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
        : operators.propertyIsEnumerable(stream.current()) ? "operator"
        : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
        : /^0[bB][0-1]+$/g.test(word) ? "number"
        : /^0[cC][0-7]+$/g.test(word) ? "number"
        : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
        : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
        : /^[0-9]+$/g.test(word) ? "number"
        : "variable";
    }
    return style;
  },
  languageData: {
    commentTokens: {line: "--"}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZWlmZmVsX2pzLjUzNDAxMTBiMmJhYmNjMWNmNmU0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2VpZmZlbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkT2JqKHdvcmRzKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBlID0gd29yZHMubGVuZ3RoOyBpIDwgZTsgKytpKSBvW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvO1xufVxudmFyIGtleXdvcmRzID0gd29yZE9iaihbXG4gICdub3RlJyxcbiAgJ2Fjcm9zcycsXG4gICd3aGVuJyxcbiAgJ3ZhcmlhbnQnLFxuICAndW50aWwnLFxuICAndW5pcXVlJyxcbiAgJ3VuZGVmaW5lJyxcbiAgJ3RoZW4nLFxuICAnc3RyaXAnLFxuICAnc2VsZWN0JyxcbiAgJ3JldHJ5JyxcbiAgJ3Jlc2N1ZScsXG4gICdyZXF1aXJlJyxcbiAgJ3JlbmFtZScsXG4gICdyZWZlcmVuY2UnLFxuICAncmVkZWZpbmUnLFxuICAncHJlZml4JyxcbiAgJ29uY2UnLFxuICAnb2xkJyxcbiAgJ29ic29sZXRlJyxcbiAgJ2xvb3AnLFxuICAnbG9jYWwnLFxuICAnbGlrZScsXG4gICdpcycsXG4gICdpbnNwZWN0JyxcbiAgJ2luZml4JyxcbiAgJ2luY2x1ZGUnLFxuICAnaWYnLFxuICAnZnJvemVuJyxcbiAgJ2Zyb20nLFxuICAnZXh0ZXJuYWwnLFxuICAnZXhwb3J0JyxcbiAgJ2Vuc3VyZScsXG4gICdlbmQnLFxuICAnZWxzZWlmJyxcbiAgJ2Vsc2UnLFxuICAnZG8nLFxuICAnY3JlYXRpb24nLFxuICAnY3JlYXRlJyxcbiAgJ2NoZWNrJyxcbiAgJ2FsaWFzJyxcbiAgJ2FnZW50JyxcbiAgJ3NlcGFyYXRlJyxcbiAgJ2ludmFyaWFudCcsXG4gICdpbmhlcml0JyxcbiAgJ2luZGV4aW5nJyxcbiAgJ2ZlYXR1cmUnLFxuICAnZXhwYW5kZWQnLFxuICAnZGVmZXJyZWQnLFxuICAnY2xhc3MnLFxuICAnVm9pZCcsXG4gICdUcnVlJyxcbiAgJ1Jlc3VsdCcsXG4gICdQcmVjdXJzb3InLFxuICAnRmFsc2UnLFxuICAnQ3VycmVudCcsXG4gICdjcmVhdGUnLFxuICAnYXR0YWNoZWQnLFxuICAnZGV0YWNoYWJsZScsXG4gICdhcycsXG4gICdhbmQnLFxuICAnaW1wbGllcycsXG4gICdub3QnLFxuICAnb3InXG5dKTtcbnZhciBvcGVyYXRvcnMgPSB3b3JkT2JqKFtcIjo9XCIsIFwiYW5kIHRoZW5cIixcImFuZFwiLCBcIm9yXCIsXCI8PFwiLFwiPj5cIl0pO1xuXG5mdW5jdGlvbiBjaGFpbihuZXd0b2ssIHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUudG9rZW5pemUucHVzaChuZXd0b2spO1xuICByZXR1cm4gbmV3dG9rKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggPT0gJ1wiJ3x8Y2ggPT0gXCInXCIpIHtcbiAgICByZXR1cm4gY2hhaW4ocmVhZFF1b3RlZChjaCwgXCJzdHJpbmdcIiksIHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGNoID09IFwiLVwiJiZzdHJlYW0uZWF0KFwiLVwiKSkge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCI6XCImJnN0cmVhbS5lYXQoXCI9XCIpKSB7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfSBlbHNlIGlmICgvWzAtOV0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9beFhiQkNjMC05XFwuXS8pO1xuICAgIHN0cmVhbS5lYXQoL1tcXD9cXCFdLyk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfSBlbHNlIGlmICgvW2EtekEtWl8wLTldLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW2EtekEtWl8wLTldLyk7XG4gICAgc3RyZWFtLmVhdCgvW1xcP1xcIV0vKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9IGVsc2UgaWYgKC9bPStcXC1cXC8qXiU8Pn5dLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvWz0rXFwtXFwvKl4lPD5+XS8pO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFF1b3RlZChxdW90ZSwgc3R5bGUsICB1bmVzY2FwZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoID09IHF1b3RlICYmICh1bmVzY2FwZWQgfHwgIWVzY2FwZWQpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIiVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZWlmZmVsID0ge1xuICBuYW1lOiBcImVpZmZlbFwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge3Rva2VuaXplOiBbdG9rZW5CYXNlXX07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGgtMV0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIikge1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgc3R5bGUgPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpKSA/IFwia2V5d29yZFwiXG4gICAgICAgIDogb3BlcmF0b3JzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkpID8gXCJvcGVyYXRvclwiXG4gICAgICAgIDogL15bQS1aXVtBLVpfMC05XSokL2cudGVzdCh3b3JkKSA/IFwidGFnXCJcbiAgICAgICAgOiAvXjBbYkJdWzAtMV0rJC9nLnRlc3Qod29yZCkgPyBcIm51bWJlclwiXG4gICAgICAgIDogL14wW2NDXVswLTddKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICA6IC9eMFt4WF1bYS1mQS1GMC05XSskL2cudGVzdCh3b3JkKSA/IFwibnVtYmVyXCJcbiAgICAgICAgOiAvXihbMC05XStcXC5bMC05XSopfChbMC05XSpcXC5bMC05XSspJC9nLnRlc3Qod29yZCkgPyBcIm51bWJlclwiXG4gICAgICAgIDogL15bMC05XSskL2cudGVzdCh3b3JkKSA/IFwibnVtYmVyXCJcbiAgICAgICAgOiBcInZhcmlhYmxlXCI7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLS1cIn1cbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9