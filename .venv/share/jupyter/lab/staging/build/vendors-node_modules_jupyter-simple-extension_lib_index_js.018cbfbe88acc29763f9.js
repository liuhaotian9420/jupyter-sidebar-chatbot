"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/api-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/api-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: icons_1.extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/globals.js":
/*!**************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/globals.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/icons.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/icons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/markdown-config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/markdown-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = text.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks, handle list items
        return line.replace(/([^\n\s])-\s/g, '$1\n- ');
    });
    return processedLines.join('\n');
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
const markdown_config_1 = __webpack_require__(/*! ./markdown-config */ "./node_modules/jupyter-simple-extension/lib/markdown-config.js");
// Configure marked with our settings
(0, markdown_config_1.configureMarked)();
/**
 * Main sidebar widget for the AI chat interface
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    constructor(docManager) {
        super();
        this.isMarkdownMode = false;
        this.isInputExpanded = false;
        this.chatHistory = [];
        this.currentChatId = '';
        this.isHistoryViewActive = false;
        this.currentNotebook = null;
        // Menu navigation state
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        /**
         * Handles keyboard shortcuts
         */
        this.handleKeyDown = (event) => {
            var _a, _b;
            // Check for Ctrl+L (for selected code)
            if (event.ctrlKey && event.key.toLowerCase() === 'l') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Get the current active cell
                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
                if (!cell || !cell.editor) {
                    return;
                }
                try {
                    // Get the CodeMirror editor instance
                    const editor = cell.editor;
                    const view = editor.editor;
                    if (!view) {
                        return;
                    }
                    // Check if there's a selection
                    const state = view.state;
                    const selection = state.selection;
                    if (!selection.main.empty) {
                        // If there's a selection, use @code
                        const from = selection.main.from;
                        const to = selection.main.to;
                        const selectedText = state.doc.sliceString(from, to);
                        this.appendToInput(`@code\n${selectedText}`);
                        this.showKeyboardShortcutIndicator('Selected code inserted');
                    }
                    else {
                        // If no selection, use @cell
                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();
                        if (cellContext) {
                            this.appendToInput(`@cell\n${cellContext.text}`);
                            this.showKeyboardShortcutIndicator('Cell content inserted');
                        }
                    }
                    // Ensure the sidebar is visible and focused
                    if (this.isHidden) {
                        this.show();
                    }
                    this.inputField.focus();
                }
                catch (error) {
                    console.error('Error handling keyboard shortcut:', error);
                }
            }
        };
        /**
         * Handles clicks outside the popup menu to close it.
         */
        this.handleClickOutside = (event) => {
            // Check if the click is outside the popup menu container
            if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
                console.log('POPUP: Click detected outside popup menu.');
                this.hidePopupMenu();
                document.removeEventListener('click', this.handleClickOutside);
            }
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        // Initialize API client
        this.apiClient = new api_client_1.ApiClient();
        // Track the current notebook
        if (globals_1.globals.notebookTracker) {
            // Set initial notebook if one is active
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            // Update currentNotebook when the active notebook changes
            globals_1.globals.notebookTracker.currentChanged.connect((_, notebook) => {
                this.currentNotebook = notebook;
            });
        }
        // Initialize container elements before creating layout
        this.messageContainer = document.createElement('div');
        this.inputContainer = document.createElement('div');
        this.inputField = document.createElement('textarea');
        this.titleInput = document.createElement('input');
        this.historyContainer = document.createElement('div');
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container'; // Renamed class
        this.popupMenuContainer.style.display = 'none'; // Hidden by default
        // Create keyboard shortcut indicator
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'keyboard-shortcut-indicator';
        document.body.appendChild(this.keyboardShortcutIndicator);
        // Create settings modal
        this.settingsModalContainer = this.createSettingsModal();
        this.node.appendChild(this.settingsModalContainer);
        // Create a new chat on start
        this.createNewChat();
        this.node.appendChild(this.createLayout());
        // Pop-up menu will be attached to document.body when shown
        // Add keyboard shortcut listener
        document.addEventListener('keydown', this.handleKeyDown);
    }
    /**
     * Shows a visual indicator for keyboard shortcuts
     */
    showKeyboardShortcutIndicator(text) {
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Hide after 1 second
        setTimeout(() => {
            this.keyboardShortcutIndicator.classList.remove('visible');
        }, 1000);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        // Remove keyboard shortcut listener
        document.removeEventListener('keydown', this.handleKeyDown);
        // Remove keyboard shortcut indicator
        if (this.keyboardShortcutIndicator.parentNode) {
            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);
        }
        super.dispose();
    }
    /**
     * Creates the main layout for the sidebar
     */
    createLayout() {
        // Create the main container
        const content = document.createElement('div');
        content.className = 'simple-sidebar-content';
        // Create title input container
        const titleContainer = document.createElement('div');
        titleContainer.className = 'title-container';
        // Set up title input
        this.titleInput.className = 'chat-title-input';
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat';
        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());
        titleContainer.appendChild(this.titleInput);
        // Configure top action buttons (New Chat & History)
        const topActionsContainer = document.createElement('div');
        topActionsContainer.className = 'top-actions-container';
        const newChatButton = document.createElement('button');
        newChatButton.className = 'jp-Button action-button';
        newChatButton.textContent = '+ New Chat';
        newChatButton.title = 'Start a new chat';
        newChatButton.addEventListener('click', () => this.createNewChat());
        const historyButton = document.createElement('button');
        historyButton.className = 'jp-Button action-button';
        historyButton.textContent = 'History';
        historyButton.title = 'View chat history';
        historyButton.addEventListener('click', () => this.toggleHistoryView());
        topActionsContainer.appendChild(newChatButton);
        topActionsContainer.appendChild(historyButton);
        // Configure message container
        this.messageContainer.className = 'message-container';
        // Configure history container
        this.historyContainer.className = 'history-container';
        this.historyContainer.style.display = 'none'; // Initially hidden
        // Configure input container
        this.inputContainer.className = 'input-container';
        // Create controls container
        const controlsContainer = this.createControlsContainer();
        // Configure input field
        this.inputField.placeholder = 'Ask me anything...';
        this.inputField.style.flexGrow = '1';
        this.inputField.style.padding = '5px';
        this.inputField.style.border = '1px solid #ccc';
        this.inputField.style.borderRadius = '3px';
        this.inputField.style.resize = 'none';
        this.inputField.rows = 1;
        this.inputField.style.overflowY = 'auto';
        // Add keypress listener to input field
        this.inputField.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.handleSendMessage();
            }
        });
        // Create send button container
        const inputActionsContainer = document.createElement('div');
        inputActionsContainer.className = 'input-actions-container';
        // Create send button
        const sendButton = document.createElement('button');
        sendButton.className = 'jp-Button send-button';
        sendButton.textContent = 'Send';
        sendButton.addEventListener('click', () => this.handleSendMessage());
        // Add button to actions container
        inputActionsContainer.appendChild(sendButton);
        // Assemble the input components
        this.inputContainer.appendChild(controlsContainer);
        this.inputContainer.appendChild(this.inputField);
        this.inputContainer.appendChild(inputActionsContainer);
        // Assemble all components
        content.appendChild(topActionsContainer);
        content.appendChild(titleContainer);
        content.appendChild(this.messageContainer);
        content.appendChild(this.historyContainer);
        content.appendChild(this.inputContainer);
        return content;
    }
    /**
     * Creates a new chat session
     */
    createNewChat() {
        // Generate a unique ID for the chat
        const chatId = `chat-${Date.now()}`;
        // Create a new chat item
        const newChat = {
            id: chatId,
            title: 'New Chat',
            messages: []
        };
        // Add to history
        this.chatHistory.push(newChat);
        // Set as current chat
        this.currentChatId = chatId;
        // Update title input
        this.titleInput.value = newChat.title;
        // Clear message container
        if (this.messageContainer) {
            this.messageContainer.innerHTML = '';
        }
        // Hide history if it's visible
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Toggles between chat view and history view
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Show history view, hide message view
            this.messageContainer.style.display = 'none';
            this.historyContainer.style.display = 'block';
            this.inputContainer.style.display = 'none';
            this.titleInput.style.display = 'none';
            // Populate history
            this.renderChatHistory();
        }
        else {
            // Show message view, hide history view
            this.messageContainer.style.display = 'block';
            this.historyContainer.style.display = 'none';
            this.inputContainer.style.display = 'flex';
            this.titleInput.style.display = 'block';
        }
    }
    /**
     * Renders the chat history in the history container
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = '';
        if (this.chatHistory.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-history-message';
            emptyMessage.textContent = 'No chat history yet';
            this.historyContainer.appendChild(emptyMessage);
            return;
        }
        // Create a list of chat history items
        this.chatHistory.forEach(chat => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            if (chat.id === this.currentChatId) {
                historyItem.classList.add('active');
            }
            // Add title
            const title = document.createElement('div');
            title.className = 'history-title';
            title.textContent = chat.title;
            // Add message preview
            const preview = document.createElement('div');
            preview.className = 'history-preview';
            const lastMessage = chat.messages[chat.messages.length - 1];
            preview.textContent = lastMessage
                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`
                : 'Empty chat';
            // Add click event
            historyItem.addEventListener('click', () => this.loadChat(chat.id));
            historyItem.appendChild(title);
            historyItem.appendChild(preview);
            this.historyContainer.appendChild(historyItem);
        });
    }
    /**
     * Loads a chat from history
     */
    loadChat(chatId) {
        const chat = this.chatHistory.find(c => c.id === chatId);
        if (!chat)
            return;
        // Set as current chat
        this.currentChatId = chatId;
        // Update title
        this.titleInput.value = chat.title;
        // Clear and re-populate message container
        this.messageContainer.innerHTML = '';
        chat.messages.forEach(msg => {
            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);
        });
        // Switch back to chat view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Updates the title of the current chat
     */
    updateCurrentChatTitle() {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            chat.title = this.titleInput.value;
        }
    }
    /**
     * Creates the controls container with toggles and action buttons
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'controls-container';
        // Create markdown toggle container
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'toggle-container';
        // Create markdown toggle
        const markdownToggle = document.createElement('input');
        markdownToggle.type = 'checkbox';
        markdownToggle.id = 'markdown-toggle';
        markdownToggle.style.marginRight = '5px';
        markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            this.inputField.placeholder = this.isMarkdownMode ?
                'Write markdown here...\n\n# Example heading\n- List item\n\n```code block```' :
                'Ask me anything...';
        });
        // Create toggle label
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        toggleLabel.style.fontSize = '12px';
        // Add toggle elements to container
        toggleContainer.appendChild(markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // Create action buttons container
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'action-buttons-container';
        // Create all action buttons
        const buttons = [
            {
                text: '@',
                title: 'Command list',
                action: (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    const rect = event.currentTarget.getBoundingClientRect();
                    this.showPopupMenu(rect.left, rect.bottom);
                }
            },
            { text: '⤢', title: 'Expand input', action: () => this.toggleInputExpansion(actionButtonsContainer.children[3]) },
            { text: '⚙️', title: 'Settings', action: (event) => { event.preventDefault(); event.stopPropagation(); this.showSettingsModal(); } },
        ];
        // Add all buttons to the container
        buttons.forEach(button => {
            const btn = this.createButton(button.text, button.title);
            btn.addEventListener('click', (e) => button.action(e));
            actionButtonsContainer.appendChild(btn);
        });
        // Add toggle and action buttons to the controls container
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field
     */
    toggleInputExpansion(button) {
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            this.inputField.style.height = '100px';
            this.inputField.style.resize = 'vertical';
            button.textContent = '⤡';
            button.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = 'auto';
            this.inputField.style.resize = 'none';
            button.textContent = '⤢';
            button.title = 'Expand input';
        }
    }
    /**
     * Helper function to create a button with given text and tooltip
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        button.className = 'jp-Button action-button';
        return button;
    }
    /**
     * Handles sending a message from the input field
     */
    handleSendMessage() {
        const message = this.inputField.value.trim();
        if (message) {
            // Add user message to UI
            this.addMessage(message, 'user', this.isMarkdownMode);
            this.inputField.value = '';
            // Reset expanded state if needed after sending
            if (this.isInputExpanded) {
                this.inputField.style.height = '100px';
            }
            else {
                this.inputField.style.height = 'auto';
                this.inputField.rows = 1;
            }
            // Create a temporary message container for the bot's streaming response
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'bot-message';
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            botMessageDiv.appendChild(markdownIndicator);
            // Create separate divs for streaming text and final markdown
            const streamingDiv = document.createElement('div');
            streamingDiv.className = 'streaming-content';
            streamingDiv.style.whiteSpace = 'pre-wrap';
            streamingDiv.style.fontFamily = 'monospace';
            streamingDiv.style.fontSize = '0.9em';
            botMessageDiv.appendChild(streamingDiv);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            contentDiv.style.display = 'none'; // Initially hidden
            botMessageDiv.appendChild(contentDiv);
            this.messageContainer.appendChild(botMessageDiv);
            // Variable to collect the complete response
            let completeResponse = '';
            // Get cell context if available
            const cellContext = globals_1.globals.cellContextTracker ?
                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;
            // Stream response from API
            this.apiClient.streamChat(message, { cellContext }, 
            // On each chunk received
            (chunk) => {
                completeResponse += chunk;
                streamingDiv.textContent = completeResponse;
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On complete
            () => {
                // Hide streaming div, show markdown div
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                // Pre-process and render markdown
                try {
                    // Pre-process the markdown to fix any issues with code blocks
                    const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
                    // Parse and sanitize
                    const rawHtml = marked_1.marked.parse(processedMarkdown);
                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                    // Apply the HTML with proper code block styling
                    contentDiv.innerHTML = sanitizedHtml;
                    // Add syntax highlighting classes to code blocks
                    const codeBlocks = contentDiv.querySelectorAll('pre code');
                    codeBlocks.forEach(block => {
                        var _a;
                        block.classList.add('jp-RenderedText');
                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                    });
                    // Add action buttons to the bot message
                    console.log('Adding action buttons to streamed bot message');
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'message-actions';
                    actionsDiv.style.display = 'flex'; // Ensure display is set
                    // Copy button with icon
                    const copyButton = document.createElement('button');
                    copyButton.className = 'message-action-button';
                    copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    copyButton.title = 'Copy message to clipboard';
                    copyButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.copyMessageToClipboard(completeResponse);
                    });
                    actionsDiv.appendChild(copyButton);
                    // Add to button with icon
                    const addToButton = document.createElement('button');
                    addToButton.className = 'message-action-button';
                    addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                    addToButton.title = 'Add message to current cell';
                    addToButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.addMessageToCell(completeResponse);
                    });
                    actionsDiv.appendChild(addToButton);
                    // Add buttons to message
                    botMessageDiv.appendChild(actionsDiv);
                    console.log('Action buttons added to bot message:', actionsDiv);
                }
                catch (error) {
                    contentDiv.textContent = completeResponse;
                    console.error('Failed to render markdown:', error);
                }
                // Save to chat history
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages.push({
                        text: completeResponse,
                        sender: 'bot',
                        isMarkdown: true
                    });
                }
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On error
            (error) => {
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                contentDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                console.error('API Error:', error);
            });
        }
    }
    /**
     * Adds a message to the chat interface
     */
    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {
        console.log('Adding message:', { sender, isMarkdown }); // Debug log
        const messageDiv = document.createElement('div');
        messageDiv.className = sender === 'user' ? 'user-message' : 'bot-message';
        // Add message content
        if (isMarkdown || sender === 'bot') {
            // Bot messages are always rendered as markdown
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            messageDiv.appendChild(markdownIndicator);
            // Create a container for the rendered markdown
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            try {
                // Pre-process the markdown text
                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
                // Parse and render markdown
                const rawHtml = marked_1.marked.parse(processedText);
                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                contentDiv.innerHTML = sanitizedHtml;
                // Add syntax highlighting classes to code blocks
                const codeBlocks = contentDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    var _a;
                    block.classList.add('jp-RenderedText');
                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                });
            }
            catch (error) {
                contentDiv.textContent = text;
                console.error('Failed to render markdown:', error);
            }
            messageDiv.appendChild(contentDiv);
            // Add action buttons for bot messages
            if (sender === 'bot') {
                console.log('Adding action buttons to bot message'); // Debug log
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                // Copy button with icon
                const copyButton = document.createElement('button');
                copyButton.className = 'message-action-button';
                copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                copyButton.title = 'Copy message to clipboard';
                copyButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.copyMessageToClipboard(text);
                });
                actionsDiv.appendChild(copyButton);
                // Add to button with icon
                const addToButton = document.createElement('button');
                addToButton.className = 'message-action-button';
                addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                addToButton.title = 'Add message to current cell';
                addToButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.addMessageToCell(text);
                });
                actionsDiv.appendChild(addToButton);
                // Add buttons to message
                messageDiv.appendChild(actionsDiv);
                console.log('Action buttons added to message:', actionsDiv); // Debug log
            }
        }
        else {
            messageDiv.textContent = text;
        }
        this.messageContainer.appendChild(messageDiv);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        // Save to chat history
        if (saveToHistory) {
            const chat = this.chatHistory.find(c => c.id === this.currentChatId);
            if (chat) {
                chat.messages.push({
                    text,
                    sender,
                    isMarkdown: isMarkdown || sender === 'bot'
                });
            }
        }
    }
    /**
     * Copies message content to clipboard
     */
    copyMessageToClipboard(text) {
        try {
            navigator.clipboard.writeText(text).then(() => {
                console.log('Content copied to clipboard');
                // Find the button element that was clicked
                const buttons = document.querySelectorAll('.message-action-button');
                let clickedButton = null;
                for (let i = 0; i < buttons.length; i++) {
                    const button = buttons[i];
                    if (button.title === 'Copy message to clipboard' && button === document.activeElement) {
                        clickedButton = button;
                        break;
                    }
                }
                // Show visual feedback if we found the button
                if (clickedButton) {
                    const originalHTML = clickedButton.innerHTML;
                    clickedButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                    setTimeout(() => {
                        clickedButton.innerHTML = originalHTML;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        catch (error) {
            console.error('Error copying to clipboard:', error);
        }
    }
    /**
     * Adds message content to the current cell
     */
    addMessageToCell(text) {
        var _a;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell || !cell.editor) {
            return;
        }
        try {
            const editor = cell.editor;
            const view = editor.editor;
            if (!view) {
                return;
            }
            // Get current cursor position
            const state = view.state;
            const selection = state.selection;
            const cursorPos = selection.main.head;
            // Insert newline and message content at cursor position
            const transaction = state.update({
                changes: {
                    from: cursorPos,
                    insert: `\n${text}`
                },
                selection: { anchor: cursorPos + text.length + 1 }
            });
            view.dispatch(transaction);
        }
        catch (error) {
            console.error('Error adding message to cell:', error);
        }
    }
    /**
     * Lists the contents of the current directory
     * @param filterType Optional parameter to filter results by type ('all', 'file', or 'directory')
     */
    async listCurrentDirectoryContents(filterType = 'all') {
        console.log('LIST DIR: Starting directory listing process...', { filterType });
        let dirPath = null;
        let source = 'unknown';
        const app = globals_1.globals.app;
        if (!app) {
            console.error('LIST DIR: Application reference not available');
            this.addMessage('Error: Application reference not available', 'bot', false);
            return null;
        }
        console.log('LIST DIR: App reference found:', app);
        console.log('LIST DIR: Current shell widget:', app.shell.currentWidget);
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            console.log('LIST DIR: Current shell widget type:', currentShellWidget.constructor.name);
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            console.log('LIST DIR: Widget context:', widgetContext);
            if (widgetContext) {
                const path = widgetContext.path;
                console.log('LIST DIR: Widget path:', path);
                const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
                dirPath = lastSlash === -1 ? '' : path.substring(0, lastSlash);
                source = 'widget context';
                console.log(`LIST DIR: Path from widget context: ${dirPath}`);
            }
            else {
                console.log('LIST DIR: Widget context is undefined.');
            }
        }
        // Fallback 1: Active Notebook Path
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            console.log('LIST DIR: Trying notebook fallback');
            const notebookPath = this.currentNotebook.context.path;
            console.log(`LIST DIR: Raw notebook path: ${notebookPath}`);
            if (typeof notebookPath === 'string') {
                // Handle both forward and backslash path separators
                const lastSlash = Math.max(notebookPath.lastIndexOf('/'), notebookPath.lastIndexOf('\\'));
                dirPath = lastSlash === -1 ? '' : notebookPath.substring(0, lastSlash);
                source = 'notebook';
                console.log(`LIST DIR: Path from notebook context: ${dirPath}`);
            }
            else {
                console.log('LIST DIR: Notebook context path is not a string.');
            }
        }
        // Fallback 2: File Browser Current Path
        if (dirPath === null) {
            console.log('LIST DIR: Trying file browser fallback');
            const leftWidgets = Array.from(app.shell.widgets('left'));
            const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
            const fileBrowserModel = fileBrowserWidget === null || fileBrowserWidget === void 0 ? void 0 : fileBrowserWidget.model;
            // Check if the model and path exist
            if (fileBrowserModel && typeof fileBrowserModel.path === 'string') {
                const fileBrowserPath = fileBrowserModel.path;
                dirPath = fileBrowserPath;
                source = 'file browser';
                console.log(`LIST DIR: Path from file browser model: ${dirPath}`);
            }
            else {
                console.log('LIST DIR: File browser path not found or model inaccessible.');
            }
        }
        // Fallback 3: Server Root
        if (dirPath === null) {
            console.log('LIST DIR: Trying server root fallback');
            // Assuming ContentsManager root is desired. Adjust if needed.
            dirPath = ''; // Use empty string for server root with ContentsManager
            source = 'server root';
        }
        // Final Check and Logging
        if (dirPath === null) {
            // This case should ideally not be reached with the server root fallback
            console.error('LIST DIR: Critical Error - Could not determine directory path after all fallbacks.');
            // Indicate failure
            return null;
        }
        console.log(`LIST DIR: Final directory path: \"${dirPath}\" (Source: ${source})`);
        let normalizedPath = ''; // Declare outside try block
        try {
            console.log('LIST DIR: Attempting to list contents for path:', dirPath);
            normalizedPath = dirPath.replace(/\\/g, '/');
            console.log('LIST DIR: Normalized path for content manager:', normalizedPath);
            console.log('LIST DIR: Calling content manager get() with path:', normalizedPath);
            const contents = await this.docManager.services.contents.get(normalizedPath);
            console.log('LIST DIR: Contents result:', contents);
            if (contents.content && Array.isArray(contents.content)) {
                if (contents.content.length > 0) {
                    const itemNames = [];
                    contents.content.forEach(item => {
                        // Apply filter based on type
                        if (filterType === 'all' ||
                            (filterType === 'file' && item.type !== 'directory') ||
                            (filterType === 'directory' && item.type === 'directory')) {
                            const icon = item.type === 'directory' ? '📁' : '📄'; // Use icons
                            itemNames.push(`${icon} ${item.name}`); // Collect names with icons
                        }
                    });
                    console.log(`LIST DIR: Successfully listed ${itemNames.length} items (filtered by: ${filterType})`);
                    return itemNames; // Return the list of names
                }
                else {
                    console.log('LIST DIR: Directory is empty or not accessible');
                    this.addMessage(`Directory "${normalizedPath || '/'}" is empty or not accessible.`, 'bot', false);
                    return null;
                }
            }
            else {
                // Handle case where contents.content is not as expected
                console.warn('LIST DIR: Contents received, but content format is unexpected or missing.');
                this.addMessage(`Could not list contents for "${normalizedPath || '/'}". Unexpected format.`, 'bot', false);
                return null;
            }
        }
        catch (error) {
            console.error('LIST DIR: Error listing directory contents:', error);
            console.error('LIST DIR: Error details:', JSON.stringify(error, Object.getOwnPropertyNames(error)));
            this.addMessage(`Error listing directory contents for "${normalizedPath || '/'}": ${error}`, 'bot', false);
            return null;
        }
    }
    /**
     * Shows the popup menu at the specified position
     */
    showPopupMenu(x, y) {
        // Clear previous menu items
        this.popupMenuContainer.innerHTML = '';
        // Ensure menu is not already attached
        if (this.popupMenuContainer.parentElement) {
            this.popupMenuContainer.parentElement.removeChild(this.popupMenuContainer);
        }
        console.log('POPUP: Showing popup menu at:', x, y, { level: this.currentMenuLevel, path: this.currentMenuPath });
        // Handle different menu levels
        if (this.currentMenuLevel === 'top') {
            // Define top-level menu items
            const topLevelCommands = [
                {
                    label: 'Code',
                    description: 'Insert selected code',
                    action: () => {
                        console.log('POPUP: Code action triggered');
                        this.handleCodeCommand();
                        this.hidePopupMenu();
                    }
                },
                {
                    label: 'Cell',
                    description: 'Insert entire cell content',
                    action: () => {
                        console.log('POPUP: Cell action triggered');
                        this.handleCellCommand();
                        this.hidePopupMenu();
                    }
                },
                {
                    label: 'File',
                    description: 'Browse and select a file',
                    action: async () => {
                        console.log('POPUP: File action triggered');
                        // Set menu state for file browsing
                        this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
                        this.currentMenuLevel = 'files';
                        // Try to determine the current path
                        await this.setCurrentDirectoryPath();
                        // Refresh the menu with the new level
                        this.showPopupMenu(x, y);
                    }
                },
                {
                    label: 'Directory',
                    description: 'Browse and select a directory',
                    action: async () => {
                        console.log('POPUP: Directory action triggered');
                        // Set menu state for directory browsing
                        this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
                        this.currentMenuLevel = 'directories';
                        // Try to determine the current path
                        await this.setCurrentDirectoryPath();
                        // Refresh the menu with the new level
                        this.showPopupMenu(x, y);
                    }
                }
            ];
            // Create and append menu items
            this.createMenuItems(topLevelCommands);
        }
        else if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
            // Add back button if we're not at the top level
            const backButton = document.createElement('div');
            backButton.className = 'jp-llm-ext-popup-menu-item';
            backButton.innerHTML = '<span style="font-weight: bold">← Back</span>';
            backButton.onclick = (e) => {
                e.stopPropagation();
                // Pop the previous state from history
                if (this.menuHistory.length > 0) {
                    const prevState = this.menuHistory.pop();
                    this.currentMenuLevel = prevState.level;
                    this.currentMenuPath = prevState.path;
                    this.showPopupMenu(x, y);
                }
                else {
                    // If no history, go back to top level
                    this.currentMenuLevel = 'top';
                    this.currentMenuPath = '';
                    this.showPopupMenu(x, y);
                }
            };
            this.popupMenuContainer.appendChild(backButton);
            // Add current path indicator
            const pathIndicator = document.createElement('div');
            pathIndicator.className = 'jp-llm-ext-popup-menu-path';
            pathIndicator.textContent = `Path: ${this.currentMenuPath || '/'}`;
            this.popupMenuContainer.appendChild(pathIndicator);
            // Load and display directory contents based on the current level
            this.loadDirectoryContents(x, y);
        }
        // Append to body and set position
        document.body.appendChild(this.popupMenuContainer);
        this.popupMenuContainer.style.position = 'absolute'; // Position relative to document body
        this.popupMenuContainer.style.left = `${x}px`;
        this.popupMenuContainer.style.top = `${y}px`;
        this.popupMenuContainer.style.display = 'block';
        console.log('POPUP: Menu container displayed and attached to body');
        // Add click outside listener (ensure it's not added multiple times)
        document.removeEventListener('click', this.handleClickOutside);
        document.addEventListener('click', this.handleClickOutside);
    }
    /**
     * Creates menu items from commands and appends them to the popup menu container
     */
    createMenuItems(commands) {
        commands.forEach(command => {
            const item = document.createElement('div');
            item.className = 'jp-llm-ext-popup-menu-item';
            const labelSpan = document.createElement('span');
            labelSpan.textContent = command.label;
            labelSpan.style.fontWeight = 'bold';
            const descSpan = document.createElement('span');
            descSpan.textContent = command.description;
            descSpan.style.fontSize = '0.8em'; // Smaller font for description
            descSpan.style.color = 'var(--jp-ui-font-color2)'; // Dimmer color
            item.appendChild(labelSpan);
            item.appendChild(descSpan);
            item.onclick = (e) => {
                e.stopPropagation(); // Prevent click outside listener
                command.action();
            };
            this.popupMenuContainer.appendChild(item);
        });
    }
    /**
     * Loads and displays directory contents in the popup menu
     */
    async loadDirectoryContents(x, y) {
        // Show loading indicator
        const loadingItem = document.createElement('div');
        loadingItem.className = 'jp-llm-ext-popup-menu-item';
        loadingItem.textContent = 'Loading...';
        this.popupMenuContainer.appendChild(loadingItem);
        try {
            // Get directory contents with appropriate filter
            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';
            const contents = await this.listCurrentDirectoryContents(filterType);
            // Remove loading indicator
            this.popupMenuContainer.removeChild(loadingItem);
            if (contents && contents.length > 0) {
                // Create items for each content item
                contents.forEach(item => {
                    const contentItem = document.createElement('div');
                    contentItem.className = 'jp-llm-ext-popup-menu-item';
                    contentItem.textContent = item;
                    contentItem.onclick = async (e) => {
                        e.stopPropagation();
                        // Extract the name without the icon
                        const name = item.substring(2).trim();
                        if (this.currentMenuLevel === 'directories') {
                            // Handle directory navigation
                            console.log(`POPUP: Selected directory: ${name}`);
                            // Save current state to history
                            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
                            // Update path (handle both empty path and paths with trailing slash)
                            if (!this.currentMenuPath || this.currentMenuPath === '/') {
                                this.currentMenuPath = name;
                            }
                            else {
                                this.currentMenuPath = `${this.currentMenuPath}/${name}`;
                            }
                            // Switch to files view to show files in the selected directory
                            this.currentMenuLevel = 'files';
                            // Refresh the menu
                            this.showPopupMenu(x, y);
                        }
                        else if (this.currentMenuLevel === 'files') {
                            // Handle file selection
                            console.log(`POPUP: Selected file: ${name}`);
                            // Construct full path
                            let fullPath;
                            if (!this.currentMenuPath || this.currentMenuPath === '/') {
                                fullPath = name;
                            }
                            else {
                                fullPath = `${this.currentMenuPath}/${name}`;
                            }
                            // Insert the file path into the input
                            this.appendToInput(`@file\n${fullPath}`);
                            // Close the menu
                            this.hidePopupMenu();
                        }
                    };
                    this.popupMenuContainer.appendChild(contentItem);
                });
            }
            else {
                // Show empty message
                const emptyItem = document.createElement('div');
                emptyItem.className = 'jp-llm-ext-popup-menu-item';
                emptyItem.textContent = `No ${this.currentMenuLevel} found in this directory`;
                this.popupMenuContainer.appendChild(emptyItem);
            }
        }
        catch (error) {
            // Remove loading indicator
            if (loadingItem.parentNode === this.popupMenuContainer) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            // Show error message
            const errorItem = document.createElement('div');
            errorItem.className = 'jp-llm-ext-popup-menu-item';
            errorItem.textContent = `Error loading contents: ${error}`;
            this.popupMenuContainer.appendChild(errorItem);
            console.error('Error loading directory contents:', error);
        }
    }
    /**
     * Sets the current directory path based on context
     */
    async setCurrentDirectoryPath() {
        // If we already have a path, keep using it
        if (this.currentMenuPath) {
            return;
        }
        // Try to determine the current path using the same logic as in listCurrentDirectoryContents
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            return;
        }
        // Try to get path from current widget
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
                dirPath = lastSlash === -1 ? '' : path.substring(0, lastSlash);
            }
        }
        // Fallback 1: Active Notebook Path
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            console.log(`POPUP: Raw notebook path: ${notebookPath}`);
            if (typeof notebookPath === 'string') {
                const lastSlash = Math.max(notebookPath.lastIndexOf('/'), notebookPath.lastIndexOf('\\'));
                dirPath = lastSlash === -1 ? '' : notebookPath.substring(0, lastSlash);
            }
        }
        // Fallback 2: File Browser Current Path
        if (dirPath === null) {
            const leftWidgets = Array.from(app.shell.widgets('left'));
            const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
            const fileBrowserModel = fileBrowserWidget === null || fileBrowserWidget === void 0 ? void 0 : fileBrowserWidget.model;
            if (fileBrowserModel && typeof fileBrowserModel.path === 'string') {
                dirPath = fileBrowserModel.path;
            }
        }
        // Fallback 3: Server Root
        if (dirPath === null) {
            dirPath = ''; // Use empty string for server root
        }
        // Set the current menu path
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Set current menu path to: ${this.currentMenuPath}`);
    }
    /**
     * Hides the popup menu
     */
    hidePopupMenu() {
        // Only act if the menu is currently displayed
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding popup menu.');
            this.popupMenuContainer.style.display = 'none';
            // Remove from body if it's attached
            if (this.popupMenuContainer.parentElement === document.body) {
                document.body.removeChild(this.popupMenuContainer);
                console.log('POPUP: Menu container removed from body');
            }
            // Remove listener when menu is hidden
            document.removeEventListener('click', this.handleClickOutside);
            // Reset menu state to top level when hiding
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
        }
    }
    /**
     * Handle widget detachment.
     */
    onBeforeDetach(msg) {
        // Ensure the popup menu is hidden and removed from the body if the widget is detached
        this.hidePopupMenu();
        super.onBeforeDetach(msg);
    }
    /**
     * Handles the code command - inserts selected code
     */
    handleCodeCommand() {
        var _a;
        const selectedText = this.getSelectedText();
        if (selectedText) {
            this.appendToInput(`@code\n${selectedText}`);
        }
        else {
            // If no selection, get the entire cell content
            const cellContext = (_a = globals_1.globals.cellContextTracker) === null || _a === void 0 ? void 0 : _a.getCurrentCellContext();
            if (cellContext) {
                this.appendToInput(`@code\n${cellContext.text}`);
            }
        }
    }
    /**
     * Handles the cell command - inserts entire cell content
     */
    handleCellCommand() {
        var _a;
        const cellContext = (_a = globals_1.globals.cellContextTracker) === null || _a === void 0 ? void 0 : _a.getCurrentCellContext();
        if (cellContext) {
            this.appendToInput(`@cell\n${cellContext.text}`);
        }
    }
    /**
     * Appends text to the input field with proper spacing
     */
    appendToInput(text) {
        try {
            const currentValue = this.inputField.value;
            if (currentValue) {
                // If there's existing content, add a newline before appending
                this.inputField.value = `${currentValue}\n\n${text}`;
            }
            else {
                this.inputField.value = text;
            }
            // Focus the input field and move cursor to end
            this.inputField.focus();
            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    /**
     * Gets the selected text from cell context
     */
    getSelectedText() {
        var _a;
        // Get the current active cell from the tracker
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell || !cell.editor) {
            return '';
        }
        // Get the CodeMirror editor instance
        const editor = cell.editor;
        const view = editor.editor;
        if (!view) {
            return '';
        }
        // Get the selection from CodeMirror
        const state = view.state;
        const selection = state.selection;
        // If there's no selection, return empty string
        if (selection.main.empty) {
            return '';
        }
        // Get the selected text
        const from = selection.main.from;
        const to = selection.main.to;
        return state.doc.sliceString(from, to);
    }
    // Settings modal methods
    createSettingsModal() {
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.display = 'none';
        modal.style.justifyContent = 'center';
        modal.style.alignItems = 'center';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        const content = document.createElement('div');
        content.style.backgroundColor = '#fff';
        content.style.padding = '20px';
        content.style.borderRadius = '5px';
        content.style.width = '400px';
        const title = document.createElement('h3');
        title.textContent = 'Settings';
        content.appendChild(title);
        const providerLabel = document.createElement('label');
        providerLabel.htmlFor = 'settings-provider';
        providerLabel.textContent = 'LLM Provider:';
        content.appendChild(providerLabel);
        const providerSelect = document.createElement('select');
        providerSelect.id = 'settings-provider';
        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            providerSelect.appendChild(option);
        });
        content.appendChild(providerSelect);
        content.appendChild(document.createElement('br'));
        const keyLabel = document.createElement('label');
        keyLabel.htmlFor = 'settings-api-key';
        keyLabel.textContent = 'API Key:';
        content.appendChild(keyLabel);
        const keyInput = document.createElement('input');
        keyInput.id = 'settings-api-key';
        keyInput.type = 'text';
        keyInput.style.width = '100%';
        content.appendChild(keyInput);
        content.appendChild(document.createElement('br'));
        const urlLabel = document.createElement('label');
        urlLabel.htmlFor = 'settings-api-base-url';
        urlLabel.textContent = 'API Base URL (optional):';
        content.appendChild(urlLabel);
        const urlInput = document.createElement('input');
        urlInput.id = 'settings-api-base-url';
        urlInput.type = 'text';
        urlInput.style.width = '100%';
        content.appendChild(urlInput);
        content.appendChild(document.createElement('br'));
        const rulesLabel = document.createElement('label');
        rulesLabel.htmlFor = 'settings-rules';
        rulesLabel.textContent = 'Rules:';
        content.appendChild(rulesLabel);
        const rulesTextarea = document.createElement('textarea');
        rulesTextarea.id = 'settings-rules';
        rulesTextarea.style.width = '100%';
        rulesTextarea.style.height = '100px';
        content.appendChild(rulesTextarea);
        content.appendChild(document.createElement('br'));
        const btnContainer = document.createElement('div');
        btnContainer.style.textAlign = 'right';
        btnContainer.style.marginTop = '10px';
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', () => {
            const provider = document.getElementById('settings-provider').value;
            const key = document.getElementById('settings-api-key').value;
            const url = document.getElementById('settings-api-base-url').value;
            const rules = document.getElementById('settings-rules').value;
            console.log('Settings saved:', { provider, key, url, rules });
            this.hideSettingsModal();
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.marginLeft = '10px';
        cancelBtn.addEventListener('click', () => this.hideSettingsModal());
        btnContainer.appendChild(saveBtn);
        btnContainer.appendChild(cancelBtn);
        content.appendChild(btnContainer);
        modal.appendChild(content);
        return modal;
    }
    showSettingsModal() {
        this.settingsModalContainer.style.display = 'flex';
    }
    hideSettingsModal() {
        this.settingsModalContainer.style.display = 'none';
    }
}
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy4wMThjYmZiZTg4YWNjMjk3NjNmOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7OztBQ3JFSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsK0VBQStFO0FBQy9FLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9hcGktY2xpZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NlbGwtY29udGV4dC10cmFja2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NvbW1hbmRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvbWFya2Rvd24tY29uZmlnLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3NpZGViYXItd2lkZ2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcGlDbGllbnQgPSB2b2lkIDA7XG4vKipcbiAqIEFQSSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIGJhY2tlbmQgTExNIHNlcnZpY2VcbiAqL1xuY2xhc3MgQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCcpIHtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIGEgY2hhdCByZXNwb25zZSBmcm9tIHRoZSBtb2NrIExMTVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSB1c2VyIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAqIEBwYXJhbSBjb250ZXh0IE9wdGlvbmFsIGNvbnRleHQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0gb25DaHVuayBDYWxsYmFjayBmb3IgZWFjaCB0ZXh0IGNodW5rIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIG9uQ29tcGxldGUgQ2FsbGJhY2sgd2hlbiBzdHJlYW1pbmcgaXMgY29tcGxldGVcbiAgICAgKiBAcGFyYW0gb25FcnJvciBDYWxsYmFjayBmb3IgZXJyb3JzXG4gICAgICovXG4gICAgYXN5bmMgc3RyZWFtQ2hhdChtZXNzYWdlLCBjb250ZXh0ID0gbnVsbCwgb25DaHVuaywgb25Db21wbGV0ZSwgb25FcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2NoYXRgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlU3RyZWFtIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHVwIHN0cmVhbSByZWFkaW5nXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmU6IHJlYWRlckRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHJlYWRlckRvbmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiAhZG9uZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25DaHVuayhjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBoZWFsdGggY2hlY2sgZm9yIHRoZSBBUElcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSBBUEkgaXMgaGVhbHRoeVxuICAgICAqL1xuICAgIGFzeW5jIGhlYWx0aENoZWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2hlYWx0aGApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQVBJIGhlYWx0aCBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BcGlDbGllbnQgPSBBcGlDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2VsbENvbnRleHRUcmFja2VyID0gdm9pZCAwO1xuLyoqXG4gKiBUcmFja3MgY2VsbCBjb250ZXh0IGFuZCBjdXJzb3IgcG9zaXRpb24gd2l0aGluIEp1cHl0ZXIgbm90ZWJvb2tzXG4gKi9cbmNsYXNzIENlbGxDb250ZXh0VHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBub3RlYm9va1RyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBlZGl0b3IgZXZlbnRzIChrZXlkb3duLCBtb3VzZXVwKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYWN0aXZlIGNlbGwgZnJvbSB0aGUgdHJhY2tlclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBpbm5lciBFZGl0b3JWaWV3IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gR2V0IGFuZCBzdG9yZSB0aGUgY3Vyc29yIGNvbnRleHRcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IHRoaXMuZ2V0Q21Db250ZXh0KHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGVkaXRvciBldmVudCBoYW5kbGVyOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyID0gbm90ZWJvb2tUcmFja2VyO1xuICAgICAgICB0aGlzLnNldHVwVHJhY2tlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIG9iamVjdCBoYXMgYmVlbiBkaXNwb3NlZFxuICAgICAqL1xuICAgIGdldCBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCB0cmFja2Vyc1xuICAgICAqL1xuICAgIHNldHVwVHJhY2tlcnMoKSB7XG4gICAgICAgIC8vIEhhbmRsZSBhY3RpdmUgY2VsbCBjaGFuZ2VzXG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGxDaGFuZ2VkLmNvbm5lY3QodGhpcy5zZXR1cENlbGxMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICAvLyBIYW5kbGUgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5jb25uZWN0KHRoaXMuaGFuZGxlTm90ZWJvb2tDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5vdGVib29rIGNoYW5nZXNcbiAgICAgKi9cbiAgICBoYW5kbGVOb3RlYm9va0NoYW5nZSh0cmFja2VyLCBwYW5lbCkge1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICBpZiAocGFuZWwgJiYgcGFuZWwuY29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHBhbmVsLmNvbnRlbnQuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzKHRyYWNrZXIsIGNlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBhY3RpdmUgY2VsbFxuICAgICAqL1xuICAgIHNldHVwQ2VsbExpc3RlbmVycyhfdHJhY2tlciwgY2VsbCkge1xuICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmIChjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsTm9kZSA9IGNlbGwubm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3JOb2RlID0gY2VsbE5vZGUucXVlcnlTZWxlY3RvcignLmpwLUVkaXRvcicpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNlbGxOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1JbnB1dEFyZWEtZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSA9IGVkaXRvck5vZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIGtleSBhbmQgbW91c2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGNhcHR1cmUgaW1tZWRpYXRlIGNvbnRleHQgaWYgRWRpdG9yVmlldyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGNlbGwuZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gdGhpcy5nZXRDbUNvbnRleHQodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2V0dGluZyB1cCBjZWxsIGxpc3RlbmVyczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgcHJldmlvdXMgYWN0aXZlIGNlbGxcbiAgICAgKi9cbiAgICBjbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjb250ZXh0IGluZm9ybWF0aW9uIGZyb20gQ29kZU1pcnJvciBFZGl0b3JWaWV3XG4gICAgICovXG4gICAgZ2V0Q21Db250ZXh0KHZpZXcpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICBjb25zdCBmdWxsVGV4dCA9IHN0YXRlLmRvYy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUubnVtYmVyIC0gMSxcbiAgICAgICAgICAgIGNvbHVtbjogb2Zmc2V0IC0gbGluZS5mcm9tLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGV4dFJhZGl1cyA9IDEwMDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBvZmZzZXQgLSBjb250ZXh0UmFkaXVzKTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oZnVsbFRleHQubGVuZ3RoLCBvZmZzZXQgKyBjb250ZXh0UmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGZ1bGxUZXh0LFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgY29udGV4dEJlZm9yZTogZnVsbFRleHQuc3Vic3RyaW5nKHN0YXJ0LCBvZmZzZXQpLFxuICAgICAgICAgICAgY29udGV4dEFmdGVyOiBmdWxsVGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBlbmQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgY2VsbCBjb250ZXh0XG4gICAgICovXG4gICAgZ2V0Q3VycmVudENlbGxDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2VsbENvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsQ2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuZGlzY29ubmVjdCh0aGlzLmhhbmRsZU5vdGVib29rQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkNlbGxDb250ZXh0VHJhY2tlciA9IENlbGxDb250ZXh0VHJhY2tlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckNvbW1hbmRzID0gcmVnaXN0ZXJDb21tYW5kcztcbmNvbnN0IGljb25zXzEgPSByZXF1aXJlKFwiLi9pY29uc1wiKTtcbi8qKlxuICogUmVnaXN0ZXJzIGNvbW1hbmRzIGZvciB0aGUgZXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29tbWFuZHMoYXBwLCBwYWxldHRlLCBsYXVuY2hlciwgc2lkZWJhcldpZGdldCkge1xuICAgIC8vIEFkZCBjb21tYW5kIHRvIHRvZ2dsZSB0aGUgc2lkZWJhclxuICAgIGFwcC5jb21tYW5kcy5hZGRDb21tYW5kKCdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJywge1xuICAgICAgICBsYWJlbDogJ1RvZ2dsZSBBSSBBc3Npc3RhbnQgU2lkZWJhcicsXG4gICAgICAgIGljb246IGljb25zXzEuZXh0ZW5zaW9uSWNvbixcbiAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZGViYXJXaWRnZXQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHNpZGViYXJXaWRnZXQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIGNvbW1hbmQgcGFsZXR0ZVxuICAgIHBhbGV0dGUuYWRkSXRlbSh7XG4gICAgICAgIGNvbW1hbmQ6ICdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdFeHRlbnNpb24nXG4gICAgfSk7XG4gICAgLy8gQWRkIGEgbGF1bmNoZXIgaXRlbVxuICAgIGxhdW5jaGVyLmFkZCh7XG4gICAgICAgIGNvbW1hbmQ6ICdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdPdGhlcicsXG4gICAgICAgIHJhbms6IDk5OTlcbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nbG9iYWxzID0gdm9pZCAwO1xuZXhwb3J0cy5pbml0R2xvYmFscyA9IGluaXRHbG9iYWxzO1xuLyoqXG4gKiBHbG9iYWwgcmVmZXJlbmNlcyB0byBrZXkgY29tcG9uZW50cyBpbiB0aGUgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5nbG9iYWxzID0ge307XG4vKipcbiAqIEluaXRpYWxpemUgZ2xvYmFsIHJlZmVyZW5jZXNcbiAqL1xuZnVuY3Rpb24gaW5pdEdsb2JhbHMoYXBwLCBub3RlYm9va1RyYWNrZXIpIHtcbiAgICBleHBvcnRzLmdsb2JhbHMuYXBwID0gYXBwO1xuICAgIGV4cG9ydHMuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5zaW9uSWNvbiA9IHZvaWQgMDtcbmNvbnN0IHVpX2NvbXBvbmVudHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi91aS1jb21wb25lbnRzXCIpO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSWNvbiBEZWZpbml0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBpY29uU3ZnU3RyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cImJpIGJpLWNoYXQtbGVmdC10ZXh0XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPicgK1xuICAgICc8cGF0aCBkPVwiTTE0IDFhMSAxIDAgMCAxIDEgMXY4YTEgMSAwIDAgMS0xIDFINC40MTRBMiAyIDAgMCAwIDMgMTEuNTg2bC0yIDJWMmExIDEgMCAwIDEgMS0xaDEyek0yIDBhMiAyIDAgMCAwLTIgMnYxMi43OTNhLjUuNSAwIDAgMCAuODU0LjM1M2wyLjg1My0yLjg1M0ExIDEgMCAwIDEgNC40MTQgMTJIMTRhMiAyIDAgMCAwIDItMlYyYTIgMiAwIDAgMC0yLTJIMnpcIi8+JyArXG4gICAgJzxwYXRoIGQ9XCJNMyAzLjVhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05YS41LjUgMCAwIDEtLjUtLjV6TTMgNmEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlBLjUuNSAwIDAgMSAzIDZ6bTAgMi41YS41LjUgMCAwIDEgLjUtLjVoNWEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxLS41LS41elwiLz4nICtcbiAgICAnPC9zdmc+Jztcbi8qKlxuICogSWNvbiBmb3IgdGhlIEFJIEFzc2lzdGFudCBleHRlbnNpb25cbiAqL1xuZXhwb3J0cy5leHRlbnNpb25JY29uID0gbmV3IHVpX2NvbXBvbmVudHNfMS5MYWJJY29uKHtcbiAgICBuYW1lOiAnc2ltcGxlOmljb24nLFxuICAgIHN2Z3N0cjogaWNvblN2Z1N0clxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBpQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgbGF1bmNoZXJfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9sYXVuY2hlclwiKTtcbmNvbnN0IGFwcHV0aWxzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvYXBwdXRpbHNcIik7XG5jb25zdCBub3RlYm9va18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL25vdGVib29rXCIpO1xuY29uc3QgZG9jbWFuYWdlcl8xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2RvY21hbmFnZXJcIik7XG5jb25zdCBzaWRlYmFyX3dpZGdldF8xID0gcmVxdWlyZShcIi4vc2lkZWJhci13aWRnZXRcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCIuL2NvbW1hbmRzXCIpO1xuY29uc3QgY2VsbF9jb250ZXh0X3RyYWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NlbGwtY29udGV4dC10cmFja2VyXCIpO1xuLy8gaW1wb3J0IHsgQXBpQ2xpZW50IH0gZnJvbSAnLi9hcGktY2xpZW50Jztcbi8vIEV4cG9ydCBBcGlDbGllbnQgZm9yIHVzZSBieSBvdGhlciBjb21wb25lbnRzXG52YXIgYXBpX2NsaWVudF8xID0gcmVxdWlyZShcIi4vYXBpLWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwaUNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBpX2NsaWVudF8xLkFwaUNsaWVudDsgfSB9KTtcbi8qKlxuICogSW5pdGlhbGl6YXRpb24gZGF0YSBmb3IgdGhlIGp1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbiBleHRlbnNpb24uXG4gKi9cbmNvbnN0IHBsdWdpbiA9IHtcbiAgICBpZDogJ2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbjpwbHVnaW4nLFxuICAgIGF1dG9TdGFydDogdHJ1ZSxcbiAgICByZXF1aXJlczogW2xhdW5jaGVyXzEuSUxhdW5jaGVyLCBhcHB1dGlsc18xLklDb21tYW5kUGFsZXR0ZSwgbm90ZWJvb2tfMS5JTm90ZWJvb2tUcmFja2VyLCBkb2NtYW5hZ2VyXzEuSURvY3VtZW50TWFuYWdlcl0sXG4gICAgYWN0aXZhdGU6IChqdXB5dGVyQXBwLCBsYXVuY2hlciwgcGFsZXR0ZSwgdHJhY2tlciwgZG9jTWFuYWdlcikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnSnVweXRlckxhYiBleHRlbnNpb24ganVweXRlci1zaW1wbGUtZXh0ZW5zaW9uIGlzIGFjdGl2YXRlZCEnKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBnbG9iYWwgcmVmZXJlbmNlc1xuICAgICAgICAoMCwgZ2xvYmFsc18xLmluaXRHbG9iYWxzKShqdXB5dGVyQXBwLCB0cmFja2VyKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjZWxsIGNvbnRleHQgdHJhY2tlclxuICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIgPSBuZXcgY2VsbF9jb250ZXh0X3RyYWNrZXJfMS5DZWxsQ29udGV4dFRyYWNrZXIoanVweXRlckFwcCwgdHJhY2tlcik7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHNpZGViYXIgd2lkZ2V0XG4gICAgICAgIGNvbnN0IHNpZGViYXJXaWRnZXQgPSBuZXcgc2lkZWJhcl93aWRnZXRfMS5TaW1wbGVTaWRlYmFyV2lkZ2V0KGRvY01hbmFnZXIpO1xuICAgICAgICBqdXB5dGVyQXBwLnNoZWxsLmFkZChzaWRlYmFyV2lkZ2V0LCAnbGVmdCcsIHsgcmFuazogOTk5OSB9KTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgY29tbWFuZHNcbiAgICAgICAgKDAsIGNvbW1hbmRzXzEucmVnaXN0ZXJDb21tYW5kcykoanVweXRlckFwcCwgcGFsZXR0ZSwgbGF1bmNoZXIsIHNpZGViYXJXaWRnZXQpO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBwbHVnaW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uZmlndXJlTWFya2VkID0gY29uZmlndXJlTWFya2VkO1xuZXhwb3J0cy5wcmVwcm9jZXNzTWFya2Rvd24gPSBwcmVwcm9jZXNzTWFya2Rvd247XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG4vKipcbiAqIENvbmZpZ3VyZSBtYXJrZWQgd2l0aCBiZXR0ZXIgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIGNvZGUgYmxvY2tzXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZU1hcmtlZCgpIHtcbiAgICAvLyBDb25maWd1cmUgbWFya2VkIG9wdGlvbnNcbiAgICBtYXJrZWRfMS5tYXJrZWQuc2V0T3B0aW9ucyh7XG4gICAgICAgIGdmbTogdHJ1ZSwgLy8gRW5hYmxlIEdpdEh1YiBGbGF2b3JlZCBNYXJrZG93blxuICAgICAgICBicmVha3M6IHRydWUsIC8vIEFkZCA8YnI+IG9uIHNpbmdsZSBsaW5lIGJyZWFrc1xuICAgICAgICBwZWRhbnRpYzogZmFsc2UsIC8vIENvbmZvcm0gdG8gb3JpZ2luYWwgbWFya2Rvd24gc3BlY1xuICAgICAgICBhc3luYzogZmFsc2UsIC8vIERpc2FibGUgYXN5bmMgcmVuZGVyaW5nXG4gICAgICAgIHNpbGVudDogZmFsc2UgLy8gRW5hYmxlIGVycm9yIHJlcG9ydGluZ1xuICAgIH0pO1xufVxuLyoqXG4gKiBQcmUtcHJvY2VzcyBtYXJrZG93biB0ZXh0IHRvIGZpeCBjb21tb24gaXNzdWVzIHdpdGggc3RyZWFtaW5nIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gcHJlcHJvY2Vzc01hcmtkb3duKHRleHQpIHtcbiAgICAvLyBIYW5kbGUgY29kZSBibG9ja3MgZmlyc3RcbiAgICBsZXQgaW5Db2RlQmxvY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHByb2Nlc3NlZExpbmVzID0gbGluZXMubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlIGJsb2NrIG1hcmtlcnNcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2BgYCcpKSB7XG4gICAgICAgICAgICBpbkNvZGVCbG9jayA9ICFpbkNvZGVCbG9jaztcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxhbmd1YWdlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIGNvZGUgYmxvY2ssIHByZXNlcnZlIHRoZSBsaW5lIGFzIGlzXG4gICAgICAgIGlmIChpbkNvZGVCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3V0c2lkZSBjb2RlIGJsb2NrcywgaGFuZGxlIGxpc3QgaXRlbXNcbiAgICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvKFteXFxuXFxzXSktXFxzL2csICckMVxcbi0gJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3NlZExpbmVzLmpvaW4oJ1xcbicpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSB2b2lkIDA7XG5jb25zdCB3aWRnZXRzXzEgPSByZXF1aXJlKFwiQGx1bWluby93aWRnZXRzXCIpO1xuY29uc3QgbWFya2VkXzEgPSByZXF1aXJlKFwibWFya2VkXCIpO1xuY29uc3QgZG9tcHVyaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbXB1cmlmeVwiKSk7XG5jb25zdCBpY29uc18xID0gcmVxdWlyZShcIi4vaWNvbnNcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xuY29uc3QgYXBpX2NsaWVudF8xID0gcmVxdWlyZShcIi4vYXBpLWNsaWVudFwiKTtcbmNvbnN0IG1hcmtkb3duX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vbWFya2Rvd24tY29uZmlnXCIpO1xuLy8gQ29uZmlndXJlIG1hcmtlZCB3aXRoIG91ciBzZXR0aW5nc1xuKDAsIG1hcmtkb3duX2NvbmZpZ18xLmNvbmZpZ3VyZU1hcmtlZCkoKTtcbi8qKlxuICogTWFpbiBzaWRlYmFyIHdpZGdldCBmb3IgdGhlIEFJIGNoYXQgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFNpbXBsZVNpZGViYXJXaWRnZXQgZXh0ZW5kcyB3aWRnZXRzXzEuV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NNYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSAnJztcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gbnVsbDtcbiAgICAgICAgLy8gTWVudSBuYXZpZ2F0aW9uIHN0YXRlXG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9ICd0b3AnO1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9ICcnO1xuICAgICAgICB0aGlzLm1lbnVIaXN0b3J5ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN0cmwrTCAoZm9yIHNlbGVjdGVkIGNvZGUpXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24ubWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHNlbGVjdGlvbiwgdXNlIEBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gc2VsZWN0aW9uLm1haW4uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gc2VsZWN0aW9uLm1haW4udG87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY29kZVxcbiR7c2VsZWN0ZWRUZXh0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignU2VsZWN0ZWQgY29kZSBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gc2VsZWN0aW9uLCB1c2UgQGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Q3VycmVudENlbGxDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjZWxsXFxuJHtjZWxsQ29udGV4dC50ZXh0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IoJ0NlbGwgY29udGVudCBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc2lkZWJhciBpcyB2aXNpYmxlIGFuZCBmb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIGtleWJvYXJkIHNob3J0Y3V0OicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGNsaWNrcyBvdXRzaWRlIHRoZSBwb3B1cCBtZW51IHRvIGNsb3NlIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBpcyBvdXRzaWRlIHRoZSBwb3B1cCBtZW51IGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiAhdGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQ2xpY2sgZGV0ZWN0ZWQgb3V0c2lkZSBwb3B1cCBtZW51LicpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRvY01hbmFnZXIgPSBkb2NNYW5hZ2VyO1xuICAgICAgICB0aGlzLmlkID0gJ3NpbXBsZS1zaWRlYmFyJztcbiAgICAgICAgdGhpcy50aXRsZS5sYWJlbCA9ICcnO1xuICAgICAgICB0aGlzLnRpdGxlLmNhcHRpb24gPSAnQUkgQ2hhdCBJbnRlcmZhY2UnO1xuICAgICAgICB0aGlzLnRpdGxlLmljb24gPSBpY29uc18xLmV4dGVuc2lvbkljb247XG4gICAgICAgIHRoaXMudGl0bGUuY2xvc2FibGUgPSB0cnVlO1xuICAgICAgICAvLyBJbml0aWFsaXplIEFQSSBjbGllbnRcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgYXBpX2NsaWVudF8xLkFwaUNsaWVudCgpO1xuICAgICAgICAvLyBUcmFjayB0aGUgY3VycmVudCBub3RlYm9va1xuICAgICAgICBpZiAoZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSB7XG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBub3RlYm9vayBpZiBvbmUgaXMgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnROb3RlYm9vayA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50V2lkZ2V0O1xuICAgICAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnROb3RlYm9vayB3aGVuIHRoZSBhY3RpdmUgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAgICAgICAgZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmNvbm5lY3QoKF8sIG5vdGVib29rKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBub3RlYm9vaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgY29udGFpbmVyIGVsZW1lbnRzIGJlZm9yZSBjcmVhdGluZyBsYXlvdXRcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGhpcy50aXRsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtY29udGFpbmVyJzsgLy8gUmVuYW1lZCBjbGFzc1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBIaWRkZW4gYnkgZGVmYXVsdFxuICAgICAgICAvLyBDcmVhdGUga2V5Ym9hcmQgc2hvcnRjdXQgaW5kaWNhdG9yXG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2tleWJvYXJkLXNob3J0Y3V0LWluZGljYXRvcic7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgLy8gQ3JlYXRlIHNldHRpbmdzIG1vZGFsXG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciA9IHRoaXMuY3JlYXRlU2V0dGluZ3NNb2RhbCgpO1xuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgb24gc3RhcnRcbiAgICAgICAgdGhpcy5jcmVhdGVOZXdDaGF0KCk7XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxheW91dCgpKTtcbiAgICAgICAgLy8gUG9wLXVwIG1lbnUgd2lsbCBiZSBhdHRhY2hlZCB0byBkb2N1bWVudC5ib2R5IHdoZW4gc2hvd25cbiAgICAgICAgLy8gQWRkIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHZpc3VhbCBpbmRpY2F0b3IgZm9yIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIHNob3dLZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKHRleHQpIHtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gSGlkZSBhZnRlciAxIHNlY29uZFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgICAgICAvLyBSZW1vdmUga2V5Ym9hcmQgc2hvcnRjdXQgaW5kaWNhdG9yXG4gICAgICAgIGlmICh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1haW4gbGF5b3V0IGZvciB0aGUgc2lkZWJhclxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gJ3NpbXBsZS1zaWRlYmFyLWNvbnRlbnQnO1xuICAgICAgICAvLyBDcmVhdGUgdGl0bGUgaW5wdXQgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRpdGxlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICd0aXRsZS1jb250YWluZXInO1xuICAgICAgICAvLyBTZXQgdXAgdGl0bGUgaW5wdXRcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmNsYXNzTmFtZSA9ICdjaGF0LXRpdGxlLWlucHV0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5wbGFjZWhvbGRlciA9ICdDaGF0IHRpdGxlJztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnZhbHVlID0gJ05ldyBDaGF0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHRoaXMudXBkYXRlQ3VycmVudENoYXRUaXRsZSgpKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZUlucHV0KTtcbiAgICAgICAgLy8gQ29uZmlndXJlIHRvcCBhY3Rpb24gYnV0dG9ucyAoTmV3IENoYXQgJiBIaXN0b3J5KVxuICAgICAgICBjb25zdCB0b3BBY3Rpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvcEFjdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3RvcC1hY3Rpb25zLWNvbnRhaW5lcic7XG4gICAgICAgIGNvbnN0IG5ld0NoYXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGFjdGlvbi1idXR0b24nO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLnRleHRDb250ZW50ID0gJysgTmV3IENoYXQnO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLnRpdGxlID0gJ1N0YXJ0IGEgbmV3IGNoYXQnO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jcmVhdGVOZXdDaGF0KCkpO1xuICAgICAgICBjb25zdCBoaXN0b3J5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBhY3Rpb24tYnV0dG9uJztcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi50ZXh0Q29udGVudCA9ICdIaXN0b3J5JztcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi50aXRsZSA9ICdWaWV3IGNoYXQgaGlzdG9yeSc7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCkpO1xuICAgICAgICB0b3BBY3Rpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKG5ld0NoYXRCdXR0b24pO1xuICAgICAgICB0b3BBY3Rpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGhpc3RvcnlCdXR0b24pO1xuICAgICAgICAvLyBDb25maWd1cmUgbWVzc2FnZSBjb250YWluZXJcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdtZXNzYWdlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuY2xhc3NOYW1lID0gJ2hpc3RvcnktY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICAgICAgLy8gQ29uZmlndXJlIGlucHV0IGNvbnRhaW5lclxuICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdpbnB1dC1jb250YWluZXInO1xuICAgICAgICAvLyBDcmVhdGUgY29udHJvbHMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpO1xuICAgICAgICAvLyBDb25maWd1cmUgaW5wdXQgZmllbGRcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gJ0FzayBtZSBhbnl0aGluZy4uLic7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5mbGV4R3JvdyA9ICcxJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnBhZGRpbmcgPSAnNXB4JztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgI2NjYyc7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnM3B4JztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJvd3MgPSAxO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICAgICAgICAvLyBBZGQga2V5cHJlc3MgbGlzdGVuZXIgdG8gaW5wdXQgZmllbGRcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInICYmICFldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIHNlbmQgYnV0dG9uIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBpbnB1dEFjdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaW5wdXRBY3Rpb25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdpbnB1dC1hY3Rpb25zLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBzZW5kIGJ1dHRvblxuICAgICAgICBjb25zdCBzZW5kQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNlbmRCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBzZW5kLWJ1dHRvbic7XG4gICAgICAgIHNlbmRCdXR0b24udGV4dENvbnRlbnQgPSAnU2VuZCc7XG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKCkpO1xuICAgICAgICAvLyBBZGQgYnV0dG9uIHRvIGFjdGlvbnMgY29udGFpbmVyXG4gICAgICAgIGlucHV0QWN0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZW5kQnV0dG9uKTtcbiAgICAgICAgLy8gQXNzZW1ibGUgdGhlIGlucHV0IGNvbXBvbmVudHNcbiAgICAgICAgdGhpcy5pbnB1dENvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuaW5wdXRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dEZpZWxkKTtcbiAgICAgICAgdGhpcy5pbnB1dENvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dEFjdGlvbnNDb250YWluZXIpO1xuICAgICAgICAvLyBBc3NlbWJsZSBhbGwgY29tcG9uZW50c1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRvcEFjdGlvbnNDb250YWluZXIpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VDb250YWluZXIpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuaGlzdG9yeUNvbnRhaW5lcik7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvblxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQoKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgY2hhdFxuICAgICAgICBjb25zdCBjaGF0SWQgPSBgY2hhdC0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgaXRlbVxuICAgICAgICBjb25zdCBuZXdDaGF0ID0ge1xuICAgICAgICAgICAgaWQ6IGNoYXRJZCxcbiAgICAgICAgICAgIHRpdGxlOiAnTmV3IENoYXQnLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgLy8gU2V0IGFzIGN1cnJlbnQgY2hhdFxuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aXRsZSBpbnB1dFxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBuZXdDaGF0LnRpdGxlO1xuICAgICAgICAvLyBDbGVhciBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlkZSBoaXN0b3J5IGlmIGl0J3MgdmlzaWJsZVxuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBiZXR3ZWVuIGNoYXQgdmlldyBhbmQgaGlzdG9yeSB2aWV3XG4gICAgICovXG4gICAgdG9nZ2xlSGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9ICF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmU7XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFNob3cgaGlzdG9yeSB2aWV3LCBoaWRlIG1lc3NhZ2Ugdmlld1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hhdEhpc3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNob3cgbWVzc2FnZSB2aWV3LCBoaWRlIGhpc3Rvcnkgdmlld1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2hhdCBoaXN0b3J5IGluIHRoZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAqL1xuICAgIHJlbmRlckNoYXRIaXN0b3J5KCkge1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmNoYXRIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UuY2xhc3NOYW1lID0gJ2VtcHR5LWhpc3RvcnktbWVzc2FnZSc7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UudGV4dENvbnRlbnQgPSAnTm8gY2hhdCBoaXN0b3J5IHlldCc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGNoYXQgaGlzdG9yeSBpdGVtc1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5LmZvckVhY2goY2hhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY2xhc3NOYW1lID0gJ2hpc3RvcnktaXRlbSc7XG4gICAgICAgICAgICBpZiAoY2hhdC5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGl0bGVcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aXRsZS5jbGFzc05hbWUgPSAnaGlzdG9yeS10aXRsZSc7XG4gICAgICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IGNoYXQudGl0bGU7XG4gICAgICAgICAgICAvLyBBZGQgbWVzc2FnZSBwcmV2aWV3XG4gICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdoaXN0b3J5LXByZXZpZXcnO1xuICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBjaGF0Lm1lc3NhZ2VzW2NoYXQubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2aWV3LnRleHRDb250ZW50ID0gbGFzdE1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IGAke2xhc3RNZXNzYWdlLnRleHQuc3Vic3RyaW5nKDAsIDQwKX0ke2xhc3RNZXNzYWdlLnRleHQubGVuZ3RoID4gNDAgPyAnLi4uJyA6ICcnfWBcbiAgICAgICAgICAgICAgICA6ICdFbXB0eSBjaGF0JztcbiAgICAgICAgICAgIC8vIEFkZCBjbGljayBldmVudFxuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmxvYWRDaGF0KGNoYXQuaWQpKTtcbiAgICAgICAgICAgIGhpc3RvcnlJdGVtLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgICAgIGhpc3RvcnlJdGVtLmFwcGVuZENoaWxkKHByZXZpZXcpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmFwcGVuZENoaWxkKGhpc3RvcnlJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgY2hhdCBmcm9tIGhpc3RvcnlcbiAgICAgKi9cbiAgICBsb2FkQ2hhdChjaGF0SWQpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IGNoYXRJZCk7XG4gICAgICAgIGlmICghY2hhdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2V0IGFzIGN1cnJlbnQgY2hhdFxuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aXRsZVxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBjaGF0LnRpdGxlO1xuICAgICAgICAvLyBDbGVhciBhbmQgcmUtcG9wdWxhdGUgbWVzc2FnZSBjb250YWluZXJcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBjaGF0Lm1lc3NhZ2VzLmZvckVhY2gobXNnID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZShtc2cudGV4dCwgbXNnLnNlbmRlciwgbXNnLmlzTWFya2Rvd24sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN3aXRjaCBiYWNrIHRvIGNoYXQgdmlld1xuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgY2hhdFxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUoKSB7XG4gICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgY2hhdC50aXRsZSA9IHRoaXMudGl0bGVJbnB1dC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjb250cm9scyBjb250YWluZXIgd2l0aCB0b2dnbGVzIGFuZCBhY3Rpb24gYnV0dG9uc1xuICAgICAqL1xuICAgIGNyZWF0ZUNvbnRyb2xzQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBjb250cm9sc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY29udHJvbHMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtkb3duIHRvZ2dsZSBjb250YWluZXJcbiAgICAgICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAndG9nZ2xlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZG93biB0b2dnbGVcbiAgICAgICAgY29uc3QgbWFya2Rvd25Ub2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBtYXJrZG93blRvZ2dsZS50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuaWQgPSAnbWFya2Rvd24tdG9nZ2xlJztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuc3R5bGUubWFyZ2luUmlnaHQgPSAnNXB4JztcbiAgICAgICAgbWFya2Rvd25Ub2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pc01hcmtkb3duTW9kZSA9IHRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gdGhpcy5pc01hcmtkb3duTW9kZSA/XG4gICAgICAgICAgICAgICAgJ1dyaXRlIG1hcmtkb3duIGhlcmUuLi5cXG5cXG4jIEV4YW1wbGUgaGVhZGluZ1xcbi0gTGlzdCBpdGVtXFxuXFxuYGBgY29kZSBibG9ja2BgYCcgOlxuICAgICAgICAgICAgICAgICdBc2sgbWUgYW55dGhpbmcuLi4nO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIHRvZ2dsZSBsYWJlbFxuICAgICAgICBjb25zdCB0b2dnbGVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHRvZ2dsZUxhYmVsLmh0bWxGb3IgPSAnbWFya2Rvd24tdG9nZ2xlJztcbiAgICAgICAgdG9nZ2xlTGFiZWwudGV4dENvbnRlbnQgPSAnTWFya2Rvd24gbW9kZSc7XG4gICAgICAgIHRvZ2dsZUxhYmVsLnN0eWxlLmZvbnRTaXplID0gJzEycHgnO1xuICAgICAgICAvLyBBZGQgdG9nZ2xlIGVsZW1lbnRzIHRvIGNvbnRhaW5lclxuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQobWFya2Rvd25Ub2dnbGUpO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlTGFiZWwpO1xuICAgICAgICAvLyBDcmVhdGUgYWN0aW9uIGJ1dHRvbnMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGFjdGlvbkJ1dHRvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnYWN0aW9uLWJ1dHRvbnMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBhY3Rpb24gYnV0dG9uc1xuICAgICAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdAJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbW1hbmQgbGlzdCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQb3B1cE1lbnUocmVjdC5sZWZ0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdGV4dDogJ+KkoicsIHRpdGxlOiAnRXhwYW5kIGlucHV0JywgYWN0aW9uOiAoKSA9PiB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKGFjdGlvbkJ1dHRvbnNDb250YWluZXIuY2hpbGRyZW5bM10pIH0sXG4gICAgICAgICAgICB7IHRleHQ6ICfimpnvuI8nLCB0aXRsZTogJ1NldHRpbmdzJywgYWN0aW9uOiAoZXZlbnQpID0+IHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IHRoaXMuc2hvd1NldHRpbmdzTW9kYWwoKTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICAvLyBBZGQgYWxsIGJ1dHRvbnMgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ0biA9IHRoaXMuY3JlYXRlQnV0dG9uKGJ1dHRvbi50ZXh0LCBidXR0b24udGl0bGUpO1xuICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IGJ1dHRvbi5hY3Rpb24oZSkpO1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRvZ2dsZSBhbmQgYWN0aW9uIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2xzIGNvbnRhaW5lclxuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0b2dnbGVDb250YWluZXIpO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b25zQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzQ29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgdG9nZ2xlSW5wdXRFeHBhbnNpb24oYnV0dG9uKSB7XG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gIXRoaXMuaXNJbnB1dEV4cGFuZGVkO1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0RXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSAn4qShJztcbiAgICAgICAgICAgIGJ1dHRvbi50aXRsZSA9ICdDb2xsYXBzZSBpbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKInO1xuICAgICAgICAgICAgYnV0dG9uLnRpdGxlID0gJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGJ1dHRvbiB3aXRoIGdpdmVuIHRleHQgYW5kIHRvb2x0aXBcbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b24odGV4dCwgdG9vbHRpcCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24gYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2VuZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kTWVzc2FnZSgpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZS50cmltKCk7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIFVJXG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZSwgJ3VzZXInLCB0aGlzLmlzTWFya2Rvd25Nb2RlKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgLy8gUmVzZXQgZXhwYW5kZWQgc3RhdGUgaWYgbmVlZGVkIGFmdGVyIHNlbmRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucm93cyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgbWVzc2FnZSBjb250YWluZXIgZm9yIHRoZSBib3QncyBzdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGJvdE1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gJ2JvdC1tZXNzYWdlJztcbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci50ZXh0Q29udGVudCA9IFwiTURcIjtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdtYXJrZG93bi1pbmRpY2F0b3InO1xuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChtYXJrZG93bkluZGljYXRvcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc2VwYXJhdGUgZGl2cyBmb3Igc3RyZWFtaW5nIHRleHQgYW5kIGZpbmFsIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBzdHJlYW1pbmdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5jbGFzc05hbWUgPSAnc3RyZWFtaW5nLWNvbnRlbnQnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnbW9ub3NwYWNlJztcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5mb250U2l6ZSA9ICcwLjllbSc7XG4gICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pdGlhbGx5IGhpZGRlblxuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RNZXNzYWdlRGl2KTtcbiAgICAgICAgICAgIC8vIFZhcmlhYmxlIHRvIGNvbGxlY3QgdGhlIGNvbXBsZXRlIHJlc3BvbnNlXG4gICAgICAgICAgICBsZXQgY29tcGxldGVSZXNwb25zZSA9ICcnO1xuICAgICAgICAgICAgLy8gR2V0IGNlbGwgY29udGV4dCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyID9cbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIuZ2V0Q3VycmVudENlbGxDb250ZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgLy8gU3RyZWFtIHJlc3BvbnNlIGZyb20gQVBJXG4gICAgICAgICAgICB0aGlzLmFwaUNsaWVudC5zdHJlYW1DaGF0KG1lc3NhZ2UsIHsgY2VsbENvbnRleHQgfSwgXG4gICAgICAgICAgICAvLyBPbiBlYWNoIGNodW5rIHJlY2VpdmVkXG4gICAgICAgICAgICAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi50ZXh0Q29udGVudCA9IGNvbXBsZXRlUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIE9uIGNvbXBsZXRlXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IG1hcmtkb3duIGRpdlxuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgLy8gUHJlLXByb2Nlc3MgYW5kIHJlbmRlciBtYXJrZG93blxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBtYXJrZG93biB0byBmaXggYW55IGlzc3VlcyB3aXRoIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZE1hcmtkb3duID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCBzYW5pdGl6ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdIdG1sID0gbWFya2VkXzEubWFya2VkLnBhcnNlKHByb2Nlc3NlZE1hcmtkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBIVE1MIHdpdGggcHJvcGVyIGNvZGUgYmxvY2sgc3R5bGluZ1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IHNhbml0aXplZEh0bWw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzeW50YXggaGlnaGxpZ2h0aW5nIGNsYXNzZXMgdG8gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkVGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYmxvY2sucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIHRvIHRoZSBib3QgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFjdGlvbiBidXR0b25zIHRvIHN0cmVhbWVkIGJvdCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnbWVzc2FnZS1hY3Rpb25zJztcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBFbnN1cmUgZGlzcGxheSBpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5jbGFzc05hbWUgPSAnbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxyZWN0IHg9XCI5XCIgeT1cIjlcIiB3aWR0aD1cIjEzXCIgaGVpZ2h0PVwiMTNcIiByeD1cIjJcIiByeT1cIjJcIj48L3JlY3Q+PHBhdGggZD1cIk01IDE1SDRhMiAyIDAgMCAxLTItMlY0YTIgMiAwIDAgMSAyLTJoOWEyIDIgMCAwIDEgMiAydjFcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi50aXRsZSA9ICdDb3B5IG1lc3NhZ2UgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5jbGFzc05hbWUgPSAnbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2VUb0NlbGwoY29tcGxldGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbnMgdG8gbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbnMgYWRkZWQgdG8gYm90IG1lc3NhZ2U6JywgYWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gY29tcGxldGVSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciBtYXJrZG93bjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdG8gY2hhdCBoaXN0b3J5XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbXBsZXRlUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6ICdib3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNYXJrZG93bjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIE9uIGVycm9yXG4gICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJlcnJvci1tZXNzYWdlXCI+RXJyb3I6ICR7ZXJyb3IubWVzc2FnZX08L2Rpdj5gO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgY2hhdCBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKHRleHQsIHNlbmRlciwgaXNNYXJrZG93biA9IGZhbHNlLCBzYXZlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIG1lc3NhZ2U6JywgeyBzZW5kZXIsIGlzTWFya2Rvd24gfSk7IC8vIERlYnVnIGxvZ1xuICAgICAgICBjb25zdCBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gc2VuZGVyID09PSAndXNlcicgPyAndXNlci1tZXNzYWdlJyA6ICdib3QtbWVzc2FnZSc7XG4gICAgICAgIC8vIEFkZCBtZXNzYWdlIGNvbnRlbnRcbiAgICAgICAgaWYgKGlzTWFya2Rvd24gfHwgc2VuZGVyID09PSAnYm90Jykge1xuICAgICAgICAgICAgLy8gQm90IG1lc3NhZ2VzIGFyZSBhbHdheXMgcmVuZGVyZWQgYXMgbWFya2Rvd25cbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci50ZXh0Q29udGVudCA9IFwiTURcIjtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdtYXJrZG93bi1pbmRpY2F0b3InO1xuICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChtYXJrZG93bkluZGljYXRvcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSByZW5kZXJlZCBtYXJrZG93blxuICAgICAgICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGVudERpdi5jbGFzc05hbWUgPSAnbWFya2Rvd24tY29udGVudCc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBtYXJrZG93biB0ZXh0XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9ICgwLCBtYXJrZG93bl9jb25maWdfMS5wcmVwcm9jZXNzTWFya2Rvd24pKHRleHQpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCByZW5kZXIgbWFya2Rvd25cbiAgICAgICAgICAgICAgICBjb25zdCByYXdIdG1sID0gbWFya2VkXzEubWFya2VkLnBhcnNlKHByb2Nlc3NlZFRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgc3ludGF4IGhpZ2hsaWdodGluZyBjbGFzc2VzIHRvIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgICAgICBjb2RlQmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkVGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBibG9jay5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LmFkZCgnanAtUmVuZGVyZWRIVE1MQ29tbW9uJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVuZGVyIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgICAgICAvLyBBZGQgYWN0aW9uIGJ1dHRvbnMgZm9yIGJvdCBtZXNzYWdlc1xuICAgICAgICAgICAgaWYgKHNlbmRlciA9PT0gJ2JvdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFjdGlvbiBidXR0b25zIHRvIGJvdCBtZXNzYWdlJyk7IC8vIERlYnVnIGxvZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdtZXNzYWdlLWFjdGlvbnMnO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdtZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgY29weUJ1dHRvbi50aXRsZSA9ICdDb3B5IG1lc3NhZ2UgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQodGV4dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChjb3B5QnV0dG9uKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZFRvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ21lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBtZXNzYWdlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZVRvQ2VsbCh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYnV0dG9ucyB0byBtZXNzYWdlXG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbnMgYWRkZWQgdG8gbWVzc2FnZTonLCBhY3Rpb25zRGl2KTsgLy8gRGVidWcgbG9nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlRGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQobWVzc2FnZURpdik7XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAvLyBTYXZlIHRvIGNoYXQgaGlzdG9yeVxuICAgICAgICBpZiAoc2F2ZVRvSGlzdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgIGNoYXQubWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgaXNNYXJrZG93bjogaXNNYXJrZG93biB8fCBzZW5kZXIgPT09ICdib3QnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIG1lc3NhZ2UgY29udGVudCB0byBjbGlwYm9hcmRcbiAgICAgKi9cbiAgICBjb3B5TWVzc2FnZVRvQ2xpcGJvYXJkKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGNvcGllZCB0byBjbGlwYm9hcmQnKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBidXR0b24gZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZXNzYWdlLWFjdGlvbi1idXR0b24nKTtcbiAgICAgICAgICAgICAgICBsZXQgY2xpY2tlZEJ1dHRvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24udGl0bGUgPT09ICdDb3B5IG1lc3NhZ2UgdG8gY2xpcGJvYXJkJyAmJiBidXR0b24gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWRCdXR0b24gPSBidXR0b247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaG93IHZpc3VhbCBmZWVkYmFjayBpZiB3ZSBmb3VuZCB0aGUgYnV0dG9uXG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrZWRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIVE1MID0gY2xpY2tlZEJ1dHRvbi5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWRCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTIwIDZMOSAxN2wtNS01XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tlZEJ1dHRvbi5pbm5lckhUTUwgPSBvcmlnaW5hbEhUTUw7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvcHkgdGV4dDogJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29weWluZyB0byBjbGlwYm9hcmQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbWVzc2FnZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IGNlbGxcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlVG9DZWxsKHRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JQb3MgPSBzZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IG5ld2xpbmUgYW5kIG1lc3NhZ2UgY29udGVudCBhdCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGN1cnNvclBvcyxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0OiBgXFxuJHt0ZXh0fWBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGN1cnNvclBvcyArIHRleHQubGVuZ3RoICsgMSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG1lc3NhZ2UgdG8gY2VsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IGRpcmVjdG9yeVxuICAgICAqIEBwYXJhbSBmaWx0ZXJUeXBlIE9wdGlvbmFsIHBhcmFtZXRlciB0byBmaWx0ZXIgcmVzdWx0cyBieSB0eXBlICgnYWxsJywgJ2ZpbGUnLCBvciAnZGlyZWN0b3J5JylcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q3VycmVudERpcmVjdG9yeUNvbnRlbnRzKGZpbHRlclR5cGUgPSAnYWxsJykge1xuICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IFN0YXJ0aW5nIGRpcmVjdG9yeSBsaXN0aW5nIHByb2Nlc3MuLi4nLCB7IGZpbHRlclR5cGUgfSk7XG4gICAgICAgIGxldCBkaXJQYXRoID0gbnVsbDtcbiAgICAgICAgbGV0IHNvdXJjZSA9ICd1bmtub3duJztcbiAgICAgICAgY29uc3QgYXBwID0gZ2xvYmFsc18xLmdsb2JhbHMuYXBwO1xuICAgICAgICBpZiAoIWFwcCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTElTVCBESVI6IEFwcGxpY2F0aW9uIHJlZmVyZW5jZSBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoJ0Vycm9yOiBBcHBsaWNhdGlvbiByZWZlcmVuY2Ugbm90IGF2YWlsYWJsZScsICdib3QnLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IEFwcCByZWZlcmVuY2UgZm91bmQ6JywgYXBwKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0xJU1QgRElSOiBDdXJyZW50IHNoZWxsIHdpZGdldDonLCBhcHAuc2hlbGwuY3VycmVudFdpZGdldCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaGVsbFdpZGdldCA9IGFwcC5zaGVsbC5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBpZiAoY3VycmVudFNoZWxsV2lkZ2V0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IEN1cnJlbnQgc2hlbGwgd2lkZ2V0IHR5cGU6JywgY3VycmVudFNoZWxsV2lkZ2V0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGV4dCA9IHRoaXMuZG9jTWFuYWdlci5jb250ZXh0Rm9yV2lkZ2V0KGN1cnJlbnRTaGVsbFdpZGdldCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IFdpZGdldCBjb250ZXh0OicsIHdpZGdldENvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHdpZGdldENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gd2lkZ2V0Q29udGV4dC5wYXRoO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogV2lkZ2V0IHBhdGg6JywgcGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gTWF0aC5tYXgocGF0aC5sYXN0SW5kZXhPZignLycpLCBwYXRoLmxhc3RJbmRleE9mKCdcXFxcJykpO1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSBsYXN0U2xhc2ggPT09IC0xID8gJycgOiBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9ICd3aWRnZXQgY29udGV4dCc7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYExJU1QgRElSOiBQYXRoIGZyb20gd2lkZ2V0IGNvbnRleHQ6ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogV2lkZ2V0IGNvbnRleHQgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIDE6IEFjdGl2ZSBOb3RlYm9vayBQYXRoXG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsICYmIHRoaXMuY3VycmVudE5vdGVib29rICYmIHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogVHJ5aW5nIG5vdGVib29rIGZhbGxiYWNrJyk7XG4gICAgICAgICAgICBjb25zdCBub3RlYm9va1BhdGggPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTElTVCBESVI6IFJhdyBub3RlYm9vayBwYXRoOiAke25vdGVib29rUGF0aH1gKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90ZWJvb2tQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBib3RoIGZvcndhcmQgYW5kIGJhY2tzbGFzaCBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBNYXRoLm1heChub3RlYm9va1BhdGgubGFzdEluZGV4T2YoJy8nKSwgbm90ZWJvb2tQYXRoLmxhc3RJbmRleE9mKCdcXFxcJykpO1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSBsYXN0U2xhc2ggPT09IC0xID8gJycgOiBub3RlYm9va1BhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCk7XG4gICAgICAgICAgICAgICAgc291cmNlID0gJ25vdGVib29rJztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTElTVCBESVI6IFBhdGggZnJvbSBub3RlYm9vayBjb250ZXh0OiAke2RpclBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IE5vdGVib29rIGNvbnRleHQgcGF0aCBpcyBub3QgYSBzdHJpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgMjogRmlsZSBCcm93c2VyIEN1cnJlbnQgUGF0aFxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xJU1QgRElSOiBUcnlpbmcgZmlsZSBicm93c2VyIGZhbGxiYWNrJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0V2lkZ2V0cyA9IEFycmF5LmZyb20oYXBwLnNoZWxsLndpZGdldHMoJ2xlZnQnKSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlQnJvd3NlcldpZGdldCA9IGxlZnRXaWRnZXRzLmZpbmQod2lkZ2V0ID0+IHdpZGdldC5pZCA9PT0gJ2ZpbGVicm93c2VyJyk7XG4gICAgICAgICAgICBjb25zdCBmaWxlQnJvd3Nlck1vZGVsID0gZmlsZUJyb3dzZXJXaWRnZXQgPT09IG51bGwgfHwgZmlsZUJyb3dzZXJXaWRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVCcm93c2VyV2lkZ2V0Lm1vZGVsO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGFuZCBwYXRoIGV4aXN0XG4gICAgICAgICAgICBpZiAoZmlsZUJyb3dzZXJNb2RlbCAmJiB0eXBlb2YgZmlsZUJyb3dzZXJNb2RlbC5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVCcm93c2VyUGF0aCA9IGZpbGVCcm93c2VyTW9kZWwucGF0aDtcbiAgICAgICAgICAgICAgICBkaXJQYXRoID0gZmlsZUJyb3dzZXJQYXRoO1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdmaWxlIGJyb3dzZXInO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMSVNUIERJUjogUGF0aCBmcm9tIGZpbGUgYnJvd3NlciBtb2RlbDogJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xJU1QgRElSOiBGaWxlIGJyb3dzZXIgcGF0aCBub3QgZm91bmQgb3IgbW9kZWwgaW5hY2Nlc3NpYmxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIDM6IFNlcnZlciBSb290XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IFRyeWluZyBzZXJ2ZXIgcm9vdCBmYWxsYmFjaycpO1xuICAgICAgICAgICAgLy8gQXNzdW1pbmcgQ29udGVudHNNYW5hZ2VyIHJvb3QgaXMgZGVzaXJlZC4gQWRqdXN0IGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGRpclBhdGggPSAnJzsgLy8gVXNlIGVtcHR5IHN0cmluZyBmb3Igc2VydmVyIHJvb3Qgd2l0aCBDb250ZW50c01hbmFnZXJcbiAgICAgICAgICAgIHNvdXJjZSA9ICdzZXJ2ZXIgcm9vdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWwgQ2hlY2sgYW5kIExvZ2dpbmdcbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgaWRlYWxseSBub3QgYmUgcmVhY2hlZCB3aXRoIHRoZSBzZXJ2ZXIgcm9vdCBmYWxsYmFja1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTElTVCBESVI6IENyaXRpY2FsIEVycm9yIC0gQ291bGQgbm90IGRldGVybWluZSBkaXJlY3RvcnkgcGF0aCBhZnRlciBhbGwgZmFsbGJhY2tzLicpO1xuICAgICAgICAgICAgLy8gSW5kaWNhdGUgZmFpbHVyZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYExJU1QgRElSOiBGaW5hbCBkaXJlY3RvcnkgcGF0aDogXFxcIiR7ZGlyUGF0aH1cXFwiIChTb3VyY2U6ICR7c291cmNlfSlgKTtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gJyc7IC8vIERlY2xhcmUgb3V0c2lkZSB0cnkgYmxvY2tcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogQXR0ZW1wdGluZyB0byBsaXN0IGNvbnRlbnRzIGZvciBwYXRoOicsIGRpclBhdGgpO1xuICAgICAgICAgICAgbm9ybWFsaXplZFBhdGggPSBkaXJQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogTm9ybWFsaXplZCBwYXRoIGZvciBjb250ZW50IG1hbmFnZXI6Jywgbm9ybWFsaXplZFBhdGgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xJU1QgRElSOiBDYWxsaW5nIGNvbnRlbnQgbWFuYWdlciBnZXQoKSB3aXRoIHBhdGg6Jywgbm9ybWFsaXplZFBhdGgpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSBhd2FpdCB0aGlzLmRvY01hbmFnZXIuc2VydmljZXMuY29udGVudHMuZ2V0KG5vcm1hbGl6ZWRQYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogQ29udGVudHMgcmVzdWx0OicsIGNvbnRlbnRzKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50cy5jb250ZW50ICYmIEFycmF5LmlzQXJyYXkoY29udGVudHMuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1OYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy5jb250ZW50LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBmaWx0ZXIgYmFzZWQgb24gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlclR5cGUgPT09ICdhbGwnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpbHRlclR5cGUgPT09ICdmaWxlJyAmJiBpdGVtLnR5cGUgIT09ICdkaXJlY3RvcnknKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWx0ZXJUeXBlID09PSAnZGlyZWN0b3J5JyAmJiBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGljb24gPSBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknID8gJ/Cfk4EnIDogJ/Cfk4QnOyAvLyBVc2UgaWNvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtTmFtZXMucHVzaChgJHtpY29ufSAke2l0ZW0ubmFtZX1gKTsgLy8gQ29sbGVjdCBuYW1lcyB3aXRoIGljb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTElTVCBESVI6IFN1Y2Nlc3NmdWxseSBsaXN0ZWQgJHtpdGVtTmFtZXMubGVuZ3RofSBpdGVtcyAoZmlsdGVyZWQgYnk6ICR7ZmlsdGVyVHlwZX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtTmFtZXM7IC8vIFJldHVybiB0aGUgbGlzdCBvZiBuYW1lc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xJU1QgRElSOiBEaXJlY3RvcnkgaXMgZW1wdHkgb3Igbm90IGFjY2Vzc2libGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKGBEaXJlY3RvcnkgXCIke25vcm1hbGl6ZWRQYXRoIHx8ICcvJ31cIiBpcyBlbXB0eSBvciBub3QgYWNjZXNzaWJsZS5gLCAnYm90JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBjb250ZW50cy5jb250ZW50IGlzIG5vdCBhcyBleHBlY3RlZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTElTVCBESVI6IENvbnRlbnRzIHJlY2VpdmVkLCBidXQgY29udGVudCBmb3JtYXQgaXMgdW5leHBlY3RlZCBvciBtaXNzaW5nLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZShgQ291bGQgbm90IGxpc3QgY29udGVudHMgZm9yIFwiJHtub3JtYWxpemVkUGF0aCB8fCAnLyd9XCIuIFVuZXhwZWN0ZWQgZm9ybWF0LmAsICdib3QnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMSVNUIERJUjogRXJyb3IgbGlzdGluZyBkaXJlY3RvcnkgY29udGVudHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTElTVCBESVI6IEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKSkpO1xuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKGBFcnJvciBsaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50cyBmb3IgXCIke25vcm1hbGl6ZWRQYXRoIHx8ICcvJ31cIjogJHtlcnJvcn1gLCAnYm90JywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHBvcHVwIG1lbnUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqL1xuICAgIHNob3dQb3B1cE1lbnUoeCwgeSkge1xuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBtZW51IGl0ZW1zXG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAvLyBFbnN1cmUgbWVudSBpcyBub3QgYWxyZWFkeSBhdHRhY2hlZFxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBTaG93aW5nIHBvcHVwIG1lbnUgYXQ6JywgeCwgeSwgeyBsZXZlbDogdGhpcy5jdXJyZW50TWVudUxldmVsLCBwYXRoOiB0aGlzLmN1cnJlbnRNZW51UGF0aCB9KTtcbiAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCBtZW51IGxldmVsc1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAndG9wJykge1xuICAgICAgICAgICAgLy8gRGVmaW5lIHRvcC1sZXZlbCBtZW51IGl0ZW1zXG4gICAgICAgICAgICBjb25zdCB0b3BMZXZlbENvbW1hbmRzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdDb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdJbnNlcnQgc2VsZWN0ZWQgY29kZScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBDb2RlIGFjdGlvbiB0cmlnZ2VyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29kZUNvbW1hbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnQ2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5zZXJ0IGVudGlyZSBjZWxsIGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQ2VsbCBhY3Rpb24gdHJpZ2dlcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNlbGxDb21tYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0ZpbGUnLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Jyb3dzZSBhbmQgc2VsZWN0IGEgZmlsZScsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGaWxlIGFjdGlvbiB0cmlnZ2VyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBtZW51IHN0YXRlIGZvciBmaWxlIGJyb3dzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5LnB1c2goeyBsZXZlbDogdGhpcy5jdXJyZW50TWVudUxldmVsLCBwYXRoOiB0aGlzLmN1cnJlbnRNZW51UGF0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9ICdmaWxlcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudERpcmVjdG9yeVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggdGhlIG1lbnUgd2l0aCB0aGUgbmV3IGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQb3B1cE1lbnUoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdEaXJlY3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Jyb3dzZSBhbmQgc2VsZWN0IGEgZGlyZWN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IERpcmVjdG9yeSBhY3Rpb24gdHJpZ2dlcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgbWVudSBzdGF0ZSBmb3IgZGlyZWN0b3J5IGJyb3dzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5LnB1c2goeyBsZXZlbDogdGhpcy5jdXJyZW50TWVudUxldmVsLCBwYXRoOiB0aGlzLmN1cnJlbnRNZW51UGF0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9ICdkaXJlY3Rvcmllcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudERpcmVjdG9yeVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggdGhlIG1lbnUgd2l0aCB0aGUgbmV3IGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQb3B1cE1lbnUoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhcHBlbmQgbWVudSBpdGVtc1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNZW51SXRlbXModG9wTGV2ZWxDb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgLy8gQWRkIGJhY2sgYnV0dG9uIGlmIHdlJ3JlIG5vdCBhdCB0aGUgdG9wIGxldmVsXG4gICAgICAgICAgICBjb25zdCBiYWNrQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBiYWNrQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbSc7XG4gICAgICAgICAgICBiYWNrQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImZvbnQtd2VpZ2h0OiBib2xkXCI+4oaQIEJhY2s8L3NwYW4+JztcbiAgICAgICAgICAgIGJhY2tCdXR0b24ub25jbGljayA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHN0YXRlIGZyb20gaGlzdG9yeVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lbnVIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5tZW51SGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gcHJldlN0YXRlLmxldmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IHByZXZTdGF0ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQb3B1cE1lbnUoeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBoaXN0b3J5LCBnbyBiYWNrIHRvIHRvcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UG9wdXBNZW51KHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChiYWNrQnV0dG9uKTtcbiAgICAgICAgICAgIC8vIEFkZCBjdXJyZW50IHBhdGggaW5kaWNhdG9yXG4gICAgICAgICAgICBjb25zdCBwYXRoSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwYXRoSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCc7XG4gICAgICAgICAgICBwYXRoSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYFBhdGg6ICR7dGhpcy5jdXJyZW50TWVudVBhdGggfHwgJy8nfWA7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChwYXRoSW5kaWNhdG9yKTtcbiAgICAgICAgICAgIC8vIExvYWQgYW5kIGRpc3BsYXkgZGlyZWN0b3J5IGNvbnRlbnRzIGJhc2VkIG9uIHRoZSBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICB0aGlzLmxvYWREaXJlY3RvcnlDb250ZW50cyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgdG8gYm9keSBhbmQgc2V0IHBvc2l0aW9uXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7IC8vIFBvc2l0aW9uIHJlbGF0aXZlIHRvIGRvY3VtZW50IGJvZHlcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUubGVmdCA9IGAke3h9cHhgO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogTWVudSBjb250YWluZXIgZGlzcGxheWVkIGFuZCBhdHRhY2hlZCB0byBib2R5Jyk7XG4gICAgICAgIC8vIEFkZCBjbGljayBvdXRzaWRlIGxpc3RlbmVyIChlbnN1cmUgaXQncyBub3QgYWRkZWQgbXVsdGlwbGUgdGltZXMpXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtZW51IGl0ZW1zIGZyb20gY29tbWFuZHMgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgcG9wdXAgbWVudSBjb250YWluZXJcbiAgICAgKi9cbiAgICBjcmVhdGVNZW51SXRlbXMoY29tbWFuZHMpIHtcbiAgICAgICAgY29tbWFuZHMuZm9yRWFjaChjb21tYW5kID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJztcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGxhYmVsU3Bhbi50ZXh0Q29udGVudCA9IGNvbW1hbmQubGFiZWw7XG4gICAgICAgICAgICBsYWJlbFNwYW4uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICAgIGNvbnN0IGRlc2NTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgZGVzY1NwYW4udGV4dENvbnRlbnQgPSBjb21tYW5kLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgZGVzY1NwYW4uc3R5bGUuZm9udFNpemUgPSAnMC44ZW0nOyAvLyBTbWFsbGVyIGZvbnQgZm9yIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICBkZXNjU3Bhbi5zdHlsZS5jb2xvciA9ICd2YXIoLS1qcC11aS1mb250LWNvbG9yMiknOyAvLyBEaW1tZXIgY29sb3JcbiAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQobGFiZWxTcGFuKTtcbiAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZGVzY1NwYW4pO1xuICAgICAgICAgICAgaXRlbS5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50IGNsaWNrIG91dHNpZGUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBjb21tYW5kLmFjdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYW5kIGRpc3BsYXlzIGRpcmVjdG9yeSBjb250ZW50cyBpbiB0aGUgcG9wdXAgbWVudVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWREaXJlY3RvcnlDb250ZW50cyh4LCB5KSB7XG4gICAgICAgIC8vIFNob3cgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgY29uc3QgbG9hZGluZ0l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbG9hZGluZ0l0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJztcbiAgICAgICAgbG9hZGluZ0l0ZW0udGV4dENvbnRlbnQgPSAnTG9hZGluZy4uLic7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBkaXJlY3RvcnkgY29udGVudHMgd2l0aCBhcHByb3ByaWF0ZSBmaWx0ZXJcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclR5cGUgPSB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgPyAnZmlsZScgOiAnZGlyZWN0b3J5JztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5saXN0Q3VycmVudERpcmVjdG9yeUNvbnRlbnRzKGZpbHRlclR5cGUpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICBpZiAoY29udGVudHMgJiYgY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBpdGVtcyBmb3IgZWFjaCBjb250ZW50IGl0ZW1cbiAgICAgICAgICAgICAgICBjb250ZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50SXRlbS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0nO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50SXRlbS50ZXh0Q29udGVudCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRJdGVtLm9uY2xpY2sgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIG5hbWUgd2l0aG91dCB0aGUgaWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW0uc3Vic3RyaW5nKDIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZGlyZWN0b3J5IG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNlbGVjdGVkIGRpcmVjdG9yeTogJHtuYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgY3VycmVudCBzdGF0ZSB0byBoaXN0b3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51SGlzdG9yeS5wdXNoKHsgbGV2ZWw6IHRoaXMuY3VycmVudE1lbnVMZXZlbCwgcGF0aDogdGhpcy5jdXJyZW50TWVudVBhdGggfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggKGhhbmRsZSBib3RoIGVtcHR5IHBhdGggYW5kIHBhdGhzIHdpdGggdHJhaWxpbmcgc2xhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCB0aGlzLmN1cnJlbnRNZW51UGF0aCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gYCR7dGhpcy5jdXJyZW50TWVudVBhdGh9LyR7bmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gZmlsZXMgdmlldyB0byBzaG93IGZpbGVzIGluIHRoZSBzZWxlY3RlZCBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAnZmlsZXMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggdGhlIG1lbnVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQb3B1cE1lbnUoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlsZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNlbGVjdGVkIGZpbGU6ICR7bmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgZnVsbCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50TWVudVBhdGggfHwgdGhpcy5jdXJyZW50TWVudVBhdGggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsUGF0aCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsUGF0aCA9IGAke3RoaXMuY3VycmVudE1lbnVQYXRofS8ke25hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBmaWxlIHBhdGggaW50byB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBmaWxlXFxuJHtmdWxsUGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSB0aGUgbWVudVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaG93IGVtcHR5IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJztcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW0udGV4dENvbnRlbnQgPSBgTm8gJHt0aGlzLmN1cnJlbnRNZW51TGV2ZWx9IGZvdW5kIGluIHRoaXMgZGlyZWN0b3J5YDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAobG9hZGluZ0l0ZW0ucGFyZW50Tm9kZSA9PT0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaG93IGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnN0IGVycm9ySXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZXJyb3JJdGVtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbSc7XG4gICAgICAgICAgICBlcnJvckl0ZW0udGV4dENvbnRlbnQgPSBgRXJyb3IgbG9hZGluZyBjb250ZW50czogJHtlcnJvcn1gO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZXJyb3JJdGVtKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGlyZWN0b3J5IGNvbnRlbnRzOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBwYXRoIGJhc2VkIG9uIGNvbnRleHRcbiAgICAgKi9cbiAgICBhc3luYyBzZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcGF0aCwga2VlcCB1c2luZyBpdFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBjdXJyZW50IHBhdGggdXNpbmcgdGhlIHNhbWUgbG9naWMgYXMgaW4gbGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50c1xuICAgICAgICBsZXQgZGlyUGF0aCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcDtcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBBcHBsaWNhdGlvbiByZWZlcmVuY2Ugbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBnZXQgcGF0aCBmcm9tIGN1cnJlbnQgd2lkZ2V0XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTaGVsbFdpZGdldCA9IGFwcC5zaGVsbC5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBpZiAoY3VycmVudFNoZWxsV2lkZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCB3aWRnZXRDb250ZXh0ID0gdGhpcy5kb2NNYW5hZ2VyLmNvbnRleHRGb3JXaWRnZXQoY3VycmVudFNoZWxsV2lkZ2V0KTtcbiAgICAgICAgICAgIGlmICh3aWRnZXRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IHdpZGdldENvbnRleHQucGF0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBNYXRoLm1heChwYXRoLmxhc3RJbmRleE9mKCcvJyksIHBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSk7XG4gICAgICAgICAgICAgICAgZGlyUGF0aCA9IGxhc3RTbGFzaCA9PT0gLTEgPyAnJyA6IHBhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgMTogQWN0aXZlIE5vdGVib29rIFBhdGhcbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwgJiYgdGhpcy5jdXJyZW50Tm90ZWJvb2sgJiYgdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGV4dCkge1xuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYXRoID0gdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBSYXcgbm90ZWJvb2sgcGF0aDogJHtub3RlYm9va1BhdGh9YCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vdGVib29rUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBNYXRoLm1heChub3RlYm9va1BhdGgubGFzdEluZGV4T2YoJy8nKSwgbm90ZWJvb2tQYXRoLmxhc3RJbmRleE9mKCdcXFxcJykpO1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSBsYXN0U2xhc2ggPT09IC0xID8gJycgOiBub3RlYm9va1BhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgMjogRmlsZSBCcm93c2VyIEN1cnJlbnQgUGF0aFxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFdpZGdldHMgPSBBcnJheS5mcm9tKGFwcC5zaGVsbC53aWRnZXRzKCdsZWZ0JykpO1xuICAgICAgICAgICAgY29uc3QgZmlsZUJyb3dzZXJXaWRnZXQgPSBsZWZ0V2lkZ2V0cy5maW5kKHdpZGdldCA9PiB3aWRnZXQuaWQgPT09ICdmaWxlYnJvd3NlcicpO1xuICAgICAgICAgICAgY29uc3QgZmlsZUJyb3dzZXJNb2RlbCA9IGZpbGVCcm93c2VyV2lkZ2V0ID09PSBudWxsIHx8IGZpbGVCcm93c2VyV2lkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlQnJvd3NlcldpZGdldC5tb2RlbDtcbiAgICAgICAgICAgIGlmIChmaWxlQnJvd3Nlck1vZGVsICYmIHR5cGVvZiBmaWxlQnJvd3Nlck1vZGVsLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGlyUGF0aCA9IGZpbGVCcm93c2VyTW9kZWwucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayAzOiBTZXJ2ZXIgUm9vdFxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlyUGF0aCA9ICcnOyAvLyBVc2UgZW1wdHkgc3RyaW5nIGZvciBzZXJ2ZXIgcm9vdFxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBtZW51IHBhdGhcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBkaXJQYXRoO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNldCBjdXJyZW50IG1lbnUgcGF0aCB0bzogJHt0aGlzLmN1cnJlbnRNZW51UGF0aH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHBvcHVwIG1lbnVcbiAgICAgKi9cbiAgICBoaWRlUG9wdXBNZW51KCkge1xuICAgICAgICAvLyBPbmx5IGFjdCBpZiB0aGUgbWVudSBpcyBjdXJyZW50bHkgZGlzcGxheWVkXG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogSGlkaW5nIHBvcHVwIG1lbnUuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSBpZiBpdCdzIGF0dGFjaGVkXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50RWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogTWVudSBjb250YWluZXIgcmVtb3ZlZCBmcm9tIGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lciB3aGVuIG1lbnUgaXMgaGlkZGVuXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlKTtcbiAgICAgICAgICAgIC8vIFJlc2V0IG1lbnUgc3RhdGUgdG8gdG9wIGxldmVsIHdoZW4gaGlkaW5nXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5ID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdpZGdldCBkZXRhY2htZW50LlxuICAgICAqL1xuICAgIG9uQmVmb3JlRGV0YWNoKG1zZykge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHBvcHVwIG1lbnUgaXMgaGlkZGVuIGFuZCByZW1vdmVkIGZyb20gdGhlIGJvZHkgaWYgdGhlIHdpZGdldCBpcyBkZXRhY2hlZFxuICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgc3VwZXIub25CZWZvcmVEZXRhY2gobXNnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY29kZSBjb21tYW5kIC0gaW5zZXJ0cyBzZWxlY3RlZCBjb2RlXG4gICAgICovXG4gICAgaGFuZGxlQ29kZUNvbW1hbmQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY29kZVxcbiR7c2VsZWN0ZWRUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gc2VsZWN0aW9uLCBnZXQgdGhlIGVudGlyZSBjZWxsIGNvbnRlbnRcbiAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q3VycmVudENlbGxDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjb2RlXFxuJHtjZWxsQ29udGV4dC50ZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNlbGwgY29tbWFuZCAtIGluc2VydHMgZW50aXJlIGNlbGwgY29udGVudFxuICAgICAqL1xuICAgIGhhbmRsZUNlbGxDb21tYW5kKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q3VycmVudENlbGxDb250ZXh0KCk7XG4gICAgICAgIGlmIChjZWxsQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY2VsbFxcbiR7Y2VsbENvbnRleHQudGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRleHQgdG8gdGhlIGlucHV0IGZpZWxkIHdpdGggcHJvcGVyIHNwYWNpbmdcbiAgICAgKi9cbiAgICBhcHBlbmRUb0lucHV0KHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGV4aXN0aW5nIGNvbnRlbnQsIGFkZCBhIG5ld2xpbmUgYmVmb3JlIGFwcGVuZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IGAke2N1cnJlbnRWYWx1ZX1cXG5cXG4ke3RleHR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb2N1cyB0aGUgaW5wdXQgZmllbGQgYW5kIG1vdmUgY3Vyc29yIHRvIGVuZFxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5pbnB1dEZpZWxkLnZhbHVlLmxlbmd0aCwgdGhpcy5pbnB1dEZpZWxkLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBlbmRpbmcgdG8gaW5wdXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlbGVjdGVkIHRleHQgZnJvbSBjZWxsIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjZWxsIGZyb20gdGhlIHRyYWNrZXJcbiAgICAgICAgY29uc3QgY2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3Rpb24gZnJvbSBDb2RlTWlycm9yXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHNlbGVjdGlvbiwgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZiAoc2VsZWN0aW9uLm1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgY29uc3QgZnJvbSA9IHNlbGVjdGlvbi5tYWluLmZyb207XG4gICAgICAgIGNvbnN0IHRvID0gc2VsZWN0aW9uLm1haW4udG87XG4gICAgICAgIHJldHVybiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvLyBTZXR0aW5ncyBtb2RhbCBtZXRob2RzXG4gICAgY3JlYXRlU2V0dGluZ3NNb2RhbCgpIHtcbiAgICAgICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbW9kYWwuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBtb2RhbC5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIG1vZGFsLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIG1vZGFsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBtb2RhbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIG1vZGFsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgICAgIG1vZGFsLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcbiAgICAgICAgbW9kYWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC41KSc7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZic7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUucGFkZGluZyA9ICcyMHB4JztcbiAgICAgICAgY29udGVudC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNXB4JztcbiAgICAgICAgY29udGVudC5zdHlsZS53aWR0aCA9ICc0MDBweCc7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgdGl0bGUudGV4dENvbnRlbnQgPSAnU2V0dGluZ3MnO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHByb3ZpZGVyTGFiZWwuaHRtbEZvciA9ICdzZXR0aW5ncy1wcm92aWRlcic7XG4gICAgICAgIHByb3ZpZGVyTGFiZWwudGV4dENvbnRlbnQgPSAnTExNIFByb3ZpZGVyOic7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvdmlkZXJMYWJlbCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyU2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHByb3ZpZGVyU2VsZWN0LmlkID0gJ3NldHRpbmdzLXByb3ZpZGVyJztcbiAgICAgICAgWydPcGVuQUknLCAnSHVnZ2luZ0ZhY2UnLCAnTG9jYWwnXS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdDtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0Q29udGVudCA9IG9wdDtcbiAgICAgICAgICAgIHByb3ZpZGVyU2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHByb3ZpZGVyU2VsZWN0KTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgICAgY29uc3Qga2V5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBrZXlMYWJlbC5odG1sRm9yID0gJ3NldHRpbmdzLWFwaS1rZXknO1xuICAgICAgICBrZXlMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgS2V5Oic7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoa2V5TGFiZWwpO1xuICAgICAgICBjb25zdCBrZXlJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGtleUlucHV0LmlkID0gJ3NldHRpbmdzLWFwaS1rZXknO1xuICAgICAgICBrZXlJbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICBrZXlJbnB1dC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChrZXlJbnB1dCk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIGNvbnN0IHVybExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdXJsTGFiZWwuaHRtbEZvciA9ICdzZXR0aW5ncy1hcGktYmFzZS11cmwnO1xuICAgICAgICB1cmxMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgQmFzZSBVUkwgKG9wdGlvbmFsKTonO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHVybExhYmVsKTtcbiAgICAgICAgY29uc3QgdXJsSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB1cmxJbnB1dC5pZCA9ICdzZXR0aW5ncy1hcGktYmFzZS11cmwnO1xuICAgICAgICB1cmxJbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICB1cmxJbnB1dC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh1cmxJbnB1dCk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIGNvbnN0IHJ1bGVzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBydWxlc0xhYmVsLmh0bWxGb3IgPSAnc2V0dGluZ3MtcnVsZXMnO1xuICAgICAgICBydWxlc0xhYmVsLnRleHRDb250ZW50ID0gJ1J1bGVzOic7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocnVsZXNMYWJlbCk7XG4gICAgICAgIGNvbnN0IHJ1bGVzVGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICBydWxlc1RleHRhcmVhLmlkID0gJ3NldHRpbmdzLXJ1bGVzJztcbiAgICAgICAgcnVsZXNUZXh0YXJlYS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgcnVsZXNUZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHJ1bGVzVGV4dGFyZWEpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgICBjb25zdCBidG5Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYnRuQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGJ0bkNvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3AgPSAnMTBweCc7XG4gICAgICAgIGNvbnN0IHNhdmVCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgc2F2ZUJ0bi50ZXh0Q29udGVudCA9ICdTYXZlJztcbiAgICAgICAgc2F2ZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLXByb3ZpZGVyJykudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtYXBpLWtleScpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLWFwaS1iYXNlLXVybCcpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcnVsZXMnKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5ncyBzYXZlZDonLCB7IHByb3ZpZGVyLCBrZXksIHVybCwgcnVsZXMgfSk7XG4gICAgICAgICAgICB0aGlzLmhpZGVTZXR0aW5nc01vZGFsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY2FuY2VsQnRuLnRleHRDb250ZW50ID0gJ0NhbmNlbCc7XG4gICAgICAgIGNhbmNlbEJ0bi5zdHlsZS5tYXJnaW5MZWZ0ID0gJzEwcHgnO1xuICAgICAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhpZGVTZXR0aW5nc01vZGFsKCkpO1xuICAgICAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoc2F2ZUJ0bik7XG4gICAgICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW5jZWxCdG4pO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGJ0bkNvbnRhaW5lcik7XG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbW9kYWw7XG4gICAgfVxuICAgIHNob3dTZXR0aW5nc01vZGFsKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9XG4gICAgaGlkZVNldHRpbmdzTW9kYWwoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlU2lkZWJhcldpZGdldCA9IFNpbXBsZVNpZGViYXJXaWRnZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=