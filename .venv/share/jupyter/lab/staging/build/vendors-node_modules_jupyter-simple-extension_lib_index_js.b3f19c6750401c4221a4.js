"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components"); // Import LabIcon if needed as placeholder
// Placeholder icon (replace if you have a specific icon)
const extensionIcon = ui_components_1.LabIcon.resolve({ icon: 'ui-components:jupyterlab' }); // Use resolve for built-in
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/api-client.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/api-client.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/globals.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/globals.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/icons.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/icons.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryHandler = void 0;
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js"); // Assuming renderers are needed
/**
 * Manages the display and interaction logic for the chat history view.
 */
class HistoryHandler {
    constructor(chatState, uiManager, callbacks, rendererCallbacks) {
        this.isHistoryViewActive = false;
        this.chatState = chatState;
        this.uiManager = uiManager;
        this.callbacks = callbacks;
        this.rendererCallbacks = rendererCallbacks;
        // Get the history container element from UIManager
        this.historyContainer = this.uiManager.getUIElements().historyContainer;
    }
    /**
     * Toggles between the main chat view and the history view.
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Use UIManager to hide chat, show history
            this.uiManager.showHistoryView();
            this.renderChatHistory(); // Populate the history view
        }
        else {
            // Use UIManager to show chat, hide history
            this.uiManager.showChatView();
            // Ensure the correct title is displayed when switching back
            const currentChat = this.chatState.getCurrentChat();
            if (currentChat) {
                this.callbacks.updateTitleInput(currentChat.title);
            }
        }
    }
    /**
     * Renders the list of past chats in the history container.
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = ''; // Clear previous list
        const history = this.chatState.getChatHistory();
        const currentChatId = this.chatState.getCurrentChatId();
        if (history.length === 0) {
            this.historyContainer.innerHTML = '<div class="jp-llm-ext-history-empty">No chat history yet.</div>';
            return;
        }
        const list = document.createElement('ul');
        list.className = 'jp-llm-ext-history-list';
        history.forEach(chat => {
            const listItem = document.createElement('li');
            listItem.className = 'jp-llm-ext-history-item';
            if (chat.id === currentChatId) {
                listItem.classList.add('jp-llm-ext-active');
            }
            // Simple representation: Title
            // TODO: Add preview, timestamp, delete button etc.
            const titleDiv = document.createElement('div');
            titleDiv.className = 'jp-llm-ext-history-item-title';
            titleDiv.textContent = chat.title || 'Untitled Chat';
            listItem.appendChild(titleDiv);
            // Add click event to load the chat
            listItem.addEventListener('click', () => this.loadChat(chat.id));
            list.appendChild(listItem);
        });
        this.historyContainer.appendChild(list);
    }
    /**
     * Loads a specific chat session from history into the main view.
     */
    loadChat(chatId) {
        const chat = this.chatState.getChatById(chatId);
        if (!chat) {
            console.error(`Chat with ID ${chatId} not found.`);
            return;
        }
        // Set this chat as the active one in the state
        this.chatState.setCurrentChatId(chatId);
        // Update the main UI title input
        this.callbacks.updateTitleInput(chat.title);
        // Clear the current message display
        this.callbacks.clearMessageContainer();
        // Re-populate the message container with messages from the loaded chat
        // Use the renderer functions via callbacks
        chat.messages.forEach((msg) => {
            let messageElement;
            if (msg.sender === 'user') {
                messageElement = (0, message_renderer_1.renderUserMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);
            }
            else { // 'bot'
                messageElement = (0, message_renderer_1.renderBotMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);
            }
            // Add the rendered element to the message container via callback
            this.callbacks.addRenderedMessage(messageElement);
        });
        // Switch back to the chat view if we were in the history view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView(); // This will call uiManager.showChatView()
        }
        else {
            // If already in chat view, ensure scrolling is correct
            this.uiManager.scrollToBottom();
        }
        // Optional: Re-render history list to update the active item indicator
        // Only really needed if not switching views
        // if (!this.isHistoryViewActive) { this.renderChatHistory(); }
    }
}
exports.HistoryHandler = HistoryHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageHandler = void 0;
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js");
const notebook_integration_1 = __webpack_require__(/*! ../utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
/**
 * Handles sending messages, interacting with the API,
 * managing streaming responses, and updating the UI and state.
 */
class MessageHandler {
    constructor(apiClient, chatState, uiManager, rendererCallbacks, inputHandler) {
        this.apiClient = apiClient;
        this.chatState = chatState;
        this.uiManager = uiManager;
        this.rendererCallbacks = rendererCallbacks;
        this.inputHandler = inputHandler;
    }
    /**
     * Processes and sends a user-initiated message.
     * Also handles adding the user message to the UI and clearing the input.
     */
    handleSendMessage(message) {
        if (!message)
            return;
        // 1. Add user message to UI and state
        // TODO: Process message for code refs (e.g., replace placeholders)
        const processedMessage = message; // Placeholder for now
        const hasCodeRefs = false; // TODO: Determine this based on processing
        this.addMessage(processedMessage, 'user', hasCodeRefs, true);
        // 2. Clear the input field (using InputHandler)
        this.inputHandler.clearInput();
        // 3. Send message to backend and handle streaming response
        this.streamAndRenderResponse(processedMessage);
    }
    /**
     * Sends an automatic message (e.g., 'confirmed', 'rejected')
     * and handles the streaming response.
     */
    handleSendAutoMessage(message) {
        if (!message.trim())
            return;
        // Auto messages are typically not saved as user messages, 
        // but the response *is* saved.
        this.streamAndRenderResponse(message);
    }
    /**
     * Adds a message to the UI via UIManager and saves to ChatState.
     * (Helper method, potentially could live in UIManager or be part of its callback)
     */
    addMessage(text, sender, isMarkdown, saveToHistory) {
        // Note: This duplicates the logic from the old SimpleSidebarWidget.addMessage
        // It might be better to have UIManager expose a method to add a rendered message
        // and ChatState handle saving directly.
        // For now, keep it here for clarity of message flow.
        // TODO: Call actual render functions from message-renderer.ts when available
        // Instead of just adding a div directly.
        let messageElement;
        if (sender === 'user') {
            // Replace with renderUserMessage call
            messageElement = document.createElement('div');
            messageElement.className = 'jp-llm-ext-user-message'; // Example class
            messageElement.textContent = text; // Basic rendering for now
        }
        else {
            // renderBotMessage is used after streaming, this part might be redundant
            // or only needed if we add non-streaming bot messages.
            messageElement = document.createElement('div');
            messageElement.className = 'jp-llm-ext-bot-message'; // Example class
            messageElement.textContent = text; // Basic rendering for now
        }
        this.uiManager.addChatMessageElement(messageElement);
        if (saveToHistory) {
            const messageData = { text, sender, isMarkdown };
            this.chatState.addMessageToCurrentChat(messageData);
        }
    }
    /**
     * Core logic for sending a message to the API, handling the stream,
     * rendering the response, and saving the final bot message.
     */
    streamAndRenderResponse(messageToSend) {
        // --- Prepare streaming UI elements (managed by UIManager) ---
        // UIManager should provide a method to create/get these elements
        const { streamingDiv, contentDiv } = this.uiManager.createBotMessageContainer();
        let completeResponse = '';
        const cellContext = (0, notebook_integration_1.getCurrentCellContent)(); // Use utility
        // Stream response from API
        this.apiClient.streamChat(messageToSend, { cellContext }, 
        // On chunk received
        (chunk) => {
            completeResponse += chunk;
            // Update the temporary streaming div
            streamingDiv.textContent = completeResponse;
            this.uiManager.scrollToBottom();
        }, 
        // On complete
        () => {
            var _a;
            // Hide streaming div, show final content div
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Render the complete response using the renderer function
            const renderedContent = (0, message_renderer_1.renderBotMessage)(completeResponse, { isMarkdown: true }, this.rendererCallbacks);
            contentDiv.innerHTML = ''; // Clear placeholder/previous content
            // Append rendered nodes, skipping any potential wrapper/indicator added by renderBotMessage itself
            while (renderedContent.firstChild) {
                // Check if the node is the specific markdown indicator we might add/remove
                // Or just append everything if renderBotMessage returns the pure content
                if (!((_a = renderedContent.firstChild.classList) === null || _a === void 0 ? void 0 : _a.contains('markdown-indicator'))) {
                    contentDiv.appendChild(renderedContent.firstChild);
                }
                else {
                    // Remove the indicator if it was part of the returned fragment
                    renderedContent.removeChild(renderedContent.firstChild);
                }
            }
            // Save final bot response to history via ChatState
            const isImage = completeResponse.trim().startsWith('/images/'); // Simple check
            const botMessageData = {
                text: completeResponse,
                sender: 'bot',
                isMarkdown: !isImage // Save as markdown unless it's an image URL
            };
            this.chatState.addMessageToCurrentChat(botMessageData);
            this.uiManager.scrollToBottom();
        }, 
        // On error
        (error) => {
            // Hide streaming div, show final content div with error
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Use a dedicated error rendering style/component if available
            contentDiv.innerHTML = `<div class="jp-llm-ext-error-message">Error: ${error.message}</div>`;
            console.error('API Error:', error);
            this.uiManager.scrollToBottom();
        });
    }
}
exports.MessageHandler = MessageHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
/**
 * Manages the state and interactions of the multi-level popup menu.
 */
class PopupMenuManager {
    constructor(docManager, widgetNode, callbacks) {
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        this.currentNotebook = null;
        this.selectedMenuItemIndex = -1; // Track currently selected menu item
        this.isRenderingContent = false; // Flag to prevent recursive renders
        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders
        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];
        this.fileCache = new Map();
        this.docManager = docManager;
        this.widgetNode = widgetNode;
        this.callbacks = callbacks;
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        // Attach to the widget node instead of the body
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Create search input
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search...';
        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling
        // Use 'input' event instead of directly re-rendering on every keystroke
        this.searchInput.addEventListener('input', () => {
            // Only re-render if the search term has actually changed
            if (this.searchInput.value !== this.lastSearchTerm) {
                this.lastSearchTerm = this.searchInput.value;
                this.renderMenuContent();
            }
        });
        // Handle keydown in search input to stop propagation for navigation keys
        this.searchInput.addEventListener('keydown', (event) => {
            console.log(`POPUP Search KeyDown: Key='${event.key}'`);
            // IMPORTANT: Prevent these keys from being captured by the document handler
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);
                if (event.key === 'Escape') {
                    // Handle Escape directly here
                    this.hidePopupMenu();
                }
                else if (event.key === 'Enter') {
                    // Maybe select first item on Enter?
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        this.selectedMenuItemIndex = 0;
                        this.updateSelectionHighlight();
                        // Optionally activate the item:
                        // menuItems[0].click(); 
                    }
                }
                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    // Move to first/last menu item
                    // The blur() will be handled by main key handler
                }
                event.stopPropagation();
            }
            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys
            // This allows default behavior to work properly
        }, true); // Use capture phase
        document.addEventListener('click', this.handleDocumentClick.bind(this), true);
        // IMPORTANT: Use a separate bound function for the document keydown
        // so we can remove the exact same listener later
        this.boundHandleKeyDown = this.handleKeyDown.bind(this);
        document.addEventListener('keydown', this.boundHandleKeyDown, true);
        if (globals_1.globals.notebookTracker) {
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            globals_1.globals.notebookTracker.currentChanged.connect((sender, notebook) => {
                this.currentNotebook = notebook;
            });
        }
    }
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);
        // Remove using the exact same bound function
        document.removeEventListener('keydown', this.boundHandleKeyDown, true);
        // Remove from widgetNode if attached
        if (this.popupMenuContainer.parentNode === this.widgetNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
    handleDocumentClick(event) {
        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');
            if (atButton && atButton.contains(event.target)) {
                console.log('POPUP: Click was on the @ button, not hiding.');
                return;
            }
            console.log('POPUP: Click detected outside the menu.');
            this.hidePopupMenu();
        }
    }
    async showPopupMenu(x, y) {
        console.log(`POPUP: Showing menu at (${x}, ${y})`);
        // Store the initial anchor point for positioning
        this._anchorX = x;
        this._anchorY = y;
        if (this.popupMenuContainer.style.display === 'none') {
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
            this.searchInput.value = ''; // Clear search on show
            this.lastSearchTerm = ''; // Reset last search term
            await this.setCurrentDirectoryPath();
        }
        await this.renderMenuContent();
        // Ensure it's attached to the widget node if somehow detached
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Position the popup menu - handled in updatePopupPosition
        this.updatePopupPosition();
        // Focus the search input if we are in file/directory view, otherwise focus the first item
        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
            setTimeout(() => {
                // Focus after timeout to ensure DOM is ready
                this.searchInput.focus();
                console.log('POPUP: Focused search input');
            }, 50); // Slightly longer timeout
            this.selectedMenuItemIndex = -1; // Don't select an item if search is focused
        }
        else {
            // Reset and select the first menu item for top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 50);
        }
    }
    hidePopupMenu() {
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding menu.');
            this.popupMenuContainer.style.display = 'none';
            // No need to explicitly remove from widgetNode unless causing issues
            // If performance becomes an issue with many menus, consider removing/re-adding
            // if (this.popupMenuContainer.parentNode === this.widgetNode) {
            //     this.widgetNode.removeChild(this.popupMenuContainer);
            // }
        }
    }
    async renderMenuContent() {
        // Prevent recursive renders
        if (this.isRenderingContent) {
            console.log('POPUP: Skipping render - already rendering');
            return;
        }
        this.isRenderingContent = true;
        try {
            // Clear existing content
            while (this.popupMenuContainer.firstChild) {
                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);
            }
            // If not at top level, add a search input for filtering items
            if (this.currentMenuLevel !== 'top') {
                // Add search input at the top of the menu
                this.popupMenuContainer.appendChild(this.searchInput);
                // Path display and back button removed for cleaner UI
            }
            // Render different menu content based on current level
            switch (this.currentMenuLevel) {
                case 'top':
                    this.renderTopLevelItems();
                    break;
                case 'files':
                case 'directories':
                    await this.renderDirectoryBrowserItems();
                    break;
                case 'cells':
                    await this.renderCellItems();
                    break;
            }
            // Reset selection after rendering
            this.selectedMenuItemIndex = -1;
            this.updateSelectionHighlight();
            // Update the position to maintain the fixed bottom edge
            if (this.popupMenuContainer.style.display !== 'none' && this._anchorX !== undefined && this._anchorY !== undefined) {
                this.updatePopupPosition();
            }
        }
        catch (error) {
            console.error('POPUP: Error rendering menu content', error);
        }
        finally {
            this.isRenderingContent = false;
        }
    }
    renderTopLevelItems() {
        const topLevelCommands = [
            { label: 'Code', description: '', actionId: 'insert-code' },
            { label: 'Cells', description: '', actionId: 'browse-cells' },
            { label: 'File', description: '', actionId: 'browse-files' },
            { label: 'Directory', description: '', actionId: 'browse-directories' }
        ];
        topLevelCommands.forEach(cmd => {
            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);
            this.popupMenuContainer.appendChild(item);
        });
    }
    async renderDirectoryBrowserItems() {
        var _a;
        // Get search term
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        // Temporarily add loading item below search/path
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // If contents were already fetched recently and we're just filtering again,
            // we could potentially cache the results to avoid unnecessary API calls
            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';
            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);
            // Check if still in DOM before trying to remove
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (contents && contents.length > 0) {
                // Filter based on search term
                const filteredContents = contents.filter(item => {
                    return item.name.toLowerCase().includes(searchTerm) ||
                        item.relativePath.toLowerCase().includes(searchTerm);
                });
                if (filteredContents.length > 0) {
                    filteredContents.forEach(item => {
                        const itemName = item.name;
                        const itemType = item.type;
                        const itemPath = item.path;
                        const relativePath = item.relativePath;
                        const icon = itemType === 'directory' ? 'üìÅ' : 'üìÑ';
                        let actionId;
                        if (itemType === 'directory') {
                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';
                        }
                        else { // itemType === 'file'
                            actionId = 'select-file';
                        }
                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                }
                else {
                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');
                    emptyItem.style.pointerEvents = 'none';
                    this.popupMenuContainer.appendChild(emptyItem);
                }
            }
            else {
                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
            }
        }
        catch (error) {
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading/filtering directory contents:', error);
        }
    }
    /**
     * Renders all cells from the current notebook
     */
    async renderCellItems() {
        var _a, _b;
        // Get search term for filtering
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        // Create a loading indicator
        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // Check if we have an active notebook
            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {
                // Remove loading item
                if (this.popupMenuContainer.contains(loadingItem)) {
                    this.popupMenuContainer.removeChild(loadingItem);
                }
                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');
                errorItem.style.color = 'red';
                errorItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(errorItem);
                return;
            }
            const notebookModel = this.currentNotebook.content.model;
            const cells = notebookModel.cells;
            // Remove loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (!cells || cells.length === 0) {
                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
                return;
            }
            // Process and display each cell
            let filteredCellCount = 0;
            for (let i = 0; i < cells.length; i++) {
                const cell = cells.get(i);
                const cellType = cell.type;
                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :
                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');
                // Use type casting to avoid TypeScript errors
                const executionCount = cellType === 'code' ?
                    (cell.executionCount !== undefined && cell.executionCount !== null ?
                        cell.executionCount : '*') :
                    '';
                // Create a preview of the cell content (truncate if needed)
                const contentPreview = typeof cellContent === 'string' ?
                    cellContent :
                    (Array.isArray(cellContent) ? cellContent.join('\n') : '');
                const firstLine = contentPreview.split('\n')[0] || '';
                const truncatedContent = firstLine.length > 30 ?
                    firstLine.substring(0, 30) + '...' :
                    firstLine;
                // Create cell label with styled type indicator
                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';
                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';
                // Create menu item for this cell
                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML
                'select-cell', i.toString() // Store cell index in path
                );
                // Create styled content with HTML elements
                const typeSpan = document.createElement('span');
                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;
                typeSpan.textContent = typeIndicator;
                const execSpan = document.createElement('span');
                execSpan.className = 'cell-exec-count';
                execSpan.textContent = executionDisplay;
                execSpan.style.marginRight = '8px';
                const contentSpan = document.createElement('span');
                contentSpan.className = 'cell-content-preview';
                contentSpan.textContent = truncatedContent;
                // Get the label span (first child of the menu item)
                const labelSpan = cellItem.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = ''; // Clear existing text
                    labelSpan.appendChild(typeSpan);
                    if (executionDisplay) {
                        labelSpan.appendChild(execSpan);
                    }
                    labelSpan.appendChild(contentSpan);
                }
                // Construct full searchable text
                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();
                // Filter by search term if one is provided
                if (searchTerm && !searchableText.includes(searchTerm)) {
                    continue;
                }
                this.popupMenuContainer.appendChild(cellItem);
                filteredCellCount++;
            }
            if (filteredCellCount === 0) {
                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');
                noMatchItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(noMatchItem);
            }
        }
        catch (error) {
            // Clean up loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading notebook cells:', error);
        }
    }
    createMenuItem(text, actionId, path = '', description = '') {
        const item = document.createElement('div');
        item.className = 'jp-llm-ext-popup-menu-item';
        item.dataset.actionId = actionId;
        if (path) {
            item.dataset.path = path;
        }
        item.onclick = (event) => this.handleMenuClick(event);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = text;
        item.appendChild(labelSpan);
        if (description) {
            const pathSpan = document.createElement('span');
            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';
            pathSpan.textContent = description;
            pathSpan.style.fontSize = '0.85em';
            pathSpan.style.color = 'var(--jp-ui-font-color2)';
            pathSpan.style.marginLeft = '8px';
            pathSpan.style.opacity = '0.8';
            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed
            item.appendChild(pathSpan);
        }
        return item;
    }
    async handleMenuClick(event) {
        var _a;
        const target = event.currentTarget;
        const actionId = target.dataset.actionId;
        const path = target.dataset.path || '';
        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);
        switch (actionId) {
            case 'navigate-back':
                this.navigateBackMenu();
                break;
            case 'insert-code': {
                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;
                if (selectedText) {
                    // Show submenu for code insertion options
                    const submenuItems = [
                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },
                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }
                    ];
                    // Replace current menu with submenu options
                    this.popupMenuContainer.innerHTML = '';
                    submenuItems.forEach(item => {
                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                    // Add back button
                    const backButton = this.createMenuItem('Back', 'navigate-back');
                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';
                    this.popupMenuContainer.appendChild(backButton);
                    return; // Don't hide menu, wait for submenu selection
                }
                else {
                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                    if (cellContent) {
                        this.callbacks.insertCode(cellContent);
                    }
                }
                this.hidePopupMenu();
                break;
            }
            case 'insert-plain-code': {
                if (path) {
                    this.callbacks.insertCode(path);
                    this.hidePopupMenu();
                }
                break;
            }
            case 'collapse-code-ref': {
                if (path && this.currentNotebook) {
                    try {
                        // Get notebook file name (without extension)
                        const notebookPath = this.currentNotebook.context.path;
                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';
                        // Find current cell index and approximate line number
                        const currentCell = this.currentNotebook.content.activeCell;
                        if (!currentCell) {
                            throw new Error('No active cell found');
                        }
                        // Get current cell index
                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;
                        // Estimate line number from cursor position
                        let lineNumber = 1; // Default to line 1
                        if (currentCell.editor) {
                            const editor = currentCell.editor;
                            const cursor = editor.getCursorPosition();
                            if (cursor) {
                                lineNumber = cursor.line + 1; // Convert to 1-indexed
                            }
                        }
                        // Invoke the callback with all the information needed
                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);
                        this.hidePopupMenu();
                    }
                    catch (error) {
                        console.error('Error creating collapsed code reference:', error);
                        // Fallback to inserting code directly
                        this.callbacks.insertCode(path);
                        this.hidePopupMenu();
                    }
                }
                else {
                    // If something went wrong or no path provided, just insert as regular code
                    if (path) {
                        this.callbacks.insertCode(path);
                    }
                    this.hidePopupMenu();
                }
                break;
            }
            case 'browse-cells':
                await this.navigateMenu('cells', '');
                this.searchInput.value = '';
                break;
            case 'browse-files':
                await this.navigateMenu('files', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'browse-directories':
                await this.navigateMenu('directories', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'select-cell':
                if (path) {
                    const cellIndex = parseInt(path);
                    if (!isNaN(cellIndex) && this.callbacks.insertCellByIndex) {
                        this.callbacks.insertCellByIndex(cellIndex);
                        this.hidePopupMenu();
                    }
                    else {
                        console.error('POPUP: Invalid cell index or callback missing.');
                    }
                }
                break;
            case 'select-file':
                if (path) {
                    this.callbacks.insertFilePath(path);
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: File selected but path is missing.');
                }
                break;
            case 'select-directory-navigate': // New action to navigate into dir when in file view
                if (path) {
                    // Clear the file cache for the specific directory to force a refresh
                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;
                    this.fileCache.delete(cacheKey);
                    // Make sure we're passing the correct level type
                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?
                        this.currentMenuLevel : 'files';
                    await this.navigateMenu(level, path);
                    this.searchInput.value = ''; // Clear search on navigation
                }
                else {
                    console.error('POPUP: Directory selected for navigation but path is missing.');
                }
                break;
            case 'select-directory-callback': // New action to select dir when in directory view
                if (path) {
                    this.callbacks.insertDirectoryPath(path); // Use the callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected for callback but path is missing.');
                }
                break;
            case 'placeholder-action':
                console.log('Placeholder action triggered.');
                this.hidePopupMenu();
                break;
            case 'loading':
            case 'empty':
            case 'error':
                break;
            default:
                console.warn('Unknown menu action:', actionId);
                this.hidePopupMenu();
                break;
        }
        event.stopPropagation();
    }
    async navigateMenu(level, path) {
        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);
        // Only push history if we are actually moving to a new state
        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {
            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
        }
        this.currentMenuLevel = level;
        this.currentMenuPath = path;
        // Don't clear search on programmatic navigation (like back button)
        // this.searchInput.value = ''; // Maybe keep search term?
        await this.renderMenuContent();
        // Focus search input after navigating to file/dir view
        if (level === 'files' || level === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0);
            this.selectedMenuItemIndex = -1; // Reset selection
        }
        else {
            // Select first item if navigating back to top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 0);
        }
    }
    navigateBackMenu() {
        const previousState = this.menuHistory.pop();
        if (previousState) {
            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);
            this.currentMenuLevel = previousState.level;
            this.currentMenuPath = previousState.path;
            // Don't clear search on back navigation
            this.renderMenuContent().then(() => {
                // Focus search input if going back to file/dir view
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    setTimeout(() => this.searchInput.focus(), 0);
                    this.selectedMenuItemIndex = -1; // Reset selection
                }
                else {
                    // Select first item if going back to top level
                    this.selectedMenuItemIndex = -1;
                    setTimeout(() => this.selectNextMenuItem(), 0);
                }
            });
        }
        else {
            console.log('POPUP: Already at the top level.');
            this.hidePopupMenu();
        }
    }
    async listCurrentDirectoryContents(basePath, filterType) {
        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);
        // Check cache first
        const cacheKey = `${basePath}:${filterType || 'all'}`;
        if (this.fileCache.has(cacheKey)) {
            console.log('POPUP: Using cached directory contents');
            return this.fileCache.get(cacheKey) || null;
        }
        try {
            const effectivePath = basePath === '/' ? '' : basePath;
            // Ensure trailing slash removed for consistency unless it's root
            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;
            // Result array that will hold all files and directories
            let allResults = [];
            // Get the base directory contents (non-recursive)
            const baseContents = await this.docManager.services.contents.get(pathForApi || '');
            if (baseContents.type !== 'directory') {
                console.error('Path is not a directory:', basePath);
                return null;
            }
            // Process base directory items
            for (const item of baseContents.content) {
                const itemType = item.type === 'directory' ? 'directory' : 'file';
                // Add directories if we're listing directories or both
                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {
                    allResults.push({
                        name: item.name,
                        path: item.path,
                        type: 'directory',
                        relativePath: `./${item.name}`
                    });
                }
                // Add files if we're listing files and the extension is allowed
                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {
                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();
                    if (this.allowedExtensions.includes(fileExt)) {
                        allResults.push({
                            name: item.name,
                            path: item.path,
                            type: 'file',
                            relativePath: `./${item.name}`
                        });
                    }
                }
            }
            // Sort the results appropriately
            allResults = allResults.sort((a, b) => {
                // If listing directories only, sort alphabetically
                if (filterType === 'directory') {
                    return a.name.localeCompare(b.name);
                }
                // If listing files only, sort alphabetically
                if (filterType === 'file') {
                    return a.name.localeCompare(b.name);
                }
                // If listing both, sort directories first, then files alphabetically
                if (a.type === 'directory' && b.type !== 'directory')
                    return -1;
                if (a.type !== 'directory' && b.type === 'directory')
                    return 1;
                return a.name.localeCompare(b.name);
            });
            // Cache the results for future use
            this.fileCache.set(cacheKey, allResults);
            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);
            return allResults;
        }
        catch (error) {
            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);
            return null;
        }
    }
    async setCurrentDirectoryPath() {
        var _a;
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            this.currentMenuPath = '';
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                dirPath = this.getParentDirectory(path);
                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);
            }
        }
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            if (typeof notebookPath === 'string') {
                dirPath = this.getParentDirectory(notebookPath);
                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);
            }
        }
        if (dirPath === null) {
            try {
                const leftWidgets = Array.from(app.shell.widgets('left'));
                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
                if (fileBrowserWidget && typeof ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path) === 'string') {
                    dirPath = fileBrowserWidget.model.path;
                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);
                }
                else {
                    console.log('POPUP: File browser widget path not directly accessible.');
                }
            }
            catch (e) {
                console.warn('POPUP: Could not get path from file browser.', e);
            }
        }
        if (dirPath === null) {
            dirPath = '';
            console.log('POPUP: Falling back to server root path.');
        }
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);
    }
    getParentDirectory(path) {
        if (!path)
            return '';
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));
        if (lastSlash === -1)
            return ''; // No directory part, likely root or just a filename
        return path.substring(0, lastSlash);
    }
    /**
     * Handle keyboard navigation when the popup menu is shown
     */
    handleKeyDown(event) {
        var _a;
        // Skip if menu not visible
        if (this.popupMenuContainer.style.display === 'none') {
            return;
        }
        console.log(`POPUP KeyDown: Key='${event.key}', Target='${(_a = event.target) === null || _a === void 0 ? void 0 : _a.tagName}', SearchFocused='${document.activeElement === this.searchInput}'`);
        // Special handling for when search input is focused
        if (document.activeElement === this.searchInput) {
            // The input's own keydown handler will handle most keys
            // But for certain keys like arrow keys, we may need to move focus
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                // Move selection to first/last item
                event.preventDefault();
                event.stopPropagation();
                // Delay before moving focus - this gives time for the search input's
                // own keydown handler to process the key first
                setTimeout(() => {
                    if (event.key === 'ArrowDown') {
                        this.searchInput.blur();
                        this.selectNextMenuItem();
                    }
                    else { // ArrowUp
                        this.searchInput.blur();
                        this.selectPreviousMenuItem();
                    }
                }, 0);
                return;
            }
            // IMPORTANT: For Backspace in search input, just return without handling
            // Let the default behavior happen
            if (event.key === 'Backspace') {
                // Just perform default behavior in search input
                return;
            }
            // Let all other keys be handled by the search input's own handler
            return;
        }
        // From here, search input is NOT focused
        const menuItems = this.getMenuItems();
        switch (event.key) {
            case 'ArrowDown':
                if (menuItems.length > 0) {
                    console.log('POPUP KeyDown (Menu Focused): ArrowDown');
                    event.preventDefault();
                    event.stopPropagation();
                    this.selectNextMenuItem();
                }
                break;
            case 'ArrowUp':
                if (menuItems.length > 0) {
                    console.log('POPUP KeyDown (Menu Focused): ArrowUp');
                    event.preventDefault();
                    event.stopPropagation();
                    this.selectPreviousMenuItem();
                }
                break;
            case 'Backspace':
                console.log('POPUP KeyDown (Menu Focused): Backspace');
                // Only prevent default and navigate back if we have history
                if (this.menuHistory.length > 0) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.navigateBackMenu();
                }
                else {
                    console.log('POPUP KeyDown (Menu Focused): No history, allowing Backspace default action');
                    // Allow default - don't prevent or stop propagation
                }
                break;
            case 'Enter':
                console.log('POPUP KeyDown (Menu Focused): Enter');
                // Only activate if an item is selected
                if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {
                    event.preventDefault();
                    event.stopPropagation();
                    menuItems[this.selectedMenuItemIndex].click();
                }
                break;
            case 'Tab':
                console.log('POPUP KeyDown (Menu Focused): Tab');
                // Basic Tab support: move focus between search and first/last item
                event.preventDefault();
                event.stopPropagation();
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    this.searchInput.focus();
                    this.deselectAllMenuItems(); // Deselect items when search gets focus via Tab
                }
                else {
                    // Maybe close menu on Tab from top level? Or do nothing.
                    this.hidePopupMenu();
                }
                break;
            case 'Escape':
                console.log('POPUP KeyDown (Menu Focused): Escape');
                event.preventDefault();
                event.stopPropagation();
                this.hidePopupMenu();
                break;
            default:
                console.log(`POPUP KeyDown (Menu Focused): Default key '${event.key}'`);
                // If typing a character and in file/dir view, focus search
                if ((this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') &&
                    event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault(); // Prevent character appearing elsewhere
                    event.stopPropagation();
                    this.searchInput.focus();
                    // Manually append the typed character as focus happens after keydown default action
                    this.searchInput.value += event.key;
                    // Trigger input event manually to update list
                    this.searchInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
                // Allow other keys (e.g., modifiers) to pass through if not handled
                break;
        }
    }
    updateSelectionHighlight() {
        const menuItems = this.getMenuItems();
        console.log(`POPUP updateSelectionHighlight: Highlighting index ${this.selectedMenuItemIndex} among ${menuItems.length} items.`);
        menuItems.forEach((item, index) => {
            if (index === this.selectedMenuItemIndex) {
                if (!item.classList.contains('selected')) {
                    item.classList.add('selected');
                    console.log(`POPUP updateSelectionHighlight: Added 'selected' to item ${index}`);
                    // Ensure item is visible
                    item.scrollIntoView({ block: 'nearest' });
                }
            }
            else {
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    console.log(`POPUP updateSelectionHighlight: Removed 'selected' from item ${index}`);
                }
            }
        });
    }
    deselectAllMenuItems() {
        const menuItems = this.getMenuItems();
        menuItems.forEach(item => item.classList.remove('selected'));
        this.selectedMenuItemIndex = -1;
    }
    selectNextMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectNext: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the next item or loop back to the first
        this.selectedMenuItemIndex = (this.selectedMenuItemIndex + 1) % menuItems.length;
        console.log(`POPUP selectNext: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    selectPreviousMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectPrevious: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the previous item or loop to the last
        this.selectedMenuItemIndex = this.selectedMenuItemIndex <= 0 ?
            menuItems.length - 1 : this.selectedMenuItemIndex - 1;
        console.log(`POPUP selectPrevious: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    /**
     * Get all interactive menu items
     */
    getMenuItems() {
        const items = Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));
        // Filter out non-interactive items like loading, empty, error
        return items.filter(item => {
            const actionId = item.dataset.actionId;
            return actionId !== 'loading' && actionId !== 'empty' && actionId !== 'error';
        });
    }
    /**
     * Update popup position, keeping the bottom edge fixed at the anchor point
     */
    updatePopupPosition() {
        var _a, _b;
        // Make sure anchor points are defined
        const anchorX = (_a = this._anchorX) !== null && _a !== void 0 ? _a : 0;
        const anchorY = (_b = this._anchorY) !== null && _b !== void 0 ? _b : 0;
        // Position the popup menu
        this.popupMenuContainer.style.position = 'absolute';
        this.popupMenuContainer.style.left = `${anchorX}px`;
        // Show the menu so we can calculate its height
        this.popupMenuContainer.style.display = 'block';
        // Get the actual height after rendering
        const menuHeight = this.popupMenuContainer.offsetHeight;
        // Add a small gap (10px) between the bottom of the menu and the trigger point
        const gap = 10;
        // Position above the cursor/button to keep bottom edge at the anchor point:
        // y - gap = bottom edge of popup, so popup top = y - gap - menuHeight
        this.popupMenuContainer.style.top = `${anchorY - gap - menuHeight}px`;
        console.log(`POPUP: Positioned menu at height ${menuHeight}px with bottom at ${anchorY - gap}px`);
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsHandler = void 0;
// import { SettingsModal } from '../ui/settings-modal'; // Commented out - unused import
/**
 * Handles the logic related to the settings modal:
 * displaying, hiding, populating, saving, and showing feedback.
 */
class SettingsHandler {
    constructor(state, 
    // successCallback: (message: string) => void, // Commented out - unused parameter
    settingsModalContainer, uiManager // Pass UIManager for notifications
    ) {
        this.state = state;
        // this.apiClient = apiClient; // Removed: unused variable
        // this.successCallback = successCallback; // Commented out - unused assignment
        this.settingsModalContainer = settingsModalContainer;
        this.uiManager = uiManager;
        // Attach internal listeners if the modal has its own save/cancel buttons
        // This assumes the modal element was created with listeners calling these methods.
        // If createSettingsModalElement in ui/settings-modal.ts attaches listeners that 
        // call callbacks passed during creation, then this handler doesn't need 
        // to attach listeners directly, just provide the callbacks (e.g., this.saveSettings.bind(this)).
        // For now, let's assume the callbacks passed to createSettingsModalElement handle this.
    }
    /**
     * Populates the settings form with current values and displays the modal.
     */
    showModal() {
        const currentSettings = this.state.getSettings();
        if (currentSettings) {
            try {
                // Query elements within the modal container
                this.settingsModalContainer.querySelector('#settings-provider').value = currentSettings.provider;
                this.settingsModalContainer.querySelector('#settings-api-key').value = currentSettings.apiKey;
                this.settingsModalContainer.querySelector('#settings-api-url').value = currentSettings.apiUrl;
                this.settingsModalContainer.querySelector('#settings-rules').value = currentSettings.rules;
            }
            catch (error) {
                console.error('Error populating settings form:', error);
                // Optionally show an error to the user
            }
        }
        this.settingsModalContainer.style.display = 'flex';
    }
    /**
     * Hides the settings modal.
     */
    hideModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    /**
     * Reads values from the form, saves them using SettingsState,
     * updates the ApiClient, hides the modal, and shows a success notification.
     * This method is intended to be called by the modal's save button listener.
     */
    saveSettings() {
        var _a, _b, _c, _d;
        // Get values from form fields within the modal container
        const provider = (_a = this.settingsModalContainer.querySelector('#settings-provider')) === null || _a === void 0 ? void 0 : _a.value;
        const key = (_b = this.settingsModalContainer.querySelector('#settings-api-key')) === null || _b === void 0 ? void 0 : _b.value;
        const url = (_c = this.settingsModalContainer.querySelector('#settings-api-url')) === null || _c === void 0 ? void 0 : _c.value;
        const rules = (_d = this.settingsModalContainer.querySelector('#settings-rules')) === null || _d === void 0 ? void 0 : _d.value;
        // Basic validation
        if (provider === undefined || key === undefined || url === undefined || rules === undefined) {
            console.error("Could not find all settings input elements.");
            this.showNotification('Error: Could not save settings. Input elements missing.', 'error');
            return;
        }
        const settings = { provider, apiKey: key, apiUrl: url, rules };
        try {
            // Save settings using SettingsState
            this.state.saveSettings(settings);
            console.log('Settings saved via SettingsState:', settings);
            // Reconfigure ApiClient instance
            // TODO: The ApiClient should ideally observe the SettingsState 
            // or have a dedicated update method instead of creating a new instance.
            // For now, we assume the main widget will recreate/update the ApiClient 
            // or pass an update callback.
            // Example: this.apiClient.updateConfig(settings.apiUrl || undefined);
            console.log('API Client needs reconfiguration with new settings.');
            this.hideModal();
            this.showNotification('Settings saved successfully', 'success');
        }
        catch (error) {
            console.error('Error saving settings:', error);
            this.showNotification(`Error saving settings: ${error}`, 'error');
        }
    }
    /**
     * Displays a temporary notification message.
     * Relies on UIManager to provide the actual notification mechanism.
     */
    showNotification(message, type) {
        // Delegate notification display to UIManager or a dedicated notification service
        if (this.uiManager && typeof this.uiManager.showNotification === 'function') {
            this.uiManager.showNotification(message, type);
        }
        else {
            // Fallback or log if UIManager doesn't support notifications yet
            console.log(`Notification (${type}): ${message}`);
            // The old popSaveSuccess logic requires direct access to the widget node,
            // which this handler shouldn't have. This needs to be handled by the UI layer.
        }
    }
}
exports.SettingsHandler = SettingsHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupShortcuts = setupShortcuts;
exports.removeShortcuts = removeShortcuts;
const notebook_integration_1 = __webpack_require__(/*! ../utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
let _handleKeyDown = null;
/**
 * Sets up global keyboard shortcuts for the extension.
 *
 * @param inputHandler Instance of InputHandler to interact with input state/methods.
 * @param popupMenuManager Instance of PopupMenuManager.
 * @param callbacks Object containing callback functions for UI interactions.
 */
function setupShortcuts(inputHandler, // Pass InputHandler instance directly
popupMenuManager, callbacks) {
    if (_handleKeyDown) {
        console.warn('Shortcuts already set up. Removing previous listener.');
        removeShortcuts();
    }
    _handleKeyDown = (event) => {
        const { showIndicator, appendToInput, showWidget, focusInput } = callbacks;
        // Check for @ key
        if (event.key === '@') {
            // Prevent default browser behavior
            event.preventDefault();
            event.stopPropagation();
            // Check if the input field is the active element
            // We rely on InputHandler potentially managing focus or assume it is handled elsewhere
            const inputField = document.activeElement; // A bit fragile
            if (inputField && inputField.tagName === 'TEXTAREA' && inputField.classList.contains('jp-llm-ext-input-field')) {
                // Get cursor position
                const cursorPosition = inputField.selectionStart || 0;
                const textBeforeCursor = inputField.value.substring(0, cursorPosition);
                // Calculate position to show menu (simplified example)
                const inputRect = inputField.getBoundingClientRect();
                const lineHeight = parseInt(window.getComputedStyle(inputField).lineHeight) || 20;
                const linesBeforeCursor = (textBeforeCursor.match(/\n/g) || []).length;
                const cursorTop = inputRect.top + (linesBeforeCursor * lineHeight);
                const left = inputRect.left + 10; // Simplified horizontal position
                // Insert @ symbol at cursor position
                const newValue = inputField.value.substring(0, cursorPosition) +
                    '@' +
                    inputField.value.substring(cursorPosition);
                inputField.value = newValue;
                // Update has @ symbol flag via InputHandler
                inputHandler.setHasAtSymbol(true);
                // Move cursor after the @ symbol
                inputField.selectionStart = cursorPosition + 1;
                inputField.selectionEnd = cursorPosition + 1;
                // Show the popup menu
                popupMenuManager.showPopupMenu(left + 60, cursorTop - 20); // Adjust positioning as needed
                showIndicator('Browse cells, code, files, and more');
            }
        }
        // Check for Ctrl+L (insert selection or cell)
        else if (event.ctrlKey && event.key.toLowerCase() === 'l') {
            event.preventDefault();
            event.stopPropagation();
            const selected = (0, notebook_integration_1.getSelectedText)();
            if (selected) {
                appendToInput(`@code ${selected}`); // Use callback
                showIndicator('Selected code inserted');
            }
            else {
                const cellContent = (0, notebook_integration_1.getCurrentCellContent)();
                if (cellContent) {
                    appendToInput(`@cell ${cellContent}`); // Use callback
                    showIndicator('Cell content inserted');
                }
            }
            // Ensure the sidebar is visible and input is focused
            showWidget(); // Use callback
            focusInput(); // Use callback
        }
    };
    // Add the event listener to the document
    document.addEventListener('keydown', _handleKeyDown);
}
/**
 * Removes the global keyboard shortcut listener.
 */
function removeShortcuts() {
    if (_handleKeyDown) {
        document.removeEventListener('keydown', _handleKeyDown);
        _handleKeyDown = null;
        console.log('Removed keyboard shortcuts.');
    }
    else {
        console.warn('Attempted to remove shortcuts, but none were active.');
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Import the main CSS file
__webpack_require__(/*! ../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./core/api-client */ "./node_modules/jupyter-simple-extension/lib/core/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const icons_1 = __webpack_require__(/*! ./core/icons */ "./node_modules/jupyter-simple-extension/lib/core/icons.js");
const api_client_1 = __webpack_require__(/*! ./core/api-client */ "./node_modules/jupyter-simple-extension/lib/core/api-client.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./handlers/popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js");
const shortcut_handler_1 = __webpack_require__(/*! ./handlers/shortcut-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js");
const layout_builder_1 = __webpack_require__(/*! ./ui/layout-builder */ "./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js");
const settings_modal_1 = __webpack_require__(/*! ./ui/settings-modal */ "./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js");
const chat_state_1 = __webpack_require__(/*! ./state/chat-state */ "./node_modules/jupyter-simple-extension/lib/state/chat-state.js");
const settings_state_1 = __webpack_require__(/*! ./state/settings-state */ "./node_modules/jupyter-simple-extension/lib/state/settings-state.js");
const message_handler_1 = __webpack_require__(/*! ./handlers/message-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js");
const history_handler_1 = __webpack_require__(/*! ./handlers/history-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js");
const settings_handler_1 = __webpack_require__(/*! ./handlers/settings-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js");
const ui_manager_1 = __webpack_require__(/*! ./ui/ui-manager */ "./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js");
// --- Import Utility Functions ---
const clipboard_1 = __webpack_require__(/*! ./utils/clipboard */ "./node_modules/jupyter-simple-extension/lib/utils/clipboard.js");
const notebook_integration_1 = __webpack_require__(/*! ./utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
// Import the new UI helper
const code_ref_widget_1 = __webpack_require__(/*! ./ui/code-ref-widget */ "./node_modules/jupyter-simple-extension/lib/ui/code-ref-widget.js");
/**
 * Main sidebar widget for the AI chat interface - Now acts as an orchestrator.
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    constructor(docManager) {
        super();
        // Placeholder for menu callbacks
        this.menuActionCallbacks = {
            insertCode: (code) => this.inputHandler.appendToInput(`\n\`\`\`\n${code}\n\`\`\`\n`),
            insertCell: (content) => { },
            insertFilePath: (path) => this.inputHandler.appendToInput(` ${path}`),
            insertDirectoryPath: (path) => this.inputHandler.appendToInput(` ${path}`),
            getSelectedText: () => { /* TODO: Implement get selected text */ return null; },
            getCurrentCellContent: () => { /* TODO: Implement get current cell */ return null; },
            insertCellByIndex: (index) => { },
            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {
                const refId = this.inputHandler.addCodeReference(code);
                this.inputHandler.appendToInput(` [${refId}:${notebookName} cell ${cellIndex + 1} line ${lineNumber}]`);
            }
        };
        // Placeholder for handler methods used in UIManager callbacks
        this.handleNewChat = () => {
            var _a;
            console.log('Handle New Chat clicked');
            const newChat = this.chatState.createNewChat();
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);
        };
        this.handleToggleHistory = () => {
            console.log('Handle Toggle History clicked');
            this.historyHandler.toggleHistoryView();
        };
        this.handleSendMessage = () => {
            console.log('Handle Send Message called from UI Manager callback');
            // Trigger the InputHandler's internal logic which then calls MessageHandler
            // This feels slightly redundant - maybe InputHandler should trigger send directly?
            // Or maybe this callback shouldn't exist and UIManager calls InputHandler directly?
            // For now, simulate Enter press logic:
            const inputElement = this.layoutElements.inputField; // Get from layoutElements
            const event = new KeyboardEvent('keypress', { key: 'Enter', bubbles: true });
            inputElement.dispatchEvent(event);
        };
        this.handleShowSettings = (event) => {
            console.log('Handle Show Settings clicked');
            this.settingsHandler.showModal();
        };
        this.handleShowPopupMenu = (event, targetButton) => {
            console.log('Handle Show Popup Menu clicked');
            // Calculate position relative to the button
            const rect = targetButton.getBoundingClientRect();
            // Position below the button
            this.popupMenuManager.showPopupMenu(rect.left, rect.bottom + 5);
        };
        this.handleUpdateTitle = () => {
            var _a;
            const newTitle = ((_a = this.layoutElements.titleInput) === null || _a === void 0 ? void 0 : _a.value) || 'Chat';
            console.log('Handle Update Title called:', newTitle);
            this.chatState.updateCurrentChatTitle(newTitle);
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        this.addClass('jp-llm-ext-sidebar');
        // --- 1. Initialize Core Components & State ---
        this.settingsState = new settings_state_1.SettingsState();
        const initialSettings = this.settingsState.getSettings();
        this.apiClient = new api_client_1.ApiClient((initialSettings === null || initialSettings === void 0 ? void 0 : initialSettings.apiUrl) || undefined);
        this.chatState = new chat_state_1.ChatState();
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {
            insertCode: (code) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@code ${code}`); },
            insertCell: (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@cell ${content}`); },
            insertFilePath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@file ${path}`); },
            insertDirectoryPath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@directory ${path}`); },
            getSelectedText: notebook_integration_1.getSelectedText, // Use the imported utility function
            getCurrentCellContent: notebook_integration_1.getCurrentCellContent, // Use the imported utility function
            // Use the imported utility, providing the callback to append to the input handler
            insertCellByIndex: (index) => (0, notebook_integration_1.insertCellContentByIndex)(index, (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@${content}`); }),
            // Implement the callback for collapsed code references
            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {
                if (!this.inputHandler)
                    return; // Guard
                // 1. Add code to handler's map and get ID
                const refId = this.inputHandler.addCodeReference(code);
                // 2. Create the placeholder text
                const placeholder = (0, code_ref_widget_1.createCodeRefPlaceholder)(refId, notebookName, lineNumber);
                // 3. Append placeholder to input field
                this.inputHandler.appendToInput(placeholder);
            }
        });
        // --- 2. Define Callbacks (used by buildLayout and Handlers) ---
        // Callbacks for UI actions (passed to buildLayout)
        const createNewChatCallback = () => {
            var _a;
            const newChat = this.chatState.createNewChat();
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id); // Call handler method
        };
        const toggleHistoryCallback = () => {
            var _a;
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.toggleHistoryView(); // Call handler method
        };
        const showSettingsCallback = () => {
            var _a;
            (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.showModal(); // Call handler method
        };
        const updateTitleCallback = (newTitle) => {
            var _a;
            this.chatState.updateCurrentChatTitle(newTitle);
            (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showNotification('Chat title updated', 'info');
        };
        const showPopupMenuCallback = (event) => {
            const rect = event.target.getBoundingClientRect();
            this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20); // Adjust positioning as needed
            event.preventDefault();
            event.stopPropagation();
        };
        const sendMessageViaButtonCallback = () => {
            var _a;
            (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendMessage(this.layoutElements.inputField.value);
        };
        const toggleMarkdownModeCallback = (isMarkdown) => {
            var _a;
            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.setMarkdownMode(isMarkdown);
        };
        const toggleExpandInputCallback = (button) => {
            var _a;
            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.toggleInputExpansion();
            // Update button text/icon based on new state (InputHandler might do this via callback)
            // Example text update, UIManager callback handles the visual state
            // button.textContent = this.inputHandler?.isInputExpanded ? 'Collapse' : 'Expand'; 
        };
        // Callbacks for Message Rendering (passed to MessageHandler -> UIManager -> renderers)
        const messageRendererCallbacks = {
            // ... (showCopyFeedback, addMessageToCell, copyToClipboard, copyImageToClipboard, copyMessageToClipboard defined as before) ...
            showCopyFeedback: (button, success = true) => {
                const originalHTML = button.innerHTML;
                button.innerHTML = success ? 'Copied!' : 'Failed!';
                button.disabled = true;
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.disabled = false;
                }, 1000);
            },
            addMessageToCell: notebook_integration_1.addMessageToCell,
            copyToClipboard: (text, feedbackCb) => {
                navigator.clipboard.writeText(text).then(() => feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb()).catch(err => {
                    console.error('Failed to copy text: ', err);
                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();
                });
            },
            copyImageToClipboard: (imageUrl, feedbackCb) => {
                (0, clipboard_1.copyImageToClipboard)(imageUrl, (success) => {
                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();
                });
            },
            copyMessageToClipboard: (text, feedbackCb) => {
                (0, clipboard_1.copyMessageToClipboard)(text, (success) => {
                    feedbackCb(); // Signal completion
                });
            },
            handleConfirmInterrupt: () => {
                var _a;
                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('confirmed');
            },
            handleRejectInterrupt: () => {
                var _a;
                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('rejected');
            }
        };
        // Callbacks for Settings Modal (passed to createSettingsModalElement)
        const settingsModalCallbacks = {
            handleSave: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.saveSettings(); },
            handleCancel: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.hideModal(); }
        };
        // Callbacks for History Handler
        const historyHandlerCallbacks = {
            updateTitleInput: (title) => this.uiManager.updateTitleInput(title),
            clearMessageContainer: () => this.uiManager.clearMessageContainer(),
            addRenderedMessage: (messageElement) => this.uiManager.addChatMessageElement(messageElement)
        };
        // Callbacks for Input Handler
        // const inputHandlerCallbacks: InputHandlerCallbacks = { // Removed unused variable
        //    handleSendMessage: (message: string) => this.messageHandler?.handleSendMessage(message),
        //    showPopupMenu: (left: number, top: number) => this.popupMenuManager.showPopupMenu(left, top),
        //    hidePopupMenu: () => this.popupMenuManager.hidePopupMenu(),
        //    // Example implementations - refine as needed
        //    updatePlaceholder: (isMarkdown: boolean) => {
        //        this.layoutElements.inputField.placeholder = isMarkdown ? 'Enter markdown...' : 'Ask anything...';
        //    },
        //    toggleInputExpansionUI: (isExpanded: boolean) => {
        //        // Update expand button appearance
        //        this.layoutElements.expandButton.textContent = isExpanded ? 'Collapse' : 'Expand'; // Or use icons
        //        this.layoutElements.expandButton.title = isExpanded ? 'Collapse input' : 'Expand input';
        //    },
        //    // Connect code ref map callbacks to the InputHandler methods
        //    getCodeRefMap: () => this.inputHandler?.getCodeReferenceMap() || new Map<string, string>(),
        //    resetCodeRefMap: () => this.inputHandler?.resetCodeReferences()
        // };
        // Callbacks for Shortcut Handler
        const shortcutCallbacks = {
            showIndicator: (text) => { var _a; return (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showIndicator(text); },
            appendToInput: (text) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(text); },
            showWidget: () => { if (this.isHidden) {
                this.show();
            } },
            focusInput: () => { var _a, _b; return (_b = (_a = this.layoutElements) === null || _a === void 0 ? void 0 : _a.inputField) === null || _b === void 0 ? void 0 : _b.focus(); }
        };
        // --- 3. Build UI Layout ---
        this.layoutElements = (0, layout_builder_1.buildLayout)({
            // Pass the correctly named callbacks from LayoutCallbacks interface
            onNewChatClick: createNewChatCallback,
            onHistoryToggleClick: toggleHistoryCallback, // Corrected name
            onSettingsClick: showSettingsCallback,
            onTitleChange: updateTitleCallback,
            onAtButtonClick: showPopupMenuCallback, // Use the specific callback
            onSendMessageClick: sendMessageViaButtonCallback, // Connect send button
            onMarkdownToggleChange: toggleMarkdownModeCallback, // Connect markdown toggle
            onExpandToggleClick: toggleExpandInputCallback, // Connect expand button
            // onInputFieldKeyPress: ... // Can be handled internally by InputHandler
            // onInputFieldValueChange: ... // Can be handled internally by InputHandler
        });
        this.settingsModalContainer = (0, settings_modal_1.createSettingsModalElement)(settingsModalCallbacks);
        // --- Initialize State Managers ---
        this.chatState = new chat_state_1.ChatState();
        this.settingsState = new settings_state_1.SettingsState();
        // --- Initialize Core Components ---
        this.apiClient = new api_client_1.ApiClient();
        // this.messageRenderer = new MessageRenderer(messageRendererCallbacks); // Fixed: Constructor takes 0 args & member removed
        // --- Initialize UI Manager (needs dependencies) ---
        // Must be initialized *after* handlers that it might need callbacks from,
        // OR pass callbacks directly here.
        const uiManagerCallbacks = {
            handleNewChat: this.handleNewChat,
            handleToggleHistory: this.handleToggleHistory,
            handleSendMessage: this.handleSendMessage,
            handleShowSettings: this.handleShowSettings,
            handleShowPopupMenu: this.handleShowPopupMenu, // Now handled by PopupMenuManager
            handleUpdateTitle: this.handleUpdateTitle
        };
        // UIManager needs: docManager, popupMenuManager, widgetNode, callbacks, layoutElements
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, this.menuActionCallbacks); // Needs docManager, widgetNode, menuActionCallbacks
        this.uiManager = new ui_manager_1.UIManager(
        // this.docManager, // Removed: not in constructor signature
        this.popupMenuManager, 
        // this.node, // Removed: not in constructor signature
        uiManagerCallbacks, this.layoutElements);
        // --- Initialize Handlers (pass dependencies) ---
        this.messageHandler = new message_handler_1.MessageHandler(this.apiClient, this.chatState, this.uiManager, messageRendererCallbacks, // Pass the refined callbacks
        this.inputHandler // Pass the initialized input handler
        );
        // History Handler: Needs state, UI manager, its callbacks, render callbacks
        this.historyHandler = new history_handler_1.HistoryHandler(this.chatState, this.uiManager, historyHandlerCallbacks, // Pass the defined callbacks object
        messageRendererCallbacks // Pass the refined callbacks
        );
        // Settings Handler: Needs state, api client, modal container, UI manager
        this.settingsHandler = new settings_handler_1.SettingsHandler(this.settingsState, this.settingsModalContainer, // Corrected: Pass modal container
        this.uiManager // Corrected: Pass uiManager instance
        );
        // --- 5. Post-Initialization Setup ---
        // Setup Shortcuts (verify signature later in Step 7)
        (0, shortcut_handler_1.setupShortcuts)(this.inputHandler, this.popupMenuManager, shortcutCallbacks // Pass the correctly defined callbacks object
        );
        // Append main UI elements to the widget node
        this.node.appendChild(this.layoutElements.mainElement);
        this.node.appendChild(this.settingsModalContainer);
        // Initialize history view? Load initial/default chat?
        // this.historyHandler.initialize(); // Check if HistoryHandler needs an init method
        const initialChat = this.chatState.getCurrentChat() || this.chatState.createNewChat();
        this.historyHandler.loadChat(initialChat.id); // Load initial chat state into view
    }
    /**
     * Disposes all resources
     */
    dispose() {
        var _a, _b;
        if (this.isDisposed) {
            return;
        }
        // Remove global listeners
        (0, shortcut_handler_1.removeShortcuts)();
        // Call dispose on handlers/managers that have it
        (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this.popupMenuManager) === null || _b === void 0 ? void 0 : _b.dispose();
        // MessageHandler, HistoryHandler, SettingsHandler, UIManager do not have dispose methods
        super.dispose();
    }
} // End of SimpleSidebarWidget class
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/chat-state.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/chat-state.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChatState = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "webpack/sharing/consume/default/uuid/uuid");
/**
 * Manages the state of chat history and the currently active chat.
 */
class ChatState {
    constructor() {
        var _a;
        this.chatHistory = [];
        this.currentChatId = null;
        // Potential: Load initial state from storage if persistence is added later
        if (this.chatHistory.length === 0) {
            this.createNewChat('Welcome Chat'); // Create an initial chat if none exists
        }
        else {
            this.currentChatId = ((_a = this.chatHistory[0]) === null || _a === void 0 ? void 0 : _a.id) || null; // Set current chat to the first one
        }
    }
    /**
     * Creates a new chat session and sets it as the current chat.
     * @param title - The initial title for the new chat.
     * @returns The newly created chat item.
     */
    createNewChat(title = 'New Chat') {
        const chatId = `chat-${(0, uuid_1.v4)()}`; // Use UUID for better uniqueness
        const newChat = {
            id: chatId,
            title: title,
            messages: []
            // createdAt: new Date() 
        };
        this.chatHistory.push(newChat);
        this.currentChatId = chatId;
        console.log('Created new chat:', newChat);
        return newChat;
    }
    /**
     * Sets the currently active chat ID.
     * @param chatId - The ID of the chat to set as current.
     */
    setCurrentChatId(chatId) {
        if (this.chatHistory.some(chat => chat.id === chatId)) {
            this.currentChatId = chatId;
        }
        else {
            console.warn(`Chat ID ${chatId} not found in history.`);
        }
    }
    /**
     * Gets the ID of the currently active chat.
     * @returns The current chat ID or null if none is active.
     */
    getCurrentChatId() {
        return this.currentChatId;
    }
    /**
     * Retrieves a specific chat by its ID.
     * @param chatId - The ID of the chat to retrieve.
     * @returns The chat item or undefined if not found.
     */
    getChatById(chatId) {
        return this.chatHistory.find(chat => chat.id === chatId);
    }
    /**
     * Retrieves the currently active chat item.
     * @returns The current chat item or undefined if no chat is active or found.
     */
    getCurrentChat() {
        if (!this.currentChatId) {
            return undefined;
        }
        return this.getChatById(this.currentChatId);
    }
    /**
     * Updates the title of the currently active chat.
     * @param newTitle - The new title for the chat.
     */
    updateCurrentChatTitle(newTitle) {
        const currentChat = this.getCurrentChat();
        if (currentChat) {
            currentChat.title = newTitle;
            console.log(`Updated title for chat ${this.currentChatId} to "${newTitle}"`);
        }
        else {
            console.warn('Cannot update title: No current chat selected.');
        }
    }
    /**
     * Adds a message to the currently active chat.
     * @param message - The message object to add.
     */
    addMessageToCurrentChat(message) {
        const currentChat = this.getCurrentChat();
        if (currentChat) {
            currentChat.messages.push(message);
        }
        else {
            console.warn('Cannot add message: No current chat selected.');
        }
    }
    /**
     * Gets all messages from the currently active chat.
     * @returns An array of messages or an empty array if no chat is active.
     */
    getCurrentChatMessages() {
        const currentChat = this.getCurrentChat();
        return currentChat ? currentChat.messages : [];
    }
    /**
     * Gets the entire chat history.
     * @returns An array of all chat history items.
     */
    getChatHistory() {
        return [...this.chatHistory]; // Return a copy to prevent direct modification
    }
}
exports.ChatState = ChatState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/settings-state.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/settings-state.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsState = void 0;
const SETTINGS_STORAGE_KEY = 'jp-llm-ext-settings';
/**
 * Manages loading and saving application settings to localStorage.
 */
class SettingsState {
    constructor() {
        this.currentSettings = null;
        this.currentSettings = this.loadSettings();
    }
    /**
     * Loads settings from localStorage.
     * @returns The loaded settings or null if none are saved or an error occurs.
     */
    loadSettings() {
        const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                // Basic validation (can be expanded)
                if (settings && settings.provider) {
                    this.currentSettings = settings;
                    console.log('Loaded settings:', this.currentSettings);
                    return this.currentSettings;
                }
            }
            catch (error) {
                console.error('Error loading saved settings:', error);
                localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear corrupted data
            }
        }
        console.log('No valid settings found in localStorage.');
        return null;
    }
    /**
     * Saves the provided settings to localStorage.
     * @param settings - The settings object to save.
     */
    saveSettings(settings) {
        try {
            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            this.currentSettings = Object.assign({}, settings); // Update internal state
            console.log('Settings saved:', this.currentSettings);
        }
        catch (error) {
            console.error('Error saving settings:', error);
            // Optional: Notify user of save failure
        }
    }
    /**
     * Gets the currently loaded settings.
     * @returns The current settings object or null if not loaded.
     */
    getSettings() {
        return this.currentSettings ? Object.assign({}, this.currentSettings) : null; // Return a copy
    }
    /**
     * Gets a specific setting value.
     * @param key - The key of the setting to retrieve.
     * @returns The value of the setting or undefined if not found.
     */
    getSetting(key) {
        return this.currentSettings ? this.currentSettings[key] : undefined;
    }
}
exports.SettingsState = SettingsState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/code-ref-widget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/code-ref-widget.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCodeRefWidgetHTML = createCodeRefWidgetHTML;
exports.attachCodeRefEventListeners = attachCodeRefEventListeners;
exports.defaultCodeRefToggleLogic = defaultCodeRefToggleLogic;
exports.createCodeRefPlaceholder = createCodeRefPlaceholder;
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
/**
 * Creates the HTML element for a collapsible code reference widget.
 *
 * @param data - The data for the code reference.
 * @returns The HTMLElement representing the code reference widget.
 */
function createCodeRefWidgetHTML(data) {
    const widget = (0, dom_elements_1.createSpan)({
        classes: 'jp-llm-ext-code-ref-widget',
        attributes: {
            'data-ref-id': data.refId,
            'data-code': encodeURIComponent(data.code), // Store original code safely
            'data-ref': data.codeRef
        }
    });
    const label = (0, dom_elements_1.createSpan)({
        classes: 'jp-llm-ext-code-ref-label',
        text: data.codeRef
    });
    const toggleButton = (0, dom_elements_1.createButton)({
        classes: 'jp-llm-ext-code-ref-toggle',
        text: '‚Øà', // Right-pointing triangle initially
        attributes: { title: 'Expand/collapse code' }
    });
    const content = (0, dom_elements_1.createSpan)({
        classes: 'jp-llm-ext-code-ref-content',
        text: data.code, // Display the raw code for now
        style: { display: 'none' } // Hidden initially
    });
    // Assemble the widget
    widget.appendChild(label);
    widget.appendChild(toggleButton);
    widget.appendChild(content);
    return widget;
}
/**
 * Attaches event listeners (specifically click for toggle) to a code ref widget.
 *
 * @param element - The code ref widget HTMLElement.
 * @param toggleCallback - A function to call when the toggle button is clicked.
 */
function attachCodeRefEventListeners(element, toggleCallback) {
    const toggleButton = element.querySelector('.jp-llm-ext-code-ref-toggle');
    const contentElement = element.querySelector('.jp-llm-ext-code-ref-content');
    if (toggleButton && contentElement) {
        toggleButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleCallback(toggleButton, contentElement);
        });
    }
}
/**
 * Default logic for toggling the visibility of the code ref content.
 * This can be passed as the callback to attachCodeRefEventListeners.
 *
 * @param toggleButton - The button element that was clicked.
 * @param contentElement - The content element to toggle.
 */
function defaultCodeRefToggleLogic(toggleButton, contentElement) {
    const isVisible = contentElement.style.display !== 'none';
    contentElement.style.display = isVisible ? 'none' : 'block'; // Or 'inline-block'/'inline' depending on desired layout
    toggleButton.textContent = isVisible ? '‚Øà' : '‚ØÜ'; // Update triangle direction
}
/**
 * Creates a textual placeholder for a code reference.
 *
 * @param refId - The unique identifier for the reference (e.g., "ref-1").
 * @param notebookName - The name of the notebook (optional, for future display enhancements).
 * @param lineNumber - The starting line number of the code (optional, for future display enhancements).
 * @returns A string placeholder like "[ref-1]".
 */
function createCodeRefPlaceholder(refId, notebookName, // Keep optional for now
lineNumber // Keep optional for now
) {
    // Keep it simple for now, just the ID.
    // Display details like notebook/line could be added later if needed.
    return `[${refId}]`;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


// import { ReadonlyPartialJSONObject } from '@lumino/coreutils';
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDiv = createDiv;
exports.createButton = createButton;
exports.createSpan = createSpan;
exports.createTextArea = createTextArea;
exports.createInputElement = createInputElement;
exports.createImageElement = createImageElement;
exports.createAnchorElement = createAnchorElement;
exports.createLabelElement = createLabelElement;
exports.createFormElement = createFormElement;
/**
 * Generic function to create an HTMLElement.
 *
 * @param tagName - The HTML tag name (e.g., 'div', 'button').
 * @param options - Optional configuration for the element.
 * @returns The created HTMLElement.
 */
function createElement(tagName, options = {}) {
    const element = document.createElement(tagName);
    if (options.id) {
        element.id = options.id;
    }
    if (options.classes) {
        const classesToAdd = Array.isArray(options.classes)
            ? options.classes
            : options.classes.split(' ').filter(c => c);
        element.classList.add(...classesToAdd);
    }
    if (options.text) {
        element.textContent = options.text;
    }
    else if (options.html) {
        element.innerHTML = options.html; // Be cautious with HTML injection
    }
    if (options.attributes) {
        for (const key in options.attributes) {
            if (options.attributes.hasOwnProperty(key)) {
                element.setAttribute(key, options.attributes[key]);
            }
        }
    }
    if (options.style) {
        for (const key in options.style) {
            if (options.style.hasOwnProperty(key)) {
                element.style[key] = options.style[key];
            }
        }
    }
    if (options.children) {
        options.children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            }
            else {
                element.appendChild(child);
            }
        });
    }
    return element;
}
/** Creates a <div> element. */
function createDiv(options = {}) {
    return createElement('div', options);
}
/** Creates a <button> element. */
function createButton(options = {}) {
    return createElement('button', options);
}
/** Creates a <span> element. */
function createSpan(options = {}) {
    return createElement('span', options);
}
/** Creates a <textarea> element. */
function createTextArea(options = {}) {
    return createElement('textarea', options);
}
/** Creates an <input> element. */
function createInputElement(options = {}) {
    var _a;
    // Ensure type is set if provided in attributes, otherwise default or leave unset
    if ((_a = options.attributes) === null || _a === void 0 ? void 0 : _a.type) {
        // Type is already set in attributes, do nothing extra
    }
    else if (!options.attributes) {
        options.attributes = { type: 'text' }; // Default to text if no attributes specified
    }
    else if (!options.attributes.type) {
        options.attributes.type = 'text'; // Default to text if type is not in attributes
    }
    return createElement('input', options);
}
/** Creates an <img> element. */
function createImageElement(options) {
    const imgOptions = Object.assign({}, options);
    imgOptions.attributes = Object.assign(Object.assign({}, options.attributes), { src: options.src });
    if (options.alt) {
        imgOptions.attributes.alt = options.alt;
    }
    return createElement('img', imgOptions);
}
/** Creates an <a> element. */
function createAnchorElement(options) {
    const anchorOptions = Object.assign({}, options);
    anchorOptions.attributes = Object.assign(Object.assign({}, options.attributes), { href: options.href });
    return createElement('a', anchorOptions);
}
/** Creates a <label> element. */
function createLabelElement(options) {
    const labelOptions = Object.assign({}, options);
    if (options.htmlFor) {
        labelOptions.attributes = Object.assign(Object.assign({}, options.attributes), { for: options.htmlFor });
    }
    return createElement('label', labelOptions);
}
/** Creates a <form> element. */
function createFormElement(options = {}) {
    return createElement('form', options);
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js":
/*!************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildLayout = buildLayout;
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
/**
 * Builds the main HTML structure for the sidebar widget.
 *
 * @param callbacks - An object containing callback functions for various UI interactions.
 * @returns An object containing the main widget HTMLElement and references to key interactive elements.
 */
function buildLayout(callbacks = {}) {
    // --- Main Content Wrapper ---
    const mainElement = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-content-wrapper'
    });
    // --- Title Bar ---
    const titleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-title-container' });
    const titleInput = (0, dom_elements_1.createInputElement)({
        id: 'chat-title-input',
        classes: 'chat-title-input',
        attributes: { type: 'text', placeholder: 'Chat title', value: 'New Chat' }
    });
    if (callbacks.onTitleChange) {
        titleInput.addEventListener('change', () => callbacks.onTitleChange(titleInput.value));
    }
    titleContainer.appendChild(titleInput);
    // --- Message & History Containers ---
    const messageContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-message-container' });
    const historyContainer = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-history-container',
        style: { display: 'none' } // Hidden by default
    });
    // --- Bottom Bar Area ---
    const bottomBarContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-container' });
    // Row 1: Controls (Markdown Toggle, @, Expand, Settings)
    const controlsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row' });
    const controlsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-controls-container' });
    // Markdown Toggle
    const toggleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-toggle-container' });
    const markdownToggleButton = (0, dom_elements_1.createInputElement)({
        id: 'markdown-toggle',
        attributes: { type: 'checkbox' }
    });
    const toggleLabel = (0, dom_elements_1.createLabelElement)({
        text: 'Markdown mode',
        htmlFor: 'markdown-toggle'
    });
    if (callbacks.onMarkdownToggleChange) {
        markdownToggleButton.addEventListener('change', () => {
            callbacks.onMarkdownToggleChange(markdownToggleButton.checked);
        });
    }
    toggleContainer.appendChild(markdownToggleButton);
    toggleContainer.appendChild(toggleLabel);
    // Action Buttons (@, Expand, Settings)
    const actionButtonsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-action-buttons-container' });
    const atButton = (0, dom_elements_1.createButton)({ text: '@', attributes: { title: 'Browse cells, code, files, and more' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onAtButtonClick) {
        atButton.addEventListener('click', callbacks.onAtButtonClick);
    }
    const expandButton = (0, dom_elements_1.createButton)({ text: '‚§¢', attributes: { title: 'Expand input' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onExpandToggleClick) {
        expandButton.addEventListener('click', () => callbacks.onExpandToggleClick(expandButton));
    }
    const settingsButton = (0, dom_elements_1.createButton)({ text: '‚öôÔ∏è', attributes: { title: 'Settings' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onSettingsClick) {
        settingsButton.addEventListener('click', callbacks.onSettingsClick);
    }
    actionButtonsContainer.appendChild(atButton);
    actionButtonsContainer.appendChild(expandButton);
    actionButtonsContainer.appendChild(settingsButton);
    controlsContainer.appendChild(toggleContainer);
    controlsContainer.appendChild(actionButtonsContainer);
    controlsRow.appendChild(controlsContainer);
    // Row 2: Input Field
    const inputRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row' });
    const inputField = (0, dom_elements_1.createTextArea)({
        classes: 'jp-llm-ext-input-field',
        attributes: { placeholder: 'Ask me anything...', rows: '1' }
    });
    if (callbacks.onInputFieldKeyPress) {
        inputField.addEventListener('keypress', callbacks.onInputFieldKeyPress);
    }
    if (callbacks.onInputFieldValueChange) {
        inputField.addEventListener('input', () => callbacks.onInputFieldValueChange(inputField.value));
    }
    inputRow.appendChild(inputField);
    // Row 3: Main Buttons (Send, New Chat, History)
    const buttonsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row' });
    const sendButton = (0, dom_elements_1.createButton)({
        text: 'Send',
        classes: 'jp-Button jp-llm-ext-send-button'
    });
    if (callbacks.onSendMessageClick) {
        sendButton.addEventListener('click', callbacks.onSendMessageClick);
    }
    const newChatButton = (0, dom_elements_1.createButton)({
        text: '+ New Chat',
        attributes: { title: 'Start a new chat' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onNewChatClick) {
        newChatButton.addEventListener('click', callbacks.onNewChatClick);
    }
    const historyButton = (0, dom_elements_1.createButton)({
        text: 'History',
        attributes: { title: 'View chat history' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onHistoryToggleClick) {
        historyButton.addEventListener('click', callbacks.onHistoryToggleClick);
    }
    buttonsRow.appendChild(sendButton);
    buttonsRow.appendChild(newChatButton);
    buttonsRow.appendChild(historyButton);
    // Assemble Bottom Bar
    bottomBarContainer.appendChild(controlsRow);
    bottomBarContainer.appendChild(inputRow);
    bottomBarContainer.appendChild(buttonsRow);
    // --- Assemble Main Element ---
    mainElement.appendChild(titleContainer);
    mainElement.appendChild(messageContainer);
    mainElement.appendChild(historyContainer);
    mainElement.appendChild(bottomBarContainer);
    return {
        mainElement,
        titleInput,
        messageContainer,
        historyContainer,
        inputField,
        bottomBarContainer,
        sendButton,
        newChatButton,
        historyButton,
        markdownToggleButton,
        expandButton,
        atButton,
        settingsButton
    };
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRenderer = void 0;
exports.renderUserMessage = renderUserMessage;
exports.renderBotMessage = renderBotMessage;
exports.renderBotMessageStreamingStart = renderBotMessageStreamingStart;
exports.renderBotMessageStreamingUpdate = renderBotMessageStreamingUpdate;
exports.renderBotMessageFinal = renderBotMessageFinal;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
// import hljs from 'highlight.js'; // Removed unused import
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
// Removed unused import block for code-ref-widget
// import {
//   CodeRefData,
//   createCodeRefWidgetHTML,
//   attachCodeRefEventListeners,
//   defaultCodeRefToggleLogic
// } from './code-ref-widget';
// Removed unused import block for clipboard utils (used via callbacks)
// import { copyToClipboard, copyImageToClipboard, copyMessageToClipboard } from '../utils/clipboard';
// Removed unused import (used via callbacks)
// import { addMessageToCell } from '../utils/notebook-integration';
const highlighting_1 = __webpack_require__(/*! ../utils/highlighting */ "./node_modules/jupyter-simple-extension/lib/utils/highlighting.js");
const markdown_config_1 = __webpack_require__(/*! ../utils/markdown-config */ "./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js");
/**
 * Base function to create a message container div.
 */
function createMessageDiv(sender) {
    const messageDiv = document.createElement('div');
    messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';
    return messageDiv;
}
/**
 * Renders a user message.
 */
function renderUserMessage(text, options = {}, callbacks = {}) {
    const messageDiv = createMessageDiv('user');
    // Handle user message with code references (logic to be moved from addMessage)
    if (options.isMarkdown) {
        // Special case: User message with code references (placeholder)
        const contentDiv = document.createElement('div');
        contentDiv.className = 'user-content-with-refs';
        // TODO: Move code reference widget creation logic here
        contentDiv.textContent = `[Code Refs Placeholder] ${text}`;
        messageDiv.appendChild(contentDiv);
    }
    else {
        messageDiv.textContent = text;
    }
    return messageDiv;
}
/**
 * Renders a bot message (text, markdown, images, code blocks).
 */
function renderBotMessage(text, options = { isMarkdown: true }, callbacks = {}) {
    const messageDiv = createMessageDiv('bot');
    // Check if the message is an image URL
    const isImageUrl = text.trim().startsWith('/images/') &&
        (text.trim().endsWith('.png') ||
            text.trim().endsWith('.jpg') ||
            text.trim().endsWith('.jpeg') ||
            text.trim().endsWith('.gif'));
    if (isImageUrl) {
        // Construct full URL (TODO: Make base URL configurable)
        const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;
        // Call dedicated image rendering function
        renderImageMessage(messageDiv, fullImageUrl, callbacks);
    }
    else if (options.isMarkdown) {
        // Render as markdown (logic from addMessage)
        const markdownIndicator = document.createElement('div');
        markdownIndicator.textContent = "MD";
        markdownIndicator.className = 'markdown-indicator';
        messageDiv.appendChild(markdownIndicator);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-content';
        try {
            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // Enhance code blocks after setting innerHTML
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                enhanceCodeBlock(block, callbacks);
            });
            // Check for and render interrupt buttons
            const isInterrupt = text.startsWith('**[INTERRUPT]**');
            if (isInterrupt) {
                renderInterruptButtons(contentDiv, callbacks);
            }
        }
        catch (error) {
            contentDiv.textContent = text; // Fallback to plain text
            console.error('Failed to render markdown:', error);
        }
        messageDiv.appendChild(contentDiv);
        // Add overall message action buttons AFTER content is added
        addBotMessageActions(messageDiv, text, callbacks);
    }
    else {
        // Render as plain text
        messageDiv.textContent = text;
        // Add overall message action buttons even for plain text bot messages
        addBotMessageActions(messageDiv, text, callbacks);
    }
    return messageDiv;
}
// Define createMessageWrapper based on createMessageDiv
function createMessageWrapper(sender) {
    return createMessageDiv(sender);
}
// --- More specific rendering functions or helpers can be added below ---
/**
 * Renders an image message with action buttons inside a container.
 *
 * @param container The parent HTML element to append the image message to.
 * @param imageUrl The full URL of the image to render.
 * @param callbacks Callbacks for actions like copy image, add path.
 */
function renderImageMessage(container, imageUrl, callbacks = {}) {
    // Create a container for the image that allows positioning the buttons
    const imageContainer = document.createElement('div');
    imageContainer.className = 'jp-llm-ext-image-container';
    imageContainer.style.position = 'relative';
    // Render as an image tag
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = 'Image from bot';
    img.style.maxWidth = '100%'; // Ensure image fits within the container
    img.style.height = 'auto';
    imageContainer.appendChild(img);
    // Add action buttons for the image
    const imgActionsDiv = document.createElement('div');
    imgActionsDiv.className = 'jp-llm-ext-image-actions';
    imgActionsDiv.style.position = 'absolute';
    imgActionsDiv.style.bottom = '10px';
    imgActionsDiv.style.right = '10px';
    imgActionsDiv.style.display = 'flex';
    imgActionsDiv.style.gap = '8px';
    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)'; // Added slight background for visibility
    imgActionsDiv.style.borderRadius = '4px';
    imgActionsDiv.style.padding = '4px';
    // Copy image button (using callback)
    if (callbacks.copyImageToClipboard && callbacks.showCopyFeedback) {
        const copyImgBtn = document.createElement('button');
        copyImgBtn.className = 'jp-llm-ext-image-action-button';
        copyImgBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyImgBtn.title = 'Copy image to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyImgBtn);
        copyImgBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyImageToClipboard(imageUrl, feedbackCb);
        });
        imgActionsDiv.appendChild(copyImgBtn);
    }
    // Add file path button (using callback)
    if (callbacks.addMessageToCell) {
        const addPathBtn = document.createElement('button');
        addPathBtn.className = 'jp-llm-ext-image-action-button';
        addPathBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addPathBtn.title = 'Add image path to current cell';
        addPathBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            // Pass the image URL (which is the message text in this case)
            callbacks.addMessageToCell(imageUrl);
        });
        imgActionsDiv.appendChild(addPathBtn);
    }
    // Only add the actions div if it has buttons
    if (imgActionsDiv.hasChildNodes()) {
        imageContainer.appendChild(imgActionsDiv);
    }
    // Add the image container to the main message div
    container.appendChild(imageContainer);
}
/**
 * Creates the initial structure for a bot message that will receive streaming content.
 *
 * @returns Object containing the wrapper, streaming div, and final content div.
 */
function renderBotMessageStreamingStart() {
    const wrapper = createMessageWrapper('bot');
    const markdownIndicator = (0, dom_elements_1.createDiv)({
        text: 'MD',
        classes: 'markdown-indicator'
    });
    wrapper.appendChild(markdownIndicator);
    const streamingDiv = (0, dom_elements_1.createDiv)({
        classes: 'streaming-content',
        style: {
            whiteSpace: 'pre-wrap',
            fontFamily: 'monospace',
            fontSize: '0.9em'
        }
    });
    wrapper.appendChild(streamingDiv);
    const contentDiv = (0, dom_elements_1.createDiv)({
        classes: 'markdown-content',
        style: { display: 'none' } // Initially hidden
    });
    wrapper.appendChild(contentDiv);
    return { wrapper, streamingDiv, contentDiv };
}
/**
 * Updates the streaming div with a new chunk of text.
 *
 * @param streamingDiv - The div displaying streaming content.
 * @param chunk - The new text chunk to append.
 */
function renderBotMessageStreamingUpdate(streamingDiv, chunk) {
    // Simple append, might need refinement for complex streams
    streamingDiv.textContent += chunk;
}
/**
 * Renders the final content of a bot message after streaming is complete.
 * Handles markdown, images, code blocks, and interrupts.
 *
 * @param contentDiv - The div where the final content should be rendered.
 * @param streamingDiv - The div that was used for streaming (will be hidden).
 * @param completeResponse - The full text content from the bot.
 * @param options - Rendering options including callbacks for actions.
 * @returns The populated contentDiv.
 */
function renderBotMessageFinal(contentDiv, streamingDiv, completeResponse, options = {}, callbacks = {}) {
    // Hide streaming div, show final content div
    streamingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    // Consolidate callbacks access
    const effectiveCallbacks = Object.assign(Object.assign({}, options), callbacks);
    // --- Image Handling ---
    const isImageUrl = completeResponse.trim().startsWith('/images/') &&
        (completeResponse.trim().endsWith('.png') ||
            completeResponse.trim().endsWith('.jpg') ||
            completeResponse.trim().endsWith('.jpeg') ||
            completeResponse.trim().endsWith('.gif'));
    if (isImageUrl) {
        const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // TODO: Make base URL configurable
        renderImageMessage(contentDiv, fullImageUrl, effectiveCallbacks);
    }
    else {
        // --- Markdown & Code Block Handling ---
        try {
            const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // --- Interrupt Handling ---
            const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');
            if (isInterrupt) {
                renderInterruptButtons(contentDiv, effectiveCallbacks);
            }
            // --- Code Block Enhancements ---
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                enhanceCodeBlock(block, effectiveCallbacks);
            });
        }
        catch (error) {
            console.error('Error rendering markdown:', error);
            contentDiv.textContent = completeResponse; // Fallback to plain text
        }
    }
    return contentDiv;
}
/**
 * Enhances a code block element with highlighting and action buttons.
 *
 * @param codeBlockElement The <code> element within a <pre>.
 * @param callbacks Callbacks for actions like copy code, add to cell.
 */
function enhanceCodeBlock(codeBlockElement, callbacks = {}) {
    var _a;
    const preElement = codeBlockElement.parentElement;
    if (!preElement || preElement.tagName !== 'PRE') {
        console.warn('Code block enhancement called on element not within a <pre> tag.');
        return;
    }
    // Add standard JupyterLab classes for consistency
    codeBlockElement.classList.add('jp-RenderedText');
    preElement.classList.add('jp-RenderedHTMLCommon');
    // Get code content
    const codeContent = codeBlockElement.textContent || '';
    // Create code block header for buttons and language indicator
    const codeHeader = document.createElement('div');
    codeHeader.className = 'jp-llm-ext-code-header';
    // Add language indicator if detected
    const language = (0, highlighting_1.detectLanguage)(codeContent); // Use imported util
    if (language) {
        const langIndicator = document.createElement('span');
        langIndicator.className = 'jp-llm-ext-code-language';
        langIndicator.textContent = language;
        codeHeader.appendChild(langIndicator);
        codeBlockElement.classList.add(`language-${language}`);
    }
    // Apply syntax highlighting
    try {
        // Use imported util (handles auto-detection if language is empty)
        codeBlockElement.innerHTML = (0, highlighting_1.highlightCode)(codeContent, language);
    }
    catch (error) {
        console.error('Error applying syntax highlighting:', error);
        // codeBlockElement might contain original text or partially highlighted
    }
    // Add action buttons to the code header
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'jp-llm-ext-code-actions';
    // Copy button
    if (callbacks.copyToClipboard && callbacks.showCopyFeedback) {
        const copyButton = document.createElement('button');
        copyButton.className = 'jp-llm-ext-code-action-button';
        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyButton.title = 'Copy code to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);
        copyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyToClipboard(codeContent, feedbackCb);
        });
        actionsDiv.appendChild(copyButton);
    }
    // Add to cell button
    if (callbacks.addMessageToCell) {
        const addToButton = document.createElement('button');
        addToButton.className = 'jp-llm-ext-code-action-button';
        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addToButton.title = 'Add code to current cell';
        addToButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.addMessageToCell(codeContent);
        });
        actionsDiv.appendChild(addToButton);
    }
    // Add the actions to the header, and insert header before the <pre>
    if (actionsDiv.hasChildNodes()) {
        codeHeader.appendChild(actionsDiv);
    }
    if (codeHeader.hasChildNodes()) {
        (_a = preElement.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(codeHeader, preElement);
    }
}
/**
 * Renders Confirm/Reject buttons for an interrupt message.
 *
 * @param container The parent HTML element (message content div) to append buttons to.
 * @param callbacks Callbacks for confirm and reject actions.
 */
function renderInterruptButtons(container, callbacks = {}) {
    if (!callbacks.handleConfirmInterrupt || !callbacks.handleRejectInterrupt) {
        console.warn('Interrupt message needs confirm/reject callbacks.');
        return;
    }
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';
    buttonsContainer.style.marginTop = '12px';
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.gap = '8px';
    // Create confirm button
    const confirmButton = document.createElement('button');
    confirmButton.className = 'jp-llm-ext-confirm-button';
    confirmButton.textContent = 'Confirm';
    // Apply specific styling (can be moved to CSS)
    confirmButton.style.padding = '6px 12px';
    confirmButton.style.background = '#4CAF50';
    confirmButton.style.color = 'white';
    confirmButton.style.border = 'none';
    confirmButton.style.borderRadius = '4px';
    confirmButton.style.cursor = 'pointer';
    confirmButton.style.fontWeight = 'bold';
    // Create reject button
    const rejectButton = document.createElement('button');
    rejectButton.className = 'jp-llm-ext-reject-button';
    rejectButton.textContent = 'Reject';
    // Apply specific styling (can be moved to CSS)
    rejectButton.style.padding = '6px 12px';
    rejectButton.style.background = '#F44336';
    rejectButton.style.color = 'white';
    rejectButton.style.border = 'none';
    rejectButton.style.borderRadius = '4px';
    rejectButton.style.cursor = 'pointer';
    rejectButton.style.fontWeight = 'bold';
    // Add event listeners
    confirmButton.addEventListener('click', () => {
        confirmButton.disabled = true;
        rejectButton.disabled = true;
        confirmButton.style.opacity = '0.5';
        rejectButton.style.opacity = '0.5';
        callbacks.handleConfirmInterrupt();
    });
    rejectButton.addEventListener('click', () => {
        confirmButton.disabled = true;
        rejectButton.disabled = true;
        confirmButton.style.opacity = '0.5';
        rejectButton.style.opacity = '0.5';
        callbacks.handleRejectInterrupt();
    });
    // Add buttons to container and container to message
    buttonsContainer.appendChild(confirmButton);
    buttonsContainer.appendChild(rejectButton);
    container.appendChild(buttonsContainer);
}
/**
 * Adds overall action buttons (Copy, Add to Cell) to a bot message container.
 *
 * @param messageDiv The main div container for the bot message.
 * @param messageText The raw text content of the message.
 * @param callbacks Callbacks for actions like copy message, add to cell.
 */
function addBotMessageActions(messageDiv, messageText, callbacks = {}) {
    // Only add actions if corresponding callbacks are provided
    if (!callbacks.copyMessageToClipboard && !callbacks.addMessageToCell) {
        return;
    }
    console.log('Adding action buttons to bot message'); // Keep debug log for now
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'jp-llm-ext-message-actions';
    // actionsDiv.style.display = 'flex'; // Ensure display via CSS if needed
    // Copy Message button
    if (callbacks.copyMessageToClipboard && callbacks.showCopyFeedback) {
        const copyButton = document.createElement('button');
        copyButton.className = 'jp-llm-ext-message-action-button';
        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyButton.title = 'Copy message to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);
        copyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyMessageToClipboard(messageText, feedbackCb);
        });
        actionsDiv.appendChild(copyButton);
    }
    // Add to Cell button
    if (callbacks.addMessageToCell) {
        const addToButton = document.createElement('button');
        addToButton.className = 'jp-llm-ext-message-action-button';
        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addToButton.title = 'Add message to current cell';
        addToButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.addMessageToCell(messageText);
        });
        actionsDiv.appendChild(addToButton);
    }
    // Append the actions container if it has any buttons
    if (actionsDiv.hasChildNodes()) {
        messageDiv.appendChild(actionsDiv);
        console.log('Action buttons added to bot message:', actionsDiv); // Keep debug log
    }
}
// Potential future additions:
// - renderErrorMessage
// - renderSystemMessage
// - A main renderMessage function that delegates based on type? 
/**
 * Handles rendering individual messages (user, bot, system) into HTML elements.
 */
class MessageRenderer {
    // private callbacks: MessageRendererCallbacks; // Removed unused member
    // private uiManager: UIManager; // Might not be needed directly if callbacks handle UI updates
    constructor( /* callbacks: MessageRendererCallbacks */ /* , uiManager: UIManager */) {
        // this.callbacks = callbacks; // Removed unused assignment
        // this.uiManager = uiManager;
    }
}
exports.MessageRenderer = MessageRenderer;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js":
/*!************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsModal = void 0;
exports.createSettingsModalElement = createSettingsModalElement;
/**
 * Creates the HTML element for the settings modal.
 * @param callbacks Callbacks for save and cancel actions.
 * @returns The main modal HTMLElement.
 */
function createSettingsModalElement(callbacks) {
    const modal = document.createElement('div');
    modal.className = 'jp-llm-ext-settings-modal';
    modal.style.display = 'none'; // Initially hidden
    const content = document.createElement('div');
    content.className = 'jp-llm-ext-settings-content';
    const title = document.createElement('h2');
    title.className = 'jp-llm-ext-settings-title';
    title.textContent = 'Settings';
    content.appendChild(title);
    const form = document.createElement('form');
    form.className = 'jp-llm-ext-settings-form';
    // Provider selection
    const providerLabel = document.createElement('label');
    providerLabel.className = 'jp-llm-ext-settings-label';
    providerLabel.textContent = 'API Provider:';
    form.appendChild(providerLabel);
    const providerSelect = document.createElement('select');
    providerSelect.className = 'jp-llm-ext-settings-select';
    providerSelect.id = 'settings-provider'; // Keep ID for retrieval
    ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        providerSelect.appendChild(option);
    });
    form.appendChild(providerSelect);
    // API Key input
    const apiKeyLabel = document.createElement('label');
    apiKeyLabel.className = 'jp-llm-ext-settings-label';
    apiKeyLabel.textContent = 'API Key:';
    form.appendChild(apiKeyLabel);
    const apiKeyInput = document.createElement('input');
    apiKeyInput.className = 'jp-llm-ext-settings-input';
    apiKeyInput.type = 'password';
    apiKeyInput.id = 'settings-api-key'; // Keep ID for retrieval
    form.appendChild(apiKeyInput);
    // API URL input
    const apiUrlLabel = document.createElement('label');
    apiUrlLabel.className = 'jp-llm-ext-settings-label';
    apiUrlLabel.textContent = 'API URL (optional):';
    form.appendChild(apiUrlLabel);
    const apiUrlInput = document.createElement('input');
    apiUrlInput.className = 'jp-llm-ext-settings-input';
    apiUrlInput.type = 'text';
    apiUrlInput.id = 'settings-api-url'; // Keep ID for retrieval
    form.appendChild(apiUrlInput);
    // Rules input
    const rulesLabel = document.createElement('label');
    rulesLabel.className = 'jp-llm-ext-settings-label';
    rulesLabel.textContent = 'Custom Rules (optional):';
    form.appendChild(rulesLabel);
    const rulesInput = document.createElement('textarea');
    rulesInput.className = 'jp-llm-ext-settings-textarea';
    rulesInput.id = 'settings-rules'; // Keep ID for retrieval
    form.appendChild(rulesInput);
    // Buttons container
    const btnContainer = document.createElement('div');
    btnContainer.className = 'jp-llm-ext-settings-buttons';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';
    saveBtn.textContent = 'Save';
    saveBtn.type = 'button'; // Prevent default form submission
    saveBtn.addEventListener('click', (event) => {
        event.preventDefault();
        // The callback implementation will handle reading values and saving
        const settings = {
            apiKey: apiKeyInput.value,
            apiUrl: apiUrlInput.value,
            rules: rulesInput.value,
            provider: providerSelect.value
        };
        callbacks.handleSave(settings);
    });
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.type = 'button'; // Prevent default form submission
    cancelBtn.addEventListener('click', (event) => {
        event.preventDefault();
        callbacks.handleCancel();
    });
    btnContainer.appendChild(saveBtn);
    btnContainer.appendChild(cancelBtn);
    form.appendChild(btnContainer);
    content.appendChild(form);
    modal.appendChild(content);
    return modal;
}
/**
 * Creates and manages the settings modal dialog.
 */
class SettingsModal {
    // private modalElement: HTMLDivElement; // Commented out - unused
    // private settings: AppSettings; // Commented out - unused
    constructor(callbacks) {
        // this.modalElement = createSettingsModalElement(callbacks); // Commented out - unused assignment
        // this.settings = { // Commented out - unused initialization
        //     provider: '', 
        //     apiKey: '', 
        //     apiUrl: '', 
        //     rules: '' 
        // }; 
    }
}
exports.SettingsModal = SettingsModal;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js":
/*!********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIManager = void 0;
/**
 * Manages UI elements and transitions for the chat interface.
 * This acts as a central point for UI manipulations, simplifying dependencies for handlers.
 */
class UIManager {
    constructor(
    // docManager: IDocumentManager, // Commented out - unused parameter
    popupMenuManager, 
    // widgetNode: HTMLElement, // Commented out - unused parameter
    callbacks, layoutElements) {
        this.notificationTimeout = null; // Timeout for the shortcut indicator
        // Internal UI state
        this.isInputExpanded = false;
        this.isMarkdownMode = false;
        // this.docManager = docManager; // Commented out - unused assignment
        this.popupMenuManager = popupMenuManager; // Needed for '@' button action
        // this.widgetNode = widgetNode; // Commented out - unused assignment
        this.callbacks = callbacks; // Callbacks to trigger widget/handler logic
        this.layoutElements = layoutElements;
        // Initialize elements that are created outside createLayout if any
        // In this case, all core elements are created within createLayout
        // Create and append the indicator element
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'jp-llm-ext-keyboard-shortcut-indicator';
        // Append it to the main element managed by the UIManager
        // Ensure mainElement exists before appending
        if (this.layoutElements.mainElement) {
            this.layoutElements.mainElement.appendChild(this.keyboardShortcutIndicator);
        }
        else {
            console.error('UIManager: Main layout element not found during indicator initialization.');
        }
    }
    /**
     * Returns the core layout elements.
     */
    getUIElements() {
        return this.layoutElements;
    }
    /**
     * Toggles the expansion state of the input field.
     */
    toggleInputExpansion() {
        // Use layoutElements provided via constructor
        const inputField = this.layoutElements.inputField;
        const expandButton = this.layoutElements.expandButton;

        if (!inputField || !expandButton)
            return; // Ensure elements exist
        
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            inputField.style.height = '200px'; // Use CSS classes ideally
            inputField.style.resize = 'vertical';
            expandButton.textContent = '‚§°'; // Collapse symbol
            expandButton.title = 'Collapse input';
        }
        else {
            inputField.style.height = ''; // Reset height
            inputField.style.resize = 'none';
            inputField.rows = 1; // Ensure collapse
            expandButton.textContent = '‚§¢'; // Expand symbol
            expandButton.title = 'Expand input';
        }
        // Future: Notify widget/handler if needed: this.callbacks.handleToggleExpansion(this.isInputExpanded);
    }
    /**
     * Updates the appearance of the Expand/Collapse button.
     * This method is needed because InputHandler manages the state,
     * but UIManager manages the button element.
     */
    updateExpandButton(isExpanded) {
        const expandButton = this.layoutElements.expandButton;
        if (!expandButton) return;

        if (isExpanded) {
            expandButton.textContent = '‚§°'; // Collapse symbol
            expandButton.title = 'Collapse input';
        }
        else {
            expandButton.textContent = '‚§¢'; // Expand symbol
            expandButton.title = 'Expand input';
        }
    }
    /**
     * Helper function to create a styled button.
     * NOTE: This might be redundant if buildLayout handles all button creation. Keeping for now.
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        // Apply base JupyterLab button class and our specific class
        button.className = 'jp-Button jp-llm-ext-action-button';
        return button;
    }
    /**
     * Appends a new chat message element to the message container and scrolls down.
     * @param element The message element (user or bot) to add.
     */
    addChatMessageElement(element) {
        // Use layoutElements provided via constructor
        const messageContainer = this.layoutElements.messageContainer;
        if (messageContainer) {
            messageContainer.appendChild(element);
            this.scrollToBottom(); // Scroll after adding the new element
        }
        else {
            console.error('Message container not found in UIManager layoutElements.');
        }
    }
    /**
     * Scrolls the message container to the bottom.
     */
    scrollToBottom() {
        // Use layoutElements provided via constructor
        const messageContainer = this.layoutElements.messageContainer;
        if (messageContainer) {
            messageContainer.scrollTop = messageContainer.scrollHeight;
        }
        else {
            console.error('Message container not found in UIManager layoutElements.');
        }
    }
    /**
     * Switches the view to show the chat history.
     */
    showHistoryView() {
        if (!this.layoutElements.messageContainer || !this.layoutElements.historyContainer || !this.layoutElements.bottomBarContainer) {
            console.error("UIManager: Cannot show history view, required layout elements missing.");
            return;
        }
        this.layoutElements.messageContainer.style.display = 'none';
        this.layoutElements.historyContainer.style.display = 'block';
        this.layoutElements.bottomBarContainer.style.display = 'none';
        // Optionally update header/title elements if needed
    }
    /**
     * Switches the view to show the main chat interface.
     */
    showChatView() {
        if (!this.layoutElements.messageContainer || !this.layoutElements.historyContainer || !this.layoutElements.bottomBarContainer) {
            console.error("UIManager: Cannot show chat view, required layout elements missing.");
            return;
        }
        this.layoutElements.historyContainer.style.display = 'none';
        this.layoutElements.messageContainer.style.display = 'block';
        this.layoutElements.bottomBarContainer.style.display = 'flex'; // Assuming flex display
        this.scrollToBottom(); // Scroll down when showing chat
    }
    /**
     * Clears all messages from the message container.
     */
    clearMessageContainer() {
        const messageContainer = this.layoutElements.messageContainer;
        if (messageContainer) {
            messageContainer.innerHTML = '';
        } else {
            console.error('UIManager: Cannot clear message container, element not found.');
        }
    }
    /**
     * Updates the value of the title input field.
     */
    updateTitleInput(title) {
        const titleInput = this.layoutElements.titleInput;
        if (titleInput) {
            titleInput.value = title;
        } else {
            console.error('UIManager: Cannot update title input, element not found.');
        }
    }
    /**
     * Creates and returns a container structure for a bot message,
     * including elements for streaming text and final rendered content.
     * This helps manage the transition from streaming to final message display.
     */
    createBotMessageContainer() {
        const botMessageDiv = document.createElement('div');
        botMessageDiv.className = 'jp-llm-ext-bot-message'; // Base class
        // Div for streaming content (initially visible)
        const streamingDiv = document.createElement('div');
        streamingDiv.className = 'jp-llm-ext-streaming-content';
        streamingDiv.style.display = 'block'; // Show streaming initially
        // Div for final rendered content (initially hidden)
        const contentDiv = document.createElement('div');
        contentDiv.className = 'jp-llm-ext-rendered-content';
        contentDiv.style.display = 'none'; // Hide final content initially
        botMessageDiv.appendChild(streamingDiv);
        botMessageDiv.appendChild(contentDiv);
        // Add the whole container to the message list *before* streaming starts
        // Ensure addChatMessageElement uses layoutElements.messageContainer correctly
        this.addChatMessageElement(botMessageDiv);
        return { botMessageDiv, streamingDiv, contentDiv };
    }
    /**
     * Displays a temporary notification message.
     * TODO: Implement a more robust notification system (e.g., toast).
     */
    showNotification(message, type, duration = 3000) {
        console.log(`Notification (${type}): ${message}`);
        // Basic temporary implementation using the existing indicator element
        // const indicator = this.layoutElements.mainElement.querySelector('.jp-llm-ext-keyboard-shortcut-indicator');
        const indicator = this.keyboardShortcutIndicator; // Use the direct reference
        if (indicator) {
            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout); // Clear previous timeout
            }
            indicator.textContent = message;
            indicator.className = `jp-llm-ext-keyboard-shortcut-indicator visible jp-llm-ext-notification-${type}`; // Add type class
            this.notificationTimeout = window.setTimeout(() => {
                indicator.classList.remove('visible');
                this.notificationTimeout = null;
            }, duration);
        }
        else {
            console.warn('Notification indicator element not found for UIManager.');
        }
    }
    /**
     * Shows a visual indicator for keyboard shortcuts.
     * @param text The text to display in the indicator.
     */
    showIndicator(text) {
        if (!this.keyboardShortcutIndicator)
            return; // Guard
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Clear any existing timeout to prevent multiple timeouts running
        if (this.notificationTimeout) {
            clearTimeout(this.notificationTimeout);
        }
        // Set new timeout to hide the indicator
        this.notificationTimeout = window.setTimeout(() => {
            if (this.keyboardShortcutIndicator) { // Check if element still exists
                this.keyboardShortcutIndicator.classList.remove('visible');
            }
            this.notificationTimeout = null;
        }, 1000); // Hide after 1 second
    }
    /**
     * Clears the indicator immediately and cancels any pending hide timeout.
     * Useful if the widget is hidden while the indicator is shown.
     */
    clearIndicator() {
        if (!this.keyboardShortcutIndicator)
            return;
        this.keyboardShortcutIndicator.classList.remove('visible');
        this.keyboardShortcutIndicator.textContent = '';
        if (this.notificationTimeout) {
            clearTimeout(this.notificationTimeout);
            this.notificationTimeout = null;
        }
    }
}
exports.UIManager = UIManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/clipboard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/clipboard.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.copyToClipboard = copyToClipboard;
exports.copyMessageToClipboard = copyMessageToClipboard;
exports.copyImageToClipboard = copyImageToClipboard;
/**
 * Helper function to copy text to clipboard.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyToClipboard(text, feedbackCallback) {
    try {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Content copied to clipboard');
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(); // Call optional feedback callback
        }).catch(err => {
            console.error('Failed to copy text: ', err);
        });
    }
    catch (error) {
        console.error('Error copying text to clipboard:', error);
    }
}
/**
 * Copies message content to clipboard.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyMessageToClipboard(text, feedbackCallback) {
    try {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Message content copied to clipboard');
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success
        }).catch(err => {
            console.error('Failed to copy message text: ', err);
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
        });
    }
    catch (error) {
        console.error('Error copying message to clipboard:', error);
        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
    }
}
/**
 * Copies an image to the clipboard from a given URL.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyImageToClipboard(imageUrl, feedbackCallback) {
    try {
        fetch(imageUrl)
            .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.statusText}`);
            }
            return response.blob();
        })
            .then(blob => {
            // Create a ClipboardItem with the image blob
            // Note: ClipboardItem might not be defined in all environments
            // You might need to add `"dom.iterable"` to tsconfig lib or handle appropriately.
            const item = new ClipboardItem({ [blob.type]: blob });
            navigator.clipboard.write([item]).then(() => {
                console.log('Image copied to clipboard');
                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success
            })
                .catch(err => {
                console.error('Failed to copy image to clipboard: ', err);
                alert('Failed to copy image: ' + err.message); // Keep alert for critical user feedback
                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
            });
        })
            .catch(err => {
            console.error('Failed to fetch or process image: ', err);
            alert('Failed to fetch image: ' + err.message); // Keep alert for critical user feedback
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
        });
    }
    catch (error) {
        console.error('Error preparing image copy:', error);
        alert('Error copying image: ' + error); // Keep alert for critical user feedback
        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/highlighting.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/highlighting.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detectLanguage = detectLanguage;
exports.highlightCode = highlightCode;
const highlight_js_1 = __importDefault(__webpack_require__(/*! highlight.js */ "webpack/sharing/consume/default/highlight.js/highlight.js"));
/**
 * Detects the programming language from code block content using highlight.js
 * and custom pattern matching for common languages.
 */
function detectLanguage(code) {
    try {
        // Try auto detection first with a limited set of common languages
        const result = highlight_js_1.default.highlightAuto(code, [
            'python', 'javascript', 'typescript', 'java',
            'html', 'css', 'cpp', 'csharp', 'sql', 'rust',
            'php', 'bash', 'json', 'xml', 'markdown'
        ]);
        // If confidence is reasonably high, use that language
        if (result.relevance > 5 && result.language) {
            return result.language;
        }
        // Fall back to basic pattern matching for better accuracy on ambiguous cases
        if (/^(?:\s*)?(?:import\s+[^;]+;|package\s+[^;]+;|public\s+class)/.test(code)) {
            return 'java';
        }
        else if (/^(?:\s*)?(import|from|def|class|if __name__)/.test(code)) {
            return 'python';
        }
        else if (/^(?:\s*)?(?:function|const|let|var|import|export|=>)/.test(code)) {
            // Broader check for JS/TS
            if (/^(?:\s*)?(?:import\s.+|export\s.+|interface|type|enum|declare|:|\s<)/.test(code)) {
                return 'typescript';
            }
            return 'javascript';
        }
        else if (/^(?:\s*)?(?:<!DOCTYPE|<html|<head|<body)/i.test(code)) {
            return 'html';
        }
        else if (/^(?:\s*)?#include/.test(code)) {
            return 'cpp';
        }
        else if (/^(?:\s*)?(?:using\s+System|namespace|public\s+static\s+void\s+Main)/.test(code)) {
            return 'csharp';
        }
        else if (/^(?:\s*)?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\s/i.test(code)) {
            return 'sql';
        }
        else if (/^(?:\s*)?(?:fn|let|struct|enum|trait|impl|mod)\s/.test(code)) {
            return 'rust';
        }
        else if (/^(?:\s*)?(?:<\?php|use\s+[\w\\]+;)/.test(code)) {
            return 'php';
        }
        else if (/^(?:\s*)?(?:#\s*!\/bin\/(?:bash|sh|zsh)|\$)/.test(code)) {
            return 'bash';
        }
        else if (/^\s*\{/.test(code) && /\}\s*$/.test(code)) {
            // Simple check for JSON-like structure
            return 'json';
        }
        else if (/^\s*<\?xml/.test(code) || /^\s*<\w+/.test(code)) {
            // Simple check for XML/HTML like structure
            return 'xml';
        }
        // If no specific language detected, return empty string for default handling
        return '';
    }
    catch (error) {
        console.error('Error detecting language:', error);
        return ''; // Return empty on error
    }
}
/**
 * Highlights code using highlight.js.
 * Falls back to auto-detection if the specified language is not supported.
 */
function highlightCode(code, language) {
    try {
        if (language && highlight_js_1.default.getLanguage(language)) {
            return highlight_js_1.default.highlight(code, { language, ignoreIllegals: true }).value;
        }
        else {
            // Fallback to auto-detection if language is empty or not registered
            return highlight_js_1.default.highlightAuto(code).value;
        }
    }
    catch (error) {
        console.error(`Error highlighting code (language: ${language || 'auto'}):`, error);
        // Return original code escaped for safety on error
        return code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Normalize line endings
    const normalizedText = text.replace(/\r\n/g, '\n');
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = normalizedText.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks:
        // 1. Handle list items with proper spacing
        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines
        let processed = line;
        // Handle dash list items by ensuring they have a space after the dash
        processed = processed.replace(/(\s*)-(\S)/g, '$1- $2');
        // Handle mixed space/dash issues - ensure proper newlines before list items
        processed = processed.replace(/([^\n\s])-\s/g, '$1\n- ');
        return processed;
    });
    // Join lines and ensure code blocks are properly formatted
    let result = processedLines.join('\n');
    // Handle empty code blocks (add a space so they render properly)
    result = result.replace(/```(.*)\n```/g, '```$1\n \n```');
    return result;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addMessageToCell = addMessageToCell;
exports.getSelectedText = getSelectedText;
exports.getCurrentCellContent = getCurrentCellContent;
exports.insertCellContentByIndex = insertCellContentByIndex;
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
/**
 * Adds message content to the current cell in the active notebook.
 */
function addMessageToCell(text) {
    var _a;
    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (!cell || !cell.editor) {
        console.warn('Cannot add message: No active cell or editor found.');
        return;
    }
    try {
        const editor = cell.editor;
        // Access the underlying CodeMirror editor view (adjust if using a different editor)
        const view = editor.editor;
        if (!view) {
            console.warn('Cannot add message: CodeMirror view not accessible.');
            return;
        }
        // Get current cursor position
        const state = view.state;
        const selection = state.selection;
        const cursorPos = selection.main.head;
        // Insert newline and message content at cursor position
        const transaction = state.update({
            changes: {
                from: cursorPos,
                insert: `\n${text}`
            },
            // Optionally move cursor to end of inserted text
            selection: { anchor: cursorPos + text.length + 1 }
        });
        view.dispatch(transaction);
    }
    catch (error) {
        console.error('Error adding message to cell:', error);
    }
}
/**
 * Gets the currently selected text from the active notebook cell or text editor.
 */
function getSelectedText() {
    var _a, _b, _c;
    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (cell === null || cell === void 0 ? void 0 : cell.editor) {
        const editor = cell.editor;
        const cmEditor = editor.editor; // Access CodeMirror editor instance
        if (cmEditor && cmEditor.state) {
            const state = cmEditor.state;
            const selection = state.selection.main;
            return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);
        }
        console.warn("Could not access CodeMirror state to get selection.");
        return null;
    }
    else {
        // Fallback for non-notebook editors (e.g., text editor)
        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
        if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {
            const editor = activeWidget.content.editor;
            const cmEditor = editor.editor;
            if (cmEditor && cmEditor.state) {
                const state = cmEditor.state;
                const selection = state.selection.main;
                return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);
            }
            console.warn("Could not access CodeMirror state for non-notebook editor selection.");
            return null;
        }
    }
    return null;
}
/**
 * Gets the content of the currently active notebook cell or text editor.
 */
function getCurrentCellContent() {
    var _a, _b, _c, _d, _e;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {
        // Try using sharedModel first (more robust)
        if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {
            return activeCell.model.sharedModel.getSource();
        }
        // Fallback: Try using toJSON().source
        const cellJson = activeCell.model.toJSON();
        const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
        if (typeof source === 'string') {
            return source;
        }
        else if (Array.isArray(source)) {
            return source.join('\n');
        }
        console.warn("Could not get cell content via sharedModel or toJSON().source");
        return null;
    }
    // Fallback for non-notebook editors if needed
    const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
    if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {
        // Assuming model.value.text for generic text editors
        return (_e = (_d = activeWidget.content.model.value) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;
    }
    return null;
}
/**
 * Gets cell content by index from the current notebook and calls a callback to insert it.
 * NOTE: The original function called `this.appendToInput`. This functionality needs
 *       to be provided via the `insertCallback`.
 */
function insertCellContentByIndex(index, insertCallback) {
    try {
        if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {
            console.error('No active notebook found');
            return;
        }
        const notebookPanel = globals_1.globals.notebookTracker.currentWidget;
        const model = notebookPanel.content.model;
        if (!model || !model.cells || index < 0 || index >= model.cells.length) {
            console.error(`Invalid cell index: ${index}`);
            return;
        }
        const cell = model.cells.get(index);
        let cellContent = '';
        // Get cell content - handle different ways content might be stored
        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {
            cellContent = cell.sharedModel.getSource();
        }
        else {
            const cellJson = cell.toJSON();
            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
            if (typeof source === 'string') {
                cellContent = source;
            }
            else if (Array.isArray(source)) {
                cellContent = source.join('\n');
            }
        }
        // Insert cell reference with content using the callback
        insertCallback(`cell ${cellContent}`);
    }
    catch (error) {
        console.error('Error inserting cell by index:', error);
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy5iM2YxOWM2NzUwNDAxYzQyMjFhNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7Ozs7Ozs7OztBQzdJYjtBQUNiLDhDQUE2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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQscUNBQXFDO0FBQ3JDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jZWxsLWNvbnRleHQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb3JlL2FwaS1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY29yZS9nbG9iYWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NvcmUvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaGFuZGxlcnMvaGlzdG9yeS1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2hhbmRsZXJzL21lc3NhZ2UtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9wb3B1cC1tZW51LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaGFuZGxlcnMvc2V0dGluZ3MtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9zaG9ydGN1dC1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3NpZGViYXItd2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3N0YXRlL2NoYXQtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvc3RhdGUvc2V0dGluZ3Mtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdWkvY29kZS1yZWYtd2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL2RvbS1lbGVtZW50cy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91aS9sYXlvdXQtYnVpbGRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91aS9tZXNzYWdlLXJlbmRlcmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL3NldHRpbmdzLW1vZGFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL3VpLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdXRpbHMvY2xpcGJvYXJkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3V0aWxzL2hpZ2hsaWdodGluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91dGlscy9tYXJrZG93bi1jb25maWcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNlbGxDb250ZXh0VHJhY2tlciA9IHZvaWQgMDtcbi8qKlxuICogVHJhY2tzIGNlbGwgY29udGV4dCBhbmQgY3Vyc29yIHBvc2l0aW9uIHdpdGhpbiBKdXB5dGVyIG5vdGVib29rc1xuICovXG5jbGFzcyBDZWxsQ29udGV4dFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgbm90ZWJvb2tUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgZWRpdG9yIGV2ZW50cyAoa2V5ZG93biwgbW91c2V1cClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjZWxsIGZyb20gdGhlIHRyYWNrZXJcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwgfHwgIWNlbGwuZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5uZXIgRWRpdG9yVmlldyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEdldCBhbmQgc3RvcmUgdGhlIGN1cnNvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlZGl0b3IgZXZlbnQgaGFuZGxlcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlciA9IG5vdGVib29rVHJhY2tlcjtcbiAgICAgICAgdGhpcy5zZXR1cFRyYWNrZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBvYmplY3QgaGFzIGJlZW4gZGlzcG9zZWRcbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgdHJhY2tlcnNcbiAgICAgKi9cbiAgICBzZXR1cFRyYWNrZXJzKCkge1xuICAgICAgICAvLyBIYW5kbGUgYWN0aXZlIGNlbGwgY2hhbmdlc1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsQ2hhbmdlZC5jb25uZWN0KHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgLy8gSGFuZGxlIG5vdGVib29rIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuY29ubmVjdCh0aGlzLmhhbmRsZU5vdGVib29rQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBub3RlYm9vayBjaGFuZ2VzXG4gICAgICovXG4gICAgaGFuZGxlTm90ZWJvb2tDaGFuZ2UodHJhY2tlciwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHBhbmVsICYmIHBhbmVsLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBwYW5lbC5jb250ZW50LmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ2VsbExpc3RlbmVycyh0cmFja2VyLCBjZWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgYWN0aXZlIGNlbGxcbiAgICAgKi9cbiAgICBzZXR1cENlbGxMaXN0ZW5lcnMoX3RyYWNrZXIsIGNlbGwpIHtcbiAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICBpZiAoY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbE5vZGUgPSBjZWxsLm5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yTm9kZSA9IGNlbGxOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1FZGl0b3InKSB8fFxuICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtSW5wdXRBcmVhLWVkaXRvcicpO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBlZGl0b3JOb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIGZvciBrZXkgYW5kIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjYXB0dXJlIGltbWVkaWF0ZSBjb250ZXh0IGlmIEVkaXRvclZpZXcgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjZWxsLmVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IHRoaXMuZ2V0Q21Db250ZXh0KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdXAgY2VsbCBsaXN0ZW5lcnM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIHByZXZpb3VzIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY29udGV4dCBpbmZvcm1hdGlvbiBmcm9tIENvZGVNaXJyb3IgRWRpdG9yVmlld1xuICAgICAqL1xuICAgIGdldENtQ29udGV4dCh2aWV3KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgY29uc3QgZnVsbFRleHQgPSBzdGF0ZS5kb2MudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLm51bWJlciAtIDEsXG4gICAgICAgICAgICBjb2x1bW46IG9mZnNldCAtIGxpbmUuZnJvbSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHRSYWRpdXMgPSAxMDA7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgb2Zmc2V0IC0gY29udGV4dFJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGZ1bGxUZXh0Lmxlbmd0aCwgb2Zmc2V0ICsgY29udGV4dFJhZGl1cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBmdWxsVGV4dCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIGNvbnRleHRCZWZvcmU6IGZ1bGxUZXh0LnN1YnN0cmluZyhzdGFydCwgb2Zmc2V0KSxcbiAgICAgICAgICAgIGNvbnRleHRBZnRlcjogZnVsbFRleHQuc3Vic3RyaW5nKG9mZnNldCwgZW5kKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGNlbGwgY29udGV4dFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDZWxsQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENlbGxDb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuZGlzY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSBDZWxsQ29udGV4dFRyYWNrZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnaXN0ZXJDb21tYW5kcyA9IHJlZ2lzdGVyQ29tbWFuZHM7XG5jb25zdCB1aV9jb21wb25lbnRzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50c1wiKTsgLy8gSW1wb3J0IExhYkljb24gaWYgbmVlZGVkIGFzIHBsYWNlaG9sZGVyXG4vLyBQbGFjZWhvbGRlciBpY29uIChyZXBsYWNlIGlmIHlvdSBoYXZlIGEgc3BlY2lmaWMgaWNvbilcbmNvbnN0IGV4dGVuc2lvbkljb24gPSB1aV9jb21wb25lbnRzXzEuTGFiSWNvbi5yZXNvbHZlKHsgaWNvbjogJ3VpLWNvbXBvbmVudHM6anVweXRlcmxhYicgfSk7IC8vIFVzZSByZXNvbHZlIGZvciBidWlsdC1pblxuLyoqXG4gKiBSZWdpc3RlcnMgY29tbWFuZHMgZm9yIHRoZSBleHRlbnNpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcyhhcHAsIHBhbGV0dGUsIGxhdW5jaGVyLCBzaWRlYmFyV2lkZ2V0KSB7XG4gICAgLy8gQWRkIGNvbW1hbmQgdG8gdG9nZ2xlIHRoZSBzaWRlYmFyXG4gICAgYXBwLmNvbW1hbmRzLmFkZENvbW1hbmQoJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLCB7XG4gICAgICAgIGxhYmVsOiAnVG9nZ2xlIEFJIEFzc2lzdGFudCBTaWRlYmFyJyxcbiAgICAgICAgaWNvbjogZXh0ZW5zaW9uSWNvbixcbiAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZGViYXJXaWRnZXQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHNpZGViYXJXaWRnZXQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIGNvbW1hbmQgcGFsZXR0ZVxuICAgIHBhbGV0dGUuYWRkSXRlbSh7XG4gICAgICAgIGNvbW1hbmQ6ICdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdFeHRlbnNpb24nXG4gICAgfSk7XG4gICAgLy8gQWRkIGEgbGF1bmNoZXIgaXRlbVxuICAgIGxhdW5jaGVyLmFkZCh7XG4gICAgICAgIGNvbW1hbmQ6ICdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdPdGhlcicsXG4gICAgICAgIHJhbms6IDk5OTlcbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcGlDbGllbnQgPSB2b2lkIDA7XG4vKipcbiAqIEFQSSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIGJhY2tlbmQgTExNIHNlcnZpY2VcbiAqL1xuY2xhc3MgQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCcpIHtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIGEgY2hhdCByZXNwb25zZSBmcm9tIHRoZSBtb2NrIExMTVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSB1c2VyIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAqIEBwYXJhbSBjb250ZXh0IE9wdGlvbmFsIGNvbnRleHQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0gb25DaHVuayBDYWxsYmFjayBmb3IgZWFjaCB0ZXh0IGNodW5rIHJlY2VpdmVkXG4gICAgICogQHBhcmFtIG9uQ29tcGxldGUgQ2FsbGJhY2sgd2hlbiBzdHJlYW1pbmcgaXMgY29tcGxldGVcbiAgICAgKiBAcGFyYW0gb25FcnJvciBDYWxsYmFjayBmb3IgZXJyb3JzXG4gICAgICovXG4gICAgYXN5bmMgc3RyZWFtQ2hhdChtZXNzYWdlLCBjb250ZXh0ID0gbnVsbCwgb25DaHVuaywgb25Db21wbGV0ZSwgb25FcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2NoYXRgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlU3RyZWFtIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHVwIHN0cmVhbSByZWFkaW5nXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmU6IHJlYWRlckRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHJlYWRlckRvbmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiAhZG9uZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25DaHVuayhjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBoZWFsdGggY2hlY2sgZm9yIHRoZSBBUElcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSBBUEkgaXMgaGVhbHRoeVxuICAgICAqL1xuICAgIGFzeW5jIGhlYWx0aENoZWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2hlYWx0aGApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQVBJIGhlYWx0aCBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BcGlDbGllbnQgPSBBcGlDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2xvYmFscyA9IHZvaWQgMDtcbmV4cG9ydHMuaW5pdEdsb2JhbHMgPSBpbml0R2xvYmFscztcbi8qKlxuICogR2xvYmFsIHJlZmVyZW5jZXMgdG8ga2V5IGNvbXBvbmVudHMgaW4gdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZ2xvYmFscyA9IHt9O1xuLyoqXG4gKiBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzXG4gKi9cbmZ1bmN0aW9uIGluaXRHbG9iYWxzKGFwcCwgbm90ZWJvb2tUcmFja2VyKSB7XG4gICAgZXhwb3J0cy5nbG9iYWxzLmFwcCA9IGFwcDtcbiAgICBleHBvcnRzLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyID0gbm90ZWJvb2tUcmFja2VyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuc2lvbkljb24gPSB2b2lkIDA7XG5jb25zdCB1aV9jb21wb25lbnRzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50c1wiKTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEljb24gRGVmaW5pdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgaWNvblN2Z1N0ciA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJiaSBiaS1jaGF0LWxlZnQtdGV4dFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj4nICtcbiAgICAnPHBhdGggZD1cIk0xNCAxYTEgMSAwIDAgMSAxIDF2OGExIDEgMCAwIDEtMSAxSDQuNDE0QTIgMiAwIDAgMCAzIDExLjU4NmwtMiAyVjJhMSAxIDAgMCAxIDEtMWgxMnpNMiAwYTIgMiAwIDAgMC0yIDJ2MTIuNzkzYS41LjUgMCAwIDAgLjg1NC4zNTNsMi44NTMtMi44NTNBMSAxIDAgMCAxIDQuNDE0IDEySDE0YTIgMiAwIDAgMCAyLTJWMmEyIDIgMCAwIDAtMi0ySDJ6XCIvPicgK1xuICAgICc8cGF0aCBkPVwiTTMgMy41YS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOWEuNS41IDAgMCAxLS41LS41ek0zIDZhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05QS41LjUgMCAwIDEgMyA2em0wIDIuNWEuNS41IDAgMCAxIC41LS41aDVhLjUuNSAwIDAgMSAwIDFoLTVhLjUuNSAwIDAgMS0uNS0uNXpcIi8+JyArXG4gICAgJzwvc3ZnPic7XG4vKipcbiAqIEljb24gZm9yIHRoZSBBSSBBc3Npc3RhbnQgZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydHMuZXh0ZW5zaW9uSWNvbiA9IG5ldyB1aV9jb21wb25lbnRzXzEuTGFiSWNvbih7XG4gICAgbmFtZTogJ3NpbXBsZTppY29uJyxcbiAgICBzdmdzdHI6IGljb25TdmdTdHJcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhpc3RvcnlIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZV9yZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uL3VpL21lc3NhZ2UtcmVuZGVyZXJcIik7IC8vIEFzc3VtaW5nIHJlbmRlcmVycyBhcmUgbmVlZGVkXG4vKipcbiAqIE1hbmFnZXMgdGhlIGRpc3BsYXkgYW5kIGludGVyYWN0aW9uIGxvZ2ljIGZvciB0aGUgY2hhdCBoaXN0b3J5IHZpZXcuXG4gKi9cbmNsYXNzIEhpc3RvcnlIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGF0U3RhdGUsIHVpTWFuYWdlciwgY2FsbGJhY2tzLCByZW5kZXJlckNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGF0U3RhdGUgPSBjaGF0U3RhdGU7XG4gICAgICAgIHRoaXMudWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5yZW5kZXJlckNhbGxiYWNrcyA9IHJlbmRlcmVyQ2FsbGJhY2tzO1xuICAgICAgICAvLyBHZXQgdGhlIGhpc3RvcnkgY29udGFpbmVyIGVsZW1lbnQgZnJvbSBVSU1hbmFnZXJcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gdGhpcy51aU1hbmFnZXIuZ2V0VUlFbGVtZW50cygpLmhpc3RvcnlDb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYmV0d2VlbiB0aGUgbWFpbiBjaGF0IHZpZXcgYW5kIHRoZSBoaXN0b3J5IHZpZXcuXG4gICAgICovXG4gICAgdG9nZ2xlSGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9ICF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmU7XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFVzZSBVSU1hbmFnZXIgdG8gaGlkZSBjaGF0LCBzaG93IGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMudWlNYW5hZ2VyLnNob3dIaXN0b3J5VmlldygpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGF0SGlzdG9yeSgpOyAvLyBQb3B1bGF0ZSB0aGUgaGlzdG9yeSB2aWV3XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgVUlNYW5hZ2VyIHRvIHNob3cgY2hhdCwgaGlkZSBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLnVpTWFuYWdlci5zaG93Q2hhdFZpZXcoKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29ycmVjdCB0aXRsZSBpcyBkaXNwbGF5ZWQgd2hlbiBzd2l0Y2hpbmcgYmFja1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENoYXQgPSB0aGlzLmNoYXRTdGF0ZS5nZXRDdXJyZW50Q2hhdCgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MudXBkYXRlVGl0bGVJbnB1dChjdXJyZW50Q2hhdC50aXRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgbGlzdCBvZiBwYXN0IGNoYXRzIGluIHRoZSBoaXN0b3J5IGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICByZW5kZXJDaGF0SGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmlubmVySFRNTCA9ICcnOyAvLyBDbGVhciBwcmV2aW91cyBsaXN0XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSB0aGlzLmNoYXRTdGF0ZS5nZXRDaGF0SGlzdG9yeSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhdElkID0gdGhpcy5jaGF0U3RhdGUuZ2V0Q3VycmVudENoYXRJZCgpO1xuICAgICAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImpwLWxsbS1leHQtaGlzdG9yeS1lbXB0eVwiPk5vIGNoYXQgaGlzdG9yeSB5ZXQuPC9kaXY+JztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgbGlzdC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWxpc3QnO1xuICAgICAgICBoaXN0b3J5LmZvckVhY2goY2hhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICBsaXN0SXRlbS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWl0ZW0nO1xuICAgICAgICAgICAgaWYgKGNoYXQuaWQgPT09IGN1cnJlbnRDaGF0SWQpIHtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5jbGFzc0xpc3QuYWRkKCdqcC1sbG0tZXh0LWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2ltcGxlIHJlcHJlc2VudGF0aW9uOiBUaXRsZVxuICAgICAgICAgICAgLy8gVE9ETzogQWRkIHByZXZpZXcsIHRpbWVzdGFtcCwgZGVsZXRlIGJ1dHRvbiBldGMuXG4gICAgICAgICAgICBjb25zdCB0aXRsZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGl0bGVEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtLXRpdGxlJztcbiAgICAgICAgICAgIHRpdGxlRGl2LnRleHRDb250ZW50ID0gY2hhdC50aXRsZSB8fCAnVW50aXRsZWQgQ2hhdCc7XG4gICAgICAgICAgICBsaXN0SXRlbS5hcHBlbmRDaGlsZCh0aXRsZURpdik7XG4gICAgICAgICAgICAvLyBBZGQgY2xpY2sgZXZlbnQgdG8gbG9hZCB0aGUgY2hhdFxuICAgICAgICAgICAgbGlzdEl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmxvYWRDaGF0KGNoYXQuaWQpKTtcbiAgICAgICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmFwcGVuZENoaWxkKGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNwZWNpZmljIGNoYXQgc2Vzc2lvbiBmcm9tIGhpc3RvcnkgaW50byB0aGUgbWFpbiB2aWV3LlxuICAgICAqL1xuICAgIGxvYWRDaGF0KGNoYXRJZCkge1xuICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0U3RhdGUuZ2V0Q2hhdEJ5SWQoY2hhdElkKTtcbiAgICAgICAgaWYgKCFjaGF0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDaGF0IHdpdGggSUQgJHtjaGF0SWR9IG5vdCBmb3VuZC5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhpcyBjaGF0IGFzIHRoZSBhY3RpdmUgb25lIGluIHRoZSBzdGF0ZVxuICAgICAgICB0aGlzLmNoYXRTdGF0ZS5zZXRDdXJyZW50Q2hhdElkKGNoYXRJZCk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFpbiBVSSB0aXRsZSBpbnB1dFxuICAgICAgICB0aGlzLmNhbGxiYWNrcy51cGRhdGVUaXRsZUlucHV0KGNoYXQudGl0bGUpO1xuICAgICAgICAvLyBDbGVhciB0aGUgY3VycmVudCBtZXNzYWdlIGRpc3BsYXlcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuY2xlYXJNZXNzYWdlQ29udGFpbmVyKCk7XG4gICAgICAgIC8vIFJlLXBvcHVsYXRlIHRoZSBtZXNzYWdlIGNvbnRhaW5lciB3aXRoIG1lc3NhZ2VzIGZyb20gdGhlIGxvYWRlZCBjaGF0XG4gICAgICAgIC8vIFVzZSB0aGUgcmVuZGVyZXIgZnVuY3Rpb25zIHZpYSBjYWxsYmFja3NcbiAgICAgICAgY2hhdC5tZXNzYWdlcy5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChtc2cuc2VuZGVyID09PSAndXNlcicpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudCA9ICgwLCBtZXNzYWdlX3JlbmRlcmVyXzEucmVuZGVyVXNlck1lc3NhZ2UpKG1zZy50ZXh0LCB7IGlzTWFya2Rvd246IG1zZy5pc01hcmtkb3duIH0sIHRoaXMucmVuZGVyZXJDYWxsYmFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vICdib3QnXG4gICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlckJvdE1lc3NhZ2UpKG1zZy50ZXh0LCB7IGlzTWFya2Rvd246IG1zZy5pc01hcmtkb3duIH0sIHRoaXMucmVuZGVyZXJDYWxsYmFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIHRoZSBtZXNzYWdlIGNvbnRhaW5lciB2aWEgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZFJlbmRlcmVkTWVzc2FnZShtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTd2l0Y2ggYmFjayB0byB0aGUgY2hhdCB2aWV3IGlmIHdlIHdlcmUgaW4gdGhlIGhpc3Rvcnkgdmlld1xuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7IC8vIFRoaXMgd2lsbCBjYWxsIHVpTWFuYWdlci5zaG93Q2hhdFZpZXcoKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSBpbiBjaGF0IHZpZXcsIGVuc3VyZSBzY3JvbGxpbmcgaXMgY29ycmVjdFxuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcHRpb25hbDogUmUtcmVuZGVyIGhpc3RvcnkgbGlzdCB0byB1cGRhdGUgdGhlIGFjdGl2ZSBpdGVtIGluZGljYXRvclxuICAgICAgICAvLyBPbmx5IHJlYWxseSBuZWVkZWQgaWYgbm90IHN3aXRjaGluZyB2aWV3c1xuICAgICAgICAvLyBpZiAoIXRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSkgeyB0aGlzLnJlbmRlckNoYXRIaXN0b3J5KCk7IH1cbiAgICB9XG59XG5leHBvcnRzLkhpc3RvcnlIYW5kbGVyID0gSGlzdG9yeUhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vdWkvbWVzc2FnZS1yZW5kZXJlclwiKTtcbmNvbnN0IG5vdGVib29rX2ludGVncmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb25cIik7XG4vKipcbiAqIEhhbmRsZXMgc2VuZGluZyBtZXNzYWdlcywgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgQVBJLFxuICogbWFuYWdpbmcgc3RyZWFtaW5nIHJlc3BvbnNlcywgYW5kIHVwZGF0aW5nIHRoZSBVSSBhbmQgc3RhdGUuXG4gKi9cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGNoYXRTdGF0ZSwgdWlNYW5hZ2VyLCByZW5kZXJlckNhbGxiYWNrcywgaW5wdXRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmNoYXRTdGF0ZSA9IGNoYXRTdGF0ZTtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXJDYWxsYmFja3MgPSByZW5kZXJlckNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhbmQgc2VuZHMgYSB1c2VyLWluaXRpYXRlZCBtZXNzYWdlLlxuICAgICAqIEFsc28gaGFuZGxlcyBhZGRpbmcgdGhlIHVzZXIgbWVzc2FnZSB0byB0aGUgVUkgYW5kIGNsZWFyaW5nIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gMS4gQWRkIHVzZXIgbWVzc2FnZSB0byBVSSBhbmQgc3RhdGVcbiAgICAgICAgLy8gVE9ETzogUHJvY2VzcyBtZXNzYWdlIGZvciBjb2RlIHJlZnMgKGUuZy4sIHJlcGxhY2UgcGxhY2Vob2xkZXJzKVxuICAgICAgICBjb25zdCBwcm9jZXNzZWRNZXNzYWdlID0gbWVzc2FnZTsgLy8gUGxhY2Vob2xkZXIgZm9yIG5vd1xuICAgICAgICBjb25zdCBoYXNDb2RlUmVmcyA9IGZhbHNlOyAvLyBUT0RPOiBEZXRlcm1pbmUgdGhpcyBiYXNlZCBvbiBwcm9jZXNzaW5nXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShwcm9jZXNzZWRNZXNzYWdlLCAndXNlcicsIGhhc0NvZGVSZWZzLCB0cnVlKTtcbiAgICAgICAgLy8gMi4gQ2xlYXIgdGhlIGlucHV0IGZpZWxkICh1c2luZyBJbnB1dEhhbmRsZXIpXG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLmNsZWFySW5wdXQoKTtcbiAgICAgICAgLy8gMy4gU2VuZCBtZXNzYWdlIHRvIGJhY2tlbmQgYW5kIGhhbmRsZSBzdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgdGhpcy5zdHJlYW1BbmRSZW5kZXJSZXNwb25zZShwcm9jZXNzZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gYXV0b21hdGljIG1lc3NhZ2UgKGUuZy4sICdjb25maXJtZWQnLCAncmVqZWN0ZWQnKVxuICAgICAqIGFuZCBoYW5kbGVzIHRoZSBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICovXG4gICAgaGFuZGxlU2VuZEF1dG9NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnRyaW0oKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQXV0byBtZXNzYWdlcyBhcmUgdHlwaWNhbGx5IG5vdCBzYXZlZCBhcyB1c2VyIG1lc3NhZ2VzLCBcbiAgICAgICAgLy8gYnV0IHRoZSByZXNwb25zZSAqaXMqIHNhdmVkLlxuICAgICAgICB0aGlzLnN0cmVhbUFuZFJlbmRlclJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgVUkgdmlhIFVJTWFuYWdlciBhbmQgc2F2ZXMgdG8gQ2hhdFN0YXRlLlxuICAgICAqIChIZWxwZXIgbWV0aG9kLCBwb3RlbnRpYWxseSBjb3VsZCBsaXZlIGluIFVJTWFuYWdlciBvciBiZSBwYXJ0IG9mIGl0cyBjYWxsYmFjaylcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKHRleHQsIHNlbmRlciwgaXNNYXJrZG93biwgc2F2ZVRvSGlzdG9yeSkge1xuICAgICAgICAvLyBOb3RlOiBUaGlzIGR1cGxpY2F0ZXMgdGhlIGxvZ2ljIGZyb20gdGhlIG9sZCBTaW1wbGVTaWRlYmFyV2lkZ2V0LmFkZE1lc3NhZ2VcbiAgICAgICAgLy8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGhhdmUgVUlNYW5hZ2VyIGV4cG9zZSBhIG1ldGhvZCB0byBhZGQgYSByZW5kZXJlZCBtZXNzYWdlXG4gICAgICAgIC8vIGFuZCBDaGF0U3RhdGUgaGFuZGxlIHNhdmluZyBkaXJlY3RseS5cbiAgICAgICAgLy8gRm9yIG5vdywga2VlcCBpdCBoZXJlIGZvciBjbGFyaXR5IG9mIG1lc3NhZ2UgZmxvdy5cbiAgICAgICAgLy8gVE9ETzogQ2FsbCBhY3R1YWwgcmVuZGVyIGZ1bmN0aW9ucyBmcm9tIG1lc3NhZ2UtcmVuZGVyZXIudHMgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBqdXN0IGFkZGluZyBhIGRpdiBkaXJlY3RseS5cbiAgICAgICAgbGV0IG1lc3NhZ2VFbGVtZW50O1xuICAgICAgICBpZiAoc2VuZGVyID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2Ugd2l0aCByZW5kZXJVc2VyTWVzc2FnZSBjYWxsXG4gICAgICAgICAgICBtZXNzYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdXNlci1tZXNzYWdlJzsgLy8gRXhhbXBsZSBjbGFzc1xuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0OyAvLyBCYXNpYyByZW5kZXJpbmcgZm9yIG5vd1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVuZGVyQm90TWVzc2FnZSBpcyB1c2VkIGFmdGVyIHN0cmVhbWluZywgdGhpcyBwYXJ0IG1pZ2h0IGJlIHJlZHVuZGFudFxuICAgICAgICAgICAgLy8gb3Igb25seSBuZWVkZWQgaWYgd2UgYWRkIG5vbi1zdHJlYW1pbmcgYm90IG1lc3NhZ2VzLlxuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdC1tZXNzYWdlJzsgLy8gRXhhbXBsZSBjbGFzc1xuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0OyAvLyBCYXNpYyByZW5kZXJpbmcgZm9yIG5vd1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudWlNYW5hZ2VyLmFkZENoYXRNZXNzYWdlRWxlbWVudChtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgIGlmIChzYXZlVG9IaXN0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHsgdGV4dCwgc2VuZGVyLCBpc01hcmtkb3duIH07XG4gICAgICAgICAgICB0aGlzLmNoYXRTdGF0ZS5hZGRNZXNzYWdlVG9DdXJyZW50Q2hhdChtZXNzYWdlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29yZSBsb2dpYyBmb3Igc2VuZGluZyBhIG1lc3NhZ2UgdG8gdGhlIEFQSSwgaGFuZGxpbmcgdGhlIHN0cmVhbSxcbiAgICAgKiByZW5kZXJpbmcgdGhlIHJlc3BvbnNlLCBhbmQgc2F2aW5nIHRoZSBmaW5hbCBib3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzdHJlYW1BbmRSZW5kZXJSZXNwb25zZShtZXNzYWdlVG9TZW5kKSB7XG4gICAgICAgIC8vIC0tLSBQcmVwYXJlIHN0cmVhbWluZyBVSSBlbGVtZW50cyAobWFuYWdlZCBieSBVSU1hbmFnZXIpIC0tLVxuICAgICAgICAvLyBVSU1hbmFnZXIgc2hvdWxkIHByb3ZpZGUgYSBtZXRob2QgdG8gY3JlYXRlL2dldCB0aGVzZSBlbGVtZW50c1xuICAgICAgICBjb25zdCB7IHN0cmVhbWluZ0RpdiwgY29udGVudERpdiB9ID0gdGhpcy51aU1hbmFnZXIuY3JlYXRlQm90TWVzc2FnZUNvbnRhaW5lcigpO1xuICAgICAgICBsZXQgY29tcGxldGVSZXNwb25zZSA9ICcnO1xuICAgICAgICBjb25zdCBjZWxsQ29udGV4dCA9ICgwLCBub3RlYm9va19pbnRlZ3JhdGlvbl8xLmdldEN1cnJlbnRDZWxsQ29udGVudCkoKTsgLy8gVXNlIHV0aWxpdHlcbiAgICAgICAgLy8gU3RyZWFtIHJlc3BvbnNlIGZyb20gQVBJXG4gICAgICAgIHRoaXMuYXBpQ2xpZW50LnN0cmVhbUNoYXQobWVzc2FnZVRvU2VuZCwgeyBjZWxsQ29udGV4dCB9LCBcbiAgICAgICAgLy8gT24gY2h1bmsgcmVjZWl2ZWRcbiAgICAgICAgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlICs9IGNodW5rO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0ZW1wb3Jhcnkgc3RyZWFtaW5nIGRpdlxuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnRleHRDb250ZW50ID0gY29tcGxldGVSZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMudWlNYW5hZ2VyLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH0sIFxuICAgICAgICAvLyBPbiBjb21wbGV0ZVxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBIaWRlIHN0cmVhbWluZyBkaXYsIHNob3cgZmluYWwgY29udGVudCBkaXZcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgY29tcGxldGUgcmVzcG9uc2UgdXNpbmcgdGhlIHJlbmRlcmVyIGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZENvbnRlbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlckJvdE1lc3NhZ2UpKGNvbXBsZXRlUmVzcG9uc2UsIHsgaXNNYXJrZG93bjogdHJ1ZSB9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gJyc7IC8vIENsZWFyIHBsYWNlaG9sZGVyL3ByZXZpb3VzIGNvbnRlbnRcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZW5kZXJlZCBub2Rlcywgc2tpcHBpbmcgYW55IHBvdGVudGlhbCB3cmFwcGVyL2luZGljYXRvciBhZGRlZCBieSByZW5kZXJCb3RNZXNzYWdlIGl0c2VsZlxuICAgICAgICAgICAgd2hpbGUgKHJlbmRlcmVkQ29udGVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgaXMgdGhlIHNwZWNpZmljIG1hcmtkb3duIGluZGljYXRvciB3ZSBtaWdodCBhZGQvcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gT3IganVzdCBhcHBlbmQgZXZlcnl0aGluZyBpZiByZW5kZXJCb3RNZXNzYWdlIHJldHVybnMgdGhlIHB1cmUgY29udGVudFxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IHJlbmRlcmVkQ29udGVudC5maXJzdENoaWxkLmNsYXNzTGlzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKCdtYXJrZG93bi1pbmRpY2F0b3InKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERpdi5hcHBlbmRDaGlsZChyZW5kZXJlZENvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGluZGljYXRvciBpZiBpdCB3YXMgcGFydCBvZiB0aGUgcmV0dXJuZWQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDb250ZW50LnJlbW92ZUNoaWxkKHJlbmRlcmVkQ29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIGZpbmFsIGJvdCByZXNwb25zZSB0byBoaXN0b3J5IHZpYSBDaGF0U3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlzSW1hZ2UgPSBjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKS5zdGFydHNXaXRoKCcvaW1hZ2VzLycpOyAvLyBTaW1wbGUgY2hlY2tcbiAgICAgICAgICAgIGNvbnN0IGJvdE1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGNvbXBsZXRlUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgc2VuZGVyOiAnYm90JyxcbiAgICAgICAgICAgICAgICBpc01hcmtkb3duOiAhaXNJbWFnZSAvLyBTYXZlIGFzIG1hcmtkb3duIHVubGVzcyBpdCdzIGFuIGltYWdlIFVSTFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY2hhdFN0YXRlLmFkZE1lc3NhZ2VUb0N1cnJlbnRDaGF0KGJvdE1lc3NhZ2VEYXRhKTtcbiAgICAgICAgICAgIHRoaXMudWlNYW5hZ2VyLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH0sIFxuICAgICAgICAvLyBPbiBlcnJvclxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIEhpZGUgc3RyZWFtaW5nIGRpdiwgc2hvdyBmaW5hbCBjb250ZW50IGRpdiB3aXRoIGVycm9yXG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAvLyBVc2UgYSBkZWRpY2F0ZWQgZXJyb3IgcmVuZGVyaW5nIHN0eWxlL2NvbXBvbmVudCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJqcC1sbG0tZXh0LWVycm9yLW1lc3NhZ2VcIj5FcnJvcjogJHtlcnJvci5tZXNzYWdlfTwvZGl2PmA7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IE1lc3NhZ2VIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvcHVwTWVudU1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBhbmQgaW50ZXJhY3Rpb25zIG9mIHRoZSBtdWx0aS1sZXZlbCBwb3B1cCBtZW51LlxuICovXG5jbGFzcyBQb3B1cE1lbnVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NNYW5hZ2VyLCB3aWRnZXROb2RlLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gJ3RvcCc7XG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgIHRoaXMubWVudUhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBUcmFjayBjdXJyZW50bHkgc2VsZWN0ZWQgbWVudSBpdGVtXG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmdDb250ZW50ID0gZmFsc2U7IC8vIEZsYWcgdG8gcHJldmVudCByZWN1cnNpdmUgcmVuZGVyc1xuICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gJyc7IC8vIFRyYWNrIGxhc3Qgc2VhcmNoIHRlcm0gdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICAgICAgICB0aGlzLmFsbG93ZWRFeHRlbnNpb25zID0gWycucHknLCAnLmlweW5iJywgJy5tZCcsICcuanNvbicsICcudHh0JywgJy5jc3YnXTtcbiAgICAgICAgdGhpcy5maWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZG9jTWFuYWdlciA9IGRvY01hbmFnZXI7XG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZSA9IHdpZGdldE5vZGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIEF0dGFjaCB0byB0aGUgd2lkZ2V0IG5vZGUgaW5zdGVhZCBvZiB0aGUgYm9keVxuICAgICAgICB0aGlzLndpZGdldE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICAvLyBDcmVhdGUgc2VhcmNoIGlucHV0XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQucGxhY2Vob2xkZXIgPSAnU2VhcmNoLi4uJztcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LXNlYXJjaCc7IC8vIEFkZCBjbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICAvLyBVc2UgJ2lucHV0JyBldmVudCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHJlLXJlbmRlcmluZyBvbiBldmVyeSBrZXlzdHJva2VcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSBzZWFyY2ggdGVybSBoYXMgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgIT09IHRoaXMubGFzdFNlYXJjaFRlcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIYW5kbGUga2V5ZG93biBpbiBzZWFyY2ggaW5wdXQgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgbmF2aWdhdGlvbiBrZXlzXG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIFNlYXJjaCBLZXlEb3duOiBLZXk9JyR7ZXZlbnQua2V5fSdgKTtcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogUHJldmVudCB0aGVzZSBrZXlzIGZyb20gYmVpbmcgY2FwdHVyZWQgYnkgdGhlIGRvY3VtZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGlmIChbJ0Fycm93VXAnLCAnQXJyb3dEb3duJywgJ0VudGVyJywgJ1RhYicsICdFc2NhcGUnXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIChTZWFyY2ggSW5wdXQpOiBTdG9wcGluZyBwcm9wYWdhdGlvbiBmb3IgbmF2aWdhdGlvbiBrZXk6JywgZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgRXNjYXBlIGRpcmVjdGx5IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBzZWxlY3QgZmlyc3QgaXRlbSBvbiBFbnRlcj9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBhY3RpdmF0ZSB0aGUgaXRlbTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lbnVJdGVtc1swXS5jbGljaygpOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gZmlyc3QvbGFzdCBtZW51IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsdXIoKSB3aWxsIGJlIGhhbmRsZWQgYnkgbWFpbiBrZXkgaGFuZGxlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENSSVRJQ0FMOiBETyBOT1Qgc3RvcCBwcm9wYWdhdGlvbiBmb3IgQmFja3NwYWNlIG9yIG90aGVyIHRleHQgZWRpdGluZyBrZXlzXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBkZWZhdWx0IGJlaGF2aW9yIHRvIHdvcmsgcHJvcGVybHlcbiAgICAgICAgfSwgdHJ1ZSk7IC8vIFVzZSBjYXB0dXJlIHBoYXNlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IFVzZSBhIHNlcGFyYXRlIGJvdW5kIGZ1bmN0aW9uIGZvciB0aGUgZG9jdW1lbnQga2V5ZG93blxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZSBleGFjdCBzYW1lIGxpc3RlbmVyIGxhdGVyXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIGlmIChnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuY29ubmVjdCgoc2VuZGVyLCBub3RlYm9vaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgLy8gUmVtb3ZlIHVzaW5nIHRoZSBleGFjdCBzYW1lIGJvdW5kIGZ1bmN0aW9uXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHdpZGdldE5vZGUgaWYgYXR0YWNoZWRcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMud2lkZ2V0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmICF0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBhdEJ1dHRvbiA9IHRoaXMud2lkZ2V0Tm9kZS5xdWVyeVNlbGVjdG9yKCcjanAtbGxtLWV4dC1hdC1idXR0b24nKTtcbiAgICAgICAgICAgIGlmIChhdEJ1dHRvbiAmJiBhdEJ1dHRvbi5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBDbGljayB3YXMgb24gdGhlIEAgYnV0dG9uLCBub3QgaGlkaW5nLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQ2xpY2sgZGV0ZWN0ZWQgb3V0c2lkZSB0aGUgbWVudS4nKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNob3dQb3B1cE1lbnUoeCwgeSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNob3dpbmcgbWVudSBhdCAoJHt4fSwgJHt5fSlgKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGluaXRpYWwgYW5jaG9yIHBvaW50IGZvciBwb3NpdGlvbmluZ1xuICAgICAgICB0aGlzLl9hbmNob3JYID0geDtcbiAgICAgICAgdGhpcy5fYW5jaG9yWSA9IHk7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9ICd0b3AnO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHRoaXMubWVudUhpc3RvcnkgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIHNob3dcbiAgICAgICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSAnJzsgLy8gUmVzZXQgbGFzdCBzZWFyY2ggdGVybVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKTtcbiAgICAgICAgLy8gRW5zdXJlIGl0J3MgYXR0YWNoZWQgdG8gdGhlIHdpZGdldCBub2RlIGlmIHNvbWVob3cgZGV0YWNoZWRcbiAgICAgICAgdGhpcy53aWRnZXROb2RlLmFwcGVuZENoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHBvcHVwIG1lbnUgLSBoYW5kbGVkIGluIHVwZGF0ZVBvcHVwUG9zaXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIEZvY3VzIHRoZSBzZWFyY2ggaW5wdXQgaWYgd2UgYXJlIGluIGZpbGUvZGlyZWN0b3J5IHZpZXcsIG90aGVyd2lzZSBmb2N1cyB0aGUgZmlyc3QgaXRlbVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRm9jdXMgYWZ0ZXIgdGltZW91dCB0byBlbnN1cmUgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRm9jdXNlZCBzZWFyY2ggaW5wdXQnKTtcbiAgICAgICAgICAgIH0sIDUwKTsgLy8gU2xpZ2h0bHkgbG9uZ2VyIHRpbWVvdXRcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIERvbid0IHNlbGVjdCBhbiBpdGVtIGlmIHNlYXJjaCBpcyBmb2N1c2VkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCBhbmQgc2VsZWN0IHRoZSBmaXJzdCBtZW51IGl0ZW0gZm9yIHRvcCBsZXZlbFxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKSwgNTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGVQb3B1cE1lbnUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogSGlkaW5nIG1lbnUuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBleHBsaWNpdGx5IHJlbW92ZSBmcm9tIHdpZGdldE5vZGUgdW5sZXNzIGNhdXNpbmcgaXNzdWVzXG4gICAgICAgICAgICAvLyBJZiBwZXJmb3JtYW5jZSBiZWNvbWVzIGFuIGlzc3VlIHdpdGggbWFueSBtZW51cywgY29uc2lkZXIgcmVtb3ZpbmcvcmUtYWRkaW5nXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy53aWRnZXROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZW5kZXJNZW51Q29udGVudCgpIHtcbiAgICAgICAgLy8gUHJldmVudCByZWN1cnNpdmUgcmVuZGVyc1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogU2tpcHBpbmcgcmVuZGVyIC0gYWxyZWFkeSByZW5kZXJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm90IGF0IHRvcCBsZXZlbCwgYWRkIGEgc2VhcmNoIGlucHV0IGZvciBmaWx0ZXJpbmcgaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHNlYXJjaCBpbnB1dCBhdCB0aGUgdG9wIG9mIHRoZSBtZW51XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWFyY2hJbnB1dCk7XG4gICAgICAgICAgICAgICAgLy8gUGF0aCBkaXNwbGF5IGFuZCBiYWNrIGJ1dHRvbiByZW1vdmVkIGZvciBjbGVhbmVyIFVJXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW5kZXIgZGlmZmVyZW50IG1lbnUgY29udGVudCBiYXNlZCBvbiBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudE1lbnVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9wTGV2ZWxJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlyZWN0b3JpZXMnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZWxscyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyQ2VsbEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgc2VsZWN0aW9uIGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIHRvIG1haW50YWluIHRoZSBmaXhlZCBib3R0b20gZWRnZVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiB0aGlzLl9hbmNob3JYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fYW5jaG9yWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgcmVuZGVyaW5nIG1lbnUgY29udGVudCcsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVG9wTGV2ZWxJdGVtcygpIHtcbiAgICAgICAgY29uc3QgdG9wTGV2ZWxDb21tYW5kcyA9IFtcbiAgICAgICAgICAgIHsgbGFiZWw6ICdDb2RlJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2luc2VydC1jb2RlJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0NlbGxzJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2Jyb3dzZS1jZWxscycgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdGaWxlJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2Jyb3dzZS1maWxlcycgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdEaXJlY3RvcnknLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWRpcmVjdG9yaWVzJyB9XG4gICAgICAgIF07XG4gICAgICAgIHRvcExldmVsQ29tbWFuZHMuZm9yRWFjaChjbWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oY21kLmxhYmVsLCBjbWQuYWN0aW9uSWQsICcnLCBjbWQuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZW5kZXJEaXJlY3RvcnlCcm93c2VySXRlbXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gR2V0IHNlYXJjaCB0ZXJtXG4gICAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBjb25zdCBsb2FkaW5nSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ0xvYWRpbmcuLi4nLCAnbG9hZGluZycsICcnLCAnJyk7XG4gICAgICAgIGxvYWRpbmdJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGFkZCBsb2FkaW5nIGl0ZW0gYmVsb3cgc2VhcmNoL3BhdGhcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uUG9pbnQgPSAoX2EgPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1wb3B1cC1tZW51LXBhdGgnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHRTaWJsaW5nO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbnNlcnRCZWZvcmUobG9hZGluZ0l0ZW0sIGluc2VydGlvblBvaW50IHx8IG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgY29udGVudHMgd2VyZSBhbHJlYWR5IGZldGNoZWQgcmVjZW50bHkgYW5kIHdlJ3JlIGp1c3QgZmlsdGVyaW5nIGFnYWluLFxuICAgICAgICAgICAgLy8gd2UgY291bGQgcG90ZW50aWFsbHkgY2FjaGUgdGhlIHJlc3VsdHMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgQVBJIGNhbGxzXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJUeXBlID0gdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSc7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHRoaXMubGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyh0aGlzLmN1cnJlbnRNZW51UGF0aCwgZmlsdGVyVHlwZSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzdGlsbCBpbiBET00gYmVmb3JlIHRyeWluZyB0byByZW1vdmVcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMgJiYgY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBiYXNlZCBvbiBzZWFyY2ggdGVybVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ29udGVudHMgPSBjb250ZW50cy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZWxhdGl2ZVBhdGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRDb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29udGVudHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1OYW1lID0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtUGF0aCA9IGl0ZW0ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGl0ZW0ucmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5JyA/ICfwn5OBJyA6ICfwn5OEJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZCA9IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyA/ICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJyA6ICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpdGVtVHlwZSA9PT0gJ2ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWQgPSAnc2VsZWN0LWZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGAke2ljb259ICR7aXRlbU5hbWV9YCwgYWN0aW9uSWQsIGl0ZW1QYXRoLCByZWxhdGl2ZVBhdGggIT09ICcuJyA/IHJlbGF0aXZlUGF0aCA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKHNlYXJjaFRlcm0gPyAnTm8gbWF0Y2hlcyBmb3VuZCcgOiBgTm8gJHtmaWx0ZXJUeXBlfXMgZm91bmRgLCAnZW1wdHknLCAnJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBObyBpdGVtcyBmb3VuZCBpbiB0aGlzIGRpcmVjdG9yeWAsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBFcnJvcjogJHtlcnJvcn1gLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgbG9hZGluZy9maWx0ZXJpbmcgZGlyZWN0b3J5IGNvbnRlbnRzOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFsbCBjZWxscyBmcm9tIHRoZSBjdXJyZW50IG5vdGVib29rXG4gICAgICovXG4gICAgYXN5bmMgcmVuZGVyQ2VsbEl0ZW1zKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBHZXQgc2VhcmNoIHRlcm0gZm9yIGZpbHRlcmluZ1xuICAgICAgICBjb25zdCBzZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgY29uc3QgbG9hZGluZ0l0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdMb2FkaW5nIGNlbGxzLi4uJywgJ2xvYWRpbmcnLCAnJywgJycpO1xuICAgICAgICBsb2FkaW5nSXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IChfYSA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dFNpYmxpbmc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmluc2VydEJlZm9yZShsb2FkaW5nSXRlbSwgaW5zZXJ0aW9uUG9pbnQgfHwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSBub3RlYm9va1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnROb3RlYm9vayB8fCAhdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudCB8fCAhdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsb2FkaW5nIGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTm8gYWN0aXZlIG5vdGVib29rIGZvdW5kJywgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTW9kZWwgPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50Lm1vZGVsO1xuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBub3RlYm9va01vZGVsLmNlbGxzO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjZWxscyB8fCBjZWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdObyBjZWxscyBpbiBub3RlYm9vaycsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGFuZCBkaXNwbGF5IGVhY2ggY2VsbFxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkQ2VsbENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxUeXBlID0gY2VsbC50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZW50ID0gY2VsbC5zaGFyZWRNb2RlbCA/IGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCkgOlxuICAgICAgICAgICAgICAgICAgICAoKChfYiA9IGNlbGwudG9KU09OKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb3VyY2UpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdHlwZSBjYXN0aW5nIHRvIGF2b2lkIFR5cGVTY3JpcHQgZXJyb3JzXG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uQ291bnQgPSBjZWxsVHlwZSA9PT0gJ2NvZGUnID9cbiAgICAgICAgICAgICAgICAgICAgKGNlbGwuZXhlY3V0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjZWxsLmV4ZWN1dGlvbkNvdW50ICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZXhlY3V0aW9uQ291bnQgOiAnKicpIDpcbiAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJldmlldyBvZiB0aGUgY2VsbCBjb250ZW50ICh0cnVuY2F0ZSBpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFByZXZpZXcgPSB0eXBlb2YgY2VsbENvbnRlbnQgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgOlxuICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjZWxsQ29udGVudCkgPyBjZWxsQ29udGVudC5qb2luKCdcXG4nKSA6ICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSBjb250ZW50UHJldmlldy5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJ1bmNhdGVkQ29udGVudCA9IGZpcnN0TGluZS5sZW5ndGggPiAzMCA/XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TGluZS5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicgOlxuICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmU7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNlbGwgbGFiZWwgd2l0aCBzdHlsZWQgdHlwZSBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlSW5kaWNhdG9yID0gY2VsbFR5cGUgPT09ICdtYXJrZG93bicgPyAnTScgOiAnQyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uRGlzcGxheSA9IGV4ZWN1dGlvbkNvdW50ICE9PSAnJyA/IGBbJHtleGVjdXRpb25Db3VudH1dYCA6ICcnO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBtZW51IGl0ZW0gZm9yIHRoaXMgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnJywgLy8gRW1wdHkgdGV4dCwgd2lsbCBiZSBhZGRlZCBhcyBIVE1MXG4gICAgICAgICAgICAgICAgJ3NlbGVjdC1jZWxsJywgaS50b1N0cmluZygpIC8vIFN0b3JlIGNlbGwgaW5kZXggaW4gcGF0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN0eWxlZCBjb250ZW50IHdpdGggSFRNTCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIHR5cGVTcGFuLmNsYXNzTmFtZSA9IGBjZWxsLXR5cGUtaW5kaWNhdG9yIGNlbGwtdHlwZS0ke2NlbGxUeXBlID09PSAnbWFya2Rvd24nID8gJ21kJyA6ICdjb2RlJ31gO1xuICAgICAgICAgICAgICAgIHR5cGVTcGFuLnRleHRDb250ZW50ID0gdHlwZUluZGljYXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi5jbGFzc05hbWUgPSAnY2VsbC1leGVjLWNvdW50JztcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi50ZXh0Q29udGVudCA9IGV4ZWN1dGlvbkRpc3BsYXk7XG4gICAgICAgICAgICAgICAgZXhlY1NwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSAnOHB4JztcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBjb250ZW50U3Bhbi5jbGFzc05hbWUgPSAnY2VsbC1jb250ZW50LXByZXZpZXcnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTcGFuLnRleHRDb250ZW50ID0gdHJ1bmNhdGVkQ29udGVudDtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGxhYmVsIHNwYW4gKGZpcnN0IGNoaWxkIG9mIHRoZSBtZW51IGl0ZW0pXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxTcGFuID0gY2VsbEl0ZW0ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbFNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLnRleHRDb250ZW50ID0gJyc7IC8vIENsZWFyIGV4aXN0aW5nIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKHR5cGVTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3Bhbi5hcHBlbmRDaGlsZChleGVjU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKGNvbnRlbnRTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGZ1bGwgc2VhcmNoYWJsZSB0ZXh0XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoYWJsZVRleHQgPSBgJHt0eXBlSW5kaWNhdG9yfSAke2V4ZWN1dGlvbkRpc3BsYXl9ICR7dHJ1bmNhdGVkQ29udGVudH1gLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHNlYXJjaCB0ZXJtIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hUZXJtICYmICFzZWFyY2hhYmxlVGV4dC5pbmNsdWRlcyhzZWFyY2hUZXJtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoY2VsbEl0ZW0pO1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ2VsbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRDZWxsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub01hdGNoSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ05vIG1hdGNoaW5nIGNlbGxzIGZvdW5kJywgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBub01hdGNoSXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG5vTWF0Y2hJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShgRXJyb3I6ICR7ZXJyb3J9YCwgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckl0ZW0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEVycm9yIGxvYWRpbmcgbm90ZWJvb2sgY2VsbHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZU1lbnVJdGVtKHRleHQsIGFjdGlvbklkLCBwYXRoID0gJycsIGRlc2NyaXB0aW9uID0gJycpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbSc7XG4gICAgICAgIGl0ZW0uZGF0YXNldC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgaXRlbS5kYXRhc2V0LnBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ub25jbGljayA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNZW51Q2xpY2soZXZlbnQpO1xuICAgICAgICBjb25zdCBsYWJlbFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxhYmVsU3Bhbi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQobGFiZWxTcGFuKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHBhdGhTcGFuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aC1pbmRpY2F0b3InO1xuICAgICAgICAgICAgcGF0aFNwYW4udGV4dENvbnRlbnQgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIHBhdGhTcGFuLnN0eWxlLmZvbnRTaXplID0gJzAuODVlbSc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5jb2xvciA9ICd2YXIoLS1qcC11aS1mb250LWNvbG9yMiknO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUubWFyZ2luTGVmdCA9ICc4cHgnO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUub3BhY2l0eSA9ICcwLjgnO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snOyAvLyBFbnN1cmUgdGhlIHBhdGggaXMgYWx3YXlzIGRpc3BsYXllZFxuICAgICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChwYXRoU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZU1lbnVDbGljayhldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGFjdGlvbklkID0gdGFyZ2V0LmRhdGFzZXQuYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0YXJnZXQuZGF0YXNldC5wYXRoIHx8ICcnO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IE1lbnUgaXRlbSBjbGlja2VkLiBBY3Rpb246ICR7YWN0aW9uSWR9LCBQYXRoOiAke3BhdGh9YCk7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ25hdmlnYXRlLWJhY2snOlxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVCYWNrTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0LWNvZGUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5jYWxsYmFja3MuZ2V0U2VsZWN0ZWRUZXh0ID8gdGhpcy5jYWxsYmFja3MuZ2V0U2VsZWN0ZWRUZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBzdWJtZW51IGZvciBjb2RlIGluc2VydGlvbiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1lbnVJdGVtcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdJbnNlcnQgYXMgcGxhaW4gY29kZScsIGFjdGlvbklkOiAnaW5zZXJ0LXBsYWluLWNvZGUnLCBkYXRhOiBzZWxlY3RlZFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdJbnNlcnQgYXMgY29sbGFwc2VkIHJlZmVyZW5jZScsIGFjdGlvbklkOiAnY29sbGFwc2UtY29kZS1yZWYnLCBkYXRhOiBzZWxlY3RlZFRleHQgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGN1cnJlbnQgbWVudSB3aXRoIHN1Ym1lbnUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3VibWVudUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oaXRlbS5sYWJlbCwgaXRlbS5hY3Rpb25JZCwgaXRlbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrQnV0dG9uID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnQmFjaycsICduYXZpZ2F0ZS1iYWNrJyk7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tCdXR0b24uc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCB2YXIoLS1qcC1ib3JkZXItY29sb3IxKSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGJhY2tCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IGhpZGUgbWVudSwgd2FpdCBmb3Igc3VibWVudSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZW50ID0gdGhpcy5jYWxsYmFja3MuZ2V0Q3VycmVudENlbGxDb250ZW50ID8gdGhpcy5jYWxsYmFja3MuZ2V0Q3VycmVudENlbGxDb250ZW50KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUoY2VsbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0LXBsYWluLWNvZGUnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29sbGFwc2UtY29kZS1yZWYnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggJiYgdGhpcy5jdXJyZW50Tm90ZWJvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBub3RlYm9vayBmaWxlIG5hbWUgKHdpdGhvdXQgZXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYXRoID0gdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tOYW1lID0gKChfYSA9IG5vdGVib29rUGF0aC5zcGxpdCgnLycpLnBvcCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoJy4nKVswXSkgfHwgJ25vdGVib29rJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgY3VycmVudCBjZWxsIGluZGV4IGFuZCBhcHByb3hpbWF0ZSBsaW5lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50LmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgY2VsbCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgY2VsbCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENlbGxJbmRleCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRlbnQuYWN0aXZlQ2VsbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXN0aW1hdGUgbGluZSBudW1iZXIgZnJvbSBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lTnVtYmVyID0gMTsgLy8gRGVmYXVsdCB0byBsaW5lIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjdXJyZW50Q2VsbC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyID0gY3Vyc29yLmxpbmUgKyAxOyAvLyBDb252ZXJ0IHRvIDEtaW5kZXhlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29sbGFwc2VkQ29kZVJlZihwYXRoLCBjdXJyZW50Q2VsbEluZGV4LCBsaW5lTnVtYmVyLCBub3RlYm9va05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjb2xsYXBzZWQgY29kZSByZWZlcmVuY2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gaW5zZXJ0aW5nIGNvZGUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3Jvbmcgb3Igbm8gcGF0aCBwcm92aWRlZCwganVzdCBpbnNlcnQgYXMgcmVndWxhciBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2RlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1jZWxscyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2NlbGxzJywgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1maWxlcyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2ZpbGVzJywgdGhpcy5jdXJyZW50TWVudVBhdGggfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaCB3aGVuIGNoYW5naW5nIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1kaXJlY3Rvcmllcyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2RpcmVjdG9yaWVzJywgdGhpcy5jdXJyZW50TWVudVBhdGggfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaCB3aGVuIGNoYW5naW5nIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1jZWxsJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBwYXJzZUludChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihjZWxsSW5kZXgpICYmIHRoaXMuY2FsbGJhY2tzLmluc2VydENlbGxCeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDZWxsQnlJbmRleChjZWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogSW52YWxpZCBjZWxsIGluZGV4IG9yIGNhbGxiYWNrIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZmlsZSc6XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0RmlsZVBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEZpbGUgc2VsZWN0ZWQgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJzogLy8gTmV3IGFjdGlvbiB0byBuYXZpZ2F0ZSBpbnRvIGRpciB3aGVuIGluIGZpbGUgdmlld1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBmaWxlIGNhY2hlIGZvciB0aGUgc3BlY2lmaWMgZGlyZWN0b3J5IHRvIGZvcmNlIGEgcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGAke3BhdGh9OiR7dGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSd9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIHBhc3NpbmcgdGhlIGNvcnJlY3QgbGV2ZWwgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9ICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgOiAnZmlsZXMnO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudShsZXZlbCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIG5hdmlnYXRpb24gYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJzogLy8gTmV3IGFjdGlvbiB0byBzZWxlY3QgZGlyIHdoZW4gaW4gZGlyZWN0b3J5IHZpZXdcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnREaXJlY3RvcnlQYXRoKHBhdGgpOyAvLyBVc2UgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IERpcmVjdG9yeSBzZWxlY3RlZCBmb3IgY2FsbGJhY2sgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwbGFjZWhvbGRlci1hY3Rpb24nOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQbGFjZWhvbGRlciBhY3Rpb24gdHJpZ2dlcmVkLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgICBjYXNlICdlbXB0eSc6XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biBtZW51IGFjdGlvbjonLCBhY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlTWVudShsZXZlbCwgcGF0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IE5hdmlnYXRpbmcgdG8gbGV2ZWw6ICR7bGV2ZWx9LCBwYXRoOiAke3BhdGh9YCk7XG4gICAgICAgIC8vIE9ubHkgcHVzaCBoaXN0b3J5IGlmIHdlIGFyZSBhY3R1YWxseSBtb3ZpbmcgdG8gYSBuZXcgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5jdXJyZW50TWVudVBhdGggIT09IHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWVudUhpc3RvcnkucHVzaCh7IGxldmVsOiB0aGlzLmN1cnJlbnRNZW51TGV2ZWwsIHBhdGg6IHRoaXMuY3VycmVudE1lbnVQYXRoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IHBhdGg7XG4gICAgICAgIC8vIERvbid0IGNsZWFyIHNlYXJjaCBvbiBwcm9ncmFtbWF0aWMgbmF2aWdhdGlvbiAobGlrZSBiYWNrIGJ1dHRvbilcbiAgICAgICAgLy8gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBNYXliZSBrZWVwIHNlYXJjaCB0ZXJtP1xuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBhZnRlciBuYXZpZ2F0aW5nIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgaWYgKGxldmVsID09PSAnZmlsZXMnIHx8IGxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBSZXNldCBzZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdCBmaXJzdCBpdGVtIGlmIG5hdmlnYXRpbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCksIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5hdmlnYXRlQmFja01lbnUoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLm1lbnVIaXN0b3J5LnBvcCgpO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIGJhY2sgdG8gbGV2ZWw6ICR7cHJldmlvdXNTdGF0ZS5sZXZlbH0sIHBhdGg6ICR7cHJldmlvdXNTdGF0ZS5wYXRofWApO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gcHJldmlvdXNTdGF0ZS5sZXZlbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gcHJldmlvdXNTdGF0ZS5wYXRoO1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2xlYXIgc2VhcmNoIG9uIGJhY2sgbmF2aWdhdGlvblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBpZiBnb2luZyBiYWNrIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFJlc2V0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZpcnN0IGl0ZW0gaWYgZ29pbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQWxyZWFkeSBhdCB0aGUgdG9wIGxldmVsLicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyhiYXNlUGF0aCwgZmlsdGVyVHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IExpc3RpbmcgZGlyZWN0b3J5IGNvbnRlbnRzIGZvciBwYXRoOiAnJHtiYXNlUGF0aH0nLCBmaWx0ZXI6ICR7ZmlsdGVyVHlwZSB8fCAnYWxsJ31gKTtcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtiYXNlUGF0aH06JHtmaWx0ZXJUeXBlIHx8ICdhbGwnfWA7XG4gICAgICAgIGlmICh0aGlzLmZpbGVDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IFVzaW5nIGNhY2hlZCBkaXJlY3RvcnkgY29udGVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVDYWNoZS5nZXQoY2FjaGVLZXkpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVBhdGggPSBiYXNlUGF0aCA9PT0gJy8nID8gJycgOiBiYXNlUGF0aDtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSB1bmxlc3MgaXQncyByb290XG4gICAgICAgICAgICBjb25zdCBwYXRoRm9yQXBpID0gZWZmZWN0aXZlUGF0aC5lbmRzV2l0aCgnLycpICYmIGVmZmVjdGl2ZVBhdGgubGVuZ3RoID4gMSA/IGVmZmVjdGl2ZVBhdGguc2xpY2UoMCwgLTEpIDogZWZmZWN0aXZlUGF0aDtcbiAgICAgICAgICAgIC8vIFJlc3VsdCBhcnJheSB0aGF0IHdpbGwgaG9sZCBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICBsZXQgYWxsUmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIGRpcmVjdG9yeSBjb250ZW50cyAobm9uLXJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDb250ZW50cyA9IGF3YWl0IHRoaXMuZG9jTWFuYWdlci5zZXJ2aWNlcy5jb250ZW50cy5nZXQocGF0aEZvckFwaSB8fCAnJyk7XG4gICAgICAgICAgICBpZiAoYmFzZUNvbnRlbnRzLnR5cGUgIT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGF0aCBpcyBub3QgYSBkaXJlY3Rvcnk6JywgYmFzZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2VzcyBiYXNlIGRpcmVjdG9yeSBpdGVtc1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGJhc2VDb250ZW50cy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknID8gJ2RpcmVjdG9yeScgOiAnZmlsZSc7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGRpcmVjdG9yaWVzIGlmIHdlJ3JlIGxpc3RpbmcgZGlyZWN0b3JpZXMgb3IgYm90aFxuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2RpcmVjdG9yeScgJiYgKGZpbHRlclR5cGUgPT09ICdkaXJlY3RvcnknIHx8IGZpbHRlclR5cGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiBgLi8ke2l0ZW0ubmFtZX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgZmlsZXMgaWYgd2UncmUgbGlzdGluZyBmaWxlcyBhbmQgdGhlIGV4dGVuc2lvbiBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnZmlsZScgJiYgKGZpbHRlclR5cGUgPT09ICdmaWxlJyB8fCBmaWx0ZXJUeXBlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVFeHQgPSBgLiR7aXRlbS5uYW1lLnNwbGl0KCcuJykucG9wKCl9YC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlRXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGg6IGAuLyR7aXRlbS5uYW1lfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29ydCB0aGUgcmVzdWx0cyBhcHByb3ByaWF0ZWx5XG4gICAgICAgICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGlzdGluZyBkaXJlY3RvcmllcyBvbmx5LCBzb3J0IGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBsaXN0aW5nIGZpbGVzIG9ubHksIHNvcnQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBsaXN0aW5nIGJvdGgsIHNvcnQgZGlyZWN0b3JpZXMgZmlyc3QsIHRoZW4gZmlsZXMgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZGlyZWN0b3J5JyAmJiBiLnR5cGUgIT09ICdkaXJlY3RvcnknKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGEudHlwZSAhPT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlID09PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICB0aGlzLmZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIGFsbFJlc3VsdHMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBGb3VuZCAke2FsbFJlc3VsdHMubGVuZ3RofSBpdGVtcyBmb3IgcGF0aCAnJHtiYXNlUGF0aH0nYCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsUmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFBPUFVQOiBFcnJvciBsaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50cyBmb3IgJyR7YmFzZVBhdGh9JzpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGlyUGF0aCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcDtcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBBcHBsaWNhdGlvbiByZWZlcmVuY2Ugbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2hlbGxXaWRnZXQgPSBhcHAuc2hlbGwuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRTaGVsbFdpZGdldCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGV4dCA9IHRoaXMuZG9jTWFuYWdlci5jb250ZXh0Rm9yV2lkZ2V0KGN1cnJlbnRTaGVsbFdpZGdldCk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aWRnZXRDb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgZGlyUGF0aCA9IHRoaXMuZ2V0UGFyZW50RGlyZWN0b3J5KHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGN1cnJlbnQgd2lkZ2V0IGNvbnRleHQ6ICR7cGF0aH0gLT4gJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsICYmIHRoaXMuY3VycmVudE5vdGVib29rICYmIHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rUGF0aCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90ZWJvb2tQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSB0aGlzLmdldFBhcmVudERpcmVjdG9yeShub3RlYm9va1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGFjdGl2ZSBub3RlYm9vazogJHtub3RlYm9va1BhdGh9IC0+ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0V2lkZ2V0cyA9IEFycmF5LmZyb20oYXBwLnNoZWxsLndpZGdldHMoJ2xlZnQnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUJyb3dzZXJXaWRnZXQgPSBsZWZ0V2lkZ2V0cy5maW5kKHdpZGdldCA9PiB3aWRnZXQuaWQgPT09ICdmaWxlYnJvd3NlcicpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlQnJvd3NlcldpZGdldCAmJiB0eXBlb2YgKChfYSA9IGZpbGVCcm93c2VyV2lkZ2V0Lm1vZGVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpclBhdGggPSBmaWxlQnJvd3NlcldpZGdldC5tb2RlbC5wYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBhdGggZnJvbSBmaWxlIGJyb3dzZXIgd2lkZ2V0IG1vZGVsOiAke2RpclBhdGh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEZpbGUgYnJvd3NlciB3aWRnZXQgcGF0aCBub3QgZGlyZWN0bHkgYWNjZXNzaWJsZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUE9QVVA6IENvdWxkIG5vdCBnZXQgcGF0aCBmcm9tIGZpbGUgYnJvd3Nlci4nLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlyUGF0aCA9ICcnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGYWxsaW5nIGJhY2sgdG8gc2VydmVyIHJvb3QgcGF0aC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IGRpclBhdGg7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogSW5pdGlhbCBjdXJyZW50IG1lbnUgcGF0aCBzZXQgdG86ICcke3RoaXMuY3VycmVudE1lbnVQYXRofSdgKTtcbiAgICB9XG4gICAgZ2V0UGFyZW50RGlyZWN0b3J5KHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBNYXRoLm1heChwYXRoLmxhc3RJbmRleE9mKCcvJyksIHBhdGgubGFzdEluZGV4T2YoJ1xcXFxcXFxcJykpO1xuICAgICAgICBpZiAobGFzdFNsYXNoID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnJzsgLy8gTm8gZGlyZWN0b3J5IHBhcnQsIGxpa2VseSByb290IG9yIGp1c3QgYSBmaWxlbmFtZVxuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGtleWJvYXJkIG5hdmlnYXRpb24gd2hlbiB0aGUgcG9wdXAgbWVudSBpcyBzaG93blxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTa2lwIGlmIG1lbnUgbm90IHZpc2libGVcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBLZXlEb3duOiBLZXk9JyR7ZXZlbnQua2V5fScsIFRhcmdldD0nJHsoX2EgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YWdOYW1lfScsIFNlYXJjaEZvY3VzZWQ9JyR7ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5zZWFyY2hJbnB1dH0nYCk7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHdoZW4gc2VhcmNoIGlucHV0IGlzIGZvY3VzZWRcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuc2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBpbnB1dCdzIG93biBrZXlkb3duIGhhbmRsZXIgd2lsbCBoYW5kbGUgbW9zdCBrZXlzXG4gICAgICAgICAgICAvLyBCdXQgZm9yIGNlcnRhaW4ga2V5cyBsaWtlIGFycm93IGtleXMsIHdlIG1heSBuZWVkIHRvIG1vdmUgZm9jdXNcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSBzZWxlY3Rpb24gdG8gZmlyc3QvbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBEZWxheSBiZWZvcmUgbW92aW5nIGZvY3VzIC0gdGhpcyBnaXZlcyB0aW1lIGZvciB0aGUgc2VhcmNoIGlucHV0J3NcbiAgICAgICAgICAgICAgICAvLyBvd24ga2V5ZG93biBoYW5kbGVyIHRvIHByb2Nlc3MgdGhlIGtleSBmaXJzdFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBBcnJvd1VwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXNNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBGb3IgQmFja3NwYWNlIGluIHNlYXJjaCBpbnB1dCwganVzdCByZXR1cm4gd2l0aG91dCBoYW5kbGluZ1xuICAgICAgICAgICAgLy8gTGV0IHRoZSBkZWZhdWx0IGJlaGF2aW9yIGhhcHBlblxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0JhY2tzcGFjZScpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHBlcmZvcm0gZGVmYXVsdCBiZWhhdmlvciBpbiBzZWFyY2ggaW5wdXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZXQgYWxsIG90aGVyIGtleXMgYmUgaGFuZGxlZCBieSB0aGUgc2VhcmNoIGlucHV0J3Mgb3duIGhhbmRsZXJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGcm9tIGhlcmUsIHNlYXJjaCBpbnB1dCBpcyBOT1QgZm9jdXNlZFxuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IEFycm93RG93bicpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IEFycm93VXAnKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXNNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IEJhY2tzcGFjZScpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJldmVudCBkZWZhdWx0IGFuZCBuYXZpZ2F0ZSBiYWNrIGlmIHdlIGhhdmUgaGlzdG9yeVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lbnVIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVCYWNrTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IE5vIGhpc3RvcnksIGFsbG93aW5nIEJhY2tzcGFjZSBkZWZhdWx0IGFjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBkZWZhdWx0IC0gZG9uJ3QgcHJldmVudCBvciBzdG9wIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBFbnRlcicpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWN0aXZhdGUgaWYgYW4gaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA+PSAwICYmIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IDwgbWVudUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW1zW3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4XS5jbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IFRhYicpO1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIFRhYiBzdXBwb3J0OiBtb3ZlIGZvY3VzIGJldHdlZW4gc2VhcmNoIGFuZCBmaXJzdC9sYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbE1lbnVJdGVtcygpOyAvLyBEZXNlbGVjdCBpdGVtcyB3aGVuIHNlYXJjaCBnZXRzIGZvY3VzIHZpYSBUYWJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIGNsb3NlIG1lbnUgb24gVGFiIGZyb20gdG9wIGxldmVsPyBPciBkbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBFc2NhcGUnKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogRGVmYXVsdCBrZXkgJyR7ZXZlbnQua2V5fSdgKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0eXBpbmcgYSBjaGFyYWN0ZXIgYW5kIGluIGZpbGUvZGlyIHZpZXcsIGZvY3VzIHNlYXJjaFxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgY2hhcmFjdGVyIGFwcGVhcmluZyBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgYXBwZW5kIHRoZSB0eXBlZCBjaGFyYWN0ZXIgYXMgZm9jdXMgaGFwcGVucyBhZnRlciBrZXlkb3duIGRlZmF1bHQgYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgKz0gZXZlbnQua2V5O1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGlucHV0IGV2ZW50IG1hbnVhbGx5IHRvIHVwZGF0ZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIga2V5cyAoZS5nLiwgbW9kaWZpZXJzKSB0byBwYXNzIHRocm91Z2ggaWYgbm90IGhhbmRsZWRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQ6IEhpZ2hsaWdodGluZyBpbmRleCAke3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4fSBhbW9uZyAke21lbnVJdGVtcy5sZW5ndGh9IGl0ZW1zLmApO1xuICAgICAgICBtZW51SXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodDogQWRkZWQgJ3NlbGVjdGVkJyB0byBpdGVtICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBpdGVtIGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodDogUmVtb3ZlZCAnc2VsZWN0ZWQnIGZyb20gaXRlbSAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2VsZWN0QWxsTWVudUl0ZW1zKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBtZW51SXRlbXMuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgfVxuICAgIHNlbGVjdE5leHRNZW51SXRlbSgpIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgaWYgKCFtZW51SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgc2VsZWN0TmV4dDogTm8gaXRlbXMgdG8gc2VsZWN0LicpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTsgLy8gRW5zdXJlIGluZGV4IGlzIHJlc2V0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleDtcbiAgICAgICAgLy8gRGVzZWxlY3QgY3VycmVudCBmaXJzdCBpcyBoYW5kbGVkIGJ5IHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodFxuICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IGl0ZW0gb3IgbG9vcCBiYWNrIHRvIHRoZSBmaXJzdFxuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9ICh0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCArIDEpICUgbWVudUl0ZW1zLmxlbmd0aDtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIHNlbGVjdE5leHQ6IEluZGV4IGNoYW5nZWQgZnJvbSAke29sZEluZGV4fSB0byAke3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4fWApO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgIH1cbiAgICBzZWxlY3RQcmV2aW91c01lbnVJdGVtKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBpZiAoIW1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBzZWxlY3RQcmV2aW91czogTm8gaXRlbXMgdG8gc2VsZWN0LicpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTsgLy8gRW5zdXJlIGluZGV4IGlzIHJlc2V0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleDtcbiAgICAgICAgLy8gRGVzZWxlY3QgY3VycmVudCBmaXJzdCBpcyBoYW5kbGVkIGJ5IHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodFxuICAgICAgICAvLyBNb3ZlIHRvIHRoZSBwcmV2aW91cyBpdGVtIG9yIGxvb3AgdG8gdGhlIGxhc3RcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA8PSAwID9cbiAgICAgICAgICAgIG1lbnVJdGVtcy5sZW5ndGggLSAxIDogdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggLSAxO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgc2VsZWN0UHJldmlvdXM6IEluZGV4IGNoYW5nZWQgZnJvbSAke29sZEluZGV4fSB0byAke3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4fWApO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGludGVyYWN0aXZlIG1lbnUgaXRlbXNcbiAgICAgKi9cbiAgICBnZXRNZW51SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbSh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0nKSk7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgbm9uLWludGVyYWN0aXZlIGl0ZW1zIGxpa2UgbG9hZGluZywgZW1wdHksIGVycm9yXG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25JZCA9IGl0ZW0uZGF0YXNldC5hY3Rpb25JZDtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25JZCAhPT0gJ2xvYWRpbmcnICYmIGFjdGlvbklkICE9PSAnZW1wdHknICYmIGFjdGlvbklkICE9PSAnZXJyb3InO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBvcHVwIHBvc2l0aW9uLCBrZWVwaW5nIHRoZSBib3R0b20gZWRnZSBmaXhlZCBhdCB0aGUgYW5jaG9yIHBvaW50XG4gICAgICovXG4gICAgdXBkYXRlUG9wdXBQb3NpdGlvbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFuY2hvciBwb2ludHMgYXJlIGRlZmluZWRcbiAgICAgICAgY29uc3QgYW5jaG9yWCA9IChfYSA9IHRoaXMuX2FuY2hvclgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGNvbnN0IGFuY2hvclkgPSAoX2IgPSB0aGlzLl9hbmNob3JZKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgcG9wdXAgbWVudVxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHthbmNob3JYfXB4YDtcbiAgICAgICAgLy8gU2hvdyB0aGUgbWVudSBzbyB3ZSBjYW4gY2FsY3VsYXRlIGl0cyBoZWlnaHRcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIC8vIEdldCB0aGUgYWN0dWFsIGhlaWdodCBhZnRlciByZW5kZXJpbmdcbiAgICAgICAgY29uc3QgbWVudUhlaWdodCA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgLy8gQWRkIGEgc21hbGwgZ2FwICgxMHB4KSBiZXR3ZWVuIHRoZSBib3R0b20gb2YgdGhlIG1lbnUgYW5kIHRoZSB0cmlnZ2VyIHBvaW50XG4gICAgICAgIGNvbnN0IGdhcCA9IDEwO1xuICAgICAgICAvLyBQb3NpdGlvbiBhYm92ZSB0aGUgY3Vyc29yL2J1dHRvbiB0byBrZWVwIGJvdHRvbSBlZGdlIGF0IHRoZSBhbmNob3IgcG9pbnQ6XG4gICAgICAgIC8vIHkgLSBnYXAgPSBib3R0b20gZWRnZSBvZiBwb3B1cCwgc28gcG9wdXAgdG9wID0geSAtIGdhcCAtIG1lbnVIZWlnaHRcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUudG9wID0gYCR7YW5jaG9yWSAtIGdhcCAtIG1lbnVIZWlnaHR9cHhgO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBvc2l0aW9uZWQgbWVudSBhdCBoZWlnaHQgJHttZW51SGVpZ2h0fXB4IHdpdGggYm90dG9tIGF0ICR7YW5jaG9yWSAtIGdhcH1weGApO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IFBvcHVwTWVudU1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2V0dGluZ3NIYW5kbGVyID0gdm9pZCAwO1xuLy8gaW1wb3J0IHsgU2V0dGluZ3NNb2RhbCB9IGZyb20gJy4uL3VpL3NldHRpbmdzLW1vZGFsJzsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZCBpbXBvcnRcbi8qKlxuICogSGFuZGxlcyB0aGUgbG9naWMgcmVsYXRlZCB0byB0aGUgc2V0dGluZ3MgbW9kYWw6XG4gKiBkaXNwbGF5aW5nLCBoaWRpbmcsIHBvcHVsYXRpbmcsIHNhdmluZywgYW5kIHNob3dpbmcgZmVlZGJhY2suXG4gKi9cbmNsYXNzIFNldHRpbmdzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUsIFxuICAgIC8vIHN1Y2Nlc3NDYWxsYmFjazogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCwgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZCBwYXJhbWV0ZXJcbiAgICBzZXR0aW5nc01vZGFsQ29udGFpbmVyLCB1aU1hbmFnZXIgLy8gUGFzcyBVSU1hbmFnZXIgZm9yIG5vdGlmaWNhdGlvbnNcbiAgICApIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDsgLy8gUmVtb3ZlZDogdW51c2VkIHZhcmlhYmxlXG4gICAgICAgIC8vIHRoaXMuc3VjY2Vzc0NhbGxiYWNrID0gc3VjY2Vzc0NhbGxiYWNrOyAvLyBDb21tZW50ZWQgb3V0IC0gdW51c2VkIGFzc2lnbm1lbnRcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyID0gc2V0dGluZ3NNb2RhbENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgICAgIC8vIEF0dGFjaCBpbnRlcm5hbCBsaXN0ZW5lcnMgaWYgdGhlIG1vZGFsIGhhcyBpdHMgb3duIHNhdmUvY2FuY2VsIGJ1dHRvbnNcbiAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBtb2RhbCBlbGVtZW50IHdhcyBjcmVhdGVkIHdpdGggbGlzdGVuZXJzIGNhbGxpbmcgdGhlc2UgbWV0aG9kcy5cbiAgICAgICAgLy8gSWYgY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQgaW4gdWkvc2V0dGluZ3MtbW9kYWwudHMgYXR0YWNoZXMgbGlzdGVuZXJzIHRoYXQgXG4gICAgICAgIC8vIGNhbGwgY2FsbGJhY2tzIHBhc3NlZCBkdXJpbmcgY3JlYXRpb24sIHRoZW4gdGhpcyBoYW5kbGVyIGRvZXNuJ3QgbmVlZCBcbiAgICAgICAgLy8gdG8gYXR0YWNoIGxpc3RlbmVycyBkaXJlY3RseSwganVzdCBwcm92aWRlIHRoZSBjYWxsYmFja3MgKGUuZy4sIHRoaXMuc2F2ZVNldHRpbmdzLmJpbmQodGhpcykpLlxuICAgICAgICAvLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgdGhlIGNhbGxiYWNrcyBwYXNzZWQgdG8gY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQgaGFuZGxlIHRoaXMuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyB0aGUgc2V0dGluZ3MgZm9ybSB3aXRoIGN1cnJlbnQgdmFsdWVzIGFuZCBkaXNwbGF5cyB0aGUgbW9kYWwuXG4gICAgICovXG4gICAgc2hvd01vZGFsKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50U2V0dGluZ3MgPSB0aGlzLnN0YXRlLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChjdXJyZW50U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gUXVlcnkgZWxlbWVudHMgd2l0aGluIHRoZSBtb2RhbCBjb250YWluZXJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLXByb3ZpZGVyJykudmFsdWUgPSBjdXJyZW50U2V0dGluZ3MucHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1hcGkta2V5JykudmFsdWUgPSBjdXJyZW50U2V0dGluZ3MuYXBpS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLXVybCcpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLmFwaVVybDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLXJ1bGVzJykudmFsdWUgPSBjdXJyZW50U2V0dGluZ3MucnVsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwb3B1bGF0aW5nIHNldHRpbmdzIGZvcm06JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgc2hvdyBhbiBlcnJvciB0byB0aGUgdXNlclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgc2V0dGluZ3MgbW9kYWwuXG4gICAgICovXG4gICAgaGlkZU1vZGFsKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdmFsdWVzIGZyb20gdGhlIGZvcm0sIHNhdmVzIHRoZW0gdXNpbmcgU2V0dGluZ3NTdGF0ZSxcbiAgICAgKiB1cGRhdGVzIHRoZSBBcGlDbGllbnQsIGhpZGVzIHRoZSBtb2RhbCwgYW5kIHNob3dzIGEgc3VjY2VzcyBub3RpZmljYXRpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGJ5IHRoZSBtb2RhbCdzIHNhdmUgYnV0dG9uIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAvLyBHZXQgdmFsdWVzIGZyb20gZm9ybSBmaWVsZHMgd2l0aGluIHRoZSBtb2RhbCBjb250YWluZXJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSAoX2EgPSB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLXByb3ZpZGVyJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gKF9iID0gdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1hcGkta2V5JykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52YWx1ZTtcbiAgICAgICAgY29uc3QgdXJsID0gKF9jID0gdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1hcGktdXJsJykpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52YWx1ZTtcbiAgICAgICAgY29uc3QgcnVsZXMgPSAoX2QgPSB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLXJ1bGVzJykpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52YWx1ZTtcbiAgICAgICAgLy8gQmFzaWMgdmFsaWRhdGlvblxuICAgICAgICBpZiAocHJvdmlkZXIgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IHVuZGVmaW5lZCB8fCB1cmwgPT09IHVuZGVmaW5lZCB8fCBydWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGZpbmQgYWxsIHNldHRpbmdzIGlucHV0IGVsZW1lbnRzLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd05vdGlmaWNhdGlvbignRXJyb3I6IENvdWxkIG5vdCBzYXZlIHNldHRpbmdzLiBJbnB1dCBlbGVtZW50cyBtaXNzaW5nLicsICdlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0geyBwcm92aWRlciwgYXBpS2V5OiBrZXksIGFwaVVybDogdXJsLCBydWxlcyB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2F2ZSBzZXR0aW5ncyB1c2luZyBTZXR0aW5nc1N0YXRlXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNhdmVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQgdmlhIFNldHRpbmdzU3RhdGU6Jywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgLy8gUmVjb25maWd1cmUgQXBpQ2xpZW50IGluc3RhbmNlXG4gICAgICAgICAgICAvLyBUT0RPOiBUaGUgQXBpQ2xpZW50IHNob3VsZCBpZGVhbGx5IG9ic2VydmUgdGhlIFNldHRpbmdzU3RhdGUgXG4gICAgICAgICAgICAvLyBvciBoYXZlIGEgZGVkaWNhdGVkIHVwZGF0ZSBtZXRob2QgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIEZvciBub3csIHdlIGFzc3VtZSB0aGUgbWFpbiB3aWRnZXQgd2lsbCByZWNyZWF0ZS91cGRhdGUgdGhlIEFwaUNsaWVudCBcbiAgICAgICAgICAgIC8vIG9yIHBhc3MgYW4gdXBkYXRlIGNhbGxiYWNrLlxuICAgICAgICAgICAgLy8gRXhhbXBsZTogdGhpcy5hcGlDbGllbnQudXBkYXRlQ29uZmlnKHNldHRpbmdzLmFwaVVybCB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FQSSBDbGllbnQgbmVlZHMgcmVjb25maWd1cmF0aW9uIHdpdGggbmV3IHNldHRpbmdzLicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlTW9kYWwoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd05vdGlmaWNhdGlvbignU2V0dGluZ3Mgc2F2ZWQgc3VjY2Vzc2Z1bGx5JywgJ3N1Y2Nlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24oYEVycm9yIHNhdmluZyBzZXR0aW5nczogJHtlcnJvcn1gLCAnZXJyb3InKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhIHRlbXBvcmFyeSBub3RpZmljYXRpb24gbWVzc2FnZS5cbiAgICAgKiBSZWxpZXMgb24gVUlNYW5hZ2VyIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBub3RpZmljYXRpb24gbWVjaGFuaXNtLlxuICAgICAqL1xuICAgIHNob3dOb3RpZmljYXRpb24obWVzc2FnZSwgdHlwZSkge1xuICAgICAgICAvLyBEZWxlZ2F0ZSBub3RpZmljYXRpb24gZGlzcGxheSB0byBVSU1hbmFnZXIgb3IgYSBkZWRpY2F0ZWQgbm90aWZpY2F0aW9uIHNlcnZpY2VcbiAgICAgICAgaWYgKHRoaXMudWlNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLnVpTWFuYWdlci5zaG93Tm90aWZpY2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnVpTWFuYWdlci5zaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2UsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgb3IgbG9nIGlmIFVJTWFuYWdlciBkb2Vzbid0IHN1cHBvcnQgbm90aWZpY2F0aW9ucyB5ZXRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBOb3RpZmljYXRpb24gKCR7dHlwZX0pOiAke21lc3NhZ2V9YCk7XG4gICAgICAgICAgICAvLyBUaGUgb2xkIHBvcFNhdmVTdWNjZXNzIGxvZ2ljIHJlcXVpcmVzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIHdpZGdldCBub2RlLFxuICAgICAgICAgICAgLy8gd2hpY2ggdGhpcyBoYW5kbGVyIHNob3VsZG4ndCBoYXZlLiBUaGlzIG5lZWRzIHRvIGJlIGhhbmRsZWQgYnkgdGhlIFVJIGxheWVyLlxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZXR0aW5nc0hhbmRsZXIgPSBTZXR0aW5nc0hhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXBTaG9ydGN1dHMgPSBzZXR1cFNob3J0Y3V0cztcbmV4cG9ydHMucmVtb3ZlU2hvcnRjdXRzID0gcmVtb3ZlU2hvcnRjdXRzO1xuY29uc3Qgbm90ZWJvb2tfaW50ZWdyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi91dGlscy9ub3RlYm9vay1pbnRlZ3JhdGlvblwiKTtcbmxldCBfaGFuZGxlS2V5RG93biA9IG51bGw7XG4vKipcbiAqIFNldHMgdXAgZ2xvYmFsIGtleWJvYXJkIHNob3J0Y3V0cyBmb3IgdGhlIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0gaW5wdXRIYW5kbGVyIEluc3RhbmNlIG9mIElucHV0SGFuZGxlciB0byBpbnRlcmFjdCB3aXRoIGlucHV0IHN0YXRlL21ldGhvZHMuXG4gKiBAcGFyYW0gcG9wdXBNZW51TWFuYWdlciBJbnN0YW5jZSBvZiBQb3B1cE1lbnVNYW5hZ2VyLlxuICogQHBhcmFtIGNhbGxiYWNrcyBPYmplY3QgY29udGFpbmluZyBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIFVJIGludGVyYWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gc2V0dXBTaG9ydGN1dHMoaW5wdXRIYW5kbGVyLCAvLyBQYXNzIElucHV0SGFuZGxlciBpbnN0YW5jZSBkaXJlY3RseVxucG9wdXBNZW51TWFuYWdlciwgY2FsbGJhY2tzKSB7XG4gICAgaWYgKF9oYW5kbGVLZXlEb3duKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2hvcnRjdXRzIGFscmVhZHkgc2V0IHVwLiBSZW1vdmluZyBwcmV2aW91cyBsaXN0ZW5lci4nKTtcbiAgICAgICAgcmVtb3ZlU2hvcnRjdXRzKCk7XG4gICAgfVxuICAgIF9oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2hvd0luZGljYXRvciwgYXBwZW5kVG9JbnB1dCwgc2hvd1dpZGdldCwgZm9jdXNJbnB1dCB9ID0gY2FsbGJhY2tzO1xuICAgICAgICAvLyBDaGVjayBmb3IgQCBrZXlcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGlucHV0IGZpZWxkIGlzIHRoZSBhY3RpdmUgZWxlbWVudFxuICAgICAgICAgICAgLy8gV2UgcmVseSBvbiBJbnB1dEhhbmRsZXIgcG90ZW50aWFsbHkgbWFuYWdpbmcgZm9jdXMgb3IgYXNzdW1lIGl0IGlzIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICBjb25zdCBpbnB1dEZpZWxkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgLy8gQSBiaXQgZnJhZ2lsZVxuICAgICAgICAgICAgaWYgKGlucHV0RmllbGQgJiYgaW5wdXRGaWVsZC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmIGlucHV0RmllbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcC1sbG0tZXh0LWlucHV0LWZpZWxkJykpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBpbnB1dEZpZWxkLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEJlZm9yZUN1cnNvciA9IGlucHV0RmllbGQudmFsdWUuc3Vic3RyaW5nKDAsIGN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gdG8gc2hvdyBtZW51IChzaW1wbGlmaWVkIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRSZWN0ID0gaW5wdXRGaWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXRGaWVsZCkubGluZUhlaWdodCkgfHwgMjA7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXNCZWZvcmVDdXJzb3IgPSAodGV4dEJlZm9yZUN1cnNvci5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yVG9wID0gaW5wdXRSZWN0LnRvcCArIChsaW5lc0JlZm9yZUN1cnNvciAqIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpbnB1dFJlY3QubGVmdCArIDEwOyAvLyBTaW1wbGlmaWVkIGhvcml6b250YWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgQCBzeW1ib2wgYXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBpbnB1dEZpZWxkLnZhbHVlLnN1YnN0cmluZygwLCBjdXJzb3JQb3NpdGlvbikgK1xuICAgICAgICAgICAgICAgICAgICAnQCcgK1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEZpZWxkLnZhbHVlLnN1YnN0cmluZyhjdXJzb3JQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaW5wdXRGaWVsZC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBoYXMgQCBzeW1ib2wgZmxhZyB2aWEgSW5wdXRIYW5kbGVyXG4gICAgICAgICAgICAgICAgaW5wdXRIYW5kbGVyLnNldEhhc0F0U3ltYm9sKHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIHRoZSBAIHN5bWJvbFxuICAgICAgICAgICAgICAgIGlucHV0RmllbGQuc2VsZWN0aW9uU3RhcnQgPSBjdXJzb3JQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICAgICAgaW5wdXRGaWVsZC5zZWxlY3Rpb25FbmQgPSBjdXJzb3JQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgcG9wdXAgbWVudVxuICAgICAgICAgICAgICAgIHBvcHVwTWVudU1hbmFnZXIuc2hvd1BvcHVwTWVudShsZWZ0ICsgNjAsIGN1cnNvclRvcCAtIDIwKTsgLy8gQWRqdXN0IHBvc2l0aW9uaW5nIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgIHNob3dJbmRpY2F0b3IoJ0Jyb3dzZSBjZWxscywgY29kZSwgZmlsZXMsIGFuZCBtb3JlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIEN0cmwrTCAoaW5zZXJ0IHNlbGVjdGlvbiBvciBjZWxsKVxuICAgICAgICBlbHNlIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpID09PSAnbCcpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gKDAsIG5vdGVib29rX2ludGVncmF0aW9uXzEuZ2V0U2VsZWN0ZWRUZXh0KSgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9JbnB1dChgQGNvZGUgJHtzZWxlY3RlZH1gKTsgLy8gVXNlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgc2hvd0luZGljYXRvcignU2VsZWN0ZWQgY29kZSBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSAoMCwgbm90ZWJvb2tfaW50ZWdyYXRpb25fMS5nZXRDdXJyZW50Q2VsbENvbnRlbnQpKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFRvSW5wdXQoYEBjZWxsICR7Y2VsbENvbnRlbnR9YCk7IC8vIFVzZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBzaG93SW5kaWNhdG9yKCdDZWxsIGNvbnRlbnQgaW5zZXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZGViYXIgaXMgdmlzaWJsZSBhbmQgaW5wdXQgaXMgZm9jdXNlZFxuICAgICAgICAgICAgc2hvd1dpZGdldCgpOyAvLyBVc2UgY2FsbGJhY2tcbiAgICAgICAgICAgIGZvY3VzSW5wdXQoKTsgLy8gVXNlIGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGRvY3VtZW50XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF9oYW5kbGVLZXlEb3duKTtcbn1cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2xvYmFsIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiByZW1vdmVTaG9ydGN1dHMoKSB7XG4gICAgaWYgKF9oYW5kbGVLZXlEb3duKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBfaGFuZGxlS2V5RG93bik7XG4gICAgICAgIF9oYW5kbGVLZXlEb3duID0gbnVsbDtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlbW92ZWQga2V5Ym9hcmQgc2hvcnRjdXRzLicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdBdHRlbXB0ZWQgdG8gcmVtb3ZlIHNob3J0Y3V0cywgYnV0IG5vbmUgd2VyZSBhY3RpdmUuJyk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGxhdW5jaGVyXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbGF1bmNoZXJcIik7XG5jb25zdCBhcHB1dGlsc18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2FwcHV0aWxzXCIpO1xuY29uc3Qgbm90ZWJvb2tfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9ub3RlYm9va1wiKTtcbmNvbnN0IGRvY21hbmFnZXJfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9kb2NtYW5hZ2VyXCIpO1xuY29uc3Qgc2lkZWJhcl93aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3NpZGViYXItd2lkZ2V0XCIpO1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vY29yZS9nbG9iYWxzXCIpO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCIuL2NvbW1hbmRzXCIpO1xuY29uc3QgY2VsbF9jb250ZXh0X3RyYWNrZXJfMSA9IHJlcXVpcmUoXCIuL2NlbGwtY29udGV4dC10cmFja2VyXCIpO1xuLy8gaW1wb3J0IHsgQXBpQ2xpZW50IH0gZnJvbSAnLi9hcGktY2xpZW50Jztcbi8vIEltcG9ydCB0aGUgbWFpbiBDU1MgZmlsZVxucmVxdWlyZShcIi4uL3N0eWxlL2luZGV4LmNzc1wiKTtcbi8vIEV4cG9ydCBBcGlDbGllbnQgZm9yIHVzZSBieSBvdGhlciBjb21wb25lbnRzXG52YXIgYXBpX2NsaWVudF8xID0gcmVxdWlyZShcIi4vY29yZS9hcGktY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBpQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcGlfY2xpZW50XzEuQXBpQ2xpZW50OyB9IH0pO1xuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBkYXRhIGZvciB0aGUganVweXRlci1zaW1wbGUtZXh0ZW5zaW9uIGV4dGVuc2lvbi5cbiAqL1xuY29uc3QgcGx1Z2luID0ge1xuICAgIGlkOiAnanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uOnBsdWdpbicsXG4gICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbbGF1bmNoZXJfMS5JTGF1bmNoZXIsIGFwcHV0aWxzXzEuSUNvbW1hbmRQYWxldHRlLCBub3RlYm9va18xLklOb3RlYm9va1RyYWNrZXIsIGRvY21hbmFnZXJfMS5JRG9jdW1lbnRNYW5hZ2VyXSxcbiAgICBhY3RpdmF0ZTogKGp1cHl0ZXJBcHAsIGxhdW5jaGVyLCBwYWxldHRlLCB0cmFja2VyLCBkb2NNYW5hZ2VyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKdXB5dGVyTGFiIGV4dGVuc2lvbiBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gaXMgYWN0aXZhdGVkIScpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzXG4gICAgICAgICgwLCBnbG9iYWxzXzEuaW5pdEdsb2JhbHMpKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNlbGwgY29udGV4dCB0cmFja2VyXG4gICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlciA9IG5ldyBjZWxsX2NvbnRleHRfdHJhY2tlcl8xLkNlbGxDb250ZXh0VHJhY2tlcihqdXB5dGVyQXBwLCB0cmFja2VyKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgc2lkZWJhciB3aWRnZXRcbiAgICAgICAgY29uc3Qgc2lkZWJhcldpZGdldCA9IG5ldyBzaWRlYmFyX3dpZGdldF8xLlNpbXBsZVNpZGViYXJXaWRnZXQoZG9jTWFuYWdlcik7XG4gICAgICAgIGp1cHl0ZXJBcHAuc2hlbGwuYWRkKHNpZGViYXJXaWRnZXQsICdsZWZ0JywgeyByYW5rOiA5OTk5IH0pO1xuICAgICAgICAvLyBSZWdpc3RlciBjb21tYW5kc1xuICAgICAgICAoMCwgY29tbWFuZHNfMS5yZWdpc3RlckNvbW1hbmRzKShqdXB5dGVyQXBwLCBwYWxldHRlLCBsYXVuY2hlciwgc2lkZWJhcldpZGdldCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBsdWdpbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW1wbGVTaWRlYmFyV2lkZ2V0ID0gdm9pZCAwO1xuY29uc3Qgd2lkZ2V0c18xID0gcmVxdWlyZShcIkBsdW1pbm8vd2lkZ2V0c1wiKTtcbmNvbnN0IGljb25zXzEgPSByZXF1aXJlKFwiLi9jb3JlL2ljb25zXCIpO1xuY29uc3QgYXBpX2NsaWVudF8xID0gcmVxdWlyZShcIi4vY29yZS9hcGktY2xpZW50XCIpO1xuY29uc3QgcG9wdXBfbWVudV9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9wb3B1cC1tZW51LW1hbmFnZXJcIik7XG5jb25zdCBzaG9ydGN1dF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9zaG9ydGN1dC1oYW5kbGVyXCIpO1xuY29uc3QgbGF5b3V0X2J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3VpL2xheW91dC1idWlsZGVyXCIpO1xuY29uc3Qgc2V0dGluZ3NfbW9kYWxfMSA9IHJlcXVpcmUoXCIuL3VpL3NldHRpbmdzLW1vZGFsXCIpO1xuY29uc3QgY2hhdF9zdGF0ZV8xID0gcmVxdWlyZShcIi4vc3RhdGUvY2hhdC1zdGF0ZVwiKTtcbmNvbnN0IHNldHRpbmdzX3N0YXRlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9zZXR0aW5ncy1zdGF0ZVwiKTtcbmNvbnN0IG1lc3NhZ2VfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvbWVzc2FnZS1oYW5kbGVyXCIpO1xuY29uc3QgaGlzdG9yeV9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9oaXN0b3J5LWhhbmRsZXJcIik7XG5jb25zdCBzZXR0aW5nc19oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9zZXR0aW5ncy1oYW5kbGVyXCIpO1xuY29uc3QgdWlfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vdWkvdWktbWFuYWdlclwiKTtcbi8vIC0tLSBJbXBvcnQgVXRpbGl0eSBGdW5jdGlvbnMgLS0tXG5jb25zdCBjbGlwYm9hcmRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NsaXBib2FyZFwiKTtcbmNvbnN0IG5vdGVib29rX2ludGVncmF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy9ub3RlYm9vay1pbnRlZ3JhdGlvblwiKTtcbi8vIEltcG9ydCB0aGUgbmV3IFVJIGhlbHBlclxuY29uc3QgY29kZV9yZWZfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi91aS9jb2RlLXJlZi13aWRnZXRcIik7XG4vKipcbiAqIE1haW4gc2lkZWJhciB3aWRnZXQgZm9yIHRoZSBBSSBjaGF0IGludGVyZmFjZSAtIE5vdyBhY3RzIGFzIGFuIG9yY2hlc3RyYXRvci5cbiAqL1xuY2xhc3MgU2ltcGxlU2lkZWJhcldpZGdldCBleHRlbmRzIHdpZGdldHNfMS5XaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgZm9yIG1lbnUgY2FsbGJhY2tzXG4gICAgICAgIHRoaXMubWVudUFjdGlvbkNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGluc2VydENvZGU6IChjb2RlKSA9PiB0aGlzLmlucHV0SGFuZGxlci5hcHBlbmRUb0lucHV0KGBcXG5cXGBcXGBcXGBcXG4ke2NvZGV9XFxuXFxgXFxgXFxgXFxuYCksXG4gICAgICAgICAgICBpbnNlcnRDZWxsOiAoY29udGVudCkgPT4geyB9LFxuICAgICAgICAgICAgaW5zZXJ0RmlsZVBhdGg6IChwYXRoKSA9PiB0aGlzLmlucHV0SGFuZGxlci5hcHBlbmRUb0lucHV0KGAgJHtwYXRofWApLFxuICAgICAgICAgICAgaW5zZXJ0RGlyZWN0b3J5UGF0aDogKHBhdGgpID0+IHRoaXMuaW5wdXRIYW5kbGVyLmFwcGVuZFRvSW5wdXQoYCAke3BhdGh9YCksXG4gICAgICAgICAgICBnZXRTZWxlY3RlZFRleHQ6ICgpID0+IHsgLyogVE9ETzogSW1wbGVtZW50IGdldCBzZWxlY3RlZCB0ZXh0ICovIHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZ2V0Q3VycmVudENlbGxDb250ZW50OiAoKSA9PiB7IC8qIFRPRE86IEltcGxlbWVudCBnZXQgY3VycmVudCBjZWxsICovIHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgaW5zZXJ0Q2VsbEJ5SW5kZXg6IChpbmRleCkgPT4geyB9LFxuICAgICAgICAgICAgaW5zZXJ0Q29sbGFwc2VkQ29kZVJlZjogKGNvZGUsIGNlbGxJbmRleCwgbGluZU51bWJlciwgbm90ZWJvb2tOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLmlucHV0SGFuZGxlci5hZGRDb2RlUmVmZXJlbmNlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLmFwcGVuZFRvSW5wdXQoYCBbJHtyZWZJZH06JHtub3RlYm9va05hbWV9IGNlbGwgJHtjZWxsSW5kZXggKyAxfSBsaW5lICR7bGluZU51bWJlcn1dYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFBsYWNlaG9sZGVyIGZvciBoYW5kbGVyIG1ldGhvZHMgdXNlZCBpbiBVSU1hbmFnZXIgY2FsbGJhY2tzXG4gICAgICAgIHRoaXMuaGFuZGxlTmV3Q2hhdCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGUgTmV3IENoYXQgY2xpY2tlZCcpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHRoaXMuY2hhdFN0YXRlLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaGlzdG9yeUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2FkQ2hhdChuZXdDaGF0LmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb2dnbGVIaXN0b3J5ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hhbmRsZSBUb2dnbGUgSGlzdG9yeSBjbGlja2VkJyk7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlIYW5kbGVyLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFNlbmQgTWVzc2FnZSBjYWxsZWQgZnJvbSBVSSBNYW5hZ2VyIGNhbGxiYWNrJyk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBJbnB1dEhhbmRsZXIncyBpbnRlcm5hbCBsb2dpYyB3aGljaCB0aGVuIGNhbGxzIE1lc3NhZ2VIYW5kbGVyXG4gICAgICAgICAgICAvLyBUaGlzIGZlZWxzIHNsaWdodGx5IHJlZHVuZGFudCAtIG1heWJlIElucHV0SGFuZGxlciBzaG91bGQgdHJpZ2dlciBzZW5kIGRpcmVjdGx5P1xuICAgICAgICAgICAgLy8gT3IgbWF5YmUgdGhpcyBjYWxsYmFjayBzaG91bGRuJ3QgZXhpc3QgYW5kIFVJTWFuYWdlciBjYWxscyBJbnB1dEhhbmRsZXIgZGlyZWN0bHk/XG4gICAgICAgICAgICAvLyBGb3Igbm93LCBzaW11bGF0ZSBFbnRlciBwcmVzcyBsb2dpYzpcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMubGF5b3V0RWxlbWVudHMuaW5wdXRGaWVsZDsgLy8gR2V0IGZyb20gbGF5b3V0RWxlbWVudHNcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleXByZXNzJywgeyBrZXk6ICdFbnRlcicsIGJ1YmJsZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2hvd1NldHRpbmdzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFNob3cgU2V0dGluZ3MgY2xpY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0hhbmRsZXIuc2hvd01vZGFsKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2hvd1BvcHVwTWVudSA9IChldmVudCwgdGFyZ2V0QnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFNob3cgUG9wdXAgTWVudSBjbGlja2VkJyk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJ1dHRvblxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRhcmdldEJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGJlbG93IHRoZSBidXR0b25cbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KHJlY3QubGVmdCwgcmVjdC5ib3R0b20gKyA1KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGVUaXRsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpdGxlID0gKChfYSA9IHRoaXMubGF5b3V0RWxlbWVudHMudGl0bGVJbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlKSB8fCAnQ2hhdCc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFVwZGF0ZSBUaXRsZSBjYWxsZWQ6JywgbmV3VGl0bGUpO1xuICAgICAgICAgICAgdGhpcy5jaGF0U3RhdGUudXBkYXRlQ3VycmVudENoYXRUaXRsZShuZXdUaXRsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZG9jTWFuYWdlciA9IGRvY01hbmFnZXI7XG4gICAgICAgIHRoaXMuaWQgPSAnc2ltcGxlLXNpZGViYXInO1xuICAgICAgICB0aGlzLnRpdGxlLmxhYmVsID0gJyc7XG4gICAgICAgIHRoaXMudGl0bGUuY2FwdGlvbiA9ICdBSSBDaGF0IEludGVyZmFjZSc7XG4gICAgICAgIHRoaXMudGl0bGUuaWNvbiA9IGljb25zXzEuZXh0ZW5zaW9uSWNvbjtcbiAgICAgICAgdGhpcy50aXRsZS5jbG9zYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2pwLWxsbS1leHQtc2lkZWJhcicpO1xuICAgICAgICAvLyAtLS0gMS4gSW5pdGlhbGl6ZSBDb3JlIENvbXBvbmVudHMgJiBTdGF0ZSAtLS1cbiAgICAgICAgdGhpcy5zZXR0aW5nc1N0YXRlID0gbmV3IHNldHRpbmdzX3N0YXRlXzEuU2V0dGluZ3NTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpbml0aWFsU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzU3RhdGUuZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgYXBpX2NsaWVudF8xLkFwaUNsaWVudCgoaW5pdGlhbFNldHRpbmdzID09PSBudWxsIHx8IGluaXRpYWxTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbFNldHRpbmdzLmFwaVVybCkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5jaGF0U3RhdGUgPSBuZXcgY2hhdF9zdGF0ZV8xLkNoYXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIgPSBuZXcgcG9wdXBfbWVudV9tYW5hZ2VyXzEuUG9wdXBNZW51TWFuYWdlcih0aGlzLmRvY01hbmFnZXIsIHRoaXMubm9kZSwge1xuICAgICAgICAgICAgaW5zZXJ0Q29kZTogKGNvZGUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KGBAY29kZSAke2NvZGV9YCk7IH0sXG4gICAgICAgICAgICBpbnNlcnRDZWxsOiAoY29udGVudCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcGVuZFRvSW5wdXQoYEBjZWxsICR7Y29udGVudH1gKTsgfSxcbiAgICAgICAgICAgIGluc2VydEZpbGVQYXRoOiAocGF0aCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcGVuZFRvSW5wdXQoYEBmaWxlICR7cGF0aH1gKTsgfSxcbiAgICAgICAgICAgIGluc2VydERpcmVjdG9yeVBhdGg6IChwYXRoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kVG9JbnB1dChgQGRpcmVjdG9yeSAke3BhdGh9YCk7IH0sXG4gICAgICAgICAgICBnZXRTZWxlY3RlZFRleHQ6IG5vdGVib29rX2ludGVncmF0aW9uXzEuZ2V0U2VsZWN0ZWRUZXh0LCAvLyBVc2UgdGhlIGltcG9ydGVkIHV0aWxpdHkgZnVuY3Rpb25cbiAgICAgICAgICAgIGdldEN1cnJlbnRDZWxsQ29udGVudDogbm90ZWJvb2tfaW50ZWdyYXRpb25fMS5nZXRDdXJyZW50Q2VsbENvbnRlbnQsIC8vIFVzZSB0aGUgaW1wb3J0ZWQgdXRpbGl0eSBmdW5jdGlvblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBpbXBvcnRlZCB1dGlsaXR5LCBwcm92aWRpbmcgdGhlIGNhbGxiYWNrIHRvIGFwcGVuZCB0byB0aGUgaW5wdXQgaGFuZGxlclxuICAgICAgICAgICAgaW5zZXJ0Q2VsbEJ5SW5kZXg6IChpbmRleCkgPT4gKDAsIG5vdGVib29rX2ludGVncmF0aW9uXzEuaW5zZXJ0Q2VsbENvbnRlbnRCeUluZGV4KShpbmRleCwgKGNvbnRlbnQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KGBAJHtjb250ZW50fWApOyB9KSxcbiAgICAgICAgICAgIC8vIEltcGxlbWVudCB0aGUgY2FsbGJhY2sgZm9yIGNvbGxhcHNlZCBjb2RlIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGluc2VydENvbGxhcHNlZENvZGVSZWY6IChjb2RlLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dEhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gR3VhcmRcbiAgICAgICAgICAgICAgICAvLyAxLiBBZGQgY29kZSB0byBoYW5kbGVyJ3MgbWFwIGFuZCBnZXQgSURcbiAgICAgICAgICAgICAgICBjb25zdCByZWZJZCA9IHRoaXMuaW5wdXRIYW5kbGVyLmFkZENvZGVSZWZlcmVuY2UoY29kZSk7XG4gICAgICAgICAgICAgICAgLy8gMi4gQ3JlYXRlIHRoZSBwbGFjZWhvbGRlciB0ZXh0XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAoMCwgY29kZV9yZWZfd2lkZ2V0XzEuY3JlYXRlQ29kZVJlZlBsYWNlaG9sZGVyKShyZWZJZCwgbm90ZWJvb2tOYW1lLCBsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAvLyAzLiBBcHBlbmQgcGxhY2Vob2xkZXIgdG8gaW5wdXQgZmllbGRcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SGFuZGxlci5hcHBlbmRUb0lucHV0KHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLSAyLiBEZWZpbmUgQ2FsbGJhY2tzICh1c2VkIGJ5IGJ1aWxkTGF5b3V0IGFuZCBIYW5kbGVycykgLS0tXG4gICAgICAgIC8vIENhbGxiYWNrcyBmb3IgVUkgYWN0aW9ucyAocGFzc2VkIHRvIGJ1aWxkTGF5b3V0KVxuICAgICAgICBjb25zdCBjcmVhdGVOZXdDaGF0Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGF0ID0gdGhpcy5jaGF0U3RhdGUuY3JlYXRlTmV3Q2hhdCgpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5oaXN0b3J5SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvYWRDaGF0KG5ld0NoYXQuaWQpOyAvLyBDYWxsIGhhbmRsZXIgbWV0aG9kXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvZ2dsZUhpc3RvcnlDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaGlzdG9yeUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2dnbGVIaXN0b3J5VmlldygpOyAvLyBDYWxsIGhhbmRsZXIgbWV0aG9kXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3dTZXR0aW5nc0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zZXR0aW5nc0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93TW9kYWwoKTsgLy8gQ2FsbCBoYW5kbGVyIG1ldGhvZFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVUaXRsZUNhbGxiYWNrID0gKG5ld1RpdGxlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0aGlzLmNoYXRTdGF0ZS51cGRhdGVDdXJyZW50Q2hhdFRpdGxlKG5ld1RpdGxlKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudWlNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvd05vdGlmaWNhdGlvbignQ2hhdCB0aXRsZSB1cGRhdGVkJywgJ2luZm8nKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2hvd1BvcHVwTWVudUNhbGxiYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUocmVjdC5sZWZ0ICsgNjAsIHJlY3QudG9wIC0gMjApOyAvLyBBZGp1c3QgcG9zaXRpb25pbmcgYXMgbmVlZGVkXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlVmlhQnV0dG9uQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlU2VuZE1lc3NhZ2UodGhpcy5sYXlvdXRFbGVtZW50cy5pbnB1dEZpZWxkLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9nZ2xlTWFya2Rvd25Nb2RlQ2FsbGJhY2sgPSAoaXNNYXJrZG93bikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRNYXJrZG93bk1vZGUoaXNNYXJrZG93bik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvZ2dsZUV4cGFuZElucHV0Q2FsbGJhY2sgPSAoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvZ2dsZUlucHV0RXhwYW5zaW9uKCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYnV0dG9uIHRleHQvaWNvbiBiYXNlZCBvbiBuZXcgc3RhdGUgKElucHV0SGFuZGxlciBtaWdodCBkbyB0aGlzIHZpYSBjYWxsYmFjaylcbiAgICAgICAgICAgIC8vIEV4YW1wbGUgdGV4dCB1cGRhdGUsIFVJTWFuYWdlciBjYWxsYmFjayBoYW5kbGVzIHRoZSB2aXN1YWwgc3RhdGVcbiAgICAgICAgICAgIC8vIGJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMuaW5wdXRIYW5kbGVyPy5pc0lucHV0RXhwYW5kZWQgPyAnQ29sbGFwc2UnIDogJ0V4cGFuZCc7IFxuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxsYmFja3MgZm9yIE1lc3NhZ2UgUmVuZGVyaW5nIChwYXNzZWQgdG8gTWVzc2FnZUhhbmRsZXIgLT4gVUlNYW5hZ2VyIC0+IHJlbmRlcmVycylcbiAgICAgICAgY29uc3QgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLy8gLi4uIChzaG93Q29weUZlZWRiYWNrLCBhZGRNZXNzYWdlVG9DZWxsLCBjb3B5VG9DbGlwYm9hcmQsIGNvcHlJbWFnZVRvQ2xpcGJvYXJkLCBjb3B5TWVzc2FnZVRvQ2xpcGJvYXJkIGRlZmluZWQgYXMgYmVmb3JlKSAuLi5cbiAgICAgICAgICAgIHNob3dDb3B5RmVlZGJhY2s6IChidXR0b24sIHN1Y2Nlc3MgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIVE1MID0gYnV0dG9uLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gc3VjY2VzcyA/ICdDb3BpZWQhJyA6ICdGYWlsZWQhJztcbiAgICAgICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gb3JpZ2luYWxIVE1MO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRNZXNzYWdlVG9DZWxsOiBub3RlYm9va19pbnRlZ3JhdGlvbl8xLmFkZE1lc3NhZ2VUb0NlbGwsXG4gICAgICAgICAgICBjb3B5VG9DbGlwYm9hcmQ6ICh0ZXh0LCBmZWVkYmFja0NiKSA9PiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbigoKSA9PiBmZWVkYmFja0NiID09PSBudWxsIHx8IGZlZWRiYWNrQ2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2IoKSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvcHkgdGV4dDogJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2tDYiA9PT0gbnVsbCB8fCBmZWVkYmFja0NiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NiKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29weUltYWdlVG9DbGlwYm9hcmQ6IChpbWFnZVVybCwgZmVlZGJhY2tDYikgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBjbGlwYm9hcmRfMS5jb3B5SW1hZ2VUb0NsaXBib2FyZCkoaW1hZ2VVcmwsIChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWRiYWNrQ2IgPT09IG51bGwgfHwgZmVlZGJhY2tDYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQ6ICh0ZXh0LCBmZWVkYmFja0NiKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNsaXBib2FyZF8xLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQpKHRleHQsIChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWRiYWNrQ2IoKTsgLy8gU2lnbmFsIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVDb25maXJtSW50ZXJydXB0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubWVzc2FnZUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVTZW5kQXV0b01lc3NhZ2UoJ2NvbmZpcm1lZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZVJlamVjdEludGVycnVwdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlU2VuZEF1dG9NZXNzYWdlKCdyZWplY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxsYmFja3MgZm9yIFNldHRpbmdzIE1vZGFsIChwYXNzZWQgdG8gY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQpXG4gICAgICAgIGNvbnN0IHNldHRpbmdzTW9kYWxDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBoYW5kbGVTYXZlOiAoKSA9PiB7IHZhciBfYTsgKF9hID0gdGhpcy5zZXR0aW5nc0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zYXZlU2V0dGluZ3MoKTsgfSxcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbDogKCkgPT4geyB2YXIgX2E7IChfYSA9IHRoaXMuc2V0dGluZ3NIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZU1vZGFsKCk7IH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2FsbGJhY2tzIGZvciBIaXN0b3J5IEhhbmRsZXJcbiAgICAgICAgY29uc3QgaGlzdG9yeUhhbmRsZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICB1cGRhdGVUaXRsZUlucHV0OiAodGl0bGUpID0+IHRoaXMudWlNYW5hZ2VyLnVwZGF0ZVRpdGxlSW5wdXQodGl0bGUpLFxuICAgICAgICAgICAgY2xlYXJNZXNzYWdlQ29udGFpbmVyOiAoKSA9PiB0aGlzLnVpTWFuYWdlci5jbGVhck1lc3NhZ2VDb250YWluZXIoKSxcbiAgICAgICAgICAgIGFkZFJlbmRlcmVkTWVzc2FnZTogKG1lc3NhZ2VFbGVtZW50KSA9PiB0aGlzLnVpTWFuYWdlci5hZGRDaGF0TWVzc2FnZUVsZW1lbnQobWVzc2FnZUVsZW1lbnQpXG4gICAgICAgIH07XG4gICAgICAgIC8vIENhbGxiYWNrcyBmb3IgSW5wdXQgSGFuZGxlclxuICAgICAgICAvLyBjb25zdCBpbnB1dEhhbmRsZXJDYWxsYmFja3M6IElucHV0SGFuZGxlckNhbGxiYWNrcyA9IHsgLy8gUmVtb3ZlZCB1bnVzZWQgdmFyaWFibGVcbiAgICAgICAgLy8gICAgaGFuZGxlU2VuZE1lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHRoaXMubWVzc2FnZUhhbmRsZXI/LmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAvLyAgICBzaG93UG9wdXBNZW51OiAobGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcikgPT4gdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUobGVmdCwgdG9wKSxcbiAgICAgICAgLy8gICAgaGlkZVBvcHVwTWVudTogKCkgPT4gdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmhpZGVQb3B1cE1lbnUoKSxcbiAgICAgICAgLy8gICAgLy8gRXhhbXBsZSBpbXBsZW1lbnRhdGlvbnMgLSByZWZpbmUgYXMgbmVlZGVkXG4gICAgICAgIC8vICAgIHVwZGF0ZVBsYWNlaG9sZGVyOiAoaXNNYXJrZG93bjogYm9vbGVhbikgPT4ge1xuICAgICAgICAvLyAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gaXNNYXJrZG93biA/ICdFbnRlciBtYXJrZG93bi4uLicgOiAnQXNrIGFueXRoaW5nLi4uJztcbiAgICAgICAgLy8gICAgfSxcbiAgICAgICAgLy8gICAgdG9nZ2xlSW5wdXRFeHBhbnNpb25VSTogKGlzRXhwYW5kZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgLy8gICAgICAgIC8vIFVwZGF0ZSBleHBhbmQgYnV0dG9uIGFwcGVhcmFuY2VcbiAgICAgICAgLy8gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuZXhwYW5kQnV0dG9uLnRleHRDb250ZW50ID0gaXNFeHBhbmRlZCA/ICdDb2xsYXBzZScgOiAnRXhwYW5kJzsgLy8gT3IgdXNlIGljb25zXG4gICAgICAgIC8vICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLmV4cGFuZEJ1dHRvbi50aXRsZSA9IGlzRXhwYW5kZWQgPyAnQ29sbGFwc2UgaW5wdXQnIDogJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgIC8vICAgIH0sXG4gICAgICAgIC8vICAgIC8vIENvbm5lY3QgY29kZSByZWYgbWFwIGNhbGxiYWNrcyB0byB0aGUgSW5wdXRIYW5kbGVyIG1ldGhvZHNcbiAgICAgICAgLy8gICAgZ2V0Q29kZVJlZk1hcDogKCkgPT4gdGhpcy5pbnB1dEhhbmRsZXI/LmdldENvZGVSZWZlcmVuY2VNYXAoKSB8fCBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpLFxuICAgICAgICAvLyAgICByZXNldENvZGVSZWZNYXA6ICgpID0+IHRoaXMuaW5wdXRIYW5kbGVyPy5yZXNldENvZGVSZWZlcmVuY2VzKClcbiAgICAgICAgLy8gfTtcbiAgICAgICAgLy8gQ2FsbGJhY2tzIGZvciBTaG9ydGN1dCBIYW5kbGVyXG4gICAgICAgIGNvbnN0IHNob3J0Y3V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgc2hvd0luZGljYXRvcjogKHRleHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy51aU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93SW5kaWNhdG9yKHRleHQpOyB9LFxuICAgICAgICAgICAgYXBwZW5kVG9JbnB1dDogKHRleHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KHRleHQpOyB9LFxuICAgICAgICAgICAgc2hvd1dpZGdldDogKCkgPT4geyBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgZm9jdXNJbnB1dDogKCkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5sYXlvdXRFbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0RmllbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb2N1cygpOyB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIC0tLSAzLiBCdWlsZCBVSSBMYXlvdXQgLS0tXG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMgPSAoMCwgbGF5b3V0X2J1aWxkZXJfMS5idWlsZExheW91dCkoe1xuICAgICAgICAgICAgLy8gUGFzcyB0aGUgY29ycmVjdGx5IG5hbWVkIGNhbGxiYWNrcyBmcm9tIExheW91dENhbGxiYWNrcyBpbnRlcmZhY2VcbiAgICAgICAgICAgIG9uTmV3Q2hhdENsaWNrOiBjcmVhdGVOZXdDaGF0Q2FsbGJhY2ssXG4gICAgICAgICAgICBvbkhpc3RvcnlUb2dnbGVDbGljazogdG9nZ2xlSGlzdG9yeUNhbGxiYWNrLCAvLyBDb3JyZWN0ZWQgbmFtZVxuICAgICAgICAgICAgb25TZXR0aW5nc0NsaWNrOiBzaG93U2V0dGluZ3NDYWxsYmFjayxcbiAgICAgICAgICAgIG9uVGl0bGVDaGFuZ2U6IHVwZGF0ZVRpdGxlQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbkF0QnV0dG9uQ2xpY2s6IHNob3dQb3B1cE1lbnVDYWxsYmFjaywgLy8gVXNlIHRoZSBzcGVjaWZpYyBjYWxsYmFja1xuICAgICAgICAgICAgb25TZW5kTWVzc2FnZUNsaWNrOiBzZW5kTWVzc2FnZVZpYUJ1dHRvbkNhbGxiYWNrLCAvLyBDb25uZWN0IHNlbmQgYnV0dG9uXG4gICAgICAgICAgICBvbk1hcmtkb3duVG9nZ2xlQ2hhbmdlOiB0b2dnbGVNYXJrZG93bk1vZGVDYWxsYmFjaywgLy8gQ29ubmVjdCBtYXJrZG93biB0b2dnbGVcbiAgICAgICAgICAgIG9uRXhwYW5kVG9nZ2xlQ2xpY2s6IHRvZ2dsZUV4cGFuZElucHV0Q2FsbGJhY2ssIC8vIENvbm5lY3QgZXhwYW5kIGJ1dHRvblxuICAgICAgICAgICAgLy8gb25JbnB1dEZpZWxkS2V5UHJlc3M6IC4uLiAvLyBDYW4gYmUgaGFuZGxlZCBpbnRlcm5hbGx5IGJ5IElucHV0SGFuZGxlclxuICAgICAgICAgICAgLy8gb25JbnB1dEZpZWxkVmFsdWVDaGFuZ2U6IC4uLiAvLyBDYW4gYmUgaGFuZGxlZCBpbnRlcm5hbGx5IGJ5IElucHV0SGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyID0gKDAsIHNldHRpbmdzX21vZGFsXzEuY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQpKHNldHRpbmdzTW9kYWxDYWxsYmFja3MpO1xuICAgICAgICAvLyAtLS0gSW5pdGlhbGl6ZSBTdGF0ZSBNYW5hZ2VycyAtLS1cbiAgICAgICAgdGhpcy5jaGF0U3RhdGUgPSBuZXcgY2hhdF9zdGF0ZV8xLkNoYXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLnNldHRpbmdzU3RhdGUgPSBuZXcgc2V0dGluZ3Nfc3RhdGVfMS5TZXR0aW5nc1N0YXRlKCk7XG4gICAgICAgIC8vIC0tLSBJbml0aWFsaXplIENvcmUgQ29tcG9uZW50cyAtLS1cbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgYXBpX2NsaWVudF8xLkFwaUNsaWVudCgpO1xuICAgICAgICAvLyB0aGlzLm1lc3NhZ2VSZW5kZXJlciA9IG5ldyBNZXNzYWdlUmVuZGVyZXIobWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzKTsgLy8gRml4ZWQ6IENvbnN0cnVjdG9yIHRha2VzIDAgYXJncyAmIG1lbWJlciByZW1vdmVkXG4gICAgICAgIC8vIC0tLSBJbml0aWFsaXplIFVJIE1hbmFnZXIgKG5lZWRzIGRlcGVuZGVuY2llcykgLS0tXG4gICAgICAgIC8vIE11c3QgYmUgaW5pdGlhbGl6ZWQgKmFmdGVyKiBoYW5kbGVycyB0aGF0IGl0IG1pZ2h0IG5lZWQgY2FsbGJhY2tzIGZyb20sXG4gICAgICAgIC8vIE9SIHBhc3MgY2FsbGJhY2tzIGRpcmVjdGx5IGhlcmUuXG4gICAgICAgIGNvbnN0IHVpTWFuYWdlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGhhbmRsZU5ld0NoYXQ6IHRoaXMuaGFuZGxlTmV3Q2hhdCxcbiAgICAgICAgICAgIGhhbmRsZVRvZ2dsZUhpc3Rvcnk6IHRoaXMuaGFuZGxlVG9nZ2xlSGlzdG9yeSxcbiAgICAgICAgICAgIGhhbmRsZVNlbmRNZXNzYWdlOiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlLFxuICAgICAgICAgICAgaGFuZGxlU2hvd1NldHRpbmdzOiB0aGlzLmhhbmRsZVNob3dTZXR0aW5ncyxcbiAgICAgICAgICAgIGhhbmRsZVNob3dQb3B1cE1lbnU6IHRoaXMuaGFuZGxlU2hvd1BvcHVwTWVudSwgLy8gTm93IGhhbmRsZWQgYnkgUG9wdXBNZW51TWFuYWdlclxuICAgICAgICAgICAgaGFuZGxlVXBkYXRlVGl0bGU6IHRoaXMuaGFuZGxlVXBkYXRlVGl0bGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVUlNYW5hZ2VyIG5lZWRzOiBkb2NNYW5hZ2VyLCBwb3B1cE1lbnVNYW5hZ2VyLCB3aWRnZXROb2RlLCBjYWxsYmFja3MsIGxheW91dEVsZW1lbnRzXG4gICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlciA9IG5ldyBwb3B1cF9tZW51X21hbmFnZXJfMS5Qb3B1cE1lbnVNYW5hZ2VyKHRoaXMuZG9jTWFuYWdlciwgdGhpcy5ub2RlLCB0aGlzLm1lbnVBY3Rpb25DYWxsYmFja3MpOyAvLyBOZWVkcyBkb2NNYW5hZ2VyLCB3aWRnZXROb2RlLCBtZW51QWN0aW9uQ2FsbGJhY2tzXG4gICAgICAgIHRoaXMudWlNYW5hZ2VyID0gbmV3IHVpX21hbmFnZXJfMS5VSU1hbmFnZXIoXG4gICAgICAgIC8vIHRoaXMuZG9jTWFuYWdlciwgLy8gUmVtb3ZlZDogbm90IGluIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIsIFxuICAgICAgICAvLyB0aGlzLm5vZGUsIC8vIFJlbW92ZWQ6IG5vdCBpbiBjb25zdHJ1Y3RvciBzaWduYXR1cmVcbiAgICAgICAgdWlNYW5hZ2VyQ2FsbGJhY2tzLCB0aGlzLmxheW91dEVsZW1lbnRzKTtcbiAgICAgICAgLy8gLS0tIEluaXRpYWxpemUgSGFuZGxlcnMgKHBhc3MgZGVwZW5kZW5jaWVzKSAtLS1cbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG5ldyBtZXNzYWdlX2hhbmRsZXJfMS5NZXNzYWdlSGFuZGxlcih0aGlzLmFwaUNsaWVudCwgdGhpcy5jaGF0U3RhdGUsIHRoaXMudWlNYW5hZ2VyLCBtZXNzYWdlUmVuZGVyZXJDYWxsYmFja3MsIC8vIFBhc3MgdGhlIHJlZmluZWQgY2FsbGJhY2tzXG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyIC8vIFBhc3MgdGhlIGluaXRpYWxpemVkIGlucHV0IGhhbmRsZXJcbiAgICAgICAgKTtcbiAgICAgICAgLy8gSGlzdG9yeSBIYW5kbGVyOiBOZWVkcyBzdGF0ZSwgVUkgbWFuYWdlciwgaXRzIGNhbGxiYWNrcywgcmVuZGVyIGNhbGxiYWNrc1xuICAgICAgICB0aGlzLmhpc3RvcnlIYW5kbGVyID0gbmV3IGhpc3RvcnlfaGFuZGxlcl8xLkhpc3RvcnlIYW5kbGVyKHRoaXMuY2hhdFN0YXRlLCB0aGlzLnVpTWFuYWdlciwgaGlzdG9yeUhhbmRsZXJDYWxsYmFja3MsIC8vIFBhc3MgdGhlIGRlZmluZWQgY2FsbGJhY2tzIG9iamVjdFxuICAgICAgICBtZXNzYWdlUmVuZGVyZXJDYWxsYmFja3MgLy8gUGFzcyB0aGUgcmVmaW5lZCBjYWxsYmFja3NcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU2V0dGluZ3MgSGFuZGxlcjogTmVlZHMgc3RhdGUsIGFwaSBjbGllbnQsIG1vZGFsIGNvbnRhaW5lciwgVUkgbWFuYWdlclxuICAgICAgICB0aGlzLnNldHRpbmdzSGFuZGxlciA9IG5ldyBzZXR0aW5nc19oYW5kbGVyXzEuU2V0dGluZ3NIYW5kbGVyKHRoaXMuc2V0dGluZ3NTdGF0ZSwgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLCAvLyBDb3JyZWN0ZWQ6IFBhc3MgbW9kYWwgY29udGFpbmVyXG4gICAgICAgIHRoaXMudWlNYW5hZ2VyIC8vIENvcnJlY3RlZDogUGFzcyB1aU1hbmFnZXIgaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgLy8gLS0tIDUuIFBvc3QtSW5pdGlhbGl6YXRpb24gU2V0dXAgLS0tXG4gICAgICAgIC8vIFNldHVwIFNob3J0Y3V0cyAodmVyaWZ5IHNpZ25hdHVyZSBsYXRlciBpbiBTdGVwIDcpXG4gICAgICAgICgwLCBzaG9ydGN1dF9oYW5kbGVyXzEuc2V0dXBTaG9ydGN1dHMpKHRoaXMuaW5wdXRIYW5kbGVyLCB0aGlzLnBvcHVwTWVudU1hbmFnZXIsIHNob3J0Y3V0Q2FsbGJhY2tzIC8vIFBhc3MgdGhlIGNvcnJlY3RseSBkZWZpbmVkIGNhbGxiYWNrcyBvYmplY3RcbiAgICAgICAgKTtcbiAgICAgICAgLy8gQXBwZW5kIG1haW4gVUkgZWxlbWVudHMgdG8gdGhlIHdpZGdldCBub2RlXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxheW91dEVsZW1lbnRzLm1haW5FbGVtZW50KTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lcik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgaGlzdG9yeSB2aWV3PyBMb2FkIGluaXRpYWwvZGVmYXVsdCBjaGF0P1xuICAgICAgICAvLyB0aGlzLmhpc3RvcnlIYW5kbGVyLmluaXRpYWxpemUoKTsgLy8gQ2hlY2sgaWYgSGlzdG9yeUhhbmRsZXIgbmVlZHMgYW4gaW5pdCBtZXRob2RcbiAgICAgICAgY29uc3QgaW5pdGlhbENoYXQgPSB0aGlzLmNoYXRTdGF0ZS5nZXRDdXJyZW50Q2hhdCgpIHx8IHRoaXMuY2hhdFN0YXRlLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5SGFuZGxlci5sb2FkQ2hhdChpbml0aWFsQ2hhdC5pZCk7IC8vIExvYWQgaW5pdGlhbCBjaGF0IHN0YXRlIGludG8gdmlld1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBnbG9iYWwgbGlzdGVuZXJzXG4gICAgICAgICgwLCBzaG9ydGN1dF9oYW5kbGVyXzEucmVtb3ZlU2hvcnRjdXRzKSgpO1xuICAgICAgICAvLyBDYWxsIGRpc3Bvc2Ugb24gaGFuZGxlcnMvbWFuYWdlcnMgdGhhdCBoYXZlIGl0XG4gICAgICAgIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnBvcHVwTWVudU1hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgIC8vIE1lc3NhZ2VIYW5kbGVyLCBIaXN0b3J5SGFuZGxlciwgU2V0dGluZ3NIYW5kbGVyLCBVSU1hbmFnZXIgZG8gbm90IGhhdmUgZGlzcG9zZSBtZXRob2RzXG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59IC8vIEVuZCBvZiBTaW1wbGVTaWRlYmFyV2lkZ2V0IGNsYXNzXG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSBTaW1wbGVTaWRlYmFyV2lkZ2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBvZiBjaGF0IGhpc3RvcnkgYW5kIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gKi9cbmNsYXNzIENoYXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBudWxsO1xuICAgICAgICAvLyBQb3RlbnRpYWw6IExvYWQgaW5pdGlhbCBzdGF0ZSBmcm9tIHN0b3JhZ2UgaWYgcGVyc2lzdGVuY2UgaXMgYWRkZWQgbGF0ZXJcbiAgICAgICAgaWYgKHRoaXMuY2hhdEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU5ld0NoYXQoJ1dlbGNvbWUgQ2hhdCcpOyAvLyBDcmVhdGUgYW4gaW5pdGlhbCBjaGF0IGlmIG5vbmUgZXhpc3RzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSAoKF9hID0gdGhpcy5jaGF0SGlzdG9yeVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSB8fCBudWxsOyAvLyBTZXQgY3VycmVudCBjaGF0IHRvIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvbiBhbmQgc2V0cyBpdCBhcyB0aGUgY3VycmVudCBjaGF0LlxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFRoZSBpbml0aWFsIHRpdGxlIGZvciB0aGUgbmV3IGNoYXQuXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgY2hhdCBpdGVtLlxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQodGl0bGUgPSAnTmV3IENoYXQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXRJZCA9IGBjaGF0LSR7KDAsIHV1aWRfMS52NCkoKX1gOyAvLyBVc2UgVVVJRCBmb3IgYmV0dGVyIHVuaXF1ZW5lc3NcbiAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHtcbiAgICAgICAgICAgIGlkOiBjaGF0SWQsXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICBtZXNzYWdlczogW11cbiAgICAgICAgICAgIC8vIGNyZWF0ZWRBdDogbmV3IERhdGUoKSBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5wdXNoKG5ld0NoYXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIG5ldyBjaGF0OicsIG5ld0NoYXQpO1xuICAgICAgICByZXR1cm4gbmV3Q2hhdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudGx5IGFjdGl2ZSBjaGF0IElELlxuICAgICAqIEBwYXJhbSBjaGF0SWQgLSBUaGUgSUQgb2YgdGhlIGNoYXQgdG8gc2V0IGFzIGN1cnJlbnQuXG4gICAgICovXG4gICAgc2V0Q3VycmVudENoYXRJZChjaGF0SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhdEhpc3Rvcnkuc29tZShjaGF0ID0+IGNoYXQuaWQgPT09IGNoYXRJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9IGNoYXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2hhdCBJRCAke2NoYXRJZH0gbm90IGZvdW5kIGluIGhpc3RvcnkuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgSUQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgY2hhdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBjaGF0IElEIG9yIG51bGwgaWYgbm9uZSBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudENoYXRJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgc3BlY2lmaWMgY2hhdCBieSBpdHMgSUQuXG4gICAgICogQHBhcmFtIGNoYXRJZCAtIFRoZSBJRCBvZiB0aGUgY2hhdCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2hhdCBpdGVtIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgZ2V0Q2hhdEJ5SWQoY2hhdElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoY2hhdCA9PiBjaGF0LmlkID09PSBjaGF0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgY2hhdCBpdGVtLlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGNoYXQgaXRlbSBvciB1bmRlZmluZWQgaWYgbm8gY2hhdCBpcyBhY3RpdmUgb3IgZm91bmQuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50Q2hhdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldENoYXRCeUlkKHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gICAgICogQHBhcmFtIG5ld1RpdGxlIC0gVGhlIG5ldyB0aXRsZSBmb3IgdGhlIGNoYXQuXG4gICAgICovXG4gICAgdXBkYXRlQ3VycmVudENoYXRUaXRsZShuZXdUaXRsZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhdCA9IHRoaXMuZ2V0Q3VycmVudENoYXQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGF0KSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hhdC50aXRsZSA9IG5ld1RpdGxlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgdGl0bGUgZm9yIGNoYXQgJHt0aGlzLmN1cnJlbnRDaGF0SWR9IHRvIFwiJHtuZXdUaXRsZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgdXBkYXRlIHRpdGxlOiBObyBjdXJyZW50IGNoYXQgc2VsZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1lc3NhZ2UgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgY2hhdC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9iamVjdCB0byBhZGQuXG4gICAgICovXG4gICAgYWRkTWVzc2FnZVRvQ3VycmVudENoYXQobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhdCA9IHRoaXMuZ2V0Q3VycmVudENoYXQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGF0KSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hhdC5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgYWRkIG1lc3NhZ2U6IE5vIGN1cnJlbnQgY2hhdCBzZWxlY3RlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgbWVzc2FnZXMgb3IgYW4gZW1wdHkgYXJyYXkgaWYgbm8gY2hhdCBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXRNZXNzYWdlcygpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXQgPSB0aGlzLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2hhdCA/IGN1cnJlbnRDaGF0Lm1lc3NhZ2VzIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVudGlyZSBjaGF0IGhpc3RvcnkuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIGNoYXQgaGlzdG9yeSBpdGVtcy5cbiAgICAgKi9cbiAgICBnZXRDaGF0SGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLmNoYXRIaXN0b3J5XTsgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IGRpcmVjdCBtb2RpZmljYXRpb25cbiAgICB9XG59XG5leHBvcnRzLkNoYXRTdGF0ZSA9IENoYXRTdGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXR0aW5nc1N0YXRlID0gdm9pZCAwO1xuY29uc3QgU0VUVElOR1NfU1RPUkFHRV9LRVkgPSAnanAtbGxtLWV4dC1zZXR0aW5ncyc7XG4vKipcbiAqIE1hbmFnZXMgbG9hZGluZyBhbmQgc2F2aW5nIGFwcGxpY2F0aW9uIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZS5cbiAqL1xuY2xhc3MgU2V0dGluZ3NTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNldHRpbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2V0dGluZ3MgPSB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIHNldHRpbmdzIG9yIG51bGwgaWYgbm9uZSBhcmUgc2F2ZWQgb3IgYW4gZXJyb3Igb2NjdXJzLlxuICAgICAqL1xuICAgIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRTZXR0aW5ncyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNFVFRJTkdTX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgaWYgKHNhdmVkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBKU09OLnBhcnNlKHNhdmVkU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gKGNhbiBiZSBleHBhbmRlZClcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBzZXR0aW5nczonLCB0aGlzLmN1cnJlbnRTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXR0aW5ncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNhdmVkIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTRVRUSU5HU19TVE9SQUdFX0tFWSk7IC8vIENsZWFyIGNvcnJ1cHRlZCBkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ05vIHZhbGlkIHNldHRpbmdzIGZvdW5kIGluIGxvY2FsU3RvcmFnZS4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2UuXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIG9iamVjdCB0byBzYXZlLlxuICAgICAqL1xuICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VUVElOR1NfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTsgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQ6JywgdGhpcy5jdXJyZW50U2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBOb3RpZnkgdXNlciBvZiBzYXZlIGZhaWx1cmVcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgbG9hZGVkIHNldHRpbmdzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldHRpbmdzIG9iamVjdCBvciBudWxsIGlmIG5vdCBsb2FkZWQuXG4gICAgICovXG4gICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXR0aW5ncyA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY3VycmVudFNldHRpbmdzKSA6IG51bGw7IC8vIFJldHVybiBhIGNvcHlcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHNwZWNpZmljIHNldHRpbmcgdmFsdWUuXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIHNldHRpbmcgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgZ2V0U2V0dGluZyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNldHRpbmdzID8gdGhpcy5jdXJyZW50U2V0dGluZ3Nba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlNldHRpbmdzU3RhdGUgPSBTZXR0aW5nc1N0YXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUNvZGVSZWZXaWRnZXRIVE1MID0gY3JlYXRlQ29kZVJlZldpZGdldEhUTUw7XG5leHBvcnRzLmF0dGFjaENvZGVSZWZFdmVudExpc3RlbmVycyA9IGF0dGFjaENvZGVSZWZFdmVudExpc3RlbmVycztcbmV4cG9ydHMuZGVmYXVsdENvZGVSZWZUb2dnbGVMb2dpYyA9IGRlZmF1bHRDb2RlUmVmVG9nZ2xlTG9naWM7XG5leHBvcnRzLmNyZWF0ZUNvZGVSZWZQbGFjZWhvbGRlciA9IGNyZWF0ZUNvZGVSZWZQbGFjZWhvbGRlcjtcbmNvbnN0IGRvbV9lbGVtZW50c18xID0gcmVxdWlyZShcIi4vZG9tLWVsZW1lbnRzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBIVE1MIGVsZW1lbnQgZm9yIGEgY29sbGFwc2libGUgY29kZSByZWZlcmVuY2Ugd2lkZ2V0LlxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoZSBjb2RlIHJlZmVyZW5jZS5cbiAqIEByZXR1cm5zIFRoZSBIVE1MRWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvZGUgcmVmZXJlbmNlIHdpZGdldC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29kZVJlZldpZGdldEhUTUwoZGF0YSkge1xuICAgIGNvbnN0IHdpZGdldCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVTcGFuKSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWNvZGUtcmVmLXdpZGdldCcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdkYXRhLXJlZi1pZCc6IGRhdGEucmVmSWQsXG4gICAgICAgICAgICAnZGF0YS1jb2RlJzogZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEuY29kZSksIC8vIFN0b3JlIG9yaWdpbmFsIGNvZGUgc2FmZWx5XG4gICAgICAgICAgICAnZGF0YS1yZWYnOiBkYXRhLmNvZGVSZWZcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGxhYmVsID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZVNwYW4pKHtcbiAgICAgICAgY2xhc3NlczogJ2pwLWxsbS1leHQtY29kZS1yZWYtbGFiZWwnLFxuICAgICAgICB0ZXh0OiBkYXRhLmNvZGVSZWZcbiAgICB9KTtcbiAgICBjb25zdCB0b2dnbGVCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWNvZGUtcmVmLXRvZ2dsZScsXG4gICAgICAgIHRleHQ6ICfir4gnLCAvLyBSaWdodC1wb2ludGluZyB0cmlhbmdsZSBpbml0aWFsbHlcbiAgICAgICAgYXR0cmlidXRlczogeyB0aXRsZTogJ0V4cGFuZC9jb2xsYXBzZSBjb2RlJyB9XG4gICAgfSk7XG4gICAgY29uc3QgY29udGVudCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVTcGFuKSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWNvZGUtcmVmLWNvbnRlbnQnLFxuICAgICAgICB0ZXh0OiBkYXRhLmNvZGUsIC8vIERpc3BsYXkgdGhlIHJhdyBjb2RlIGZvciBub3dcbiAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gLy8gSGlkZGVuIGluaXRpYWxseVxuICAgIH0pO1xuICAgIC8vIEFzc2VtYmxlIHRoZSB3aWRnZXRcbiAgICB3aWRnZXQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIHdpZGdldC5hcHBlbmRDaGlsZCh0b2dnbGVCdXR0b24pO1xuICAgIHdpZGdldC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICByZXR1cm4gd2lkZ2V0O1xufVxuLyoqXG4gKiBBdHRhY2hlcyBldmVudCBsaXN0ZW5lcnMgKHNwZWNpZmljYWxseSBjbGljayBmb3IgdG9nZ2xlKSB0byBhIGNvZGUgcmVmIHdpZGdldC5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBjb2RlIHJlZiB3aWRnZXQgSFRNTEVsZW1lbnQuXG4gKiBAcGFyYW0gdG9nZ2xlQ2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdG9nZ2xlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICovXG5mdW5jdGlvbiBhdHRhY2hDb2RlUmVmRXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgdG9nZ2xlQ2FsbGJhY2spIHtcbiAgICBjb25zdCB0b2dnbGVCdXR0b24gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LWNvZGUtcmVmLXRvZ2dsZScpO1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1jb2RlLXJlZi1jb250ZW50Jyk7XG4gICAgaWYgKHRvZ2dsZUJ1dHRvbiAmJiBjb250ZW50RWxlbWVudCkge1xuICAgICAgICB0b2dnbGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRvZ2dsZUNhbGxiYWNrKHRvZ2dsZUJ1dHRvbiwgY29udGVudEVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgbG9naWMgZm9yIHRvZ2dsaW5nIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBjb2RlIHJlZiBjb250ZW50LlxuICogVGhpcyBjYW4gYmUgcGFzc2VkIGFzIHRoZSBjYWxsYmFjayB0byBhdHRhY2hDb2RlUmVmRXZlbnRMaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHRvZ2dsZUJ1dHRvbiAtIFRoZSBidXR0b24gZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkLlxuICogQHBhcmFtIGNvbnRlbnRFbGVtZW50IC0gVGhlIGNvbnRlbnQgZWxlbWVudCB0byB0b2dnbGUuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRDb2RlUmVmVG9nZ2xlTG9naWModG9nZ2xlQnV0dG9uLCBjb250ZW50RWxlbWVudCkge1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IGNvbnRlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaXNWaXNpYmxlID8gJ25vbmUnIDogJ2Jsb2NrJzsgLy8gT3IgJ2lubGluZS1ibG9jaycvJ2lubGluZScgZGVwZW5kaW5nIG9uIGRlc2lyZWQgbGF5b3V0XG4gICAgdG9nZ2xlQnV0dG9uLnRleHRDb250ZW50ID0gaXNWaXNpYmxlID8gJ+KviCcgOiAn4q+GJzsgLy8gVXBkYXRlIHRyaWFuZ2xlIGRpcmVjdGlvblxufVxuLyoqXG4gKiBDcmVhdGVzIGEgdGV4dHVhbCBwbGFjZWhvbGRlciBmb3IgYSBjb2RlIHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gcmVmSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSByZWZlcmVuY2UgKGUuZy4sIFwicmVmLTFcIikuXG4gKiBAcGFyYW0gbm90ZWJvb2tOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG5vdGVib29rIChvcHRpb25hbCwgZm9yIGZ1dHVyZSBkaXNwbGF5IGVuaGFuY2VtZW50cykuXG4gKiBAcGFyYW0gbGluZU51bWJlciAtIFRoZSBzdGFydGluZyBsaW5lIG51bWJlciBvZiB0aGUgY29kZSAob3B0aW9uYWwsIGZvciBmdXR1cmUgZGlzcGxheSBlbmhhbmNlbWVudHMpLlxuICogQHJldHVybnMgQSBzdHJpbmcgcGxhY2Vob2xkZXIgbGlrZSBcIltyZWYtMV1cIi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29kZVJlZlBsYWNlaG9sZGVyKHJlZklkLCBub3RlYm9va05hbWUsIC8vIEtlZXAgb3B0aW9uYWwgZm9yIG5vd1xubGluZU51bWJlciAvLyBLZWVwIG9wdGlvbmFsIGZvciBub3dcbikge1xuICAgIC8vIEtlZXAgaXQgc2ltcGxlIGZvciBub3csIGp1c3QgdGhlIElELlxuICAgIC8vIERpc3BsYXkgZGV0YWlscyBsaWtlIG5vdGVib29rL2xpbmUgY291bGQgYmUgYWRkZWQgbGF0ZXIgaWYgbmVlZGVkLlxuICAgIHJldHVybiBgWyR7cmVmSWR9XWA7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGltcG9ydCB7IFJlYWRvbmx5UGFydGlhbEpTT05PYmplY3QgfSBmcm9tICdAbHVtaW5vL2NvcmV1dGlscyc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURpdiA9IGNyZWF0ZURpdjtcbmV4cG9ydHMuY3JlYXRlQnV0dG9uID0gY3JlYXRlQnV0dG9uO1xuZXhwb3J0cy5jcmVhdGVTcGFuID0gY3JlYXRlU3BhbjtcbmV4cG9ydHMuY3JlYXRlVGV4dEFyZWEgPSBjcmVhdGVUZXh0QXJlYTtcbmV4cG9ydHMuY3JlYXRlSW5wdXRFbGVtZW50ID0gY3JlYXRlSW5wdXRFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVJbWFnZUVsZW1lbnQgPSBjcmVhdGVJbWFnZUVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZUFuY2hvckVsZW1lbnQgPSBjcmVhdGVBbmNob3JFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVMYWJlbEVsZW1lbnQgPSBjcmVhdGVMYWJlbEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZUZvcm1FbGVtZW50ID0gY3JlYXRlRm9ybUVsZW1lbnQ7XG4vKipcbiAqIEdlbmVyaWMgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIEhUTUxFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB0YWdOYW1lIC0gVGhlIEhUTUwgdGFnIG5hbWUgKGUuZy4sICdkaXYnLCAnYnV0dG9uJykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBlbGVtZW50LlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgSFRNTEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgZWxlbWVudC5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgICAgY29uc3QgY2xhc3Nlc1RvQWRkID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmNsYXNzZXMpXG4gICAgICAgICAgICA/IG9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICAgICAgOiBvcHRpb25zLmNsYXNzZXMuc3BsaXQoJyAnKS5maWx0ZXIoYyA9PiBjKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbnMudGV4dDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sOyAvLyBCZSBjYXV0aW91cyB3aXRoIEhUTUwgaW5qZWN0aW9uXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnN0eWxlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gb3B0aW9ucy5zdHlsZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICAgIG9wdGlvbnMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKiogQ3JlYXRlcyBhIDxkaXY+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVEaXYob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIG9wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYSA8YnV0dG9uPiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdidXR0b24nLCBvcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGEgPHNwYW4+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVTcGFuKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzcGFuJywgb3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhIDx0ZXh0YXJlYT4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHRBcmVhKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScsIG9wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYW4gPGlucHV0PiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRFbGVtZW50KG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBFbnN1cmUgdHlwZSBpcyBzZXQgaWYgcHJvdmlkZWQgaW4gYXR0cmlidXRlcywgb3RoZXJ3aXNlIGRlZmF1bHQgb3IgbGVhdmUgdW5zZXRcbiAgICBpZiAoKF9hID0gb3B0aW9ucy5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkge1xuICAgICAgICAvLyBUeXBlIGlzIGFscmVhZHkgc2V0IGluIGF0dHJpYnV0ZXMsIGRvIG5vdGhpbmcgZXh0cmFcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB7IHR5cGU6ICd0ZXh0JyB9OyAvLyBEZWZhdWx0IHRvIHRleHQgaWYgbm8gYXR0cmlidXRlcyBzcGVjaWZpZWRcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcy50eXBlKSB7XG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcy50eXBlID0gJ3RleHQnOyAvLyBEZWZhdWx0IHRvIHRleHQgaWYgdHlwZSBpcyBub3QgaW4gYXR0cmlidXRlc1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBvcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGFuIDxpbWc+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVJbWFnZUVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGltZ09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpbWdPcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYXR0cmlidXRlcyksIHsgc3JjOiBvcHRpb25zLnNyYyB9KTtcbiAgICBpZiAob3B0aW9ucy5hbHQpIHtcbiAgICAgICAgaW1nT3B0aW9ucy5hdHRyaWJ1dGVzLmFsdCA9IG9wdGlvbnMuYWx0O1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnaW1nJywgaW1nT3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhbiA8YT4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvckVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGFuY2hvck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBhbmNob3JPcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYXR0cmlidXRlcyksIHsgaHJlZjogb3B0aW9ucy5ocmVmIH0pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdhJywgYW5jaG9yT3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhIDxsYWJlbD4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxhYmVsRWxlbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaHRtbEZvcikge1xuICAgICAgICBsYWJlbE9wdGlvbnMuYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5hdHRyaWJ1dGVzKSwgeyBmb3I6IG9wdGlvbnMuaHRtbEZvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2xhYmVsJywgbGFiZWxPcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGEgPGZvcm0+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JtRWxlbWVudChvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZm9ybScsIG9wdGlvbnMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkTGF5b3V0ID0gYnVpbGRMYXlvdXQ7XG5jb25zdCBkb21fZWxlbWVudHNfMSA9IHJlcXVpcmUoXCIuL2RvbS1lbGVtZW50c1wiKTtcbi8qKlxuICogQnVpbGRzIHRoZSBtYWluIEhUTUwgc3RydWN0dXJlIGZvciB0aGUgc2lkZWJhciB3aWRnZXQuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrcyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdmFyaW91cyBVSSBpbnRlcmFjdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFpbiB3aWRnZXQgSFRNTEVsZW1lbnQgYW5kIHJlZmVyZW5jZXMgdG8ga2V5IGludGVyYWN0aXZlIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBidWlsZExheW91dChjYWxsYmFja3MgPSB7fSkge1xuICAgIC8vIC0tLSBNYWluIENvbnRlbnQgV3JhcHBlciAtLS1cbiAgICBjb25zdCBtYWluRWxlbWVudCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ2pwLWxsbS1leHQtY29udGVudC13cmFwcGVyJ1xuICAgIH0pO1xuICAgIC8vIC0tLSBUaXRsZSBCYXIgLS0tXG4gICAgY29uc3QgdGl0bGVDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LXRpdGxlLWNvbnRhaW5lcicgfSk7XG4gICAgY29uc3QgdGl0bGVJbnB1dCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVJbnB1dEVsZW1lbnQpKHtcbiAgICAgICAgaWQ6ICdjaGF0LXRpdGxlLWlucHV0JyxcbiAgICAgICAgY2xhc3NlczogJ2NoYXQtdGl0bGUtaW5wdXQnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IHR5cGU6ICd0ZXh0JywgcGxhY2Vob2xkZXI6ICdDaGF0IHRpdGxlJywgdmFsdWU6ICdOZXcgQ2hhdCcgfVxuICAgIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25UaXRsZUNoYW5nZSkge1xuICAgICAgICB0aXRsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IGNhbGxiYWNrcy5vblRpdGxlQ2hhbmdlKHRpdGxlSW5wdXQudmFsdWUpKTtcbiAgICB9XG4gICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGVJbnB1dCk7XG4gICAgLy8gLS0tIE1lc3NhZ2UgJiBIaXN0b3J5IENvbnRhaW5lcnMgLS0tXG4gICAgY29uc3QgbWVzc2FnZUNvbnRhaW5lciA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtbWVzc2FnZS1jb250YWluZXInIH0pO1xuICAgIGNvbnN0IGhpc3RvcnlDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWhpc3RvcnktY29udGFpbmVyJyxcbiAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gLy8gSGlkZGVuIGJ5IGRlZmF1bHRcbiAgICB9KTtcbiAgICAvLyAtLS0gQm90dG9tIEJhciBBcmVhIC0tLVxuICAgIGNvbnN0IGJvdHRvbUJhckNvbnRhaW5lciA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtYm90dG9tLWJhci1jb250YWluZXInIH0pO1xuICAgIC8vIFJvdyAxOiBDb250cm9scyAoTWFya2Rvd24gVG9nZ2xlLCBALCBFeHBhbmQsIFNldHRpbmdzKVxuICAgIGNvbnN0IGNvbnRyb2xzUm93ID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWNvbnRyb2xzLXJvdycgfSk7XG4gICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWNvbnRyb2xzLWNvbnRhaW5lcicgfSk7XG4gICAgLy8gTWFya2Rvd24gVG9nZ2xlXG4gICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC10b2dnbGUtY29udGFpbmVyJyB9KTtcbiAgICBjb25zdCBtYXJrZG93blRvZ2dsZUJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVJbnB1dEVsZW1lbnQpKHtcbiAgICAgICAgaWQ6ICdtYXJrZG93bi10b2dnbGUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IHR5cGU6ICdjaGVja2JveCcgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRvZ2dsZUxhYmVsID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUxhYmVsRWxlbWVudCkoe1xuICAgICAgICB0ZXh0OiAnTWFya2Rvd24gbW9kZScsXG4gICAgICAgIGh0bWxGb3I6ICdtYXJrZG93bi10b2dnbGUnXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbk1hcmtkb3duVG9nZ2xlQ2hhbmdlKSB7XG4gICAgICAgIG1hcmtkb3duVG9nZ2xlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5vbk1hcmtkb3duVG9nZ2xlQ2hhbmdlKG1hcmtkb3duVG9nZ2xlQnV0dG9uLmNoZWNrZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9nZ2xlQ29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmtkb3duVG9nZ2xlQnV0dG9uKTtcbiAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlTGFiZWwpO1xuICAgIC8vIEFjdGlvbiBCdXR0b25zIChALCBFeHBhbmQsIFNldHRpbmdzKVxuICAgIGNvbnN0IGFjdGlvbkJ1dHRvbnNDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWFjdGlvbi1idXR0b25zLWNvbnRhaW5lcicgfSk7XG4gICAgY29uc3QgYXRCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7IHRleHQ6ICdAJywgYXR0cmlidXRlczogeyB0aXRsZTogJ0Jyb3dzZSBjZWxscywgY29kZSwgZmlsZXMsIGFuZCBtb3JlJyB9LCBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbicgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbkF0QnV0dG9uQ2xpY2spIHtcbiAgICAgICAgYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFja3Mub25BdEJ1dHRvbkNsaWNrKTtcbiAgICB9XG4gICAgY29uc3QgZXhwYW5kQnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoeyB0ZXh0OiAn4qSiJywgYXR0cmlidXRlczogeyB0aXRsZTogJ0V4cGFuZCBpbnB1dCcgfSwgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25FeHBhbmRUb2dnbGVDbGljaykge1xuICAgICAgICBleHBhbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBjYWxsYmFja3Mub25FeHBhbmRUb2dnbGVDbGljayhleHBhbmRCdXR0b24pKTtcbiAgICB9XG4gICAgY29uc3Qgc2V0dGluZ3NCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7IHRleHQ6ICfimpnvuI8nLCBhdHRyaWJ1dGVzOiB7IHRpdGxlOiAnU2V0dGluZ3MnIH0sIGNsYXNzZXM6ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJyB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uU2V0dGluZ3NDbGljaykge1xuICAgICAgICBzZXR0aW5nc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrcy5vblNldHRpbmdzQ2xpY2spO1xuICAgIH1cbiAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGF0QnV0dG9uKTtcbiAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGV4cGFuZEJ1dHRvbik7XG4gICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZXR0aW5nc0J1dHRvbik7XG4gICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlQ29udGFpbmVyKTtcbiAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b25zQ29udGFpbmVyKTtcbiAgICBjb250cm9sc1Jvdy5hcHBlbmRDaGlsZChjb250cm9sc0NvbnRhaW5lcik7XG4gICAgLy8gUm93IDI6IElucHV0IEZpZWxkXG4gICAgY29uc3QgaW5wdXRSb3cgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtaW5wdXQtcm93JyB9KTtcbiAgICBjb25zdCBpbnB1dEZpZWxkID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZVRleHRBcmVhKSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWlucHV0LWZpZWxkJyxcbiAgICAgICAgYXR0cmlidXRlczogeyBwbGFjZWhvbGRlcjogJ0FzayBtZSBhbnl0aGluZy4uLicsIHJvd3M6ICcxJyB9XG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbklucHV0RmllbGRLZXlQcmVzcykge1xuICAgICAgICBpbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgY2FsbGJhY2tzLm9uSW5wdXRGaWVsZEtleVByZXNzKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrcy5vbklucHV0RmllbGRWYWx1ZUNoYW5nZSkge1xuICAgICAgICBpbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4gY2FsbGJhY2tzLm9uSW5wdXRGaWVsZFZhbHVlQ2hhbmdlKGlucHV0RmllbGQudmFsdWUpKTtcbiAgICB9XG4gICAgaW5wdXRSb3cuYXBwZW5kQ2hpbGQoaW5wdXRGaWVsZCk7XG4gICAgLy8gUm93IDM6IE1haW4gQnV0dG9ucyAoU2VuZCwgTmV3IENoYXQsIEhpc3RvcnkpXG4gICAgY29uc3QgYnV0dG9uc1JvdyA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtYm90dG9tLWJhci1yb3cganAtbGxtLWV4dC1idXR0b25zLXJvdycgfSk7XG4gICAgY29uc3Qgc2VuZEJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVCdXR0b24pKHtcbiAgICAgICAgdGV4dDogJ1NlbmQnLFxuICAgICAgICBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtc2VuZC1idXR0b24nXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vblNlbmRNZXNzYWdlQ2xpY2spIHtcbiAgICAgICAgc2VuZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrcy5vblNlbmRNZXNzYWdlQ2xpY2spO1xuICAgIH1cbiAgICBjb25zdCBuZXdDaGF0QnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoe1xuICAgICAgICB0ZXh0OiAnKyBOZXcgQ2hhdCcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdTdGFydCBhIG5ldyBjaGF0JyB9LFxuICAgICAgICBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbidcbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uTmV3Q2hhdENsaWNrKSB7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFja3Mub25OZXdDaGF0Q2xpY2spO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5QnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoe1xuICAgICAgICB0ZXh0OiAnSGlzdG9yeScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdWaWV3IGNoYXQgaGlzdG9yeScgfSxcbiAgICAgICAgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbkhpc3RvcnlUb2dnbGVDbGljaykge1xuICAgICAgICBoaXN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FsbGJhY2tzLm9uSGlzdG9yeVRvZ2dsZUNsaWNrKTtcbiAgICB9XG4gICAgYnV0dG9uc1Jvdy5hcHBlbmRDaGlsZChzZW5kQnV0dG9uKTtcbiAgICBidXR0b25zUm93LmFwcGVuZENoaWxkKG5ld0NoYXRCdXR0b24pO1xuICAgIGJ1dHRvbnNSb3cuYXBwZW5kQ2hpbGQoaGlzdG9yeUJ1dHRvbik7XG4gICAgLy8gQXNzZW1ibGUgQm90dG9tIEJhclxuICAgIGJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sc1Jvdyk7XG4gICAgYm90dG9tQmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0Um93KTtcbiAgICBib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uc1Jvdyk7XG4gICAgLy8gLS0tIEFzc2VtYmxlIE1haW4gRWxlbWVudCAtLS1cbiAgICBtYWluRWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZUNvbnRhaW5lcik7XG4gICAgbWFpbkVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZUNvbnRhaW5lcik7XG4gICAgbWFpbkVsZW1lbnQuYXBwZW5kQ2hpbGQoaGlzdG9yeUNvbnRhaW5lcik7XG4gICAgbWFpbkVsZW1lbnQuYXBwZW5kQ2hpbGQoYm90dG9tQmFyQ29udGFpbmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWluRWxlbWVudCxcbiAgICAgICAgdGl0bGVJbnB1dCxcbiAgICAgICAgbWVzc2FnZUNvbnRhaW5lcixcbiAgICAgICAgaGlzdG9yeUNvbnRhaW5lcixcbiAgICAgICAgaW5wdXRGaWVsZCxcbiAgICAgICAgYm90dG9tQmFyQ29udGFpbmVyLFxuICAgICAgICBzZW5kQnV0dG9uLFxuICAgICAgICBuZXdDaGF0QnV0dG9uLFxuICAgICAgICBoaXN0b3J5QnV0dG9uLFxuICAgICAgICBtYXJrZG93blRvZ2dsZUJ1dHRvbixcbiAgICAgICAgZXhwYW5kQnV0dG9uLFxuICAgICAgICBhdEJ1dHRvbixcbiAgICAgICAgc2V0dGluZ3NCdXR0b25cbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VSZW5kZXJlciA9IHZvaWQgMDtcbmV4cG9ydHMucmVuZGVyVXNlck1lc3NhZ2UgPSByZW5kZXJVc2VyTWVzc2FnZTtcbmV4cG9ydHMucmVuZGVyQm90TWVzc2FnZSA9IHJlbmRlckJvdE1lc3NhZ2U7XG5leHBvcnRzLnJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdTdGFydCA9IHJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdTdGFydDtcbmV4cG9ydHMucmVuZGVyQm90TWVzc2FnZVN0cmVhbWluZ1VwZGF0ZSA9IHJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdVcGRhdGU7XG5leHBvcnRzLnJlbmRlckJvdE1lc3NhZ2VGaW5hbCA9IHJlbmRlckJvdE1lc3NhZ2VGaW5hbDtcbmNvbnN0IG1hcmtlZF8xID0gcmVxdWlyZShcIm1hcmtlZFwiKTtcbmNvbnN0IGRvbXB1cmlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkb21wdXJpZnlcIikpO1xuLy8gaW1wb3J0IGhsanMgZnJvbSAnaGlnaGxpZ2h0LmpzJzsgLy8gUmVtb3ZlZCB1bnVzZWQgaW1wb3J0XG5jb25zdCBkb21fZWxlbWVudHNfMSA9IHJlcXVpcmUoXCIuL2RvbS1lbGVtZW50c1wiKTtcbi8vIFJlbW92ZWQgdW51c2VkIGltcG9ydCBibG9jayBmb3IgY29kZS1yZWYtd2lkZ2V0XG4vLyBpbXBvcnQge1xuLy8gICBDb2RlUmVmRGF0YSxcbi8vICAgY3JlYXRlQ29kZVJlZldpZGdldEhUTUwsXG4vLyAgIGF0dGFjaENvZGVSZWZFdmVudExpc3RlbmVycyxcbi8vICAgZGVmYXVsdENvZGVSZWZUb2dnbGVMb2dpY1xuLy8gfSBmcm9tICcuL2NvZGUtcmVmLXdpZGdldCc7XG4vLyBSZW1vdmVkIHVudXNlZCBpbXBvcnQgYmxvY2sgZm9yIGNsaXBib2FyZCB1dGlscyAodXNlZCB2aWEgY2FsbGJhY2tzKVxuLy8gaW1wb3J0IHsgY29weVRvQ2xpcGJvYXJkLCBjb3B5SW1hZ2VUb0NsaXBib2FyZCwgY29weU1lc3NhZ2VUb0NsaXBib2FyZCB9IGZyb20gJy4uL3V0aWxzL2NsaXBib2FyZCc7XG4vLyBSZW1vdmVkIHVudXNlZCBpbXBvcnQgKHVzZWQgdmlhIGNhbGxiYWNrcylcbi8vIGltcG9ydCB7IGFkZE1lc3NhZ2VUb0NlbGwgfSBmcm9tICcuLi91dGlscy9ub3RlYm9vay1pbnRlZ3JhdGlvbic7XG5jb25zdCBoaWdobGlnaHRpbmdfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9oaWdobGlnaHRpbmdcIik7XG5jb25zdCBtYXJrZG93bl9jb25maWdfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9tYXJrZG93bi1jb25maWdcIik7XG4vKipcbiAqIEJhc2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbWVzc2FnZSBjb250YWluZXIgZGl2LlxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRGl2KHNlbmRlcikge1xuICAgIGNvbnN0IG1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtZXNzYWdlRGl2LmNsYXNzTmFtZSA9IHNlbmRlciA9PT0gJ3VzZXInID8gJ2pwLWxsbS1leHQtdXNlci1tZXNzYWdlJyA6ICdqcC1sbG0tZXh0LWJvdC1tZXNzYWdlJztcbiAgICByZXR1cm4gbWVzc2FnZURpdjtcbn1cbi8qKlxuICogUmVuZGVycyBhIHVzZXIgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyVXNlck1lc3NhZ2UodGV4dCwgb3B0aW9ucyA9IHt9LCBjYWxsYmFja3MgPSB7fSkge1xuICAgIGNvbnN0IG1lc3NhZ2VEaXYgPSBjcmVhdGVNZXNzYWdlRGl2KCd1c2VyJyk7XG4gICAgLy8gSGFuZGxlIHVzZXIgbWVzc2FnZSB3aXRoIGNvZGUgcmVmZXJlbmNlcyAobG9naWMgdG8gYmUgbW92ZWQgZnJvbSBhZGRNZXNzYWdlKVxuICAgIGlmIChvcHRpb25zLmlzTWFya2Rvd24pIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBVc2VyIG1lc3NhZ2Ugd2l0aCBjb2RlIHJlZmVyZW5jZXMgKHBsYWNlaG9sZGVyKVxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ3VzZXItY29udGVudC13aXRoLXJlZnMnO1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIGNvZGUgcmVmZXJlbmNlIHdpZGdldCBjcmVhdGlvbiBsb2dpYyBoZXJlXG4gICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSBgW0NvZGUgUmVmcyBQbGFjZWhvbGRlcl0gJHt0ZXh0fWA7XG4gICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXNzYWdlRGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VEaXY7XG59XG4vKipcbiAqIFJlbmRlcnMgYSBib3QgbWVzc2FnZSAodGV4dCwgbWFya2Rvd24sIGltYWdlcywgY29kZSBibG9ja3MpLlxuICovXG5mdW5jdGlvbiByZW5kZXJCb3RNZXNzYWdlKHRleHQsIG9wdGlvbnMgPSB7IGlzTWFya2Rvd246IHRydWUgfSwgY2FsbGJhY2tzID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlRGl2ID0gY3JlYXRlTWVzc2FnZURpdignYm90Jyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgaXMgYW4gaW1hZ2UgVVJMXG4gICAgY29uc3QgaXNJbWFnZVVybCA9IHRleHQudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJykgJiZcbiAgICAgICAgKHRleHQudHJpbSgpLmVuZHNXaXRoKCcucG5nJykgfHxcbiAgICAgICAgICAgIHRleHQudHJpbSgpLmVuZHNXaXRoKCcuanBnJykgfHxcbiAgICAgICAgICAgIHRleHQudHJpbSgpLmVuZHNXaXRoKCcuanBlZycpIHx8XG4gICAgICAgICAgICB0ZXh0LnRyaW0oKS5lbmRzV2l0aCgnLmdpZicpKTtcbiAgICBpZiAoaXNJbWFnZVVybCkge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgZnVsbCBVUkwgKFRPRE86IE1ha2UgYmFzZSBVUkwgY29uZmlndXJhYmxlKVxuICAgICAgICBjb25zdCBmdWxsSW1hZ2VVcmwgPSBgaHR0cDovLzEyNy4wLjAuMTo4MDAwJHt0ZXh0LnRyaW0oKX1gO1xuICAgICAgICAvLyBDYWxsIGRlZGljYXRlZCBpbWFnZSByZW5kZXJpbmcgZnVuY3Rpb25cbiAgICAgICAgcmVuZGVySW1hZ2VNZXNzYWdlKG1lc3NhZ2VEaXYsIGZ1bGxJbWFnZVVybCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5pc01hcmtkb3duKSB7XG4gICAgICAgIC8vIFJlbmRlciBhcyBtYXJrZG93biAobG9naWMgZnJvbSBhZGRNZXNzYWdlKVxuICAgICAgICBjb25zdCBtYXJrZG93bkluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXJrZG93bkluZGljYXRvci50ZXh0Q29udGVudCA9IFwiTURcIjtcbiAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IuY2xhc3NOYW1lID0gJ21hcmtkb3duLWluZGljYXRvcic7XG4gICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ21hcmtkb3duLWNvbnRlbnQnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9ICgwLCBtYXJrZG93bl9jb25maWdfMS5wcmVwcm9jZXNzTWFya2Rvd24pKHRleHQpO1xuICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgLy8gRW5oYW5jZSBjb2RlIGJsb2NrcyBhZnRlciBzZXR0aW5nIGlubmVySFRNTFxuICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgIGNvZGVCbG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgZW5oYW5jZUNvZGVCbG9jayhibG9jaywgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFuZCByZW5kZXIgaW50ZXJydXB0IGJ1dHRvbnNcbiAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJydXB0ID0gdGV4dC5zdGFydHNXaXRoKCcqKltJTlRFUlJVUFRdKionKTtcbiAgICAgICAgICAgIGlmIChpc0ludGVycnVwdCkge1xuICAgICAgICAgICAgICAgIHJlbmRlckludGVycnVwdEJ1dHRvbnMoY29udGVudERpdiwgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSB0ZXh0OyAvLyBGYWxsYmFjayB0byBwbGFpbiB0ZXh0XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVuZGVyIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgICAgICAvLyBBZGQgb3ZlcmFsbCBtZXNzYWdlIGFjdGlvbiBidXR0b25zIEFGVEVSIGNvbnRlbnQgaXMgYWRkZWRcbiAgICAgICAgYWRkQm90TWVzc2FnZUFjdGlvbnMobWVzc2FnZURpdiwgdGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlbmRlciBhcyBwbGFpbiB0ZXh0XG4gICAgICAgIG1lc3NhZ2VEaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAvLyBBZGQgb3ZlcmFsbCBtZXNzYWdlIGFjdGlvbiBidXR0b25zIGV2ZW4gZm9yIHBsYWluIHRleHQgYm90IG1lc3NhZ2VzXG4gICAgICAgIGFkZEJvdE1lc3NhZ2VBY3Rpb25zKG1lc3NhZ2VEaXYsIHRleHQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlRGl2O1xufVxuLy8gRGVmaW5lIGNyZWF0ZU1lc3NhZ2VXcmFwcGVyIGJhc2VkIG9uIGNyZWF0ZU1lc3NhZ2VEaXZcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VXcmFwcGVyKHNlbmRlcikge1xuICAgIHJldHVybiBjcmVhdGVNZXNzYWdlRGl2KHNlbmRlcik7XG59XG4vLyAtLS0gTW9yZSBzcGVjaWZpYyByZW5kZXJpbmcgZnVuY3Rpb25zIG9yIGhlbHBlcnMgY2FuIGJlIGFkZGVkIGJlbG93IC0tLVxuLyoqXG4gKiBSZW5kZXJzIGFuIGltYWdlIG1lc3NhZ2Ugd2l0aCBhY3Rpb24gYnV0dG9ucyBpbnNpZGUgYSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciBUaGUgcGFyZW50IEhUTUwgZWxlbWVudCB0byBhcHBlbmQgdGhlIGltYWdlIG1lc3NhZ2UgdG8uXG4gKiBAcGFyYW0gaW1hZ2VVcmwgVGhlIGZ1bGwgVVJMIG9mIHRoZSBpbWFnZSB0byByZW5kZXIuXG4gKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgYWN0aW9ucyBsaWtlIGNvcHkgaW1hZ2UsIGFkZCBwYXRoLlxuICovXG5mdW5jdGlvbiByZW5kZXJJbWFnZU1lc3NhZ2UoY29udGFpbmVyLCBpbWFnZVVybCwgY2FsbGJhY2tzID0ge30pIHtcbiAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSBpbWFnZSB0aGF0IGFsbG93cyBwb3NpdGlvbmluZyB0aGUgYnV0dG9uc1xuICAgIGNvbnN0IGltYWdlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW1hZ2VDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW1hZ2UtY29udGFpbmVyJztcbiAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgLy8gUmVuZGVyIGFzIGFuIGltYWdlIHRhZ1xuICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltZy5zcmMgPSBpbWFnZVVybDtcbiAgICBpbWcuYWx0ID0gJ0ltYWdlIGZyb20gYm90JztcbiAgICBpbWcuc3R5bGUubWF4V2lkdGggPSAnMTAwJSc7IC8vIEVuc3VyZSBpbWFnZSBmaXRzIHdpdGhpbiB0aGUgY29udGFpbmVyXG4gICAgaW1nLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICBpbWFnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWcpO1xuICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgdGhlIGltYWdlXG4gICAgY29uc3QgaW1nQWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGltZ0FjdGlvbnNEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW1hZ2UtYWN0aW9ucyc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5ib3R0b20gPSAnMTBweCc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5yaWdodCA9ICcxMHB4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5nYXAgPSAnOHB4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNiknOyAvLyBBZGRlZCBzbGlnaHQgYmFja2dyb3VuZCBmb3IgdmlzaWJpbGl0eVxuICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgLy8gQ29weSBpbWFnZSBidXR0b24gKHVzaW5nIGNhbGxiYWNrKVxuICAgIGlmIChjYWxsYmFja3MuY29weUltYWdlVG9DbGlwYm9hcmQgJiYgY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2spIHtcbiAgICAgICAgY29uc3QgY29weUltZ0J0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5SW1nQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBjb3B5SW1nQnRuLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBjb3B5SW1nQnRuLnRpdGxlID0gJ0NvcHkgaW1hZ2UgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgY29uc3QgZmVlZGJhY2tDYiA9ICgpID0+IGNhbGxiYWNrcy5zaG93Q29weUZlZWRiYWNrKGNvcHlJbWdCdG4pO1xuICAgICAgICBjb3B5SW1nQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5jb3B5SW1hZ2VUb0NsaXBib2FyZChpbWFnZVVybCwgZmVlZGJhY2tDYik7XG4gICAgICAgIH0pO1xuICAgICAgICBpbWdBY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlJbWdCdG4pO1xuICAgIH1cbiAgICAvLyBBZGQgZmlsZSBwYXRoIGJ1dHRvbiAodXNpbmcgY2FsbGJhY2spXG4gICAgaWYgKGNhbGxiYWNrcy5hZGRNZXNzYWdlVG9DZWxsKSB7XG4gICAgICAgIGNvbnN0IGFkZFBhdGhCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkUGF0aEJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgYWRkUGF0aEJ0bi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGFkZFBhdGhCdG4udGl0bGUgPSAnQWRkIGltYWdlIHBhdGggdG8gY3VycmVudCBjZWxsJztcbiAgICAgICAgYWRkUGF0aEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBpbWFnZSBVUkwgKHdoaWNoIGlzIHRoZSBtZXNzYWdlIHRleHQgaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwoaW1hZ2VVcmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW1nQWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRQYXRoQnRuKTtcbiAgICB9XG4gICAgLy8gT25seSBhZGQgdGhlIGFjdGlvbnMgZGl2IGlmIGl0IGhhcyBidXR0b25zXG4gICAgaWYgKGltZ0FjdGlvbnNEaXYuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGltZ0FjdGlvbnNEaXYpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGltYWdlIGNvbnRhaW5lciB0byB0aGUgbWFpbiBtZXNzYWdlIGRpdlxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWFnZUNvbnRhaW5lcik7XG59XG4vKipcbiAqIENyZWF0ZXMgdGhlIGluaXRpYWwgc3RydWN0dXJlIGZvciBhIGJvdCBtZXNzYWdlIHRoYXQgd2lsbCByZWNlaXZlIHN0cmVhbWluZyBjb250ZW50LlxuICpcbiAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIHRoZSB3cmFwcGVyLCBzdHJlYW1pbmcgZGl2LCBhbmQgZmluYWwgY29udGVudCBkaXYuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdTdGFydCgpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlTWVzc2FnZVdyYXBwZXIoJ2JvdCcpO1xuICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoe1xuICAgICAgICB0ZXh0OiAnTUQnLFxuICAgICAgICBjbGFzc2VzOiAnbWFya2Rvd24taW5kaWNhdG9yJ1xuICAgIH0pO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgIGNvbnN0IHN0cmVhbWluZ0RpdiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ3N0cmVhbWluZy1jb250ZW50JyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMC45ZW0nXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgY29uc3QgY29udGVudERpdiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ21hcmtkb3duLWNvbnRlbnQnLFxuICAgICAgICBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgfSk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICByZXR1cm4geyB3cmFwcGVyLCBzdHJlYW1pbmdEaXYsIGNvbnRlbnREaXYgfTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RyZWFtaW5nIGRpdiB3aXRoIGEgbmV3IGNodW5rIG9mIHRleHQuXG4gKlxuICogQHBhcmFtIHN0cmVhbWluZ0RpdiAtIFRoZSBkaXYgZGlzcGxheWluZyBzdHJlYW1pbmcgY29udGVudC5cbiAqIEBwYXJhbSBjaHVuayAtIFRoZSBuZXcgdGV4dCBjaHVuayB0byBhcHBlbmQuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdVcGRhdGUoc3RyZWFtaW5nRGl2LCBjaHVuaykge1xuICAgIC8vIFNpbXBsZSBhcHBlbmQsIG1pZ2h0IG5lZWQgcmVmaW5lbWVudCBmb3IgY29tcGxleCBzdHJlYW1zXG4gICAgc3RyZWFtaW5nRGl2LnRleHRDb250ZW50ICs9IGNodW5rO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBmaW5hbCBjb250ZW50IG9mIGEgYm90IG1lc3NhZ2UgYWZ0ZXIgc3RyZWFtaW5nIGlzIGNvbXBsZXRlLlxuICogSGFuZGxlcyBtYXJrZG93biwgaW1hZ2VzLCBjb2RlIGJsb2NrcywgYW5kIGludGVycnVwdHMuXG4gKlxuICogQHBhcmFtIGNvbnRlbnREaXYgLSBUaGUgZGl2IHdoZXJlIHRoZSBmaW5hbCBjb250ZW50IHNob3VsZCBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSBzdHJlYW1pbmdEaXYgLSBUaGUgZGl2IHRoYXQgd2FzIHVzZWQgZm9yIHN0cmVhbWluZyAod2lsbCBiZSBoaWRkZW4pLlxuICogQHBhcmFtIGNvbXBsZXRlUmVzcG9uc2UgLSBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgYm90LlxuICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucyBpbmNsdWRpbmcgY2FsbGJhY2tzIGZvciBhY3Rpb25zLlxuICogQHJldHVybnMgVGhlIHBvcHVsYXRlZCBjb250ZW50RGl2LlxuICovXG5mdW5jdGlvbiByZW5kZXJCb3RNZXNzYWdlRmluYWwoY29udGVudERpdiwgc3RyZWFtaW5nRGl2LCBjb21wbGV0ZVJlc3BvbnNlLCBvcHRpb25zID0ge30sIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IGZpbmFsIGNvbnRlbnQgZGl2XG4gICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAvLyBDb25zb2xpZGF0ZSBjYWxsYmFja3MgYWNjZXNzXG4gICAgY29uc3QgZWZmZWN0aXZlQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgY2FsbGJhY2tzKTtcbiAgICAvLyAtLS0gSW1hZ2UgSGFuZGxpbmcgLS0tXG4gICAgY29uc3QgaXNJbWFnZVVybCA9IGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJykgJiZcbiAgICAgICAgKGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcucG5nJykgfHxcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcuanBnJykgfHxcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcuanBlZycpIHx8XG4gICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKS5lbmRzV2l0aCgnLmdpZicpKTtcbiAgICBpZiAoaXNJbWFnZVVybCkge1xuICAgICAgICBjb25zdCBmdWxsSW1hZ2VVcmwgPSBgaHR0cDovLzEyNy4wLjAuMTo4MDAwJHtjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKX1gOyAvLyBUT0RPOiBNYWtlIGJhc2UgVVJMIGNvbmZpZ3VyYWJsZVxuICAgICAgICByZW5kZXJJbWFnZU1lc3NhZ2UoY29udGVudERpdiwgZnVsbEltYWdlVXJsLCBlZmZlY3RpdmVDYWxsYmFja3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gLS0tIE1hcmtkb3duICYgQ29kZSBCbG9jayBIYW5kbGluZyAtLS1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKShjb21wbGV0ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRIdG1sID0gZG9tcHVyaWZ5XzEuZGVmYXVsdC5zYW5pdGl6ZShyYXdIdG1sKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgIC8vIC0tLSBJbnRlcnJ1cHQgSGFuZGxpbmcgLS0tXG4gICAgICAgICAgICBjb25zdCBpc0ludGVycnVwdCA9IGNvbXBsZXRlUmVzcG9uc2Uuc3RhcnRzV2l0aCgnKipbSU5URVJSVVBUXSoqJyk7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcnJ1cHQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbnRlcnJ1cHRCdXR0b25zKGNvbnRlbnREaXYsIGVmZmVjdGl2ZUNhbGxiYWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0gQ29kZSBCbG9jayBFbmhhbmNlbWVudHMgLS0tXG4gICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBlbmhhbmNlQ29kZUJsb2NrKGJsb2NrLCBlZmZlY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgY29udGVudERpdi50ZXh0Q29udGVudCA9IGNvbXBsZXRlUmVzcG9uc2U7IC8vIEZhbGxiYWNrIHRvIHBsYWluIHRleHRcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGVudERpdjtcbn1cbi8qKlxuICogRW5oYW5jZXMgYSBjb2RlIGJsb2NrIGVsZW1lbnQgd2l0aCBoaWdobGlnaHRpbmcgYW5kIGFjdGlvbiBidXR0b25zLlxuICpcbiAqIEBwYXJhbSBjb2RlQmxvY2tFbGVtZW50IFRoZSA8Y29kZT4gZWxlbWVudCB3aXRoaW4gYSA8cHJlPi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBhY3Rpb25zIGxpa2UgY29weSBjb2RlLCBhZGQgdG8gY2VsbC5cbiAqL1xuZnVuY3Rpb24gZW5oYW5jZUNvZGVCbG9jayhjb2RlQmxvY2tFbGVtZW50LCBjYWxsYmFja3MgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmVFbGVtZW50ID0gY29kZUJsb2NrRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghcHJlRWxlbWVudCB8fCBwcmVFbGVtZW50LnRhZ05hbWUgIT09ICdQUkUnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29kZSBibG9jayBlbmhhbmNlbWVudCBjYWxsZWQgb24gZWxlbWVudCBub3Qgd2l0aGluIGEgPHByZT4gdGFnLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFkZCBzdGFuZGFyZCBKdXB5dGVyTGFiIGNsYXNzZXMgZm9yIGNvbnNpc3RlbmN5XG4gICAgY29kZUJsb2NrRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZFRleHQnKTtcbiAgICBwcmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgIC8vIEdldCBjb2RlIGNvbnRlbnRcbiAgICBjb25zdCBjb2RlQ29udGVudCA9IGNvZGVCbG9ja0VsZW1lbnQudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgLy8gQ3JlYXRlIGNvZGUgYmxvY2sgaGVhZGVyIGZvciBidXR0b25zIGFuZCBsYW5ndWFnZSBpbmRpY2F0b3JcbiAgICBjb25zdCBjb2RlSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29kZUhlYWRlci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWhlYWRlcic7XG4gICAgLy8gQWRkIGxhbmd1YWdlIGluZGljYXRvciBpZiBkZXRlY3RlZFxuICAgIGNvbnN0IGxhbmd1YWdlID0gKDAsIGhpZ2hsaWdodGluZ18xLmRldGVjdExhbmd1YWdlKShjb2RlQ29udGVudCk7IC8vIFVzZSBpbXBvcnRlZCB1dGlsXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgIGNvbnN0IGxhbmdJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxhbmdJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1sYW5ndWFnZSc7XG4gICAgICAgIGxhbmdJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBsYW5ndWFnZTtcbiAgICAgICAgY29kZUhlYWRlci5hcHBlbmRDaGlsZChsYW5nSW5kaWNhdG9yKTtcbiAgICAgICAgY29kZUJsb2NrRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBsYW5ndWFnZS0ke2xhbmd1YWdlfWApO1xuICAgIH1cbiAgICAvLyBBcHBseSBzeW50YXggaGlnaGxpZ2h0aW5nXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVXNlIGltcG9ydGVkIHV0aWwgKGhhbmRsZXMgYXV0by1kZXRlY3Rpb24gaWYgbGFuZ3VhZ2UgaXMgZW1wdHkpXG4gICAgICAgIGNvZGVCbG9ja0VsZW1lbnQuaW5uZXJIVE1MID0gKDAsIGhpZ2hsaWdodGluZ18xLmhpZ2hsaWdodENvZGUpKGNvZGVDb250ZW50LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyBzeW50YXggaGlnaGxpZ2h0aW5nOicsIGVycm9yKTtcbiAgICAgICAgLy8gY29kZUJsb2NrRWxlbWVudCBtaWdodCBjb250YWluIG9yaWdpbmFsIHRleHQgb3IgcGFydGlhbGx5IGhpZ2hsaWdodGVkXG4gICAgfVxuICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyB0byB0aGUgY29kZSBoZWFkZXJcbiAgICBjb25zdCBhY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbnMnO1xuICAgIC8vIENvcHkgYnV0dG9uXG4gICAgaWYgKGNhbGxiYWNrcy5jb3B5VG9DbGlwYm9hcmQgJiYgY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2spIHtcbiAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBjb2RlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrQ2IgPSAoKSA9PiBjYWxsYmFja3Muc2hvd0NvcHlGZWVkYmFjayhjb3B5QnV0dG9uKTtcbiAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuY29weVRvQ2xpcGJvYXJkKGNvZGVDb250ZW50LCBmZWVkYmFja0NiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgfVxuICAgIC8vIEFkZCB0byBjZWxsIGJ1dHRvblxuICAgIGlmIChjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbCkge1xuICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBhZGRUb0J1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBhZGRUb0J1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBjb2RlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgIGFkZFRvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5hZGRNZXNzYWdlVG9DZWxsKGNvZGVDb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoYWRkVG9CdXR0b24pO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGFjdGlvbnMgdG8gdGhlIGhlYWRlciwgYW5kIGluc2VydCBoZWFkZXIgYmVmb3JlIHRoZSA8cHJlPlxuICAgIGlmIChhY3Rpb25zRGl2Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjb2RlSGVhZGVyLmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgIH1cbiAgICBpZiAoY29kZUhlYWRlci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgKF9hID0gcHJlRWxlbWVudC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5zZXJ0QmVmb3JlKGNvZGVIZWFkZXIsIHByZUVsZW1lbnQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVuZGVycyBDb25maXJtL1JlamVjdCBidXR0b25zIGZvciBhbiBpbnRlcnJ1cHQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIFRoZSBwYXJlbnQgSFRNTCBlbGVtZW50IChtZXNzYWdlIGNvbnRlbnQgZGl2KSB0byBhcHBlbmQgYnV0dG9ucyB0by5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBjb25maXJtIGFuZCByZWplY3QgYWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVySW50ZXJydXB0QnV0dG9ucyhjb250YWluZXIsIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgaWYgKCFjYWxsYmFja3MuaGFuZGxlQ29uZmlybUludGVycnVwdCB8fCAhY2FsbGJhY2tzLmhhbmRsZVJlamVjdEludGVycnVwdCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludGVycnVwdCBtZXNzYWdlIG5lZWRzIGNvbmZpcm0vcmVqZWN0IGNhbGxiYWNrcy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidXR0b25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbnRlcnJ1cHQtYnV0dG9ucyc7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3AgPSAnMTJweCc7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIGJ1dHRvbnNDb250YWluZXIuc3R5bGUuZ2FwID0gJzhweCc7XG4gICAgLy8gQ3JlYXRlIGNvbmZpcm0gYnV0dG9uXG4gICAgY29uc3QgY29uZmlybUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGNvbmZpcm1CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29uZmlybS1idXR0b24nO1xuICAgIGNvbmZpcm1CdXR0b24udGV4dENvbnRlbnQgPSAnQ29uZmlybSc7XG4gICAgLy8gQXBwbHkgc3BlY2lmaWMgc3R5bGluZyAoY2FuIGJlIG1vdmVkIHRvIENTUylcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLnBhZGRpbmcgPSAnNnB4IDEycHgnO1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuYmFja2dyb3VuZCA9ICcjNENBRjUwJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAvLyBDcmVhdGUgcmVqZWN0IGJ1dHRvblxuICAgIGNvbnN0IHJlamVjdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHJlamVjdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1yZWplY3QtYnV0dG9uJztcbiAgICByZWplY3RCdXR0b24udGV4dENvbnRlbnQgPSAnUmVqZWN0JztcbiAgICAvLyBBcHBseSBzcGVjaWZpYyBzdHlsaW5nIChjYW4gYmUgbW92ZWQgdG8gQ1NTKVxuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5wYWRkaW5nID0gJzZweCAxMnB4JztcbiAgICByZWplY3RCdXR0b24uc3R5bGUuYmFja2dyb3VuZCA9ICcjRjQ0MzM2JztcbiAgICByZWplY3RCdXR0b24uc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgcmVqZWN0QnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgcmVqZWN0QnV0dG9uLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIGNvbmZpcm1CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgY2FsbGJhY2tzLmhhbmRsZUNvbmZpcm1JbnRlcnJ1cHQoKTtcbiAgICB9KTtcbiAgICByZWplY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgY2FsbGJhY2tzLmhhbmRsZVJlamVjdEludGVycnVwdCgpO1xuICAgIH0pO1xuICAgIC8vIEFkZCBidXR0b25zIHRvIGNvbnRhaW5lciBhbmQgY29udGFpbmVyIHRvIG1lc3NhZ2VcbiAgICBidXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbmZpcm1CdXR0b24pO1xuICAgIGJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQocmVqZWN0QnV0dG9uKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uc0NvbnRhaW5lcik7XG59XG4vKipcbiAqIEFkZHMgb3ZlcmFsbCBhY3Rpb24gYnV0dG9ucyAoQ29weSwgQWRkIHRvIENlbGwpIHRvIGEgYm90IG1lc3NhZ2UgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGl2IFRoZSBtYWluIGRpdiBjb250YWluZXIgZm9yIHRoZSBib3QgbWVzc2FnZS5cbiAqIEBwYXJhbSBtZXNzYWdlVGV4dCBUaGUgcmF3IHRleHQgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBhY3Rpb25zIGxpa2UgY29weSBtZXNzYWdlLCBhZGQgdG8gY2VsbC5cbiAqL1xuZnVuY3Rpb24gYWRkQm90TWVzc2FnZUFjdGlvbnMobWVzc2FnZURpdiwgbWVzc2FnZVRleHQsIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgLy8gT25seSBhZGQgYWN0aW9ucyBpZiBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcyBhcmUgcHJvdmlkZWRcbiAgICBpZiAoIWNhbGxiYWNrcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkICYmICFjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgYWN0aW9uIGJ1dHRvbnMgdG8gYm90IG1lc3NhZ2UnKTsgLy8gS2VlcCBkZWJ1ZyBsb2cgZm9yIG5vd1xuICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9ucyc7XG4gICAgLy8gYWN0aW9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBFbnN1cmUgZGlzcGxheSB2aWEgQ1NTIGlmIG5lZWRlZFxuICAgIC8vIENvcHkgTWVzc2FnZSBidXR0b25cbiAgICBpZiAoY2FsbGJhY2tzLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQgJiYgY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2spIHtcbiAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrQ2IgPSAoKSA9PiBjYWxsYmFja3Muc2hvd0NvcHlGZWVkYmFjayhjb3B5QnV0dG9uKTtcbiAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuY29weU1lc3NhZ2VUb0NsaXBib2FyZChtZXNzYWdlVGV4dCwgZmVlZGJhY2tDYik7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgIH1cbiAgICAvLyBBZGQgdG8gQ2VsbCBidXR0b25cbiAgICBpZiAoY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwpIHtcbiAgICAgICAgY29uc3QgYWRkVG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbChtZXNzYWdlVGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIHRoZSBhY3Rpb25zIGNvbnRhaW5lciBpZiBpdCBoYXMgYW55IGJ1dHRvbnNcbiAgICBpZiAoYWN0aW9uc0Rpdi5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICAgICAgY29uc29sZS5sb2coJ0FjdGlvbiBidXR0b25zIGFkZGVkIHRvIGJvdCBtZXNzYWdlOicsIGFjdGlvbnNEaXYpOyAvLyBLZWVwIGRlYnVnIGxvZ1xuICAgIH1cbn1cbi8vIFBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb25zOlxuLy8gLSByZW5kZXJFcnJvck1lc3NhZ2Vcbi8vIC0gcmVuZGVyU3lzdGVtTWVzc2FnZVxuLy8gLSBBIG1haW4gcmVuZGVyTWVzc2FnZSBmdW5jdGlvbiB0aGF0IGRlbGVnYXRlcyBiYXNlZCBvbiB0eXBlPyBcbi8qKlxuICogSGFuZGxlcyByZW5kZXJpbmcgaW5kaXZpZHVhbCBtZXNzYWdlcyAodXNlciwgYm90LCBzeXN0ZW0pIGludG8gSFRNTCBlbGVtZW50cy5cbiAqL1xuY2xhc3MgTWVzc2FnZVJlbmRlcmVyIHtcbiAgICAvLyBwcml2YXRlIGNhbGxiYWNrczogTWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzOyAvLyBSZW1vdmVkIHVudXNlZCBtZW1iZXJcbiAgICAvLyBwcml2YXRlIHVpTWFuYWdlcjogVUlNYW5hZ2VyOyAvLyBNaWdodCBub3QgYmUgbmVlZGVkIGRpcmVjdGx5IGlmIGNhbGxiYWNrcyBoYW5kbGUgVUkgdXBkYXRlc1xuICAgIGNvbnN0cnVjdG9yKCAvKiBjYWxsYmFja3M6IE1lc3NhZ2VSZW5kZXJlckNhbGxiYWNrcyAqLyAvKiAsIHVpTWFuYWdlcjogVUlNYW5hZ2VyICovKSB7XG4gICAgICAgIC8vIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzOyAvLyBSZW1vdmVkIHVudXNlZCBhc3NpZ25tZW50XG4gICAgICAgIC8vIHRoaXMudWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZVJlbmRlcmVyID0gTWVzc2FnZVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNldHRpbmdzTW9kYWwgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZVNldHRpbmdzTW9kYWxFbGVtZW50ID0gY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQ7XG4vKipcbiAqIENyZWF0ZXMgdGhlIEhUTUwgZWxlbWVudCBmb3IgdGhlIHNldHRpbmdzIG1vZGFsLlxuICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHNhdmUgYW5kIGNhbmNlbCBhY3Rpb25zLlxuICogQHJldHVybnMgVGhlIG1haW4gbW9kYWwgSFRNTEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNldHRpbmdzTW9kYWxFbGVtZW50KGNhbGxiYWNrcykge1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW9kYWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbW9kYWwnO1xuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1jb250ZW50JztcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG4gICAgdGl0bGUuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtdGl0bGUnO1xuICAgIHRpdGxlLnRleHRDb250ZW50ID0gJ1NldHRpbmdzJztcbiAgICBjb250ZW50LmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICBjb25zdCBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIGZvcm0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtZm9ybSc7XG4gICAgLy8gUHJvdmlkZXIgc2VsZWN0aW9uXG4gICAgY29uc3QgcHJvdmlkZXJMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgcHJvdmlkZXJMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgcHJvdmlkZXJMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgUHJvdmlkZXI6JztcbiAgICBmb3JtLmFwcGVuZENoaWxkKHByb3ZpZGVyTGFiZWwpO1xuICAgIGNvbnN0IHByb3ZpZGVyU2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgcHJvdmlkZXJTZWxlY3QuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3Mtc2VsZWN0JztcbiAgICBwcm92aWRlclNlbGVjdC5pZCA9ICdzZXR0aW5ncy1wcm92aWRlcic7IC8vIEtlZXAgSUQgZm9yIHJldHJpZXZhbFxuICAgIFsnT3BlbkFJJywgJ0h1Z2dpbmdGYWNlJywgJ0xvY2FsJ10uZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0O1xuICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBvcHQ7XG4gICAgICAgIHByb3ZpZGVyU2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgfSk7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChwcm92aWRlclNlbGVjdCk7XG4gICAgLy8gQVBJIEtleSBpbnB1dFxuICAgIGNvbnN0IGFwaUtleUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBhcGlLZXlMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgYXBpS2V5TGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIEtleTonO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpS2V5TGFiZWwpO1xuICAgIGNvbnN0IGFwaUtleUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBhcGlLZXlJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1pbnB1dCc7XG4gICAgYXBpS2V5SW5wdXQudHlwZSA9ICdwYXNzd29yZCc7XG4gICAgYXBpS2V5SW5wdXQuaWQgPSAnc2V0dGluZ3MtYXBpLWtleSc7IC8vIEtlZXAgSUQgZm9yIHJldHJpZXZhbFxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpS2V5SW5wdXQpO1xuICAgIC8vIEFQSSBVUkwgaW5wdXRcbiAgICBjb25zdCBhcGlVcmxMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgYXBpVXJsTGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgIGFwaVVybExhYmVsLnRleHRDb250ZW50ID0gJ0FQSSBVUkwgKG9wdGlvbmFsKTonO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpVXJsTGFiZWwpO1xuICAgIGNvbnN0IGFwaVVybElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBhcGlVcmxJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1pbnB1dCc7XG4gICAgYXBpVXJsSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICBhcGlVcmxJbnB1dC5pZCA9ICdzZXR0aW5ncy1hcGktdXJsJzsgLy8gS2VlcCBJRCBmb3IgcmV0cmlldmFsXG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcGlVcmxJbnB1dCk7XG4gICAgLy8gUnVsZXMgaW5wdXRcbiAgICBjb25zdCBydWxlc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBydWxlc0xhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICBydWxlc0xhYmVsLnRleHRDb250ZW50ID0gJ0N1c3RvbSBSdWxlcyAob3B0aW9uYWwpOic7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChydWxlc0xhYmVsKTtcbiAgICBjb25zdCBydWxlc0lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICBydWxlc0lucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLXRleHRhcmVhJztcbiAgICBydWxlc0lucHV0LmlkID0gJ3NldHRpbmdzLXJ1bGVzJzsgLy8gS2VlcCBJRCBmb3IgcmV0cmlldmFsXG4gICAgZm9ybS5hcHBlbmRDaGlsZChydWxlc0lucHV0KTtcbiAgICAvLyBCdXR0b25zIGNvbnRhaW5lclxuICAgIGNvbnN0IGJ0bkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ0bkNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1idXR0b25zJztcbiAgICBjb25zdCBzYXZlQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgc2F2ZUJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1idXR0b24ganAtbGxtLWV4dC1zZXR0aW5ncy1zYXZlLWJ1dHRvbic7XG4gICAgc2F2ZUJ0bi50ZXh0Q29udGVudCA9ICdTYXZlJztcbiAgICBzYXZlQnRuLnR5cGUgPSAnYnV0dG9uJzsgLy8gUHJldmVudCBkZWZhdWx0IGZvcm0gc3VibWlzc2lvblxuICAgIHNhdmVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGltcGxlbWVudGF0aW9uIHdpbGwgaGFuZGxlIHJlYWRpbmcgdmFsdWVzIGFuZCBzYXZpbmdcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBhcGlLZXk6IGFwaUtleUlucHV0LnZhbHVlLFxuICAgICAgICAgICAgYXBpVXJsOiBhcGlVcmxJbnB1dC52YWx1ZSxcbiAgICAgICAgICAgIHJ1bGVzOiBydWxlc0lucHV0LnZhbHVlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyU2VsZWN0LnZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrcy5oYW5kbGVTYXZlKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBjYW5jZWxCdG4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtYnV0dG9uIGpwLWxsbS1leHQtc2V0dGluZ3MtY2FuY2VsLWJ1dHRvbic7XG4gICAgY2FuY2VsQnRuLnRleHRDb250ZW50ID0gJ0NhbmNlbCc7XG4gICAgY2FuY2VsQnRuLnR5cGUgPSAnYnV0dG9uJzsgLy8gUHJldmVudCBkZWZhdWx0IGZvcm0gc3VibWlzc2lvblxuICAgIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYWxsYmFja3MuaGFuZGxlQ2FuY2VsKCk7XG4gICAgfSk7XG4gICAgYnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHNhdmVCdG4pO1xuICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW5jZWxCdG4pO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYnRuQ29udGFpbmVyKTtcbiAgICBjb250ZW50LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHJldHVybiBtb2RhbDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgbWFuYWdlcyB0aGUgc2V0dGluZ3MgbW9kYWwgZGlhbG9nLlxuICovXG5jbGFzcyBTZXR0aW5nc01vZGFsIHtcbiAgICAvLyBwcml2YXRlIG1vZGFsRWxlbWVudDogSFRNTERpdkVsZW1lbnQ7IC8vIENvbW1lbnRlZCBvdXQgLSB1bnVzZWRcbiAgICAvLyBwcml2YXRlIHNldHRpbmdzOiBBcHBTZXR0aW5nczsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZFxuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgICAgICAvLyB0aGlzLm1vZGFsRWxlbWVudCA9IGNyZWF0ZVNldHRpbmdzTW9kYWxFbGVtZW50KGNhbGxiYWNrcyk7IC8vIENvbW1lbnRlZCBvdXQgLSB1bnVzZWQgYXNzaWdubWVudFxuICAgICAgICAvLyB0aGlzLnNldHRpbmdzID0geyAvLyBDb21tZW50ZWQgb3V0IC0gdW51c2VkIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vICAgICBwcm92aWRlcjogJycsIFxuICAgICAgICAvLyAgICAgYXBpS2V5OiAnJywgXG4gICAgICAgIC8vICAgICBhcGlVcmw6ICcnLCBcbiAgICAgICAgLy8gICAgIHJ1bGVzOiAnJyBcbiAgICAgICAgLy8gfTsgXG4gICAgfVxufVxuZXhwb3J0cy5TZXR0aW5nc01vZGFsID0gU2V0dGluZ3NNb2RhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VSU1hbmFnZXIgPSB2b2lkIDA7XG4vKipcbiAqIE1hbmFnZXMgVUkgZWxlbWVudHMgYW5kIHRyYW5zaXRpb25zIGZvciB0aGUgY2hhdCBpbnRlcmZhY2UuXG4gKiBUaGlzIGFjdHMgYXMgYSBjZW50cmFsIHBvaW50IGZvciBVSSBtYW5pcHVsYXRpb25zLCBzaW1wbGlmeWluZyBkZXBlbmRlbmNpZXMgZm9yIGhhbmRsZXJzLlxuICovXG5jbGFzcyBVSU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIGRvY01hbmFnZXI6IElEb2N1bWVudE1hbmFnZXIsIC8vIENvbW1lbnRlZCBvdXQgLSB1bnVzZWQgcGFyYW1ldGVyXG4gICAgcG9wdXBNZW51TWFuYWdlciwgXG4gICAgLy8gd2lkZ2V0Tm9kZTogSFRNTEVsZW1lbnQsIC8vIENvbW1lbnRlZCBvdXQgLSB1bnVzZWQgcGFyYW1ldGVyXG4gICAgY2FsbGJhY2tzLCBsYXlvdXRFbGVtZW50cykge1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSBudWxsOyAvLyBUaW1lb3V0IGZvciB0aGUgc2hvcnRjdXQgaW5kaWNhdG9yXG4gICAgICAgIC8vIEludGVybmFsIFVJIHN0YXRlXG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTtcbiAgICAgICAgLy8gdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZCBhc3NpZ25tZW50XG4gICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlciA9IHBvcHVwTWVudU1hbmFnZXI7IC8vIE5lZWRlZCBmb3IgJ0AnIGJ1dHRvbiBhY3Rpb25cbiAgICAgICAgLy8gdGhpcy53aWRnZXROb2RlID0gd2lkZ2V0Tm9kZTsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZCBhc3NpZ25tZW50XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzOyAvLyBDYWxsYmFja3MgdG8gdHJpZ2dlciB3aWRnZXQvaGFuZGxlciBsb2dpY1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzID0gbGF5b3V0RWxlbWVudHM7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZWxlbWVudHMgdGhhdCBhcmUgY3JlYXRlZCBvdXRzaWRlIGNyZWF0ZUxheW91dCBpZiBhbnlcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBhbGwgY29yZSBlbGVtZW50cyBhcmUgY3JlYXRlZCB3aXRoaW4gY3JlYXRlTGF5b3V0XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYXBwZW5kIHRoZSBpbmRpY2F0b3IgZWxlbWVudFxuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWtleWJvYXJkLXNob3J0Y3V0LWluZGljYXRvcic7XG4gICAgICAgIC8vIEFwcGVuZCBpdCB0byB0aGUgbWFpbiBlbGVtZW50IG1hbmFnZWQgYnkgdGhlIFVJTWFuYWdlclxuICAgICAgICAvLyBFbnN1cmUgbWFpbkVsZW1lbnQgZXhpc3RzIGJlZm9yZSBhcHBlbmRpbmdcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0RWxlbWVudHMubWFpbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMubWFpbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VJTWFuYWdlcjogTWFpbiBsYXlvdXQgZWxlbWVudCBub3QgZm91bmQgZHVyaW5nIGluZGljYXRvciBpbml0aWFsaXphdGlvbi4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb3JlIGxheW91dCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBnZXRVSUVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXRFbGVtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgKi9cbiAgICB0b2dnbGVJbnB1dEV4cGFuc2lvbigpIHtcbiAgICAgICAgLy8gVXNlIGxheW91dEVsZW1lbnRzIHByb3ZpZGVkIHZpYSBjb25zdHJ1Y3RvclxuICAgICAgICBjb25zdCBpbnB1dEZpZWxkID0gdGhpcy5sYXlvdXRFbGVtZW50cy5pbnB1dEZpZWxkO1xuICAgICAgICBjb25zdCBleHBhbmRCdXR0b24gPSB0aGlzLmxheW91dEVsZW1lbnRzLmV4cGFuZEJ1dHRvbjtcblxuICAgICAgICBpZiAoIWlucHV0RmllbGQgfHwgIWV4cGFuZEJ1dHRvbilcbiAgICAgICAgICAgIHJldHVybjsgLy8gRW5zdXJlIGVsZW1lbnRzIGV4aXN0XG4gICAgICAgIFxuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9ICF0aGlzLmlzSW5wdXRFeHBhbmRlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7XG4gICAgICAgICAgICBpbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcyMDBweCc7IC8vIFVzZSBDU1MgY2xhc3NlcyBpZGVhbGx5XG4gICAgICAgICAgICBpbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICBleHBhbmRCdXR0b24udGV4dENvbnRlbnQgPSAn4qShJzsgLy8gQ29sbGFwc2Ugc3ltYm9sXG4gICAgICAgICAgICBleHBhbmRCdXR0b24udGl0bGUgPSAnQ29sbGFwc2UgaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnJzsgLy8gUmVzZXQgaGVpZ2h0XG4gICAgICAgICAgICBpbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgICAgIGlucHV0RmllbGQucm93cyA9IDE7IC8vIEVuc3VyZSBjb2xsYXBzZVxuICAgICAgICAgICAgZXhwYW5kQnV0dG9uLnRleHRDb250ZW50ID0gJ+Kkoic7IC8vIEV4cGFuZCBzeW1ib2xcbiAgICAgICAgICAgIGV4cGFuZEJ1dHRvbi50aXRsZSA9ICdFeHBhbmQgaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZ1dHVyZTogTm90aWZ5IHdpZGdldC9oYW5kbGVyIGlmIG5lZWRlZDogdGhpcy5jYWxsYmFja3MuaGFuZGxlVG9nZ2xlRXhwYW5zaW9uKHRoaXMuaXNJbnB1dEV4cGFuZGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgRXhwYW5kL0NvbGxhcHNlIGJ1dHRvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBuZWVkZWQgYmVjYXVzZSBJbnB1dEhhbmRsZXIgbWFuYWdlcyB0aGUgc3RhdGUsXG4gICAgICogYnV0IFVJTWFuYWdlciBtYW5hZ2VzIHRoZSBidXR0b24gZWxlbWVudC5cbiAgICAgKi9cbiAgICB1cGRhdGVFeHBhbmRCdXR0b24oaXNFeHBhbmRlZCkge1xuICAgICAgICBjb25zdCBleHBhbmRCdXR0b24gPSB0aGlzLmxheW91dEVsZW1lbnRzLmV4cGFuZEJ1dHRvbjtcbiAgICAgICAgaWYgKCFleHBhbmRCdXR0b24pIHJldHVybjtcblxuICAgICAgICBpZiAoaXNFeHBhbmRlZCkge1xuICAgICAgICAgICAgZXhwYW5kQnV0dG9uLnRleHRDb250ZW50ID0gJ+KkoSc7IC8vIENvbGxhcHNlIHN5bWJvbFxuICAgICAgICAgICAgZXhwYW5kQnV0dG9uLnRpdGxlID0gJ0NvbGxhcHNlIGlucHV0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cGFuZEJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKInOyAvLyBFeHBhbmQgc3ltYm9sXG4gICAgICAgICAgICBleHBhbmRCdXR0b24udGl0bGUgPSAnRXhwYW5kIGlucHV0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3R5bGVkIGJ1dHRvbi5cbiAgICAgKiBOT1RFOiBUaGlzIG1pZ2h0IGJlIHJlZHVuZGFudCBpZiBidWlsZExheW91dCBoYW5kbGVzIGFsbCBidXR0b24gY3JlYXRpb24uIEtlZXBpbmcgZm9yIG5vdy5cbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b24odGV4dCwgdG9vbHRpcCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICAgICAgLy8gQXBwbHkgYmFzZSBKdXB5dGVyTGFiIGJ1dHRvbiBjbGFzcyBhbmQgb3VyIHNwZWNpZmljIGNsYXNzXG4gICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBuZXcgY2hhdCBtZXNzYWdlIGVsZW1lbnQgdG8gdGhlIG1lc3NhZ2UgY29udGFpbmVyIGFuZCBzY3JvbGxzIGRvd24uXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIG1lc3NhZ2UgZWxlbWVudCAodXNlciBvciBib3QpIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRDaGF0TWVzc2FnZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBVc2UgbGF5b3V0RWxlbWVudHMgcHJvdmlkZWQgdmlhIGNvbnN0cnVjdG9yXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250YWluZXIgPSB0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXI7XG4gICAgICAgIGlmIChtZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpOyAvLyBTY3JvbGwgYWZ0ZXIgYWRkaW5nIHRoZSBuZXcgZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWVzc2FnZSBjb250YWluZXIgbm90IGZvdW5kIGluIFVJTWFuYWdlciBsYXlvdXRFbGVtZW50cy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRoZSBtZXNzYWdlIGNvbnRhaW5lciB0byB0aGUgYm90dG9tLlxuICAgICAqL1xuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICAvLyBVc2UgbGF5b3V0RWxlbWVudHMgcHJvdmlkZWQgdmlhIGNvbnN0cnVjdG9yXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250YWluZXIgPSB0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXI7XG4gICAgICAgIGlmIChtZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IG1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWVzc2FnZSBjb250YWluZXIgbm90IGZvdW5kIGluIFVJTWFuYWdlciBsYXlvdXRFbGVtZW50cy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgdmlldyB0byBzaG93IHRoZSBjaGF0IGhpc3RvcnkuXG4gICAgICovXG4gICAgc2hvd0hpc3RvcnlWaWV3KCkge1xuICAgICAgICBpZiAoIXRoaXMubGF5b3V0RWxlbWVudHMubWVzc2FnZUNvbnRhaW5lciB8fCAhdGhpcy5sYXlvdXRFbGVtZW50cy5oaXN0b3J5Q29udGFpbmVyIHx8ICF0aGlzLmxheW91dEVsZW1lbnRzLmJvdHRvbUJhckNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVJTWFuYWdlcjogQ2Fubm90IHNob3cgaGlzdG9yeSB2aWV3LCByZXF1aXJlZCBsYXlvdXQgZWxlbWVudHMgbWlzc2luZy5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5ib3R0b21CYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gT3B0aW9uYWxseSB1cGRhdGUgaGVhZGVyL3RpdGxlIGVsZW1lbnRzIGlmIG5lZWRlZFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgdmlldyB0byBzaG93IHRoZSBtYWluIGNoYXQgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHNob3dDaGF0VmlldygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXIgfHwgIXRoaXMubGF5b3V0RWxlbWVudHMuaGlzdG9yeUNvbnRhaW5lciB8fCAhdGhpcy5sYXlvdXRFbGVtZW50cy5ib3R0b21CYXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVSU1hbmFnZXI6IENhbm5vdCBzaG93IGNoYXQgdmlldywgcmVxdWlyZWQgbGF5b3V0IGVsZW1lbnRzIG1pc3NpbmcuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIEFzc3VtaW5nIGZsZXggZGlzcGxheVxuICAgICAgICB0aGlzLnNjcm9sbFRvQm90dG9tKCk7IC8vIFNjcm9sbCBkb3duIHdoZW4gc2hvd2luZyBjaGF0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgbWVzc2FnZSBjb250YWluZXIuXG4gICAgICovXG4gICAgY2xlYXJNZXNzYWdlQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlQ29udGFpbmVyID0gdGhpcy5sYXlvdXRFbGVtZW50cy5tZXNzYWdlQ29udGFpbmVyO1xuICAgICAgICBpZiAobWVzc2FnZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgbWVzc2FnZUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VJTWFuYWdlcjogQ2Fubm90IGNsZWFyIG1lc3NhZ2UgY29udGFpbmVyLCBlbGVtZW50IG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgdGl0bGUgaW5wdXQgZmllbGQuXG4gICAgICovXG4gICAgdXBkYXRlVGl0bGVJbnB1dCh0aXRsZSkge1xuICAgICAgICBjb25zdCB0aXRsZUlucHV0ID0gdGhpcy5sYXlvdXRFbGVtZW50cy50aXRsZUlucHV0O1xuICAgICAgICBpZiAodGl0bGVJbnB1dCkge1xuICAgICAgICAgICAgdGl0bGVJbnB1dC52YWx1ZSA9IHRpdGxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVUlNYW5hZ2VyOiBDYW5ub3QgdXBkYXRlIHRpdGxlIGlucHV0LCBlbGVtZW50IG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY29udGFpbmVyIHN0cnVjdHVyZSBmb3IgYSBib3QgbWVzc2FnZSxcbiAgICAgKiBpbmNsdWRpbmcgZWxlbWVudHMgZm9yIHN0cmVhbWluZyB0ZXh0IGFuZCBmaW5hbCByZW5kZXJlZCBjb250ZW50LlxuICAgICAqIFRoaXMgaGVscHMgbWFuYWdlIHRoZSB0cmFuc2l0aW9uIGZyb20gc3RyZWFtaW5nIHRvIGZpbmFsIG1lc3NhZ2UgZGlzcGxheS5cbiAgICAgKi9cbiAgICBjcmVhdGVCb3RNZXNzYWdlQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBib3RNZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYm90LW1lc3NhZ2UnOyAvLyBCYXNlIGNsYXNzXG4gICAgICAgIC8vIERpdiBmb3Igc3RyZWFtaW5nIGNvbnRlbnQgKGluaXRpYWxseSB2aXNpYmxlKVxuICAgICAgICBjb25zdCBzdHJlYW1pbmdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3RyZWFtaW5nRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXN0cmVhbWluZy1jb250ZW50JztcbiAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBTaG93IHN0cmVhbWluZyBpbml0aWFsbHlcbiAgICAgICAgLy8gRGl2IGZvciBmaW5hbCByZW5kZXJlZCBjb250ZW50IChpbml0aWFsbHkgaGlkZGVuKVxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcmVuZGVyZWQtY29udGVudCc7XG4gICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSGlkZSBmaW5hbCBjb250ZW50IGluaXRpYWxseVxuICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgIC8vIEFkZCB0aGUgd2hvbGUgY29udGFpbmVyIHRvIHRoZSBtZXNzYWdlIGxpc3QgKmJlZm9yZSogc3RyZWFtaW5nIHN0YXJ0c1xuICAgICAgICAvLyBFbnN1cmUgYWRkQ2hhdE1lc3NhZ2VFbGVtZW50IHVzZXMgbGF5b3V0RWxlbWVudHMubWVzc2FnZUNvbnRhaW5lciBjb3JyZWN0bHlcbiAgICAgICAgdGhpcy5hZGRDaGF0TWVzc2FnZUVsZW1lbnQoYm90TWVzc2FnZURpdik7XG4gICAgICAgIHJldHVybiB7IGJvdE1lc3NhZ2VEaXYsIHN0cmVhbWluZ0RpdiwgY29udGVudERpdiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhIHRlbXBvcmFyeSBub3RpZmljYXRpb24gbWVzc2FnZS5cbiAgICAgKiBUT0RPOiBJbXBsZW1lbnQgYSBtb3JlIHJvYnVzdCBub3RpZmljYXRpb24gc3lzdGVtIChlLmcuLCB0b2FzdCkuXG4gICAgICovXG4gICAgc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlLCB0eXBlLCBkdXJhdGlvbiA9IDMwMDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYE5vdGlmaWNhdGlvbiAoJHt0eXBlfSk6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgLy8gQmFzaWMgdGVtcG9yYXJ5IGltcGxlbWVudGF0aW9uIHVzaW5nIHRoZSBleGlzdGluZyBpbmRpY2F0b3IgZWxlbWVudFxuICAgICAgICAvLyBjb25zdCBpbmRpY2F0b3IgPSB0aGlzLmxheW91dEVsZW1lbnRzLm1haW5FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LWtleWJvYXJkLXNob3J0Y3V0LWluZGljYXRvcicpO1xuICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3I7IC8vIFVzZSB0aGUgZGlyZWN0IHJlZmVyZW5jZVxuICAgICAgICBpZiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub3RpZmljYXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm90aWZpY2F0aW9uVGltZW91dCk7IC8vIENsZWFyIHByZXZpb3VzIHRpbWVvdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGljYXRvci50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBpbmRpY2F0b3IuY2xhc3NOYW1lID0gYGpwLWxsbS1leHQta2V5Ym9hcmQtc2hvcnRjdXQtaW5kaWNhdG9yIHZpc2libGUganAtbGxtLWV4dC1ub3RpZmljYXRpb24tJHt0eXBlfWA7IC8vIEFkZCB0eXBlIGNsYXNzXG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOb3RpZmljYXRpb24gaW5kaWNhdG9yIGVsZW1lbnQgbm90IGZvdW5kIGZvciBVSU1hbmFnZXIuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgYSB2aXN1YWwgaW5kaWNhdG9yIGZvciBrZXlib2FyZCBzaG9ydGN1dHMuXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gZGlzcGxheSBpbiB0aGUgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIHNob3dJbmRpY2F0b3IodGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcilcbiAgICAgICAgICAgIHJldHVybjsgLy8gR3VhcmRcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXQgdG8gcHJldmVudCBtdWx0aXBsZSB0aW1lb3V0cyBydW5uaW5nXG4gICAgICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBuZXcgdGltZW91dCB0byBoaWRlIHRoZSBpbmRpY2F0b3JcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcikgeyAvLyBDaGVjayBpZiBlbGVtZW50IHN0aWxsIGV4aXN0c1xuICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCAxMDAwKTsgLy8gSGlkZSBhZnRlciAxIHNlY29uZFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGluZGljYXRvciBpbW1lZGlhdGVseSBhbmQgY2FuY2VscyBhbnkgcGVuZGluZyBoaWRlIHRpbWVvdXQuXG4gICAgICogVXNlZnVsIGlmIHRoZSB3aWRnZXQgaXMgaGlkZGVuIHdoaWxlIHRoZSBpbmRpY2F0b3IgaXMgc2hvd24uXG4gICAgICovXG4gICAgY2xlYXJJbmRpY2F0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgaWYgKHRoaXMubm90aWZpY2F0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm90aWZpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VSU1hbmFnZXIgPSBVSU1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29weVRvQ2xpcGJvYXJkID0gY29weVRvQ2xpcGJvYXJkO1xuZXhwb3J0cy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkID0gY29weU1lc3NhZ2VUb0NsaXBib2FyZDtcbmV4cG9ydHMuY29weUltYWdlVG9DbGlwYm9hcmQgPSBjb3B5SW1hZ2VUb0NsaXBib2FyZDtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvcHkgdGV4dCB0byBjbGlwYm9hcmQuXG4gKiBQcm92aWRlcyB2aXN1YWwgZmVlZGJhY2sgdmlhIGNvbnNvbGUgbG9ncyBhbmQgb3B0aW9uYWxseSBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dCwgZmVlZGJhY2tDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRlbnQgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKCk7IC8vIENhbGwgb3B0aW9uYWwgZmVlZGJhY2sgY2FsbGJhY2tcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IHRleHQ6ICcsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29weWluZyB0ZXh0IHRvIGNsaXBib2FyZDonLCBlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBDb3BpZXMgbWVzc2FnZSBjb250ZW50IHRvIGNsaXBib2FyZC5cbiAqIFByb3ZpZGVzIHZpc3VhbCBmZWVkYmFjayB2aWEgY29uc29sZSBsb2dzIGFuZCBvcHRpb25hbGx5IGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQodGV4dCwgZmVlZGJhY2tDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01lc3NhZ2UgY29udGVudCBjb3BpZWQgdG8gY2xpcGJvYXJkJyk7XG4gICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2sodHJ1ZSk7IC8vIEluZGljYXRlIHN1Y2Nlc3NcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IG1lc3NhZ2UgdGV4dDogJywgZXJyKTtcbiAgICAgICAgICAgIGZlZWRiYWNrQ2FsbGJhY2sgPT09IG51bGwgfHwgZmVlZGJhY2tDYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYWxsYmFjayhmYWxzZSk7IC8vIEluZGljYXRlIGZhaWx1cmVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb3B5aW5nIG1lc3NhZ2UgdG8gY2xpcGJvYXJkOicsIGVycm9yKTtcbiAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKGZhbHNlKTsgLy8gSW5kaWNhdGUgZmFpbHVyZVxuICAgIH1cbn1cbi8qKlxuICogQ29waWVzIGFuIGltYWdlIHRvIHRoZSBjbGlwYm9hcmQgZnJvbSBhIGdpdmVuIFVSTC5cbiAqIFByb3ZpZGVzIHZpc3VhbCBmZWVkYmFjayB2aWEgY29uc29sZSBsb2dzIGFuZCBvcHRpb25hbGx5IGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGNvcHlJbWFnZVRvQ2xpcGJvYXJkKGltYWdlVXJsLCBmZWVkYmFja0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZmV0Y2goaW1hZ2VVcmwpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIENsaXBib2FyZEl0ZW0gd2l0aCB0aGUgaW1hZ2UgYmxvYlxuICAgICAgICAgICAgLy8gTm90ZTogQ2xpcGJvYXJkSXRlbSBtaWdodCBub3QgYmUgZGVmaW5lZCBpbiBhbGwgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBZb3UgbWlnaHQgbmVlZCB0byBhZGQgYFwiZG9tLml0ZXJhYmxlXCJgIHRvIHRzY29uZmlnIGxpYiBvciBoYW5kbGUgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgQ2xpcGJvYXJkSXRlbSh7IFtibG9iLnR5cGVdOiBibG9iIH0pO1xuICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZShbaXRlbV0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbWFnZSBjb3BpZWQgdG8gY2xpcGJvYXJkJyk7XG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKHRydWUpOyAvLyBJbmRpY2F0ZSBzdWNjZXNzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IGltYWdlIHRvIGNsaXBib2FyZDogJywgZXJyKTtcbiAgICAgICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIGNvcHkgaW1hZ2U6ICcgKyBlcnIubWVzc2FnZSk7IC8vIEtlZXAgYWxlcnQgZm9yIGNyaXRpY2FsIHVzZXIgZmVlZGJhY2tcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG9yIHByb2Nlc3MgaW1hZ2U6ICcsIGVycik7XG4gICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIGZldGNoIGltYWdlOiAnICsgZXJyLm1lc3NhZ2UpOyAvLyBLZWVwIGFsZXJ0IGZvciBjcml0aWNhbCB1c2VyIGZlZWRiYWNrXG4gICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJlcGFyaW5nIGltYWdlIGNvcHk6JywgZXJyb3IpO1xuICAgICAgICBhbGVydCgnRXJyb3IgY29weWluZyBpbWFnZTogJyArIGVycm9yKTsgLy8gS2VlcCBhbGVydCBmb3IgY3JpdGljYWwgdXNlciBmZWVkYmFja1xuICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRldGVjdExhbmd1YWdlID0gZGV0ZWN0TGFuZ3VhZ2U7XG5leHBvcnRzLmhpZ2hsaWdodENvZGUgPSBoaWdobGlnaHRDb2RlO1xuY29uc3QgaGlnaGxpZ2h0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImhpZ2hsaWdodC5qc1wiKSk7XG4vKipcbiAqIERldGVjdHMgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlIGZyb20gY29kZSBibG9jayBjb250ZW50IHVzaW5nIGhpZ2hsaWdodC5qc1xuICogYW5kIGN1c3RvbSBwYXR0ZXJuIG1hdGNoaW5nIGZvciBjb21tb24gbGFuZ3VhZ2VzLlxuICovXG5mdW5jdGlvbiBkZXRlY3RMYW5ndWFnZShjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IGF1dG8gZGV0ZWN0aW9uIGZpcnN0IHdpdGggYSBsaW1pdGVkIHNldCBvZiBjb21tb24gbGFuZ3VhZ2VzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhpZ2hsaWdodF9qc18xLmRlZmF1bHQuaGlnaGxpZ2h0QXV0byhjb2RlLCBbXG4gICAgICAgICAgICAncHl0aG9uJywgJ2phdmFzY3JpcHQnLCAndHlwZXNjcmlwdCcsICdqYXZhJyxcbiAgICAgICAgICAgICdodG1sJywgJ2NzcycsICdjcHAnLCAnY3NoYXJwJywgJ3NxbCcsICdydXN0JyxcbiAgICAgICAgICAgICdwaHAnLCAnYmFzaCcsICdqc29uJywgJ3htbCcsICdtYXJrZG93bidcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIElmIGNvbmZpZGVuY2UgaXMgcmVhc29uYWJseSBoaWdoLCB1c2UgdGhhdCBsYW5ndWFnZVxuICAgICAgICBpZiAocmVzdWx0LnJlbGV2YW5jZSA+IDUgJiYgcmVzdWx0Lmxhbmd1YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxhbmd1YWdlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBiYXNpYyBwYXR0ZXJuIG1hdGNoaW5nIGZvciBiZXR0ZXIgYWNjdXJhY3kgb24gYW1iaWd1b3VzIGNhc2VzXG4gICAgICAgIGlmICgvXig/OlxccyopPyg/OmltcG9ydFxccytbXjtdKzt8cGFja2FnZVxccytbXjtdKzt8cHVibGljXFxzK2NsYXNzKS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdqYXZhJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyhpbXBvcnR8ZnJvbXxkZWZ8Y2xhc3N8aWYgX19uYW1lX18pLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3B5dGhvbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzpmdW5jdGlvbnxjb25zdHxsZXR8dmFyfGltcG9ydHxleHBvcnR8PT4pLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAvLyBCcm9hZGVyIGNoZWNrIGZvciBKUy9UU1xuICAgICAgICAgICAgaWYgKC9eKD86XFxzKik/KD86aW1wb3J0XFxzLit8ZXhwb3J0XFxzLit8aW50ZXJmYWNlfHR5cGV8ZW51bXxkZWNsYXJlfDp8XFxzPCkvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3R5cGVzY3JpcHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdqYXZhc2NyaXB0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OjwhRE9DVFlQRXw8aHRtbHw8aGVhZHw8Ym9keSkvaS50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2h0bWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/I2luY2x1ZGUvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnY3BwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OnVzaW5nXFxzK1N5c3RlbXxuYW1lc3BhY2V8cHVibGljXFxzK3N0YXRpY1xccyt2b2lkXFxzK01haW4pLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NzaGFycCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzpTRUxFQ1R8SU5TRVJUfFVQREFURXxERUxFVEV8Q1JFQVRFfEFMVEVSKVxccy9pLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3FsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OmZufGxldHxzdHJ1Y3R8ZW51bXx0cmFpdHxpbXBsfG1vZClcXHMvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAncnVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzo8XFw/cGhwfHVzZVxccytbXFx3XFxcXF0rOykvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAncGhwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OiNcXHMqIVxcL2JpblxcLyg/OmJhc2h8c2h8enNoKXxcXCQpLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Jhc2gnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eXFxzKlxcey8udGVzdChjb2RlKSAmJiAvXFx9XFxzKiQvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBjaGVjayBmb3IgSlNPTi1saWtlIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0dXJuICdqc29uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXlxccyo8XFw/eG1sLy50ZXN0KGNvZGUpIHx8IC9eXFxzKjxcXHcrLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUgY2hlY2sgZm9yIFhNTC9IVE1MIGxpa2Ugc3RydWN0dXJlXG4gICAgICAgICAgICByZXR1cm4gJ3htbCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gc3BlY2lmaWMgbGFuZ3VhZ2UgZGV0ZWN0ZWQsIHJldHVybiBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0ZWN0aW5nIGxhbmd1YWdlOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuICcnOyAvLyBSZXR1cm4gZW1wdHkgb24gZXJyb3JcbiAgICB9XG59XG4vKipcbiAqIEhpZ2hsaWdodHMgY29kZSB1c2luZyBoaWdobGlnaHQuanMuXG4gKiBGYWxscyBiYWNrIHRvIGF1dG8tZGV0ZWN0aW9uIGlmIHRoZSBzcGVjaWZpZWQgbGFuZ3VhZ2UgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCBsYW5ndWFnZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChsYW5ndWFnZSAmJiBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmdldExhbmd1YWdlKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodF9qc18xLmRlZmF1bHQuaGlnaGxpZ2h0KGNvZGUsIHsgbGFuZ3VhZ2UsIGlnbm9yZUlsbGVnYWxzOiB0cnVlIH0pLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYXV0by1kZXRlY3Rpb24gaWYgbGFuZ3VhZ2UgaXMgZW1wdHkgb3Igbm90IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmhpZ2hsaWdodEF1dG8oY29kZSkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGhpZ2hsaWdodGluZyBjb2RlIChsYW5ndWFnZTogJHtsYW5ndWFnZSB8fCAnYXV0byd9KTpgLCBlcnJvcik7XG4gICAgICAgIC8vIFJldHVybiBvcmlnaW5hbCBjb2RlIGVzY2FwZWQgZm9yIHNhZmV0eSBvbiBlcnJvclxuICAgICAgICByZXR1cm4gY29kZS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uZmlndXJlTWFya2VkID0gY29uZmlndXJlTWFya2VkO1xuZXhwb3J0cy5wcmVwcm9jZXNzTWFya2Rvd24gPSBwcmVwcm9jZXNzTWFya2Rvd247XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG4vKipcbiAqIENvbmZpZ3VyZSBtYXJrZWQgd2l0aCBiZXR0ZXIgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIGNvZGUgYmxvY2tzXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZU1hcmtlZCgpIHtcbiAgICAvLyBDb25maWd1cmUgbWFya2VkIG9wdGlvbnNcbiAgICBtYXJrZWRfMS5tYXJrZWQuc2V0T3B0aW9ucyh7XG4gICAgICAgIGdmbTogdHJ1ZSwgLy8gRW5hYmxlIEdpdEh1YiBGbGF2b3JlZCBNYXJrZG93blxuICAgICAgICBicmVha3M6IHRydWUsIC8vIEFkZCA8YnI+IG9uIHNpbmdsZSBsaW5lIGJyZWFrc1xuICAgICAgICBwZWRhbnRpYzogZmFsc2UsIC8vIENvbmZvcm0gdG8gb3JpZ2luYWwgbWFya2Rvd24gc3BlY1xuICAgICAgICBhc3luYzogZmFsc2UsIC8vIERpc2FibGUgYXN5bmMgcmVuZGVyaW5nXG4gICAgICAgIHNpbGVudDogZmFsc2UgLy8gRW5hYmxlIGVycm9yIHJlcG9ydGluZ1xuICAgIH0pO1xufVxuLyoqXG4gKiBQcmUtcHJvY2VzcyBtYXJrZG93biB0ZXh0IHRvIGZpeCBjb21tb24gaXNzdWVzIHdpdGggc3RyZWFtaW5nIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gcHJlcHJvY2Vzc01hcmtkb3duKHRleHQpIHtcbiAgICAvLyBOb3JtYWxpemUgbGluZSBlbmRpbmdzXG4gICAgY29uc3Qgbm9ybWFsaXplZFRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgLy8gSGFuZGxlIGNvZGUgYmxvY2tzIGZpcnN0XG4gICAgbGV0IGluQ29kZUJsb2NrID0gZmFsc2U7XG4gICAgY29uc3QgbGluZXMgPSBub3JtYWxpemVkVGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgcHJvY2Vzc2VkTGluZXMgPSBsaW5lcy5tYXAoKGxpbmUsIGkpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGUgYmxvY2sgbWFya2Vyc1xuICAgICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgnYGBgJykpIHtcbiAgICAgICAgICAgIGluQ29kZUJsb2NrID0gIWluQ29kZUJsb2NrO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgbGFuZ3VhZ2Ugc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGluIGEgY29kZSBibG9jaywgcHJlc2VydmUgdGhlIGxpbmUgYXMgaXNcbiAgICAgICAgaWYgKGluQ29kZUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXRzaWRlIGNvZGUgYmxvY2tzOlxuICAgICAgICAvLyAxLiBIYW5kbGUgbGlzdCBpdGVtcyB3aXRoIHByb3BlciBzcGFjaW5nXG4gICAgICAgIC8vIDIuIFRyaW0gZXhjZXNzaXZlIHdoaXRlc3BhY2UgYXQgc3RhcnQgYW5kIGVuZCwgYnV0IHByZXNlcnZlIGluZGVudGF0aW9uIHdpdGhpbiBsaW5lc1xuICAgICAgICBsZXQgcHJvY2Vzc2VkID0gbGluZTtcbiAgICAgICAgLy8gSGFuZGxlIGRhc2ggbGlzdCBpdGVtcyBieSBlbnN1cmluZyB0aGV5IGhhdmUgYSBzcGFjZSBhZnRlciB0aGUgZGFzaFxuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvKFxccyopLShcXFMpL2csICckMS0gJDInKTtcbiAgICAgICAgLy8gSGFuZGxlIG1peGVkIHNwYWNlL2Rhc2ggaXNzdWVzIC0gZW5zdXJlIHByb3BlciBuZXdsaW5lcyBiZWZvcmUgbGlzdCBpdGVtc1xuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvKFteXFxuXFxzXSktXFxzL2csICckMVxcbi0gJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gICAgfSk7XG4gICAgLy8gSm9pbiBsaW5lcyBhbmQgZW5zdXJlIGNvZGUgYmxvY2tzIGFyZSBwcm9wZXJseSBmb3JtYXR0ZWRcbiAgICBsZXQgcmVzdWx0ID0gcHJvY2Vzc2VkTGluZXMuam9pbignXFxuJyk7XG4gICAgLy8gSGFuZGxlIGVtcHR5IGNvZGUgYmxvY2tzIChhZGQgYSBzcGFjZSBzbyB0aGV5IHJlbmRlciBwcm9wZXJseSlcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvYGBgKC4qKVxcbmBgYC9nLCAnYGBgJDFcXG4gXFxuYGBgJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRNZXNzYWdlVG9DZWxsID0gYWRkTWVzc2FnZVRvQ2VsbDtcbmV4cG9ydHMuZ2V0U2VsZWN0ZWRUZXh0ID0gZ2V0U2VsZWN0ZWRUZXh0O1xuZXhwb3J0cy5nZXRDdXJyZW50Q2VsbENvbnRlbnQgPSBnZXRDdXJyZW50Q2VsbENvbnRlbnQ7XG5leHBvcnRzLmluc2VydENlbGxDb250ZW50QnlJbmRleCA9IGluc2VydENlbGxDb250ZW50QnlJbmRleDtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2dsb2JhbHNcIik7XG4vKipcbiAqIEFkZHMgbWVzc2FnZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IGNlbGwgaW4gdGhlIGFjdGl2ZSBub3RlYm9vay5cbiAqL1xuZnVuY3Rpb24gYWRkTWVzc2FnZVRvQ2VsbCh0ZXh0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgYWRkIG1lc3NhZ2U6IE5vIGFjdGl2ZSBjZWxsIG9yIGVkaXRvciBmb3VuZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgLy8gQWNjZXNzIHRoZSB1bmRlcmx5aW5nIENvZGVNaXJyb3IgZWRpdG9yIHZpZXcgKGFkanVzdCBpZiB1c2luZyBhIGRpZmZlcmVudCBlZGl0b3IpXG4gICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGFkZCBtZXNzYWdlOiBDb2RlTWlycm9yIHZpZXcgbm90IGFjY2Vzc2libGUuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBjdXJzb3JQb3MgPSBzZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICAvLyBJbnNlcnQgbmV3bGluZSBhbmQgbWVzc2FnZSBjb250ZW50IGF0IGN1cnNvciBwb3NpdGlvblxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgZnJvbTogY3Vyc29yUG9zLFxuICAgICAgICAgICAgICAgIGluc2VydDogYFxcbiR7dGV4dH1gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBtb3ZlIGN1cnNvciB0byBlbmQgb2YgaW5zZXJ0ZWQgdGV4dFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogY3Vyc29yUG9zICsgdGV4dC5sZW5ndGggKyAxIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG1lc3NhZ2UgdG8gY2VsbDonLCBlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCBmcm9tIHRoZSBhY3RpdmUgbm90ZWJvb2sgY2VsbCBvciB0ZXh0IGVkaXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRUZXh0KCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgIGlmIChjZWxsID09PSBudWxsIHx8IGNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGwuZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICBjb25zdCBjbUVkaXRvciA9IGVkaXRvci5lZGl0b3I7IC8vIEFjY2VzcyBDb2RlTWlycm9yIGVkaXRvciBpbnN0YW5jZVxuICAgICAgICBpZiAoY21FZGl0b3IgJiYgY21FZGl0b3Iuc3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY21FZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uZW1wdHkgPyBudWxsIDogc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgQ29kZU1pcnJvciBzdGF0ZSB0byBnZXQgc2VsZWN0aW9uLlwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3Igbm9uLW5vdGVib29rIGVkaXRvcnMgKGUuZy4sIHRleHQgZWRpdG9yKVxuICAgICAgICBjb25zdCBhY3RpdmVXaWRnZXQgPSAoX2MgPSAoX2IgPSBnbG9iYWxzXzEuZ2xvYmFscy5hcHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGVsbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgIGlmIChhY3RpdmVXaWRnZXQgJiYgJ2NvbnRlbnQnIGluIGFjdGl2ZVdpZGdldCAmJiBhY3RpdmVXaWRnZXQuY29udGVudC5lZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVdpZGdldC5jb250ZW50LmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IGNtRWRpdG9yID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgIGlmIChjbUVkaXRvciAmJiBjbUVkaXRvci5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY21FZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5lbXB0eSA/IG51bGwgOiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgYWNjZXNzIENvZGVNaXJyb3Igc3RhdGUgZm9yIG5vbi1ub3RlYm9vayBlZGl0b3Igc2VsZWN0aW9uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG5vdGVib29rIGNlbGwgb3IgdGV4dCBlZGl0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRDZWxsQ29udGVudCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IGFjdGl2ZUNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgIGlmIChhY3RpdmVDZWxsID09PSBudWxsIHx8IGFjdGl2ZUNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUNlbGwubW9kZWwpIHtcbiAgICAgICAgLy8gVHJ5IHVzaW5nIHNoYXJlZE1vZGVsIGZpcnN0IChtb3JlIHJvYnVzdClcbiAgICAgICAgaWYgKGFjdGl2ZUNlbGwubW9kZWwuc2hhcmVkTW9kZWwgJiYgdHlwZW9mIGFjdGl2ZUNlbGwubW9kZWwuc2hhcmVkTW9kZWwuZ2V0U291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlQ2VsbC5tb2RlbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjazogVHJ5IHVzaW5nIHRvSlNPTigpLnNvdXJjZVxuICAgICAgICBjb25zdCBjZWxsSnNvbiA9IGFjdGl2ZUNlbGwubW9kZWwudG9KU09OKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNlbGxKc29uID09PSBudWxsIHx8IGNlbGxKc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsSnNvbi5zb3VyY2U7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGdldCBjZWxsIGNvbnRlbnQgdmlhIHNoYXJlZE1vZGVsIG9yIHRvSlNPTigpLnNvdXJjZVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tbm90ZWJvb2sgZWRpdG9ycyBpZiBuZWVkZWRcbiAgICBjb25zdCBhY3RpdmVXaWRnZXQgPSAoX2MgPSAoX2IgPSBnbG9iYWxzXzEuZ2xvYmFscy5hcHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGVsbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmN1cnJlbnRXaWRnZXQ7XG4gICAgaWYgKGFjdGl2ZVdpZGdldCAmJiAnY29udGVudCcgaW4gYWN0aXZlV2lkZ2V0ICYmIGFjdGl2ZVdpZGdldC5jb250ZW50Lm1vZGVsKSB7XG4gICAgICAgIC8vIEFzc3VtaW5nIG1vZGVsLnZhbHVlLnRleHQgZm9yIGdlbmVyaWMgdGV4dCBlZGl0b3JzXG4gICAgICAgIHJldHVybiAoX2UgPSAoX2QgPSBhY3RpdmVXaWRnZXQuY29udGVudC5tb2RlbC52YWx1ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRleHQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXRzIGNlbGwgY29udGVudCBieSBpbmRleCBmcm9tIHRoZSBjdXJyZW50IG5vdGVib29rIGFuZCBjYWxscyBhIGNhbGxiYWNrIHRvIGluc2VydCBpdC5cbiAqIE5PVEU6IFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBjYWxsZWQgYHRoaXMuYXBwZW5kVG9JbnB1dGAuIFRoaXMgZnVuY3Rpb25hbGl0eSBuZWVkc1xuICogICAgICAgdG8gYmUgcHJvdmlkZWQgdmlhIHRoZSBgaW5zZXJ0Q2FsbGJhY2tgLlxuICovXG5mdW5jdGlvbiBpbnNlcnRDZWxsQ29udGVudEJ5SW5kZXgoaW5kZXgsIGluc2VydENhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIgfHwgIWdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50V2lkZ2V0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBhY3RpdmUgbm90ZWJvb2sgZm91bmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3RlYm9va1BhbmVsID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gbm90ZWJvb2tQYW5lbC5jb250ZW50Lm1vZGVsO1xuICAgICAgICBpZiAoIW1vZGVsIHx8ICFtb2RlbC5jZWxscyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gbW9kZWwuY2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIGNlbGwgaW5kZXg6ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VsbCA9IG1vZGVsLmNlbGxzLmdldChpbmRleCk7XG4gICAgICAgIGxldCBjZWxsQ29udGVudCA9ICcnO1xuICAgICAgICAvLyBHZXQgY2VsbCBjb250ZW50IC0gaGFuZGxlIGRpZmZlcmVudCB3YXlzIGNvbnRlbnQgbWlnaHQgYmUgc3RvcmVkXG4gICAgICAgIGlmIChjZWxsLnNoYXJlZE1vZGVsICYmIHR5cGVvZiBjZWxsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBjZWxsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2VsbEpzb24gPSBjZWxsLnRvSlNPTigpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gY2VsbEpzb24gPT09IG51bGwgfHwgY2VsbEpzb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGxKc29uLnNvdXJjZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNlbGxDb250ZW50ID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBzb3VyY2Uuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5zZXJ0IGNlbGwgcmVmZXJlbmNlIHdpdGggY29udGVudCB1c2luZyB0aGUgY2FsbGJhY2tcbiAgICAgICAgaW5zZXJ0Q2FsbGJhY2soYGNlbGwgJHtjZWxsQ29udGVudH1gKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluc2VydGluZyBjZWxsIGJ5IGluZGV4OicsIGVycm9yKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=