"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_shell_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/shell.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/shell.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shell: () => (/* binding */ shell)
/* harmony export */ });
var words = {};
function define(style, dict) {
  for(var i = 0; i < dict.length; i++) {
    words[dict[i]] = style;
  }
};

var commonAtoms = ["true", "false"];
var commonKeywords = ["if", "then", "do", "else", "elif", "while", "until", "for", "in", "esac", "fi",
                      "fin", "fil", "done", "exit", "set", "unset", "export", "function"];
var commonCommands = ["ab", "awk", "bash", "beep", "cat", "cc", "cd", "chown", "chmod", "chroot", "clear",
                      "cp", "curl", "cut", "diff", "echo", "find", "gawk", "gcc", "get", "git", "grep", "hg", "kill", "killall",
                      "ln", "ls", "make", "mkdir", "openssl", "mv", "nc", "nl", "node", "npm", "ping", "ps", "restart", "rm",
                      "rmdir", "sed", "service", "sh", "shopt", "shred", "source", "sort", "sleep", "ssh", "start", "stop",
                      "su", "sudo", "svn", "tee", "telnet", "top", "touch", "vi", "vim", "wall", "wc", "wget", "who", "write",
                      "yes", "zsh"];

define('atom', commonAtoms);
define('keyword', commonKeywords);
define('builtin', commonCommands);

function tokenBase(stream, state) {
  if (stream.eatSpace()) return null;

  var sol = stream.sol();
  var ch = stream.next();

  if (ch === '\\') {
    stream.next();
    return null;
  }
  if (ch === '\'' || ch === '"' || ch === '`') {
    state.tokens.unshift(tokenString(ch, ch === "`" ? "quote" : "string"));
    return tokenize(stream, state);
  }
  if (ch === '#') {
    if (sol && stream.eat('!')) {
      stream.skipToEnd();
      return 'meta'; // 'comment'?
    }
    stream.skipToEnd();
    return 'comment';
  }
  if (ch === '$') {
    state.tokens.unshift(tokenDollar);
    return tokenize(stream, state);
  }
  if (ch === '+' || ch === '=') {
    return 'operator';
  }
  if (ch === '-') {
    stream.eat('-');
    stream.eatWhile(/\w/);
    return 'attribute';
  }
  if (ch == "<") {
    if (stream.match("<<")) return "operator"
    var heredoc = stream.match(/^<-?\s*(?:['"]([^'"]*)['"]|([^'"\s]*))/)
    if (heredoc) {
      state.tokens.unshift(tokenHeredoc(heredoc[1] || heredoc[2]))
      return 'string.special'
    }
  }
  if (/\d/.test(ch)) {
    stream.eatWhile(/\d/);
    if(stream.eol() || !/\w/.test(stream.peek())) {
      return 'number';
    }
  }
  stream.eatWhile(/[\w-]/);
  var cur = stream.current();
  if (stream.peek() === '=' && /\w+/.test(cur)) return 'def';
  return words.hasOwnProperty(cur) ? words[cur] : null;
}

function tokenString(quote, style) {
  var close = quote == "(" ? ")" : quote == "{" ? "}" : quote
  return function(stream, state) {
    var next, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === close && !escaped) {
        state.tokens.shift();
        break;
      } else if (next === '$' && !escaped && quote !== "'" && stream.peek() != close) {
        escaped = true;
        stream.backUp(1);
        state.tokens.unshift(tokenDollar);
        break;
      } else if (!escaped && quote !== close && next === quote) {
        state.tokens.unshift(tokenString(quote, style))
        return tokenize(stream, state)
      } else if (!escaped && /['"]/.test(next) && !/['"]/.test(quote)) {
        state.tokens.unshift(tokenStringStart(next, "string"));
        stream.backUp(1);
        break;
      }
      escaped = !escaped && next === '\\';
    }
    return style;
  };
};

function tokenStringStart(quote, style) {
  return function(stream, state) {
    state.tokens[0] = tokenString(quote, style)
    stream.next()
    return tokenize(stream, state)
  }
}

var tokenDollar = function(stream, state) {
  if (state.tokens.length > 1) stream.eat('$');
  var ch = stream.next()
  if (/['"({]/.test(ch)) {
    state.tokens[0] = tokenString(ch, ch == "(" ? "quote" : ch == "{" ? "def" : "string");
    return tokenize(stream, state);
  }
  if (!/\d/.test(ch)) stream.eatWhile(/\w/);
  state.tokens.shift();
  return 'def';
};

function tokenHeredoc(delim) {
  return function(stream, state) {
    if (stream.sol() && stream.string == delim) state.tokens.shift()
    stream.skipToEnd()
    return "string.special"
  }
}

function tokenize(stream, state) {
  return (state.tokens[0] || tokenBase) (stream, state);
};

const shell = {
  name: "shell",
  startState: function() {return {tokens:[]};},
  token: function(stream, state) {
    return tokenize(stream, state);
  },
  languageData: {
    autocomplete: commonAtoms.concat(commonKeywords, commonCommands),
    closeBrackets: {brackets: ["(", "[", "{", "'", '"', "`"]},
    commentTokens: {line: "#"}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc2hlbGxfanMuYzM5MmRhYjNhMWY1MjFhNzZkOWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSwwQkFBMEIsUUFBUSxZQUFZO0FBQzlDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUIsa0JBQWtCO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3NoZWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB3b3JkcyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lKHN0eWxlLCBkaWN0KSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBkaWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgd29yZHNbZGljdFtpXV0gPSBzdHlsZTtcbiAgfVxufTtcblxudmFyIGNvbW1vbkF0b21zID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdO1xudmFyIGNvbW1vbktleXdvcmRzID0gW1wiaWZcIiwgXCJ0aGVuXCIsIFwiZG9cIiwgXCJlbHNlXCIsIFwiZWxpZlwiLCBcIndoaWxlXCIsIFwidW50aWxcIiwgXCJmb3JcIiwgXCJpblwiLCBcImVzYWNcIiwgXCJmaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZmluXCIsIFwiZmlsXCIsIFwiZG9uZVwiLCBcImV4aXRcIiwgXCJzZXRcIiwgXCJ1bnNldFwiLCBcImV4cG9ydFwiLCBcImZ1bmN0aW9uXCJdO1xudmFyIGNvbW1vbkNvbW1hbmRzID0gW1wiYWJcIiwgXCJhd2tcIiwgXCJiYXNoXCIsIFwiYmVlcFwiLCBcImNhdFwiLCBcImNjXCIsIFwiY2RcIiwgXCJjaG93blwiLCBcImNobW9kXCIsIFwiY2hyb290XCIsIFwiY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImNwXCIsIFwiY3VybFwiLCBcImN1dFwiLCBcImRpZmZcIiwgXCJlY2hvXCIsIFwiZmluZFwiLCBcImdhd2tcIiwgXCJnY2NcIiwgXCJnZXRcIiwgXCJnaXRcIiwgXCJncmVwXCIsIFwiaGdcIiwgXCJraWxsXCIsIFwia2lsbGFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwibG5cIiwgXCJsc1wiLCBcIm1ha2VcIiwgXCJta2RpclwiLCBcIm9wZW5zc2xcIiwgXCJtdlwiLCBcIm5jXCIsIFwibmxcIiwgXCJub2RlXCIsIFwibnBtXCIsIFwicGluZ1wiLCBcInBzXCIsIFwicmVzdGFydFwiLCBcInJtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJybWRpclwiLCBcInNlZFwiLCBcInNlcnZpY2VcIiwgXCJzaFwiLCBcInNob3B0XCIsIFwic2hyZWRcIiwgXCJzb3VyY2VcIiwgXCJzb3J0XCIsIFwic2xlZXBcIiwgXCJzc2hcIiwgXCJzdGFydFwiLCBcInN0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInN1XCIsIFwic3Vkb1wiLCBcInN2blwiLCBcInRlZVwiLCBcInRlbG5ldFwiLCBcInRvcFwiLCBcInRvdWNoXCIsIFwidmlcIiwgXCJ2aW1cIiwgXCJ3YWxsXCIsIFwid2NcIiwgXCJ3Z2V0XCIsIFwid2hvXCIsIFwid3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInllc1wiLCBcInpzaFwiXTtcblxuZGVmaW5lKCdhdG9tJywgY29tbW9uQXRvbXMpO1xuZGVmaW5lKCdrZXl3b3JkJywgY29tbW9uS2V5d29yZHMpO1xuZGVmaW5lKCdidWlsdGluJywgY29tbW9uQ29tbWFuZHMpO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuXG4gIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjaCA9PT0gJ1xcJycgfHwgY2ggPT09ICdcIicgfHwgY2ggPT09ICdgJykge1xuICAgIHN0YXRlLnRva2Vucy51bnNoaWZ0KHRva2VuU3RyaW5nKGNoLCBjaCA9PT0gXCJgXCIgPyBcInF1b3RlXCIgOiBcInN0cmluZ1wiKSk7XG4gICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgaWYgKHNvbCAmJiBzdHJlYW0uZWF0KCchJykpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiAnbWV0YSc7IC8vICdjb21tZW50Jz9cbiAgICB9XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiAnY29tbWVudCc7XG4gIH1cbiAgaWYgKGNoID09PSAnJCcpIHtcbiAgICBzdGF0ZS50b2tlbnMudW5zaGlmdCh0b2tlbkRvbGxhcik7XG4gICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnPScpIHtcbiAgICByZXR1cm4gJ29wZXJhdG9yJztcbiAgfVxuICBpZiAoY2ggPT09ICctJykge1xuICAgIHN0cmVhbS5lYXQoJy0nKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICAgIHJldHVybiAnYXR0cmlidXRlJztcbiAgfVxuICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiPDxcIikpIHJldHVybiBcIm9wZXJhdG9yXCJcbiAgICB2YXIgaGVyZWRvYyA9IHN0cmVhbS5tYXRjaCgvXjwtP1xccyooPzpbJ1wiXShbXidcIl0qKVsnXCJdfChbXidcIlxcc10qKSkvKVxuICAgIGlmIChoZXJlZG9jKSB7XG4gICAgICBzdGF0ZS50b2tlbnMudW5zaGlmdCh0b2tlbkhlcmVkb2MoaGVyZWRvY1sxXSB8fCBoZXJlZG9jWzJdKSlcbiAgICAgIHJldHVybiAnc3RyaW5nLnNwZWNpYWwnXG4gICAgfVxuICB9XG4gIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvXFxkLyk7XG4gICAgaWYoc3RyZWFtLmVvbCgpIHx8ICEvXFx3Ly50ZXN0KHN0cmVhbS5wZWVrKCkpKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICB9XG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy1dLyk7XG4gIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJz0nICYmIC9cXHcrLy50ZXN0KGN1cikpIHJldHVybiAnZGVmJztcbiAgcmV0dXJuIHdvcmRzLmhhc093blByb3BlcnR5KGN1cikgPyB3b3Jkc1tjdXJdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUsIHN0eWxlKSB7XG4gIHZhciBjbG9zZSA9IHF1b3RlID09IFwiKFwiID8gXCIpXCIgOiBxdW90ZSA9PSBcIntcIiA/IFwifVwiIDogcXVvdGVcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbmV4dCwgZXNjYXBlZCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09PSBjbG9zZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICBzdGF0ZS50b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgPT09ICckJyAmJiAhZXNjYXBlZCAmJiBxdW90ZSAhPT0gXCInXCIgJiYgc3RyZWFtLnBlZWsoKSAhPSBjbG9zZSkge1xuICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgc3RhdGUudG9rZW5zLnVuc2hpZnQodG9rZW5Eb2xsYXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoIWVzY2FwZWQgJiYgcXVvdGUgIT09IGNsb3NlICYmIG5leHQgPT09IHF1b3RlKSB7XG4gICAgICAgIHN0YXRlLnRva2Vucy51bnNoaWZ0KHRva2VuU3RyaW5nKHF1b3RlLCBzdHlsZSkpXG4gICAgICAgIHJldHVybiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfSBlbHNlIGlmICghZXNjYXBlZCAmJiAvWydcIl0vLnRlc3QobmV4dCkgJiYgIS9bJ1wiXS8udGVzdChxdW90ZSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5zLnVuc2hpZnQodG9rZW5TdHJpbmdTdGFydChuZXh0LCBcInN0cmluZ1wiKSk7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT09ICdcXFxcJztcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufTtcblxuZnVuY3Rpb24gdG9rZW5TdHJpbmdTdGFydChxdW90ZSwgc3R5bGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdGF0ZS50b2tlbnNbMF0gPSB0b2tlblN0cmluZyhxdW90ZSwgc3R5bGUpXG4gICAgc3RyZWFtLm5leHQoKVxuICAgIHJldHVybiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICB9XG59XG5cbnZhciB0b2tlbkRvbGxhciA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnRva2Vucy5sZW5ndGggPiAxKSBzdHJlYW0uZWF0KCckJyk7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KClcbiAgaWYgKC9bJ1wiKHtdLy50ZXN0KGNoKSkge1xuICAgIHN0YXRlLnRva2Vuc1swXSA9IHRva2VuU3RyaW5nKGNoLCBjaCA9PSBcIihcIiA/IFwicXVvdGVcIiA6IGNoID09IFwie1wiID8gXCJkZWZcIiA6IFwic3RyaW5nXCIpO1xuICAgIHJldHVybiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBpZiAoIS9cXGQvLnRlc3QoY2gpKSBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICBzdGF0ZS50b2tlbnMuc2hpZnQoKTtcbiAgcmV0dXJuICdkZWYnO1xufTtcblxuZnVuY3Rpb24gdG9rZW5IZXJlZG9jKGRlbGltKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSAmJiBzdHJlYW0uc3RyaW5nID09IGRlbGltKSBzdGF0ZS50b2tlbnMuc2hpZnQoKVxuICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgIHJldHVybiBcInN0cmluZy5zcGVjaWFsXCJcbiAgfVxufVxuXG5mdW5jdGlvbiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUudG9rZW5zWzBdIHx8IHRva2VuQmFzZSkgKHN0cmVhbSwgc3RhdGUpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNoZWxsID0ge1xuICBuYW1lOiBcInNoZWxsXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge3JldHVybiB7dG9rZW5zOltdfTt9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHJldHVybiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgYXV0b2NvbXBsZXRlOiBjb21tb25BdG9tcy5jb25jYXQoY29tbW9uS2V5d29yZHMsIGNvbW1vbkNvbW1hbmRzKSxcbiAgICBjbG9zZUJyYWNrZXRzOiB7YnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgXCJgXCJdfSxcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIjXCJ9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=