"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components"); // Import LabIcon if needed as placeholder
// Placeholder icon (replace if you have a specific icon)
const extensionIcon = ui_components_1.LabIcon.resolve({ icon: 'ui-components:jupyterlab' }); // Use resolve for built-in
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/api-client.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/api-client.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/globals.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/globals.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/icons.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/icons.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryHandler = void 0;
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js"); // Assuming renderers are needed
/**
 * Manages the display and interaction logic for the chat history view.
 */
class HistoryHandler {
    constructor(chatState, uiManager, callbacks, rendererCallbacks) {
        this.isHistoryViewActive = false;
        this.chatState = chatState;
        this.uiManager = uiManager;
        this.callbacks = callbacks;
        this.rendererCallbacks = rendererCallbacks;
        // Get the history container element from UIManager
        this.historyContainer = this.uiManager.getUIElements().historyContainer;
    }
    /**
     * Toggles between the main chat view and the history view.
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Use UIManager to hide chat, show history
            this.uiManager.showHistoryView();
            this.renderChatHistory(); // Populate the history view
        }
        else {
            // Use UIManager to show chat, hide history
            this.uiManager.showChatView();
            // Ensure the correct title is displayed when switching back
            const currentChat = this.chatState.getCurrentChat();
            if (currentChat) {
                this.callbacks.updateTitleInput(currentChat.title);
            }
        }
    }
    /**
     * Renders the list of past chats in the history container.
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = ''; // Clear previous list
        const history = this.chatState.getChatHistory();
        const currentChatId = this.chatState.getCurrentChatId();
        // Create header with back button
        const header = document.createElement('div');
        header.className = 'jp-llm-ext-history-header';
        // Create back button
        const backButton = document.createElement('button');
        backButton.className = 'jp-Button jp-llm-ext-back-button';
        backButton.innerHTML = '<span class="jp-icon3 jp-icon-selectable" role="presentation"><svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg></span>';
        backButton.title = 'Back to chat';
        backButton.addEventListener('click', () => this.hideHistoryView());
        const title = document.createElement('h2');
        title.textContent = 'Chat History';
        header.appendChild(backButton);
        header.appendChild(title);
        this.historyContainer.appendChild(header);
        if (history.length === 0) {
            this.historyContainer.innerHTML += '<div class="jp-llm-ext-history-empty">No chat history yet.</div>';
            return;
        }
        const list = document.createElement('ul');
        list.className = 'jp-llm-ext-history-list';
        history.forEach(chat => {
            const listItem = document.createElement('li');
            listItem.className = 'jp-llm-ext-history-item';
            if (chat.id === currentChatId) {
                listItem.classList.add('jp-llm-ext-active');
            }
            // Simple representation: Title
            // TODO: Add preview, timestamp, delete button etc.
            const titleDiv = document.createElement('div');
            titleDiv.className = 'jp-llm-ext-history-item-title';
            titleDiv.textContent = chat.title || 'Untitled Chat';
            listItem.appendChild(titleDiv);
            // Add click event to load the chat
            listItem.addEventListener('click', () => this.loadChat(chat.id));
            list.appendChild(listItem);
        });
        this.historyContainer.appendChild(list);
    }
    /**
     * Loads a specific chat session from history into the main view.
     */
    loadChat(chatId) {
        const chat = this.chatState.getChatById(chatId);
        if (!chat) {
            console.error(`Chat with ID ${chatId} not found.`);
            return;
        }
        // Set this chat as the active one in the state
        this.chatState.setCurrentChatId(chatId);
        // Update the main UI title input
        this.callbacks.updateTitleInput(chat.title);
        // Clear the current message display
        this.callbacks.clearMessageContainer();
        // Re-populate the message container with messages from the loaded chat
        // Use the renderer functions via callbacks
        chat.messages.forEach((msg) => {
            let messageElement;
            if (msg.sender === 'user') {
                messageElement = (0, message_renderer_1.renderUserMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);
            }
            else { // 'bot'
                messageElement = (0, message_renderer_1.renderBotMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);
            }
            // Add the rendered element to the message container via callback
            this.callbacks.addRenderedMessage(messageElement);
        });
        // Switch back to the chat view if we were in the history view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView(); // This will call uiManager.showChatView()
        }
        else {
            // If already in chat view, ensure scrolling is correct
            this.uiManager.scrollToBottom();
        }
        // Optional: Re-render history list to update the active item indicator
        // Only really needed if not switching views
        // if (!this.isHistoryViewActive) { this.renderChatHistory(); }
    }
    /**
     * Hides the history view and shows the chat view.
     */
    hideHistoryView() {
        this.isHistoryViewActive = false;
        this.uiManager.showChatView();
        // Ensure the correct title is displayed when switching back
        const currentChat = this.chatState.getCurrentChat();
        if (currentChat) {
            this.callbacks.updateTitleInput(currentChat.title);
        }
    }
}
exports.HistoryHandler = HistoryHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/input-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/input-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputHandler = void 0;
const content_editable_utils_1 = __webpack_require__(/*! ../utils/content-editable-utils */ "./node_modules/jupyter-simple-extension/lib/utils/content-editable-utils.js"); // Helper needed
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js"); // Import globals
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js");
/**
 * Handles events and logic related to the chat input field.
 */
class InputHandler {
    constructor(chatInput, callbacks
    // uiManager: UIManager // Removed unused parameter
    ) {
        // private uiManager: UIManager; // Removed unused member
        // --- Code Reference State ---
        this.codeRefMap = new Map();
        this.nextRefId = 1;
        // ---------------------------
        this.hasAtSymbol = false;
        this.isMarkdownMode = false; // Internal state, potentially synced with UIManager
        this.isInputExpanded = false; // Internal state, potentially synced with UIManager
        // NEW Click handler for widget interactions (e.g., expand)
        this._handleClick = (event) => {
            const target = event.target;
            const widget = target.closest('.jp-llm-ext-ref-widget');
            if (widget && widget.isContentEditable) {
                // Don't trigger preview if clicking inside the main editable div itself
                // Only trigger if clicking directly on a non-editable widget span
                if (widget === this.chatInput)
                    return; // Ignore clicks on the main div background
            }
            if (widget && !widget.isContentEditable) { // Ensure it's our non-editable widget span
                const type = widget.dataset.type;
                const content = widget.dataset.content;
                const refId = widget.dataset.refId;
                const path = widget.dataset.path;
                console.log(`Widget clicked: Type=${type}, RefID=${refId}, Path=${path}`);
                if ((type === 'code' || type === 'cell') && content) {
                    event.preventDefault(); // Prevent potential text selection issues
                    event.stopPropagation(); // Stop event from bubbling further
                    this.showWidgetPreview(widget, content);
                }
                else {
                    // Handle click on file/dir or widget without content? Maybe do nothing.
                    // Or potentially remove existing preview if any
                    this.removeWidgetPreview();
                }
            }
            else {
                // Click was not on a widget, remove any existing preview
                this.removeWidgetPreview();
            }
        };
        // --- Widget Preview Logic ---
        this.activePreviewElement = null;
        // --- Private Event Handlers ---
        this._handleKeyPress = (event) => {
            // Handle Enter key press (send message)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default newline insertion
                // NEW: Use serialization method to get the raw message with placeholders
                let message = this._serializeInputContent();
                message = message.trim(); // Trim whitespace
                if (message) {
                    // Resolve code references with proper formatting based on markdown mode
                    const resolvedMessage = this.resolveCodeReferences(message, this.isMarkdownMode);
                    // Pass resolved message with current markdown state
                    this.callbacks.handleSendMessage(resolvedMessage, this.isMarkdownMode);
                }
            }
            // --- Handle Tab/Escape/Arrows for popup interaction ---
            // Check if popup is visible (needs a way to know, maybe via callbacks or direct reference?)
            // Assuming popupMenuManager reference is available or state is tracked
            // else if (this.popupMenuManager.isPopupMenuVisible()) { // Pseudo-code
            //    if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            //        // Prevent default input field behavior
            //        event.preventDefault();
            //        // Let the PopupMenuManager's document handler manage the event
            //    }
            // }
            // --- End Popup Interaction Handling ---
        };
        this._handleInput = () => {
            // Use textContent for div
            const currentText = this.chatInput.textContent || '';
            // --- Update Code Ref Placeholders --- 
            // Optional: If we want visual placeholders to update live
            // This could involve complex DOM manipulation or using a library.
            // For now, we resolve refs only on send.
            // --- At Symbol Detection for Popup --- 
            // This logic was moved to UIManager.handleInputForReference
            // because UIManager needs to coordinate showing the popup.
            // InputHandler might still need to know *if* an @ was typed recently
            // to adjust behavior (e.g., how Enter works), but UIManager handles the popup trigger.
            // Simple check if text contains '@' for potential state management
            this.hasAtSymbol = currentText.includes('@');
            // Adjust input height dynamically based on content?
            // Can be complex with contenteditable divs. Requires careful calculation.
            // this.adjustInputHeight(); 
        };
        // NEW Keydown handler for widget deletion etc.
        this._handleKeyDown = (event) => {
            var _a, _b;
            const selection = window.getSelection();
            if (!selection || !selection.rangeCount || !selection.isCollapsed) {
                // Only handle single cursor position, not range selection
                return;
            }
            const range = selection.getRangeAt(0);
            const container = range.startContainer;
            const offset = range.startOffset;
            const key = event.key;
            let widgetToDelete = null;
            let nodeToCheck = null;
            if (key === 'Backspace') {
                if (offset > 0 && container.nodeType === Node.TEXT_NODE) {
                    // Cursor is within a text node, check the node *before* this text node
                    // But only if the cursor is at the *start* of the text node (offset === 0? No, check previousSibling always?)
                    // Let's check the node directly preceding the container
                    nodeToCheck = container.previousSibling;
                }
                else if (offset > 0 && container === this.chatInput) {
                    // Cursor is between nodes in the main input div
                    nodeToCheck = container.childNodes[offset - 1];
                }
                else if (offset === 0 && container !== this.chatInput) {
                    // Cursor is at the beginning of a non-div node (e.g., start of a text node after a widget)
                    // Need to check the node before the container
                    nodeToCheck = container.previousSibling;
                }
                // Check if the node to check is a ZWS or space node, if so, check the node before that
                if (nodeToCheck && nodeToCheck.nodeType === Node.TEXT_NODE && (nodeToCheck.textContent === '\u200B' || nodeToCheck.textContent === ' ')) {
                    nodeToCheck = nodeToCheck.previousSibling;
                }
            }
            else if (key === 'Delete') {
                if (container.nodeType === Node.TEXT_NODE && offset < container.length) {
                    // Cursor is within a text node, check the node *after* this text node
                    nodeToCheck = container.nextSibling;
                }
                else if (container === this.chatInput && offset < container.childNodes.length) {
                    // Cursor is between nodes in the main input div
                    nodeToCheck = container.childNodes[offset];
                }
                else if (container !== this.chatInput && offset === (((_a = container.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0)) {
                    // Cursor is at the end of a non-div node (e.g., end of a text node before a widget)
                    // Need to check the node after the container
                    nodeToCheck = container.nextSibling;
                }
                // Check if the node to check is a ZWS or space node, if so, check the node after that
                if (nodeToCheck && nodeToCheck.nodeType === Node.TEXT_NODE && (nodeToCheck.textContent === '\u200B' || nodeToCheck.textContent === ' ')) {
                    nodeToCheck = nodeToCheck.nextSibling;
                }
            }
            // Check if the final nodeToCheck is a widget
            if (nodeToCheck && nodeToCheck.nodeType === Node.ELEMENT_NODE && ((_b = nodeToCheck.classList) === null || _b === void 0 ? void 0 : _b.contains('jp-llm-ext-ref-widget'))) {
                widgetToDelete = nodeToCheck;
                console.log(`${key} pressed adjacent to widget:`, widgetToDelete);
            }
            if (widgetToDelete) {
                event.preventDefault();
                const parent = widgetToDelete.parentNode;
                if (parent) {
                    // Define nodes to remove: widget itself, potentially space before, potentially ZWS after
                    const nodesToRemove = [widgetToDelete];
                    const spaceBefore = widgetToDelete.previousSibling;
                    const zwsAfter = widgetToDelete.nextSibling;
                    if (spaceBefore && spaceBefore.nodeType === Node.TEXT_NODE && spaceBefore.textContent === ' ') {
                        nodesToRemove.unshift(spaceBefore); // Add space to beginning of removal list
                    }
                    if (zwsAfter && zwsAfter.nodeType === Node.TEXT_NODE && zwsAfter.textContent === '\u200B') {
                        nodesToRemove.push(zwsAfter); // Add ZWS to end of removal list
                    }
                    // Remove all identified nodes
                    nodesToRemove.forEach(node => parent.removeChild(node));
                    // Optional: Remove ref from map if it was a code/cell ref
                    const refId = widgetToDelete.dataset.refId;
                    if (refId && this.codeRefMap.has(refId)) {
                        this.codeRefMap.delete(refId);
                        console.log('Removed reference from map:', refId);
                    }
                    // Trigger input event manually after deletion
                    this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
            }
        };
        this.chatInput = chatInput;
        this.callbacks = callbacks;
        // this.uiManager = uiManager; // Removed unused assignment
        // Bind event listeners
        this.chatInput.addEventListener('keypress', this._handleKeyPress);
        this.chatInput.addEventListener('input', this._handleInput);
        this.chatInput.addEventListener('keydown', this._handleKeyDown);
        this.chatInput.addEventListener('click', this._handleClick); // ADDED Click Listener
        // Note: Actual markdown toggle and expand buttons are likely managed by UIManager,
        // which would then call methods like `setMarkdownMode` or `toggleExpansion` on this handler.
    }
    /**
     * Removes event listeners.
     */
    dispose() {
        this.chatInput.removeEventListener('keypress', this._handleKeyPress);
        this.chatInput.removeEventListener('input', this._handleInput);
        this.chatInput.removeEventListener('keydown', this._handleKeyDown);
        this.chatInput.removeEventListener('click', this._handleClick); // ADDED
    }
    /**
     * Appends text to the input field, potentially replacing a preceding '@' symbol.
     */
    appendToInput(text) {
        try {
            this.chatInput.focus(); // Ensure focus first
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                console.error('Cannot append to input: No selection found.');
                // Fallback: append to end
                this.chatInput.textContent = (this.chatInput.textContent || '') + text;
                return;
            }
            const range = selection.getRangeAt(0);
            const { startContainer, startOffset } = range;
            let currentTextContent = this.chatInput.textContent || ''; // Use textContent
            let insertPos = (0, content_editable_utils_1.getCaretPosition)(this.chatInput); // Get linear position
            // Simple check: if the character before the linear caret position is '@'
            if (insertPos > 0 && currentTextContent[insertPos - 1] === '@') {
                // Replace the '@' - more complex with DOM manipulation,
                // For simplicity, we'll replace in textContent and reset
                const before = currentTextContent.slice(0, insertPos - 1);
                const after = currentTextContent.slice(insertPos);
                this.chatInput.textContent = before + text + after;
                // Set cursor position after the inserted text
                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, (insertPos - 1) + text.length);
            }
            else {
                // Standard insertion - more complex with DOM manipulation
                // For simplicity, we'll insert in textContent and reset
                const before = currentTextContent.slice(0, insertPos);
                const after = currentTextContent.slice(insertPos);
                this.chatInput.textContent = before + text + after;
                // Set cursor position after the inserted text
                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, insertPos + text.length);
            }
            // Trigger input event manually since we're changing textContent directly
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    /**
     * Clears the input field and resets associated state after sending.
     */
    clearInput() {
        // Use textContent for div
        this.chatInput.textContent = '';
        // Directly reset internal state instead of relying on callback
        this.resetCodeReferences();
        // Remove rows manipulation
        // this.chatInput.rows = 1;
        this.chatInput.style.height = ''; // Reset height
        this.hasAtSymbol = false; // Reset @ state
        // Reset expand button state if it was expanded
        if (this.isInputExpanded) {
            this.toggleInputExpansion(false); // Collapse input
        }
        // Trigger input event manually after clearing
        this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    }
    /**
     * Sets the markdown mode state and updates the placeholder.
     */
    setMarkdownMode(isMarkdown) {
        this.isMarkdownMode = isMarkdown;
        this.callbacks.updatePlaceholder(this.isMarkdownMode);
        // Update placeholder directly (alternative to callback)
        // this.chatInput.placeholder = this.isMarkdownMode ? 
        //   'Write markdown here...' : 
        //   'Ask me anything...';
    }
    /**
     * Toggles the input expansion state and updates UI.
     */
    toggleInputExpansion(forceState) {
        this.isInputExpanded = forceState !== undefined ? forceState : !this.isInputExpanded;
        if (this.isInputExpanded) {
            // Use max-height or height for div
            this.chatInput.style.height = '200px'; // Example height
            // Allow vertical resizing if desired, or keep as 'none'
            this.chatInput.style.resize = 'vertical';
            this.chatInput.style.overflowY = 'auto'; // Ensure scrollbar appears if needed
        }
        else {
            this.chatInput.style.height = ''; // Reset height
            this.chatInput.style.resize = 'none';
            // Remove rows manipulation
            // this.chatInput.rows = 1; // Ensure it collapses back to 1 row height
            this.chatInput.style.overflowY = 'hidden'; // Hide scrollbar when collapsed
        }
        // Notify UIManager/LayoutBuilder to update button appearance
        this.callbacks.toggleInputExpansionUI(this.isInputExpanded);
    }
    // --- Code Reference Methods ---
    /**
     * Adds a code reference to the internal map and returns its ID.
     * @param codeContent The actual code content.
     * @param notebookName The name of the notebook the code is from.
     * @param cellIndex The index of the cell the code is from (0-based).
     * @param lineNumber The starting line number of the code within the cell (1-based).
     * @param lineEndNumber The ending line number of the code within the cell (1-based).
     * @returns The generated reference ID (e.g., "ref-1").
     */
    addCodeReference(codeContent, // Renamed parameter
    notebookName, cellIndex, lineNumber, // Start line
    lineEndNumber // End line
    ) {
        const refId = `ref-${this.nextRefId++}`;
        // Store type and use 'content' field
        const refData = {
            type: 'code',
            content: codeContent, // Use content field
            notebookName,
            cellIndex,
            lineNumber,
            lineEndNumber
        };
        this.codeRefMap.set(refId, refData);
        console.log('Added code reference:', refId, '->', `(${notebookName}, Cell ${cellIndex + 1}, Line ${lineNumber}${lineNumber !== lineEndNumber ? '_' + lineEndNumber : ''}) ` +
            codeContent.substring(0, 30) + '...' // Use codeContent
        );
        return refId;
    }
    /**
     * Returns the current map of code references.
     */
    getCodeReferenceMap() {
        return this.codeRefMap;
    }
    /**
     * Clears the code reference map and resets the ID counter.
     */
    resetCodeReferences() {
        // --- DEBUG LOG --- 
        console.log('[InputHandler] resetCodeReferences called!', new Error().stack); // Log call stack
        // --- END DEBUG LOG --- 
        this.codeRefMap.clear();
        this.nextRefId = 1;
        console.log('Code references reset.'); // Debug log
    }
    /**
     * Replaces code reference placeholders (e.g., "[ref-1]") in a message string
     * with the actual code from the map.
     * @param message The message string potentially containing placeholders.
     * @param isMarkdown Whether the message should be formatted for markdown
     * @returns The message string with placeholders resolved.
     */
    resolveCodeReferences(message, isMarkdown = false) {
        if (this.codeRefMap.size === 0) {
            return message; // No references to resolve
        }
        // Regex to find placeholders like [ref-1], [ref-12], etc.
        // Adjusted regex slightly to be non-greedy if needed, though current format is fine.
        const placeholderRegex = /@(?:code|Cell)\[(ref-\d+)\]|@code\((?:[^)]+)\)\[(ref-\d+)\]|\[(ref-\d+)\]/g;
        let resolvedMessage = message.replace(placeholderRegex, (match, refId1, refId2, refId3) => {
            const refId = refId1 || refId2 || refId3; // Get the captured refId
            if (!refId)
                return match; // If somehow no refId captured, return original match
            const refData = this.codeRefMap.get(refId);
            if (refData) {
                console.log(`Resolving ${refData.type} reference:`, refId); // Debug log type
                // Use refData.content (renamed from refData.code)
                // Add context based on type?
                let prefix, suffix;
                if (isMarkdown) {
                    // Format for markdown with code block
                    const lang = refData.type === 'code' ? 'python' : ''; // Default to python for code, blank for cell
                    prefix = refData.type === 'cell' ?
                        `\n\`\`\`${lang} # Cell ${refData.cellIndex + 1} (${refData.notebookName})\n` :
                        `\n\`\`\`${lang} # Code (${refData.notebookName}:Cell ${refData.cellIndex + 1}:L${refData.lineNumber}-${refData.lineEndNumber})\n`;
                    suffix = `\n\`\`\``;
                }
                else {
                    // Plain text format
                    prefix = refData.type === 'cell' ?
                        `\n--- Start Cell ${refData.cellIndex + 1} (${refData.notebookName}) ---\n` :
                        `\n--- Start Code (${refData.notebookName}:Cell ${refData.cellIndex + 1}:L${refData.lineNumber}-${refData.lineEndNumber}) ---\n`;
                    suffix = refData.type === 'cell' ?
                        `\n--- End Cell ${refData.cellIndex + 1} ---` :
                        `\n--- End Code ---`;
                }
                return `${prefix}${refData.content}${suffix}`;
            }
            else {
                console.warn('Could not find data for reference:', refId); // Warn if ref ID not found
                return match; // Keep the placeholder if not found
            }
        });
        return resolvedMessage;
    }
    // NEW method specifically for Ctrl+L shortcut
    handleInsertCodeReferenceFromShortcut(selectedText) {
        var _a, _b, _c;
        const currentNotebookWidget = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;
        const activeCell = (_b = globals_1.globals.notebookTracker) === null || _b === void 0 ? void 0 : _b.activeCell;
        const editor = activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor;
        const cmEditor = editor ? editor.editor : null; // CodeMirror view
        if (!currentNotebookWidget || !activeCell || !editor || !cmEditor || !cmEditor.state) {
            console.error('Cannot insert code reference: Missing notebook, cell, or editor context.');
            // Optionally show an indicator via callbacks?
            return;
        }
        try {
            // 1. Gather Context
            const notebookPath = currentNotebookWidget.context.path;
            const notebookName = ((_c = notebookPath.split('/').pop()) === null || _c === void 0 ? void 0 : _c.split('.')[0]) || 'notebook';
            const cellIndex = currentNotebookWidget.content.activeCellIndex;
            const state = cmEditor.state;
            const selection = state.selection.main;
            const startLine = state.doc.lineAt(selection.from).number; // 1-based
            const endLine = state.doc.lineAt(selection.to).number; // 1-based
            if (cellIndex === undefined || cellIndex === null) {
                console.error('Cannot insert code reference: Could not determine active cell index.');
                return;
            }
            // 2. Create Ref Data (but don't necessarily add to map yet? Or do?)
            // Let's add it now for consistency.
            const refData = {
                type: 'code',
                content: selectedText,
                notebookName,
                cellIndex,
                lineNumber: startLine,
                lineEndNumber: endLine
            };
            const refId = `ref-${this.nextRefId++}`;
            this.codeRefMap.set(refId, refData);
            console.log(`Added code reference via shortcut: ${refId}`);
            // ADDED: Construct placeholder
            const placeholder = `@code[${refId}]`;
            // 3. Insert RENDERED WIDGET Representation into Input Field
            this.chatInput.focus(); // Ensure focus
            const winSelection = window.getSelection();
            if (!winSelection || winSelection.rangeCount === 0) {
                console.error('Cannot insert reference widget: No window selection found.');
                // Fallback might be complex, maybe just log error for now
                return;
            }
            const range = winSelection.getRangeAt(0);
            // Render the widget - Pass placeholder
            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('code', refData, placeholder, refId);
            // Create a zero-width space text node for cursor positioning
            const zeroWidthSpace = document.createTextNode('\u200B');
            // Add a normal space for separation
            const spaceNode = document.createTextNode(' ');
            range.deleteContents(); // Clear any existing selection in the input field
            range.insertNode(spaceNode); // Insert space first
            range.insertNode(widgetElement); // Insert the widget element
            range.insertNode(zeroWidthSpace); // Insert ZWS after widget
            // Move cursor after the zero-width space (effectively after the widget + space)
            range.setStartAfter(zeroWidthSpace);
            range.setEndAfter(zeroWidthSpace);
            winSelection.removeAllRanges();
            winSelection.addRange(range);
            // --- End Insertion Logic ---
            // Trigger input event manually
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error handling insert code reference from shortcut:', error);
        }
    }
    // NEW: Method to add a cell reference
    addCellReference(notebookName, cellIndex) {
        var _a;
        const notebookPanel = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;
        if (!notebookPanel || !notebookPanel.content.model || !notebookPanel.content.model.cells) {
            console.error('Cannot add cell reference: Notebook or cells not found.');
            return null;
        }
        const model = notebookPanel.content.model;
        if (cellIndex < 0 || cellIndex >= model.cells.length) {
            console.error(`Cannot add cell reference: Invalid cell index ${cellIndex}`);
            return null;
        }
        const cell = model.cells.get(cellIndex);
        let cellContent = '';
        // Get cell content - handle different ways content might be stored
        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {
            cellContent = cell.sharedModel.getSource();
        }
        else {
            const cellJson = cell.toJSON();
            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
            if (typeof source === 'string') {
                cellContent = source;
            }
            else if (Array.isArray(source)) {
                cellContent = source.join('\n'); // Corrected: Use actual newline
            }
        }
        const refId = `ref-${this.nextRefId++}`;
        const refData = {
            type: 'cell',
            content: cellContent,
            notebookName,
            cellIndex
            // lineNumber/lineEndNumber are omitted
        };
        this.codeRefMap.set(refId, refData);
        // Combine console.log into one line
        console.log(`Added cell reference: ${refId} -> (${notebookName}, Cell ${cellIndex + 1}) ${cellContent.substring(0, 30)}...`);
        return refId;
    }
    // NEW method specifically for Ctrl+L shortcut (Cell)
    handleInsertCellReferenceFromShortcut() {
        var _a, _b, _c;
        const currentNotebookWidget = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;
        const activeCell = (_b = globals_1.globals.notebookTracker) === null || _b === void 0 ? void 0 : _b.activeCell;
        if (!currentNotebookWidget || !activeCell) {
            console.error('Cannot insert cell reference: Missing notebook or cell context.');
            return;
        }
        try {
            // 1. Gather Context
            const notebookPath = currentNotebookWidget.context.path;
            const notebookName = ((_c = notebookPath.split('/').pop()) === null || _c === void 0 ? void 0 : _c.split('.')[0]) || 'notebook';
            const cellIndex = currentNotebookWidget.content.activeCellIndex;
            if (cellIndex === undefined || cellIndex === null) {
                console.error('Cannot insert cell reference: Could not determine active cell index.');
                return;
            }
            // 2. Add Cell Reference to Map and get data
            const refId = this.addCellReference(notebookName, cellIndex);
            if (!refId) {
                console.error('Failed to add cell reference to map.');
                return; // Stop if we couldn't create the reference data
            }
            const refData = this.codeRefMap.get(refId);
            if (!refData) {
                console.error(`Failed to retrieve data for cell reference ${refId}.`);
                return;
            }
            // ADDED: Construct placeholder
            const placeholder = `@Cell[${cellIndex + 1}]`;
            // 3. Insert RENDERED WIDGET Representation into Input Field
            this.chatInput.focus(); // Ensure focus
            const winSelection = window.getSelection();
            if (!winSelection || winSelection.rangeCount === 0) {
                console.error('Cannot insert reference widget: No window selection found.');
                return;
            }
            const range = winSelection.getRangeAt(0);
            // Render the widget - Pass placeholder
            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('cell', refData, placeholder, refId);
            // Create a zero-width space text node for cursor positioning
            const zeroWidthSpace = document.createTextNode('\u200B');
            // Add a normal space for separation
            const spaceNode = document.createTextNode(' ');
            range.deleteContents(); // Clear any existing selection in the input field
            range.insertNode(spaceNode); // Insert space first
            range.insertNode(widgetElement); // Insert the widget element
            range.insertNode(zeroWidthSpace); // Insert ZWS after widget
            // Move cursor after the zero-width space
            range.setStartAfter(zeroWidthSpace);
            range.setEndAfter(zeroWidthSpace);
            winSelection.removeAllRanges();
            winSelection.addRange(range);
            // Trigger input event manually
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error handling insert cell reference from shortcut:', error);
        }
    }
    // NEW method for inserting File widgets from Popup
    handleInsertFileWidget(filePath) {
        var _a;
        try {
            this.chatInput.focus(); // Ensure focus
            const winSelection = window.getSelection();
            if (!winSelection || winSelection.rangeCount === 0) {
                console.error('Cannot insert file widget: No window selection found.');
                return;
            }
            // Get the current selection range
            const range = winSelection.getRangeAt(0);
            // Construct placeholder
            const placeholder = `@file[${filePath}]`;
            // Render the widget - Pass placeholder (no refId needed)
            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('file', filePath, placeholder);
            // Create a zero-width space text node for cursor positioning
            const zeroWidthSpace = document.createTextNode('\u200B');
            // Add a normal space for separation
            const spaceNode = document.createTextNode(' ');
            // Check if the character before the cursor is '@' and replace it
            let replacedAtSymbol = false;
            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {
                const textBefore = (_a = range.startContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, range.startOffset);
                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {
                    // Modify the range to include the '@'
                    range.setStart(range.startContainer, range.startOffset - 1);
                    replacedAtSymbol = true;
                    console.log("Replacing @ symbol before inserting file widget."); // Debug log
                }
            }
            // Wrap the widget and additional nodes in a fragment for cleaner insertion
            const fragment = document.createDocumentFragment();
            fragment.appendChild(widgetElement);
            fragment.appendChild(zeroWidthSpace);
            fragment.appendChild(spaceNode);
            // Delete any selected content (including @ if found)
            range.deleteContents();
            // Insert the fragment with all elements
            range.insertNode(fragment);
            // Explicitly move cursor after the inserted space node
            const newRange = document.createRange();
            newRange.setStartAfter(spaceNode);
            newRange.setEndAfter(spaceNode);
            winSelection.removeAllRanges();
            winSelection.addRange(newRange);
            // Trigger input event manually
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error handling insert file widget:', error);
        }
    }
    // NEW method for inserting Directory widgets from Popup
    handleInsertDirWidget(dirPath) {
        var _a;
        try {
            this.chatInput.focus(); // Ensure focus
            const winSelection = window.getSelection();
            if (!winSelection || winSelection.rangeCount === 0) {
                console.error('Cannot insert directory widget: No window selection found.');
                return;
            }
            const range = winSelection.getRangeAt(0);
            // Construct placeholder
            const placeholder = `@dir[${dirPath}]`;
            // Render the widget - Pass placeholder (no refId needed)
            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('dir', dirPath, placeholder);
            // Create a zero-width space text node for cursor positioning
            const zeroWidthSpace = document.createTextNode('\u200B');
            // Add a normal space for separation
            const spaceNode = document.createTextNode(' ');
            // Check if the character before the cursor is '@' and replace it
            let replacedAtSymbol = false;
            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {
                const textBefore = (_a = range.startContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, range.startOffset);
                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {
                    // Modify the range to include the '@'
                    range.setStart(range.startContainer, range.startOffset - 1);
                    replacedAtSymbol = true;
                    console.log("Replacing @ symbol before inserting dir widget."); // Debug log
                }
            }
            // Wrap the widget and additional nodes in a fragment for cleaner insertion
            const fragment = document.createDocumentFragment();
            fragment.appendChild(widgetElement);
            fragment.appendChild(zeroWidthSpace);
            fragment.appendChild(spaceNode);
            // Delete any selected content (including @ if found)
            range.deleteContents();
            // Insert the fragment with all elements
            range.insertNode(fragment);
            // Explicitly move cursor after the inserted space node
            const newRange = document.createRange();
            newRange.setStartAfter(spaceNode);
            newRange.setEndAfter(spaceNode);
            winSelection.removeAllRanges();
            winSelection.addRange(newRange);
            // Trigger input event manually
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error handling insert directory widget:', error);
        }
    }
    // NEW method for inserting Cell widgets from Popup
    handleInsertCellWidgetFromPopup(cellIndex) {
        var _a, _b, _c;
        const currentNotebookWidget = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;
        if (!currentNotebookWidget) {
            console.error('Cannot insert cell widget: Missing notebook context.');
            return;
        }
        try {
            // 1. Gather Context (Notebook Name)
            const notebookPath = currentNotebookWidget.context.path;
            const notebookName = ((_b = notebookPath.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';
            // Provided cellIndex is 0-based already
            if (cellIndex === undefined || cellIndex === null || cellIndex < 0) {
                console.error(`Cannot insert cell widget: Invalid cell index ${cellIndex}.`);
                return;
            }
            // 2. Add Cell Reference to Map and get data
            const refId = this.addCellReference(notebookName, cellIndex);
            if (!refId) {
                console.error('Failed to add cell reference to map for index:', cellIndex);
                return; // Stop if we couldn't create the reference data
            }
            const refData = this.codeRefMap.get(refId);
            if (!refData) {
                console.error(`Failed to retrieve data for cell reference ${refId}.`);
                return;
            }
            // ADDED: Construct placeholder
            const placeholder = `@Cell[${cellIndex + 1}]`;
            // 3. Insert RENDERED WIDGET Representation into Input Field
            this.chatInput.focus(); // Ensure focus
            const winSelection = window.getSelection();
            if (!winSelection || winSelection.rangeCount === 0) {
                console.error('Cannot insert cell widget: No window selection found.');
                return;
            }
            const range = winSelection.getRangeAt(0);
            // Render the widget - Pass placeholder
            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('cell', refData, placeholder, refId);
            const zeroWidthSpace = document.createTextNode('\u200B');
            const spaceNode = document.createTextNode(' ');
            // Check if the character before the cursor is '@' and replace it
            let replacedAtSymbol = false;
            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {
                const textBefore = (_c = range.startContainer.textContent) === null || _c === void 0 ? void 0 : _c.substring(0, range.startOffset);
                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {
                    range.setStart(range.startContainer, range.startOffset - 1);
                    replacedAtSymbol = true;
                    console.log("Replacing @ symbol before inserting cell widget.");
                }
            }
            // Create a fragment to hold our nodes in the correct order
            const fragment = document.createDocumentFragment();
            fragment.appendChild(widgetElement);
            fragment.appendChild(zeroWidthSpace);
            fragment.appendChild(spaceNode);
            // Delete any selected content (including @ if found)
            range.deleteContents();
            // Insert all elements at once in the correct order
            range.insertNode(fragment);
            // Move cursor after the zero-width space
            range.setStartAfter(spaceNode);
            range.setEndAfter(spaceNode);
            winSelection.removeAllRanges();
            winSelection.addRange(range);
            // Trigger input event manually
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error handling insert cell widget from popup:', error);
        }
    }
    // NEW method for inserting Code widgets from Popup (via insertCollapsedCodeRef callback)
    handleInsertCodeWidgetFromPopup(codeContent, notebookName, cellIndex, lineNumber // Assumes start line = end line from popup callback
    ) {
        var _a;
        try {
            // 1. Create Ref Data (assume start=end line)
            const lineEndNumber = lineNumber;
            const refData = {
                type: 'code',
                content: codeContent,
                notebookName,
                cellIndex,
                lineNumber,
                lineEndNumber
            };
            const refId = `ref-${this.nextRefId++}`;
            this.codeRefMap.set(refId, refData);
            console.log(`Added code reference via popup: ${refId}`);
            // ADDED: Construct placeholder
            const placeholder = `@code[${refId}]`;
            // 2. Insert RENDERED WIDGET Representation into Input Field
            this.chatInput.focus(); // Ensure focus
            const winSelection = window.getSelection();
            if (!winSelection || winSelection.rangeCount === 0) {
                console.error('Cannot insert code widget: No window selection found.');
                return;
            }
            const range = winSelection.getRangeAt(0);
            // Render the widget - Pass placeholder
            const widgetElement = (0, message_renderer_1.renderReferenceWidgetInline)('code', refData, placeholder, refId);
            const zeroWidthSpace = document.createTextNode('\u200B');
            const spaceNode = document.createTextNode(' ');
            // Check if the character before the cursor is '@' and replace it
            let replacedAtSymbol = false;
            if (range.startOffset > 0 && range.startContainer.nodeType === Node.TEXT_NODE) {
                const textBefore = (_a = range.startContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, range.startOffset);
                if (textBefore === null || textBefore === void 0 ? void 0 : textBefore.endsWith('@')) {
                    range.setStart(range.startContainer, range.startOffset - 1);
                    replacedAtSymbol = true;
                    console.log("Replacing @ symbol before inserting code widget.");
                }
            }
            // Create a fragment to hold our nodes in the correct order
            const fragment = document.createDocumentFragment();
            fragment.appendChild(widgetElement);
            fragment.appendChild(zeroWidthSpace);
            fragment.appendChild(spaceNode);
            // Delete any selected content (including @ if found)
            range.deleteContents();
            // Insert all elements at once in the correct order
            range.insertNode(fragment);
            // Move cursor after the zero-width space
            range.setStartAfter(spaceNode);
            range.setEndAfter(spaceNode);
            winSelection.removeAllRanges();
            winSelection.addRange(range);
            // Trigger input event manually
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error handling insert code widget from popup:', error);
        }
    }
    // NEW method to serialize input content, converting widgets back to placeholders
    _serializeInputContent() {
        let serialized = '';
        const nodes = this.chatInput.childNodes;
        nodes.forEach(node => {
            var _a;
            if (node.nodeType === Node.TEXT_NODE) {
                // Append text content directly
                serialized += node.textContent || '';
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                // Check if it's our widget span
                if ((_a = element.classList) === null || _a === void 0 ? void 0 : _a.contains('jp-llm-ext-ref-widget')) {
                    // Append the stored placeholder text
                    const placeholder = element.dataset.placeholder;
                    if (placeholder) {
                        serialized += placeholder;
                    }
                    else {
                        // Fallback: append the visible text if placeholder is missing (shouldn't happen)
                        console.warn('Widget found without data-placeholder:', element);
                        serialized += element.textContent || '';
                    }
                }
                else if (element.tagName === 'BR') {
                    // Handle <br> as newline
                    serialized += '\n';
                }
                else if (element.tagName === 'DIV') {
                    // Handle <div> elements, potentially introduced by pasting or Shift+Enter
                    // Recursively serialize or just add newline?
                    // Add newline before and serialize inner content recursively?
                    // For now, let's treat div boundaries as potential newlines, similar to <br>
                    // We might need a more robust HTML -> text conversion later
                    serialized += '\n'; // Simplified handling
                }
                else {
                    // Append text content of other unknown elements?
                    serialized += element.textContent || '';
                }
            }
        });
        // Trim potentially leading/trailing whitespace introduced during serialization
        // or by the structure of the contenteditable div
        return serialized.trim();
    }
    showWidgetPreview(widgetElement, content) {
        // Remove existing preview first
        this.removeWidgetPreview();
        console.log('Showing preview for widget:', widgetElement);
        const firstThreeLines = content.split('\n').slice(0, 3).join('\n');
        const preview = document.createElement('div');
        preview.className = 'jp-llm-ext-widget-preview';
        // Basic styling (move to CSS later)
        preview.style.position = 'absolute';
        preview.style.border = '1px solid var(--jp-border-color1)';
        preview.style.background = 'var(--jp-layout-color0)';
        preview.style.padding = '5px';
        preview.style.fontSize = '0.9em';
        preview.style.maxWidth = '400px';
        preview.style.maxHeight = '100px';
        preview.style.overflow = 'hidden';
        preview.style.whiteSpace = 'pre-wrap'; // Preserve whitespace and newlines
        preview.style.fontFamily = 'monospace';
        preview.style.zIndex = '10000'; // Ensure it's on top
        preview.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        preview.textContent = firstThreeLines + (content.split('\n').length > 3 ? '\n...' : '');
        // Position near the widget
        const widgetRect = widgetElement.getBoundingClientRect();
        // Position above the widget for now
        preview.style.bottom = `${window.innerHeight - widgetRect.top + 5}px`;
        preview.style.left = `${widgetRect.left}px`;
        document.body.appendChild(preview); // Append to body to avoid layout issues
        this.activePreviewElement = preview;
    }
    removeWidgetPreview() {
        if (this.activePreviewElement) {
            console.log('Removing active preview');
            this.activePreviewElement.remove();
            this.activePreviewElement = null;
        }
    }
    /**
      // Handle @ symbol removal to hide popup using selection API
      const selection = window.getSelection();
      if (!selection || !selection.rangeCount) return;
  
      const range = selection.getRangeAt(0);
      // Check if the input field contains the start of the range
      if (!this.chatInput.contains(range.startContainer)) return;
  
      const cursorPosition = getCaretPosition(this.chatInput); // Use helper
      if (cursorPosition === null) return;
  
      const textContent = this.chatInput.textContent || '';
      const textBeforeCursor = textContent.slice(0, cursorPosition);
  
      // Check if the character immediately before the cursor is '@'
      // and if it's preceded by whitespace or is at the start of the input.
      const isAtSymbolContext = textBeforeCursor.endsWith('@') &&
                             (cursorPosition === 1 ||
                              cursorPosition > 1 && /\s/.test(textBeforeCursor[cursorPosition - 2]));
  
      if (this.hasAtSymbol && !isAtSymbolContext) {
        // @ symbol context was present but now it's gone, hide the popup
        this.callbacks.hidePopupMenu();
      }
      // Update the state *after* checking the previous state
      this.hasAtSymbol = isAtSymbolContext;
  
      // --- Auto-resize logic (optional) ---
      // Simple auto-resize based on scroll height (might need refinement)
      if (!this.isInputExpanded) { // Only auto-resize if not manually expanded
          this.chatInput.style.height = 'auto'; // Temporarily shrink to content
          const scrollHeight = this.chatInput.scrollHeight;
          // Set a max height to prevent infinite growth, e.g., 150px
          const maxHeight = 150;
          const newHeight = Math.min(scrollHeight, maxHeight);
           // Only update height if it actually changes to avoid flicker
          if (this.chatInput.offsetHeight < newHeight) {
               this.chatInput.style.height = `${newHeight}px`;
               this.chatInput.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
          } else if (scrollHeight <= this.chatInput.clientHeight) {
              // Shrink if content height is less than current height
              this.chatInput.style.height = `${scrollHeight}px`;
              this.chatInput.style.overflowY = 'hidden';
          }
      }
      // -----------------------------------
    };
    
    /**
     * Explicitly sets the hasAtSymbol flag. Called by shortcut handler.
     */
    setHasAtSymbol(value) {
        this.hasAtSymbol = value;
    }
    /**
     * Gets the current value of the hasAtSymbol flag. Called by shortcut handler.
     */
    getHasAtSymbol() {
        return this.hasAtSymbol;
    }
}
exports.InputHandler = InputHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageHandler = void 0;
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js");
const notebook_integration_1 = __webpack_require__(/*! ../utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js"); // Import globals for notebook tracker
/**
 * Handles sending messages, interacting with the API,
 * managing streaming responses, and updating the UI and state.
 */
class MessageHandler {
    constructor(apiClient, chatState, uiManager, rendererCallbacks, inputHandler) {
        this.apiClient = apiClient;
        this.chatState = chatState;
        this.uiManager = uiManager;
        this.rendererCallbacks = rendererCallbacks;
        this.inputHandler = inputHandler;
    }
    /**
     * Processes and sends a user-initiated message.
     * Also handles adding the user message to the UI and clearing the input.
     * Accepts the message text.
     */
    handleSendMessage(message, isMarkdown = false) {
        if (!message.trim())
            return;
        console.log(`[MessageHandler] Handling send: "${message}", Markdown: ${isMarkdown}`);
        console.log(`[MessageHandler] isMarkdown type: ${typeof isMarkdown}, value: ${isMarkdown}`);
        // Add user message to UI with isMarkdown flag
        this.addMessage(message, 'user', isMarkdown);
        // Clear input via InputHandler (which uses UIManager)
        // REMOVED: this.inputHandler.clearInput(); // Input clearing is now handled by UIManager after the callback
        // Send message to backend API and handle streaming response
        this.streamAndRenderResponse(message);
    }
    /**
     * Sends an automatic message (e.g., 'confirmed', 'rejected')
     * to the backend and handles the streaming response.
     * Also adds the user's confirmation/rejection action and a separator to the UI.
     */
    handleSendAutoMessage(message) {
        if (!message.trim())
            return;
        // Add the user's action ('Confirmed' or 'Rejected') to the UI immediately
        const userDisplayMessage = message.charAt(0).toUpperCase() + message.slice(1);
        // Explicitly false for isMarkdown, true for isAuto
        this.addMessage(userDisplayMessage, 'user', false, true);
        // Create and add the separator element
        console.log('[MessageHandler] Creating action separator element...'); // Debug log
        const separatorDiv = document.createElement('div');
        separatorDiv.className = 'jp-llm-ext-action-separator'; // Add a class for potential styling
        separatorDiv.style.textAlign = 'center'; // Basic styling
        separatorDiv.style.margin = '10px 0'; // Add some vertical space
        separatorDiv.style.fontSize = '0.9em';
        separatorDiv.style.color = 'var(--jp-ui-font-color2, grey)'; // Use JupyterLab theme variable
        if (message === 'confirmed') {
            separatorDiv.textContent = '--------✅ Confirmed--------';
        }
        else if (message === 'rejected') {
            separatorDiv.textContent = '--------❌ Rejected--------';
        }
        else {
            // Optional: Handle unexpected messages? Or just don't add a separator.
            separatorDiv.textContent = `--------${userDisplayMessage}--------`;
        }
        // Add the separator directly to the UI Manager's container
        console.log('[MessageHandler] Attempting to add separator element:', separatorDiv); // Debug log
        this.uiManager.addChatMessageElement(separatorDiv);
        console.log('[MessageHandler] Separator element should be added.'); // Debug log
        // Send the technical message ('confirmed' or 'rejected') to the backend
        // and handle the streaming response from the backend.
        this.streamAndRenderResponse(message);
    }
    /**
     * Adds a message to the UI via UIManager and saves to ChatState.
     */
    addMessage(text, sender, isMarkdown = false, // Default false, overridden below
    isAuto = false // Flag for auto messages like confirm/reject
    ) {
        console.log(`[MessageHandler] Adding message: Sender=${sender}, Markdown=${isMarkdown}, Auto=${isAuto}`);
        console.log(`[MessageHandler] isMarkdown type in addMessage: ${typeof isMarkdown}, value: ${isMarkdown}`);
        let messageElement;
        // Prepare extended callbacks for the renderer
        const extendedCallbacks = Object.assign(Object.assign({}, this.rendererCallbacks), { getCodeRefData: (refId) => {
                return this.inputHandler.getCodeReferenceMap().get(refId);
            }, getCurrentNotebookContext: () => {
                var _a, _b;
                const currentNotebook = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;
                if (currentNotebook === null || currentNotebook === void 0 ? void 0 : currentNotebook.context) {
                    const path = currentNotebook.context.path;
                    const name = ((_b = path.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';
                    return { name, path };
                }
                return undefined;
            } });
        if (sender === 'user') {
            console.log(`[MessageHandler] Calling renderUserMessage with isMarkdown=${isMarkdown}`);
            // Pass the isMarkdown option and extended callbacks to the renderer
            messageElement = (0, message_renderer_1.renderUserMessage)(text, { isMarkdown }, extendedCallbacks);
        }
        else {
            // Bot messages usually are markdown unless specified otherwise
            // Handle auto messages specifically if they shouldn't be parsed as markdown
            const botIsMarkdown = !isAuto; // Assume auto messages aren't markdown
            // Pass extended callbacks to bot message renderer too, in case it needs them later
            messageElement = (0, message_renderer_1.renderBotMessage)(text, { isMarkdown: botIsMarkdown }, extendedCallbacks);
        }
        this.uiManager.addChatMessageElement(messageElement);
        // Don't save internal 'confirmed'/'rejected' messages to history
        if (!isAuto) {
            // Add isMarkdown back to the saved message state
            const chatMessage = { sender, text, isMarkdown };
            this.chatState.addMessageToCurrentChat(chatMessage);
        }
    }
    /**
     * Core logic for sending a message to the API, handling the stream,
     * rendering the response, and saving the final bot message.
     */
    streamAndRenderResponse(messageToSend) {
        // --- Prepare streaming UI elements (managed by UIManager) ---
        // UIManager should provide a method to create/get these elements
        const { streamingDiv, contentDiv } = this.uiManager.createBotMessageContainer();
        let completeResponse = '';
        const cellContext = (0, notebook_integration_1.getCurrentCellContent)(); // Use utility
        // Stream response from API
        this.apiClient.streamChat(messageToSend, { cellContext }, 
        // On chunk received
        (chunk) => {
            completeResponse += chunk;
            // Update the temporary streaming div
            streamingDiv.textContent = completeResponse;
            this.uiManager.scrollToBottom();
        }, 
        // On complete
        () => {
            var _a;
            // Hide streaming div, show final content div
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Render the complete response using the renderer function
            const renderedContent = (0, message_renderer_1.renderBotMessage)(completeResponse, { isMarkdown: true }, this.rendererCallbacks);
            contentDiv.innerHTML = ''; // Clear placeholder/previous content
            // Append rendered nodes, skipping any potential wrapper/indicator added by renderBotMessage itself
            while (renderedContent.firstChild) {
                // Check if the node is the specific markdown indicator we might add/remove
                // Or just append everything if renderBotMessage returns the pure content
                if (!((_a = renderedContent.firstChild.classList) === null || _a === void 0 ? void 0 : _a.contains('markdown-indicator'))) {
                    contentDiv.appendChild(renderedContent.firstChild);
                }
                else {
                    // Remove the indicator if it was part of the returned fragment
                    renderedContent.removeChild(renderedContent.firstChild);
                }
            }
            // Save final bot response to history via ChatState
            const isImage = completeResponse.trim().startsWith('/images/'); // Simple check
            const botMessageData = {
                text: completeResponse,
                sender: 'bot',
                isMarkdown: !isImage // Save as markdown unless it's an image URL
            };
            this.chatState.addMessageToCurrentChat(botMessageData);
            this.uiManager.scrollToBottom();
        }, 
        // On error
        (error) => {
            // Hide streaming div, show final content div with error
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Use a dedicated error rendering style/component if available
            contentDiv.innerHTML = `<div class="jp-llm-ext-error-message">Error: ${error.message}</div>`;
            console.error('API Error:', error);
            this.uiManager.scrollToBottom();
        });
    }
}
exports.MessageHandler = MessageHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/note-handler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/note-handler.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoteHandler = void 0;
const note_modal_1 = __webpack_require__(/*! ../ui/note-modal */ "./node_modules/jupyter-simple-extension/lib/ui/note-modal.js");
const markdown_1 = __webpack_require__(/*! ../utils/markdown */ "./node_modules/jupyter-simple-extension/lib/utils/markdown.js");
/**
 * Manages the notes UI and interactions.
 */
class NoteHandler {
    /**
     * Creates a new NoteHandler.
     * @param noteState The note state.
     * @param uiManager The UI manager.
     * @param callbacks Callbacks for note changes.
     * @param parentNode The parent node where the note handler will append its elements.
     */
    constructor(noteState, uiManager, callbacks, parentNode) {
        this.noteState = noteState;
        this.uiManager = uiManager;
        this.callbacks = callbacks;
        this.parentNode = parentNode;
        this.selectedNoteId = null;
        this.isNotesViewVisible = false;
        // Create main container for notes
        this.notesContainer = document.createElement('div');
        this.notesContainer.className = 'jp-llm-ext-notes-container';
        this.notesContainer.style.display = 'none';
        // Create container for the note list
        this.noteListContainer = document.createElement('div');
        this.noteListContainer.className = 'jp-llm-ext-note-list-container';
        // Create container for note content
        this.noteContentContainer = document.createElement('div');
        this.noteContentContainer.className = 'jp-llm-ext-note-content-container';
        // Create container for the note modal
        this.noteModalContainer = document.createElement('div');
        this.noteModalContainer.className = 'jp-llm-ext-note-modal-container';
        // Append the modal container to the parent node (not inside the notes container)
        // This allows the modal to appear as an overlay on the entire UI
        this.parentNode.appendChild(this.noteModalContainer);
        // Initialize the notes view
        this.initializeNotesView();
    }
    /**
     * Initializes the notes view with header, list and content sections.
     */
    initializeNotesView() {
        // Create header
        const header = document.createElement('div');
        header.className = 'jp-llm-ext-notes-header';
        // Create back button
        const backButton = document.createElement('button');
        backButton.className = 'jp-Button jp-llm-ext-back-button';
        backButton.innerHTML = '<span class="jp-icon3 jp-icon-selectable" role="presentation"><svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg></span>';
        backButton.title = 'Back to chat';
        backButton.addEventListener('click', () => this.hideNotesView());
        const title = document.createElement('h2');
        title.textContent = 'Notes';
        const addButton = document.createElement('button');
        addButton.className = 'jp-Button jp-llm-ext-add-note-button';
        addButton.textContent = 'Add Note';
        addButton.addEventListener('click', () => this.showAddNoteModal());
        header.appendChild(backButton);
        header.appendChild(title);
        header.appendChild(addButton);
        // Create flex container for list and content
        const flexContainer = document.createElement('div');
        flexContainer.className = 'jp-llm-ext-notes-flex-container';
        flexContainer.appendChild(this.noteListContainer);
        flexContainer.appendChild(this.noteContentContainer);
        // Add components to the main container
        this.notesContainer.appendChild(header);
        this.notesContainer.appendChild(flexContainer);
        // Initial render of notes
        this.renderNotes();
    }
    /**
     * Shows the add note modal.
     */
    showAddNoteModal() {
        const modalCallbacks = {
            handleSave: (title, content) => {
                this.noteState.createNewNote(title, content);
                this.renderNotes();
                this.hideNoteModal();
                this.onNoteChange();
            },
            handleCancel: () => {
                this.hideNoteModal();
            }
        };
        const modal = (0, note_modal_1.createNoteModalElement)(modalCallbacks);
        this.showModal(modal);
    }
    /**
     * Shows the edit note modal for a specific note.
     * @param note The note to edit.
     */
    showEditNoteModal(note) {
        const modalCallbacks = {
            handleSave: (title, content) => {
                this.noteState.updateNote(note.id, title, content);
                this.renderNotes();
                this.hideNoteModal();
                if (this.selectedNoteId === note.id) {
                    this.showNoteContent(note.id);
                }
                this.onNoteChange();
            },
            handleCancel: () => {
                this.hideNoteModal();
            }
        };
        const modal = (0, note_modal_1.createNoteModalElement)(modalCallbacks, note.title, note.content);
        this.showModal(modal);
    }
    /**
     * Called when a note is changed. Updates the UI title if needed.
     */
    onNoteChange() {
        // Check if a note is selected and update the title input
        const currentNote = this.noteState.getNoteById(this.selectedNoteId || '');
        if (currentNote && this.callbacks.updateTitleInput) {
            this.callbacks.updateTitleInput(currentNote.title);
        }
    }
    /**
     * Shows a modal in the note modal container.
     * @param modal The modal element to show.
     */
    showModal(modal) {
        // Clear any existing modal
        this.noteModalContainer.innerHTML = '';
        // Add the new modal
        this.noteModalContainer.appendChild(modal);
        // Show the modal container
        this.noteModalContainer.style.display = 'block';
    }
    /**
     * Hides the note modal.
     */
    hideNoteModal() {
        this.noteModalContainer.style.display = 'none';
        this.noteModalContainer.innerHTML = '';
    }
    /**
     * Renders the list of notes.
     */
    renderNotes() {
        // Clear the current list
        this.noteListContainer.innerHTML = '';
        // Get all notes
        const notes = this.noteState.getAllNotes();
        if (notes.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'jp-llm-ext-note-empty-message';
            emptyMessage.textContent = 'No notes yet. Click "Add Note" to create one.';
            this.noteListContainer.appendChild(emptyMessage);
            return;
        }
        // Create list
        const notesList = document.createElement('ul');
        notesList.className = 'jp-llm-ext-note-list';
        // Add each note to the list
        notes.forEach((note) => {
            const noteItem = document.createElement('li');
            noteItem.className = 'jp-llm-ext-note-item';
            if (this.selectedNoteId === note.id) {
                noteItem.classList.add('jp-llm-ext-note-item-selected');
            }
            // Note content (title and actions)
            const noteContent = document.createElement('div');
            noteContent.className = 'jp-llm-ext-note-item-content';
            const noteTitle = document.createElement('span');
            noteTitle.className = 'jp-llm-ext-note-item-title';
            noteTitle.textContent = note.title;
            const noteActions = document.createElement('div');
            noteActions.className = 'jp-llm-ext-note-item-actions';
            const editButton = document.createElement('button');
            editButton.className = 'jp-Button jp-llm-ext-note-edit-button';
            editButton.innerHTML = '<span class="jp-icon3 jp-icon-selectable" role="presentation"><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg></span>';
            editButton.title = 'Edit note';
            editButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent note selection
                this.showEditNoteModal(note);
            });
            const deleteButton = document.createElement('button');
            deleteButton.className = 'jp-Button jp-llm-ext-note-delete-button';
            deleteButton.innerHTML = '<span class="jp-icon3 jp-icon-selectable" role="presentation"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></span>';
            deleteButton.title = 'Delete note';
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent note selection
                if (confirm(`Are you sure you want to delete the note "${note.title}"?`)) {
                    this.noteState.deleteNote(note.id);
                    // If the deleted note was selected, clear the content container
                    if (this.selectedNoteId === note.id) {
                        this.selectedNoteId = null;
                        this.noteContentContainer.innerHTML = '';
                    }
                    this.renderNotes();
                    this.onNoteChange();
                }
            });
            noteActions.appendChild(editButton);
            noteActions.appendChild(deleteButton);
            noteContent.appendChild(noteTitle);
            noteContent.appendChild(noteActions);
            noteItem.appendChild(noteContent);
            // Add click event to show the note content
            noteItem.addEventListener('click', () => {
                this.showNoteContent(note.id);
            });
            notesList.appendChild(noteItem);
        });
        this.noteListContainer.appendChild(notesList);
    }
    /**
     * Shows the content of a specific note.
     * @param noteId The ID of the note to show.
     */
    showNoteContent(noteId) {
        // Set as selected
        this.selectedNoteId = noteId;
        // Re-render notes to update selection
        this.renderNotes();
        // Clear current content
        this.noteContentContainer.innerHTML = '';
        // Get the note
        const note = this.noteState.getNoteById(noteId);
        if (!note)
            return;
        // Create content container
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'jp-llm-ext-note-content-wrapper';
        // Note title
        const title = document.createElement('h3');
        title.className = 'jp-llm-ext-note-content-title';
        title.textContent = note.title;
        contentWrapper.appendChild(title);
        // Note content
        const content = document.createElement('div');
        content.className = 'jp-llm-ext-note-content-text jp-RenderedMarkdown';
        // Render markdown content
        content.innerHTML = (0, markdown_1.renderMarkdown)(note.content);
        contentWrapper.appendChild(content);
        this.noteContentContainer.appendChild(contentWrapper);
        // Update the title in parent UI if callback exists
        if (this.callbacks.updateTitleInput) {
            this.callbacks.updateTitleInput(note.title);
        }
    }
    /**
     * Toggles visibility of the notes view.
     */
    toggleNotesView() {
        this.isNotesViewVisible = !this.isNotesViewVisible;
        if (this.isNotesViewVisible) {
            this.showNotesView();
        }
        else {
            this.hideNotesView();
        }
    }
    /**
     * Shows the notes view.
     */
    showNotesView() {
        this.notesContainer.style.display = 'flex';
        this.isNotesViewVisible = true;
        // Use UIManager to properly hide message containers and show notes view
        this.uiManager.showNotesView();
        // Find any other message containers that might be visible and hide them
        const allMessageContainers = document.querySelectorAll('.jp-llm-ext-message-container');
        allMessageContainers.forEach(container => {
            container.style.display = 'none';
        });
    }
    /**
     * Hides the notes view.
     */
    hideNotesView() {
        this.notesContainer.style.display = 'none';
        this.isNotesViewVisible = false;
        // Use UIManager to show the chat view again
        this.uiManager.showChatView();
    }
    /**
     * Returns the notes container.
     * @returns The notes container element.
     */
    getContainer() {
        return this.notesContainer;
    }
}
exports.NoteHandler = NoteHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
/**
 * Manages the state and interactions of the multi-level popup menu.
 */
class PopupMenuManager {
    constructor(docManager, widgetNode, callbacks) {
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        this.currentNotebook = null;
        this.selectedMenuItemIndex = -1; // Track currently selected menu item
        this.isRenderingContent = false; // Flag to prevent recursive renders
        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders
        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];
        this.fileCache = new Map();
        this.docManager = docManager;
        this.widgetNode = widgetNode;
        this.callbacks = callbacks;
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        this.popupMenuContainer.style.position = 'absolute'; // Crucial for positioning relative to widgetNode
        // Attach to the widget node instead of the body
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Create search input
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search...';
        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling
        // Use 'input' event instead of directly re-rendering on every keystroke
        this.searchInput.addEventListener('input', () => {
            // Only re-render if the search term has actually changed
            if (this.searchInput.value !== this.lastSearchTerm) {
                this.lastSearchTerm = this.searchInput.value;
                this.renderMenuContent();
            }
        });
        // Handle keydown in search input to stop propagation for navigation keys
        this.searchInput.addEventListener('keydown', (event) => {
            console.log(`POPUP Search KeyDown: Key='${event.key}'`);
            // IMPORTANT: Prevent these keys from being captured by the document handler
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);
                if (event.key === 'Escape') {
                    // Handle Escape directly here
                    this.hidePopupMenu();
                }
                else if (event.key === 'Enter') {
                    // Select first item on Enter
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        // If we already have a selection, click it
                        if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {
                            menuItems[this.selectedMenuItemIndex].click();
                        }
                        else {
                            // Otherwise, select and click the first item
                            this.selectedMenuItemIndex = 0;
                            this.updateSelectionHighlight();
                            menuItems[0].click();
                        }
                    }
                }
                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        const direction = event.key === 'ArrowDown' ? 1 : -1;
                        // If no selection yet, select first or last based on direction
                        if (this.selectedMenuItemIndex < 0) {
                            this.selectedMenuItemIndex = direction > 0 ? 0 : menuItems.length - 1;
                        }
                        else {
                            // Otherwise move in the specified direction with wraparound
                            this.selectedMenuItemIndex = (this.selectedMenuItemIndex + direction + menuItems.length) % menuItems.length;
                        }
                        this.updateSelectionHighlight();
                        // Keep focus in search input but update selection visually
                        this.searchInput.focus();
                    }
                }
                event.preventDefault();
                event.stopPropagation();
            }
            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys
            // This allows default behavior to work properly
        }, true); // Use capture phase
        document.addEventListener('click', this.handleDocumentClick.bind(this), true);
        // IMPORTANT: Use a separate bound function for the document keydown
        // so we can remove the exact same listener later
        this.boundHandleKeyDown = this.handleKeyDown.bind(this);
        document.addEventListener('keydown', this.boundHandleKeyDown, true);
        if (globals_1.globals.notebookTracker) {
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            globals_1.globals.notebookTracker.currentChanged.connect((sender, notebook) => {
                this.currentNotebook = notebook;
            });
        }
    }
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);
        // Remove using the exact same bound function
        document.removeEventListener('keydown', this.boundHandleKeyDown, true);
        // Remove from widgetNode if attached
        if (this.popupMenuContainer.parentNode === this.widgetNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
    handleDocumentClick(event) {
        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');
            if (atButton && atButton.contains(event.target)) {
                console.log('POPUP: Click was on the @ button, not hiding.');
                return;
            }
            console.log('POPUP: Click detected outside the menu.');
            this.hidePopupMenu();
        }
    }
    async showPopupMenu(trigger) {
        let anchorX;
        let anchorY;
        if (trigger instanceof HTMLElement) {
            const rect = trigger.getBoundingClientRect();
            anchorX = rect.left; // Use button's top-left for anchor
            anchorY = rect.top;
            console.log(`POPUP: Showing menu triggered by element at (${anchorX}, ${anchorY})`);
        }
        else {
            anchorX = trigger.x;
            anchorY = trigger.y;
            console.log(`POPUP: Showing menu triggered by coordinates at (${anchorX}, ${anchorY})`);
        }
        // Store the calculated anchor point for positioning
        this._anchorX = anchorX;
        this._anchorY = anchorY;
        if (this.popupMenuContainer.style.display === 'none') {
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
            this.searchInput.value = ''; // Clear search on show
            this.lastSearchTerm = ''; // Reset last search term
            await this.setCurrentDirectoryPath();
        }
        await this.renderMenuContent();
        // Ensure it's attached to the widget node if somehow detached
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Add keydown listener when showing
        document.addEventListener('keydown', this.boundHandleKeyDown, true);
        // Position the popup menu - DEFER calculation slightly
        setTimeout(() => {
            console.log("POPUP: Deferred updatePopupPosition call.");
            try {
                this.updatePopupPosition();
            }
            catch (error) {
                console.error("POPUP: Error during deferred updatePopupPosition:", error);
            }
            // Focus the search input *after* positioning if in file/dir view
            // Otherwise, focus first menu item
            if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                this.searchInput.focus();
                console.log('POPUP: Focused search input after deferred positioning.');
                this.selectedMenuItemIndex = -1; // Don't select an item if search is focused
            }
            else { // Top level or cells
                this.selectedMenuItemIndex = -1;
                this.selectNextMenuItem(); // Select first item
                console.log('POPUP: Selected first menu item');
            }
        }, 0); // 0ms delay is usually sufficient
    }
    hidePopupMenu() {
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding menu. Called from:', new Error().stack);
            this.popupMenuContainer.style.display = 'none';
            this.currentMenuLevel = 'top'; // Reset level
            // Remove keydown listener when hiding
            document.removeEventListener('keydown', this.boundHandleKeyDown, true);
            console.log("POPUP: Removed keydown listener.");
            // Clear anchors
            this._anchorX = undefined;
            this._anchorY = undefined;
        }
    }
    async renderMenuContent() {
        // Prevent recursive renders
        if (this.isRenderingContent) {
            console.log('POPUP: Skipping render - already rendering');
            return;
        }
        this.isRenderingContent = true;
        try {
            // Clear existing content
            while (this.popupMenuContainer.firstChild) {
                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);
            }
            // Only add search input if NOT at top level
            if (this.currentMenuLevel !== 'top') {
                // Add search input at the top of the menu
                this.popupMenuContainer.appendChild(this.searchInput);
                this.searchInput.value = ''; // Clear for file/dir/cell levels
                this.lastSearchTerm = '';
            }
            // Render different menu content based on current level
            switch (this.currentMenuLevel) {
                case 'top':
                    this.renderTopLevelItems();
                    break;
                case 'files':
                case 'directories':
                    await this.renderDirectoryBrowserItems();
                    break;
                case 'cells':
                    await this.renderCellItems();
                    break;
            }
            // Reset selection after rendering
            this.selectedMenuItemIndex = -1;
            this.updateSelectionHighlight();
            // Update the position (might have changed due to content rendering)
            console.log("POPUP: ===> About to call updatePopupPosition after renderMenuContent");
            try {
                this.updatePopupPosition();
            }
            catch (err) {
                console.error("POPUP: Error calling updatePopupPosition after render:", err);
            }
        }
        catch (error) {
            console.error('POPUP: Error rendering menu content', error);
        }
        finally {
            this.isRenderingContent = false;
        }
    }
    renderTopLevelItems() {
        const topLevelCommands = [
            { label: 'Code', description: '', actionId: 'insert-code' },
            { label: 'Cells', description: '', actionId: 'browse-cells' },
            { label: 'File', description: '', actionId: 'browse-files' },
            { label: 'Directory', description: '', actionId: 'browse-directories' }
        ];
        topLevelCommands.forEach(cmd => {
            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);
            this.popupMenuContainer.appendChild(item);
        });
    }
    async renderDirectoryBrowserItems() {
        var _a;
        // Get search term
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        // Temporarily add loading item below search/path
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // If contents were already fetched recently and we're just filtering again,
            // we could potentially cache the results to avoid unnecessary API calls
            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';
            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);
            // Check if still in DOM before trying to remove
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (contents && contents.length > 0) {
                // Filter based on search term
                const filteredContents = contents.filter(item => {
                    return item.name.toLowerCase().includes(searchTerm) ||
                        item.relativePath.toLowerCase().includes(searchTerm);
                });
                if (filteredContents.length > 0) {
                    filteredContents.forEach(item => {
                        const itemName = item.name;
                        const itemType = item.type;
                        const itemPath = item.path;
                        const relativePath = item.relativePath;
                        const icon = itemType === 'directory' ? '📁' : '📄';
                        let actionId;
                        if (itemType === 'directory') {
                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';
                        }
                        else { // itemType === 'file'
                            actionId = 'select-file';
                        }
                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                }
                else {
                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');
                    emptyItem.style.pointerEvents = 'none';
                    this.popupMenuContainer.appendChild(emptyItem);
                }
            }
            else {
                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
            }
        }
        catch (error) {
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading/filtering directory contents:', error);
        }
    }
    /**
     * Renders all cells from the current notebook
     */
    async renderCellItems() {
        var _a, _b;
        // Get search term for filtering
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        // Create a loading indicator
        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // Check if we have an active notebook
            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {
                // Remove loading item
                if (this.popupMenuContainer.contains(loadingItem)) {
                    this.popupMenuContainer.removeChild(loadingItem);
                }
                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');
                errorItem.style.color = 'red';
                errorItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(errorItem);
                return;
            }
            const notebookModel = this.currentNotebook.content.model;
            const cells = notebookModel.cells;
            // Remove loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (!cells || cells.length === 0) {
                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
                return;
            }
            // Process and display each cell
            let filteredCellCount = 0;
            for (let i = 0; i < cells.length; i++) {
                const cell = cells.get(i);
                const cellType = cell.type;
                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :
                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');
                // Use type casting to avoid TypeScript errors
                const executionCount = cellType === 'code' ?
                    (cell.executionCount !== undefined && cell.executionCount !== null ?
                        cell.executionCount : '*') :
                    '';
                // Create a preview of the cell content (truncate if needed)
                const contentPreview = typeof cellContent === 'string' ?
                    cellContent :
                    (Array.isArray(cellContent) ? cellContent.join('\n') : '');
                const firstLine = contentPreview.split('\n')[0] || '';
                const truncatedContent = firstLine.length > 30 ?
                    firstLine.substring(0, 30) + '...' :
                    firstLine;
                // Create cell label with styled type indicator
                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';
                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';
                // Create menu item for this cell
                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML
                'select-cell', i.toString() // Store cell index in path
                );
                // Create styled content with HTML elements
                const typeSpan = document.createElement('span');
                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;
                typeSpan.textContent = typeIndicator;
                const execSpan = document.createElement('span');
                execSpan.className = 'cell-exec-count';
                execSpan.textContent = executionDisplay;
                execSpan.style.marginRight = '8px';
                const contentSpan = document.createElement('span');
                contentSpan.className = 'cell-content-preview';
                contentSpan.textContent = truncatedContent;
                // Get the label span (first child of the menu item)
                const labelSpan = cellItem.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = ''; // Clear existing text
                    labelSpan.appendChild(typeSpan);
                    if (executionDisplay) {
                        labelSpan.appendChild(execSpan);
                    }
                    labelSpan.appendChild(contentSpan);
                }
                // Construct full searchable text
                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();
                // Filter by search term if one is provided
                if (searchTerm && !searchableText.includes(searchTerm)) {
                    continue;
                }
                this.popupMenuContainer.appendChild(cellItem);
                filteredCellCount++;
            }
            if (filteredCellCount === 0) {
                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');
                noMatchItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(noMatchItem);
            }
        }
        catch (error) {
            // Clean up loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading notebook cells:', error);
        }
    }
    createMenuItem(text, actionId, path = '', description = '') {
        const item = document.createElement('div');
        item.className = 'jp-llm-ext-popup-menu-item';
        item.dataset.actionId = actionId;
        if (path) {
            item.dataset.path = path;
        }
        // Add mouse events to coordinate with keyboard navigation
        item.onmouseover = () => {
            // Find index of this item
            const menuItems = this.getMenuItems();
            const index = menuItems.indexOf(item);
            if (index !== -1) {
                this.selectedMenuItemIndex = index;
                this.updateSelectionHighlight();
            }
        };
        item.onclick = (event) => this.handleMenuClick(event);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = text;
        item.appendChild(labelSpan);
        if (description) {
            const pathSpan = document.createElement('span');
            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';
            pathSpan.textContent = description;
            pathSpan.style.fontSize = '0.85em';
            pathSpan.style.color = 'var(--jp-ui-font-color2)';
            pathSpan.style.marginLeft = '8px';
            pathSpan.style.opacity = '0.8';
            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed
            item.appendChild(pathSpan);
        }
        return item;
    }
    async handleMenuClick(event) {
        var _a;
        const target = event.currentTarget;
        const actionId = target.dataset.actionId;
        const path = target.dataset.path || '';
        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);
        switch (actionId) {
            case 'navigate-back':
                this.navigateBackMenu();
                break;
            case 'insert-code': {
                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;
                if (selectedText) {
                    // Show submenu for code insertion options
                    const submenuItems = [
                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },
                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }
                    ];
                    // Replace current menu with submenu options
                    this.popupMenuContainer.innerHTML = '';
                    submenuItems.forEach(item => {
                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                    // Add back button
                    const backButton = this.createMenuItem('Back', 'navigate-back');
                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';
                    this.popupMenuContainer.appendChild(backButton);
                    return; // Don't hide menu, wait for submenu selection
                }
                else {
                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                    if (cellContent) {
                        this.callbacks.insertCode(cellContent);
                    }
                }
                this.hidePopupMenu();
                break;
            }
            case 'insert-plain-code': {
                if (path) {
                    this.callbacks.insertCode(path);
                    this.hidePopupMenu();
                }
                break;
            }
            case 'collapse-code-ref': {
                if (path && this.currentNotebook) {
                    try {
                        // Get notebook file name (without extension)
                        const notebookPath = this.currentNotebook.context.path;
                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';
                        // Find current cell index and approximate line number
                        const currentCell = this.currentNotebook.content.activeCell;
                        if (!currentCell) {
                            throw new Error('No active cell found');
                        }
                        // Get current cell index
                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;
                        // Estimate line number from cursor position
                        let lineNumber = 1; // Default to line 1
                        if (currentCell.editor) {
                            const editor = currentCell.editor;
                            const cursor = editor.getCursorPosition();
                            if (cursor) {
                                lineNumber = cursor.line + 1; // Convert to 1-indexed
                            }
                        }
                        // Invoke the callback with all the information needed
                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);
                        this.hidePopupMenu();
                    }
                    catch (error) {
                        console.error('Error creating collapsed code reference:', error);
                        // Fallback to inserting code directly
                        this.callbacks.insertCode(path);
                        this.hidePopupMenu();
                    }
                }
                else {
                    // If something went wrong or no path provided, just insert as regular code
                    if (path) {
                        this.callbacks.insertCode(path);
                    }
                    this.hidePopupMenu();
                }
                break;
            }
            case 'browse-cells':
                await this.navigateMenu('cells', '');
                this.searchInput.value = '';
                break;
            case 'browse-files':
                await this.navigateMenu('files', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'browse-directories':
                await this.navigateMenu('directories', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'select-cell':
                if (path) {
                    const cellIndex = parseInt(path);
                    if (!isNaN(cellIndex)) {
                        // Construct the reference text (e.g., "@Cell 3")
                        // const refText = `@Cell ${cellIndex + 1}`; // Use 1-based index for display
                        // console.log("TODO: Implement cell reference insertion: ", refText);
                        this.callbacks.insertCellByIndex(cellIndex); // Call the appropriate callback
                        this.hidePopupMenu();
                    }
                    else {
                        console.error('POPUP: Invalid cell index.');
                    }
                }
                else {
                    console.error('POPUP: Cell selected but index (path) is missing.');
                }
                break;
            case 'select-file':
                if (path) {
                    // Construct the reference text (e.g., "@file path/to/file.py")
                    // const refText = `@file ${path}`;
                    // console.log("TODO: Implement file reference insertion: ", refText);
                    this.callbacks.handleInsertFileWidget(path); // NEW: Call widget insertion callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: File selected but path is missing.');
                }
                break;
            case 'select-directory':
                if (path) {
                    this.callbacks.handleInsertDirWidget(path); // NEW: Call widget insertion callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected but path is missing.');
                }
                break;
            case 'select-directory-navigate': // New action to navigate into dir when in file view
                if (path) {
                    // Clear the file cache for the specific directory to force a refresh
                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;
                    this.fileCache.delete(cacheKey);
                    // Make sure we're passing the correct level type
                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?
                        this.currentMenuLevel : 'files';
                    await this.navigateMenu(level, path);
                    this.searchInput.value = ''; // Clear search on navigation
                }
                else {
                    console.error('POPUP: Directory selected for navigation but path is missing.');
                }
                break;
            case 'select-directory-callback': // New action to select dir when in directory view
                if (path) {
                    // Construct the reference text (e.g., "@dir path/to/directory")
                    // const refText = `@dir ${path}`;
                    // console.log("TODO: Implement directory reference insertion: ", refText);
                    this.callbacks.handleInsertDirWidget(path); // Corrected to use the new widget insertion callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected for callback but path is missing.');
                }
                break;
            case 'placeholder-action':
                console.log('Placeholder action triggered.');
                this.hidePopupMenu();
                break;
            case 'loading':
            case 'empty':
            case 'error':
                break;
            default:
                console.log('POPUP: Unknown menu action:', actionId);
                this.hidePopupMenu();
                break;
        }
        event.stopPropagation();
    }
    async navigateMenu(level, path) {
        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);
        // Only push history if we are actually moving to a new state
        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {
            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
        }
        this.currentMenuLevel = level;
        this.currentMenuPath = path;
        // Don't clear search on programmatic navigation (like back button)
        // this.searchInput.value = ''; // Maybe keep search term?
        await this.renderMenuContent();
        // Focus search input after navigating to file/dir view
        if (level === 'files' || level === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0);
            this.selectedMenuItemIndex = -1; // Reset selection
        }
        else {
            // Select first item if navigating back to top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 0);
        }
    }
    navigateBackMenu() {
        const previousState = this.menuHistory.pop();
        if (previousState) {
            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);
            this.currentMenuLevel = previousState.level;
            this.currentMenuPath = previousState.path;
            // Don't clear search on back navigation
            this.renderMenuContent().then(() => {
                // Focus search input if going back to file/dir view
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    setTimeout(() => {
                        this.searchInput.focus();
                        // Move cursor to end of input text
                        const length = this.searchInput.value.length;
                        this.searchInput.setSelectionRange(length, length);
                    }, 0);
                    this.selectedMenuItemIndex = -1; // Reset selection
                }
                else {
                    // Select first item if going back to top level
                    this.selectedMenuItemIndex = -1;
                    setTimeout(() => this.selectNextMenuItem(), 0);
                }
            });
        }
        else {
            console.log('POPUP: Already at the top level.');
            this.hidePopupMenu();
        }
    }
    async listCurrentDirectoryContents(basePath, filterType) {
        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);
        // Check cache first
        const cacheKey = `${basePath}:${filterType || 'all'}`;
        if (this.fileCache.has(cacheKey)) {
            console.log('POPUP: Using cached directory contents');
            return this.fileCache.get(cacheKey) || null;
        }
        try {
            const effectivePath = basePath === '/' ? '' : basePath;
            // Ensure trailing slash removed for consistency unless it's root
            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;
            // Result array that will hold all files and directories
            let allResults = [];
            // Get the base directory contents (non-recursive)
            const baseContents = await this.docManager.services.contents.get(pathForApi || '');
            if (baseContents.type !== 'directory') {
                console.error('Path is not a directory:', basePath);
                return null;
            }
            // Process base directory items
            for (const item of baseContents.content) {
                const itemType = item.type === 'directory' ? 'directory' : 'file';
                // Add directories if we're listing directories or both
                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {
                    allResults.push({
                        name: item.name,
                        path: item.path,
                        type: 'directory',
                        relativePath: `./${item.name}`
                    });
                }
                // Add files if we're listing files and the extension is allowed
                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {
                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();
                    if (this.allowedExtensions.includes(fileExt)) {
                        allResults.push({
                            name: item.name,
                            path: item.path,
                            type: 'file',
                            relativePath: `./${item.name}`
                        });
                    }
                }
            }
            // Sort the results appropriately
            allResults = allResults.sort((a, b) => {
                // If listing directories only, sort alphabetically
                if (filterType === 'directory') {
                    return a.name.localeCompare(b.name);
                }
                // If listing files only, sort alphabetically
                if (filterType === 'file') {
                    return a.name.localeCompare(b.name);
                }
                // If listing both, sort directories first, then files alphabetically
                if (a.type === 'directory' && b.type !== 'directory')
                    return -1;
                if (a.type !== 'directory' && b.type === 'directory')
                    return 1;
                return a.name.localeCompare(b.name);
            });
            // Cache the results for future use
            this.fileCache.set(cacheKey, allResults);
            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);
            return allResults;
        }
        catch (error) {
            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);
            return null;
        }
    }
    async setCurrentDirectoryPath() {
        var _a;
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            this.currentMenuPath = '';
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                dirPath = this.getParentDirectory(path);
                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);
            }
        }
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            if (typeof notebookPath === 'string') {
                dirPath = this.getParentDirectory(notebookPath);
                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);
            }
        }
        if (dirPath === null) {
            try {
                const leftWidgets = Array.from(app.shell.widgets('left'));
                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
                if (fileBrowserWidget && typeof ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path) === 'string') {
                    dirPath = fileBrowserWidget.model.path;
                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);
                }
                else {
                    console.log('POPUP: File browser widget path not directly accessible.');
                }
            }
            catch (e) {
                console.warn('POPUP: Could not get path from file browser.', e);
            }
        }
        if (dirPath === null) {
            dirPath = '';
            console.log('POPUP: Falling back to server root path.');
        }
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);
    }
    getParentDirectory(path) {
        if (!path)
            return '';
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
        if (lastSlash === -1)
            return ''; // No directory part, likely root or just a filename
        return path.substring(0, lastSlash);
    }
    /**
     * Handle keyboard navigation when the popup menu is shown
     */
    handleKeyDown(event) {
        if (this.popupMenuContainer.style.display === 'none')
            return;
        console.log(`POPUP (Document): KeyDown intercepted. Key='${event.key}'`);
        // Prioritize search input if focused
        if (document.activeElement === this.searchInput) {
            console.log('POPUP (Document): KeyDown - Search input is focused, letting it handle.');
            // Handle Tab and arrow keys specifically to move focus out of search
            if (event.key === 'Tab' || event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                console.log(`POPUP (Document): Key='${event.key}' in search input - moving focus.`);
                // Instead of blurring, let's handle arrows directly in the input
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    const direction = event.key === 'ArrowDown' ? 1 : -1;
                    const menuItems = this.getMenuItems();
                    // If no items selected yet, select first/last based on direction
                    if (this.selectedMenuItemIndex < 0) {
                        this.selectedMenuItemIndex = direction > 0 ? 0 : menuItems.length - 1;
                    }
                    else {
                        // Move selection in specified direction
                        this.selectedMenuItemIndex =
                            (this.selectedMenuItemIndex + direction + menuItems.length) % menuItems.length;
                    }
                    this.updateSelectionHighlight();
                    // Keep search input focused
                    this.searchInput.focus();
                }
                else if (event.key === 'Tab') {
                    // Tab should select next item but keep search focused
                    this.selectNextMenuItem();
                    this.searchInput.focus();
                }
                event.preventDefault(); // Prevent default Tab behavior
                event.stopPropagation();
                return;
            }
            // Let other keys (like Escape, Enter) be handled by the search input's own listener
            return;
        }
        // Handle navigation if search is not focused
        if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
            console.log('POPUP (Document): Handling navigation key:', event.key);
            event.preventDefault();
            event.stopPropagation();
            this.processMenuNavigation(event.key);
        }
        else {
            // If typing characters and NOT in search input, focus search and add the character
            if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories' || this.currentMenuLevel === 'cells') {
                if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    console.log('POPUP (Document): Focusing search input due to character typed.');
                    this.searchInput.focus();
                    // Append the typed character to search input if it's a printable character
                    if (event.key.match(/^[\w\d\s.,\-_=+;:'"\[\]{}()*&^%$#@!~`|\\/<>?]$/)) {
                        this.searchInput.value += event.key;
                        // Trigger search input's 'input' event to update filtering
                        this.searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
    }
    processMenuNavigation(key) {
        switch (key) {
            case 'ArrowDown':
                console.log('POPUP: Arrow Down pressed');
                this.selectNextMenuItem();
                break;
            case 'ArrowUp':
                console.log('POPUP: Arrow Up pressed');
                this.selectPreviousMenuItem();
                break;
            case 'Enter':
            case 'Tab': // Treat Tab like Enter for selection
                console.log(`POPUP: ${key} pressed`);
                if (this.selectedMenuItemIndex >= 0) {
                    const menuItems = this.getMenuItems();
                    if (this.selectedMenuItemIndex < menuItems.length) {
                        console.log('POPUP: Simulating click on selected item:', menuItems[this.selectedMenuItemIndex].textContent);
                        // Simulate click to trigger handleMenuClick
                        menuItems[this.selectedMenuItemIndex].click();
                    }
                    else {
                        console.log('POPUP: Selected index out of bounds?');
                    }
                }
                else {
                    console.log('POPUP: Enter/Tab pressed but no item selected');
                    // If no item is selected, select the first one and activate
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        this.selectedMenuItemIndex = 0;
                        this.updateSelectionHighlight();
                        // With Enter, always activate the newly selected item
                        if (key === 'Enter') {
                            menuItems[0].click(); // Activate first item
                        }
                    }
                }
                break;
            case 'Escape':
                console.log('POPUP: Escape pressed');
                // If in a submenu, navigate back; otherwise, hide.
                if (this.menuHistory.length > 0) {
                    this.navigateBackMenu();
                }
                else {
                    this.hidePopupMenu();
                }
                break;
        }
    }
    updateSelectionHighlight() {
        const menuItems = this.getMenuItems();
        // Handle out-of-bounds index
        if (this.selectedMenuItemIndex >= menuItems.length) {
            this.selectedMenuItemIndex = menuItems.length - 1;
        }
        menuItems.forEach((item, index) => {
            if (index === this.selectedMenuItemIndex) {
                item.classList.add('jp-llm-ext-popup-menu-item-selected');
                // Scroll into view if necessary
                item.scrollIntoView({ block: 'nearest' });
            }
            else {
                item.classList.remove('jp-llm-ext-popup-menu-item-selected');
            }
        });
    }
    deselectAllMenuItems() {
        const menuItems = this.getMenuItems();
        menuItems.forEach(item => {
            item.classList.remove('jp-llm-ext-popup-menu-item-selected');
        });
        this.selectedMenuItemIndex = -1;
    }
    selectNextMenuItem() {
        const menuItems = this.getMenuItems();
        if (menuItems.length === 0)
            return;
        this.selectedMenuItemIndex++;
        if (this.selectedMenuItemIndex >= menuItems.length) {
            this.selectedMenuItemIndex = 0; // Wrap around
        }
        this.updateSelectionHighlight();
        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);
    }
    selectPreviousMenuItem() {
        const menuItems = this.getMenuItems();
        if (menuItems.length === 0)
            return;
        this.selectedMenuItemIndex--;
        if (this.selectedMenuItemIndex < 0) {
            this.selectedMenuItemIndex = menuItems.length - 1; // Wrap around
        }
        this.updateSelectionHighlight();
        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);
    }
    /**
     * Get all interactive menu items currently displayed
     */
    getMenuItems() {
        return Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));
    }
    /**
     * Updates the position of the popup menu based on the active reference range
     * or the initial anchor point. Tries to position the BOTTOM-LEFT corner of the menu
     * just AT THE TOP-LEFT corner of the range/anchor.
     */
    updatePopupPosition() {
        if (!this.widgetNode || this._anchorX === undefined || this._anchorY === undefined) {
            console.warn("POPUP: Cannot update position - missing widgetNode or anchor points.");
            return;
        }
        const widgetRect = this.widgetNode.getBoundingClientRect();
        // Target position is the viewport-relative anchor point
        const targetTop = this._anchorY;
        const targetLeft = this._anchorX;
        console.log(`POPUP: Positioning relative to anchor: (${targetLeft}, ${targetTop})`);
        // Make sure the popup is visible and rendered to get its dimensions
        // Use visibility to prevent flicker while measuring
        this.popupMenuContainer.style.visibility = 'hidden';
        this.popupMenuContainer.style.display = 'block';
        const popupHeight = this.popupMenuContainer.offsetHeight;
        const popupWidth = this.popupMenuContainer.offsetWidth;
        if (popupHeight === 0 || popupWidth === 0) {
            console.warn("POPUP: Cannot update position - popup dimensions are zero.");
            this.popupMenuContainer.style.display = 'none'; // Hide if dimensions are invalid
            return;
        }
        // Calculate desired viewport coordinates for popup's top-left
        // Goal: popup bottom-left = anchor top-left
        // popup top = anchor top - popup height
        // popup left = anchor left
        let desiredTop = targetTop - popupHeight;
        let desiredLeft = targetLeft;
        // --- Viewport Boundary checks ---
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // Prevent going off the left viewport edge
        if (desiredLeft < 0) {
            desiredLeft = 5; // Small padding
            console.log("POPUP Viewport Adjust: Corrected left edge");
        }
        // Prevent going off the right viewport edge
        if (desiredLeft + popupWidth > viewportWidth) {
            desiredLeft = viewportWidth - popupWidth - 5; // Adjust left, add padding
            console.log("POPUP Viewport Adjust: Corrected right edge");
        }
        // Prevent going off the top viewport edge
        if (desiredTop < 0) {
            // If it goes off the top, try positioning it *below* the anchor instead
            // Goal: popup top-left = anchor bottom-left
            const desiredTopBelow = targetTop + 5; // Add small gap
            if (desiredTopBelow + popupHeight <= viewportHeight) {
                desiredTop = desiredTopBelow;
                console.log("POPUP Viewport Adjust: Flipping below anchor (was off top)");
            }
            else {
                // Not enough space below either, clamp to top of viewport
                desiredTop = 5; // Small padding from top
                console.log("POPUP Viewport Adjust: Clamped to top edge (no space below)");
            }
        }
        // Note: No check for bottom edge needed if we prioritize positioning above or clamping to top.
        // --- Convert viewport coordinates to style relative to widgetNode ---
        const styleTop = desiredTop - widgetRect.top;
        const styleLeft = desiredLeft - widgetRect.left;
        console.log(`POPUP: Setting position - Top: ${styleTop}px, Left: ${styleLeft}px (Relative to Widget)`);
        this.popupMenuContainer.style.top = `${styleTop}px`;
        this.popupMenuContainer.style.left = `${styleLeft}px`;
        // Make it visible again
        this.popupMenuContainer.style.display = 'block';
        this.popupMenuContainer.style.visibility = 'visible';
    }
    /**
     * Checks if the popup menu is currently visible.
     */
    isPopupMenuVisible() {
        return this.popupMenuContainer.style.display !== 'none';
    }
    /**
     * Gets the current level of the popup menu.
     */
    getCurrentMenuLevel() {
        return this.currentMenuLevel;
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsHandler = void 0;
/**
 * Handles the logic related to the settings modal:
 * displaying, hiding, populating, saving, and showing feedback.
 */
class SettingsHandler {
    constructor(state, settingsModalContainer, uiManager // Pass UIManager for notifications
    ) {
        this.state = state;
        this.settingsModalContainer = settingsModalContainer;
        this.uiManager = uiManager;
    }
    /**
     * Populates the settings form with current values and displays the modal.
     */
    showModal() {
        const currentSettings = this.state.getSettings();
        if (currentSettings) {
            try {
                // Query elements within the modal container
                this.settingsModalContainer.querySelector('#settings-provider').value = currentSettings.provider;
                this.settingsModalContainer.querySelector('#settings-api-key').value = currentSettings.apiKey;
                this.settingsModalContainer.querySelector('#settings-api-url').value = currentSettings.apiUrl;
                this.settingsModalContainer.querySelector('#settings-rules').value = currentSettings.rules;
            }
            catch (error) {
                console.error('Error populating settings form:', error);
                // Optionally show an error to the user
            }
        }
        this.settingsModalContainer.style.display = 'flex';
    }
    /**
     * Hides the settings modal.
     */
    hideModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    /**
     * Reads values from the form, saves them using SettingsState,
     * updates the ApiClient, hides the modal, and shows a success notification.
     * This method is intended to be called by the modal's save button listener.
     */
    saveSettings() {
        var _a, _b, _c, _d;
        // Get values from form fields within the modal container
        const provider = (_a = this.settingsModalContainer.querySelector('#settings-provider')) === null || _a === void 0 ? void 0 : _a.value;
        const key = (_b = this.settingsModalContainer.querySelector('#settings-api-key')) === null || _b === void 0 ? void 0 : _b.value;
        const url = (_c = this.settingsModalContainer.querySelector('#settings-api-url')) === null || _c === void 0 ? void 0 : _c.value;
        const rules = (_d = this.settingsModalContainer.querySelector('#settings-rules')) === null || _d === void 0 ? void 0 : _d.value;
        // Basic validation
        if (provider === undefined || key === undefined || url === undefined || rules === undefined) {
            console.error("Could not find all settings input elements.");
            this.showNotification('Error: Could not save settings. Input elements missing.', 'error');
            return;
        }
        const settings = { provider, apiKey: key, apiUrl: url, rules };
        try {
            // Save settings using SettingsState
            this.state.saveSettings(settings);
            console.log('Settings saved via SettingsState:', settings);
            // Reconfigure ApiClient instance
            // TODO: The ApiClient should ideally observe the SettingsState 
            // or have a dedicated update method instead of creating a new instance.
            // For now, we assume the main widget will recreate/update the ApiClient 
            // or pass an update callback.
            // Example: this.apiClient.updateConfig(settings.apiUrl || undefined);
            console.log('API Client needs reconfiguration with new settings.');
            this.hideModal();
            this.showNotification('Settings saved successfully', 'success');
        }
        catch (error) {
            console.error('Error saving settings:', error);
            this.showNotification(`Error saving settings: ${error}`, 'error');
        }
    }
    /**
     * Displays a temporary notification message.
     * Relies on UIManager to provide the actual notification mechanism.
     */
    showNotification(message, type) {
        // Delegate notification display to UIManager or a dedicated notification service
        if (this.uiManager && typeof this.uiManager.showNotification === 'function') {
            this.uiManager.showNotification(message, type);
        }
        else {
            // Fallback or log if UIManager doesn't support notifications yet
            console.log(`Notification (${type}): ${message}`);
            // The old popSaveSuccess logic requires direct access to the widget node,
            // which this handler shouldn't have. This needs to be handled by the UI layer.
        }
    }
}
exports.SettingsHandler = SettingsHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupShortcuts = setupShortcuts;
exports.removeShortcuts = removeShortcuts;
const notebook_integration_1 = __webpack_require__(/*! ../utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js"); // Import globals to get cell index etc.
let _handleKeyDown = null;
/**
 * Sets up global keyboard shortcuts for the extension.
 *
 * @param inputHandler Instance of InputHandler to interact with input state/methods.
 * @param popupMenuManager Instance of PopupMenuManager.
 * @param callbacks Object containing callback functions for UI interactions.
 */
function setupShortcuts(inputHandler, // Pass InputHandler instance directly
popupMenuManager, callbacks) {
    if (_handleKeyDown) {
        console.warn('Shortcuts already set up. Removing previous listener.');
        removeShortcuts();
    }
    _handleKeyDown = (event) => {
        var _a, _b, _c;
        const { showIndicator, appendToInput, showWidget, focusInput } = callbacks;
        // Check for @ key - event.key should correctly report '@' even with Shift
        // Also check for SHIFT+2 as an alternative way to trigger '@'
        if (event.key === '@' || (event.shiftKey && event.key === '2')) {
            console.log("SHORTCUT HANDLER: '@' key or SHIFT+2 detected");
            const inputField = document.activeElement;
            const isContentEditableInput = inputField &&
                inputField.getAttribute('contenteditable') === 'true' &&
                inputField.classList.contains('jp-llm-ext-input-field');
            // Handle the case where the input field is NOT the active element first
            if (isContentEditableInput) { // Only handle if NOT our input field
                console.log("SHORTCUT HANDLER: Input field is NOT active element. Handling '@' globally.");
                // If not in our input field, prevent default, show widget, focus, insert '@', and show popup.
                event.preventDefault();
                event.stopPropagation();
                showWidget();
                focusInput();
                // After focus, show popup via window.setTimeout to ensure input is ready
                window.setTimeout(() => {
                    const inputElement = document.querySelector('.jp-llm-ext-input-field');
                    if (inputElement) {
                        const selection = window.getSelection();
                        if (selection) { // Check if selection exists (even if rangeCount is 0 initially)
                            // Ensure the input field has focus *before* manipulating the range
                            if (document.activeElement !== inputElement) {
                                inputElement.focus(); // Re-focus just in case
                            }
                            // Create or get the range
                            let range;
                            if (selection.rangeCount > 0) {
                                range = selection.getRangeAt(0);
                                // Double-check if the focus is now correctly inside the input element
                                if (!inputElement.contains(range.commonAncestorContainer)) {
                                    console.log("SHORTCUT HANDLER: Range is not inside the input field after focus. Creating new range.");
                                    // If range is not inside, create a new one collapsed at the end
                                    range = document.createRange();
                                    range.selectNodeContents(inputElement);
                                    range.collapse(false); // Collapse to the end
                                    selection.removeAllRanges();
                                    selection.addRange(range);
                                }
                            }
                            else {
                                // If no range exists, create one collapsed at the end
                                console.log("SHORTCUT HANDLER: No range found after focus. Creating new range.");
                                range = document.createRange();
                                range.selectNodeContents(inputElement);
                                range.collapse(false); // Collapse to the end
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                            // Manually insert '@' since we prevented default
                            const atNode = document.createTextNode('@');
                            range.deleteContents(); // Clear any selection just in case
                            range.insertNode(atNode);
                            // Move cursor after the inserted '@'
                            range.setStartAfter(atNode);
                            range.setEndAfter(atNode);
                            selection.removeAllRanges(); // Update selection to the new cursor position
                            selection.addRange(range);
                            // **NESTED TIMEOUT:** Give browser time to render before getting range position
                            window.setTimeout(() => {
                                console.log("SHORTCUT HANDLER: Showing popup after focusing, inserting '@', and nested timeout.");
                                // Ensure we get the most up-to-date range reference
                                const currentSelection = window.getSelection();
                                if (currentSelection && currentSelection.rangeCount > 0) {
                                    const currentRange = currentSelection.getRangeAt(0);
                                    // --- Insert temporary span to get reliable coords --- 
                                    const tempAnchorId = 'jp-llm-shortcut-popup-anchor';
                                    let tempSpan = document.getElementById(tempAnchorId);
                                    if (tempSpan)
                                        tempSpan.remove(); // Clean up previous
                                    tempSpan = document.createElement('span');
                                    tempSpan.id = tempAnchorId;
                                    tempSpan.style.visibility = 'hidden';
                                    tempSpan.style.width = '0';
                                    tempSpan.style.overflow = 'hidden';
                                    tempSpan.textContent = '\u200B'; // Zero-width space
                                    currentRange.insertNode(tempSpan); // Insert at cursor
                                    const spanRect = tempSpan.getBoundingClientRect();
                                    tempSpan.remove(); // Remove immediately
                                    // --- End temporary span logic ---
                                    if (spanRect.top === 0 && spanRect.left === 0) {
                                        console.error("SHORTCUT HANDLER: Failed to get valid coordinates from temp anchor span.");
                                    }
                                    else {
                                        console.log(`SHORTCUT HANDLER: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);
                                        popupMenuManager.showPopupMenu({ x: spanRect.left, y: spanRect.top });
                                        showIndicator('Browsing references...');
                                    }
                                }
                                else {
                                    console.error("SHORTCUT HANDLER: Could not get range immediately before showing popup.");
                                }
                            }, 0); // 0ms delay is often sufficient
                        }
                        else {
                            console.log("SHORTCUT HANDLER: No selection object after focus, cannot insert '@' or show popup reliably.");
                        }
                    }
                    else {
                        console.log("SHORTCUT HANDLER: Could not find input element after timeout.");
                    }
                }, 50); // Outer timeout remains 50ms
            }
            else {
                // Input field IS focused. Let default '@' insertion happen.
                // The 'input' listener in UIManager should handle the popup.
                console.log("SHORTCUT HANDLER: Input field IS active element. Letting default '@' behavior proceed.");
            }
        }
        // Check for Ctrl+L (insert selection or cell)
        else if (event.ctrlKey && event.key.toLowerCase() === 'l') {
            event.preventDefault();
            event.stopPropagation();
            const selected = (0, notebook_integration_1.getSelectedText)();
            // const cellContent = getCurrentCellContent(); // We don't need the content itself anymore
            const isCellFocused = (0, notebook_integration_1.isInNotebookCellAndEditorFocused)(); // If the cursor is in the editor mode
            const isCellSelected = (0, notebook_integration_1.isInNotebookCell)(); // If the cursor is in the notebook cell
            const activeCellIndex = (_c = (_b = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.activeCellIndex; // Get index
            let handled = false;
            // Priority 1: Selected text in an active cell editor
            if (isCellFocused && selected) {
                // Call the new InputHandler method to create the reference and insert its representation
                inputHandler.handleInsertCodeReferenceFromShortcut(selected);
                showIndicator('Code reference inserted'); // Updated indicator message
                handled = true;
                // Priority 2: Active cell selected (not necessarily editor focus)
            }
            else if (isCellSelected && activeCellIndex !== undefined && activeCellIndex !== null) {
                // Call the new InputHandler method to create the reference and insert its representation
                inputHandler.handleInsertCellReferenceFromShortcut();
                showIndicator('Cell reference inserted'); // Message remains the same
                handled = true;
            }
            else {
                // Invalid context for the shortcut
                showIndicator('Cannot insert reference: Select code or an active cell.');
                handled = true; // Still handled the shortcut, just showed a warning
            }
            // Ensure the sidebar is visible and input is focused only if an action was taken
            if (handled) {
                showWidget(); // Use callback
                focusInput(); // Use callback
            }
        }
    };
    // Add the event listener to the document
    document.addEventListener('keydown', _handleKeyDown);
}
/**
 * Removes the global keyboard shortcut listener.
 */
function removeShortcuts() {
    if (_handleKeyDown) {
        document.removeEventListener('keydown', _handleKeyDown);
        _handleKeyDown = null;
        console.log('Removed keyboard shortcuts.');
    }
    else {
        console.warn('Attempted to remove shortcuts, but none were active.');
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Import the main CSS file
__webpack_require__(/*! ../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./core/api-client */ "./node_modules/jupyter-simple-extension/lib/core/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const icons_1 = __webpack_require__(/*! ./core/icons */ "./node_modules/jupyter-simple-extension/lib/core/icons.js");
const api_client_1 = __webpack_require__(/*! ./core/api-client */ "./node_modules/jupyter-simple-extension/lib/core/api-client.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./handlers/popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js");
const shortcut_handler_1 = __webpack_require__(/*! ./handlers/shortcut-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js");
const layout_builder_1 = __webpack_require__(/*! ./ui/layout-builder */ "./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js");
const settings_modal_1 = __webpack_require__(/*! ./ui/settings-modal */ "./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js");
const chat_state_1 = __webpack_require__(/*! ./state/chat-state */ "./node_modules/jupyter-simple-extension/lib/state/chat-state.js");
const settings_state_1 = __webpack_require__(/*! ./state/settings-state */ "./node_modules/jupyter-simple-extension/lib/state/settings-state.js");
const input_handler_1 = __webpack_require__(/*! ./handlers/input-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/input-handler.js");
const message_handler_1 = __webpack_require__(/*! ./handlers/message-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js");
const history_handler_1 = __webpack_require__(/*! ./handlers/history-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js");
const settings_handler_1 = __webpack_require__(/*! ./handlers/settings-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js");
const ui_manager_1 = __webpack_require__(/*! ./ui/ui-manager */ "./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js");
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
const globals_1 = __webpack_require__(/*! ./core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
const note_state_1 = __webpack_require__(/*! ./state/note-state */ "./node_modules/jupyter-simple-extension/lib/state/note-state.js");
const note_handler_1 = __webpack_require__(/*! ./handlers/note-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/note-handler.js");
// --- Import Utility Functions ---
const clipboard_1 = __webpack_require__(/*! ./utils/clipboard */ "./node_modules/jupyter-simple-extension/lib/utils/clipboard.js");
const notebook_integration_1 = __webpack_require__(/*! ./utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
/**
 * Main sidebar widget for the AI chat interface - Now acts as an orchestrator.
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    /**
     * Helper function to replace a text range with a non-editable widget span.
     */
    createWidgetSpan(range, refText) {
        if (!range)
            return;
        // Extract a display-friendly version (e.g., filename from path)
        let displayLabel = refText;
        if (refText.startsWith('@file ') || refText.startsWith('@dir ')) {
            const parts = refText.split(' ');
            if (parts.length > 1) {
                const pathParts = parts[1].split(/[\\/]/);
                displayLabel = pathParts[pathParts.length - 1] || parts[1]; // Use last part of path or full path
            }
        }
        else if (refText.startsWith('@Cell ')) {
            displayLabel = refText.substring(1); // Remove leading '@'
        } // Add more conditions for other types if needed
        // Create the widget span
        const span = document.createElement('span');
        span.className = 'jp-llm-ext-ref-widget'; // Class for styling
        span.setAttribute('contenteditable', 'false'); // Make it non-editable
        span.setAttribute('data-ref-text', refText); // Store original text for serialization
        span.textContent = displayLabel; // Set visible text
        // Replace the range content with the span
        range.deleteContents();
        range.insertNode(span);
        // Move cursor after the inserted span
        const selection = window.getSelection();
        if (selection) {
            const newRange = document.createRange();
            newRange.setStartAfter(span);
            newRange.setEndAfter(span);
            selection.removeAllRanges();
            selection.addRange(newRange);
        }
    }
    constructor(docManager) {
        super();
        // Placeholder for handler methods used in UIManager callbacks
        this.handleNewChat = () => {
            var _a;
            console.log('Handle New Chat clicked');
            const newChat = this.chatState.createNewChat();
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);
        };
        this.handleToggleHistory = () => {
            console.log('Handle Toggle History clicked');
            this.historyHandler.toggleHistoryView();
        };
        this.handleToggleNotes = () => {
            console.log('Handle Toggle Notes clicked');
            this.noteHandler.toggleNotesView();
        };
        this.handleSendMessage = (message, isMarkdown = false) => {
            // 1. Get the current text from the input field via UIManager or LayoutElements
            // const text = this.layoutElements.inputField.value; // No longer needed, text is passed in
            if (!message.trim())
                return; // Don't send empty messages (check the passed message)
            console.log(`[Widget] handleSendMessage: Text='${message}', Markdown=${isMarkdown}`); // Debug log using passed message
            // 3. Call the MessageHandler's send method with text and state
            this.messageHandler.handleSendMessage(message, isMarkdown); // Pass the received message and markdown state
            // NOTE: Input clearing is now handled by UIManager after this callback returns.
            // Do NOT clear input here or in MessageHandler.
        };
        this.handleShowSettings = (event) => {
            console.log('Handle Show Settings clicked');
            this.settingsHandler.showModal();
        };
        this.handleShowPopupMenu = (event, targetButton) => {
            console.log('Handle Show Popup Menu clicked');
            const rect = targetButton.getBoundingClientRect();
            this.popupMenuManager.showPopupMenu({ x: rect.left, y: rect.bottom + 5 });
        };
        this.handleUpdateTitle = () => {
            var _a;
            const newTitle = ((_a = this.layoutElements.titleInput) === null || _a === void 0 ? void 0 : _a.value) || 'Chat';
            console.log('Handle Update Title called:', newTitle);
            this.chatState.updateCurrentChatTitle(newTitle);
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        this.addClass('jp-llm-ext-sidebar');
        // --- 1. Initialize Core Components & State ---
        this.settingsState = new settings_state_1.SettingsState();
        const initialSettings = this.settingsState.getSettings();
        this.apiClient = new api_client_1.ApiClient((initialSettings === null || initialSettings === void 0 ? void 0 : initialSettings.apiUrl) || undefined);
        this.chatState = new chat_state_1.ChatState();
        this.noteState = new note_state_1.NoteState();
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {
            insertCode: (code) => {
                var _a, _b, _c;
                if (!this.inputHandler || !globals_1.globals.notebookTracker)
                    return;
                const currentNotebookPanel = globals_1.globals.notebookTracker.currentWidget;
                if (!currentNotebookPanel || !currentNotebookPanel.context || !currentNotebookPanel.content) {
                    console.warn('Could not get notebook context for code reference, inserting raw code as fallback.');
                    (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(code);
                    return;
                }
                const notebookPath = currentNotebookPanel.context.path;
                const notebookName = ((_b = notebookPath.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';
                const currentCell = currentNotebookPanel.content.activeCell;
                if (!currentCell) {
                    console.warn('Could not get active cell for code reference, inserting raw code as fallback.');
                    (_c = this.inputHandler) === null || _c === void 0 ? void 0 : _c.appendToInput(code);
                    return;
                }
                const cellIndex = currentNotebookPanel.content.activeCellIndex;
                let lineNumber = 1; // Default line number
                let lineEndNumber = 1; // Default end line number
                // --- DEBUG LOG --- 
                console.log('Are we currently in a code cell?');
                // check if currentCell is in editor 
                console.log(currentCell.editor);
                // --- END DEBUG LOG ---
                if (currentCell.editor) {
                    const editor = currentCell.editor;
                    const cmEditor = editor.editor; // Access CodeMirror editor instance (EditorView)
                    if (cmEditor && cmEditor.state) {
                        const state = cmEditor.state;
                        const selection = state.selection.main;
                        if (!selection.empty) {
                            lineNumber = state.doc.lineAt(selection.from).number; // 1-based start line
                            lineEndNumber = state.doc.lineAt(selection.to).number; // 1-based end line
                        }
                        else {
                            // Fallback for cursor position if no selection
                            const cursor = editor.getCursorPosition();
                            if (cursor) {
                                lineNumber = cursor.line + 1; // 1-based line number
                                lineEndNumber = lineNumber; // Start and end are the same for cursor
                            }
                        }
                    }
                    else {
                        // Fallback if cmEditor or state is not available (should not happen often)
                        console.warn('Could not access CodeMirror state for line numbers.');
                        const cursor = editor.getCursorPosition();
                        if (cursor) {
                            lineNumber = cursor.line + 1;
                            lineEndNumber = lineNumber;
                        }
                    }
                }
                else {
                    console.warn('Could not access cell editor for line numbers.');
                    // Keep default line numbers 1, 1 if editor is not available
                }
                // --- DEBUG LOG --- 
                console.log(`[SimpleSidebarWidget.insertCode] Determined lines: Start=${lineNumber}, End=${lineEndNumber}`);
                // --- END DEBUG LOG ---
                // Pass both start and end line numbers
                const refId = this.inputHandler.addCodeReference(code, notebookName, cellIndex, lineNumber, lineEndNumber);
                const placeholder = `@code[${refId}]`;
                this.inputHandler.appendToInput(placeholder);
            },
            insertCell: (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@cell ${content}`); },
            handleInsertFileWidget: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.handleInsertFileWidget(path); },
            handleInsertDirWidget: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.handleInsertDirWidget(path); },
            getSelectedText: notebook_integration_1.getSelectedText,
            getCurrentCellContent: notebook_integration_1.getCurrentCellContent,
            insertCellByIndex: (index) => {
                var _a;
                (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.handleInsertCellWidgetFromPopup(index);
            },
            // TODO: insertCollapsedCodeRef should later be merged with insertCode
            // as we only expect one kind of behavior from the input handler.
            // this change will also involve ui changes
            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {
                if (!this.inputHandler)
                    return;
                this.inputHandler.handleInsertCodeWidgetFromPopup(code, notebookName, cellIndex, lineNumber);
            }
        });
        // --- 2. Define Callbacks (used by buildLayout and Handlers) ---
        // Callbacks for UI actions (passed to buildLayout)
        const createNewChatCallback = () => {
            var _a;
            const newChat = this.chatState.createNewChat();
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);
        };
        const toggleHistoryCallback = () => {
            var _a;
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.toggleHistoryView();
        };
        const toggleNotesCallback = () => {
            this.noteHandler.toggleNotesView();
        };
        const showSettingsCallback = () => {
            var _a;
            (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.showModal();
        };
        const showPopupMenuCallback = (event) => {
            const rect = event.target.getBoundingClientRect();
            this.popupMenuManager.showPopupMenu({ x: rect.left + 60, y: rect.top - 20 });
            event.preventDefault();
            event.stopPropagation();
        };
        const sendMessageViaButtonCallback = () => {
            const inputElement = this.layoutElements.inputField;
            const event = new KeyboardEvent('keypress', { key: 'Enter', bubbles: true });
            inputElement.dispatchEvent(event);
        };
        const toggleMarkdownModeCallback = (isMarkdown) => {
            var _a;
            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.setMarkdownMode(isMarkdown);
        };
        const toggleExpandInputCallback = (button) => {
            var _a;
            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.toggleInputExpansion();
        };
        // Callbacks for Message Rendering (passed to MessageHandler -> UIManager -> renderers)
        const messageRendererCallbacks = {
            showCopyFeedback: (button, success = true) => {
                const originalHTML = button.innerHTML;
                button.innerHTML = success ? 'Copied!' : 'Failed!';
                button.disabled = true;
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.disabled = false;
                }, 1000);
            },
            addMessageToCell: notebook_integration_1.addMessageToCell,
            copyToClipboard: (text, feedbackCb) => {
                navigator.clipboard.writeText(text).then(() => feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb()).catch(err => {
                    console.error('Failed to copy text: ', err);
                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();
                });
            },
            copyImageToClipboard: (imageUrl, feedbackCb) => {
                (0, clipboard_1.copyImageToClipboard)(imageUrl, (success) => {
                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();
                });
            },
            copyMessageToClipboard: (text, feedbackCb) => {
                (0, clipboard_1.copyMessageToClipboard)(text, (success) => {
                    feedbackCb();
                });
            },
            handleConfirmInterrupt: () => {
                var _a;
                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('confirmed');
            },
            handleRejectInterrupt: () => {
                var _a;
                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('rejected');
            }
        };
        const settingsModalCallbacks = {
            handleSave: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.saveSettings(); },
            handleCancel: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.hideModal(); }
        };
        const historyHandlerCallbacks = {
            updateTitleInput: (title) => this.uiManager.updateTitleInput(title),
            clearMessageContainer: () => this.uiManager.clearMessageContainer(),
            addRenderedMessage: (messageElement) => this.uiManager.addChatMessageElement(messageElement)
        };
        const noteHandlerCallbacks = {
            updateTitleInput: (title) => this.uiManager.updateTitleInput(title)
        };
        const inputHandlerCallbacks = {
            handleSendMessage: (message, isMarkdown) => {
                if (this.messageHandler) {
                    this.messageHandler.handleSendMessage(message, isMarkdown);
                }
                else {
                    console.error('MessageHandler not initialized when trying to send message from InputHandler');
                }
            },
            showPopupMenu: (left, top) => this.popupMenuManager.showPopupMenu({ x: left, y: top }),
            hidePopupMenu: () => this.popupMenuManager.hidePopupMenu(),
            updatePlaceholder: (isMarkdown) => {
                // Use dataset for data-placeholder attribute
                this.layoutElements.inputField.dataset.placeholder = isMarkdown ? 'Enter markdown...' : 'Ask anything...';
            },
            toggleInputExpansionUI: (isExpanded) => {
                const button = this.layoutElements.expandButton;
                // Clear existing content (text or old icon)
                while (button.firstChild) {
                    button.removeChild(button.firstChild);
                }
                // Add the appropriate icon using LabIcon.resolve
                const icon = isExpanded
                    ? ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-up' })
                    : ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-down' });
                icon.element({ container: button, tag: 'span' }); // Add icon to button
                // Update title for accessibility
                button.title = isExpanded ? 'Collapse input' : 'Expand input';
            },
            getCodeRefMap: () => { var _a; return ((_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.getCodeReferenceMap()) || new Map(); },
            resetCodeRefMap: () => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.resetCodeReferences(); }
        };
        const shortcutCallbacks = {
            showIndicator: (text) => { var _a; return (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showIndicator(text); },
            appendToInput: (text) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(text); },
            showWidget: () => { if (this.isHidden) {
                this.show();
            } },
            focusInput: () => { var _a, _b; return (_b = (_a = this.layoutElements) === null || _a === void 0 ? void 0 : _a.inputField) === null || _b === void 0 ? void 0 : _b.focus(); }
        };
        // --- 3. Build UI Layout ---
        this.layoutElements = (0, layout_builder_1.buildLayout)({
            onNewChatClick: createNewChatCallback,
            onHistoryToggleClick: toggleHistoryCallback,
            onNotesClick: toggleNotesCallback,
            onSettingsClick: showSettingsCallback,
            onTitleChange: this.handleUpdateTitle,
            onAtButtonClick: showPopupMenuCallback,
            onSendMessageClick: sendMessageViaButtonCallback,
            onMarkdownToggleChange: toggleMarkdownModeCallback,
            onExpandToggleClick: toggleExpandInputCallback,
        });
        this.settingsModalContainer = (0, settings_modal_1.createSettingsModalElement)(settingsModalCallbacks);
        // --- Initialize State Managers ---
        this.chatState = new chat_state_1.ChatState();
        this.settingsState = new settings_state_1.SettingsState();
        this.noteState = new note_state_1.NoteState();
        // --- Initialize Core Components ---
        this.apiClient = new api_client_1.ApiClient();
        // --- Initialize UI Manager (needs dependencies) ---
        const uiManagerCallbacks = {
            handleNewChat: this.handleNewChat,
            handleToggleHistory: this.handleToggleHistory,
            handleToggleNotes: this.handleToggleNotes,
            handleSendMessage: this.handleSendMessage,
            handleShowSettings: this.handleShowSettings,
            handleShowPopupMenu: this.handleShowPopupMenu,
            handleUpdateTitle: this.handleUpdateTitle
        };
        this.uiManager = new ui_manager_1.UIManager(this.popupMenuManager, uiManagerCallbacks, this.layoutElements);
        // --- 4. Initialize Handlers (using UI elements and core components) ---
        this.inputHandler = new input_handler_1.InputHandler(this.layoutElements.inputField, inputHandlerCallbacks);
        this.messageHandler = new message_handler_1.MessageHandler(this.apiClient, this.chatState, this.uiManager, messageRendererCallbacks, this.inputHandler);
        this.historyHandler = new history_handler_1.HistoryHandler(this.chatState, this.uiManager, historyHandlerCallbacks, messageRendererCallbacks);
        this.noteHandler = new note_handler_1.NoteHandler(this.noteState, this.uiManager, noteHandlerCallbacks, this.node);
        // Replace the layout's notes container with the one from NoteHandler
        const noteContainer = this.noteHandler.getContainer();
        const layoutNoteContainer = this.layoutElements.notesContainer;
        const parent = layoutNoteContainer.parentNode;
        if (parent) {
            parent.replaceChild(noteContainer, layoutNoteContainer);
            // Update the reference in layoutElements
            this.layoutElements.notesContainer = noteContainer;
        }
        this.settingsHandler = new settings_handler_1.SettingsHandler(this.settingsState, this.settingsModalContainer, this.uiManager);
        // --- 5. Final Setup (Attach event listeners, connect signals, etc.) ---
        const initialChatId = this.chatState.getCurrentChatId();
        if (initialChatId) {
            this.historyHandler.loadChat(initialChatId);
        }
        else {
            const newChat = this.chatState.createNewChat();
            this.historyHandler.loadChat(newChat.id);
        }
        // Setup global keyboard shortcuts with the UIManager for proper @ key handling
        (0, shortcut_handler_1.setupShortcuts)(this.inputHandler, this.popupMenuManager, shortcutCallbacks);
        this.node.appendChild(this.layoutElements.mainElement);
        this.node.appendChild(this.settingsModalContainer);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        var _a, _b;
        if (this.isDisposed) {
            return;
        }
        (0, shortcut_handler_1.removeShortcuts)();
        (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this.popupMenuManager) === null || _b === void 0 ? void 0 : _b.dispose();
        super.dispose();
    }
} // End of SimpleSidebarWidget class
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/chat-state.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/chat-state.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChatState = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "webpack/sharing/consume/default/uuid/uuid");
/**
 * Manages the state of chat history and the currently active chat.
 */
class ChatState {
    constructor() {
        var _a;
        this.chatHistory = [];
        this.currentChatId = null;
        // Potential: Load initial state from storage if persistence is added later
        if (this.chatHistory.length === 0) {
            this.createNewChat('Welcome Chat'); // Create an initial chat if none exists
        }
        else {
            this.currentChatId = ((_a = this.chatHistory[0]) === null || _a === void 0 ? void 0 : _a.id) || null; // Set current chat to the first one
        }
    }
    /**
     * Creates a new chat session and sets it as the current chat.
     * @param title - The initial title for the new chat.
     * @returns The newly created chat item.
     */
    createNewChat(title = 'New Chat') {
        const chatId = `chat-${(0, uuid_1.v4)()}`; // Use UUID for better uniqueness
        const newChat = {
            id: chatId,
            title: title,
            messages: [],
            // Optional: Add timestamp or other metadata if needed later
            // createdAt: Date; 
        };
        this.chatHistory.push(newChat);
        this.currentChatId = chatId;
        console.log('Created new chat:', newChat);
        return newChat;
    }
    /**
     * Sets the currently active chat ID.
     * @param chatId - The ID of the chat to set as current.
     */
    setCurrentChatId(chatId) {
        if (this.chatHistory.some(chat => chat.id === chatId)) {
            this.currentChatId = chatId;
        }
        else {
            console.warn(`Chat ID ${chatId} not found in history.`);
        }
    }
    /**
     * Gets the ID of the currently active chat.
     * @returns The current chat ID or null if none is active.
     */
    getCurrentChatId() {
        return this.currentChatId;
    }
    /**
     * Retrieves a specific chat by its ID.
     * @param chatId - The ID of the chat to retrieve.
     * @returns The chat item or undefined if not found.
     */
    getChatById(chatId) {
        return this.chatHistory.find(chat => chat.id === chatId);
    }
    /**
     * Retrieves the currently active chat item.
     * @returns The current chat item or undefined if no chat is active or found.
     */
    getCurrentChat() {
        if (!this.currentChatId) {
            return undefined;
        }
        return this.getChatById(this.currentChatId);
    }
    /**
     * Updates the title of the currently active chat.
     * @param newTitle - The new title for the chat.
     */
    updateCurrentChatTitle(newTitle) {
        const currentChat = this.getCurrentChat();
        if (currentChat) {
            currentChat.title = newTitle;
            console.log(`Updated title for chat ${this.currentChatId} to "${newTitle}"`);
        }
        else {
            console.warn('Cannot update title: No current chat selected.');
        }
    }
    /**
     * Adds a message to the currently active chat.
     * @param message - The message object to add.
     */
    addMessageToCurrentChat(message) {
        const currentChat = this.getCurrentChat();
        if (currentChat) {
            currentChat.messages.push(message);
        }
        else {
            console.warn('Cannot add message: No current chat selected.');
        }
    }
    /**
     * Gets all messages from the currently active chat.
     * @returns An array of messages or an empty array if no chat is active.
     */
    getCurrentChatMessages() {
        const currentChat = this.getCurrentChat();
        return currentChat ? currentChat.messages : [];
    }
    /**
     * Gets the entire chat history.
     * @returns An array of all chat history items.
     */
    getChatHistory() {
        return [...this.chatHistory]; // Return a copy to prevent direct modification
    }
}
exports.ChatState = ChatState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/note-state.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/note-state.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoteState = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "webpack/sharing/consume/default/uuid/uuid");
/**
 * Manages the state of notes and the currently selected note.
 */
class NoteState {
    constructor() {
        this.notes = [];
        this.currentNoteId = null;
        // In the future, we might load notes from persistent storage here
    }
    /**
     * Creates a new note.
     * @param title - The title for the new note.
     * @param content - The content for the new note.
     * @returns The newly created note.
     */
    createNewNote(title, content) {
        const timestamp = new Date().toISOString();
        const newNote = {
            id: (0, uuid_1.v4)(),
            title,
            content,
            createdAt: timestamp,
            updatedAt: timestamp
        };
        this.notes.push(newNote);
        this.currentNoteId = newNote.id;
        return newNote;
    }
    /**
     * Sets the currently selected note ID.
     * @param noteId - The ID of the note to set as current.
     */
    setCurrentNoteId(noteId) {
        this.currentNoteId = noteId;
    }
    /**
     * Gets the ID of the currently selected note.
     * @returns The current note ID or null if none is selected.
     */
    getCurrentNoteId() {
        return this.currentNoteId;
    }
    /**
     * Retrieves a specific note by its ID.
     * @param noteId - The ID of the note to retrieve.
     * @returns The note or undefined if not found.
     */
    getNoteById(noteId) {
        return this.notes.find(note => note.id === noteId);
    }
    /**
     * Retrieves the currently selected note.
     * @returns The current note or undefined if no note is selected or found.
     */
    getCurrentNote() {
        if (!this.currentNoteId) {
            return undefined;
        }
        return this.getNoteById(this.currentNoteId);
    }
    /**
     * Updates a note's title and content.
     * @param noteId - The ID of the note to update.
     * @param title - The new title for the note.
     * @param content - The new content for the note.
     * @returns The updated note or undefined if not found.
     */
    updateNote(noteId, title, content) {
        const noteIndex = this.notes.findIndex(note => note.id === noteId);
        if (noteIndex < 0) {
            return undefined;
        }
        this.notes[noteIndex] = Object.assign(Object.assign({}, this.notes[noteIndex]), { title,
            content, updatedAt: new Date().toISOString() });
        return this.notes[noteIndex];
    }
    /**
     * Deletes a note by its ID.
     * @param noteId - The ID of the note to delete.
     * @returns True if the note was found and deleted, false otherwise.
     */
    deleteNote(noteId) {
        const initialLength = this.notes.length;
        this.notes = this.notes.filter(note => note.id !== noteId);
        if (this.notes.length < initialLength) {
            // If the deleted note was the current one, reset current or set to the first note
            if (this.currentNoteId === noteId) {
                this.currentNoteId = this.notes.length > 0 ? this.notes[0].id : null;
            }
            return true;
        }
        return false;
    }
    /**
     * Gets all notes.
     * @returns An array of all notes.
     */
    getAllNotes() {
        return [...this.notes]; // Return a copy to prevent direct mutation
    }
}
exports.NoteState = NoteState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/settings-state.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/settings-state.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsState = void 0;
const SETTINGS_STORAGE_KEY = 'jp-llm-ext-settings';
/**
 * Manages loading and saving application settings to localStorage.
 */
class SettingsState {
    constructor() {
        this.currentSettings = null;
        this.currentSettings = this.loadSettings();
    }
    /**
     * Loads settings from localStorage.
     * @returns The loaded settings or null if none are saved or an error occurs.
     */
    loadSettings() {
        const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                // Basic validation (can be expanded)
                if (settings && settings.provider) {
                    this.currentSettings = settings;
                    console.log('Loaded settings:', this.currentSettings);
                    return this.currentSettings;
                }
            }
            catch (error) {
                console.error('Error loading saved settings:', error);
                localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear corrupted data
            }
        }
        console.log('No valid settings found in localStorage.');
        return null;
    }
    /**
     * Saves the provided settings to localStorage.
     * @param settings - The settings object to save.
     */
    saveSettings(settings) {
        try {
            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            this.currentSettings = Object.assign({}, settings); // Update internal state
            console.log('Settings saved:', this.currentSettings);
        }
        catch (error) {
            console.error('Error saving settings:', error);
            // Optional: Notify user of save failure
        }
    }
    /**
     * Gets the currently loaded settings.
     * @returns The current settings object or null if not loaded.
     */
    getSettings() {
        return this.currentSettings ? Object.assign({}, this.currentSettings) : null; // Return a copy
    }
    /**
     * Gets a specific setting value.
     * @param key - The key of the setting to retrieve.
     * @returns The value of the setting or undefined if not found.
     */
    getSetting(key) {
        return this.currentSettings ? this.currentSettings[key] : undefined;
    }
}
exports.SettingsState = SettingsState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDiv = createDiv;
exports.createButton = createButton;
exports.createSpan = createSpan;
exports.createTextArea = createTextArea;
exports.createInputElement = createInputElement;
exports.createImageElement = createImageElement;
exports.createAnchorElement = createAnchorElement;
exports.createLabelElement = createLabelElement;
exports.createFormElement = createFormElement;
/**
 * Generic function to create an HTMLElement.
 *
 * @param tagName - The HTML tag name (e.g., 'div', 'button').
 * @param options - Optional configuration for the element.
 * @returns The created HTMLElement.
 */
function createElement(tagName, options = {}) {
    const element = document.createElement(tagName);
    if (options.id) {
        element.id = options.id;
    }
    if (options.classes) {
        const classesToAdd = Array.isArray(options.classes)
            ? options.classes
            : options.classes.split(' ').filter(c => c);
        element.classList.add(...classesToAdd);
    }
    if (options.text) {
        element.textContent = options.text;
    }
    else if (options.html) {
        element.innerHTML = options.html; // Be cautious with HTML injection
    }
    if (options.attributes) {
        for (const key in options.attributes) {
            if (options.attributes.hasOwnProperty(key)) {
                element.setAttribute(key, options.attributes[key]);
            }
        }
    }
    if (options.style) {
        for (const key in options.style) {
            if (options.style.hasOwnProperty(key)) {
                element.style[key] = options.style[key];
            }
        }
    }
    if (options.children) {
        options.children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            }
            else {
                element.appendChild(child);
            }
        });
    }
    return element;
}
/** Creates a <div> element. */
function createDiv(options = {}) {
    return createElement('div', options);
}
/** Creates a <button> element. */
function createButton(options = {}) {
    return createElement('button', options);
}
/** Creates a <span> element. */
function createSpan(options = {}) {
    return createElement('span', options);
}
/** Creates a <textarea> element. */
function createTextArea(options = {}) {
    return createElement('textarea', options);
}
/** Creates an <input> element. */
function createInputElement(options = {}) {
    var _a;
    // Ensure type is set if provided in attributes, otherwise default or leave unset
    if ((_a = options.attributes) === null || _a === void 0 ? void 0 : _a.type) {
        // Type is already set in attributes, do nothing extra
    }
    else if (!options.attributes) {
        options.attributes = { type: 'text' }; // Default to text if no attributes specified
    }
    else if (!options.attributes.type) {
        options.attributes.type = 'text'; // Default to text if type is not in attributes
    }
    return createElement('input', options);
}
/** Creates an <img> element. */
function createImageElement(options) {
    const imgOptions = Object.assign({}, options);
    imgOptions.attributes = Object.assign(Object.assign({}, options.attributes), { src: options.src });
    if (options.alt) {
        imgOptions.attributes.alt = options.alt;
    }
    return createElement('img', imgOptions);
}
/** Creates an <a> element. */
function createAnchorElement(options) {
    const anchorOptions = Object.assign({}, options);
    anchorOptions.attributes = Object.assign(Object.assign({}, options.attributes), { href: options.href });
    return createElement('a', anchorOptions);
}
/** Creates a <label> element. */
function createLabelElement(options) {
    const labelOptions = Object.assign({}, options);
    if (options.htmlFor) {
        labelOptions.attributes = Object.assign(Object.assign({}, options.attributes), { for: options.htmlFor });
    }
    return createElement('label', labelOptions);
}
/** Creates a <form> element. */
function createFormElement(options = {}) {
    return createElement('form', options);
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js":
/*!************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildLayout = buildLayout;
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
/**
 * Builds the main HTML structure for the sidebar widget.
 *
 * @param callbacks - An object containing callback functions for various UI interactions.
 * @returns An object containing the main widget HTMLElement and references to key interactive elements.
 */
function buildLayout(callbacks = {}) {
    // --- Main Content Wrapper ---
    const mainElement = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-content-wrapper'
    });
    // --- Title Bar ---
    const titleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-title-container' });
    const titleInput = (0, dom_elements_1.createInputElement)({
        id: 'chat-title-input',
        classes: 'chat-title-input',
        attributes: { type: 'text', placeholder: 'Chat title', value: 'New Chat' }
    });
    if (callbacks.onTitleChange) {
        titleInput.addEventListener('change', () => callbacks.onTitleChange(titleInput.value));
    }
    titleContainer.appendChild(titleInput);
    // --- Message & History Containers ---
    const messageContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-message-container' });
    const historyContainer = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-history-container',
        style: { display: 'none' } // Hidden by default
    });
    // --- Notes Container ---
    const notesContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-notes-container', style: { display: 'none' } });
    // --- Bottom Bar Area ---
    const bottomBarContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-container' });
    // Row 1: Controls (Markdown Toggle, @, Expand, Settings)
    const controlsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row' });
    const controlsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-controls-container' });
    // Markdown Toggle
    const toggleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-toggle-container' });
    const markdownToggleButton = (0, dom_elements_1.createInputElement)({
        id: 'markdown-toggle',
        attributes: { type: 'checkbox' }
    });
    const toggleLabel = (0, dom_elements_1.createLabelElement)({
        text: 'Markdown mode',
        htmlFor: 'markdown-toggle'
    });
    if (callbacks.onMarkdownToggleChange) {
        markdownToggleButton.addEventListener('change', () => {
            callbacks.onMarkdownToggleChange(markdownToggleButton.checked);
        });
    }
    toggleContainer.appendChild(markdownToggleButton);
    toggleContainer.appendChild(toggleLabel);
    // Action Buttons (@, Expand, Settings)
    const actionButtonsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-action-buttons-container' });
    const atButton = (0, dom_elements_1.createButton)({ text: '@', attributes: { title: 'Browse cells, code, files, and more' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onAtButtonClick) {
        atButton.addEventListener('click', callbacks.onAtButtonClick);
    }
    const expandButton = (0, dom_elements_1.createButton)({ text: '⤢', attributes: { title: 'Expand input' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onExpandToggleClick) {
        expandButton.addEventListener('click', () => callbacks.onExpandToggleClick(expandButton));
    }
    const settingsButton = (0, dom_elements_1.createButton)({ text: '⚙️', attributes: { title: 'Settings' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onSettingsClick) {
        settingsButton.addEventListener('click', callbacks.onSettingsClick);
    }
    actionButtonsContainer.appendChild(atButton);
    actionButtonsContainer.appendChild(expandButton);
    actionButtonsContainer.appendChild(settingsButton);
    controlsContainer.appendChild(toggleContainer);
    controlsContainer.appendChild(actionButtonsContainer);
    controlsRow.appendChild(controlsContainer);
    // Row 2: Input Field
    const inputRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row' });
    const inputField = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-input-field',
        attributes: {
            contenteditable: 'true',
            role: 'textbox',
            'aria-multiline': 'true',
            'data-placeholder': 'Ask me anything...'
        },
        style: { minHeight: '20px', overflowY: 'hidden' }
    });
    if (callbacks.onInputFieldKeyPress) {
        inputField.addEventListener('keypress', callbacks.onInputFieldKeyPress);
    }
    if (callbacks.onInputFieldValueChange) {
        inputField.addEventListener('input', () => callbacks.onInputFieldValueChange(inputField.textContent || ''));
    }
    inputRow.appendChild(inputField);
    // Row 3: Main Buttons (Send, New Chat, History)
    const buttonsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row' });
    const sendButton = (0, dom_elements_1.createButton)({
        text: 'Send',
        classes: 'jp-Button jp-llm-ext-send-button'
    });
    if (callbacks.onSendMessageClick) {
        sendButton.addEventListener('click', callbacks.onSendMessageClick);
    }
    const newChatButton = (0, dom_elements_1.createButton)({
        text: '+ New Chat',
        attributes: { title: 'Start a new chat' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onNewChatClick) {
        newChatButton.addEventListener('click', callbacks.onNewChatClick);
    }
    const historyButton = (0, dom_elements_1.createButton)({
        text: 'History',
        attributes: { title: 'View chat history' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onHistoryToggleClick) {
        historyButton.addEventListener('click', callbacks.onHistoryToggleClick);
    }
    // Notes button
    const notesButton = (0, dom_elements_1.createButton)({
        text: 'Notes',
        attributes: { title: 'View notes' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onNotesClick) {
        notesButton.addEventListener('click', callbacks.onNotesClick);
    }
    buttonsRow.appendChild(sendButton);
    buttonsRow.appendChild(newChatButton);
    buttonsRow.appendChild(historyButton);
    buttonsRow.appendChild(notesButton);
    // Assemble Bottom Bar
    bottomBarContainer.appendChild(controlsRow);
    bottomBarContainer.appendChild(inputRow);
    bottomBarContainer.appendChild(buttonsRow);
    // --- Assemble Main Element ---
    mainElement.appendChild(titleContainer);
    mainElement.appendChild(messageContainer);
    mainElement.appendChild(historyContainer);
    mainElement.appendChild(notesContainer);
    mainElement.appendChild(bottomBarContainer);
    return {
        mainElement,
        titleInput,
        messageContainer,
        historyContainer,
        notesContainer,
        inputField,
        bottomBarContainer,
        sendButton,
        newChatButton,
        historyButton,
        notesButton,
        markdownToggleButton,
        expandButton,
        atButton,
        settingsButton
    };
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRenderer = void 0;
exports.renderUserMessage = renderUserMessage;
exports.renderBotMessage = renderBotMessage;
exports.renderBotMessageStreamingStart = renderBotMessageStreamingStart;
exports.renderBotMessageStreamingUpdate = renderBotMessageStreamingUpdate;
exports.renderBotMessageFinal = renderBotMessageFinal;
exports.renderReferenceWidgetInline = renderReferenceWidgetInline;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
// import hljs from 'highlight.js'; // Removed unused import
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js"); // Import globals
// Removed unused import block for clipboard utils (used via callbacks)
// import { copyToClipboard, copyImageToClipboard, copyMessageToClipboard } from '../utils/clipboard';
// Removed unused import (used via callbacks)
// import { addMessageToCell } from '../utils/notebook-integration';
const highlighting_1 = __webpack_require__(/*! ../utils/highlighting */ "./node_modules/jupyter-simple-extension/lib/utils/highlighting.js");
const markdown_config_1 = __webpack_require__(/*! ../utils/markdown-config */ "./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js");
/**
 * Base function to create a message container div.
 */
function createMessageDiv(sender) {
    const messageDiv = document.createElement('div');
    messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';
    return messageDiv;
}
/**
 * Renders a user message.
 */
function renderUserMessage(text, options = {}, callbacks = {}) {
    console.log(`[renderUserMessage] Rendering with isMarkdown: ${options.isMarkdown}, text: "${text}"`);
    const messageDiv = createMessageDiv('user');
    if (options.isMarkdown) {
        // Use 'markdown-content' class for consistent styling
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-content';
        try {
            // Preprocess, parse, and sanitize like in bot messages
            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // Add markdown indicator (similar to bot messages)
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            messageDiv.appendChild(markdownIndicator);
            // Enhance code blocks if user messages can contain them
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                // Pass only relevant callbacks if needed for user code blocks
                enhanceCodeBlock(block, callbacks);
            });
        }
        catch (error) {
            console.error('Failed to render user markdown:', error);
            // Fallback to plain text if Markdown rendering fails
            contentDiv.textContent = text;
        }
        messageDiv.appendChild(contentDiv);
    }
    else {
        // Non-Markdown user message (plain text)
        // Replace simple textContent assignment with ref-aware rendering
        // messageDiv.textContent = text;
        renderMessageContentWithRefs(messageDiv, text, callbacks);
    }
    return messageDiv;
}
/**
 * NEW: Renders message content, replacing @references with widgets.
 */
function renderMessageContentWithRefs(container, text, callbacks) {
    // --- DEBUG LOG --- 
    console.log('[renderMessageContentWithRefs] Processing text:', JSON.stringify(text)); // Log exact text
    // --- END DEBUG LOG ---
    // Regex to find @file, @dir, @Cell, @code references (with optional surrounding whitespace)
    const refRegex = /\s*(@(file|dir|Cell|code)\[([^\]]+?)\])\s*/g;
    let lastIndex = 0;
    let match;
    // Reset regex state just in case
    refRegex.lastIndex = 0;
    while ((match = refRegex.exec(text)) !== null) {
        // Append text before the match
        if (match.index > lastIndex) {
            container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
        }
        // Process the matched reference
        const fullMatchWithWhitespace = match[0]; // Includes potential whitespace
        const fullMatch = match[1]; // The actual @type[value] part
        const type = match[2];
        const value = match[3];
        try {
            const widget = createRefWidget(type, value, fullMatch, callbacks); // Pass the clean match
            container.appendChild(widget);
        }
        catch (error) {
            console.error(`Failed to create widget for reference: ${fullMatch}`, error);
            // Fallback: append the original reference text (with potential whitespace)
            container.appendChild(document.createTextNode(fullMatchWithWhitespace));
        }
        lastIndex = refRegex.lastIndex;
    }
    // Append any remaining text after the last match
    if (lastIndex < text.length) {
        container.appendChild(document.createTextNode(text.substring(lastIndex)));
    }
}
/**
 * NEW: Creates a reference widget span.
 */
function createRefWidget(type, value, originalRefText, // The full @type[value] string
callbacks) {
    const widget = document.createElement('span');
    widget.className = `jp-llm-ext-ref-widget ref-${type.toLowerCase()}`;
    widget.setAttribute('contenteditable', 'false');
    widget.dataset.refText = originalRefText; // Store the original reference
    let displayText = '';
    let titleText = originalRefText; // Default tooltip
    switch (type) {
        case 'file':
            displayText = value.split(/[\\/]/).pop() || value; // Extract filename
            titleText = `File: ${value}`;
            break;
        case 'dir':
            displayText = value.split(/[\\/]/).pop() || value || '/'; // Extract dirname, handle root
            titleText = `Directory: ${value}`;
            break;
        case 'Cell': {
            const cellIndex = parseInt(value) - 1; // Convert back to 0-based index
            const notebookContext = callbacks.getCurrentNotebookContext ? callbacks.getCurrentNotebookContext() : undefined;
            // --- DEBUG LOG --- 
            console.log(`[createRefWidget @Cell] Input Value: ${value}, Parsed Index: ${cellIndex}, Notebook Context:`, notebookContext);
            // --- END DEBUG LOG --- 
            const notebookName = (notebookContext === null || notebookContext === void 0 ? void 0 : notebookContext.name) || 'notebook';
            let cellTypeChar = '?';
            if (notebookContext && globals_1.globals.notebookTracker) {
                const currentNotebookPanel = globals_1.globals.notebookTracker.find(widget => widget.context.path === notebookContext.path);
                if (currentNotebookPanel && currentNotebookPanel.model) {
                    const cellModel = currentNotebookPanel.model.cells.get(cellIndex);
                    if (cellModel) {
                        cellTypeChar = cellModel.type === 'markdown' ? 'M' : 'C';
                    }
                }
            }
            displayText = `${notebookName}-${cellTypeChar}-${value}`; // value is 1-based index
            titleText = `Cell ${value} (${cellTypeChar === 'M' ? 'Markdown' : 'Code'}) in ${notebookName}`;
            break;
        }
        case 'code': {
            const refId = value;
            const refData = callbacks.getCodeRefData ? callbacks.getCodeRefData(refId) : undefined;
            // --- DEBUG LOG --- 
            console.log(`[createRefWidget @code] Input Value (refId): ${refId}, Ref Data Found:`, refData);
            // --- END DEBUG LOG --- 
            if (refData) {
                // Construct display text using start and end lines
                const startLine = refData.lineNumber;
                const endLine = refData.lineEndNumber;
                const linePart = startLine === endLine ? `${startLine}` : `${startLine}_${endLine}`;
                displayText = `${refData.notebookName}-${refData.cellIndex + 1}-${linePart}`;
                // Update title text as well
                const titleLinePart = startLine === endLine ? `Line ${startLine}` : `Lines ${startLine}-${endLine}`;
                titleText = `Code Reference: ${refData.notebookName}, Cell ${refData.cellIndex + 1}, ${titleLinePart}`;
            }
            else {
                displayText = `code-ref-${refId}`; // Fallback display
                titleText = `Code Reference ID: ${refId} (Data not found)`;
            }
            break;
        }
    }
    widget.textContent = displayText;
    widget.title = titleText; // Add tooltip
    return widget;
}
/**
 * NEW: Recursively finds and replaces @references within text nodes of an element.
 */
function renderRefsInElement(element, callbacks) {
    // Use the same updated regex here
    const refRegex = /\s*(@(file|dir|Cell|code)\[([^\]]+?)\])\s*/g;
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
    let node;
    const nodesToProcess = [];
    while ((node = walker.nextNode())) {
        if (node instanceof Text &&
            node.textContent &&
            !(node.parentElement && node.parentElement.closest('.jp-llm-ext-ref-widget'))) {
            // Test with the specific regex before adding
            refRegex.lastIndex = 0; // Reset before test
            if (refRegex.test(node.textContent)) {
                nodesToProcess.push(node);
            }
        }
    }
    // Now, process the collected text nodes
    nodesToProcess.forEach(textNode => {
        const parent = textNode.parentNode;
        if (!parent)
            return;
        const text = textNode.textContent || '';
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        refRegex.lastIndex = 0; // Reset regex state for each node
        while ((match = refRegex.exec(text)) !== null) {
            // Append text before the match
            if (match.index > lastIndex) {
                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
            }
            // Process the matched reference
            const fullMatchWithWhitespace = match[0];
            const fullMatch = match[1];
            const type = match[2];
            const value = match[3];
            try {
                const widget = createRefWidget(type, value, fullMatch, callbacks);
                fragment.appendChild(widget);
            }
            catch (error) {
                console.error(`Failed to create widget for reference: ${fullMatch}`, error);
                fragment.appendChild(document.createTextNode(fullMatchWithWhitespace)); // Fallback
            }
            lastIndex = refRegex.lastIndex;
        }
        // Append any remaining text after the last match
        if (lastIndex < text.length) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        // Replace the original text node with the fragment
        parent.replaceChild(fragment, textNode);
    });
}
/**
 * Renders a bot message (text, markdown, images, code blocks).
 */
function renderBotMessage(text, options = { isMarkdown: true }, callbacks = {}) {
    const messageDiv = createMessageDiv('bot');
    // Check if the message is an image URL
    const isImageUrl = text.trim().startsWith('/images/') &&
        (text.trim().endsWith('.png') ||
            text.trim().endsWith('.jpg') ||
            text.trim().endsWith('.jpeg') ||
            text.trim().endsWith('.gif'));
    if (isImageUrl) {
        // Construct full URL (TODO: Make base URL configurable)
        const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;
        // Call dedicated image rendering function
        renderImageMessage(messageDiv, fullImageUrl, callbacks);
    }
    else if (options.isMarkdown) {
        // Render as markdown (logic from addMessage)
        const markdownIndicator = document.createElement('div');
        markdownIndicator.textContent = "MD";
        markdownIndicator.className = 'markdown-indicator';
        messageDiv.appendChild(markdownIndicator);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-content';
        try {
            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // --- NEW: Render references within the sanitized HTML --- 
            renderRefsInElement(contentDiv, callbacks);
            // --- End NEW ---
            // Enhance code blocks after setting innerHTML and rendering refs
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                enhanceCodeBlock(block, callbacks);
            });
            // Check for and render interrupt buttons
            const isInterrupt = text.startsWith('**[INTERRUPT]**');
            if (isInterrupt) {
                renderInterruptButtons(contentDiv, callbacks);
            }
        }
        catch (error) {
            contentDiv.textContent = text; // Fallback to plain text
            console.error('Failed to render markdown:', error);
        }
        messageDiv.appendChild(contentDiv);
        // Add overall message action buttons AFTER content is added
        addBotMessageActions(messageDiv, text, callbacks);
    }
    else {
        // Render as plain text
        messageDiv.textContent = text;
        // Add overall message action buttons even for plain text bot messages
        addBotMessageActions(messageDiv, text, callbacks);
    }
    return messageDiv;
}
// Define createMessageWrapper based on createMessageDiv
function createMessageWrapper(sender) {
    return createMessageDiv(sender);
}
// --- More specific rendering functions or helpers can be added below ---
/**
 * Renders an image message with action buttons inside a container.
 *
 * @param container The parent HTML element to append the image message to.
 * @param imageUrl The full URL of the image to render.
 * @param callbacks Callbacks for actions like copy image, add path.
 */
function renderImageMessage(container, imageUrl, callbacks = {}) {
    // Create a container for the image that allows positioning the buttons
    const imageContainer = document.createElement('div');
    imageContainer.className = 'jp-llm-ext-image-container';
    imageContainer.style.position = 'relative';
    // Render as an image tag
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = 'Image from bot';
    img.style.maxWidth = '100%'; // Ensure image fits within the container
    img.style.height = 'auto';
    imageContainer.appendChild(img);
    // Add action buttons for the image
    const imgActionsDiv = document.createElement('div');
    imgActionsDiv.className = 'jp-llm-ext-image-actions';
    imgActionsDiv.style.position = 'absolute';
    imgActionsDiv.style.bottom = '10px';
    imgActionsDiv.style.right = '10px';
    imgActionsDiv.style.display = 'flex';
    imgActionsDiv.style.gap = '8px';
    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)'; // Added slight background for visibility
    imgActionsDiv.style.borderRadius = '4px';
    imgActionsDiv.style.padding = '4px';
    // Copy image button (using callback)
    if (callbacks.copyImageToClipboard && callbacks.showCopyFeedback) {
        const copyImgBtn = document.createElement('button');
        copyImgBtn.className = 'jp-llm-ext-image-action-button';
        copyImgBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyImgBtn.title = 'Copy image to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyImgBtn);
        copyImgBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyImageToClipboard(imageUrl, feedbackCb);
        });
        imgActionsDiv.appendChild(copyImgBtn);
    }
    // Add file path button (using callback)
    if (callbacks.addMessageToCell) {
        const addPathBtn = document.createElement('button');
        addPathBtn.className = 'jp-llm-ext-image-action-button';
        addPathBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addPathBtn.title = 'Add image path to current cell';
        addPathBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            // Pass the image URL (which is the message text in this case)
            callbacks.addMessageToCell(imageUrl);
        });
        imgActionsDiv.appendChild(addPathBtn);
    }
    // Only add the actions div if it has buttons
    if (imgActionsDiv.hasChildNodes()) {
        imageContainer.appendChild(imgActionsDiv);
    }
    // Add the image container to the main message div
    container.appendChild(imageContainer);
}
/**
 * Creates the initial structure for a bot message that will receive streaming content.
 *
 * @returns Object containing the wrapper, streaming div, and final content div.
 */
function renderBotMessageStreamingStart() {
    const wrapper = createMessageWrapper('bot');
    const markdownIndicator = (0, dom_elements_1.createDiv)({
        text: 'MD',
        classes: 'markdown-indicator'
    });
    wrapper.appendChild(markdownIndicator);
    const streamingDiv = (0, dom_elements_1.createDiv)({
        classes: 'streaming-content',
        style: {
            whiteSpace: 'pre-wrap',
            fontFamily: 'monospace',
            fontSize: '0.9em'
        }
    });
    wrapper.appendChild(streamingDiv);
    const contentDiv = (0, dom_elements_1.createDiv)({
        classes: 'markdown-content',
        style: { display: 'none' } // Initially hidden
    });
    wrapper.appendChild(contentDiv);
    return { wrapper, streamingDiv, contentDiv };
}
/**
 * Updates the streaming div with a new chunk of text.
 *
 * @param streamingDiv - The div displaying streaming content.
 * @param chunk - The new text chunk to append.
 */
function renderBotMessageStreamingUpdate(streamingDiv, chunk) {
    // Simple append, might need refinement for complex streams
    streamingDiv.textContent += chunk;
}
/**
 * Renders the final content of a bot message after streaming is complete.
 * Handles markdown, images, code blocks, and interrupts.
 *
 * @param contentDiv - The div where the final content should be rendered.
 * @param streamingDiv - The div that was used for streaming (will be hidden).
 * @param completeResponse - The full text content from the bot.
 * @param options - Rendering options including callbacks for actions.
 * @returns The populated contentDiv.
 */
function renderBotMessageFinal(contentDiv, streamingDiv, completeResponse, options = {}, callbacks = {}) {
    // Hide streaming div, show final content div
    streamingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    // Consolidate callbacks access
    const effectiveCallbacks = Object.assign(Object.assign({}, options), callbacks);
    // --- Image Handling ---
    const isImageUrl = completeResponse.trim().startsWith('/images/') &&
        (completeResponse.trim().endsWith('.png') ||
            completeResponse.trim().endsWith('.jpg') ||
            completeResponse.trim().endsWith('.jpeg') ||
            completeResponse.trim().endsWith('.gif'));
    if (isImageUrl) {
        const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // TODO: Make base URL configurable
        renderImageMessage(contentDiv, fullImageUrl, effectiveCallbacks);
    }
    else {
        // --- Markdown & Code Block Handling ---
        try {
            const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // --- NEW: Render references within the sanitized HTML --- 
            renderRefsInElement(contentDiv, effectiveCallbacks);
            // --- End NEW ---
            // --- Interrupt Handling ---
            const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');
            if (isInterrupt) {
                renderInterruptButtons(contentDiv, effectiveCallbacks);
            }
            // --- Code Block Enhancements ---
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                enhanceCodeBlock(block, effectiveCallbacks);
            });
        }
        catch (error) {
            console.error('Error rendering markdown:', error);
            contentDiv.textContent = completeResponse; // Fallback to plain text
        }
    }
    return contentDiv;
}
/**
 * Enhances a code block element with highlighting and action buttons.
 *
 * @param codeBlockElement The <code> element within a <pre>.
 * @param callbacks Callbacks for actions like copy code, add to cell.
 */
function enhanceCodeBlock(codeBlockElement, callbacks = {}) {
    var _a;
    const preElement = codeBlockElement.parentElement;
    if (!preElement || preElement.tagName !== 'PRE') {
        console.warn('Code block enhancement called on element not within a <pre> tag.');
        return;
    }
    // Add standard JupyterLab classes for consistency
    codeBlockElement.classList.add('jp-RenderedText');
    preElement.classList.add('jp-RenderedHTMLCommon');
    // Get code content
    const codeContent = codeBlockElement.textContent || '';
    // Create code block header for buttons and language indicator
    const codeHeader = document.createElement('div');
    codeHeader.className = 'jp-llm-ext-code-header';
    // Add language indicator if detected
    const language = (0, highlighting_1.detectLanguage)(codeContent); // Use imported util
    if (language) {
        const langIndicator = document.createElement('span');
        langIndicator.className = 'jp-llm-ext-code-language';
        langIndicator.textContent = language;
        codeHeader.appendChild(langIndicator);
        codeBlockElement.classList.add(`language-${language}`);
    }
    // Apply syntax highlighting
    try {
        // Use imported util (handles auto-detection if language is empty)
        codeBlockElement.innerHTML = (0, highlighting_1.highlightCode)(codeContent, language);
    }
    catch (error) {
        console.error('Error applying syntax highlighting:', error);
        // codeBlockElement might contain original text or partially highlighted
    }
    // Add action buttons to the code header
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'jp-llm-ext-code-actions';
    // Copy button
    if (callbacks.copyToClipboard && callbacks.showCopyFeedback) {
        const copyButton = document.createElement('button');
        copyButton.className = 'jp-llm-ext-code-action-button';
        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyButton.title = 'Copy code to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);
        copyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyToClipboard(codeContent, feedbackCb);
        });
        actionsDiv.appendChild(copyButton);
    }
    // Add to cell button
    if (callbacks.addMessageToCell) {
        const addToButton = document.createElement('button');
        addToButton.className = 'jp-llm-ext-code-action-button';
        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addToButton.title = 'Add code to current cell';
        addToButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.addMessageToCell(codeContent);
        });
        actionsDiv.appendChild(addToButton);
    }
    // Add the actions to the header, and insert header before the <pre>
    if (actionsDiv.hasChildNodes()) {
        codeHeader.appendChild(actionsDiv);
    }
    if (codeHeader.hasChildNodes()) {
        (_a = preElement.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(codeHeader, preElement);
    }
}
/**
 * Renders Confirm/Reject buttons for an interrupt message.
 *
 * @param container The parent HTML element (message content div) to append buttons to.
 * @param callbacks Callbacks for confirm and reject actions.
 */
function renderInterruptButtons(container, callbacks = {}) {
    if (!callbacks.handleConfirmInterrupt || !callbacks.handleRejectInterrupt) {
        console.warn('Interrupt message needs confirm/reject callbacks.');
        return;
    }
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';
    buttonsContainer.style.marginTop = '12px';
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.gap = '8px';
    // Create confirm button
    const confirmButton = document.createElement('button');
    confirmButton.className = 'jp-llm-ext-confirm-button';
    confirmButton.textContent = 'Confirm';
    // Apply specific styling (can be moved to CSS)
    confirmButton.style.padding = '6px 12px';
    confirmButton.style.background = '#4CAF50';
    confirmButton.style.color = 'white';
    confirmButton.style.border = 'none';
    confirmButton.style.borderRadius = '4px';
    confirmButton.style.cursor = 'pointer';
    confirmButton.style.fontWeight = 'bold';
    // Create reject button
    const rejectButton = document.createElement('button');
    rejectButton.className = 'jp-llm-ext-reject-button';
    rejectButton.textContent = 'Reject';
    // Apply specific styling (can be moved to CSS)
    rejectButton.style.padding = '6px 12px';
    rejectButton.style.background = '#F44336';
    rejectButton.style.color = 'white';
    rejectButton.style.border = 'none';
    rejectButton.style.borderRadius = '4px';
    rejectButton.style.cursor = 'pointer';
    rejectButton.style.fontWeight = 'bold';
    // Add event listeners
    confirmButton.addEventListener('click', () => {
        confirmButton.disabled = true;
        rejectButton.disabled = true;
        confirmButton.style.opacity = '0.5';
        rejectButton.style.opacity = '0.5';
        callbacks.handleConfirmInterrupt();
    });
    rejectButton.addEventListener('click', () => {
        confirmButton.disabled = true;
        rejectButton.disabled = true;
        confirmButton.style.opacity = '0.5';
        rejectButton.style.opacity = '0.5';
        callbacks.handleRejectInterrupt();
    });
    // Add buttons to container and container to message
    buttonsContainer.appendChild(confirmButton);
    buttonsContainer.appendChild(rejectButton);
    container.appendChild(buttonsContainer);
}
/**
 * Adds overall action buttons (Copy, Add to Cell) to a bot message container.
 *
 * @param messageDiv The main div container for the bot message.
 * @param messageText The raw text content of the message.
 * @param callbacks Callbacks for actions like copy message, add to cell.
 */
function addBotMessageActions(messageDiv, messageText, callbacks = {}) {
    // Only add actions if corresponding callbacks are provided
    if (!callbacks.copyMessageToClipboard && !callbacks.addMessageToCell) {
        return;
    }
    console.log('Adding action buttons to bot message'); // Keep debug log for now
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'jp-llm-ext-message-actions';
    // actionsDiv.style.display = 'flex'; // Ensure display via CSS if needed
    // Copy Message button
    if (callbacks.copyMessageToClipboard && callbacks.showCopyFeedback) {
        const copyButton = document.createElement('button');
        copyButton.className = 'jp-llm-ext-message-action-button';
        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyButton.title = 'Copy message to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);
        copyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyMessageToClipboard(messageText, feedbackCb);
        });
        actionsDiv.appendChild(copyButton);
    }
    // Add to Cell button
    if (callbacks.addMessageToCell) {
        const addToButton = document.createElement('button');
        addToButton.className = 'jp-llm-ext-message-action-button';
        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addToButton.title = 'Add message to current cell';
        addToButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.addMessageToCell(messageText);
        });
        actionsDiv.appendChild(addToButton);
    }
    // Append the actions container if it has any buttons
    if (actionsDiv.hasChildNodes()) {
        messageDiv.appendChild(actionsDiv);
        console.log('Action buttons added to bot message:', actionsDiv); // Keep debug log
    }
}
/**
 * Renders a reference widget as an HTMLElement suitable for inline display
 * (e.g., within the input field or a message).
 *
 * @param type - The type of reference ('code', 'cell', 'file', 'dir').
 * @param data - The data associated with the reference (CodeRefData, path string, etc.).
 * @param refId - Optional reference ID (e.g., 'ref-1') to store on the element.
 * @returns An HTMLElement representing the widget.
 */
function renderReferenceWidgetInline(type, data, // string for file/dir paths
placeholder, // ADDED: The original placeholder text (e.g., @code[ref-1])
refId // Keep refId separate for map lookups if needed
) {
    const widget = document.createElement('span');
    widget.classList.add('jp-llm-ext-ref-widget', `jp-llm-ext-ref-${type}`);
    widget.contentEditable = 'false'; // Make the widget non-editable itself
    widget.style.display = 'inline-block'; // Ensure it behaves like a block for styling/selection
    widget.style.cursor = 'pointer'; // Change cursor to pointer to indicate clickability
    widget.dataset.placeholder = placeholder; // ADDED: Store the placeholder
    const displayTextSpan = document.createElement('span'); // Span for the main text
    const previewDiv = document.createElement('div'); // Div for the preview content
    previewDiv.className = 'jp-llm-ext-ref-preview';
    previewDiv.style.display = 'none'; // Initially hidden
    previewDiv.style.border = '1px solid var(--jp-border-color1)';
    previewDiv.style.padding = '4px';
    previewDiv.style.marginTop = '2px';
    previewDiv.style.fontSize = '0.9em';
    previewDiv.style.backgroundColor = 'var(--jp-layout-color0)';
    previewDiv.style.whiteSpace = 'pre-wrap'; // Preserve line breaks
    previewDiv.style.fontFamily = 'monospace';
    previewDiv.style.cursor = 'text'; // Keep text cursor for preview
    let displayText = '';
    let baseTitle = ''; // Tooltip for the main widget text, without preview
    let previewContent = '';
    switch (type) {
        case 'code':
        case 'cell': { // Combine logic for code and cell previews
            const refData = data;
            const isCode = type === 'code';
            const lines = refData.lineNumber === refData.lineEndNumber
                ? `L${refData.lineNumber}`
                : `L${refData.lineNumber}-${refData.lineEndNumber}`;
            displayText = isCode
                ? `@code (${refData.notebookName}:${lines})`
                : `@Cell (${refData.notebookName}:Cell ${refData.cellIndex + 1})`;
            baseTitle = isCode
                ? `Code: ${refData.notebookName}, Cell ${refData.cellIndex + 1}, ${lines}`
                : `Cell: ${refData.notebookName}, Index ${refData.cellIndex + 1}`;
            if (refId)
                widget.dataset.refId = refId;
            widget.dataset.notebookName = refData.notebookName;
            widget.dataset.cellIndex = String(refData.cellIndex);
            widget.dataset.content = refData.content; // Store content
            if (isCode) {
                widget.dataset.startLine = String(refData.lineNumber);
                widget.dataset.endLine = String(refData.lineEndNumber);
            }
            // Prepare preview content
            if (refData.content) {
                const contentLines = refData.content.split('\n');
                previewContent = contentLines.slice(0, 3).join('\n');
                if (contentLines.length > 3) {
                    previewContent += '\n...';
                }
            }
            break;
        }
        case 'file':
            const filePath = data;
            const fileName = filePath.split(/[\/\\]/).pop() || filePath; // Handle windows paths
            displayText = `@file (${fileName})`;
            baseTitle = `File: ${filePath}`; // Tooltip shows full path
            widget.dataset.path = filePath; // Store full path
            // No preview for files/dirs
            widget.style.cursor = 'default'; // No expansion for file/dir
            break;
        case 'dir':
            const dirPath = data;
            const dirName = dirPath.split(/[\/\\]/).pop() || dirPath || '/'; // Handle windows paths
            displayText = `@dir (${dirName})`;
            baseTitle = `Directory: ${dirPath}`; // Tooltip shows full path
            widget.dataset.path = dirPath; // Store full path
            // No preview for files/dirs
            widget.style.cursor = 'default'; // No expansion for file/dir
            break;
        default:
            displayText = '@unknown-ref';
            baseTitle = 'Unknown Reference';
            widget.style.cursor = 'default';
    }
    displayTextSpan.textContent = displayText;
    widget.title = baseTitle; // Set base tooltip for the main part
    widget.appendChild(displayTextSpan);
    // Add preview div and click listener only if there's preview content
    if (previewContent) {
        previewDiv.textContent = previewContent;
        widget.appendChild(previewDiv);
        // Add click listener to the main widget span to toggle preview
        widget.addEventListener('click', (event) => {
            // Prevent the click from propagating to the input div listener if needed
            event.stopPropagation();
            const isHidden = previewDiv.style.display === 'none';
            previewDiv.style.display = isHidden ? 'block' : 'none';
            // Optional: Change an indicator icon here
        });
        // Prevent clicks *inside* the preview div from closing it
        previewDiv.addEventListener('click', (event) => {
            event.stopPropagation();
        });
    }
    else {
        // Ensure cursor remains default if no preview/expansion
        widget.style.cursor = 'default';
    }
    return widget;
}
// Potential future additions:
// - renderErrorMessage
// - renderSystemMessage
// - A main renderMessage function that delegates based on type? 
/**
 * Handles rendering individual messages (user, bot, system) into HTML elements.
 */
class MessageRenderer {
    // private callbacks: MessageRendererCallbacks; // Removed unused member
    // private uiManager: UIManager; // Might not be needed directly if callbacks handle UI updates
    constructor( /* callbacks: MessageRendererCallbacks */ /* , uiManager: UIManager */) {
        // this.callbacks = callbacks; // Removed unused assignment
        // this.uiManager = uiManager;
    }
}
exports.MessageRenderer = MessageRenderer;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/note-modal.js":
/*!********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/note-modal.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNoteModalElement = createNoteModalElement;
/**
 * Creates a note modal element.
 * @param callbacks Callbacks for the modal actions.
 * @param initialTitle Optional initial title for editing.
 * @param initialContent Optional initial content for editing.
 * @returns The modal element.
 */
function createNoteModalElement(callbacks, initialTitle = '', initialContent = '') {
    // Create backdrop for the modal
    const modalBackdrop = document.createElement('div');
    modalBackdrop.className = 'jp-llm-ext-note-modal-backdrop';
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'jp-llm-ext-note-modal';
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.className = 'jp-llm-ext-note-modal-content';
    // Create modal title
    const modalTitle = document.createElement('h3');
    modalTitle.className = 'jp-llm-ext-note-modal-title';
    modalTitle.textContent = initialTitle ? 'Edit Note' : 'Add New Note';
    modalContent.appendChild(modalTitle);
    // Create form
    const form = document.createElement('form');
    form.className = 'jp-llm-ext-note-modal-form';
    form.addEventListener('submit', (e) => {
        e.preventDefault();
        const titleInput = form.querySelector('.jp-llm-ext-note-modal-input');
        const contentTextarea = form.querySelector('.jp-llm-ext-note-modal-textarea');
        if (titleInput && contentTextarea) {
            callbacks.handleSave(titleInput.value, contentTextarea.value);
        }
    });
    // Create title input
    const titleLabel = document.createElement('label');
    titleLabel.className = 'jp-llm-ext-note-modal-label';
    titleLabel.textContent = 'Title';
    titleLabel.htmlFor = 'note-title-input';
    const titleInput = document.createElement('input');
    titleInput.className = 'jp-llm-ext-note-modal-input';
    titleInput.type = 'text';
    titleInput.id = 'note-title-input';
    titleInput.placeholder = 'Enter note title';
    titleInput.value = initialTitle;
    titleInput.required = true;
    // Create content textarea
    const contentLabel = document.createElement('label');
    contentLabel.className = 'jp-llm-ext-note-modal-label';
    contentLabel.textContent = 'Content (Markdown supported)';
    contentLabel.htmlFor = 'note-content-textarea';
    const contentTextarea = document.createElement('textarea');
    contentTextarea.className = 'jp-llm-ext-note-modal-textarea';
    contentTextarea.id = 'note-content-textarea';
    contentTextarea.placeholder = 'Enter note content (supports Markdown)';
    contentTextarea.value = initialContent;
    contentTextarea.required = true;
    contentTextarea.rows = 10;
    // Create buttons
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'jp-llm-ext-note-modal-buttons';
    const cancelButton = document.createElement('button');
    cancelButton.className = 'jp-Button jp-llm-ext-note-modal-cancel';
    cancelButton.textContent = 'Cancel';
    cancelButton.type = 'button';
    cancelButton.addEventListener('click', () => {
        callbacks.handleCancel();
    });
    const saveButton = document.createElement('button');
    saveButton.className = 'jp-Button jp-llm-ext-note-modal-save';
    saveButton.textContent = 'Save';
    saveButton.type = 'submit';
    // Add elements to form
    form.appendChild(titleLabel);
    form.appendChild(titleInput);
    form.appendChild(contentLabel);
    form.appendChild(contentTextarea);
    buttonsContainer.appendChild(cancelButton);
    buttonsContainer.appendChild(saveButton);
    form.appendChild(buttonsContainer);
    modalContent.appendChild(form);
    modal.appendChild(modalContent);
    modalBackdrop.appendChild(modal);
    // Auto-focus the title input when the modal is shown
    setTimeout(() => {
        titleInput.focus();
    }, 0);
    return modalBackdrop;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js":
/*!************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsModal = void 0;
exports.createSettingsModalElement = createSettingsModalElement;
/**
 * Creates the HTML element for the settings modal.
 * @param callbacks Callbacks for save and cancel actions.
 * @returns The main modal HTMLElement.
 */
function createSettingsModalElement(callbacks) {
    const modal = document.createElement('div');
    modal.className = 'jp-llm-ext-settings-modal';
    modal.style.display = 'none'; // Initially hidden
    const content = document.createElement('div');
    content.className = 'jp-llm-ext-settings-content';
    const title = document.createElement('h2');
    title.className = 'jp-llm-ext-settings-title';
    title.textContent = 'Settings';
    content.appendChild(title);
    const form = document.createElement('form');
    form.className = 'jp-llm-ext-settings-form';
    // Provider selection
    const providerLabel = document.createElement('label');
    providerLabel.className = 'jp-llm-ext-settings-label';
    providerLabel.textContent = 'API Provider:';
    form.appendChild(providerLabel);
    const providerSelect = document.createElement('select');
    providerSelect.className = 'jp-llm-ext-settings-select';
    providerSelect.id = 'settings-provider'; // Keep ID for retrieval
    ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        providerSelect.appendChild(option);
    });
    form.appendChild(providerSelect);
    // API Key input
    const apiKeyLabel = document.createElement('label');
    apiKeyLabel.className = 'jp-llm-ext-settings-label';
    apiKeyLabel.textContent = 'API Key:';
    form.appendChild(apiKeyLabel);
    const apiKeyInput = document.createElement('input');
    apiKeyInput.className = 'jp-llm-ext-settings-input';
    apiKeyInput.type = 'password';
    apiKeyInput.id = 'settings-api-key'; // Keep ID for retrieval
    form.appendChild(apiKeyInput);
    // API URL input
    const apiUrlLabel = document.createElement('label');
    apiUrlLabel.className = 'jp-llm-ext-settings-label';
    apiUrlLabel.textContent = 'API URL (optional):';
    form.appendChild(apiUrlLabel);
    const apiUrlInput = document.createElement('input');
    apiUrlInput.className = 'jp-llm-ext-settings-input';
    apiUrlInput.type = 'text';
    apiUrlInput.id = 'settings-api-url'; // Keep ID for retrieval
    form.appendChild(apiUrlInput);
    // Rules input
    const rulesLabel = document.createElement('label');
    rulesLabel.className = 'jp-llm-ext-settings-label';
    rulesLabel.textContent = 'Custom Rules (optional):';
    form.appendChild(rulesLabel);
    const rulesInput = document.createElement('textarea');
    rulesInput.className = 'jp-llm-ext-settings-textarea';
    rulesInput.id = 'settings-rules'; // Keep ID for retrieval
    form.appendChild(rulesInput);
    // Buttons container
    const btnContainer = document.createElement('div');
    btnContainer.className = 'jp-llm-ext-settings-buttons';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';
    saveBtn.textContent = 'Save';
    saveBtn.type = 'button'; // Prevent default form submission
    saveBtn.addEventListener('click', (event) => {
        event.preventDefault();
        // The callback implementation will handle reading values and saving
        const settings = {
            apiKey: apiKeyInput.value,
            apiUrl: apiUrlInput.value,
            rules: rulesInput.value,
            provider: providerSelect.value
        };
        callbacks.handleSave(settings);
    });
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.type = 'button'; // Prevent default form submission
    cancelBtn.addEventListener('click', (event) => {
        event.preventDefault();
        callbacks.handleCancel();
    });
    btnContainer.appendChild(saveBtn);
    btnContainer.appendChild(cancelBtn);
    form.appendChild(btnContainer);
    content.appendChild(form);
    modal.appendChild(content);
    return modal;
}
/**
 * Creates and manages the settings modal dialog.
 */
class SettingsModal {
    // private modalElement: HTMLDivElement; // Commented out - unused
    // private settings: AppSettings; // Commented out - unused
    constructor(callbacks) {
        // this.modalElement = createSettingsModalElement(callbacks); // Commented out - unused assignment
        // this.settings = { // Commented out - unused initialization
        //     provider: '', 
        //     apiKey: '', 
        //     apiUrl: '', 
        //     rules: '' 
        // }; 
    }
}
exports.SettingsModal = SettingsModal;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js":
/*!********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIManager = void 0;
/**
 * Manages UI elements and transitions for the chat interface.
 * This acts as a central point for UI manipulations, simplifying dependencies for handlers.
 */
class UIManager {
    constructor(popupMenuManager, callbacks, layoutElements) {
        this.notificationTimeout = null; // Timeout for the shortcut indicator
        // Internal UI state
        this.isInputExpanded = false;
        this.isMarkdownMode = false;
        this.popupMenuManager = popupMenuManager;
        this.callbacks = callbacks;
        this.layoutElements = layoutElements; // Store the layout elements passed in
        // Assign class properties directly from the passed layoutElements
        this.inputField = layoutElements.inputField; // Use provided input field
        this.messageContainer = layoutElements.messageContainer;
        this.historyContainer = layoutElements.historyContainer;
        this.titleInput = layoutElements.titleInput;
        this.bottomBarContainer = layoutElements.bottomBarContainer;
        this.notesContainer = layoutElements.notesContainer;
        // Initialize and append the keyboard shortcut indicator
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'jp-llm-ext-shortcut-indicator';
        this.keyboardShortcutIndicator.style.display = 'none'; // Hidden by default
        // Append the indicator to the main layout or another appropriate place
        // Ensure the necessary element (e.g., bottomBarContainer) exists before appending
        if (this.bottomBarContainer) { // Check if bottomBarContainer exists from layoutElements
            // Prepend within the main content wrapper, before other elements
            // Or append to bottom bar, depending on desired position
            // Appending after bottomBarContainer seems reasonable
            this.bottomBarContainer.insertAdjacentElement('afterend', this.keyboardShortcutIndicator);
        }
        else {
            // If bottomBarContainer is not available, maybe append to mainElement? 
            // Or log an error if it's essential.
            console.error('UIManager: bottomBarContainer element not found during indicator initialization.');
        }
    }
    /**
     * Returns the core layout elements.
     */
    getUIElements() {
        return this.layoutElements;
    }
    /**
     * Creates the main layout structure for the sidebar.
     * @returns References to key DOM elements.
     */
    createLayout() {
        // Create the main container
        const mainContent = document.createElement('div');
        mainContent.className = 'jp-llm-ext-content-wrapper';
        // --- Title Container ---
        const titleContainer = document.createElement('div');
        titleContainer.className = 'jp-llm-ext-title-container';
        this.titleInput = document.createElement('input');
        this.titleInput.className = 'chat-title-input';
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat'; // Default value, widget might update later
        this.titleInput.addEventListener('change', this.callbacks.handleUpdateTitle);
        titleContainer.appendChild(this.titleInput);
        // --- Message & History Containers ---
        this.messageContainer = document.createElement('div');
        this.messageContainer.className = 'jp-llm-ext-message-container';
        this.historyContainer = document.createElement('div');
        this.historyContainer.className = 'jp-llm-ext-history-container';
        this.historyContainer.style.display = 'none'; // Initially hidden
        // --- Bottom Bar ---
        this.bottomBarContainer = document.createElement('div');
        this.bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';
        // Controls Row (Markdown Toggle, Action Buttons)
        const topRow = document.createElement('div');
        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';
        const controlsContainer = this.createControlsContainer(); // Creates markdown toggle, @, expand, settings
        topRow.appendChild(controlsContainer);
        // Input Row
        const middleRow = document.createElement('div');
        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';
        this.inputField = document.createElement('div');
        this.inputField.setAttribute('contenteditable', 'true');
        this.inputField.setAttribute('role', 'textbox');
        this.inputField.setAttribute('aria-multiline', 'true');
        this.inputField.setAttribute('data-placeholder', 'Ask me anything...');
        this.inputField.className = 'jp-llm-ext-input-field';
        // --- Input Event Listener for @ detection ---
        this.inputField.addEventListener('input', (event) => {
            this.handleInputForReference();
        });
        // --- End Input Event Listener ---
        this.inputField.addEventListener('keydown', (event) => {
            console.log(`UI_MANAGER KeyDown: Key='${event.key}', Shift='${event.shiftKey}', Code='${event.code}'`);
            const selection = window.getSelection();
            // --- Backspace handling for widgets ---
            if (event.key === 'Backspace' && selection && selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                const nodeBefore = range.startContainer.childNodes[range.startOffset - 1] || range.startContainer.previousSibling;
                // Check nodeBefore more carefully
                let potentialWidget = null;
                if (range.startOffset > 0 && range.startContainer.childNodes.length >= range.startOffset) {
                    potentialWidget = range.startContainer.childNodes[range.startOffset - 1];
                }
                else if (range.startOffset === 0 && range.startContainer.previousSibling) {
                    potentialWidget = range.startContainer.previousSibling;
                }
                else if (range.startContainer !== this.inputField && range.startContainer.parentNode === this.inputField && range.startOffset === 0) {
                    // Cursor might be at the start of a text node following a widget
                    potentialWidget = range.startContainer.previousSibling;
                }
                if (potentialWidget &&
                    potentialWidget.nodeType === Node.ELEMENT_NODE &&
                    potentialWidget.classList.contains('jp-llm-ext-ref-widget')) {
                    event.preventDefault(); // Stop default backspace
                    potentialWidget.remove(); // Remove the entire widget node
                    // Manually trigger input event for consistency?
                    this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    return; // Stop further processing for this keydown
                }
            }
            // --- End Backspace handling ---
            // --- @ Key Direct Handling ---
            // REMOVED: This logic is now centralized in shortcut-handler.ts
            // --- End @ Key Direct Handling ---
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default newline insertion
                const message = this.getSerializedInput();
                if (message.trim()) {
                    console.log(`[UIManager] Sending message with markdown mode: ${this.isMarkdownMode}`);
                    this.callbacks.handleSendMessage(message, this.isMarkdownMode);
                    this.clearInputField();
                }
            }
            // --- New: Handle Tab/Escape for popup interaction ---
            else if (this.popupMenuManager.isPopupMenuVisible()) {
                if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'Enter') {
                    // Let the PopupMenuManager's document keydown handler manage these
                    // We just need to prevent the default input field behavior
                    if (event.key !== 'Enter') { // Allow Enter to potentially work if menu doesn't handle it
                        event.preventDefault();
                        // We don't stop propagation here; let the document handler in PopupMenuManager receive it.
                    }
                }
            }
            // --- End New ---
        });
        // --- Copy/Paste Event Listeners ---
        this.inputField.addEventListener('copy', (event) => {
            this.handleCopy(event);
        });
        this.inputField.addEventListener('paste', (event) => {
            this.handlePaste(event);
        });
        // --- End Copy/Paste ---
        middleRow.appendChild(this.inputField);
        // Buttons Row (Send, New Chat, History)
        const bottomRow = document.createElement('div');
        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';
        const sendButton = this.createButton('Send', 'Send message');
        sendButton.classList.add('jp-llm-ext-send-button'); // Specific class for send
        sendButton.addEventListener('click', () => {
            const message = this.getSerializedInput();
            if (message.trim()) {
                console.log(`[UIManager] Sending message from button click with markdown mode: ${this.isMarkdownMode}`);
                this.callbacks.handleSendMessage(message, this.isMarkdownMode);
                this.clearInputField();
            }
        });
        const newChatButton = this.createButton('+ New Chat', 'Start a new chat');
        newChatButton.addEventListener('click', this.callbacks.handleNewChat);
        const historyButton = this.createButton('History', 'View chat history');
        historyButton.addEventListener('click', this.callbacks.handleToggleHistory);
        bottomRow.appendChild(sendButton);
        bottomRow.appendChild(newChatButton);
        bottomRow.appendChild(historyButton);
        // Assemble Bottom Bar
        this.bottomBarContainer.appendChild(topRow);
        this.bottomBarContainer.appendChild(middleRow);
        this.bottomBarContainer.appendChild(bottomRow);
        // --- Assemble Main Content ---
        mainContent.appendChild(titleContainer);
        mainContent.appendChild(this.messageContainer);
        mainContent.appendChild(this.historyContainer);
        mainContent.appendChild(this.bottomBarContainer);
        // Return references to key elements
        return {
            mainLayout: mainContent,
            messageContainer: this.messageContainer,
            inputField: this.inputField,
            titleInput: this.titleInput,
            historyContainer: this.historyContainer,
            bottomBarContainer: this.bottomBarContainer,
            notesContainer: this.notesContainer,
        };
    }
    /**
     * Creates the controls container with toggles and action buttons.
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'jp-llm-ext-controls-container';
        // --- Markdown Toggle ---
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'jp-llm-ext-toggle-container';
        this.markdownToggle = document.createElement('input');
        this.markdownToggle.type = 'checkbox';
        this.markdownToggle.id = 'markdown-toggle'; // Ensure unique ID or handle differently
        this.markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            console.log(`[UIManager] Markdown mode changed to: ${this.isMarkdownMode}`);
            const placeholderText = this.isMarkdownMode
                ? 'Write markdown here...\\n\\n# Example heading\\n- List item\\n\\n```code block```'
                : 'Ask me anything...';
            this.inputField.setAttribute('data-placeholder', placeholderText);
            this.inputField.blur();
            this.inputField.focus();
        });
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        toggleContainer.appendChild(this.markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // --- Action Buttons (@, Expand, Settings) ---
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';
        // '@' Button
        const atButton = this.createButton('@', 'Browse cells, code, files, and more');
        atButton.addEventListener('click', (event) => {
            this.callbacks.handleShowPopupMenu(event, event.currentTarget);
        });
        // Expand Button (store reference)
        this.expandButton = this.createButton('⤢', 'Expand input');
        this.expandButton.addEventListener('click', () => this.toggleInputExpansion());
        // Settings Button
        const settingsButton = this.createButton('⚙️', 'Settings');
        settingsButton.addEventListener('click', this.callbacks.handleShowSettings);
        // Add buttons to container
        actionButtonsContainer.appendChild(atButton);
        actionButtonsContainer.appendChild(this.expandButton);
        actionButtonsContainer.appendChild(settingsButton);
        // Assemble Controls Container
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field.
     */
    toggleInputExpansion() {
        if (!this.inputField || !this.expandButton)
            return; // Ensure elements exist
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            this.inputField.style.height = '200px'; // Keep for now, consider CSS classes
            this.inputField.style.resize = 'vertical'; // Works on divs too (if overflow visible/auto)
            this.expandButton.textContent = '⤡';
            this.expandButton.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = ''; // Reset height
            this.inputField.style.resize = 'none';
            this.expandButton.textContent = '⤢';
            this.expandButton.title = 'Expand input';
        }
        // Future: Notify widget/handler if needed: this.callbacks.handleToggleExpansion(this.isInputExpanded);
    }
    /**
     * Helper function to create a styled button.
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        // Apply base JupyterLab button class and our specific class
        button.className = 'jp-Button jp-llm-ext-action-button';
        return button;
    }
    /**
     * Appends a new chat message element to the message container and scrolls down.
     * @param element The message element (user or bot) to add.
     */
    addChatMessageElement(element) {
        if (this.messageContainer) {
            this.messageContainer.appendChild(element);
            this.scrollToBottom(); // Scroll after adding the new element
        }
        else {
            console.error('Message container not initialized in UIManager.');
        }
    }
    /**
     * Scrolls the message container to the bottom.
     */
    scrollToBottom() {
        if (this.messageContainer) {
            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        }
        else {
            console.error('Message container not initialized in UIManager.');
        }
    }
    /**
     * Switches the view to show the notes.
     */
    showNotesView() {
        this.layoutElements.messageContainer.style.display = 'none';
        this.layoutElements.historyContainer.style.display = 'none';
        this.layoutElements.notesContainer.style.display = 'block';
        this.layoutElements.bottomBarContainer.style.display = 'none';
    }
    /**
     * Switches the view to show the chat history.
     */
    showHistoryView() {
        this.layoutElements.messageContainer.style.display = 'none';
        this.layoutElements.historyContainer.style.display = 'block';
        this.layoutElements.notesContainer.style.display = 'none';
        this.layoutElements.bottomBarContainer.style.display = 'none';
        // Optionally update header/title elements if needed
    }
    /**
     * Switches the view to show the main chat interface.
     */
    showChatView() {
        this.layoutElements.historyContainer.style.display = 'none';
        this.layoutElements.notesContainer.style.display = 'none';
        this.layoutElements.messageContainer.style.display = 'block';
        this.layoutElements.bottomBarContainer.style.display = 'flex'; // Assuming flex display
        this.scrollToBottom(); // Scroll down when showing chat
    }
    /**
     * Clears all messages from the message container.
     */
    clearMessageContainer() {
        this.layoutElements.messageContainer.innerHTML = '';
    }
    /**
     * Updates the value of the title input field.
     */
    updateTitleInput(title) {
        if (this.layoutElements.titleInput) {
            this.layoutElements.titleInput.value = title;
        }
    }
    /**
     * Creates and returns a container structure for a bot message,
     * including elements for streaming text and final rendered content.
     * This helps manage the transition from streaming to final message display.
     */
    createBotMessageContainer() {
        const botMessageDiv = document.createElement('div');
        botMessageDiv.className = 'jp-llm-ext-bot-message'; // Base class
        // Div for streaming content (initially visible)
        const streamingDiv = document.createElement('div');
        streamingDiv.className = 'jp-llm-ext-streaming-content';
        streamingDiv.style.display = 'block'; // Show streaming initially
        // Div for final rendered content (initially hidden)
        const contentDiv = document.createElement('div');
        contentDiv.className = 'jp-llm-ext-rendered-content';
        contentDiv.style.display = 'none'; // Hide final content initially
        botMessageDiv.appendChild(streamingDiv);
        botMessageDiv.appendChild(contentDiv);
        // Add the whole container to the message list *before* streaming starts
        this.addChatMessageElement(botMessageDiv);
        return { botMessageDiv, streamingDiv, contentDiv };
    }
    /**
     * Displays a temporary notification message.
     * TODO: Implement a more robust notification system (e.g., toast).
     */
    showNotification(message, type, duration = 3000) {
        console.log(`Notification (${type}): ${message}`);
        // Basic temporary implementation using the existing indicator element
        const indicator = this.layoutElements.mainElement.querySelector('.jp-llm-ext-keyboard-shortcut-indicator');
        if (indicator) {
            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout); // Clear previous timeout
            }
            indicator.textContent = message;
            indicator.className = `jp-llm-ext-keyboard-shortcut-indicator visible jp-llm-ext-notification-${type}`; // Add type class
            this.notificationTimeout = window.setTimeout(() => {
                indicator.classList.remove('visible');
                this.notificationTimeout = null;
            }, duration);
        }
        else {
            console.warn('Notification indicator element not found for UIManager.');
        }
    }
    /**
     * Shows a visual indicator for keyboard shortcuts.
     * @param text The text to display in the indicator.
     */
    showIndicator(text) {
        if (!this.keyboardShortcutIndicator)
            return; // Guard
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Clear any existing timeout to prevent multiple timeouts running
        if (this.notificationTimeout) {
            clearTimeout(this.notificationTimeout);
        }
        // Set new timeout to hide the indicator
        this.notificationTimeout = window.setTimeout(() => {
            if (this.keyboardShortcutIndicator) { // Check if element still exists
                this.keyboardShortcutIndicator.classList.remove('visible');
            }
            this.notificationTimeout = null;
        }, 1000); // Hide after 1 second
    }
    /**
     * Clears the indicator immediately and cancels any pending hide timeout.
     * Useful if the widget is hidden while the indicator is shown.
     */
    clearIndicator() {
        if (!this.keyboardShortcutIndicator)
            return;
        this.keyboardShortcutIndicator.classList.remove('visible');
        this.keyboardShortcutIndicator.textContent = '';
        if (this.notificationTimeout) {
            clearTimeout(this.notificationTimeout);
            this.notificationTimeout = null;
        }
    }
    /**
     * Checks the input field content and cursor position to determine if
     * the reference suggestion popup should be shown or hidden.
     * Triggered on 'input' events.
     */
    handleInputForReference() {
        var _a, _b;
        const selection = window.getSelection();
        if (!selection || !selection.rangeCount || !selection.isCollapsed) {
            // Need a collapsed selection (cursor) inside the input field
            this.popupMenuManager.hidePopupMenu();
            return;
        }
        const range = selection.getRangeAt(0);
        const container = range.startContainer;
        const offset = range.startOffset;
        // Ensure the cursor is within the input field itself
        if (!this.inputField.contains(container)) {
            this.popupMenuManager.hidePopupMenu();
            return;
        }
        // Combine text content from preceding siblings if cursor is at the start of a text node
        let textBeforeCursor = '';
        let currentContainer = container;
        let currentOffset = offset;
        while (currentContainer) {
            if (currentContainer.nodeType === Node.TEXT_NODE) {
                textBeforeCursor = ((_a = currentContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, currentOffset)) + textBeforeCursor;
            }
            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.classList.contains('jp-llm-ext-ref-widget')) {
                // If we encounter a widget before the cursor, we can't be right after '@'
                textBeforeCursor = '[widget]' + textBeforeCursor; // Add placeholder to break '@' sequence
            }
            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.tagName === 'BR') {
                textBeforeCursor = '\n' + textBeforeCursor; // Treat BR as newline
            }
            // Move to the previous sibling or parent's previous sibling
            if (currentContainer.previousSibling) {
                currentContainer = currentContainer.previousSibling;
                // If moving to a new node, take its full content
                currentOffset = (currentContainer.textContent || '').length;
            }
            else {
                // Move up to parent, continue search from before the parent
                currentContainer = currentContainer.parentNode;
                if (currentContainer === this.inputField || !currentContainer) {
                    break; // Stop if we reached the input field or top
                }
                currentOffset = Array.prototype.indexOf.call(((_b = currentContainer.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes) || [], currentContainer);
            }
        }
        console.log(`UI_MANAGER handleInput: Text before cursor: "${textBeforeCursor}"`);
        // --- Check for trigger conditions --- 
        const endsWithAt = textBeforeCursor.endsWith('@');
        const endsWithAtSpace = textBeforeCursor.endsWith('@ ');
        if (endsWithAt || endsWithAtSpace) {
            if (this.popupMenuManager.isPopupMenuVisible()) {
                // TODO: If visible, maybe just update the query in the popup?
                console.log('UI_MANAGER handleInput: Popup already visible, skipping show.');
            }
            else {
                // Find the start of the query (after '@' or '@ ')
                const atIndex = textBeforeCursor.lastIndexOf('@');
                let queryStartIndex = atIndex + 1;
                if (endsWithAtSpace) {
                    queryStartIndex = atIndex + 2;
                }
                const query = textBeforeCursor.substring(queryStartIndex);
                // --- Insert temporary span to get reliable coordinates --- 
                const tempAnchorId = 'jp-llm-temp-popup-anchor';
                let tempSpan = document.getElementById(tempAnchorId);
                if (tempSpan)
                    tempSpan.remove(); // Clean up previous if any
                tempSpan = document.createElement('span');
                tempSpan.id = tempAnchorId;
                // Style to be invisible and take no space
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.width = '0';
                tempSpan.style.height = '0';
                tempSpan.style.overflow = 'hidden';
                tempSpan.textContent = '\u200B'; // Zero-width space might help rendering
                // Insert the span at the current cursor position
                range.insertNode(tempSpan);
                const spanRect = tempSpan.getBoundingClientRect();
                tempSpan.remove(); // Remove immediately after getting coords
                // --- End temporary span logic ---
                if (spanRect.top === 0 && spanRect.left === 0) {
                    console.error("UI_MANAGER handleInput: Failed to get valid coordinates from temp anchor span.");
                    // Fallback or alternative positioning might be needed here
                    // Maybe position relative to input field bottom-left?
                    this.popupMenuManager.hidePopupMenu(); // Don't show if coords are bad
                }
                else {
                    console.log(`UI_MANAGER handleInput: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);
                    // Show the TOP LEVEL suggestions using the reliable coordinates
                    // Pass the coordinates directly to showPopupMenu
                    this.popupMenuManager.showPopupMenu({ x: spanRect.left, y: spanRect.top });
                }
            }
        }
        else {
            // If text doesn't end with @ or @-space, hide the popup
            // Only hide if it was previously showing the 'top' or 'references' menu triggered by '@'
            // Avoid hiding menus triggered by the button click unnecessarily
            if (this.popupMenuManager.isPopupMenuVisible()) { // && (this.popupMenuManager.getCurrentMenuLevel() === 'references' || /* Need way to know if triggered by @ */ )) {
                console.log('UI_MANAGER handleInput: Hiding popup, trigger condition no longer met.');
                this.popupMenuManager.hidePopupMenu();
            }
        }
        // TODO: Update popup query if it's already visible and the text after @ changes
        // (Need more robust logic here, considering backspace, etc.)
    }
    /**
     * Serializes the content of the input field, converting known widgets
     * back to their reference strings (e.g., @file:path/to/file.txt).
     *
     * NOTE: This currently uses a simple text serialization. For full fidelity
     * preserving structure (like multiple paragraphs), a more complex approach
     * (e.g., HTML processing or a dedicated editor model) would be needed.
     *
     * @returns {string} The serialized plain text content of the input field.
     */
    getSerializedInput() {
        let serialized = '';
        const nodes = this.inputField.childNodes;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.nodeType === Node.TEXT_NODE) {
                serialized += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {
                    // Append the reference text stored in the data attribute
                    serialized += element.dataset.referenceText;
                }
                else if (element.tagName === 'BR') {
                    // Convert BR tags back to newlines
                    serialized += '\n';
                }
                else if (element.tagName === 'DIV') {
                    // Handle DIV elements (might be inserted by browser on paste/enter)
                    // Add newline before if needed, then serialize children recursively?
                    if (i > 0) { // Add newline only if not the first element
                        serialized += '\n';
                    }
                    serialized += this.serializeNodeChildren(element); // Recursively serialize children
                }
                else {
                    // Include text content of other unexpected elements, but log a warning
                    console.warn('UIManager getSerializedInput: Encountered unexpected element:', element.tagName);
                    serialized += element.textContent;
                }
            } // Ignore other node types (comments, etc.)
        }
        return serialized.trim(); // Trim leading/trailing whitespace
    }
    // Helper to serialize children of a node (e.g., for DIVs)
    serializeNodeChildren(parentNode) {
        let content = '';
        const nodes = parentNode.childNodes;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.nodeType === Node.TEXT_NODE) {
                content += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {
                    content += element.dataset.referenceText;
                }
                else if (element.tagName === 'BR') {
                    content += '\n';
                }
                else {
                    // Recursively handle nested elements if necessary, or just get text content
                    content += this.serializeNodeChildren(element);
                }
            }
        }
        return content;
    }
    clearInputField() {
        this.inputField.innerHTML = ''; // Clear all content
        // Reset expansion state if needed
        if (this.isInputExpanded) {
            this.toggleInputExpansion();
        }
        // Ensure placeholder reappears if using CSS for it
        this.inputField.dispatchEvent(new Event('input')); // Trigger event to update UI state if necessary
    }
    /**
     * Handles the 'copy' event to put serialized plain text onto the clipboard.
     */
    handleCopy(event) {
        const selection = window.getSelection();
        if (!selection || selection.isCollapsed || !event.clipboardData) {
            return; // Nothing selected or no clipboard data object
        }
        const range = selection.getRangeAt(0);
        // Ensure the selection is within our input field
        if (!this.inputField.contains(range.commonAncestorContainer)) {
            return;
        }
        const selectedText = this.serializeRangeContent(range);
        event.preventDefault(); // Prevent default copy behavior
        event.clipboardData.setData('text/plain', selectedText);
        console.log('UIManager handleCopy: Copied serialized text:', selectedText);
    }
    /**
     * Handles the 'paste' event to insert plain text content.
     */
    handlePaste(event) {
        var _a;
        if (!event.clipboardData) {
            return;
        }
        const text = event.clipboardData.getData('text/plain');
        if (text) {
            event.preventDefault(); // Prevent default paste behavior
            // Insert the plain text at the current cursor position
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                range.deleteContents(); // Delete selected content if any
                const textNode = document.createTextNode(text);
                range.insertNode(textNode);
                // Move cursor after inserted text
                range.setStartAfter(textNode);
                range.setEndAfter(textNode);
                selection.removeAllRanges();
                selection.addRange(range);
                // Ensure scroll into view and trigger input event for potential updates
                this.inputField.focus();
                (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'nearest' });
                this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }
            console.log('UIManager handlePaste: Pasted text:', text);
        }
    }
    // --- Methods for updating UI elements will be added later ---
    // e.g., updateMessageContainer(html: string), showHistoryView(), showChatView()
    // --- Potentially add methods to get element references if needed externally ---
    // public getInputField(): HTMLTextAreaElement { return this.inputField; }
    // etc.
    // Helper to serialize a range (needed for copy)
    serializeRangeContent(range) {
        const fragment = range.cloneContents();
        let tempDiv = document.createElement('div');
        tempDiv.appendChild(fragment);
        // Now, serialize tempDiv's content like we do for getSerializedInput
        let serialized = '';
        const nodes = tempDiv.childNodes;
        const serializeNode = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
                serialized += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {
                    serialized += element.dataset.referenceText;
                }
                else if (element.tagName === 'BR') {
                    serialized += '\n';
                }
                else { // For other elements (like DIVs potentially in fragment), serialize children
                    const childNodes = element.childNodes;
                    for (let j = 0; j < childNodes.length; j++) {
                        serializeNode(childNodes[j]);
                    }
                }
            }
        };
        for (let i = 0; i < nodes.length; i++) {
            serializeNode(nodes[i]);
        }
        return serialized;
    }
}
exports.UIManager = UIManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/clipboard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/clipboard.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.copyToClipboard = copyToClipboard;
exports.copyMessageToClipboard = copyMessageToClipboard;
exports.copyImageToClipboard = copyImageToClipboard;
/**
 * Helper function to copy text to clipboard.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyToClipboard(text, feedbackCallback) {
    try {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Content copied to clipboard');
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(); // Call optional feedback callback
        }).catch(err => {
            console.error('Failed to copy text: ', err);
        });
    }
    catch (error) {
        console.error('Error copying text to clipboard:', error);
    }
}
/**
 * Copies message content to clipboard.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyMessageToClipboard(text, feedbackCallback) {
    try {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Message content copied to clipboard');
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success
        }).catch(err => {
            console.error('Failed to copy message text: ', err);
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
        });
    }
    catch (error) {
        console.error('Error copying message to clipboard:', error);
        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
    }
}
/**
 * Copies an image to the clipboard from a given URL.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyImageToClipboard(imageUrl, feedbackCallback) {
    try {
        fetch(imageUrl)
            .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.statusText}`);
            }
            return response.blob();
        })
            .then(blob => {
            // Create a ClipboardItem with the image blob
            // Note: ClipboardItem might not be defined in all environments
            // You might need to add `"dom.iterable"` to tsconfig lib or handle appropriately.
            const item = new ClipboardItem({ [blob.type]: blob });
            navigator.clipboard.write([item]).then(() => {
                console.log('Image copied to clipboard');
                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success
            })
                .catch(err => {
                console.error('Failed to copy image to clipboard: ', err);
                alert('Failed to copy image: ' + err.message); // Keep alert for critical user feedback
                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
            });
        })
            .catch(err => {
            console.error('Failed to fetch or process image: ', err);
            alert('Failed to fetch image: ' + err.message); // Keep alert for critical user feedback
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
        });
    }
    catch (error) {
        console.error('Error preparing image copy:', error);
        alert('Error copying image: ' + error); // Keep alert for critical user feedback
        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/content-editable-utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/content-editable-utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCaretPosition = getCaretPosition;
exports.setCaretPosition = setCaretPosition;
/**
 * Gets the caret position within a contenteditable element.
 * Returns the linear offset from the start of the element's text content.
 */
function getCaretPosition(element) {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0 || !element.contains(selection.anchorNode)) {
        // Check if selection is within the element
        return 0;
    }
    const range = selection.getRangeAt(0);
    // Create a range that spans from the beginning of the element to the caret
    const preCaretRange = range.cloneRange();
    preCaretRange.selectNodeContents(element);
    preCaretRange.setEnd(range.startContainer, range.startOffset);
    // The length of the text content within this pre-caret range is the position
    // Using toString() is generally more reliable than textContent for range length
    return preCaretRange.toString().length;
}
/**
 * Sets the caret position within a contenteditable element.
 * @param element The contenteditable element.
 * @param position The desired linear offset from the start of the text content.
 */
function setCaretPosition(element, position) {
    var _a;
    const selection = window.getSelection();
    if (!selection) {
        return;
    }
    const range = document.createRange();
    let charCount = 0;
    let foundNode = false;
    let nodeStack = [element]; // Use a stack for DFS traversal
    // Depth-first search to find the correct text node and offset
    while (nodeStack.length > 0) {
        const node = nodeStack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const textLength = ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;
            if (position >= charCount && position <= charCount + textLength) {
                range.setStart(node, position - charCount);
                range.setEnd(node, position - charCount);
                foundNode = true;
                break; // Found the node, exit loop
            }
            charCount += textLength;
        }
        else if (node.nodeType === Node.ELEMENT_NODE) {
            const elementNode = node;
            if (elementNode.tagName === 'BR') {
                if (position === charCount) { // Position is right before BR
                    range.setStartBefore(node);
                    range.setEndBefore(node);
                    foundNode = true;
                    break;
                }
                charCount += 1; // Treat BR as one character
            }
            else if (elementNode.getAttribute('contenteditable') === 'false') {
                // Treat non-editable elements (like our widgets) as single characters
                if (position === charCount) {
                    // Position is right before the widget
                    range.setStartBefore(node);
                    range.setEndBefore(node);
                    foundNode = true;
                    break;
                }
                charCount += 1;
            }
            else {
                // Add child nodes to the stack in reverse order for correct DFS
                const children = node.childNodes;
                for (let i = children.length - 1; i >= 0; i--) {
                    nodeStack.push(children[i]);
                }
            }
        }
    }
    // If the position is beyond the content or wasn't found, place cursor at the end
    if (!foundNode) {
        range.selectNodeContents(element);
        range.collapse(false); // Collapse to the end
    }
    selection.removeAllRanges();
    selection.addRange(range);
    // Restore focus only if the element was previously focused or is the target
    // This avoids stealing focus unnecessarily
    if (document.activeElement !== element) {
        element.focus({ preventScroll: true }); // preventScroll helps avoid jumping
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/highlighting.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/highlighting.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detectLanguage = detectLanguage;
exports.highlightCode = highlightCode;
const highlight_js_1 = __importDefault(__webpack_require__(/*! highlight.js */ "webpack/sharing/consume/default/highlight.js/highlight.js"));
/**
 * Detects the programming language from code block content using highlight.js
 * and custom pattern matching for common languages.
 */
function detectLanguage(code) {
    try {
        // Try auto detection first with a limited set of common languages
        const result = highlight_js_1.default.highlightAuto(code, [
            'python', 'javascript', 'typescript', 'java',
            'html', 'css', 'cpp', 'csharp', 'sql', 'rust',
            'php', 'bash', 'json', 'xml', 'markdown'
        ]);
        // If confidence is reasonably high, use that language
        if (result.relevance > 5 && result.language) {
            return result.language;
        }
        // Fall back to basic pattern matching for better accuracy on ambiguous cases
        if (/^(?:\s*)?(?:import\s+[^;]+;|package\s+[^;]+;|public\s+class)/.test(code)) {
            return 'java';
        }
        else if (/^(?:\s*)?(import|from|def|class|if __name__)/.test(code)) {
            return 'python';
        }
        else if (/^(?:\s*)?(?:function|const|let|var|import|export|=>)/.test(code)) {
            // Broader check for JS/TS
            if (/^(?:\s*)?(?:import\s.+|export\s.+|interface|type|enum|declare|:|\s<)/.test(code)) {
                return 'typescript';
            }
            return 'javascript';
        }
        else if (/^(?:\s*)?(?:<!DOCTYPE|<html|<head|<body)/i.test(code)) {
            return 'html';
        }
        else if (/^(?:\s*)?#include/.test(code)) {
            return 'cpp';
        }
        else if (/^(?:\s*)?(?:using\s+System|namespace|public\s+static\s+void\s+Main)/.test(code)) {
            return 'csharp';
        }
        else if (/^(?:\s*)?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\s/i.test(code)) {
            return 'sql';
        }
        else if (/^(?:\s*)?(?:fn|let|struct|enum|trait|impl|mod)\s/.test(code)) {
            return 'rust';
        }
        else if (/^(?:\s*)?(?:<\?php|use\s+[\w\\]+;)/.test(code)) {
            return 'php';
        }
        else if (/^(?:\s*)?(?:#\s*!\/bin\/(?:bash|sh|zsh)|\$)/.test(code)) {
            return 'bash';
        }
        else if (/^\s*\{/.test(code) && /\}\s*$/.test(code)) {
            // Simple check for JSON-like structure
            return 'json';
        }
        else if (/^\s*<\?xml/.test(code) || /^\s*<\w+/.test(code)) {
            // Simple check for XML/HTML like structure
            return 'xml';
        }
        // If no specific language detected, return empty string for default handling
        return '';
    }
    catch (error) {
        console.error('Error detecting language:', error);
        return ''; // Return empty on error
    }
}
/**
 * Highlights code using highlight.js.
 * Falls back to auto-detection if the specified language is not supported.
 */
function highlightCode(code, language) {
    try {
        if (language && highlight_js_1.default.getLanguage(language)) {
            return highlight_js_1.default.highlight(code, { language, ignoreIllegals: true }).value;
        }
        else {
            // Fallback to auto-detection if language is empty or not registered
            return highlight_js_1.default.highlightAuto(code).value;
        }
    }
    catch (error) {
        console.error(`Error highlighting code (language: ${language || 'auto'}):`, error);
        // Return original code escaped for safety on error
        return code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Normalize line endings
    const normalizedText = text.replace(/\r\n/g, '\n');
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = normalizedText.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks:
        // 1. Handle list items with proper spacing
        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines
        let processed = line;
        // Handle dash list items by ensuring they have a space after the dash
        processed = processed.replace(/(\s*)-(\S)/g, '$1- $2');
        // Handle mixed space/dash issues - ensure proper newlines before list items
        processed = processed.replace(/([^\n\s])-\s/g, '$1\n- ');
        return processed;
    });
    // Join lines and ensure code blocks are properly formatted
    let result = processedLines.join('\n');
    // Handle empty code blocks (add a space so they render properly)
    result = result.replace(/```(.*)\n```/g, '```$1\n \n```');
    return result;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/markdown.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/markdown.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.renderMarkdown = renderMarkdown;
/**
 * Renders markdown text to HTML.
 * @param markdownText The markdown text to render
 * @returns HTML string
 */
function renderMarkdown(markdownText) {
    // This is a simple implementation. In a real app, you would use a library like marked.js
    if (!markdownText) {
        return '';
    }
    // Basic markdown conversion
    let html = markdownText
        // Handle headers
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^#### (.*$)/gm, '<h4>$1</h4>')
        .replace(/^##### (.*$)/gm, '<h5>$1</h5>')
        .replace(/^###### (.*$)/gm, '<h6>$1</h6>')
        // Handle bold
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/__(.*?)__/g, '<strong>$1</strong>')
        // Handle italic
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/_(.*?)_/g, '<em>$1</em>')
        // Handle links
        .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>')
        // Handle code blocks
        .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
        // Handle inline code
        .replace(/`(.*?)`/g, '<code>$1</code>')
        // Handle horizontal rules
        .replace(/^---$/gm, '<hr>')
        // Handle unordered lists
        .replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>')
        .replace(/^- (.*$)/gm, '<ul><li>$1</li></ul>')
        // Handle ordered lists
        .replace(/^\d+\. (.*$)/gm, '<ol><li>$1</li></ol>')
        // Handle blockquotes
        .replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>')
        // Handle paragraphs - ensures double newlines create p tags
        .replace(/\n\n/g, '</p><p>');
    // Wrap in paragraph if not already wrapped
    if (!html.startsWith('<')) {
        html = '<p>' + html + '</p>';
    }
    // Fix nested list items
    html = html
        .replace(/<\/ul>\s*<ul>/g, '')
        .replace(/<\/ol>\s*<ol>/g, '');
    return html;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addMessageToCell = addMessageToCell;
exports.getSelectedText = getSelectedText;
exports.isInNotebookCell = isInNotebookCell;
exports.isInNotebookCellAndEditorFocused = isInNotebookCellAndEditorFocused;
exports.isCodeCell = isCodeCell;
exports.isOutputArea = isOutputArea;
exports.getCurrentCellContent = getCurrentCellContent;
exports.insertCellContentByIndex = insertCellContentByIndex;
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
/**
 * Adds message content to the current cell in the active notebook.
 */
function addMessageToCell(text) {
    var _a;
    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (!cell || !cell.editor) {
        console.warn('Cannot add message: No active cell or editor found.');
        return;
    }
    try {
        const editor = cell.editor;
        // Access the underlying CodeMirror editor view (adjust if using a different editor)
        const view = editor.editor;
        if (!view) {
            console.warn('Cannot add message: CodeMirror view not accessible.');
            return;
        }
        // Get current cursor position
        const state = view.state;
        const selection = state.selection;
        const cursorPos = selection.main.head;
        // Insert newline and message content at cursor position
        const transaction = state.update({
            changes: {
                from: cursorPos,
                insert: `\n${text}`
            },
            // Optionally move cursor to end of inserted text
            selection: { anchor: cursorPos + text.length + 1 }
        });
        view.dispatch(transaction);
    }
    catch (error) {
        console.error('Error adding message to cell:', error);
    }
}
/**
 * Gets the currently selected text from:
 *  - the active notebook cell
 *  - the text editor
 *  - the output area of a code cell
 */
function getSelectedText() {
    var _a, _b, _c;
    // if (isOutputArea()) {
    //   // TODO: return what's selected in the output area
    //   return null;
    // }
    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (cell === null || cell === void 0 ? void 0 : cell.editor) {
        const editor = cell.editor;
        const cmEditor = editor.editor; // Access CodeMirror editor instance
        if (cmEditor && cmEditor.state) {
            const state = cmEditor.state;
            const selection = state.selection.main;
            return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);
        }
        console.warn("Could not access CodeMirror state to get selection.");
        return null;
    }
    else {
        // Fallback for non-notebook editors (e.g., text editor)
        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
        if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {
            const editor = activeWidget.content.editor;
            const cmEditor = editor.editor;
            if (cmEditor && cmEditor.state) {
                const state = cmEditor.state;
                const selection = state.selection.main;
                return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);
            }
            console.warn("Could not access CodeMirror state for non-notebook editor selection.");
            return null;
        }
    }
    return null;
}
/**
 * Checks whether we are currently in a notebook cell.
*/
function isInNotebookCell() {
    var _a;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    return activeCell !== null;
}
/**
 * Checks whether we are currently in a notebook cell and the editor is focused:
 * meaning that the cursor is in the editor.
*/
function isInNotebookCellAndEditorFocused() {
    var _a;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor) {
        const editor = activeCell.editor;
        const cmEditor = editor.editor; // Access CodeMirror editor instance
        return cmEditor && cmEditor.state;
    }
    return false;
}
/**
 * Check whether the currently active cell is a code cell.
*/
function isCodeCell() {
    var _a, _b;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    return ((_b = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) === null || _b === void 0 ? void 0 : _b.type) === 'code';
}
/**
 * Check whether the cursor is in the output area of a code cell.
 * This function specifically checks if we're in a code cell's output area,
 * not just any output area.
 */
function isOutputArea() {
    var _a;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (!(activeCell === null || activeCell === void 0 ? void 0 : activeCell.model))
        return false;
    // First check if it's a code cell
    if (activeCell.model.type !== 'code')
        return false;
    // Then check if we're in the output area
    const editor = activeCell.editor;
    if (!editor)
        return false;
    const cmEditor = editor.editor;
    if (!(cmEditor === null || cmEditor === void 0 ? void 0 : cmEditor.state))
        return false;
    // Get the editor's DOM element
    const editorElement = cmEditor.dom;
    if (!editorElement)
        return false;
    // Check if the active element is within the output area
    const activeElement = document.activeElement;
    if (!activeElement)
        return false;
    // The output area is typically a sibling of the editor element
    const outputArea = editorElement.nextElementSibling;
    if (!outputArea)
        return false;
    return outputArea.contains(activeElement);
}
/**
 * Gets the content of the currently active notebook cell or text editor.
 */
function getCurrentCellContent() {
    var _a, _b, _c, _d, _e;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {
        // Try using sharedModel first (more robust)
        if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {
            return activeCell.model.sharedModel.getSource();
        }
        // Fallback: Try using toJSON().source
        const cellJson = activeCell.model.toJSON();
        const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
        if (typeof source === 'string') {
            return source;
        }
        else if (Array.isArray(source)) {
            return source.join('\n');
        }
        console.warn("Could not get cell content via sharedModel or toJSON().source");
        return null;
    }
    // Fallback for non-notebook editors if needed
    const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
    if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {
        // Assuming model.value.text for generic text editors
        return (_e = (_d = activeWidget.content.model.value) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;
    }
    return null;
}
/**
 * Gets cell content by index from the current notebook and calls a callback to insert it.
 * NOTE: The original function called `this.appendToInput`. This functionality needs
 *       to be provided via the `insertCallback`.
 */
function insertCellContentByIndex(index, insertCallback) {
    try {
        if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {
            console.error('No active notebook found');
            return;
        }
        const notebookPanel = globals_1.globals.notebookTracker.currentWidget;
        const model = notebookPanel.content.model;
        if (!model || !model.cells || index < 0 || index >= model.cells.length) {
            console.error(`Invalid cell index: ${index}`);
            return;
        }
        const cell = model.cells.get(index);
        let cellContent = '';
        // Get cell content - handle different ways content might be stored
        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {
            cellContent = cell.sharedModel.getSource();
        }
        else {
            const cellJson = cell.toJSON();
            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
            if (typeof source === 'string') {
                cellContent = source;
            }
            else if (Array.isArray(source)) {
                cellContent = source.join('\n');
            }
        }
        // Insert cell reference with content using the callback
        insertCallback(`cell ${cellContent}`);
    }
    catch (error) {
        console.error('Error inserting cell by index:', error);
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy43MmE1ZmEzNzAyZmIyZmE3Y2IwYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7Ozs7Ozs7OztBQzdJYjtBQUNiLDhDQUE2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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx5RUFBeUUsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jZWxsLWNvbnRleHQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb3JlL2FwaS1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY29yZS9nbG9iYWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NvcmUvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaGFuZGxlcnMvaGlzdG9yeS1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2hhbmRsZXJzL2lucHV0LWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaGFuZGxlcnMvbWVzc2FnZS1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2hhbmRsZXJzL25vdGUtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9wb3B1cC1tZW51LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaGFuZGxlcnMvc2V0dGluZ3MtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9zaG9ydGN1dC1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3NpZGViYXItd2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3N0YXRlL2NoYXQtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvc3RhdGUvbm90ZS1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9zdGF0ZS9zZXR0aW5ncy1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91aS9kb20tZWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdWkvbGF5b3V0LWJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdWkvbWVzc2FnZS1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91aS9ub3RlLW1vZGFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL3NldHRpbmdzLW1vZGFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL3VpLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdXRpbHMvY2xpcGJvYXJkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3V0aWxzL2NvbnRlbnQtZWRpdGFibGUtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdXRpbHMvaGlnaGxpZ2h0aW5nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3V0aWxzL21hcmtkb3duLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91dGlscy9tYXJrZG93bi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91dGlscy9ub3RlYm9vay1pbnRlZ3JhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2VsbENvbnRleHRUcmFja2VyID0gdm9pZCAwO1xuLyoqXG4gKiBUcmFja3MgY2VsbCBjb250ZXh0IGFuZCBjdXJzb3IgcG9zaXRpb24gd2l0aGluIEp1cHl0ZXIgbm90ZWJvb2tzXG4gKi9cbmNsYXNzIENlbGxDb250ZXh0VHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBub3RlYm9va1RyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBlZGl0b3IgZXZlbnRzIChrZXlkb3duLCBtb3VzZXVwKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYWN0aXZlIGNlbGwgZnJvbSB0aGUgdHJhY2tlclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBpbm5lciBFZGl0b3JWaWV3IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gR2V0IGFuZCBzdG9yZSB0aGUgY3Vyc29yIGNvbnRleHRcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IHRoaXMuZ2V0Q21Db250ZXh0KHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGVkaXRvciBldmVudCBoYW5kbGVyOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyID0gbm90ZWJvb2tUcmFja2VyO1xuICAgICAgICB0aGlzLnNldHVwVHJhY2tlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIG9iamVjdCBoYXMgYmVlbiBkaXNwb3NlZFxuICAgICAqL1xuICAgIGdldCBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCB0cmFja2Vyc1xuICAgICAqL1xuICAgIHNldHVwVHJhY2tlcnMoKSB7XG4gICAgICAgIC8vIEhhbmRsZSBhY3RpdmUgY2VsbCBjaGFuZ2VzXG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGxDaGFuZ2VkLmNvbm5lY3QodGhpcy5zZXR1cENlbGxMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICAvLyBIYW5kbGUgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5jb25uZWN0KHRoaXMuaGFuZGxlTm90ZWJvb2tDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5vdGVib29rIGNoYW5nZXNcbiAgICAgKi9cbiAgICBoYW5kbGVOb3RlYm9va0NoYW5nZSh0cmFja2VyLCBwYW5lbCkge1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICBpZiAocGFuZWwgJiYgcGFuZWwuY29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHBhbmVsLmNvbnRlbnQuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzKHRyYWNrZXIsIGNlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBhY3RpdmUgY2VsbFxuICAgICAqL1xuICAgIHNldHVwQ2VsbExpc3RlbmVycyhfdHJhY2tlciwgY2VsbCkge1xuICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmIChjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsTm9kZSA9IGNlbGwubm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3JOb2RlID0gY2VsbE5vZGUucXVlcnlTZWxlY3RvcignLmpwLUVkaXRvcicpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNlbGxOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1JbnB1dEFyZWEtZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSA9IGVkaXRvck5vZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIGtleSBhbmQgbW91c2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGNhcHR1cmUgaW1tZWRpYXRlIGNvbnRleHQgaWYgRWRpdG9yVmlldyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGNlbGwuZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gdGhpcy5nZXRDbUNvbnRleHQodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2V0dGluZyB1cCBjZWxsIGxpc3RlbmVyczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgcHJldmlvdXMgYWN0aXZlIGNlbGxcbiAgICAgKi9cbiAgICBjbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjb250ZXh0IGluZm9ybWF0aW9uIGZyb20gQ29kZU1pcnJvciBFZGl0b3JWaWV3XG4gICAgICovXG4gICAgZ2V0Q21Db250ZXh0KHZpZXcpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICBjb25zdCBmdWxsVGV4dCA9IHN0YXRlLmRvYy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUubnVtYmVyIC0gMSxcbiAgICAgICAgICAgIGNvbHVtbjogb2Zmc2V0IC0gbGluZS5mcm9tLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGV4dFJhZGl1cyA9IDEwMDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBvZmZzZXQgLSBjb250ZXh0UmFkaXVzKTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oZnVsbFRleHQubGVuZ3RoLCBvZmZzZXQgKyBjb250ZXh0UmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGZ1bGxUZXh0LFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgY29udGV4dEJlZm9yZTogZnVsbFRleHQuc3Vic3RyaW5nKHN0YXJ0LCBvZmZzZXQpLFxuICAgICAgICAgICAgY29udGV4dEFmdGVyOiBmdWxsVGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBlbmQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgY2VsbCBjb250ZXh0XG4gICAgICovXG4gICAgZ2V0Q3VycmVudENlbGxDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2VsbENvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsQ2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuZGlzY29ubmVjdCh0aGlzLmhhbmRsZU5vdGVib29rQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkNlbGxDb250ZXh0VHJhY2tlciA9IENlbGxDb250ZXh0VHJhY2tlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckNvbW1hbmRzID0gcmVnaXN0ZXJDb21tYW5kcztcbmNvbnN0IHVpX2NvbXBvbmVudHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi91aS1jb21wb25lbnRzXCIpOyAvLyBJbXBvcnQgTGFiSWNvbiBpZiBuZWVkZWQgYXMgcGxhY2Vob2xkZXJcbi8vIFBsYWNlaG9sZGVyIGljb24gKHJlcGxhY2UgaWYgeW91IGhhdmUgYSBzcGVjaWZpYyBpY29uKVxuY29uc3QgZXh0ZW5zaW9uSWNvbiA9IHVpX2NvbXBvbmVudHNfMS5MYWJJY29uLnJlc29sdmUoeyBpY29uOiAndWktY29tcG9uZW50czpqdXB5dGVybGFiJyB9KTsgLy8gVXNlIHJlc29sdmUgZm9yIGJ1aWx0LWluXG4vKipcbiAqIFJlZ2lzdGVycyBjb21tYW5kcyBmb3IgdGhlIGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiByZWdpc3RlckNvbW1hbmRzKGFwcCwgcGFsZXR0ZSwgbGF1bmNoZXIsIHNpZGViYXJXaWRnZXQpIHtcbiAgICAvLyBBZGQgY29tbWFuZCB0byB0b2dnbGUgdGhlIHNpZGViYXJcbiAgICBhcHAuY29tbWFuZHMuYWRkQ29tbWFuZCgnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsIHtcbiAgICAgICAgbGFiZWw6ICdUb2dnbGUgQUkgQXNzaXN0YW50IFNpZGViYXInLFxuICAgICAgICBpY29uOiBleHRlbnNpb25JY29uLFxuICAgICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2lkZWJhcldpZGdldC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgc2lkZWJhcldpZGdldC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwLnNoZWxsLmFkZChzaWRlYmFyV2lkZ2V0LCAnbGVmdCcsIHsgcmFuazogOTk5OSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgY29tbWFuZCBwYWxldHRlXG4gICAgcGFsZXR0ZS5hZGRJdGVtKHtcbiAgICAgICAgY29tbWFuZDogJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLFxuICAgICAgICBjYXRlZ29yeTogJ0V4dGVuc2lvbidcbiAgICB9KTtcbiAgICAvLyBBZGQgYSBsYXVuY2hlciBpdGVtXG4gICAgbGF1bmNoZXIuYWRkKHtcbiAgICAgICAgY29tbWFuZDogJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLFxuICAgICAgICBjYXRlZ29yeTogJ090aGVyJyxcbiAgICAgICAgcmFuazogOTk5OVxuICAgIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbi8qKlxuICogQVBJIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZCBMTE0gc2VydmljZVxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJykge1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYSBjaGF0IHJlc3BvbnNlIGZyb20gdGhlIG1vY2sgTExNXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIHVzZXIgbWVzc2FnZSB0byBzZW5kXG4gICAgICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBvbkNodW5rIENhbGxiYWNrIGZvciBlYWNoIHRleHQgY2h1bmsgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gb25Db21wbGV0ZSBDYWxsYmFjayB3aGVuIHN0cmVhbWluZyBpcyBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSBvbkVycm9yIENhbGxiYWNrIGZvciBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW1DaGF0KG1lc3NhZ2UsIGNvbnRleHQgPSBudWxsLCBvbkNodW5rLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vY2hhdGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhZGFibGVTdHJlYW0gbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdXAgc3RyZWFtIHJlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZTogcmVhZGVyRG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBkb25lID0gcmVhZGVyRG9uZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06ICFkb25lIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGhlYWx0aCBjaGVjayBmb3IgdGhlIEFQSVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIEFQSSBpcyBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vaGVhbHRoYCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFwaUNsaWVudCA9IEFwaUNsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nbG9iYWxzID0gdm9pZCAwO1xuZXhwb3J0cy5pbml0R2xvYmFscyA9IGluaXRHbG9iYWxzO1xuLyoqXG4gKiBHbG9iYWwgcmVmZXJlbmNlcyB0byBrZXkgY29tcG9uZW50cyBpbiB0aGUgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5nbG9iYWxzID0ge307XG4vKipcbiAqIEluaXRpYWxpemUgZ2xvYmFsIHJlZmVyZW5jZXNcbiAqL1xuZnVuY3Rpb24gaW5pdEdsb2JhbHMoYXBwLCBub3RlYm9va1RyYWNrZXIpIHtcbiAgICBleHBvcnRzLmdsb2JhbHMuYXBwID0gYXBwO1xuICAgIGV4cG9ydHMuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5zaW9uSWNvbiA9IHZvaWQgMDtcbmNvbnN0IHVpX2NvbXBvbmVudHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi91aS1jb21wb25lbnRzXCIpO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSWNvbiBEZWZpbml0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBpY29uU3ZnU3RyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cImJpIGJpLWNoYXQtbGVmdC10ZXh0XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPicgK1xuICAgICc8cGF0aCBkPVwiTTE0IDFhMSAxIDAgMCAxIDEgMXY4YTEgMSAwIDAgMS0xIDFINC40MTRBMiAyIDAgMCAwIDMgMTEuNTg2bC0yIDJWMmExIDEgMCAwIDEgMS0xaDEyek0yIDBhMiAyIDAgMCAwLTIgMnYxMi43OTNhLjUuNSAwIDAgMCAuODU0LjM1M2wyLjg1My0yLjg1M0ExIDEgMCAwIDEgNC40MTQgMTJIMTRhMiAyIDAgMCAwIDItMlYyYTIgMiAwIDAgMC0yLTJIMnpcIi8+JyArXG4gICAgJzxwYXRoIGQ9XCJNMyAzLjVhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05YS41LjUgMCAwIDEtLjUtLjV6TTMgNmEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlBLjUuNSAwIDAgMSAzIDZ6bTAgMi41YS41LjUgMCAwIDEgLjUtLjVoNWEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxLS41LS41elwiLz4nICtcbiAgICAnPC9zdmc+Jztcbi8qKlxuICogSWNvbiBmb3IgdGhlIEFJIEFzc2lzdGFudCBleHRlbnNpb25cbiAqL1xuZXhwb3J0cy5leHRlbnNpb25JY29uID0gbmV3IHVpX2NvbXBvbmVudHNfMS5MYWJJY29uKHtcbiAgICBuYW1lOiAnc2ltcGxlOmljb24nLFxuICAgIHN2Z3N0cjogaWNvblN2Z1N0clxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGlzdG9yeUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vdWkvbWVzc2FnZS1yZW5kZXJlclwiKTsgLy8gQXNzdW1pbmcgcmVuZGVyZXJzIGFyZSBuZWVkZWRcbi8qKlxuICogTWFuYWdlcyB0aGUgZGlzcGxheSBhbmQgaW50ZXJhY3Rpb24gbG9naWMgZm9yIHRoZSBjaGF0IGhpc3Rvcnkgdmlldy5cbiAqL1xuY2xhc3MgSGlzdG9yeUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYXRTdGF0ZSwgdWlNYW5hZ2VyLCBjYWxsYmFja3MsIHJlbmRlcmVyQ2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYXRTdGF0ZSA9IGNoYXRTdGF0ZTtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzID0gcmVuZGVyZXJDYWxsYmFja3M7XG4gICAgICAgIC8vIEdldCB0aGUgaGlzdG9yeSBjb250YWluZXIgZWxlbWVudCBmcm9tIFVJTWFuYWdlclxuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIgPSB0aGlzLnVpTWFuYWdlci5nZXRVSUVsZW1lbnRzKCkuaGlzdG9yeUNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBiZXR3ZWVuIHRoZSBtYWluIGNoYXQgdmlldyBhbmQgdGhlIGhpc3Rvcnkgdmlldy5cbiAgICAgKi9cbiAgICB0b2dnbGVIaXN0b3J5VmlldygpIHtcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gIXRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gVXNlIFVJTWFuYWdlciB0byBoaWRlIGNoYXQsIHNob3cgaGlzdG9yeVxuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2hvd0hpc3RvcnlWaWV3KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoYXRIaXN0b3J5KCk7IC8vIFBvcHVsYXRlIHRoZSBoaXN0b3J5IHZpZXdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBVSU1hbmFnZXIgdG8gc2hvdyBjaGF0LCBoaWRlIGhpc3RvcnlcbiAgICAgICAgICAgIHRoaXMudWlNYW5hZ2VyLnNob3dDaGF0VmlldygpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjb3JyZWN0IHRpdGxlIGlzIGRpc3BsYXllZCB3aGVuIHN3aXRjaGluZyBiYWNrXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhdCA9IHRoaXMuY2hhdFN0YXRlLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy51cGRhdGVUaXRsZUlucHV0KGN1cnJlbnRDaGF0LnRpdGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBsaXN0IG9mIHBhc3QgY2hhdHMgaW4gdGhlIGhpc3RvcnkgY29udGFpbmVyLlxuICAgICAqL1xuICAgIHJlbmRlckNoYXRIaXN0b3J5KCkge1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuaW5uZXJIVE1MID0gJyc7IC8vIENsZWFyIHByZXZpb3VzIGxpc3RcbiAgICAgICAgY29uc3QgaGlzdG9yeSA9IHRoaXMuY2hhdFN0YXRlLmdldENoYXRIaXN0b3J5KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGF0SWQgPSB0aGlzLmNoYXRTdGF0ZS5nZXRDdXJyZW50Q2hhdElkKCk7XG4gICAgICAgIC8vIENyZWF0ZSBoZWFkZXIgd2l0aCBiYWNrIGJ1dHRvblxuICAgICAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGVhZGVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktaGVhZGVyJztcbiAgICAgICAgLy8gQ3JlYXRlIGJhY2sgYnV0dG9uXG4gICAgICAgIGNvbnN0IGJhY2tCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYmFja0J1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYmFjay1idXR0b24nO1xuICAgICAgICBiYWNrQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTIwIDExSDcuODNsNS41OS01LjU5TDEyIDRsLTggOCA4IDggMS40MS0xLjQxTDcuODMgMTNIMjB2LTJ6XCIvPjwvc3ZnPjwvc3Bhbj4nO1xuICAgICAgICBiYWNrQnV0dG9uLnRpdGxlID0gJ0JhY2sgdG8gY2hhdCc7XG4gICAgICAgIGJhY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhpZGVIaXN0b3J5VmlldygpKTtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9ICdDaGF0IEhpc3RvcnknO1xuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoYmFja0J1dHRvbik7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5pbm5lckhUTUwgKz0gJzxkaXYgY2xhc3M9XCJqcC1sbG0tZXh0LWhpc3RvcnktZW1wdHlcIj5ObyBjaGF0IGhpc3RvcnkgeWV0LjwvZGl2Pic7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIGxpc3QuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1saXN0JztcbiAgICAgICAgaGlzdG9yeS5mb3JFYWNoKGNoYXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgbGlzdEl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtJztcbiAgICAgICAgICAgIGlmIChjaGF0LmlkID09PSBjdXJyZW50Q2hhdElkKSB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uY2xhc3NMaXN0LmFkZCgnanAtbGxtLWV4dC1hY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbXBsZSByZXByZXNlbnRhdGlvbjogVGl0bGVcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBwcmV2aWV3LCB0aW1lc3RhbXAsIGRlbGV0ZSBidXR0b24gZXRjLlxuICAgICAgICAgICAgY29uc3QgdGl0bGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRpdGxlRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktaXRlbS10aXRsZSc7XG4gICAgICAgICAgICB0aXRsZURpdi50ZXh0Q29udGVudCA9IGNoYXQudGl0bGUgfHwgJ1VudGl0bGVkIENoYXQnO1xuICAgICAgICAgICAgbGlzdEl0ZW0uYXBwZW5kQ2hpbGQodGl0bGVEaXYpO1xuICAgICAgICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50IHRvIGxvYWQgdGhlIGNoYXRcbiAgICAgICAgICAgIGxpc3RJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5sb2FkQ2hhdChjaGF0LmlkKSk7XG4gICAgICAgICAgICBsaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzcGVjaWZpYyBjaGF0IHNlc3Npb24gZnJvbSBoaXN0b3J5IGludG8gdGhlIG1haW4gdmlldy5cbiAgICAgKi9cbiAgICBsb2FkQ2hhdChjaGF0SWQpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdFN0YXRlLmdldENoYXRCeUlkKGNoYXRJZCk7XG4gICAgICAgIGlmICghY2hhdCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ2hhdCB3aXRoIElEICR7Y2hhdElkfSBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoaXMgY2hhdCBhcyB0aGUgYWN0aXZlIG9uZSBpbiB0aGUgc3RhdGVcbiAgICAgICAgdGhpcy5jaGF0U3RhdGUuc2V0Q3VycmVudENoYXRJZChjaGF0SWQpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG1haW4gVUkgdGl0bGUgaW5wdXRcbiAgICAgICAgdGhpcy5jYWxsYmFja3MudXBkYXRlVGl0bGVJbnB1dChjaGF0LnRpdGxlKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgbWVzc2FnZSBkaXNwbGF5XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmNsZWFyTWVzc2FnZUNvbnRhaW5lcigpO1xuICAgICAgICAvLyBSZS1wb3B1bGF0ZSB0aGUgbWVzc2FnZSBjb250YWluZXIgd2l0aCBtZXNzYWdlcyBmcm9tIHRoZSBsb2FkZWQgY2hhdFxuICAgICAgICAvLyBVc2UgdGhlIHJlbmRlcmVyIGZ1bmN0aW9ucyB2aWEgY2FsbGJhY2tzXG4gICAgICAgIGNoYXQubWVzc2FnZXMuZm9yRWFjaCgobXNnKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobXNnLnNlbmRlciA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclVzZXJNZXNzYWdlKShtc2cudGV4dCwgeyBpc01hcmtkb3duOiBtc2cuaXNNYXJrZG93biB9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyAnYm90J1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50ID0gKDAsIG1lc3NhZ2VfcmVuZGVyZXJfMS5yZW5kZXJCb3RNZXNzYWdlKShtc2cudGV4dCwgeyBpc01hcmtkb3duOiBtc2cuaXNNYXJrZG93biB9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byB0aGUgbWVzc2FnZSBjb250YWluZXIgdmlhIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGRSZW5kZXJlZE1lc3NhZ2UobWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3dpdGNoIGJhY2sgdG8gdGhlIGNoYXQgdmlldyBpZiB3ZSB3ZXJlIGluIHRoZSBoaXN0b3J5IHZpZXdcbiAgICAgICAgaWYgKHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVIaXN0b3J5VmlldygpOyAvLyBUaGlzIHdpbGwgY2FsbCB1aU1hbmFnZXIuc2hvd0NoYXRWaWV3KClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgaW4gY2hhdCB2aWV3LCBlbnN1cmUgc2Nyb2xsaW5nIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHRoaXMudWlNYW5hZ2VyLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW9uYWw6IFJlLXJlbmRlciBoaXN0b3J5IGxpc3QgdG8gdXBkYXRlIHRoZSBhY3RpdmUgaXRlbSBpbmRpY2F0b3JcbiAgICAgICAgLy8gT25seSByZWFsbHkgbmVlZGVkIGlmIG5vdCBzd2l0Y2hpbmcgdmlld3NcbiAgICAgICAgLy8gaWYgKCF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHsgdGhpcy5yZW5kZXJDaGF0SGlzdG9yeSgpOyB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBoaXN0b3J5IHZpZXcgYW5kIHNob3dzIHRoZSBjaGF0IHZpZXcuXG4gICAgICovXG4gICAgaGlkZUhpc3RvcnlWaWV3KCkge1xuICAgICAgICB0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIuc2hvd0NoYXRWaWV3KCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgY29ycmVjdCB0aXRsZSBpcyBkaXNwbGF5ZWQgd2hlbiBzd2l0Y2hpbmcgYmFja1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhdCA9IHRoaXMuY2hhdFN0YXRlLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MudXBkYXRlVGl0bGVJbnB1dChjdXJyZW50Q2hhdC50aXRsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkhpc3RvcnlIYW5kbGVyID0gSGlzdG9yeUhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5wdXRIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgY29udGVudF9lZGl0YWJsZV91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnRlbnQtZWRpdGFibGUtdXRpbHNcIik7IC8vIEhlbHBlciBuZWVkZWRcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2dsb2JhbHNcIik7IC8vIEltcG9ydCBnbG9iYWxzXG5jb25zdCBtZXNzYWdlX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vdWkvbWVzc2FnZS1yZW5kZXJlclwiKTtcbi8qKlxuICogSGFuZGxlcyBldmVudHMgYW5kIGxvZ2ljIHJlbGF0ZWQgdG8gdGhlIGNoYXQgaW5wdXQgZmllbGQuXG4gKi9cbmNsYXNzIElucHV0SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY2hhdElucHV0LCBjYWxsYmFja3NcbiAgICAvLyB1aU1hbmFnZXI6IFVJTWFuYWdlciAvLyBSZW1vdmVkIHVudXNlZCBwYXJhbWV0ZXJcbiAgICApIHtcbiAgICAgICAgLy8gcHJpdmF0ZSB1aU1hbmFnZXI6IFVJTWFuYWdlcjsgLy8gUmVtb3ZlZCB1bnVzZWQgbWVtYmVyXG4gICAgICAgIC8vIC0tLSBDb2RlIFJlZmVyZW5jZSBTdGF0ZSAtLS1cbiAgICAgICAgdGhpcy5jb2RlUmVmTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5leHRSZWZJZCA9IDE7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhc0F0U3ltYm9sID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTsgLy8gSW50ZXJuYWwgc3RhdGUsIHBvdGVudGlhbGx5IHN5bmNlZCB3aXRoIFVJTWFuYWdlclxuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9IGZhbHNlOyAvLyBJbnRlcm5hbCBzdGF0ZSwgcG90ZW50aWFsbHkgc3luY2VkIHdpdGggVUlNYW5hZ2VyXG4gICAgICAgIC8vIE5FVyBDbGljayBoYW5kbGVyIGZvciB3aWRnZXQgaW50ZXJhY3Rpb25zIChlLmcuLCBleHBhbmQpXG4gICAgICAgIHRoaXMuX2hhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB3aWRnZXQgPSB0YXJnZXQuY2xvc2VzdCgnLmpwLWxsbS1leHQtcmVmLXdpZGdldCcpO1xuICAgICAgICAgICAgaWYgKHdpZGdldCAmJiB3aWRnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCB0cmlnZ2VyIHByZXZpZXcgaWYgY2xpY2tpbmcgaW5zaWRlIHRoZSBtYWluIGVkaXRhYmxlIGRpdiBpdHNlbGZcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgaWYgY2xpY2tpbmcgZGlyZWN0bHkgb24gYSBub24tZWRpdGFibGUgd2lkZ2V0IHNwYW5cbiAgICAgICAgICAgICAgICBpZiAod2lkZ2V0ID09PSB0aGlzLmNoYXRJbnB1dClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgY2xpY2tzIG9uIHRoZSBtYWluIGRpdiBiYWNrZ3JvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkZ2V0ICYmICF3aWRnZXQuaXNDb250ZW50RWRpdGFibGUpIHsgLy8gRW5zdXJlIGl0J3Mgb3VyIG5vbi1lZGl0YWJsZSB3aWRnZXQgc3BhblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB3aWRnZXQuZGF0YXNldC50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB3aWRnZXQuZGF0YXNldC5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZklkID0gd2lkZ2V0LmRhdGFzZXQucmVmSWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IHdpZGdldC5kYXRhc2V0LnBhdGg7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFdpZGdldCBjbGlja2VkOiBUeXBlPSR7dHlwZX0sIFJlZklEPSR7cmVmSWR9LCBQYXRoPSR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGUgPT09ICdjb2RlJyB8fCB0eXBlID09PSAnY2VsbCcpICYmIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBwb3RlbnRpYWwgdGV4dCBzZWxlY3Rpb24gaXNzdWVzXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBTdG9wIGV2ZW50IGZyb20gYnViYmxpbmcgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dXaWRnZXRQcmV2aWV3KHdpZGdldCwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2sgb24gZmlsZS9kaXIgb3Igd2lkZ2V0IHdpdGhvdXQgY29udGVudD8gTWF5YmUgZG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3IgcG90ZW50aWFsbHkgcmVtb3ZlIGV4aXN0aW5nIHByZXZpZXcgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0UHJldmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENsaWNrIHdhcyBub3Qgb24gYSB3aWRnZXQsIHJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlld1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0UHJldmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyAtLS0gV2lkZ2V0IFByZXZpZXcgTG9naWMgLS0tXG4gICAgICAgIHRoaXMuYWN0aXZlUHJldmlld0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAvLyAtLS0gUHJpdmF0ZSBFdmVudCBIYW5kbGVycyAtLS1cbiAgICAgICAgdGhpcy5faGFuZGxlS2V5UHJlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBFbnRlciBrZXkgcHJlc3MgKHNlbmQgbWVzc2FnZSlcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IG5ld2xpbmUgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgLy8gTkVXOiBVc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QgdG8gZ2V0IHRoZSByYXcgbWVzc2FnZSB3aXRoIHBsYWNlaG9sZGVyc1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5fc2VyaWFsaXplSW5wdXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudHJpbSgpOyAvLyBUcmltIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGNvZGUgcmVmZXJlbmNlcyB3aXRoIHByb3BlciBmb3JtYXR0aW5nIGJhc2VkIG9uIG1hcmtkb3duIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRNZXNzYWdlID0gdGhpcy5yZXNvbHZlQ29kZVJlZmVyZW5jZXMobWVzc2FnZSwgdGhpcy5pc01hcmtkb3duTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgcmVzb2x2ZWQgbWVzc2FnZSB3aXRoIGN1cnJlbnQgbWFya2Rvd24gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaGFuZGxlU2VuZE1lc3NhZ2UocmVzb2x2ZWRNZXNzYWdlLCB0aGlzLmlzTWFya2Rvd25Nb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0gSGFuZGxlIFRhYi9Fc2NhcGUvQXJyb3dzIGZvciBwb3B1cCBpbnRlcmFjdGlvbiAtLS1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHBvcHVwIGlzIHZpc2libGUgKG5lZWRzIGEgd2F5IHRvIGtub3csIG1heWJlIHZpYSBjYWxsYmFja3Mgb3IgZGlyZWN0IHJlZmVyZW5jZT8pXG4gICAgICAgICAgICAvLyBBc3N1bWluZyBwb3B1cE1lbnVNYW5hZ2VyIHJlZmVyZW5jZSBpcyBhdmFpbGFibGUgb3Igc3RhdGUgaXMgdHJhY2tlZFxuICAgICAgICAgICAgLy8gZWxzZSBpZiAodGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmlzUG9wdXBNZW51VmlzaWJsZSgpKSB7IC8vIFBzZXVkby1jb2RlXG4gICAgICAgICAgICAvLyAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJyB8fCBldmVudC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgaW5wdXQgZmllbGQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gICAgICAgIC8vIExldCB0aGUgUG9wdXBNZW51TWFuYWdlcidzIGRvY3VtZW50IGhhbmRsZXIgbWFuYWdlIHRoZSBldmVudFxuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gLS0tIEVuZCBQb3B1cCBJbnRlcmFjdGlvbiBIYW5kbGluZyAtLS1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5wdXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGRpdlxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSB0aGlzLmNoYXRJbnB1dC50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgICAgICAgIC8vIC0tLSBVcGRhdGUgQ29kZSBSZWYgUGxhY2Vob2xkZXJzIC0tLSBcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBJZiB3ZSB3YW50IHZpc3VhbCBwbGFjZWhvbGRlcnMgdG8gdXBkYXRlIGxpdmVcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgaW52b2x2ZSBjb21wbGV4IERPTSBtYW5pcHVsYXRpb24gb3IgdXNpbmcgYSBsaWJyYXJ5LlxuICAgICAgICAgICAgLy8gRm9yIG5vdywgd2UgcmVzb2x2ZSByZWZzIG9ubHkgb24gc2VuZC5cbiAgICAgICAgICAgIC8vIC0tLSBBdCBTeW1ib2wgRGV0ZWN0aW9uIGZvciBQb3B1cCAtLS0gXG4gICAgICAgICAgICAvLyBUaGlzIGxvZ2ljIHdhcyBtb3ZlZCB0byBVSU1hbmFnZXIuaGFuZGxlSW5wdXRGb3JSZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgVUlNYW5hZ2VyIG5lZWRzIHRvIGNvb3JkaW5hdGUgc2hvd2luZyB0aGUgcG9wdXAuXG4gICAgICAgICAgICAvLyBJbnB1dEhhbmRsZXIgbWlnaHQgc3RpbGwgbmVlZCB0byBrbm93ICppZiogYW4gQCB3YXMgdHlwZWQgcmVjZW50bHlcbiAgICAgICAgICAgIC8vIHRvIGFkanVzdCBiZWhhdmlvciAoZS5nLiwgaG93IEVudGVyIHdvcmtzKSwgYnV0IFVJTWFuYWdlciBoYW5kbGVzIHRoZSBwb3B1cCB0cmlnZ2VyLlxuICAgICAgICAgICAgLy8gU2ltcGxlIGNoZWNrIGlmIHRleHQgY29udGFpbnMgJ0AnIGZvciBwb3RlbnRpYWwgc3RhdGUgbWFuYWdlbWVudFxuICAgICAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGN1cnJlbnRUZXh0LmluY2x1ZGVzKCdAJyk7XG4gICAgICAgICAgICAvLyBBZGp1c3QgaW5wdXQgaGVpZ2h0IGR5bmFtaWNhbGx5IGJhc2VkIG9uIGNvbnRlbnQ/XG4gICAgICAgICAgICAvLyBDYW4gYmUgY29tcGxleCB3aXRoIGNvbnRlbnRlZGl0YWJsZSBkaXZzLiBSZXF1aXJlcyBjYXJlZnVsIGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgLy8gdGhpcy5hZGp1c3RJbnB1dEhlaWdodCgpOyBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTkVXIEtleWRvd24gaGFuZGxlciBmb3Igd2lkZ2V0IGRlbGV0aW9uIGV0Yy5cbiAgICAgICAgdGhpcy5faGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgc2luZ2xlIGN1cnNvciBwb3NpdGlvbiwgbm90IHJhbmdlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgbGV0IHdpZGdldFRvRGVsZXRlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBub2RlVG9DaGVjayA9IG51bGw7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwICYmIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIGlzIHdpdGhpbiBhIHRleHQgbm9kZSwgY2hlY2sgdGhlIG5vZGUgKmJlZm9yZSogdGhpcyB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IG9ubHkgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgKnN0YXJ0KiBvZiB0aGUgdGV4dCBub2RlIChvZmZzZXQgPT09IDA/IE5vLCBjaGVjayBwcmV2aW91c1NpYmxpbmcgYWx3YXlzPylcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgY2hlY2sgdGhlIG5vZGUgZGlyZWN0bHkgcHJlY2VkaW5nIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVRvQ2hlY2sgPSBjb250YWluZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmZzZXQgPiAwICYmIGNvbnRhaW5lciA9PT0gdGhpcy5jaGF0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIGlzIGJldHdlZW4gbm9kZXMgaW4gdGhlIG1haW4gaW5wdXQgZGl2XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUb0NoZWNrID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldCA9PT0gMCAmJiBjb250YWluZXIgIT09IHRoaXMuY2hhdElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnNvciBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbm9uLWRpdiBub2RlIChlLmcuLCBzdGFydCBvZiBhIHRleHQgbm9kZSBhZnRlciBhIHdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayB0aGUgbm9kZSBiZWZvcmUgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBub2RlVG9DaGVjayA9IGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIHRvIGNoZWNrIGlzIGEgWldTIG9yIHNwYWNlIG5vZGUsIGlmIHNvLCBjaGVjayB0aGUgbm9kZSBiZWZvcmUgdGhhdFxuICAgICAgICAgICAgICAgIGlmIChub2RlVG9DaGVjayAmJiBub2RlVG9DaGVjay5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgKG5vZGVUb0NoZWNrLnRleHRDb250ZW50ID09PSAnXFx1MjAwQicgfHwgbm9kZVRvQ2hlY2sudGV4dENvbnRlbnQgPT09ICcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVRvQ2hlY2sgPSBub2RlVG9DaGVjay5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnRGVsZXRlJykge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIG9mZnNldCA8IGNvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIGlzIHdpdGhpbiBhIHRleHQgbm9kZSwgY2hlY2sgdGhlIG5vZGUgKmFmdGVyKiB0aGlzIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBub2RlVG9DaGVjayA9IGNvbnRhaW5lci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyID09PSB0aGlzLmNoYXRJbnB1dCAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIGlzIGJldHdlZW4gbm9kZXMgaW4gdGhlIG1haW4gaW5wdXQgZGl2XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUb0NoZWNrID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyICE9PSB0aGlzLmNoYXRJbnB1dCAmJiBvZmZzZXQgPT09ICgoKF9hID0gY29udGFpbmVyLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIG5vbi1kaXYgbm9kZSAoZS5nLiwgZW5kIG9mIGEgdGV4dCBub2RlIGJlZm9yZSBhIHdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayB0aGUgbm9kZSBhZnRlciB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVUb0NoZWNrID0gY29udGFpbmVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSB0byBjaGVjayBpcyBhIFpXUyBvciBzcGFjZSBub2RlLCBpZiBzbywgY2hlY2sgdGhlIG5vZGUgYWZ0ZXIgdGhhdFxuICAgICAgICAgICAgICAgIGlmIChub2RlVG9DaGVjayAmJiBub2RlVG9DaGVjay5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgKG5vZGVUb0NoZWNrLnRleHRDb250ZW50ID09PSAnXFx1MjAwQicgfHwgbm9kZVRvQ2hlY2sudGV4dENvbnRlbnQgPT09ICcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVRvQ2hlY2sgPSBub2RlVG9DaGVjay5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmluYWwgbm9kZVRvQ2hlY2sgaXMgYSB3aWRnZXRcbiAgICAgICAgICAgIGlmIChub2RlVG9DaGVjayAmJiBub2RlVG9DaGVjay5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgKChfYiA9IG5vZGVUb0NoZWNrLmNsYXNzTGlzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRhaW5zKCdqcC1sbG0tZXh0LXJlZi13aWRnZXQnKSkpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRUb0RlbGV0ZSA9IG5vZGVUb0NoZWNrO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2tleX0gcHJlc3NlZCBhZGphY2VudCB0byB3aWRnZXQ6YCwgd2lkZ2V0VG9EZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZGdldFRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB3aWRnZXRUb0RlbGV0ZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmaW5lIG5vZGVzIHRvIHJlbW92ZTogd2lkZ2V0IGl0c2VsZiwgcG90ZW50aWFsbHkgc3BhY2UgYmVmb3JlLCBwb3RlbnRpYWxseSBaV1MgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IFt3aWRnZXRUb0RlbGV0ZV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlQmVmb3JlID0gd2lkZ2V0VG9EZWxldGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB6d3NBZnRlciA9IHdpZGdldFRvRGVsZXRlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2VCZWZvcmUgJiYgc3BhY2VCZWZvcmUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIHNwYWNlQmVmb3JlLnRleHRDb250ZW50ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUudW5zaGlmdChzcGFjZUJlZm9yZSk7IC8vIEFkZCBzcGFjZSB0byBiZWdpbm5pbmcgb2YgcmVtb3ZhbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHp3c0FmdGVyICYmIHp3c0FmdGVyLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiB6d3NBZnRlci50ZXh0Q29udGVudCA9PT0gJ1xcdTIwMEInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2goendzQWZ0ZXIpOyAvLyBBZGQgWldTIHRvIGVuZCBvZiByZW1vdmFsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGlkZW50aWZpZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5mb3JFYWNoKG5vZGUgPT4gcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWw6IFJlbW92ZSByZWYgZnJvbSBtYXAgaWYgaXQgd2FzIGEgY29kZS9jZWxsIHJlZlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZJZCA9IHdpZGdldFRvRGVsZXRlLmRhdGFzZXQucmVmSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZJZCAmJiB0aGlzLmNvZGVSZWZNYXAuaGFzKHJlZklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlUmVmTWFwLmRlbGV0ZShyZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVtb3ZlZCByZWZlcmVuY2UgZnJvbSBtYXA6JywgcmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHkgYWZ0ZXIgZGVsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhdElucHV0ID0gY2hhdElucHV0O1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgLy8gdGhpcy51aU1hbmFnZXIgPSB1aU1hbmFnZXI7IC8vIFJlbW92ZWQgdW51c2VkIGFzc2lnbm1lbnRcbiAgICAgICAgLy8gQmluZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5jaGF0SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVLZXlQcmVzcyk7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faGFuZGxlSW5wdXQpO1xuICAgICAgICB0aGlzLmNoYXRJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5RG93bik7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2spOyAvLyBBRERFRCBDbGljayBMaXN0ZW5lclxuICAgICAgICAvLyBOb3RlOiBBY3R1YWwgbWFya2Rvd24gdG9nZ2xlIGFuZCBleHBhbmQgYnV0dG9ucyBhcmUgbGlrZWx5IG1hbmFnZWQgYnkgVUlNYW5hZ2VyLFxuICAgICAgICAvLyB3aGljaCB3b3VsZCB0aGVuIGNhbGwgbWV0aG9kcyBsaWtlIGBzZXRNYXJrZG93bk1vZGVgIG9yIGB0b2dnbGVFeHBhbnNpb25gIG9uIHRoaXMgaGFuZGxlci5cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jaGF0SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVLZXlQcmVzcyk7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faGFuZGxlSW5wdXQpO1xuICAgICAgICB0aGlzLmNoYXRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5RG93bik7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2spOyAvLyBBRERFRFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRleHQgdG8gdGhlIGlucHV0IGZpZWxkLCBwb3RlbnRpYWxseSByZXBsYWNpbmcgYSBwcmVjZWRpbmcgJ0AnIHN5bWJvbC5cbiAgICAgKi9cbiAgICBhcHBlbmRUb0lucHV0KHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmZvY3VzKCk7IC8vIEVuc3VyZSBmb2N1cyBmaXJzdFxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgYXBwZW5kIHRvIGlucHV0OiBObyBzZWxlY3Rpb24gZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGFwcGVuZCB0byBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC50ZXh0Q29udGVudCA9ICh0aGlzLmNoYXRJbnB1dC50ZXh0Q29udGVudCB8fCAnJykgKyB0ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCB9ID0gcmFuZ2U7XG4gICAgICAgICAgICBsZXQgY3VycmVudFRleHRDb250ZW50ID0gdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgfHwgJyc7IC8vIFVzZSB0ZXh0Q29udGVudFxuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICgwLCBjb250ZW50X2VkaXRhYmxlX3V0aWxzXzEuZ2V0Q2FyZXRQb3NpdGlvbikodGhpcy5jaGF0SW5wdXQpOyAvLyBHZXQgbGluZWFyIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyBTaW1wbGUgY2hlY2s6IGlmIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBsaW5lYXIgY2FyZXQgcG9zaXRpb24gaXMgJ0AnXG4gICAgICAgICAgICBpZiAoaW5zZXJ0UG9zID4gMCAmJiBjdXJyZW50VGV4dENvbnRlbnRbaW5zZXJ0UG9zIC0gMV0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlICdAJyAtIG1vcmUgY29tcGxleCB3aXRoIERPTSBtYW5pcHVsYXRpb24sXG4gICAgICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHdlJ2xsIHJlcGxhY2UgaW4gdGV4dENvbnRlbnQgYW5kIHJlc2V0XG4gICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gY3VycmVudFRleHRDb250ZW50LnNsaWNlKDAsIGluc2VydFBvcyAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gY3VycmVudFRleHRDb250ZW50LnNsaWNlKGluc2VydFBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnNvciBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICgwLCBjb250ZW50X2VkaXRhYmxlX3V0aWxzXzEuc2V0Q2FyZXRQb3NpdGlvbikodGhpcy5jaGF0SW5wdXQsIChpbnNlcnRQb3MgLSAxKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0YW5kYXJkIGluc2VydGlvbiAtIG1vcmUgY29tcGxleCB3aXRoIERPTSBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UnbGwgaW5zZXJ0IGluIHRleHRDb250ZW50IGFuZCByZXNldFxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGN1cnJlbnRUZXh0Q29udGVudC5zbGljZSgwLCBpbnNlcnRQb3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gY3VycmVudFRleHRDb250ZW50LnNsaWNlKGluc2VydFBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnNvciBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICgwLCBjb250ZW50X2VkaXRhYmxlX3V0aWxzXzEuc2V0Q2FyZXRQb3NpdGlvbikodGhpcy5jaGF0SW5wdXQsIGluc2VydFBvcyArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHkgc2luY2Ugd2UncmUgY2hhbmdpbmcgdGV4dENvbnRlbnQgZGlyZWN0bHlcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBlbmRpbmcgdG8gaW5wdXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgaW5wdXQgZmllbGQgYW5kIHJlc2V0cyBhc3NvY2lhdGVkIHN0YXRlIGFmdGVyIHNlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYXJJbnB1dCgpIHtcbiAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBkaXZcbiAgICAgICAgdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgLy8gRGlyZWN0bHkgcmVzZXQgaW50ZXJuYWwgc3RhdGUgaW5zdGVhZCBvZiByZWx5aW5nIG9uIGNhbGxiYWNrXG4gICAgICAgIHRoaXMucmVzZXRDb2RlUmVmZXJlbmNlcygpO1xuICAgICAgICAvLyBSZW1vdmUgcm93cyBtYW5pcHVsYXRpb25cbiAgICAgICAgLy8gdGhpcy5jaGF0SW5wdXQucm93cyA9IDE7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLmhlaWdodCA9ICcnOyAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGZhbHNlOyAvLyBSZXNldCBAIHN0YXRlXG4gICAgICAgIC8vIFJlc2V0IGV4cGFuZCBidXR0b24gc3RhdGUgaWYgaXQgd2FzIGV4cGFuZGVkXG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVJbnB1dEV4cGFuc2lvbihmYWxzZSk7IC8vIENvbGxhcHNlIGlucHV0XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZ2dlciBpbnB1dCBldmVudCBtYW51YWxseSBhZnRlciBjbGVhcmluZ1xuICAgICAgICB0aGlzLmNoYXRJbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXJrZG93biBtb2RlIHN0YXRlIGFuZCB1cGRhdGVzIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgKi9cbiAgICBzZXRNYXJrZG93bk1vZGUoaXNNYXJrZG93bikge1xuICAgICAgICB0aGlzLmlzTWFya2Rvd25Nb2RlID0gaXNNYXJrZG93bjtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MudXBkYXRlUGxhY2Vob2xkZXIodGhpcy5pc01hcmtkb3duTW9kZSk7XG4gICAgICAgIC8vIFVwZGF0ZSBwbGFjZWhvbGRlciBkaXJlY3RseSAoYWx0ZXJuYXRpdmUgdG8gY2FsbGJhY2spXG4gICAgICAgIC8vIHRoaXMuY2hhdElucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5pc01hcmtkb3duTW9kZSA/IFxuICAgICAgICAvLyAgICdXcml0ZSBtYXJrZG93biBoZXJlLi4uJyA6IFxuICAgICAgICAvLyAgICdBc2sgbWUgYW55dGhpbmcuLi4nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBpbnB1dCBleHBhbnNpb24gc3RhdGUgYW5kIHVwZGF0ZXMgVUkuXG4gICAgICovXG4gICAgdG9nZ2xlSW5wdXRFeHBhbnNpb24oZm9yY2VTdGF0ZSkge1xuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9IGZvcmNlU3RhdGUgIT09IHVuZGVmaW5lZCA/IGZvcmNlU3RhdGUgOiAhdGhpcy5pc0lucHV0RXhwYW5kZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgLy8gVXNlIG1heC1oZWlnaHQgb3IgaGVpZ2h0IGZvciBkaXZcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLmhlaWdodCA9ICcyMDBweCc7IC8vIEV4YW1wbGUgaGVpZ2h0XG4gICAgICAgICAgICAvLyBBbGxvdyB2ZXJ0aWNhbCByZXNpemluZyBpZiBkZXNpcmVkLCBvciBrZWVwIGFzICdub25lJ1xuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUucmVzaXplID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJzsgLy8gRW5zdXJlIHNjcm9sbGJhciBhcHBlYXJzIGlmIG5lZWRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUuaGVpZ2h0ID0gJyc7IC8vIFJlc2V0IGhlaWdodFxuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUucmVzaXplID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHJvd3MgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICAvLyB0aGlzLmNoYXRJbnB1dC5yb3dzID0gMTsgLy8gRW5zdXJlIGl0IGNvbGxhcHNlcyBiYWNrIHRvIDEgcm93IGhlaWdodFxuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7IC8vIEhpZGUgc2Nyb2xsYmFyIHdoZW4gY29sbGFwc2VkXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90aWZ5IFVJTWFuYWdlci9MYXlvdXRCdWlsZGVyIHRvIHVwZGF0ZSBidXR0b24gYXBwZWFyYW5jZVxuICAgICAgICB0aGlzLmNhbGxiYWNrcy50b2dnbGVJbnB1dEV4cGFuc2lvblVJKHRoaXMuaXNJbnB1dEV4cGFuZGVkKTtcbiAgICB9XG4gICAgLy8gLS0tIENvZGUgUmVmZXJlbmNlIE1ldGhvZHMgLS0tXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvZGUgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBtYXAgYW5kIHJldHVybnMgaXRzIElELlxuICAgICAqIEBwYXJhbSBjb2RlQ29udGVudCBUaGUgYWN0dWFsIGNvZGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0gbm90ZWJvb2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBub3RlYm9vayB0aGUgY29kZSBpcyBmcm9tLlxuICAgICAqIEBwYXJhbSBjZWxsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjZWxsIHRoZSBjb2RlIGlzIGZyb20gKDAtYmFzZWQpLlxuICAgICAqIEBwYXJhbSBsaW5lTnVtYmVyIFRoZSBzdGFydGluZyBsaW5lIG51bWJlciBvZiB0aGUgY29kZSB3aXRoaW4gdGhlIGNlbGwgKDEtYmFzZWQpLlxuICAgICAqIEBwYXJhbSBsaW5lRW5kTnVtYmVyIFRoZSBlbmRpbmcgbGluZSBudW1iZXIgb2YgdGhlIGNvZGUgd2l0aGluIHRoZSBjZWxsICgxLWJhc2VkKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHJlZmVyZW5jZSBJRCAoZS5nLiwgXCJyZWYtMVwiKS5cbiAgICAgKi9cbiAgICBhZGRDb2RlUmVmZXJlbmNlKGNvZGVDb250ZW50LCAvLyBSZW5hbWVkIHBhcmFtZXRlclxuICAgIG5vdGVib29rTmFtZSwgY2VsbEluZGV4LCBsaW5lTnVtYmVyLCAvLyBTdGFydCBsaW5lXG4gICAgbGluZUVuZE51bWJlciAvLyBFbmQgbGluZVxuICAgICkge1xuICAgICAgICBjb25zdCByZWZJZCA9IGByZWYtJHt0aGlzLm5leHRSZWZJZCsrfWA7XG4gICAgICAgIC8vIFN0b3JlIHR5cGUgYW5kIHVzZSAnY29udGVudCcgZmllbGRcbiAgICAgICAgY29uc3QgcmVmRGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvZGVDb250ZW50LCAvLyBVc2UgY29udGVudCBmaWVsZFxuICAgICAgICAgICAgbm90ZWJvb2tOYW1lLFxuICAgICAgICAgICAgY2VsbEluZGV4LFxuICAgICAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVFbmROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb2RlUmVmTWFwLnNldChyZWZJZCwgcmVmRGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRlZCBjb2RlIHJlZmVyZW5jZTonLCByZWZJZCwgJy0+JywgYCgke25vdGVib29rTmFtZX0sIENlbGwgJHtjZWxsSW5kZXggKyAxfSwgTGluZSAke2xpbmVOdW1iZXJ9JHtsaW5lTnVtYmVyICE9PSBsaW5lRW5kTnVtYmVyID8gJ18nICsgbGluZUVuZE51bWJlciA6ICcnfSkgYCArXG4gICAgICAgICAgICBjb2RlQ29udGVudC5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicgLy8gVXNlIGNvZGVDb250ZW50XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZWZJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYXAgb2YgY29kZSByZWZlcmVuY2VzLlxuICAgICAqL1xuICAgIGdldENvZGVSZWZlcmVuY2VNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVSZWZNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY29kZSByZWZlcmVuY2UgbWFwIGFuZCByZXNldHMgdGhlIElEIGNvdW50ZXIuXG4gICAgICovXG4gICAgcmVzZXRDb2RlUmVmZXJlbmNlcygpIHtcbiAgICAgICAgLy8gLS0tIERFQlVHIExPRyAtLS0gXG4gICAgICAgIGNvbnNvbGUubG9nKCdbSW5wdXRIYW5kbGVyXSByZXNldENvZGVSZWZlcmVuY2VzIGNhbGxlZCEnLCBuZXcgRXJyb3IoKS5zdGFjayk7IC8vIExvZyBjYWxsIHN0YWNrXG4gICAgICAgIC8vIC0tLSBFTkQgREVCVUcgTE9HIC0tLSBcbiAgICAgICAgdGhpcy5jb2RlUmVmTWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMubmV4dFJlZklkID0gMTtcbiAgICAgICAgY29uc29sZS5sb2coJ0NvZGUgcmVmZXJlbmNlcyByZXNldC4nKTsgLy8gRGVidWcgbG9nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGNvZGUgcmVmZXJlbmNlIHBsYWNlaG9sZGVycyAoZS5nLiwgXCJbcmVmLTFdXCIpIGluIGEgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiB3aXRoIHRoZSBhY3R1YWwgY29kZSBmcm9tIHRoZSBtYXAuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2Ugc3RyaW5nIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgcGxhY2Vob2xkZXJzLlxuICAgICAqIEBwYXJhbSBpc01hcmtkb3duIFdoZXRoZXIgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGZvcm1hdHRlZCBmb3IgbWFya2Rvd25cbiAgICAgKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgcmVzb2x2ZUNvZGVSZWZlcmVuY2VzKG1lc3NhZ2UsIGlzTWFya2Rvd24gPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5jb2RlUmVmTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlOyAvLyBObyByZWZlcmVuY2VzIHRvIHJlc29sdmVcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdleCB0byBmaW5kIHBsYWNlaG9sZGVycyBsaWtlIFtyZWYtMV0sIFtyZWYtMTJdLCBldGMuXG4gICAgICAgIC8vIEFkanVzdGVkIHJlZ2V4IHNsaWdodGx5IHRvIGJlIG5vbi1ncmVlZHkgaWYgbmVlZGVkLCB0aG91Z2ggY3VycmVudCBmb3JtYXQgaXMgZmluZS5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJSZWdleCA9IC9AKD86Y29kZXxDZWxsKVxcWyhyZWYtXFxkKylcXF18QGNvZGVcXCgoPzpbXildKylcXClcXFsocmVmLVxcZCspXFxdfFxcWyhyZWYtXFxkKylcXF0vZztcbiAgICAgICAgbGV0IHJlc29sdmVkTWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShwbGFjZWhvbGRlclJlZ2V4LCAobWF0Y2gsIHJlZklkMSwgcmVmSWQyLCByZWZJZDMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZklkID0gcmVmSWQxIHx8IHJlZklkMiB8fCByZWZJZDM7IC8vIEdldCB0aGUgY2FwdHVyZWQgcmVmSWRcbiAgICAgICAgICAgIGlmICghcmVmSWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoOyAvLyBJZiBzb21laG93IG5vIHJlZklkIGNhcHR1cmVkLCByZXR1cm4gb3JpZ2luYWwgbWF0Y2hcbiAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSB0aGlzLmNvZGVSZWZNYXAuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgIGlmIChyZWZEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlc29sdmluZyAke3JlZkRhdGEudHlwZX0gcmVmZXJlbmNlOmAsIHJlZklkKTsgLy8gRGVidWcgbG9nIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBVc2UgcmVmRGF0YS5jb250ZW50IChyZW5hbWVkIGZyb20gcmVmRGF0YS5jb2RlKVxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb250ZXh0IGJhc2VkIG9uIHR5cGU/XG4gICAgICAgICAgICAgICAgbGV0IHByZWZpeCwgc3VmZml4O1xuICAgICAgICAgICAgICAgIGlmIChpc01hcmtkb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBmb3IgbWFya2Rvd24gd2l0aCBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmcgPSByZWZEYXRhLnR5cGUgPT09ICdjb2RlJyA/ICdweXRob24nIDogJyc7IC8vIERlZmF1bHQgdG8gcHl0aG9uIGZvciBjb2RlLCBibGFuayBmb3IgY2VsbFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSByZWZEYXRhLnR5cGUgPT09ICdjZWxsJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxuXFxgXFxgXFxgJHtsYW5nfSAjIENlbGwgJHtyZWZEYXRhLmNlbGxJbmRleCArIDF9ICgke3JlZkRhdGEubm90ZWJvb2tOYW1lfSlcXG5gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXG5cXGBcXGBcXGAke2xhbmd9ICMgQ29kZSAoJHtyZWZEYXRhLm5vdGVib29rTmFtZX06Q2VsbCAke3JlZkRhdGEuY2VsbEluZGV4ICsgMX06TCR7cmVmRGF0YS5saW5lTnVtYmVyfS0ke3JlZkRhdGEubGluZUVuZE51bWJlcn0pXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gYFxcblxcYFxcYFxcYGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGFpbiB0ZXh0IGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSByZWZEYXRhLnR5cGUgPT09ICdjZWxsJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxuLS0tIFN0YXJ0IENlbGwgJHtyZWZEYXRhLmNlbGxJbmRleCArIDF9ICgke3JlZkRhdGEubm90ZWJvb2tOYW1lfSkgLS0tXFxuYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxuLS0tIFN0YXJ0IENvZGUgKCR7cmVmRGF0YS5ub3RlYm9va05hbWV9OkNlbGwgJHtyZWZEYXRhLmNlbGxJbmRleCArIDF9Okwke3JlZkRhdGEubGluZU51bWJlcn0tJHtyZWZEYXRhLmxpbmVFbmROdW1iZXJ9KSAtLS1cXG5gO1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSByZWZEYXRhLnR5cGUgPT09ICdjZWxsJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxuLS0tIEVuZCBDZWxsICR7cmVmRGF0YS5jZWxsSW5kZXggKyAxfSAtLS1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tLS0gRW5kIENvZGUgLS0tYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke3JlZkRhdGEuY29udGVudH0ke3N1ZmZpeH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBkYXRhIGZvciByZWZlcmVuY2U6JywgcmVmSWQpOyAvLyBXYXJuIGlmIHJlZiBJRCBub3QgZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7IC8vIEtlZXAgdGhlIHBsYWNlaG9sZGVyIGlmIG5vdCBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkTWVzc2FnZTtcbiAgICB9XG4gICAgLy8gTkVXIG1ldGhvZCBzcGVjaWZpY2FsbHkgZm9yIEN0cmwrTCBzaG9ydGN1dFxuICAgIGhhbmRsZUluc2VydENvZGVSZWZlcmVuY2VGcm9tU2hvcnRjdXQoc2VsZWN0ZWRUZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBjdXJyZW50Tm90ZWJvb2tXaWRnZXQgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBjb25zdCBhY3RpdmVDZWxsID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0aXZlQ2VsbDtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlQ2VsbCA9PT0gbnVsbCB8fCBhY3RpdmVDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVDZWxsLmVkaXRvcjtcbiAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IgPyBlZGl0b3IuZWRpdG9yIDogbnVsbDsgLy8gQ29kZU1pcnJvciB2aWV3XG4gICAgICAgIGlmICghY3VycmVudE5vdGVib29rV2lkZ2V0IHx8ICFhY3RpdmVDZWxsIHx8ICFlZGl0b3IgfHwgIWNtRWRpdG9yIHx8ICFjbUVkaXRvci5zdGF0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGluc2VydCBjb2RlIHJlZmVyZW5jZTogTWlzc2luZyBub3RlYm9vaywgY2VsbCwgb3IgZWRpdG9yIGNvbnRleHQuJyk7XG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IHNob3cgYW4gaW5kaWNhdG9yIHZpYSBjYWxsYmFja3M/XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIEdhdGhlciBDb250ZXh0XG4gICAgICAgICAgICBjb25zdCBub3RlYm9va1BhdGggPSBjdXJyZW50Tm90ZWJvb2tXaWRnZXQuY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tOYW1lID0gKChfYyA9IG5vdGVib29rUGF0aC5zcGxpdCgnLycpLnBvcCgpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3BsaXQoJy4nKVswXSkgfHwgJ25vdGVib29rJztcbiAgICAgICAgICAgIGNvbnN0IGNlbGxJbmRleCA9IGN1cnJlbnROb3RlYm9va1dpZGdldC5jb250ZW50LmFjdGl2ZUNlbGxJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY21FZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc2VsZWN0aW9uLmZyb20pLm51bWJlcjsgLy8gMS1iYXNlZFxuICAgICAgICAgICAgY29uc3QgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc2VsZWN0aW9uLnRvKS5udW1iZXI7IC8vIDEtYmFzZWRcbiAgICAgICAgICAgIGlmIChjZWxsSW5kZXggPT09IHVuZGVmaW5lZCB8fCBjZWxsSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgaW5zZXJ0IGNvZGUgcmVmZXJlbmNlOiBDb3VsZCBub3QgZGV0ZXJtaW5lIGFjdGl2ZSBjZWxsIGluZGV4LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBSZWYgRGF0YSAoYnV0IGRvbid0IG5lY2Vzc2FyaWx5IGFkZCB0byBtYXAgeWV0PyBPciBkbz8pXG4gICAgICAgICAgICAvLyBMZXQncyBhZGQgaXQgbm93IGZvciBjb25zaXN0ZW5jeS5cbiAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHNlbGVjdGVkVGV4dCxcbiAgICAgICAgICAgICAgICBub3RlYm9va05hbWUsXG4gICAgICAgICAgICAgICAgY2VsbEluZGV4LFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICBsaW5lRW5kTnVtYmVyOiBlbmRMaW5lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBgcmVmLSR7dGhpcy5uZXh0UmVmSWQrK31gO1xuICAgICAgICAgICAgdGhpcy5jb2RlUmVmTWFwLnNldChyZWZJZCwgcmVmRGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkZWQgY29kZSByZWZlcmVuY2UgdmlhIHNob3J0Y3V0OiAke3JlZklkfWApO1xuICAgICAgICAgICAgLy8gQURERUQ6IENvbnN0cnVjdCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgQGNvZGVbJHtyZWZJZH1dYDtcbiAgICAgICAgICAgIC8vIDMuIEluc2VydCBSRU5ERVJFRCBXSURHRVQgUmVwcmVzZW50YXRpb24gaW50byBJbnB1dCBGaWVsZFxuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuZm9jdXMoKTsgLy8gRW5zdXJlIGZvY3VzXG4gICAgICAgICAgICBjb25zdCB3aW5TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIXdpblNlbGVjdGlvbiB8fCB3aW5TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBpbnNlcnQgcmVmZXJlbmNlIHdpZGdldDogTm8gd2luZG93IHNlbGVjdGlvbiBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBtaWdodCBiZSBjb21wbGV4LCBtYXliZSBqdXN0IGxvZyBlcnJvciBmb3Igbm93XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB3aW5TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgd2lkZ2V0IC0gUGFzcyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0RWxlbWVudCA9ICgwLCBtZXNzYWdlX3JlbmRlcmVyXzEucmVuZGVyUmVmZXJlbmNlV2lkZ2V0SW5saW5lKSgnY29kZScsIHJlZkRhdGEsIHBsYWNlaG9sZGVyLCByZWZJZCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB6ZXJvLXdpZHRoIHNwYWNlIHRleHQgbm9kZSBmb3IgY3Vyc29yIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICBjb25zdCB6ZXJvV2lkdGhTcGFjZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDBCJyk7XG4gICAgICAgICAgICAvLyBBZGQgYSBub3JtYWwgc3BhY2UgZm9yIHNlcGFyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHNwYWNlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpOyAvLyBDbGVhciBhbnkgZXhpc3Rpbmcgc2VsZWN0aW9uIGluIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShzcGFjZU5vZGUpOyAvLyBJbnNlcnQgc3BhY2UgZmlyc3RcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUod2lkZ2V0RWxlbWVudCk7IC8vIEluc2VydCB0aGUgd2lkZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoemVyb1dpZHRoU3BhY2UpOyAvLyBJbnNlcnQgWldTIGFmdGVyIHdpZGdldFxuICAgICAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWZ0ZXIgdGhlIHplcm8td2lkdGggc3BhY2UgKGVmZmVjdGl2ZWx5IGFmdGVyIHRoZSB3aWRnZXQgKyBzcGFjZSlcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIoemVyb1dpZHRoU3BhY2UpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoemVyb1dpZHRoU3BhY2UpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIC8vIC0tLSBFbmQgSW5zZXJ0aW9uIExvZ2ljIC0tLVxuICAgICAgICAgICAgLy8gVHJpZ2dlciBpbnB1dCBldmVudCBtYW51YWxseVxuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIGluc2VydCBjb2RlIHJlZmVyZW5jZSBmcm9tIHNob3J0Y3V0OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBORVc6IE1ldGhvZCB0byBhZGQgYSBjZWxsIHJlZmVyZW5jZVxuICAgIGFkZENlbGxSZWZlcmVuY2Uobm90ZWJvb2tOYW1lLCBjZWxsSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub3RlYm9va1BhbmVsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKCFub3RlYm9va1BhbmVsIHx8ICFub3RlYm9va1BhbmVsLmNvbnRlbnQubW9kZWwgfHwgIW5vdGVib29rUGFuZWwuY29udGVudC5tb2RlbC5jZWxscykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGFkZCBjZWxsIHJlZmVyZW5jZTogTm90ZWJvb2sgb3IgY2VsbHMgbm90IGZvdW5kLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSBub3RlYm9va1BhbmVsLmNvbnRlbnQubW9kZWw7XG4gICAgICAgIGlmIChjZWxsSW5kZXggPCAwIHx8IGNlbGxJbmRleCA+PSBtb2RlbC5jZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENhbm5vdCBhZGQgY2VsbCByZWZlcmVuY2U6IEludmFsaWQgY2VsbCBpbmRleCAke2NlbGxJbmRleH1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGwgPSBtb2RlbC5jZWxscy5nZXQoY2VsbEluZGV4KTtcbiAgICAgICAgbGV0IGNlbGxDb250ZW50ID0gJyc7XG4gICAgICAgIC8vIEdldCBjZWxsIGNvbnRlbnQgLSBoYW5kbGUgZGlmZmVyZW50IHdheXMgY29udGVudCBtaWdodCBiZSBzdG9yZWRcbiAgICAgICAgaWYgKGNlbGwuc2hhcmVkTW9kZWwgJiYgdHlwZW9mIGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjZWxsQ29udGVudCA9IGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsSnNvbiA9IGNlbGwudG9KU09OKCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA9IHNvdXJjZS5qb2luKCdcXG4nKTsgLy8gQ29ycmVjdGVkOiBVc2UgYWN0dWFsIG5ld2xpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZJZCA9IGByZWYtJHt0aGlzLm5leHRSZWZJZCsrfWA7XG4gICAgICAgIGNvbnN0IHJlZkRhdGEgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY2VsbCcsXG4gICAgICAgICAgICBjb250ZW50OiBjZWxsQ29udGVudCxcbiAgICAgICAgICAgIG5vdGVib29rTmFtZSxcbiAgICAgICAgICAgIGNlbGxJbmRleFxuICAgICAgICAgICAgLy8gbGluZU51bWJlci9saW5lRW5kTnVtYmVyIGFyZSBvbWl0dGVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29kZVJlZk1hcC5zZXQocmVmSWQsIHJlZkRhdGEpO1xuICAgICAgICAvLyBDb21iaW5lIGNvbnNvbGUubG9nIGludG8gb25lIGxpbmVcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGVkIGNlbGwgcmVmZXJlbmNlOiAke3JlZklkfSAtPiAoJHtub3RlYm9va05hbWV9LCBDZWxsICR7Y2VsbEluZGV4ICsgMX0pICR7Y2VsbENvbnRlbnQuc3Vic3RyaW5nKDAsIDMwKX0uLi5gKTtcbiAgICAgICAgcmV0dXJuIHJlZklkO1xuICAgIH1cbiAgICAvLyBORVcgbWV0aG9kIHNwZWNpZmljYWxseSBmb3IgQ3RybCtMIHNob3J0Y3V0IChDZWxsKVxuICAgIGhhbmRsZUluc2VydENlbGxSZWZlcmVuY2VGcm9tU2hvcnRjdXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBjdXJyZW50Tm90ZWJvb2tXaWRnZXQgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBjb25zdCBhY3RpdmVDZWxsID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm90ZWJvb2tXaWRnZXQgfHwgIWFjdGl2ZUNlbGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBpbnNlcnQgY2VsbCByZWZlcmVuY2U6IE1pc3Npbmcgbm90ZWJvb2sgb3IgY2VsbCBjb250ZXh0LicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAxLiBHYXRoZXIgQ29udGV4dFxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYXRoID0gY3VycmVudE5vdGVib29rV2lkZ2V0LmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTmFtZSA9ICgoX2MgPSBub3RlYm9va1BhdGguc3BsaXQoJy8nKS5wb3AoKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwbGl0KCcuJylbMF0pIHx8ICdub3RlYm9vayc7XG4gICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBjdXJyZW50Tm90ZWJvb2tXaWRnZXQuY29udGVudC5hY3RpdmVDZWxsSW5kZXg7XG4gICAgICAgICAgICBpZiAoY2VsbEluZGV4ID09PSB1bmRlZmluZWQgfHwgY2VsbEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGluc2VydCBjZWxsIHJlZmVyZW5jZTogQ291bGQgbm90IGRldGVybWluZSBhY3RpdmUgY2VsbCBpbmRleC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyLiBBZGQgQ2VsbCBSZWZlcmVuY2UgdG8gTWFwIGFuZCBnZXQgZGF0YVxuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLmFkZENlbGxSZWZlcmVuY2Uobm90ZWJvb2tOYW1lLCBjZWxsSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFyZWZJZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhZGQgY2VsbCByZWZlcmVuY2UgdG8gbWFwLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU3RvcCBpZiB3ZSBjb3VsZG4ndCBjcmVhdGUgdGhlIHJlZmVyZW5jZSBkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWZEYXRhID0gdGhpcy5jb2RlUmVmTWFwLmdldChyZWZJZCk7XG4gICAgICAgICAgICBpZiAoIXJlZkRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgZGF0YSBmb3IgY2VsbCByZWZlcmVuY2UgJHtyZWZJZH0uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQURERUQ6IENvbnN0cnVjdCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgQENlbGxbJHtjZWxsSW5kZXggKyAxfV1gO1xuICAgICAgICAgICAgLy8gMy4gSW5zZXJ0IFJFTkRFUkVEIFdJREdFVCBSZXByZXNlbnRhdGlvbiBpbnRvIElucHV0IEZpZWxkXG4gICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5mb2N1cygpOyAvLyBFbnN1cmUgZm9jdXNcbiAgICAgICAgICAgIGNvbnN0IHdpblNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghd2luU2VsZWN0aW9uIHx8IHdpblNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGluc2VydCByZWZlcmVuY2Ugd2lkZ2V0OiBObyB3aW5kb3cgc2VsZWN0aW9uIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gd2luU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHdpZGdldCAtIFBhc3MgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldEVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclJlZmVyZW5jZVdpZGdldElubGluZSkoJ2NlbGwnLCByZWZEYXRhLCBwbGFjZWhvbGRlciwgcmVmSWQpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgemVyby13aWR0aCBzcGFjZSB0ZXh0IG5vZGUgZm9yIGN1cnNvciBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgY29uc3QgemVyb1dpZHRoU3BhY2UgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjAwQicpO1xuICAgICAgICAgICAgLy8gQWRkIGEgbm9ybWFsIHNwYWNlIGZvciBzZXBhcmF0aW9uXG4gICAgICAgICAgICBjb25zdCBzcGFjZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpO1xuICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTsgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHNlbGVjdGlvbiBpbiB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoc3BhY2VOb2RlKTsgLy8gSW5zZXJ0IHNwYWNlIGZpcnN0XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHdpZGdldEVsZW1lbnQpOyAvLyBJbnNlcnQgdGhlIHdpZGdldCBlbGVtZW50XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHplcm9XaWR0aFNwYWNlKTsgLy8gSW5zZXJ0IFpXUyBhZnRlciB3aWRnZXRcbiAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIHRoZSB6ZXJvLXdpZHRoIHNwYWNlXG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHplcm9XaWR0aFNwYWNlKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKHplcm9XaWR0aFNwYWNlKTtcbiAgICAgICAgICAgIHdpblNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHdpblNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGlucHV0IGV2ZW50IG1hbnVhbGx5XG4gICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgaW5zZXJ0IGNlbGwgcmVmZXJlbmNlIGZyb20gc2hvcnRjdXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5FVyBtZXRob2QgZm9yIGluc2VydGluZyBGaWxlIHdpZGdldHMgZnJvbSBQb3B1cFxuICAgIGhhbmRsZUluc2VydEZpbGVXaWRnZXQoZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuZm9jdXMoKTsgLy8gRW5zdXJlIGZvY3VzXG4gICAgICAgICAgICBjb25zdCB3aW5TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIXdpblNlbGVjdGlvbiB8fCB3aW5TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBpbnNlcnQgZmlsZSB3aWRnZXQ6IE5vIHdpbmRvdyBzZWxlY3Rpb24gZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiByYW5nZVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB3aW5TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgQGZpbGVbJHtmaWxlUGF0aH1dYDtcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgd2lkZ2V0IC0gUGFzcyBwbGFjZWhvbGRlciAobm8gcmVmSWQgbmVlZGVkKVxuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0RWxlbWVudCA9ICgwLCBtZXNzYWdlX3JlbmRlcmVyXzEucmVuZGVyUmVmZXJlbmNlV2lkZ2V0SW5saW5lKSgnZmlsZScsIGZpbGVQYXRoLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB6ZXJvLXdpZHRoIHNwYWNlIHRleHQgbm9kZSBmb3IgY3Vyc29yIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICBjb25zdCB6ZXJvV2lkdGhTcGFjZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDBCJyk7XG4gICAgICAgICAgICAvLyBBZGQgYSBub3JtYWwgc3BhY2UgZm9yIHNlcGFyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHNwYWNlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgY3Vyc29yIGlzICdAJyBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgbGV0IHJlcGxhY2VkQXRTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydE9mZnNldCA+IDAgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEJlZm9yZSA9IChfYSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJlZm9yZSA9PT0gbnVsbCB8fCB0ZXh0QmVmb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0QmVmb3JlLmVuZHNXaXRoKCdAJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSByYW5nZSB0byBpbmNsdWRlIHRoZSAnQCdcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VkQXRTeW1ib2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlcGxhY2luZyBAIHN5bWJvbCBiZWZvcmUgaW5zZXJ0aW5nIGZpbGUgd2lkZ2V0LlwiKTsgLy8gRGVidWcgbG9nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV3JhcCB0aGUgd2lkZ2V0IGFuZCBhZGRpdGlvbmFsIG5vZGVzIGluIGEgZnJhZ21lbnQgZm9yIGNsZWFuZXIgaW5zZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdpZGdldEVsZW1lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoU3BhY2UpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3BhY2VOb2RlKTtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhbnkgc2VsZWN0ZWQgY29udGVudCAoaW5jbHVkaW5nIEAgaWYgZm91bmQpXG4gICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBmcmFnbWVudCB3aXRoIGFsbCBlbGVtZW50c1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShmcmFnbWVudCk7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IG1vdmUgY3Vyc29yIGFmdGVyIHRoZSBpbnNlcnRlZCBzcGFjZSBub2RlXG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydEFmdGVyKHNwYWNlTm9kZSk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRFbmRBZnRlcihzcGFjZU5vZGUpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBpbnNlcnQgZmlsZSB3aWRnZXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5FVyBtZXRob2QgZm9yIGluc2VydGluZyBEaXJlY3Rvcnkgd2lkZ2V0cyBmcm9tIFBvcHVwXG4gICAgaGFuZGxlSW5zZXJ0RGlyV2lkZ2V0KGRpclBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuZm9jdXMoKTsgLy8gRW5zdXJlIGZvY3VzXG4gICAgICAgICAgICBjb25zdCB3aW5TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIXdpblNlbGVjdGlvbiB8fCB3aW5TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBpbnNlcnQgZGlyZWN0b3J5IHdpZGdldDogTm8gd2luZG93IHNlbGVjdGlvbiBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHdpblNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBAZGlyWyR7ZGlyUGF0aH1dYDtcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgd2lkZ2V0IC0gUGFzcyBwbGFjZWhvbGRlciAobm8gcmVmSWQgbmVlZGVkKVxuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0RWxlbWVudCA9ICgwLCBtZXNzYWdlX3JlbmRlcmVyXzEucmVuZGVyUmVmZXJlbmNlV2lkZ2V0SW5saW5lKSgnZGlyJywgZGlyUGF0aCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgemVyby13aWR0aCBzcGFjZSB0ZXh0IG5vZGUgZm9yIGN1cnNvciBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgY29uc3QgemVyb1dpZHRoU3BhY2UgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjAwQicpO1xuICAgICAgICAgICAgLy8gQWRkIGEgbm9ybWFsIHNwYWNlIGZvciBzZXBhcmF0aW9uXG4gICAgICAgICAgICBjb25zdCBzcGFjZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlIGN1cnNvciBpcyAnQCcgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICAgIGxldCByZXBsYWNlZEF0U3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRPZmZzZXQgPiAwICYmIHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRCZWZvcmUgPSAoX2EgPSByYW5nZS5zdGFydENvbnRhaW5lci50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnN0cmluZygwLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCZWZvcmUgPT09IG51bGwgfHwgdGV4dEJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dEJlZm9yZS5lbmRzV2l0aCgnQCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgcmFuZ2UgdG8gaW5jbHVkZSB0aGUgJ0AnXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlZEF0U3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZXBsYWNpbmcgQCBzeW1ib2wgYmVmb3JlIGluc2VydGluZyBkaXIgd2lkZ2V0LlwiKTsgLy8gRGVidWcgbG9nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV3JhcCB0aGUgd2lkZ2V0IGFuZCBhZGRpdGlvbmFsIG5vZGVzIGluIGEgZnJhZ21lbnQgZm9yIGNsZWFuZXIgaW5zZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdpZGdldEVsZW1lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoU3BhY2UpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3BhY2VOb2RlKTtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhbnkgc2VsZWN0ZWQgY29udGVudCAoaW5jbHVkaW5nIEAgaWYgZm91bmQpXG4gICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBmcmFnbWVudCB3aXRoIGFsbCBlbGVtZW50c1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShmcmFnbWVudCk7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IG1vdmUgY3Vyc29yIGFmdGVyIHRoZSBpbnNlcnRlZCBzcGFjZSBub2RlXG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydEFmdGVyKHNwYWNlTm9kZSk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRFbmRBZnRlcihzcGFjZU5vZGUpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBpbnNlcnQgZGlyZWN0b3J5IHdpZGdldDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTkVXIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIENlbGwgd2lkZ2V0cyBmcm9tIFBvcHVwXG4gICAgaGFuZGxlSW5zZXJ0Q2VsbFdpZGdldEZyb21Qb3B1cChjZWxsSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGN1cnJlbnROb3RlYm9va1dpZGdldCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgIGlmICghY3VycmVudE5vdGVib29rV2lkZ2V0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgaW5zZXJ0IGNlbGwgd2lkZ2V0OiBNaXNzaW5nIG5vdGVib29rIGNvbnRleHQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIEdhdGhlciBDb250ZXh0IChOb3RlYm9vayBOYW1lKVxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYXRoID0gY3VycmVudE5vdGVib29rV2lkZ2V0LmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTmFtZSA9ICgoX2IgPSBub3RlYm9va1BhdGguc3BsaXQoJy8nKS5wb3AoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNwbGl0KCcuJylbMF0pIHx8ICdub3RlYm9vayc7XG4gICAgICAgICAgICAvLyBQcm92aWRlZCBjZWxsSW5kZXggaXMgMC1iYXNlZCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoY2VsbEluZGV4ID09PSB1bmRlZmluZWQgfHwgY2VsbEluZGV4ID09PSBudWxsIHx8IGNlbGxJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDYW5ub3QgaW5zZXJ0IGNlbGwgd2lkZ2V0OiBJbnZhbGlkIGNlbGwgaW5kZXggJHtjZWxsSW5kZXh9LmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIuIEFkZCBDZWxsIFJlZmVyZW5jZSB0byBNYXAgYW5kIGdldCBkYXRhXG4gICAgICAgICAgICBjb25zdCByZWZJZCA9IHRoaXMuYWRkQ2VsbFJlZmVyZW5jZShub3RlYm9va05hbWUsIGNlbGxJbmRleCk7XG4gICAgICAgICAgICBpZiAoIXJlZklkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFkZCBjZWxsIHJlZmVyZW5jZSB0byBtYXAgZm9yIGluZGV4OicsIGNlbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdG9wIGlmIHdlIGNvdWxkbid0IGNyZWF0ZSB0aGUgcmVmZXJlbmNlIGRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSB0aGlzLmNvZGVSZWZNYXAuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgIGlmICghcmVmRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byByZXRyaWV2ZSBkYXRhIGZvciBjZWxsIHJlZmVyZW5jZSAke3JlZklkfS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBRERFRDogQ29uc3RydWN0IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBAQ2VsbFske2NlbGxJbmRleCArIDF9XWA7XG4gICAgICAgICAgICAvLyAzLiBJbnNlcnQgUkVOREVSRUQgV0lER0VUIFJlcHJlc2VudGF0aW9uIGludG8gSW5wdXQgRmllbGRcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmZvY3VzKCk7IC8vIEVuc3VyZSBmb2N1c1xuICAgICAgICAgICAgY29uc3Qgd2luU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCF3aW5TZWxlY3Rpb24gfHwgd2luU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgaW5zZXJ0IGNlbGwgd2lkZ2V0OiBObyB3aW5kb3cgc2VsZWN0aW9uIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gd2luU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHdpZGdldCAtIFBhc3MgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldEVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclJlZmVyZW5jZVdpZGdldElubGluZSkoJ2NlbGwnLCByZWZEYXRhLCBwbGFjZWhvbGRlciwgcmVmSWQpO1xuICAgICAgICAgICAgY29uc3QgemVyb1dpZHRoU3BhY2UgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjAwQicpO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBjdXJzb3IgaXMgJ0AnIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgICBsZXQgcmVwbGFjZWRBdFN5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0T2Zmc2V0ID4gMCAmJiByYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0QmVmb3JlID0gKF9jID0gcmFuZ2Uuc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0QmVmb3JlID09PSBudWxsIHx8IHRleHRCZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRCZWZvcmUuZW5kc1dpdGgoJ0AnKSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWRBdFN5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVwbGFjaW5nIEAgc3ltYm9sIGJlZm9yZSBpbnNlcnRpbmcgY2VsbCB3aWRnZXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGZyYWdtZW50IHRvIGhvbGQgb3VyIG5vZGVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdpZGdldEVsZW1lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoU3BhY2UpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3BhY2VOb2RlKTtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhbnkgc2VsZWN0ZWQgY29udGVudCAoaW5jbHVkaW5nIEAgaWYgZm91bmQpXG4gICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGFsbCBlbGVtZW50cyBhdCBvbmNlIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGZyYWdtZW50KTtcbiAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIHRoZSB6ZXJvLXdpZHRoIHNwYWNlXG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHNwYWNlTm9kZSk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihzcGFjZU5vZGUpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBpbnNlcnQgY2VsbCB3aWRnZXQgZnJvbSBwb3B1cDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTkVXIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIENvZGUgd2lkZ2V0cyBmcm9tIFBvcHVwICh2aWEgaW5zZXJ0Q29sbGFwc2VkQ29kZVJlZiBjYWxsYmFjaylcbiAgICBoYW5kbGVJbnNlcnRDb2RlV2lkZ2V0RnJvbVBvcHVwKGNvZGVDb250ZW50LCBub3RlYm9va05hbWUsIGNlbGxJbmRleCwgbGluZU51bWJlciAvLyBBc3N1bWVzIHN0YXJ0IGxpbmUgPSBlbmQgbGluZSBmcm9tIHBvcHVwIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSBSZWYgRGF0YSAoYXNzdW1lIHN0YXJ0PWVuZCBsaW5lKVxuICAgICAgICAgICAgY29uc3QgbGluZUVuZE51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCByZWZEYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb2RlQ29udGVudCxcbiAgICAgICAgICAgICAgICBub3RlYm9va05hbWUsXG4gICAgICAgICAgICAgICAgY2VsbEluZGV4LFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZUVuZE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlZklkID0gYHJlZi0ke3RoaXMubmV4dFJlZklkKyt9YDtcbiAgICAgICAgICAgIHRoaXMuY29kZVJlZk1hcC5zZXQocmVmSWQsIHJlZkRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEFkZGVkIGNvZGUgcmVmZXJlbmNlIHZpYSBwb3B1cDogJHtyZWZJZH1gKTtcbiAgICAgICAgICAgIC8vIEFEREVEOiBDb25zdHJ1Y3QgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYEBjb2RlWyR7cmVmSWR9XWA7XG4gICAgICAgICAgICAvLyAyLiBJbnNlcnQgUkVOREVSRUQgV0lER0VUIFJlcHJlc2VudGF0aW9uIGludG8gSW5wdXQgRmllbGRcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmZvY3VzKCk7IC8vIEVuc3VyZSBmb2N1c1xuICAgICAgICAgICAgY29uc3Qgd2luU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCF3aW5TZWxlY3Rpb24gfHwgd2luU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgaW5zZXJ0IGNvZGUgd2lkZ2V0OiBObyB3aW5kb3cgc2VsZWN0aW9uIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gd2luU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHdpZGdldCAtIFBhc3MgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldEVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclJlZmVyZW5jZVdpZGdldElubGluZSkoJ2NvZGUnLCByZWZEYXRhLCBwbGFjZWhvbGRlciwgcmVmSWQpO1xuICAgICAgICAgICAgY29uc3QgemVyb1dpZHRoU3BhY2UgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjAwQicpO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBjdXJzb3IgaXMgJ0AnIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgICBsZXQgcmVwbGFjZWRBdFN5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0T2Zmc2V0ID4gMCAmJiByYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0QmVmb3JlID0gKF9hID0gcmFuZ2Uuc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0QmVmb3JlID09PSBudWxsIHx8IHRleHRCZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRCZWZvcmUuZW5kc1dpdGgoJ0AnKSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWRBdFN5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVwbGFjaW5nIEAgc3ltYm9sIGJlZm9yZSBpbnNlcnRpbmcgY29kZSB3aWRnZXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGZyYWdtZW50IHRvIGhvbGQgb3VyIG5vZGVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdpZGdldEVsZW1lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoU3BhY2UpO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3BhY2VOb2RlKTtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhbnkgc2VsZWN0ZWQgY29udGVudCAoaW5jbHVkaW5nIEAgaWYgZm91bmQpXG4gICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGFsbCBlbGVtZW50cyBhdCBvbmNlIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGZyYWdtZW50KTtcbiAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIHRoZSB6ZXJvLXdpZHRoIHNwYWNlXG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHNwYWNlTm9kZSk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihzcGFjZU5vZGUpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgd2luU2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBpbnNlcnQgY29kZSB3aWRnZXQgZnJvbSBwb3B1cDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTkVXIG1ldGhvZCB0byBzZXJpYWxpemUgaW5wdXQgY29udGVudCwgY29udmVydGluZyB3aWRnZXRzIGJhY2sgdG8gcGxhY2Vob2xkZXJzXG4gICAgX3NlcmlhbGl6ZUlucHV0Q29udGVudCgpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQgPSAnJztcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLmNoYXRJbnB1dC5jaGlsZE5vZGVzO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRleHQgY29udGVudCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gbm9kZS50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBvdXIgd2lkZ2V0IHNwYW5cbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gZWxlbWVudC5jbGFzc0xpc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucygnanAtbGxtLWV4dC1yZWYtd2lkZ2V0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdG9yZWQgcGxhY2Vob2xkZXIgdGV4dFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGVsZW1lbnQuZGF0YXNldC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGFwcGVuZCB0aGUgdmlzaWJsZSB0ZXh0IGlmIHBsYWNlaG9sZGVyIGlzIG1pc3NpbmcgKHNob3VsZG4ndCBoYXBwZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dpZGdldCBmb3VuZCB3aXRob3V0IGRhdGEtcGxhY2Vob2xkZXI6JywgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9IGVsZW1lbnQudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSA8YnI+IGFzIG5ld2xpbmVcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnRElWJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgPGRpdj4gZWxlbWVudHMsIHBvdGVudGlhbGx5IGludHJvZHVjZWQgYnkgcGFzdGluZyBvciBTaGlmdCtFbnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb3IganVzdCBhZGQgbmV3bGluZT9cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5ld2xpbmUgYmVmb3JlIGFuZCBzZXJpYWxpemUgaW5uZXIgY29udGVudCByZWN1cnNpdmVseT9cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgbGV0J3MgdHJlYXQgZGl2IGJvdW5kYXJpZXMgYXMgcG90ZW50aWFsIG5ld2xpbmVzLCBzaW1pbGFyIHRvIDxicj5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgbmVlZCBhIG1vcmUgcm9idXN0IEhUTUwgLT4gdGV4dCBjb252ZXJzaW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gJ1xcbic7IC8vIFNpbXBsaWZpZWQgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0ZXh0IGNvbnRlbnQgb2Ygb3RoZXIgdW5rbm93biBlbGVtZW50cz9cbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBlbGVtZW50LnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gcG90ZW50aWFsbHkgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGludHJvZHVjZWQgZHVyaW5nIHNlcmlhbGl6YXRpb25cbiAgICAgICAgLy8gb3IgYnkgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udGVudGVkaXRhYmxlIGRpdlxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC50cmltKCk7XG4gICAgfVxuICAgIHNob3dXaWRnZXRQcmV2aWV3KHdpZGdldEVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHByZXZpZXcgZmlyc3RcbiAgICAgICAgdGhpcy5yZW1vdmVXaWRnZXRQcmV2aWV3KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTaG93aW5nIHByZXZpZXcgZm9yIHdpZGdldDonLCB3aWRnZXRFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZmlyc3RUaHJlZUxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJykuc2xpY2UoMCwgMykuam9pbignXFxuJyk7XG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC13aWRnZXQtcHJldmlldyc7XG4gICAgICAgIC8vIEJhc2ljIHN0eWxpbmcgKG1vdmUgdG8gQ1NTIGxhdGVyKVxuICAgICAgICBwcmV2aWV3LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgcHJldmlldy5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHZhcigtLWpwLWJvcmRlci1jb2xvcjEpJztcbiAgICAgICAgcHJldmlldy5zdHlsZS5iYWNrZ3JvdW5kID0gJ3ZhcigtLWpwLWxheW91dC1jb2xvcjApJztcbiAgICAgICAgcHJldmlldy5zdHlsZS5wYWRkaW5nID0gJzVweCc7XG4gICAgICAgIHByZXZpZXcuc3R5bGUuZm9udFNpemUgPSAnMC45ZW0nO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLm1heFdpZHRoID0gJzQwMHB4JztcbiAgICAgICAgcHJldmlldy5zdHlsZS5tYXhIZWlnaHQgPSAnMTAwcHgnO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHByZXZpZXcuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7IC8vIFByZXNlcnZlIHdoaXRlc3BhY2UgYW5kIG5ld2xpbmVzXG4gICAgICAgIHByZXZpZXcuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLnpJbmRleCA9ICcxMDAwMCc7IC8vIEVuc3VyZSBpdCdzIG9uIHRvcFxuICAgICAgICBwcmV2aWV3LnN0eWxlLmJveFNoYWRvdyA9ICcwIDJweCA1cHggcmdiYSgwLDAsMCwwLjIpJztcbiAgICAgICAgcHJldmlldy50ZXh0Q29udGVudCA9IGZpcnN0VGhyZWVMaW5lcyArIChjb250ZW50LnNwbGl0KCdcXG4nKS5sZW5ndGggPiAzID8gJ1xcbi4uLicgOiAnJyk7XG4gICAgICAgIC8vIFBvc2l0aW9uIG5lYXIgdGhlIHdpZGdldFxuICAgICAgICBjb25zdCB3aWRnZXRSZWN0ID0gd2lkZ2V0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gUG9zaXRpb24gYWJvdmUgdGhlIHdpZGdldCBmb3Igbm93XG4gICAgICAgIHByZXZpZXcuc3R5bGUuYm90dG9tID0gYCR7d2luZG93LmlubmVySGVpZ2h0IC0gd2lkZ2V0UmVjdC50b3AgKyA1fXB4YDtcbiAgICAgICAgcHJldmlldy5zdHlsZS5sZWZ0ID0gYCR7d2lkZ2V0UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3KTsgLy8gQXBwZW5kIHRvIGJvZHkgdG8gYXZvaWQgbGF5b3V0IGlzc3Vlc1xuICAgICAgICB0aGlzLmFjdGl2ZVByZXZpZXdFbGVtZW50ID0gcHJldmlldztcbiAgICB9XG4gICAgcmVtb3ZlV2lkZ2V0UHJldmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUHJldmlld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdmluZyBhY3RpdmUgcHJldmlldycpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcmV2aWV3RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJldmlld0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgLy8gSGFuZGxlIEAgc3ltYm9sIHJlbW92YWwgdG8gaGlkZSBwb3B1cCB1c2luZyBzZWxlY3Rpb24gQVBJXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc2VsZWN0aW9uLnJhbmdlQ291bnQpIHJldHVybjtcbiAgXG4gICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGlucHV0IGZpZWxkIGNvbnRhaW5zIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2VcbiAgICAgIGlmICghdGhpcy5jaGF0SW5wdXQuY29udGFpbnMocmFuZ2Uuc3RhcnRDb250YWluZXIpKSByZXR1cm47XG4gIFxuICAgICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBnZXRDYXJldFBvc2l0aW9uKHRoaXMuY2hhdElucHV0KTsgLy8gVXNlIGhlbHBlclxuICAgICAgaWYgKGN1cnNvclBvc2l0aW9uID09PSBudWxsKSByZXR1cm47XG4gIFxuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB0aGlzLmNoYXRJbnB1dC50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgIGNvbnN0IHRleHRCZWZvcmVDdXJzb3IgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBjdXJzb3JQb3NpdGlvbik7XG4gIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnNvciBpcyAnQCdcbiAgICAgIC8vIGFuZCBpZiBpdCdzIHByZWNlZGVkIGJ5IHdoaXRlc3BhY2Ugb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgIGNvbnN0IGlzQXRTeW1ib2xDb250ZXh0ID0gdGV4dEJlZm9yZUN1cnNvci5lbmRzV2l0aCgnQCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJzb3JQb3NpdGlvbiA9PT0gMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yUG9zaXRpb24gPiAxICYmIC9cXHMvLnRlc3QodGV4dEJlZm9yZUN1cnNvcltjdXJzb3JQb3NpdGlvbiAtIDJdKSk7XG4gIFxuICAgICAgaWYgKHRoaXMuaGFzQXRTeW1ib2wgJiYgIWlzQXRTeW1ib2xDb250ZXh0KSB7XG4gICAgICAgIC8vIEAgc3ltYm9sIGNvbnRleHQgd2FzIHByZXNlbnQgYnV0IG5vdyBpdCdzIGdvbmUsIGhpZGUgdGhlIHBvcHVwXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgKmFmdGVyKiBjaGVja2luZyB0aGUgcHJldmlvdXMgc3RhdGVcbiAgICAgIHRoaXMuaGFzQXRTeW1ib2wgPSBpc0F0U3ltYm9sQ29udGV4dDtcbiAgXG4gICAgICAvLyAtLS0gQXV0by1yZXNpemUgbG9naWMgKG9wdGlvbmFsKSAtLS1cbiAgICAgIC8vIFNpbXBsZSBhdXRvLXJlc2l6ZSBiYXNlZCBvbiBzY3JvbGwgaGVpZ2h0IChtaWdodCBuZWVkIHJlZmluZW1lbnQpXG4gICAgICBpZiAoIXRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7IC8vIE9ubHkgYXV0by1yZXNpemUgaWYgbm90IG1hbnVhbGx5IGV4cGFuZGVkXG4gICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nOyAvLyBUZW1wb3JhcmlseSBzaHJpbmsgdG8gY29udGVudFxuICAgICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuY2hhdElucHV0LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAvLyBTZXQgYSBtYXggaGVpZ2h0IHRvIHByZXZlbnQgaW5maW5pdGUgZ3Jvd3RoLCBlLmcuLCAxNTBweFxuICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IDE1MDtcbiAgICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1pbihzY3JvbGxIZWlnaHQsIG1heEhlaWdodCk7XG4gICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGhlaWdodCBpZiBpdCBhY3R1YWxseSBjaGFuZ2VzIHRvIGF2b2lkIGZsaWNrZXJcbiAgICAgICAgICBpZiAodGhpcy5jaGF0SW5wdXQub2Zmc2V0SGVpZ2h0IDwgbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5zdHlsZS5oZWlnaHQgPSBgJHtuZXdIZWlnaHR9cHhgO1xuICAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUub3ZlcmZsb3dZID0gc2Nyb2xsSGVpZ2h0ID4gbWF4SGVpZ2h0ID8gJ2F1dG8nIDogJ2hpZGRlbic7XG4gICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxIZWlnaHQgPD0gdGhpcy5jaGF0SW5wdXQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIC8vIFNocmluayBpZiBjb250ZW50IGhlaWdodCBpcyBsZXNzIHRoYW4gY3VycmVudCBoZWlnaHRcbiAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUuaGVpZ2h0ID0gYCR7c2Nyb2xsSGVpZ2h0fXB4YDtcbiAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEV4cGxpY2l0bHkgc2V0cyB0aGUgaGFzQXRTeW1ib2wgZmxhZy4gQ2FsbGVkIGJ5IHNob3J0Y3V0IGhhbmRsZXIuXG4gICAgICovXG4gICAgc2V0SGFzQXRTeW1ib2wodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBoYXNBdFN5bWJvbCBmbGFnLiBDYWxsZWQgYnkgc2hvcnRjdXQgaGFuZGxlci5cbiAgICAgKi9cbiAgICBnZXRIYXNBdFN5bWJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXRTeW1ib2w7XG4gICAgfVxufVxuZXhwb3J0cy5JbnB1dEhhbmRsZXIgPSBJbnB1dEhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlX3JlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi4vdWkvbWVzc2FnZS1yZW5kZXJlclwiKTtcbmNvbnN0IG5vdGVib29rX2ludGVncmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb25cIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpOyAvLyBJbXBvcnQgZ2xvYmFscyBmb3Igbm90ZWJvb2sgdHJhY2tlclxuLyoqXG4gKiBIYW5kbGVzIHNlbmRpbmcgbWVzc2FnZXMsIGludGVyYWN0aW5nIHdpdGggdGhlIEFQSSxcbiAqIG1hbmFnaW5nIHN0cmVhbWluZyByZXNwb25zZXMsIGFuZCB1cGRhdGluZyB0aGUgVUkgYW5kIHN0YXRlLlxuICovXG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBjaGF0U3RhdGUsIHVpTWFuYWdlciwgcmVuZGVyZXJDYWxsYmFja3MsIGlucHV0SGFuZGxlcikge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5jaGF0U3RhdGUgPSBjaGF0U3RhdGU7XG4gICAgICAgIHRoaXMudWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzID0gcmVuZGVyZXJDYWxsYmFja3M7XG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYW5kIHNlbmRzIGEgdXNlci1pbml0aWF0ZWQgbWVzc2FnZS5cbiAgICAgKiBBbHNvIGhhbmRsZXMgYWRkaW5nIHRoZSB1c2VyIG1lc3NhZ2UgdG8gdGhlIFVJIGFuZCBjbGVhcmluZyB0aGUgaW5wdXQuXG4gICAgICogQWNjZXB0cyB0aGUgbWVzc2FnZSB0ZXh0LlxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UsIGlzTWFya2Rvd24gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UudHJpbSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyhgW01lc3NhZ2VIYW5kbGVyXSBIYW5kbGluZyBzZW5kOiBcIiR7bWVzc2FnZX1cIiwgTWFya2Rvd246ICR7aXNNYXJrZG93bn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtNZXNzYWdlSGFuZGxlcl0gaXNNYXJrZG93biB0eXBlOiAke3R5cGVvZiBpc01hcmtkb3dufSwgdmFsdWU6ICR7aXNNYXJrZG93bn1gKTtcbiAgICAgICAgLy8gQWRkIHVzZXIgbWVzc2FnZSB0byBVSSB3aXRoIGlzTWFya2Rvd24gZmxhZ1xuICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZSwgJ3VzZXInLCBpc01hcmtkb3duKTtcbiAgICAgICAgLy8gQ2xlYXIgaW5wdXQgdmlhIElucHV0SGFuZGxlciAod2hpY2ggdXNlcyBVSU1hbmFnZXIpXG4gICAgICAgIC8vIFJFTU9WRUQ6IHRoaXMuaW5wdXRIYW5kbGVyLmNsZWFySW5wdXQoKTsgLy8gSW5wdXQgY2xlYXJpbmcgaXMgbm93IGhhbmRsZWQgYnkgVUlNYW5hZ2VyIGFmdGVyIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyBTZW5kIG1lc3NhZ2UgdG8gYmFja2VuZCBBUEkgYW5kIGhhbmRsZSBzdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgdGhpcy5zdHJlYW1BbmRSZW5kZXJSZXNwb25zZShtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gYXV0b21hdGljIG1lc3NhZ2UgKGUuZy4sICdjb25maXJtZWQnLCAncmVqZWN0ZWQnKVxuICAgICAqIHRvIHRoZSBiYWNrZW5kIGFuZCBoYW5kbGVzIHRoZSBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICogQWxzbyBhZGRzIHRoZSB1c2VyJ3MgY29uZmlybWF0aW9uL3JlamVjdGlvbiBhY3Rpb24gYW5kIGEgc2VwYXJhdG9yIHRvIHRoZSBVSS5cbiAgICAgKi9cbiAgICBoYW5kbGVTZW5kQXV0b01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UudHJpbSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBBZGQgdGhlIHVzZXIncyBhY3Rpb24gKCdDb25maXJtZWQnIG9yICdSZWplY3RlZCcpIHRvIHRoZSBVSSBpbW1lZGlhdGVseVxuICAgICAgICBjb25zdCB1c2VyRGlzcGxheU1lc3NhZ2UgPSBtZXNzYWdlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbWVzc2FnZS5zbGljZSgxKTtcbiAgICAgICAgLy8gRXhwbGljaXRseSBmYWxzZSBmb3IgaXNNYXJrZG93biwgdHJ1ZSBmb3IgaXNBdXRvXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZSh1c2VyRGlzcGxheU1lc3NhZ2UsICd1c2VyJywgZmFsc2UsIHRydWUpO1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgc2VwYXJhdG9yIGVsZW1lbnRcbiAgICAgICAgY29uc29sZS5sb2coJ1tNZXNzYWdlSGFuZGxlcl0gQ3JlYXRpbmcgYWN0aW9uIHNlcGFyYXRvciBlbGVtZW50Li4uJyk7IC8vIERlYnVnIGxvZ1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2VwYXJhdG9yRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWFjdGlvbi1zZXBhcmF0b3InOyAvLyBBZGQgYSBjbGFzcyBmb3IgcG90ZW50aWFsIHN0eWxpbmdcbiAgICAgICAgc2VwYXJhdG9yRGl2LnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInOyAvLyBCYXNpYyBzdHlsaW5nXG4gICAgICAgIHNlcGFyYXRvckRpdi5zdHlsZS5tYXJnaW4gPSAnMTBweCAwJzsgLy8gQWRkIHNvbWUgdmVydGljYWwgc3BhY2VcbiAgICAgICAgc2VwYXJhdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gJzAuOWVtJztcbiAgICAgICAgc2VwYXJhdG9yRGl2LnN0eWxlLmNvbG9yID0gJ3ZhcigtLWpwLXVpLWZvbnQtY29sb3IyLCBncmV5KSc7IC8vIFVzZSBKdXB5dGVyTGFiIHRoZW1lIHZhcmlhYmxlXG4gICAgICAgIGlmIChtZXNzYWdlID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgc2VwYXJhdG9yRGl2LnRleHRDb250ZW50ID0gJy0tLS0tLS0t4pyFIENvbmZpcm1lZC0tLS0tLS0tJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3JEaXYudGV4dENvbnRlbnQgPSAnLS0tLS0tLS3inYwgUmVqZWN0ZWQtLS0tLS0tLSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPcHRpb25hbDogSGFuZGxlIHVuZXhwZWN0ZWQgbWVzc2FnZXM/IE9yIGp1c3QgZG9uJ3QgYWRkIGEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgc2VwYXJhdG9yRGl2LnRleHRDb250ZW50ID0gYC0tLS0tLS0tJHt1c2VyRGlzcGxheU1lc3NhZ2V9LS0tLS0tLS1gO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgc2VwYXJhdG9yIGRpcmVjdGx5IHRvIHRoZSBVSSBNYW5hZ2VyJ3MgY29udGFpbmVyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbTWVzc2FnZUhhbmRsZXJdIEF0dGVtcHRpbmcgdG8gYWRkIHNlcGFyYXRvciBlbGVtZW50OicsIHNlcGFyYXRvckRpdik7IC8vIERlYnVnIGxvZ1xuICAgICAgICB0aGlzLnVpTWFuYWdlci5hZGRDaGF0TWVzc2FnZUVsZW1lbnQoc2VwYXJhdG9yRGl2KTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tNZXNzYWdlSGFuZGxlcl0gU2VwYXJhdG9yIGVsZW1lbnQgc2hvdWxkIGJlIGFkZGVkLicpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgLy8gU2VuZCB0aGUgdGVjaG5pY2FsIG1lc3NhZ2UgKCdjb25maXJtZWQnIG9yICdyZWplY3RlZCcpIHRvIHRoZSBiYWNrZW5kXG4gICAgICAgIC8vIGFuZCBoYW5kbGUgdGhlIHN0cmVhbWluZyByZXNwb25zZSBmcm9tIHRoZSBiYWNrZW5kLlxuICAgICAgICB0aGlzLnN0cmVhbUFuZFJlbmRlclJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgVUkgdmlhIFVJTWFuYWdlciBhbmQgc2F2ZXMgdG8gQ2hhdFN0YXRlLlxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2UodGV4dCwgc2VuZGVyLCBpc01hcmtkb3duID0gZmFsc2UsIC8vIERlZmF1bHQgZmFsc2UsIG92ZXJyaWRkZW4gYmVsb3dcbiAgICBpc0F1dG8gPSBmYWxzZSAvLyBGbGFnIGZvciBhdXRvIG1lc3NhZ2VzIGxpa2UgY29uZmlybS9yZWplY3RcbiAgICApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtNZXNzYWdlSGFuZGxlcl0gQWRkaW5nIG1lc3NhZ2U6IFNlbmRlcj0ke3NlbmRlcn0sIE1hcmtkb3duPSR7aXNNYXJrZG93bn0sIEF1dG89JHtpc0F1dG99YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbTWVzc2FnZUhhbmRsZXJdIGlzTWFya2Rvd24gdHlwZSBpbiBhZGRNZXNzYWdlOiAke3R5cGVvZiBpc01hcmtkb3dufSwgdmFsdWU6ICR7aXNNYXJrZG93bn1gKTtcbiAgICAgICAgbGV0IG1lc3NhZ2VFbGVtZW50O1xuICAgICAgICAvLyBQcmVwYXJlIGV4dGVuZGVkIGNhbGxiYWNrcyBmb3IgdGhlIHJlbmRlcmVyXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKSwgeyBnZXRDb2RlUmVmRGF0YTogKHJlZklkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRIYW5kbGVyLmdldENvZGVSZWZlcmVuY2VNYXAoKS5nZXQocmVmSWQpO1xuICAgICAgICAgICAgfSwgZ2V0Q3VycmVudE5vdGVib29rQ29udGV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE5vdGVib29rID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vdGVib29rID09PSBudWxsIHx8IGN1cnJlbnROb3RlYm9vayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAoKF9iID0gcGF0aC5zcGxpdCgnLycpLnBvcCgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3BsaXQoJy4nKVswXSkgfHwgJ25vdGVib29rJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgcGF0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgaWYgKHNlbmRlciA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW01lc3NhZ2VIYW5kbGVyXSBDYWxsaW5nIHJlbmRlclVzZXJNZXNzYWdlIHdpdGggaXNNYXJrZG93bj0ke2lzTWFya2Rvd259YCk7XG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBpc01hcmtkb3duIG9wdGlvbiBhbmQgZXh0ZW5kZWQgY2FsbGJhY2tzIHRvIHRoZSByZW5kZXJlclxuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclVzZXJNZXNzYWdlKSh0ZXh0LCB7IGlzTWFya2Rvd24gfSwgZXh0ZW5kZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQm90IG1lc3NhZ2VzIHVzdWFsbHkgYXJlIG1hcmtkb3duIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBIYW5kbGUgYXV0byBtZXNzYWdlcyBzcGVjaWZpY2FsbHkgaWYgdGhleSBzaG91bGRuJ3QgYmUgcGFyc2VkIGFzIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBib3RJc01hcmtkb3duID0gIWlzQXV0bzsgLy8gQXNzdW1lIGF1dG8gbWVzc2FnZXMgYXJlbid0IG1hcmtkb3duXG4gICAgICAgICAgICAvLyBQYXNzIGV4dGVuZGVkIGNhbGxiYWNrcyB0byBib3QgbWVzc2FnZSByZW5kZXJlciB0b28sIGluIGNhc2UgaXQgbmVlZHMgdGhlbSBsYXRlclxuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlckJvdE1lc3NhZ2UpKHRleHQsIHsgaXNNYXJrZG93bjogYm90SXNNYXJrZG93biB9LCBleHRlbmRlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aU1hbmFnZXIuYWRkQ2hhdE1lc3NhZ2VFbGVtZW50KG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgLy8gRG9uJ3Qgc2F2ZSBpbnRlcm5hbCAnY29uZmlybWVkJy8ncmVqZWN0ZWQnIG1lc3NhZ2VzIHRvIGhpc3RvcnlcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcbiAgICAgICAgICAgIC8vIEFkZCBpc01hcmtkb3duIGJhY2sgdG8gdGhlIHNhdmVkIG1lc3NhZ2Ugc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGNoYXRNZXNzYWdlID0geyBzZW5kZXIsIHRleHQsIGlzTWFya2Rvd24gfTtcbiAgICAgICAgICAgIHRoaXMuY2hhdFN0YXRlLmFkZE1lc3NhZ2VUb0N1cnJlbnRDaGF0KGNoYXRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3JlIGxvZ2ljIGZvciBzZW5kaW5nIGEgbWVzc2FnZSB0byB0aGUgQVBJLCBoYW5kbGluZyB0aGUgc3RyZWFtLFxuICAgICAqIHJlbmRlcmluZyB0aGUgcmVzcG9uc2UsIGFuZCBzYXZpbmcgdGhlIGZpbmFsIGJvdCBtZXNzYWdlLlxuICAgICAqL1xuICAgIHN0cmVhbUFuZFJlbmRlclJlc3BvbnNlKG1lc3NhZ2VUb1NlbmQpIHtcbiAgICAgICAgLy8gLS0tIFByZXBhcmUgc3RyZWFtaW5nIFVJIGVsZW1lbnRzIChtYW5hZ2VkIGJ5IFVJTWFuYWdlcikgLS0tXG4gICAgICAgIC8vIFVJTWFuYWdlciBzaG91bGQgcHJvdmlkZSBhIG1ldGhvZCB0byBjcmVhdGUvZ2V0IHRoZXNlIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHsgc3RyZWFtaW5nRGl2LCBjb250ZW50RGl2IH0gPSB0aGlzLnVpTWFuYWdlci5jcmVhdGVCb3RNZXNzYWdlQ29udGFpbmVyKCk7XG4gICAgICAgIGxldCBjb21wbGV0ZVJlc3BvbnNlID0gJyc7XG4gICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKDAsIG5vdGVib29rX2ludGVncmF0aW9uXzEuZ2V0Q3VycmVudENlbGxDb250ZW50KSgpOyAvLyBVc2UgdXRpbGl0eVxuICAgICAgICAvLyBTdHJlYW0gcmVzcG9uc2UgZnJvbSBBUElcbiAgICAgICAgdGhpcy5hcGlDbGllbnQuc3RyZWFtQ2hhdChtZXNzYWdlVG9TZW5kLCB7IGNlbGxDb250ZXh0IH0sIFxuICAgICAgICAvLyBPbiBjaHVuayByZWNlaXZlZFxuICAgICAgICAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UgKz0gY2h1bms7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRlbXBvcmFyeSBzdHJlYW1pbmcgZGl2XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYudGV4dENvbnRlbnQgPSBjb21wbGV0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIE9uIGNvbXBsZXRlXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIEhpZGUgc3RyZWFtaW5nIGRpdiwgc2hvdyBmaW5hbCBjb250ZW50IGRpdlxuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBjb21wbGV0ZSByZXNwb25zZSB1c2luZyB0aGUgcmVuZGVyZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkQ29udGVudCA9ICgwLCBtZXNzYWdlX3JlbmRlcmVyXzEucmVuZGVyQm90TWVzc2FnZSkoY29tcGxldGVSZXNwb25zZSwgeyBpc01hcmtkb3duOiB0cnVlIH0sIHRoaXMucmVuZGVyZXJDYWxsYmFja3MpO1xuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSAnJzsgLy8gQ2xlYXIgcGxhY2Vob2xkZXIvcHJldmlvdXMgY29udGVudFxuICAgICAgICAgICAgLy8gQXBwZW5kIHJlbmRlcmVkIG5vZGVzLCBza2lwcGluZyBhbnkgcG90ZW50aWFsIHdyYXBwZXIvaW5kaWNhdG9yIGFkZGVkIGJ5IHJlbmRlckJvdE1lc3NhZ2UgaXRzZWxmXG4gICAgICAgICAgICB3aGlsZSAocmVuZGVyZWRDb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBpcyB0aGUgc3BlY2lmaWMgbWFya2Rvd24gaW5kaWNhdG9yIHdlIG1pZ2h0IGFkZC9yZW1vdmVcbiAgICAgICAgICAgICAgICAvLyBPciBqdXN0IGFwcGVuZCBldmVyeXRoaW5nIGlmIHJlbmRlckJvdE1lc3NhZ2UgcmV0dXJucyB0aGUgcHVyZSBjb250ZW50XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gcmVuZGVyZWRDb250ZW50LmZpcnN0Q2hpbGQuY2xhc3NMaXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoJ21hcmtkb3duLWluZGljYXRvcicpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LmFwcGVuZENoaWxkKHJlbmRlcmVkQ29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaW5kaWNhdG9yIGlmIGl0IHdhcyBwYXJ0IG9mIHRoZSByZXR1cm5lZCBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENvbnRlbnQucmVtb3ZlQ2hpbGQocmVuZGVyZWRDb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhdmUgZmluYWwgYm90IHJlc3BvbnNlIHRvIGhpc3RvcnkgdmlhIENoYXRTdGF0ZVxuICAgICAgICAgICAgY29uc3QgaXNJbWFnZSA9IGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJyk7IC8vIFNpbXBsZSBjaGVja1xuICAgICAgICAgICAgY29uc3QgYm90TWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogY29tcGxldGVSZXNwb25zZSxcbiAgICAgICAgICAgICAgICBzZW5kZXI6ICdib3QnLFxuICAgICAgICAgICAgICAgIGlzTWFya2Rvd246ICFpc0ltYWdlIC8vIFNhdmUgYXMgbWFya2Rvd24gdW5sZXNzIGl0J3MgYW4gaW1hZ2UgVVJMXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jaGF0U3RhdGUuYWRkTWVzc2FnZVRvQ3VycmVudENoYXQoYm90TWVzc2FnZURhdGEpO1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIE9uIGVycm9yXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IGZpbmFsIGNvbnRlbnQgZGl2IHdpdGggZXJyb3JcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIC8vIFVzZSBhIGRlZGljYXRlZCBlcnJvciByZW5kZXJpbmcgc3R5bGUvY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImpwLWxsbS1leHQtZXJyb3ItbWVzc2FnZVwiPkVycm9yOiAke2Vycm9yLm1lc3NhZ2V9PC9kaXY+YDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLnVpTWFuYWdlci5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gTWVzc2FnZUhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90ZUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBub3RlX21vZGFsXzEgPSByZXF1aXJlKFwiLi4vdWkvbm90ZS1tb2RhbFwiKTtcbmNvbnN0IG1hcmtkb3duXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWFya2Rvd25cIik7XG4vKipcbiAqIE1hbmFnZXMgdGhlIG5vdGVzIFVJIGFuZCBpbnRlcmFjdGlvbnMuXG4gKi9cbmNsYXNzIE5vdGVIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE5vdGVIYW5kbGVyLlxuICAgICAqIEBwYXJhbSBub3RlU3RhdGUgVGhlIG5vdGUgc3RhdGUuXG4gICAgICogQHBhcmFtIHVpTWFuYWdlciBUaGUgVUkgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3Igbm90ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBwYXJlbnROb2RlIFRoZSBwYXJlbnQgbm9kZSB3aGVyZSB0aGUgbm90ZSBoYW5kbGVyIHdpbGwgYXBwZW5kIGl0cyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlU3RhdGUsIHVpTWFuYWdlciwgY2FsbGJhY2tzLCBwYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMubm90ZVN0YXRlID0gbm90ZVN0YXRlO1xuICAgICAgICB0aGlzLnVpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb3RlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTm90ZXNWaWV3VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBDcmVhdGUgbWFpbiBjb250YWluZXIgZm9yIG5vdGVzXG4gICAgICAgIHRoaXMubm90ZXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5ub3Rlc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3Rlcy1jb250YWluZXInO1xuICAgICAgICB0aGlzLm5vdGVzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIENyZWF0ZSBjb250YWluZXIgZm9yIHRoZSBub3RlIGxpc3RcbiAgICAgICAgdGhpcy5ub3RlTGlzdENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm5vdGVMaXN0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtbGlzdC1jb250YWluZXInO1xuICAgICAgICAvLyBDcmVhdGUgY29udGFpbmVyIGZvciBub3RlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5ub3RlQ29udGVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm5vdGVDb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtY29udGVudC1jb250YWluZXInO1xuICAgICAgICAvLyBDcmVhdGUgY29udGFpbmVyIGZvciB0aGUgbm90ZSBtb2RhbFxuICAgICAgICB0aGlzLm5vdGVNb2RhbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm5vdGVNb2RhbENvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLW1vZGFsLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIEFwcGVuZCB0aGUgbW9kYWwgY29udGFpbmVyIHRvIHRoZSBwYXJlbnQgbm9kZSAobm90IGluc2lkZSB0aGUgbm90ZXMgY29udGFpbmVyKVxuICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgbW9kYWwgdG8gYXBwZWFyIGFzIGFuIG92ZXJsYXkgb24gdGhlIGVudGlyZSBVSVxuICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub3RlTW9kYWxDb250YWluZXIpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBub3RlcyB2aWV3XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU5vdGVzVmlldygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbm90ZXMgdmlldyB3aXRoIGhlYWRlciwgbGlzdCBhbmQgY29udGVudCBzZWN0aW9ucy5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplTm90ZXNWaWV3KCkge1xuICAgICAgICAvLyBDcmVhdGUgaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoZWFkZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbm90ZXMtaGVhZGVyJztcbiAgICAgICAgLy8gQ3JlYXRlIGJhY2sgYnV0dG9uXG4gICAgICAgIGNvbnN0IGJhY2tCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYmFja0J1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYmFjay1idXR0b24nO1xuICAgICAgICBiYWNrQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTIwIDExSDcuODNsNS41OS01LjU5TDEyIDRsLTggOCA4IDggMS40MS0xLjQxTDcuODMgMTNIMjB2LTJ6XCIvPjwvc3ZnPjwvc3Bhbj4nO1xuICAgICAgICBiYWNrQnV0dG9uLnRpdGxlID0gJ0JhY2sgdG8gY2hhdCc7XG4gICAgICAgIGJhY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhpZGVOb3Rlc1ZpZXcoKSk7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICAgICAgdGl0bGUudGV4dENvbnRlbnQgPSAnTm90ZXMnO1xuICAgICAgICBjb25zdCBhZGRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hZGQtbm90ZS1idXR0b24nO1xuICAgICAgICBhZGRCdXR0b24udGV4dENvbnRlbnQgPSAnQWRkIE5vdGUnO1xuICAgICAgICBhZGRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnNob3dBZGROb3RlTW9kYWwoKSk7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChiYWNrQnV0dG9uKTtcbiAgICAgICAgaGVhZGVyLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgaGVhZGVyLmFwcGVuZENoaWxkKGFkZEJ1dHRvbik7XG4gICAgICAgIC8vIENyZWF0ZSBmbGV4IGNvbnRhaW5lciBmb3IgbGlzdCBhbmQgY29udGVudFxuICAgICAgICBjb25zdCBmbGV4Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZsZXhDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbm90ZXMtZmxleC1jb250YWluZXInO1xuICAgICAgICBmbGV4Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm90ZUxpc3RDb250YWluZXIpO1xuICAgICAgICBmbGV4Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm90ZUNvbnRlbnRDb250YWluZXIpO1xuICAgICAgICAvLyBBZGQgY29tcG9uZW50cyB0byB0aGUgbWFpbiBjb250YWluZXJcbiAgICAgICAgdGhpcy5ub3Rlc0NvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgICB0aGlzLm5vdGVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGZsZXhDb250YWluZXIpO1xuICAgICAgICAvLyBJbml0aWFsIHJlbmRlciBvZiBub3Rlc1xuICAgICAgICB0aGlzLnJlbmRlck5vdGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBhZGQgbm90ZSBtb2RhbC5cbiAgICAgKi9cbiAgICBzaG93QWRkTm90ZU1vZGFsKCkge1xuICAgICAgICBjb25zdCBtb2RhbENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGhhbmRsZVNhdmU6ICh0aXRsZSwgY29udGVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubm90ZVN0YXRlLmNyZWF0ZU5ld05vdGUodGl0bGUsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm90ZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVOb3RlTW9kYWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTm90ZUNoYW5nZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZU5vdGVNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtb2RhbCA9ICgwLCBub3RlX21vZGFsXzEuY3JlYXRlTm90ZU1vZGFsRWxlbWVudCkobW9kYWxDYWxsYmFja3MpO1xuICAgICAgICB0aGlzLnNob3dNb2RhbChtb2RhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBlZGl0IG5vdGUgbW9kYWwgZm9yIGEgc3BlY2lmaWMgbm90ZS5cbiAgICAgKiBAcGFyYW0gbm90ZSBUaGUgbm90ZSB0byBlZGl0LlxuICAgICAqL1xuICAgIHNob3dFZGl0Tm90ZU1vZGFsKG5vdGUpIHtcbiAgICAgICAgY29uc3QgbW9kYWxDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBoYW5kbGVTYXZlOiAodGl0bGUsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGVTdGF0ZS51cGRhdGVOb3RlKG5vdGUuaWQsIHRpdGxlLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vdGVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlTm90ZU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWROb3RlSWQgPT09IG5vdGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Tm90ZUNvbnRlbnQobm90ZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25Ob3RlQ2hhbmdlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlTm90ZU1vZGFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1vZGFsID0gKDAsIG5vdGVfbW9kYWxfMS5jcmVhdGVOb3RlTW9kYWxFbGVtZW50KShtb2RhbENhbGxiYWNrcywgbm90ZS50aXRsZSwgbm90ZS5jb250ZW50KTtcbiAgICAgICAgdGhpcy5zaG93TW9kYWwobW9kYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIG5vdGUgaXMgY2hhbmdlZC4gVXBkYXRlcyB0aGUgVUkgdGl0bGUgaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIG9uTm90ZUNoYW5nZSgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBub3RlIGlzIHNlbGVjdGVkIGFuZCB1cGRhdGUgdGhlIHRpdGxlIGlucHV0XG4gICAgICAgIGNvbnN0IGN1cnJlbnROb3RlID0gdGhpcy5ub3RlU3RhdGUuZ2V0Tm90ZUJ5SWQodGhpcy5zZWxlY3RlZE5vdGVJZCB8fCAnJyk7XG4gICAgICAgIGlmIChjdXJyZW50Tm90ZSAmJiB0aGlzLmNhbGxiYWNrcy51cGRhdGVUaXRsZUlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy51cGRhdGVUaXRsZUlucHV0KGN1cnJlbnROb3RlLnRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIG1vZGFsIGluIHRoZSBub3RlIG1vZGFsIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gbW9kYWwgVGhlIG1vZGFsIGVsZW1lbnQgdG8gc2hvdy5cbiAgICAgKi9cbiAgICBzaG93TW9kYWwobW9kYWwpIHtcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIG1vZGFsXG4gICAgICAgIHRoaXMubm90ZU1vZGFsQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBtb2RhbFxuICAgICAgICB0aGlzLm5vdGVNb2RhbENvbnRhaW5lci5hcHBlbmRDaGlsZChtb2RhbCk7XG4gICAgICAgIC8vIFNob3cgdGhlIG1vZGFsIGNvbnRhaW5lclxuICAgICAgICB0aGlzLm5vdGVNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIG5vdGUgbW9kYWwuXG4gICAgICovXG4gICAgaGlkZU5vdGVNb2RhbCgpIHtcbiAgICAgICAgdGhpcy5ub3RlTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5ub3RlTW9kYWxDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGxpc3Qgb2Ygbm90ZXMuXG4gICAgICovXG4gICAgcmVuZGVyTm90ZXMoKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBjdXJyZW50IGxpc3RcbiAgICAgICAgdGhpcy5ub3RlTGlzdENvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgLy8gR2V0IGFsbCBub3Rlc1xuICAgICAgICBjb25zdCBub3RlcyA9IHRoaXMubm90ZVN0YXRlLmdldEFsbE5vdGVzKCk7XG4gICAgICAgIGlmIChub3Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZW1wdHlNZXNzYWdlLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtZW1wdHktbWVzc2FnZSc7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UudGV4dENvbnRlbnQgPSAnTm8gbm90ZXMgeWV0LiBDbGljayBcIkFkZCBOb3RlXCIgdG8gY3JlYXRlIG9uZS4nO1xuICAgICAgICAgICAgdGhpcy5ub3RlTGlzdENvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eU1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBsaXN0XG4gICAgICAgIGNvbnN0IG5vdGVzTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIG5vdGVzTGlzdC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLWxpc3QnO1xuICAgICAgICAvLyBBZGQgZWFjaCBub3RlIHRvIHRoZSBsaXN0XG4gICAgICAgIG5vdGVzLmZvckVhY2goKG5vdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIG5vdGVJdGVtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtaXRlbSc7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE5vdGVJZCA9PT0gbm90ZS5pZCkge1xuICAgICAgICAgICAgICAgIG5vdGVJdGVtLmNsYXNzTGlzdC5hZGQoJ2pwLWxsbS1leHQtbm90ZS1pdGVtLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlIGNvbnRlbnQgKHRpdGxlIGFuZCBhY3Rpb25zKVxuICAgICAgICAgICAgY29uc3Qgbm90ZUNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vdGVDb250ZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtaXRlbS1jb250ZW50JztcbiAgICAgICAgICAgIGNvbnN0IG5vdGVUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIG5vdGVUaXRsZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLWl0ZW0tdGl0bGUnO1xuICAgICAgICAgICAgbm90ZVRpdGxlLnRleHRDb250ZW50ID0gbm90ZS50aXRsZTtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVBY3Rpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3RlQWN0aW9ucy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLWl0ZW0tYWN0aW9ucyc7XG4gICAgICAgICAgICBjb25zdCBlZGl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBlZGl0QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1ub3RlLWVkaXQtYnV0dG9uJztcbiAgICAgICAgICAgIGVkaXRCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPjxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMyAxNy4yNVYyMWgzLjc1TDE3LjgxIDkuOTRsLTMuNzUtMy43NUwzIDE3LjI1ek0yMC43MSA3LjA0Yy4zOS0uMzkuMzktMS4wMiAwLTEuNDFsLTIuMzQtMi4zNGEuOTk1OS45OTU5IDAgMCAwLTEuNDEgMGwtMS44MyAxLjgzIDMuNzUgMy43NSAxLjgzLTEuODN6XCIvPjwvc3ZnPjwvc3Bhbj4nO1xuICAgICAgICAgICAgZWRpdEJ1dHRvbi50aXRsZSA9ICdFZGl0IG5vdGUnO1xuICAgICAgICAgICAgZWRpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBub3RlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0VkaXROb3RlTW9kYWwobm90ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgZGVsZXRlQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1ub3RlLWRlbGV0ZS1idXR0b24nO1xuICAgICAgICAgICAgZGVsZXRlQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTYgMTljMCAxLjEuOSAyIDIgMmg4YzEuMSAwIDItLjkgMi0yVjdINnYxMnpNMTkgNGgtMy41bC0xLTFoLTVsLTEgMUg1djJoMTRWNHpcIi8+PC9zdmc+PC9zcGFuPic7XG4gICAgICAgICAgICBkZWxldGVCdXR0b24udGl0bGUgPSAnRGVsZXRlIG5vdGUnO1xuICAgICAgICAgICAgZGVsZXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50IG5vdGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhlIG5vdGUgXCIke25vdGUudGl0bGV9XCI/YCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RlU3RhdGUuZGVsZXRlTm90ZShub3RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGV0ZWQgbm90ZSB3YXMgc2VsZWN0ZWQsIGNsZWFyIHRoZSBjb250ZW50IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE5vdGVJZCA9PT0gbm90ZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vdGVJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGVDb250ZW50Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm90ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5vdGVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vdGVBY3Rpb25zLmFwcGVuZENoaWxkKGVkaXRCdXR0b24pO1xuICAgICAgICAgICAgbm90ZUFjdGlvbnMuYXBwZW5kQ2hpbGQoZGVsZXRlQnV0dG9uKTtcbiAgICAgICAgICAgIG5vdGVDb250ZW50LmFwcGVuZENoaWxkKG5vdGVUaXRsZSk7XG4gICAgICAgICAgICBub3RlQ29udGVudC5hcHBlbmRDaGlsZChub3RlQWN0aW9ucyk7XG4gICAgICAgICAgICBub3RlSXRlbS5hcHBlbmRDaGlsZChub3RlQ29udGVudCk7XG4gICAgICAgICAgICAvLyBBZGQgY2xpY2sgZXZlbnQgdG8gc2hvdyB0aGUgbm90ZSBjb250ZW50XG4gICAgICAgICAgICBub3RlSXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dOb3RlQ29udGVudChub3RlLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm90ZXNMaXN0LmFwcGVuZENoaWxkKG5vdGVJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm90ZUxpc3RDb250YWluZXIuYXBwZW5kQ2hpbGQobm90ZXNMaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGNvbnRlbnQgb2YgYSBzcGVjaWZpYyBub3RlLlxuICAgICAqIEBwYXJhbSBub3RlSWQgVGhlIElEIG9mIHRoZSBub3RlIHRvIHNob3cuXG4gICAgICovXG4gICAgc2hvd05vdGVDb250ZW50KG5vdGVJZCkge1xuICAgICAgICAvLyBTZXQgYXMgc2VsZWN0ZWRcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vdGVJZCA9IG5vdGVJZDtcbiAgICAgICAgLy8gUmUtcmVuZGVyIG5vdGVzIHRvIHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5yZW5kZXJOb3RlcygpO1xuICAgICAgICAvLyBDbGVhciBjdXJyZW50IGNvbnRlbnRcbiAgICAgICAgdGhpcy5ub3RlQ29udGVudENvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgLy8gR2V0IHRoZSBub3RlXG4gICAgICAgIGNvbnN0IG5vdGUgPSB0aGlzLm5vdGVTdGF0ZS5nZXROb3RlQnlJZChub3RlSWQpO1xuICAgICAgICBpZiAoIW5vdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENyZWF0ZSBjb250ZW50IGNvbnRhaW5lclxuICAgICAgICBjb25zdCBjb250ZW50V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZW50V3JhcHBlci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLWNvbnRlbnQtd3JhcHBlcic7XG4gICAgICAgIC8vIE5vdGUgdGl0bGVcbiAgICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgICAgICB0aXRsZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLWNvbnRlbnQtdGl0bGUnO1xuICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IG5vdGUudGl0bGU7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgLy8gTm90ZSBjb250ZW50XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGVudC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLWNvbnRlbnQtdGV4dCBqcC1SZW5kZXJlZE1hcmtkb3duJztcbiAgICAgICAgLy8gUmVuZGVyIG1hcmtkb3duIGNvbnRlbnRcbiAgICAgICAgY29udGVudC5pbm5lckhUTUwgPSAoMCwgbWFya2Rvd25fMS5yZW5kZXJNYXJrZG93bikobm90ZS5jb250ZW50KTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHRoaXMubm90ZUNvbnRlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudFdyYXBwZXIpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHRpdGxlIGluIHBhcmVudCBVSSBpZiBjYWxsYmFjayBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLnVwZGF0ZVRpdGxlSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnVwZGF0ZVRpdGxlSW5wdXQobm90ZS50aXRsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB2aXNpYmlsaXR5IG9mIHRoZSBub3RlcyB2aWV3LlxuICAgICAqL1xuICAgIHRvZ2dsZU5vdGVzVmlldygpIHtcbiAgICAgICAgdGhpcy5pc05vdGVzVmlld1Zpc2libGUgPSAhdGhpcy5pc05vdGVzVmlld1Zpc2libGU7XG4gICAgICAgIGlmICh0aGlzLmlzTm90ZXNWaWV3VmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zaG93Tm90ZXNWaWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVOb3Rlc1ZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgbm90ZXMgdmlldy5cbiAgICAgKi9cbiAgICBzaG93Tm90ZXNWaWV3KCkge1xuICAgICAgICB0aGlzLm5vdGVzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgIHRoaXMuaXNOb3Rlc1ZpZXdWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gVXNlIFVJTWFuYWdlciB0byBwcm9wZXJseSBoaWRlIG1lc3NhZ2UgY29udGFpbmVycyBhbmQgc2hvdyBub3RlcyB2aWV3XG4gICAgICAgIHRoaXMudWlNYW5hZ2VyLnNob3dOb3Rlc1ZpZXcoKTtcbiAgICAgICAgLy8gRmluZCBhbnkgb3RoZXIgbWVzc2FnZSBjb250YWluZXJzIHRoYXQgbWlnaHQgYmUgdmlzaWJsZSBhbmQgaGlkZSB0aGVtXG4gICAgICAgIGNvbnN0IGFsbE1lc3NhZ2VDb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmpwLWxsbS1leHQtbWVzc2FnZS1jb250YWluZXInKTtcbiAgICAgICAgYWxsTWVzc2FnZUNvbnRhaW5lcnMuZm9yRWFjaChjb250YWluZXIgPT4ge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgbm90ZXMgdmlldy5cbiAgICAgKi9cbiAgICBoaWRlTm90ZXNWaWV3KCkge1xuICAgICAgICB0aGlzLm5vdGVzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuaXNOb3Rlc1ZpZXdWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZSBVSU1hbmFnZXIgdG8gc2hvdyB0aGUgY2hhdCB2aWV3IGFnYWluXG4gICAgICAgIHRoaXMudWlNYW5hZ2VyLnNob3dDaGF0VmlldygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBub3RlcyBjb250YWluZXIuXG4gICAgICogQHJldHVybnMgVGhlIG5vdGVzIGNvbnRhaW5lciBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90ZXNDb250YWluZXI7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RlSGFuZGxlciA9IE5vdGVIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvcHVwTWVudU1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBhbmQgaW50ZXJhY3Rpb25zIG9mIHRoZSBtdWx0aS1sZXZlbCBwb3B1cCBtZW51LlxuICovXG5jbGFzcyBQb3B1cE1lbnVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NNYW5hZ2VyLCB3aWRnZXROb2RlLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gJ3RvcCc7XG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgIHRoaXMubWVudUhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBUcmFjayBjdXJyZW50bHkgc2VsZWN0ZWQgbWVudSBpdGVtXG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmdDb250ZW50ID0gZmFsc2U7IC8vIEZsYWcgdG8gcHJldmVudCByZWN1cnNpdmUgcmVuZGVyc1xuICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gJyc7IC8vIFRyYWNrIGxhc3Qgc2VhcmNoIHRlcm0gdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICAgICAgICB0aGlzLmFsbG93ZWRFeHRlbnNpb25zID0gWycucHknLCAnLmlweW5iJywgJy5tZCcsICcuanNvbicsICcudHh0JywgJy5jc3YnXTtcbiAgICAgICAgdGhpcy5maWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZG9jTWFuYWdlciA9IGRvY01hbmFnZXI7XG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZSA9IHdpZGdldE5vZGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJzsgLy8gQ3J1Y2lhbCBmb3IgcG9zaXRpb25pbmcgcmVsYXRpdmUgdG8gd2lkZ2V0Tm9kZVxuICAgICAgICAvLyBBdHRhY2ggdG8gdGhlIHdpZGdldCBub2RlIGluc3RlYWQgb2YgdGhlIGJvZHlcbiAgICAgICAgdGhpcy53aWRnZXROb2RlLmFwcGVuZENoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgLy8gQ3JlYXRlIHNlYXJjaCBpbnB1dFxuICAgICAgICB0aGlzLnNlYXJjaElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LnBsYWNlaG9sZGVyID0gJ1NlYXJjaC4uLic7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1zZWFyY2gnOyAvLyBBZGQgY2xhc3MgZm9yIHN0eWxpbmdcbiAgICAgICAgLy8gVXNlICdpbnB1dCcgZXZlbnQgaW5zdGVhZCBvZiBkaXJlY3RseSByZS1yZW5kZXJpbmcgb24gZXZlcnkga2V5c3Ryb2tlXG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlLXJlbmRlciBpZiB0aGUgc2VhcmNoIHRlcm0gaGFzIGFjdHVhbGx5IGNoYW5nZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaElucHV0LnZhbHVlICE9PSB0aGlzLmxhc3RTZWFyY2hUZXJtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2VhcmNoVGVybSA9IHRoaXMuc2VhcmNoSW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSGFuZGxlIGtleWRvd24gaW4gc2VhcmNoIGlucHV0IHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIG5hdmlnYXRpb24ga2V5c1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBTZWFyY2ggS2V5RG93bjogS2V5PScke2V2ZW50LmtleX0nYCk7XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFByZXZlbnQgdGhlc2Uga2V5cyBmcm9tIGJlaW5nIGNhcHR1cmVkIGJ5IHRoZSBkb2N1bWVudCBoYW5kbGVyXG4gICAgICAgICAgICBpZiAoWydBcnJvd1VwJywgJ0Fycm93RG93bicsICdFbnRlcicsICdUYWInLCAnRXNjYXBlJ10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCAoU2VhcmNoIElucHV0KTogU3RvcHBpbmcgcHJvcGFnYXRpb24gZm9yIG5hdmlnYXRpb24ga2V5OicsIGV2ZW50LmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIEVzY2FwZSBkaXJlY3RseSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZpcnN0IGl0ZW0gb24gRW50ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBzZWxlY3Rpb24sIGNsaWNrIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPj0gMCAmJiB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA8IG1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXNbdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXhdLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHNlbGVjdCBhbmQgY2xpY2sgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXNbMF0uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW51SXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHNlbGVjdGlvbiB5ZXQsIHNlbGVjdCBmaXJzdCBvciBsYXN0IGJhc2VkIG9uIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gZGlyZWN0aW9uID4gMCA/IDAgOiBtZW51SXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBtb3ZlIGluIHRoZSBzcGVjaWZpZWQgZGlyZWN0aW9uIHdpdGggd3JhcGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ICsgZGlyZWN0aW9uICsgbWVudUl0ZW1zLmxlbmd0aCkgJSBtZW51SXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgZm9jdXMgaW4gc2VhcmNoIGlucHV0IGJ1dCB1cGRhdGUgc2VsZWN0aW9uIHZpc3VhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENSSVRJQ0FMOiBETyBOT1Qgc3RvcCBwcm9wYWdhdGlvbiBmb3IgQmFja3NwYWNlIG9yIG90aGVyIHRleHQgZWRpdGluZyBrZXlzXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBkZWZhdWx0IGJlaGF2aW9yIHRvIHdvcmsgcHJvcGVybHlcbiAgICAgICAgfSwgdHJ1ZSk7IC8vIFVzZSBjYXB0dXJlIHBoYXNlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IFVzZSBhIHNlcGFyYXRlIGJvdW5kIGZ1bmN0aW9uIGZvciB0aGUgZG9jdW1lbnQga2V5ZG93blxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZSBleGFjdCBzYW1lIGxpc3RlbmVyIGxhdGVyXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIGlmIChnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuY29ubmVjdCgoc2VuZGVyLCBub3RlYm9vaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgLy8gUmVtb3ZlIHVzaW5nIHRoZSBleGFjdCBzYW1lIGJvdW5kIGZ1bmN0aW9uXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHdpZGdldE5vZGUgaWYgYXR0YWNoZWRcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMud2lkZ2V0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmICF0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBhdEJ1dHRvbiA9IHRoaXMud2lkZ2V0Tm9kZS5xdWVyeVNlbGVjdG9yKCcjanAtbGxtLWV4dC1hdC1idXR0b24nKTtcbiAgICAgICAgICAgIGlmIChhdEJ1dHRvbiAmJiBhdEJ1dHRvbi5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBDbGljayB3YXMgb24gdGhlIEAgYnV0dG9uLCBub3QgaGlkaW5nLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQ2xpY2sgZGV0ZWN0ZWQgb3V0c2lkZSB0aGUgbWVudS4nKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNob3dQb3B1cE1lbnUodHJpZ2dlcikge1xuICAgICAgICBsZXQgYW5jaG9yWDtcbiAgICAgICAgbGV0IGFuY2hvclk7XG4gICAgICAgIGlmICh0cmlnZ2VyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0cmlnZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgYW5jaG9yWCA9IHJlY3QubGVmdDsgLy8gVXNlIGJ1dHRvbidzIHRvcC1sZWZ0IGZvciBhbmNob3JcbiAgICAgICAgICAgIGFuY2hvclkgPSByZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogU2hvd2luZyBtZW51IHRyaWdnZXJlZCBieSBlbGVtZW50IGF0ICgke2FuY2hvclh9LCAke2FuY2hvcll9KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yWCA9IHRyaWdnZXIueDtcbiAgICAgICAgICAgIGFuY2hvclkgPSB0cmlnZ2VyLnk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNob3dpbmcgbWVudSB0cmlnZ2VyZWQgYnkgY29vcmRpbmF0ZXMgYXQgKCR7YW5jaG9yWH0sICR7YW5jaG9yWX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIGNhbGN1bGF0ZWQgYW5jaG9yIHBvaW50IGZvciBwb3NpdGlvbmluZ1xuICAgICAgICB0aGlzLl9hbmNob3JYID0gYW5jaG9yWDtcbiAgICAgICAgdGhpcy5fYW5jaG9yWSA9IGFuY2hvclk7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9ICd0b3AnO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHRoaXMubWVudUhpc3RvcnkgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIHNob3dcbiAgICAgICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSAnJzsgLy8gUmVzZXQgbGFzdCBzZWFyY2ggdGVybVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKTtcbiAgICAgICAgLy8gRW5zdXJlIGl0J3MgYXR0YWNoZWQgdG8gdGhlIHdpZGdldCBub2RlIGlmIHNvbWVob3cgZGV0YWNoZWRcbiAgICAgICAgdGhpcy53aWRnZXROb2RlLmFwcGVuZENoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgLy8gQWRkIGtleWRvd24gbGlzdGVuZXIgd2hlbiBzaG93aW5nXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBwb3B1cCBtZW51IC0gREVGRVIgY2FsY3VsYXRpb24gc2xpZ2h0bHlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBPUFVQOiBEZWZlcnJlZCB1cGRhdGVQb3B1cFBvc2l0aW9uIGNhbGwuXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvcHVwUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQT1BVUDogRXJyb3IgZHVyaW5nIGRlZmVycmVkIHVwZGF0ZVBvcHVwUG9zaXRpb246XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvY3VzIHRoZSBzZWFyY2ggaW5wdXQgKmFmdGVyKiBwb3NpdGlvbmluZyBpZiBpbiBmaWxlL2RpciB2aWV3XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGZvY3VzIGZpcnN0IG1lbnUgaXRlbVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGb2N1c2VkIHNlYXJjaCBpbnB1dCBhZnRlciBkZWZlcnJlZCBwb3NpdGlvbmluZy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBEb24ndCBzZWxlY3QgYW4gaXRlbSBpZiBzZWFyY2ggaXMgZm9jdXNlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIFRvcCBsZXZlbCBvciBjZWxsc1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKTsgLy8gU2VsZWN0IGZpcnN0IGl0ZW1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IFNlbGVjdGVkIGZpcnN0IG1lbnUgaXRlbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTsgLy8gMG1zIGRlbGF5IGlzIHVzdWFsbHkgc3VmZmljaWVudFxuICAgIH1cbiAgICBoaWRlUG9wdXBNZW51KCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEhpZGluZyBtZW51LiBDYWxsZWQgZnJvbTonLCBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gJ3RvcCc7IC8vIFJlc2V0IGxldmVsXG4gICAgICAgICAgICAvLyBSZW1vdmUga2V5ZG93biBsaXN0ZW5lciB3aGVuIGhpZGluZ1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUE9QVVA6IFJlbW92ZWQga2V5ZG93biBsaXN0ZW5lci5cIik7XG4gICAgICAgICAgICAvLyBDbGVhciBhbmNob3JzXG4gICAgICAgICAgICB0aGlzLl9hbmNob3JYID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yWSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZW5kZXJNZW51Q29udGVudCgpIHtcbiAgICAgICAgLy8gUHJldmVudCByZWN1cnNpdmUgcmVuZGVyc1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogU2tpcHBpbmcgcmVuZGVyIC0gYWxyZWFkeSByZW5kZXJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBhZGQgc2VhcmNoIGlucHV0IGlmIE5PVCBhdCB0b3AgbGV2ZWxcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHNlYXJjaCBpbnB1dCBhdCB0aGUgdG9wIG9mIHRoZSBtZW51XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWFyY2hJbnB1dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBDbGVhciBmb3IgZmlsZS9kaXIvY2VsbCBsZXZlbHNcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW5kZXIgZGlmZmVyZW50IG1lbnUgY29udGVudCBiYXNlZCBvbiBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudE1lbnVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9wTGV2ZWxJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlyZWN0b3JpZXMnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZWxscyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyQ2VsbEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgc2VsZWN0aW9uIGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIChtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIGNvbnRlbnQgcmVuZGVyaW5nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQT1BVUDogPT09PiBBYm91dCB0byBjYWxsIHVwZGF0ZVBvcHVwUG9zaXRpb24gYWZ0ZXIgcmVuZGVyTWVudUNvbnRlbnRcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUG9wdXBQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQT1BVUDogRXJyb3IgY2FsbGluZyB1cGRhdGVQb3B1cFBvc2l0aW9uIGFmdGVyIHJlbmRlcjpcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBFcnJvciByZW5kZXJpbmcgbWVudSBjb250ZW50JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJUb3BMZXZlbEl0ZW1zKCkge1xuICAgICAgICBjb25zdCB0b3BMZXZlbENvbW1hbmRzID0gW1xuICAgICAgICAgICAgeyBsYWJlbDogJ0NvZGUnLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnaW5zZXJ0LWNvZGUnIH0sXG4gICAgICAgICAgICB7IGxhYmVsOiAnQ2VsbHMnLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWNlbGxzJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0ZpbGUnLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWZpbGVzJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0RpcmVjdG9yeScsIGRlc2NyaXB0aW9uOiAnJywgYWN0aW9uSWQ6ICdicm93c2UtZGlyZWN0b3JpZXMnIH1cbiAgICAgICAgXTtcbiAgICAgICAgdG9wTGV2ZWxDb21tYW5kcy5mb3JFYWNoKGNtZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShjbWQubGFiZWwsIGNtZC5hY3Rpb25JZCwgJycsIGNtZC5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBHZXQgc2VhcmNoIHRlcm1cbiAgICAgICAgY29uc3Qgc2VhcmNoVGVybSA9IHRoaXMuc2VhcmNoSW5wdXQudmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGNvbnN0IGxvYWRpbmdJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTG9hZGluZy4uLicsICdsb2FkaW5nJywgJycsICcnKTtcbiAgICAgICAgbG9hZGluZ0l0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgYWRkIGxvYWRpbmcgaXRlbSBiZWxvdyBzZWFyY2gvcGF0aFxuICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IChfYSA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dFNpYmxpbmc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmluc2VydEJlZm9yZShsb2FkaW5nSXRlbSwgaW5zZXJ0aW9uUG9pbnQgfHwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBjb250ZW50cyB3ZXJlIGFscmVhZHkgZmV0Y2hlZCByZWNlbnRseSBhbmQgd2UncmUganVzdCBmaWx0ZXJpbmcgYWdhaW4sXG4gICAgICAgICAgICAvLyB3ZSBjb3VsZCBwb3RlbnRpYWxseSBjYWNoZSB0aGUgcmVzdWx0cyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBBUEkgY2FsbHNcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclR5cGUgPSB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgPyAnZmlsZScgOiAnZGlyZWN0b3J5JztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5saXN0Q3VycmVudERpcmVjdG9yeUNvbnRlbnRzKHRoaXMuY3VycmVudE1lbnVQYXRoLCBmaWx0ZXJUeXBlKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHN0aWxsIGluIERPTSBiZWZvcmUgdHJ5aW5nIHRvIHJlbW92ZVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50cyAmJiBjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJhc2VkIG9uIHNlYXJjaCB0ZXJtXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRDb250ZW50cyA9IGNvbnRlbnRzLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbGF0aXZlUGF0aC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZENvbnRlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRDb250ZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbU5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1QYXRoID0gaXRlbS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gaXRlbS5yZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gaXRlbVR5cGUgPT09ICdkaXJlY3RvcnknID8gJ/Cfk4EnIDogJ/Cfk4QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbklkID0gdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ3NlbGVjdC1kaXJlY3RvcnktbmF2aWdhdGUnIDogJ3NlbGVjdC1kaXJlY3RvcnktY2FsbGJhY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGl0ZW1UeXBlID09PSAnZmlsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZCA9ICdzZWxlY3QtZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oYCR7aWNvbn0gJHtpdGVtTmFtZX1gLCBhY3Rpb25JZCwgaXRlbVBhdGgsIHJlbGF0aXZlUGF0aCAhPT0gJy4nID8gcmVsYXRpdmVQYXRoIDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQobWVudUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oc2VhcmNoVGVybSA/ICdObyBtYXRjaGVzIGZvdW5kJyA6IGBObyAke2ZpbHRlclR5cGV9cyBmb3VuZGAsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5SXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oYE5vIGl0ZW1zIGZvdW5kIGluIHRoaXMgZGlyZWN0b3J5YCwgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVycm9ySXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oYEVycm9yOiAke2Vycm9yfWAsICdlcnJvcicsICcnLCAnJyk7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZXJyb3JJdGVtKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBFcnJvciBsb2FkaW5nL2ZpbHRlcmluZyBkaXJlY3RvcnkgY29udGVudHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYWxsIGNlbGxzIGZyb20gdGhlIGN1cnJlbnQgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBhc3luYyByZW5kZXJDZWxsSXRlbXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIEdldCBzZWFyY2ggdGVybSBmb3IgZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICAvLyBDcmVhdGUgYSBsb2FkaW5nIGluZGljYXRvclxuICAgICAgICBjb25zdCBsb2FkaW5nSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ0xvYWRpbmcgY2VsbHMuLi4nLCAnbG9hZGluZycsICcnLCAnJyk7XG4gICAgICAgIGxvYWRpbmdJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIGNvbnN0IGluc2VydGlvblBvaW50ID0gKF9hID0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIucXVlcnlTZWxlY3RvcignLmpwLWxsbS1leHQtcG9wdXAtbWVudS1wYXRoJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXh0U2libGluZztcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuaW5zZXJ0QmVmb3JlKGxvYWRpbmdJdGVtLCBpbnNlcnRpb25Qb2ludCB8fCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW4gYWN0aXZlIG5vdGVib29rXG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudE5vdGVib29rIHx8ICF0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50IHx8ICF0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50Lm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaXRlbVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdObyBhY3RpdmUgbm90ZWJvb2sgZm91bmQnLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tNb2RlbCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRlbnQubW9kZWw7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IG5vdGVib29rTW9kZWwuY2VsbHM7XG4gICAgICAgICAgICAvLyBSZW1vdmUgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNlbGxzIHx8IGNlbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ05vIGNlbGxzIGluIG5vdGVib29rJywgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW5kIGRpc3BsYXkgZWFjaCBjZWxsXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWRDZWxsQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxscy5nZXQoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbFR5cGUgPSBjZWxsLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSBjZWxsLnNoYXJlZE1vZGVsID8gY2VsbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKSA6XG4gICAgICAgICAgICAgICAgICAgICgoKF9iID0gY2VsbC50b0pTT04oKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvdXJjZSkgfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0eXBlIGNhc3RpbmcgdG8gYXZvaWQgVHlwZVNjcmlwdCBlcnJvcnNcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRpb25Db3VudCA9IGNlbGxUeXBlID09PSAnY29kZScgP1xuICAgICAgICAgICAgICAgICAgICAoY2VsbC5leGVjdXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNlbGwuZXhlY3V0aW9uQ291bnQgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5leGVjdXRpb25Db3VudCA6ICcqJykgOlxuICAgICAgICAgICAgICAgICAgICAnJztcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwcmV2aWV3IG9mIHRoZSBjZWxsIGNvbnRlbnQgKHRydW5jYXRlIGlmIG5lZWRlZClcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50UHJldmlldyA9IHR5cGVvZiBjZWxsQ29udGVudCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA6XG4gICAgICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNlbGxDb250ZW50KSA/IGNlbGxDb250ZW50LmpvaW4oJ1xcbicpIDogJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGNvbnRlbnRQcmV2aWV3LnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCB0cnVuY2F0ZWRDb250ZW50ID0gZmlyc3RMaW5lLmxlbmd0aCA+IDMwID9cbiAgICAgICAgICAgICAgICAgICAgZmlyc3RMaW5lLnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJyA6XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY2VsbCBsYWJlbCB3aXRoIHN0eWxlZCB0eXBlIGluZGljYXRvclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJbmRpY2F0b3IgPSBjZWxsVHlwZSA9PT0gJ21hcmtkb3duJyA/ICdNJyA6ICdDJztcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRpb25EaXNwbGF5ID0gZXhlY3V0aW9uQ291bnQgIT09ICcnID8gYFske2V4ZWN1dGlvbkNvdW50fV1gIDogJyc7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG1lbnUgaXRlbSBmb3IgdGhpcyBjZWxsXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCcnLCAvLyBFbXB0eSB0ZXh0LCB3aWxsIGJlIGFkZGVkIGFzIEhUTUxcbiAgICAgICAgICAgICAgICAnc2VsZWN0LWNlbGwnLCBpLnRvU3RyaW5nKCkgLy8gU3RvcmUgY2VsbCBpbmRleCBpbiBwYXRoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc3R5bGVkIGNvbnRlbnQgd2l0aCBIVE1MIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgdHlwZVNwYW4uY2xhc3NOYW1lID0gYGNlbGwtdHlwZS1pbmRpY2F0b3IgY2VsbC10eXBlLSR7Y2VsbFR5cGUgPT09ICdtYXJrZG93bicgPyAnbWQnIDogJ2NvZGUnfWA7XG4gICAgICAgICAgICAgICAgdHlwZVNwYW4udGV4dENvbnRlbnQgPSB0eXBlSW5kaWNhdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWNTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGV4ZWNTcGFuLmNsYXNzTmFtZSA9ICdjZWxsLWV4ZWMtY291bnQnO1xuICAgICAgICAgICAgICAgIGV4ZWNTcGFuLnRleHRDb250ZW50ID0gZXhlY3V0aW9uRGlzcGxheTtcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi5zdHlsZS5tYXJnaW5SaWdodCA9ICc4cHgnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTcGFuLmNsYXNzTmFtZSA9ICdjZWxsLWNvbnRlbnQtcHJldmlldyc7XG4gICAgICAgICAgICAgICAgY29udGVudFNwYW4udGV4dENvbnRlbnQgPSB0cnVuY2F0ZWRDb250ZW50O1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbGFiZWwgc3BhbiAoZmlyc3QgY2hpbGQgb2YgdGhlIG1lbnUgaXRlbSlcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFNwYW4gPSBjZWxsSXRlbS5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsU3Bhbikge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFNwYW4udGV4dENvbnRlbnQgPSAnJzsgLy8gQ2xlYXIgZXhpc3RpbmcgdGV4dFxuICAgICAgICAgICAgICAgICAgICBsYWJlbFNwYW4uYXBwZW5kQ2hpbGQodHlwZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKGV4ZWNTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbFNwYW4uYXBwZW5kQ2hpbGQoY29udGVudFNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgZnVsbCBzZWFyY2hhYmxlIHRleHRcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hhYmxlVGV4dCA9IGAke3R5cGVJbmRpY2F0b3J9ICR7ZXhlY3V0aW9uRGlzcGxheX0gJHt0cnVuY2F0ZWRDb250ZW50fWAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgYnkgc2VhcmNoIHRlcm0gaWYgb25lIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFRlcm0gJiYgIXNlYXJjaGFibGVUZXh0LmluY2x1ZGVzKHNlYXJjaFRlcm0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChjZWxsSXRlbSk7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRDZWxsQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZENlbGxDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vTWF0Y2hJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTm8gbWF0Y2hpbmcgY2VsbHMgZm91bmQnLCAnZW1wdHknLCAnJywgJycpO1xuICAgICAgICAgICAgICAgIG5vTWF0Y2hJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQobm9NYXRjaEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBFcnJvcjogJHtlcnJvcn1gLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgbG9hZGluZyBub3RlYm9vayBjZWxsczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTWVudUl0ZW0odGV4dCwgYWN0aW9uSWQsIHBhdGggPSAnJywgZGVzY3JpcHRpb24gPSAnJykge1xuICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJztcbiAgICAgICAgaXRlbS5kYXRhc2V0LmFjdGlvbklkID0gYWN0aW9uSWQ7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBpdGVtLmRhdGFzZXQucGF0aCA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG1vdXNlIGV2ZW50cyB0byBjb29yZGluYXRlIHdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgICBpdGVtLm9ubW91c2VvdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gRmluZCBpbmRleCBvZiB0aGlzIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG1lbnVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaXRlbS5vbmNsaWNrID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1lbnVDbGljayhldmVudCk7XG4gICAgICAgIGNvbnN0IGxhYmVsU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgbGFiZWxTcGFuLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChsYWJlbFNwYW4pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgcGF0aFNwYW4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1wYXRoLWluZGljYXRvcic7XG4gICAgICAgICAgICBwYXRoU3Bhbi50ZXh0Q29udGVudCA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUuZm9udFNpemUgPSAnMC44NWVtJztcbiAgICAgICAgICAgIHBhdGhTcGFuLnN0eWxlLmNvbG9yID0gJ3ZhcigtLWpwLXVpLWZvbnQtY29sb3IyKSc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5tYXJnaW5MZWZ0ID0gJzhweCc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5vcGFjaXR5ID0gJzAuOCc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7IC8vIEVuc3VyZSB0aGUgcGF0aCBpcyBhbHdheXMgZGlzcGxheWVkXG4gICAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKHBhdGhTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTWVudUNsaWNrKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgY29uc3QgYWN0aW9uSWQgPSB0YXJnZXQuZGF0YXNldC5hY3Rpb25JZDtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRhcmdldC5kYXRhc2V0LnBhdGggfHwgJyc7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogTWVudSBpdGVtIGNsaWNrZWQuIEFjdGlvbjogJHthY3Rpb25JZH0sIFBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb25JZCkge1xuICAgICAgICAgICAgY2FzZSAnbmF2aWdhdGUtYmFjayc6XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUJhY2tNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNlcnQtY29kZSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmNhbGxiYWNrcy5nZXRTZWxlY3RlZFRleHQgPyB0aGlzLmNhbGxiYWNrcy5nZXRTZWxlY3RlZFRleHQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHN1Ym1lbnUgZm9yIGNvZGUgaW5zZXJ0aW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VibWVudUl0ZW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBsYWJlbDogJ0luc2VydCBhcyBwbGFpbiBjb2RlJywgYWN0aW9uSWQ6ICdpbnNlcnQtcGxhaW4tY29kZScsIGRhdGE6IHNlbGVjdGVkVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsYWJlbDogJ0luc2VydCBhcyBjb2xsYXBzZWQgcmVmZXJlbmNlJywgYWN0aW9uSWQ6ICdjb2xsYXBzZS1jb2RlLXJlZicsIGRhdGE6IHNlbGVjdGVkVGV4dCB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgY3VycmVudCBtZW51IHdpdGggc3VibWVudSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzdWJtZW51SXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShpdGVtLmxhYmVsLCBpdGVtLmFjdGlvbklkLCBpdGVtLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQobWVudUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tCdXR0b24gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdCYWNrJywgJ25hdmlnYXRlLWJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgYmFja0J1dHRvbi5zdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkIHZhcigtLWpwLWJvcmRlci1jb2xvcjEpJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja0J1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgaGlkZSBtZW51LCB3YWl0IGZvciBzdWJtZW51IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSB0aGlzLmNhbGxiYWNrcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQgPyB0aGlzLmNhbGxiYWNrcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShjZWxsQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbnNlcnQtcGxhaW4tY29kZSc6IHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2RlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb2xsYXBzZS1jb2RlLXJlZic6IHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiB0aGlzLmN1cnJlbnROb3RlYm9vaykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG5vdGVib29rIGZpbGUgbmFtZSAod2l0aG91dCBleHRlbnNpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RlYm9va1BhdGggPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RlYm9va05hbWUgPSAoKF9hID0gbm90ZWJvb2tQYXRoLnNwbGl0KCcvJykucG9wKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnLicpWzBdKSB8fCAnbm90ZWJvb2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBjdXJyZW50IGNlbGwgaW5kZXggYW5kIGFwcHJveGltYXRlIGxpbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRlbnQuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBjZWxsIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBjZWxsIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEluZGV4ID0gdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudC5hY3RpdmVDZWxsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBsaW5lIG51bWJlciBmcm9tIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAxOyAvLyBEZWZhdWx0IHRvIGxpbmUgMVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGN1cnJlbnRDZWxsLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBjdXJzb3IubGluZSArIDE7IC8vIENvbnZlcnQgdG8gMS1pbmRleGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2xsYXBzZWRDb2RlUmVmKHBhdGgsIGN1cnJlbnRDZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGNvbGxhcHNlZCBjb2RlIHJlZmVyZW5jZTonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBpbnNlcnRpbmcgY29kZSBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZyBvciBubyBwYXRoIHByb3ZpZGVkLCBqdXN0IGluc2VydCBhcyByZWd1bGFyIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWNlbGxzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnY2VsbHMnLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWZpbGVzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnZmlsZXMnLCB0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgc2VhcmNoIHdoZW4gY2hhbmdpbmcgdmlldyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWRpcmVjdG9yaWVzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnZGlyZWN0b3JpZXMnLCB0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgc2VhcmNoIHdoZW4gY2hhbmdpbmcgdmlldyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZWN0LWNlbGwnOlxuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJbmRleCA9IHBhcnNlSW50KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNlbGxJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgcmVmZXJlbmNlIHRleHQgKGUuZy4sIFwiQENlbGwgM1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcmVmVGV4dCA9IGBAQ2VsbCAke2NlbGxJbmRleCArIDF9YDsgLy8gVXNlIDEtYmFzZWQgaW5kZXggZm9yIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVE9ETzogSW1wbGVtZW50IGNlbGwgcmVmZXJlbmNlIGluc2VydGlvbjogXCIsIHJlZlRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q2VsbEJ5SW5kZXgoY2VsbEluZGV4KTsgLy8gQ2FsbCB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEludmFsaWQgY2VsbCBpbmRleC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IENlbGwgc2VsZWN0ZWQgYnV0IGluZGV4IChwYXRoKSBpcyBtaXNzaW5nLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1maWxlJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHJlZmVyZW5jZSB0ZXh0IChlLmcuLCBcIkBmaWxlIHBhdGgvdG8vZmlsZS5weVwiKVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCByZWZUZXh0ID0gYEBmaWxlICR7cGF0aH1gO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRPRE86IEltcGxlbWVudCBmaWxlIHJlZmVyZW5jZSBpbnNlcnRpb246IFwiLCByZWZUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaGFuZGxlSW5zZXJ0RmlsZVdpZGdldChwYXRoKTsgLy8gTkVXOiBDYWxsIHdpZGdldCBpbnNlcnRpb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRmlsZSBzZWxlY3RlZCBidXQgcGF0aCBpcyBtaXNzaW5nLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1kaXJlY3RvcnknOlxuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhhbmRsZUluc2VydERpcldpZGdldChwYXRoKTsgLy8gTkVXOiBDYWxsIHdpZGdldCBpbnNlcnRpb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRGlyZWN0b3J5IHNlbGVjdGVkIGJ1dCBwYXRoIGlzIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZWN0LWRpcmVjdG9yeS1uYXZpZ2F0ZSc6IC8vIE5ldyBhY3Rpb24gdG8gbmF2aWdhdGUgaW50byBkaXIgd2hlbiBpbiBmaWxlIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgZmlsZSBjYWNoZSBmb3IgdGhlIHNwZWNpZmljIGRpcmVjdG9yeSB0byBmb3JjZSBhIHJlZnJlc2hcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtwYXRofToke3RoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyA/ICdmaWxlJyA6ICdkaXJlY3RvcnknfWA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBwYXNzaW5nIHRoZSBjb3JyZWN0IGxldmVsIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsIDogJ2ZpbGVzJztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUobGV2ZWwsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlID0gJyc7IC8vIENsZWFyIHNlYXJjaCBvbiBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRGlyZWN0b3J5IHNlbGVjdGVkIGZvciBuYXZpZ2F0aW9uIGJ1dCBwYXRoIGlzIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZWN0LWRpcmVjdG9yeS1jYWxsYmFjayc6IC8vIE5ldyBhY3Rpb24gdG8gc2VsZWN0IGRpciB3aGVuIGluIGRpcmVjdG9yeSB2aWV3XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSByZWZlcmVuY2UgdGV4dCAoZS5nLiwgXCJAZGlyIHBhdGgvdG8vZGlyZWN0b3J5XCIpXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHJlZlRleHQgPSBgQGRpciAke3BhdGh9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJUT0RPOiBJbXBsZW1lbnQgZGlyZWN0b3J5IHJlZmVyZW5jZSBpbnNlcnRpb246IFwiLCByZWZUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaGFuZGxlSW5zZXJ0RGlyV2lkZ2V0KHBhdGgpOyAvLyBDb3JyZWN0ZWQgdG8gdXNlIHRoZSBuZXcgd2lkZ2V0IGluc2VydGlvbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIGNhbGxiYWNrIGJ1dCBwYXRoIGlzIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGxhY2Vob2xkZXItYWN0aW9uJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGxhY2Vob2xkZXIgYWN0aW9uIHRyaWdnZXJlZC4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZW1wdHknOlxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IFVua25vd24gbWVudSBhY3Rpb246JywgYWN0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBuYXZpZ2F0ZU1lbnUobGV2ZWwsIHBhdGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIHRvIGxldmVsOiAke2xldmVsfSwgcGF0aDogJHtwYXRofWApO1xuICAgICAgICAvLyBPbmx5IHB1c2ggaGlzdG9yeSBpZiB3ZSBhcmUgYWN0dWFsbHkgbW92aW5nIHRvIGEgbmV3IHN0YXRlXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09IGxldmVsIHx8IHRoaXMuY3VycmVudE1lbnVQYXRoICE9PSBwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5LnB1c2goeyBsZXZlbDogdGhpcy5jdXJyZW50TWVudUxldmVsLCBwYXRoOiB0aGlzLmN1cnJlbnRNZW51UGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBwYXRoO1xuICAgICAgICAvLyBEb24ndCBjbGVhciBzZWFyY2ggb24gcHJvZ3JhbW1hdGljIG5hdmlnYXRpb24gKGxpa2UgYmFjayBidXR0b24pXG4gICAgICAgIC8vIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gTWF5YmUga2VlcCBzZWFyY2ggdGVybT9cbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpO1xuICAgICAgICAvLyBGb2N1cyBzZWFyY2ggaW5wdXQgYWZ0ZXIgbmF2aWdhdGluZyB0byBmaWxlL2RpciB2aWV3XG4gICAgICAgIGlmIChsZXZlbCA9PT0gJ2ZpbGVzJyB8fCBsZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCksIDApO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTsgLy8gUmVzZXQgc2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgZmlyc3QgaXRlbSBpZiBuYXZpZ2F0aW5nIGJhY2sgdG8gdG9wIGxldmVsXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZUJhY2tNZW51KCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5tZW51SGlzdG9yeS5wb3AoKTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogTmF2aWdhdGluZyBiYWNrIHRvIGxldmVsOiAke3ByZXZpb3VzU3RhdGUubGV2ZWx9LCBwYXRoOiAke3ByZXZpb3VzU3RhdGUucGF0aH1gKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9IHByZXZpb3VzU3RhdGUubGV2ZWw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IHByZXZpb3VzU3RhdGUucGF0aDtcbiAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHNlYXJjaCBvbiBiYWNrIG5hdmlnYXRpb25cbiAgICAgICAgICAgIHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBzZWFyY2ggaW5wdXQgaWYgZ29pbmcgYmFjayB0byBmaWxlL2RpciB2aWV3XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGN1cnNvciB0byBlbmQgb2YgaW5wdXQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFJlc2V0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZpcnN0IGl0ZW0gaWYgZ29pbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQWxyZWFkeSBhdCB0aGUgdG9wIGxldmVsLicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyhiYXNlUGF0aCwgZmlsdGVyVHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IExpc3RpbmcgZGlyZWN0b3J5IGNvbnRlbnRzIGZvciBwYXRoOiAnJHtiYXNlUGF0aH0nLCBmaWx0ZXI6ICR7ZmlsdGVyVHlwZSB8fCAnYWxsJ31gKTtcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtiYXNlUGF0aH06JHtmaWx0ZXJUeXBlIHx8ICdhbGwnfWA7XG4gICAgICAgIGlmICh0aGlzLmZpbGVDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IFVzaW5nIGNhY2hlZCBkaXJlY3RvcnkgY29udGVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVDYWNoZS5nZXQoY2FjaGVLZXkpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVBhdGggPSBiYXNlUGF0aCA9PT0gJy8nID8gJycgOiBiYXNlUGF0aDtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSB1bmxlc3MgaXQncyByb290XG4gICAgICAgICAgICBjb25zdCBwYXRoRm9yQXBpID0gZWZmZWN0aXZlUGF0aC5lbmRzV2l0aCgnLycpICYmIGVmZmVjdGl2ZVBhdGgubGVuZ3RoID4gMSA/IGVmZmVjdGl2ZVBhdGguc2xpY2UoMCwgLTEpIDogZWZmZWN0aXZlUGF0aDtcbiAgICAgICAgICAgIC8vIFJlc3VsdCBhcnJheSB0aGF0IHdpbGwgaG9sZCBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICBsZXQgYWxsUmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIGRpcmVjdG9yeSBjb250ZW50cyAobm9uLXJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDb250ZW50cyA9IGF3YWl0IHRoaXMuZG9jTWFuYWdlci5zZXJ2aWNlcy5jb250ZW50cy5nZXQocGF0aEZvckFwaSB8fCAnJyk7XG4gICAgICAgICAgICBpZiAoYmFzZUNvbnRlbnRzLnR5cGUgIT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGF0aCBpcyBub3QgYSBkaXJlY3Rvcnk6JywgYmFzZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2VzcyBiYXNlIGRpcmVjdG9yeSBpdGVtc1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGJhc2VDb250ZW50cy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknID8gJ2RpcmVjdG9yeScgOiAnZmlsZSc7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGRpcmVjdG9yaWVzIGlmIHdlJ3JlIGxpc3RpbmcgZGlyZWN0b3JpZXMgb3IgYm90aFxuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2RpcmVjdG9yeScgJiYgKGZpbHRlclR5cGUgPT09ICdkaXJlY3RvcnknIHx8IGZpbHRlclR5cGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiBgLi8ke2l0ZW0ubmFtZX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgZmlsZXMgaWYgd2UncmUgbGlzdGluZyBmaWxlcyBhbmQgdGhlIGV4dGVuc2lvbiBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnZmlsZScgJiYgKGZpbHRlclR5cGUgPT09ICdmaWxlJyB8fCBmaWx0ZXJUeXBlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVFeHQgPSBgLiR7aXRlbS5uYW1lLnNwbGl0KCcuJykucG9wKCl9YC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlRXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGg6IGAuLyR7aXRlbS5uYW1lfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29ydCB0aGUgcmVzdWx0cyBhcHByb3ByaWF0ZWx5XG4gICAgICAgICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGlzdGluZyBkaXJlY3RvcmllcyBvbmx5LCBzb3J0IGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBsaXN0aW5nIGZpbGVzIG9ubHksIHNvcnQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBsaXN0aW5nIGJvdGgsIHNvcnQgZGlyZWN0b3JpZXMgZmlyc3QsIHRoZW4gZmlsZXMgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZGlyZWN0b3J5JyAmJiBiLnR5cGUgIT09ICdkaXJlY3RvcnknKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGEudHlwZSAhPT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlID09PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICB0aGlzLmZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIGFsbFJlc3VsdHMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBGb3VuZCAke2FsbFJlc3VsdHMubGVuZ3RofSBpdGVtcyBmb3IgcGF0aCAnJHtiYXNlUGF0aH0nYCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsUmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFBPUFVQOiBFcnJvciBsaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50cyBmb3IgJyR7YmFzZVBhdGh9JzpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGlyUGF0aCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcDtcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBBcHBsaWNhdGlvbiByZWZlcmVuY2Ugbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2hlbGxXaWRnZXQgPSBhcHAuc2hlbGwuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRTaGVsbFdpZGdldCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGV4dCA9IHRoaXMuZG9jTWFuYWdlci5jb250ZXh0Rm9yV2lkZ2V0KGN1cnJlbnRTaGVsbFdpZGdldCk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aWRnZXRDb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgZGlyUGF0aCA9IHRoaXMuZ2V0UGFyZW50RGlyZWN0b3J5KHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGN1cnJlbnQgd2lkZ2V0IGNvbnRleHQ6ICR7cGF0aH0gLT4gJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsICYmIHRoaXMuY3VycmVudE5vdGVib29rICYmIHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rUGF0aCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90ZWJvb2tQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSB0aGlzLmdldFBhcmVudERpcmVjdG9yeShub3RlYm9va1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGFjdGl2ZSBub3RlYm9vazogJHtub3RlYm9va1BhdGh9IC0+ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0V2lkZ2V0cyA9IEFycmF5LmZyb20oYXBwLnNoZWxsLndpZGdldHMoJ2xlZnQnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUJyb3dzZXJXaWRnZXQgPSBsZWZ0V2lkZ2V0cy5maW5kKHdpZGdldCA9PiB3aWRnZXQuaWQgPT09ICdmaWxlYnJvd3NlcicpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlQnJvd3NlcldpZGdldCAmJiB0eXBlb2YgKChfYSA9IGZpbGVCcm93c2VyV2lkZ2V0Lm1vZGVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpclBhdGggPSBmaWxlQnJvd3NlcldpZGdldC5tb2RlbC5wYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBhdGggZnJvbSBmaWxlIGJyb3dzZXIgd2lkZ2V0IG1vZGVsOiAke2RpclBhdGh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEZpbGUgYnJvd3NlciB3aWRnZXQgcGF0aCBub3QgZGlyZWN0bHkgYWNjZXNzaWJsZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUE9QVVA6IENvdWxkIG5vdCBnZXQgcGF0aCBmcm9tIGZpbGUgYnJvd3Nlci4nLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlyUGF0aCA9ICcnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGYWxsaW5nIGJhY2sgdG8gc2VydmVyIHJvb3QgcGF0aC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IGRpclBhdGg7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogSW5pdGlhbCBjdXJyZW50IG1lbnUgcGF0aCBzZXQgdG86ICcke3RoaXMuY3VycmVudE1lbnVQYXRofSdgKTtcbiAgICB9XG4gICAgZ2V0UGFyZW50RGlyZWN0b3J5KHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBNYXRoLm1heChwYXRoLmxhc3RJbmRleE9mKCcvJyksIHBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSk7XG4gICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuICcnOyAvLyBObyBkaXJlY3RvcnkgcGFydCwgbGlrZWx5IHJvb3Qgb3IganVzdCBhIGZpbGVuYW1lXG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUga2V5Ym9hcmQgbmF2aWdhdGlvbiB3aGVuIHRoZSBwb3B1cCBtZW51IGlzIHNob3duXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgKERvY3VtZW50KTogS2V5RG93biBpbnRlcmNlcHRlZC4gS2V5PScke2V2ZW50LmtleX0nYCk7XG4gICAgICAgIC8vIFByaW9yaXRpemUgc2VhcmNoIGlucHV0IGlmIGZvY3VzZWRcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuc2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCAoRG9jdW1lbnQpOiBLZXlEb3duIC0gU2VhcmNoIGlucHV0IGlzIGZvY3VzZWQsIGxldHRpbmcgaXQgaGFuZGxlLicpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIFRhYiBhbmQgYXJyb3cga2V5cyBzcGVjaWZpY2FsbHkgdG8gbW92ZSBmb2N1cyBvdXQgb2Ygc2VhcmNoXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJyB8fCBldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIChEb2N1bWVudCk6IEtleT0nJHtldmVudC5rZXl9JyBpbiBzZWFyY2ggaW5wdXQgLSBtb3ZpbmcgZm9jdXMuYCk7XG4gICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBibHVycmluZywgbGV0J3MgaGFuZGxlIGFycm93cyBkaXJlY3RseSBpbiB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBpdGVtcyBzZWxlY3RlZCB5ZXQsIHNlbGVjdCBmaXJzdC9sYXN0IGJhc2VkIG9uIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IGRpcmVjdGlvbiA+IDAgPyAwIDogbWVudUl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHNlbGVjdGlvbiBpbiBzcGVjaWZpZWQgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ICsgZGlyZWN0aW9uICsgbWVudUl0ZW1zLmxlbmd0aCkgJSBtZW51SXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgc2VhcmNoIGlucHV0IGZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRhYiBzaG91bGQgc2VsZWN0IG5leHQgaXRlbSBidXQga2VlcCBzZWFyY2ggZm9jdXNlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBUYWIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZXQgb3RoZXIga2V5cyAobGlrZSBFc2NhcGUsIEVudGVyKSBiZSBoYW5kbGVkIGJ5IHRoZSBzZWFyY2ggaW5wdXQncyBvd24gbGlzdGVuZXJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbmF2aWdhdGlvbiBpZiBzZWFyY2ggaXMgbm90IGZvY3VzZWRcbiAgICAgICAgaWYgKFsnQXJyb3dVcCcsICdBcnJvd0Rvd24nLCAnRW50ZXInLCAnVGFiJywgJ0VzY2FwZSddLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCAoRG9jdW1lbnQpOiBIYW5kbGluZyBuYXZpZ2F0aW9uIGtleTonLCBldmVudC5rZXkpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTWVudU5hdmlnYXRpb24oZXZlbnQua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHR5cGluZyBjaGFyYWN0ZXJzIGFuZCBOT1QgaW4gc2VhcmNoIGlucHV0LCBmb2N1cyBzZWFyY2ggYW5kIGFkZCB0aGUgY2hhcmFjdGVyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdjZWxscycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCAoRG9jdW1lbnQpOiBGb2N1c2luZyBzZWFyY2ggaW5wdXQgZHVlIHRvIGNoYXJhY3RlciB0eXBlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHR5cGVkIGNoYXJhY3RlciB0byBzZWFyY2ggaW5wdXQgaWYgaXQncyBhIHByaW50YWJsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleS5tYXRjaCgvXltcXHdcXGRcXHMuLFxcLV89Kzs6J1wiXFxbXFxde30oKSomXiUkI0AhfmB8XFxcXC88Pj9dJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlICs9IGV2ZW50LmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VhcmNoIGlucHV0J3MgJ2lucHV0JyBldmVudCB0byB1cGRhdGUgZmlsdGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNZW51TmF2aWdhdGlvbihrZXkpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBBcnJvdyBEb3duIHByZXNzZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBBcnJvdyBVcCBwcmVzc2VkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91c01lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICdUYWInOiAvLyBUcmVhdCBUYWIgbGlrZSBFbnRlciBmb3Igc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiAke2tleX0gcHJlc3NlZGApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA8IG1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogU2ltdWxhdGluZyBjbGljayBvbiBzZWxlY3RlZCBpdGVtOicsIG1lbnVJdGVtc1t0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleF0udGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgY2xpY2sgdG8gdHJpZ2dlciBoYW5kbGVNZW51Q2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVJdGVtc1t0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleF0uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogU2VsZWN0ZWQgaW5kZXggb3V0IG9mIGJvdW5kcz8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBFbnRlci9UYWIgcHJlc3NlZCBidXQgbm8gaXRlbSBzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBpdGVtIGlzIHNlbGVjdGVkLCBzZWxlY3QgdGhlIGZpcnN0IG9uZSBhbmQgYWN0aXZhdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2l0aCBFbnRlciwgYWx3YXlzIGFjdGl2YXRlIHRoZSBuZXdseSBzZWxlY3RlZCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW1zWzBdLmNsaWNrKCk7IC8vIEFjdGl2YXRlIGZpcnN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBFc2NhcGUgcHJlc3NlZCcpO1xuICAgICAgICAgICAgICAgIC8vIElmIGluIGEgc3VibWVudSwgbmF2aWdhdGUgYmFjazsgb3RoZXJ3aXNlLCBoaWRlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lbnVIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUJhY2tNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICAvLyBIYW5kbGUgb3V0LW9mLWJvdW5kcyBpbmRleFxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPj0gbWVudUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSBtZW51SXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBtZW51SXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIGludG8gdmlldyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpdGVtLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICduZWFyZXN0JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2VsZWN0QWxsTWVudUl0ZW1zKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBtZW51SXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgfVxuICAgIHNlbGVjdE5leHRNZW51SXRlbSgpIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA+PSBtZW51SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IDA7IC8vIFdyYXAgYXJvdW5kXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKTtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBTZWxlY3RlZCBpdGVtIGluZGV4OiAke3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4fWApO1xuICAgIH1cbiAgICBzZWxlY3RQcmV2aW91c01lbnVJdGVtKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXgtLTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSBtZW51SXRlbXMubGVuZ3RoIC0gMTsgLy8gV3JhcCBhcm91bmRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNlbGVjdGVkIGl0ZW0gaW5kZXg6ICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgaW50ZXJhY3RpdmUgbWVudSBpdGVtcyBjdXJyZW50bHkgZGlzcGxheWVkXG4gICAgICovXG4gICAgZ2V0TWVudUl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0nKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCBtZW51IGJhc2VkIG9uIHRoZSBhY3RpdmUgcmVmZXJlbmNlIHJhbmdlXG4gICAgICogb3IgdGhlIGluaXRpYWwgYW5jaG9yIHBvaW50LiBUcmllcyB0byBwb3NpdGlvbiB0aGUgQk9UVE9NLUxFRlQgY29ybmVyIG9mIHRoZSBtZW51XG4gICAgICoganVzdCBBVCBUSEUgVE9QLUxFRlQgY29ybmVyIG9mIHRoZSByYW5nZS9hbmNob3IuXG4gICAgICovXG4gICAgdXBkYXRlUG9wdXBQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpZGdldE5vZGUgfHwgdGhpcy5fYW5jaG9yWCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2FuY2hvclkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUE9QVVA6IENhbm5vdCB1cGRhdGUgcG9zaXRpb24gLSBtaXNzaW5nIHdpZGdldE5vZGUgb3IgYW5jaG9yIHBvaW50cy5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkZ2V0UmVjdCA9IHRoaXMud2lkZ2V0Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gVGFyZ2V0IHBvc2l0aW9uIGlzIHRoZSB2aWV3cG9ydC1yZWxhdGl2ZSBhbmNob3IgcG9pbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0VG9wID0gdGhpcy5fYW5jaG9yWTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TGVmdCA9IHRoaXMuX2FuY2hvclg7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUG9zaXRpb25pbmcgcmVsYXRpdmUgdG8gYW5jaG9yOiAoJHt0YXJnZXRMZWZ0fSwgJHt0YXJnZXRUb3B9KWApO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBvcHVwIGlzIHZpc2libGUgYW5kIHJlbmRlcmVkIHRvIGdldCBpdHMgZGltZW5zaW9uc1xuICAgICAgICAvLyBVc2UgdmlzaWJpbGl0eSB0byBwcmV2ZW50IGZsaWNrZXIgd2hpbGUgbWVhc3VyaW5nXG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGNvbnN0IHBvcHVwSGVpZ2h0ID0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBwb3B1cFdpZHRoID0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIGlmIChwb3B1cEhlaWdodCA9PT0gMCB8fCBwb3B1cFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQT1BVUDogQ2Fubm90IHVwZGF0ZSBwb3NpdGlvbiAtIHBvcHVwIGRpbWVuc2lvbnMgYXJlIHplcm8uXCIpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSGlkZSBpZiBkaW1lbnNpb25zIGFyZSBpbnZhbGlkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRlc2lyZWQgdmlld3BvcnQgY29vcmRpbmF0ZXMgZm9yIHBvcHVwJ3MgdG9wLWxlZnRcbiAgICAgICAgLy8gR29hbDogcG9wdXAgYm90dG9tLWxlZnQgPSBhbmNob3IgdG9wLWxlZnRcbiAgICAgICAgLy8gcG9wdXAgdG9wID0gYW5jaG9yIHRvcCAtIHBvcHVwIGhlaWdodFxuICAgICAgICAvLyBwb3B1cCBsZWZ0ID0gYW5jaG9yIGxlZnRcbiAgICAgICAgbGV0IGRlc2lyZWRUb3AgPSB0YXJnZXRUb3AgLSBwb3B1cEhlaWdodDtcbiAgICAgICAgbGV0IGRlc2lyZWRMZWZ0ID0gdGFyZ2V0TGVmdDtcbiAgICAgICAgLy8gLS0tIFZpZXdwb3J0IEJvdW5kYXJ5IGNoZWNrcyAtLS1cbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgLy8gUHJldmVudCBnb2luZyBvZmYgdGhlIGxlZnQgdmlld3BvcnQgZWRnZVxuICAgICAgICBpZiAoZGVzaXJlZExlZnQgPCAwKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGVmdCA9IDU7IC8vIFNtYWxsIHBhZGRpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUE9QVVAgVmlld3BvcnQgQWRqdXN0OiBDb3JyZWN0ZWQgbGVmdCBlZGdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgZ29pbmcgb2ZmIHRoZSByaWdodCB2aWV3cG9ydCBlZGdlXG4gICAgICAgIGlmIChkZXNpcmVkTGVmdCArIHBvcHVwV2lkdGggPiB2aWV3cG9ydFdpZHRoKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGVmdCA9IHZpZXdwb3J0V2lkdGggLSBwb3B1cFdpZHRoIC0gNTsgLy8gQWRqdXN0IGxlZnQsIGFkZCBwYWRkaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBPUFVQIFZpZXdwb3J0IEFkanVzdDogQ29ycmVjdGVkIHJpZ2h0IGVkZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBnb2luZyBvZmYgdGhlIHRvcCB2aWV3cG9ydCBlZGdlXG4gICAgICAgIGlmIChkZXNpcmVkVG9wIDwgMCkge1xuICAgICAgICAgICAgLy8gSWYgaXQgZ29lcyBvZmYgdGhlIHRvcCwgdHJ5IHBvc2l0aW9uaW5nIGl0ICpiZWxvdyogdGhlIGFuY2hvciBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBHb2FsOiBwb3B1cCB0b3AtbGVmdCA9IGFuY2hvciBib3R0b20tbGVmdFxuICAgICAgICAgICAgY29uc3QgZGVzaXJlZFRvcEJlbG93ID0gdGFyZ2V0VG9wICsgNTsgLy8gQWRkIHNtYWxsIGdhcFxuICAgICAgICAgICAgaWYgKGRlc2lyZWRUb3BCZWxvdyArIHBvcHVwSGVpZ2h0IDw9IHZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZGVzaXJlZFRvcCA9IGRlc2lyZWRUb3BCZWxvdztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBPUFVQIFZpZXdwb3J0IEFkanVzdDogRmxpcHBpbmcgYmVsb3cgYW5jaG9yICh3YXMgb2ZmIHRvcClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgZW5vdWdoIHNwYWNlIGJlbG93IGVpdGhlciwgY2xhbXAgdG8gdG9wIG9mIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgZGVzaXJlZFRvcCA9IDU7IC8vIFNtYWxsIHBhZGRpbmcgZnJvbSB0b3BcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBPUFVQIFZpZXdwb3J0IEFkanVzdDogQ2xhbXBlZCB0byB0b3AgZWRnZSAobm8gc3BhY2UgYmVsb3cpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IE5vIGNoZWNrIGZvciBib3R0b20gZWRnZSBuZWVkZWQgaWYgd2UgcHJpb3JpdGl6ZSBwb3NpdGlvbmluZyBhYm92ZSBvciBjbGFtcGluZyB0byB0b3AuXG4gICAgICAgIC8vIC0tLSBDb252ZXJ0IHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHN0eWxlIHJlbGF0aXZlIHRvIHdpZGdldE5vZGUgLS0tXG4gICAgICAgIGNvbnN0IHN0eWxlVG9wID0gZGVzaXJlZFRvcCAtIHdpZGdldFJlY3QudG9wO1xuICAgICAgICBjb25zdCBzdHlsZUxlZnQgPSBkZXNpcmVkTGVmdCAtIHdpZGdldFJlY3QubGVmdDtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBTZXR0aW5nIHBvc2l0aW9uIC0gVG9wOiAke3N0eWxlVG9wfXB4LCBMZWZ0OiAke3N0eWxlTGVmdH1weCAoUmVsYXRpdmUgdG8gV2lkZ2V0KWApO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHtzdHlsZVRvcH1weGA7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHtzdHlsZUxlZnR9cHhgO1xuICAgICAgICAvLyBNYWtlIGl0IHZpc2libGUgYWdhaW5cbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcG9wdXAgbWVudSBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc1BvcHVwTWVudVZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGV2ZWwgb2YgdGhlIHBvcHVwIG1lbnUuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudE1lbnVMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1lbnVMZXZlbDtcbiAgICB9XG59XG5leHBvcnRzLlBvcHVwTWVudU1hbmFnZXIgPSBQb3B1cE1lbnVNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNldHRpbmdzSGFuZGxlciA9IHZvaWQgMDtcbi8qKlxuICogSGFuZGxlcyB0aGUgbG9naWMgcmVsYXRlZCB0byB0aGUgc2V0dGluZ3MgbW9kYWw6XG4gKiBkaXNwbGF5aW5nLCBoaWRpbmcsIHBvcHVsYXRpbmcsIHNhdmluZywgYW5kIHNob3dpbmcgZmVlZGJhY2suXG4gKi9cbmNsYXNzIFNldHRpbmdzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUsIHNldHRpbmdzTW9kYWxDb250YWluZXIsIHVpTWFuYWdlciAvLyBQYXNzIFVJTWFuYWdlciBmb3Igbm90aWZpY2F0aW9uc1xuICAgICkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciA9IHNldHRpbmdzTW9kYWxDb250YWluZXI7XG4gICAgICAgIHRoaXMudWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgdGhlIHNldHRpbmdzIGZvcm0gd2l0aCBjdXJyZW50IHZhbHVlcyBhbmQgZGlzcGxheXMgdGhlIG1vZGFsLlxuICAgICAqL1xuICAgIHNob3dNb2RhbCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNldHRpbmdzID0gdGhpcy5zdGF0ZS5nZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAoY3VycmVudFNldHRpbmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFF1ZXJ5IGVsZW1lbnRzIHdpdGhpbiB0aGUgbW9kYWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1wcm92aWRlcicpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLnByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLWtleScpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLmFwaUtleTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLWFwaS11cmwnKS52YWx1ZSA9IGN1cnJlbnRTZXR0aW5ncy5hcGlVcmw7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1ydWxlcycpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLnJ1bGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcG9wdWxhdGluZyBzZXR0aW5ncyBmb3JtOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IHNob3cgYW4gZXJyb3IgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHNldHRpbmdzIG1vZGFsLlxuICAgICAqL1xuICAgIGhpZGVNb2RhbCgpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHZhbHVlcyBmcm9tIHRoZSBmb3JtLCBzYXZlcyB0aGVtIHVzaW5nIFNldHRpbmdzU3RhdGUsXG4gICAgICogdXBkYXRlcyB0aGUgQXBpQ2xpZW50LCBoaWRlcyB0aGUgbW9kYWwsIGFuZCBzaG93cyBhIHN1Y2Nlc3Mgbm90aWZpY2F0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBieSB0aGUgbW9kYWwncyBzYXZlIGJ1dHRvbiBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gR2V0IHZhbHVlcyBmcm9tIGZvcm0gZmllbGRzIHdpdGhpbiB0aGUgbW9kYWwgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gKF9hID0gdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1wcm92aWRlcicpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IChfYiA9IHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLWtleScpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWU7XG4gICAgICAgIGNvbnN0IHVybCA9IChfYyA9IHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLXVybCcpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmFsdWU7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gKF9kID0gdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1ydWxlcycpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudmFsdWU7XG4gICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSB1bmRlZmluZWQgfHwga2V5ID09PSB1bmRlZmluZWQgfHwgdXJsID09PSB1bmRlZmluZWQgfHwgcnVsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBmaW5kIGFsbCBzZXR0aW5ncyBpbnB1dCBlbGVtZW50cy5cIik7XG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24oJ0Vycm9yOiBDb3VsZCBub3Qgc2F2ZSBzZXR0aW5ncy4gSW5wdXQgZWxlbWVudHMgbWlzc2luZy4nLCAnZXJyb3InKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHsgcHJvdmlkZXIsIGFwaUtleToga2V5LCBhcGlVcmw6IHVybCwgcnVsZXMgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNhdmUgc2V0dGluZ3MgdXNpbmcgU2V0dGluZ3NTdGF0ZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIHNhdmVkIHZpYSBTZXR0aW5nc1N0YXRlOicsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIC8vIFJlY29uZmlndXJlIEFwaUNsaWVudCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gVE9ETzogVGhlIEFwaUNsaWVudCBzaG91bGQgaWRlYWxseSBvYnNlcnZlIHRoZSBTZXR0aW5nc1N0YXRlIFxuICAgICAgICAgICAgLy8gb3IgaGF2ZSBhIGRlZGljYXRlZCB1cGRhdGUgbWV0aG9kIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSBhc3N1bWUgdGhlIG1haW4gd2lkZ2V0IHdpbGwgcmVjcmVhdGUvdXBkYXRlIHRoZSBBcGlDbGllbnQgXG4gICAgICAgICAgICAvLyBvciBwYXNzIGFuIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IHRoaXMuYXBpQ2xpZW50LnVwZGF0ZUNvbmZpZyhzZXR0aW5ncy5hcGlVcmwgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBUEkgQ2xpZW50IG5lZWRzIHJlY29uZmlndXJhdGlvbiB3aXRoIG5ldyBzZXR0aW5ncy4nKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZU1vZGFsKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24oJ1NldHRpbmdzIHNhdmVkIHN1Y2Nlc3NmdWxseScsICdzdWNjZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5zaG93Tm90aWZpY2F0aW9uKGBFcnJvciBzYXZpbmcgc2V0dGluZ3M6ICR7ZXJyb3J9YCwgJ2Vycm9yJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYSB0ZW1wb3Jhcnkgbm90aWZpY2F0aW9uIG1lc3NhZ2UuXG4gICAgICogUmVsaWVzIG9uIFVJTWFuYWdlciB0byBwcm92aWRlIHRoZSBhY3R1YWwgbm90aWZpY2F0aW9uIG1lY2hhbmlzbS5cbiAgICAgKi9cbiAgICBzaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICAgICAgLy8gRGVsZWdhdGUgbm90aWZpY2F0aW9uIGRpc3BsYXkgdG8gVUlNYW5hZ2VyIG9yIGEgZGVkaWNhdGVkIG5vdGlmaWNhdGlvbiBzZXJ2aWNlXG4gICAgICAgIGlmICh0aGlzLnVpTWFuYWdlciAmJiB0eXBlb2YgdGhpcy51aU1hbmFnZXIuc2hvd05vdGlmaWNhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9yIGxvZyBpZiBVSU1hbmFnZXIgZG9lc24ndCBzdXBwb3J0IG5vdGlmaWNhdGlvbnMgeWV0XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTm90aWZpY2F0aW9uICgke3R5cGV9KTogJHttZXNzYWdlfWApO1xuICAgICAgICAgICAgLy8gVGhlIG9sZCBwb3BTYXZlU3VjY2VzcyBsb2dpYyByZXF1aXJlcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSB3aWRnZXQgbm9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIHRoaXMgaGFuZGxlciBzaG91bGRuJ3QgaGF2ZS4gVGhpcyBuZWVkcyB0byBiZSBoYW5kbGVkIGJ5IHRoZSBVSSBsYXllci5cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2V0dGluZ3NIYW5kbGVyID0gU2V0dGluZ3NIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwU2hvcnRjdXRzID0gc2V0dXBTaG9ydGN1dHM7XG5leHBvcnRzLnJlbW92ZVNob3J0Y3V0cyA9IHJlbW92ZVNob3J0Y3V0cztcbmNvbnN0IG5vdGVib29rX2ludGVncmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb25cIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpOyAvLyBJbXBvcnQgZ2xvYmFscyB0byBnZXQgY2VsbCBpbmRleCBldGMuXG5sZXQgX2hhbmRsZUtleURvd24gPSBudWxsO1xuLyoqXG4gKiBTZXRzIHVwIGdsb2JhbCBrZXlib2FyZCBzaG9ydGN1dHMgZm9yIHRoZSBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIGlucHV0SGFuZGxlciBJbnN0YW5jZSBvZiBJbnB1dEhhbmRsZXIgdG8gaW50ZXJhY3Qgd2l0aCBpbnB1dCBzdGF0ZS9tZXRob2RzLlxuICogQHBhcmFtIHBvcHVwTWVudU1hbmFnZXIgSW5zdGFuY2Ugb2YgUG9wdXBNZW51TWFuYWdlci5cbiAqIEBwYXJhbSBjYWxsYmFja3MgT2JqZWN0IGNvbnRhaW5pbmcgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBVSSBpbnRlcmFjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldHVwU2hvcnRjdXRzKGlucHV0SGFuZGxlciwgLy8gUGFzcyBJbnB1dEhhbmRsZXIgaW5zdGFuY2UgZGlyZWN0bHlcbnBvcHVwTWVudU1hbmFnZXIsIGNhbGxiYWNrcykge1xuICAgIGlmIChfaGFuZGxlS2V5RG93bikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Nob3J0Y3V0cyBhbHJlYWR5IHNldCB1cC4gUmVtb3ZpbmcgcHJldmlvdXMgbGlzdGVuZXIuJyk7XG4gICAgICAgIHJlbW92ZVNob3J0Y3V0cygpO1xuICAgIH1cbiAgICBfaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgeyBzaG93SW5kaWNhdG9yLCBhcHBlbmRUb0lucHV0LCBzaG93V2lkZ2V0LCBmb2N1c0lucHV0IH0gPSBjYWxsYmFja3M7XG4gICAgICAgIC8vIENoZWNrIGZvciBAIGtleSAtIGV2ZW50LmtleSBzaG91bGQgY29ycmVjdGx5IHJlcG9ydCAnQCcgZXZlbiB3aXRoIFNoaWZ0XG4gICAgICAgIC8vIEFsc28gY2hlY2sgZm9yIFNISUZUKzIgYXMgYW4gYWx0ZXJuYXRpdmUgd2F5IHRvIHRyaWdnZXIgJ0AnXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdAJyB8fCAoZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnMicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNIT1JUQ1VUIEhBTkRMRVI6ICdAJyBrZXkgb3IgU0hJRlQrMiBkZXRlY3RlZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RmllbGQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVJbnB1dCA9IGlucHV0RmllbGQgJiZcbiAgICAgICAgICAgICAgICBpbnB1dEZpZWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJyAmJlxuICAgICAgICAgICAgICAgIGlucHV0RmllbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcC1sbG0tZXh0LWlucHV0LWZpZWxkJyk7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGlucHV0IGZpZWxkIGlzIE5PVCB0aGUgYWN0aXZlIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUlucHV0KSB7IC8vIE9ubHkgaGFuZGxlIGlmIE5PVCBvdXIgaW5wdXQgZmllbGRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNIT1JUQ1VUIEhBTkRMRVI6IElucHV0IGZpZWxkIGlzIE5PVCBhY3RpdmUgZWxlbWVudC4gSGFuZGxpbmcgJ0AnIGdsb2JhbGx5LlwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgaW4gb3VyIGlucHV0IGZpZWxkLCBwcmV2ZW50IGRlZmF1bHQsIHNob3cgd2lkZ2V0LCBmb2N1cywgaW5zZXJ0ICdAJywgYW5kIHNob3cgcG9wdXAuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBzaG93V2lkZ2V0KCk7XG4gICAgICAgICAgICAgICAgZm9jdXNJbnB1dCgpO1xuICAgICAgICAgICAgICAgIC8vIEFmdGVyIGZvY3VzLCBzaG93IHBvcHVwIHZpYSB3aW5kb3cuc2V0VGltZW91dCB0byBlbnN1cmUgaW5wdXQgaXMgcmVhZHlcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LWlucHV0LWZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gQ2hlY2sgaWYgc2VsZWN0aW9uIGV4aXN0cyAoZXZlbiBpZiByYW5nZUNvdW50IGlzIDAgaW5pdGlhbGx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgaW5wdXQgZmllbGQgaGFzIGZvY3VzICpiZWZvcmUqIG1hbmlwdWxhdGluZyB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RWxlbWVudC5mb2N1cygpOyAvLyBSZS1mb2N1cyBqdXN0IGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9yIGdldCB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb3VibGUtY2hlY2sgaWYgdGhlIGZvY3VzIGlzIG5vdyBjb3JyZWN0bHkgaW5zaWRlIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXRFbGVtZW50LmNvbnRhaW5zKHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTSE9SVENVVCBIQU5ETEVSOiBSYW5nZSBpcyBub3QgaW5zaWRlIHRoZSBpbnB1dCBmaWVsZCBhZnRlciBmb2N1cy4gQ3JlYXRpbmcgbmV3IHJhbmdlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJhbmdlIGlzIG5vdCBpbnNpZGUsIGNyZWF0ZSBhIG5ldyBvbmUgY29sbGFwc2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhpbnB1dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpOyAvLyBDb2xsYXBzZSB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyByYW5nZSBleGlzdHMsIGNyZWF0ZSBvbmUgY29sbGFwc2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTSE9SVENVVCBIQU5ETEVSOiBObyByYW5nZSBmb3VuZCBhZnRlciBmb2N1cy4gQ3JlYXRpbmcgbmV3IHJhbmdlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoaW5wdXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpOyAvLyBDb2xsYXBzZSB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgaW5zZXJ0ICdAJyBzaW5jZSB3ZSBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdAJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTsgLy8gQ2xlYXIgYW55IHNlbGVjdGlvbiBqdXN0IGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGF0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWZ0ZXIgdGhlIGluc2VydGVkICdAJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIoYXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihhdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTsgLy8gVXBkYXRlIHNlbGVjdGlvbiB0byB0aGUgbmV3IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKipORVNURUQgVElNRU9VVDoqKiBHaXZlIGJyb3dzZXIgdGltZSB0byByZW5kZXIgYmVmb3JlIGdldHRpbmcgcmFuZ2UgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogU2hvd2luZyBwb3B1cCBhZnRlciBmb2N1c2luZywgaW5zZXJ0aW5nICdAJywgYW5kIG5lc3RlZCB0aW1lb3V0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGdldCB0aGUgbW9zdCB1cC10by1kYXRlIHJhbmdlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbiAmJiBjdXJyZW50U2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmFuZ2UgPSBjdXJyZW50U2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gSW5zZXJ0IHRlbXBvcmFyeSBzcGFuIHRvIGdldCByZWxpYWJsZSBjb29yZHMgLS0tIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEFuY2hvcklkID0gJ2pwLWxsbS1zaG9ydGN1dC1wb3B1cC1hbmNob3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBTcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGVtcEFuY2hvcklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wU3BhbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5yZW1vdmUoKTsgLy8gQ2xlYW4gdXAgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4uaWQgPSB0ZW1wQW5jaG9ySWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5zdHlsZS53aWR0aCA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGFuLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3Bhbi50ZXh0Q29udGVudCA9ICdcXHUyMDBCJzsgLy8gWmVyby13aWR0aCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJhbmdlLmluc2VydE5vZGUodGVtcFNwYW4pOyAvLyBJbnNlcnQgYXQgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFuUmVjdCA9IHRlbXBTcGFuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4ucmVtb3ZlKCk7IC8vIFJlbW92ZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIEVuZCB0ZW1wb3Jhcnkgc3BhbiBsb2dpYyAtLS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuUmVjdC50b3AgPT09IDAgJiYgc3BhblJlY3QubGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTSE9SVENVVCBIQU5ETEVSOiBGYWlsZWQgdG8gZ2V0IHZhbGlkIGNvb3JkaW5hdGVzIGZyb20gdGVtcCBhbmNob3Igc3Bhbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU0hPUlRDVVQgSEFORExFUjogQW5jaG9yIGNvb3JkcyBmcm9tIHRlbXAgc3BhbjogVG9wPSR7c3BhblJlY3QudG9wfSwgTGVmdD0ke3NwYW5SZWN0LmxlZnR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KHsgeDogc3BhblJlY3QubGVmdCwgeTogc3BhblJlY3QudG9wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJbmRpY2F0b3IoJ0Jyb3dzaW5nIHJlZmVyZW5jZXMuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTSE9SVENVVCBIQU5ETEVSOiBDb3VsZCBub3QgZ2V0IHJhbmdlIGltbWVkaWF0ZWx5IGJlZm9yZSBzaG93aW5nIHBvcHVwLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApOyAvLyAwbXMgZGVsYXkgaXMgb2Z0ZW4gc3VmZmljaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTSE9SVENVVCBIQU5ETEVSOiBObyBzZWxlY3Rpb24gb2JqZWN0IGFmdGVyIGZvY3VzLCBjYW5ub3QgaW5zZXJ0ICdAJyBvciBzaG93IHBvcHVwIHJlbGlhYmx5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogQ291bGQgbm90IGZpbmQgaW5wdXQgZWxlbWVudCBhZnRlciB0aW1lb3V0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTsgLy8gT3V0ZXIgdGltZW91dCByZW1haW5zIDUwbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElucHV0IGZpZWxkIElTIGZvY3VzZWQuIExldCBkZWZhdWx0ICdAJyBpbnNlcnRpb24gaGFwcGVuLlxuICAgICAgICAgICAgICAgIC8vIFRoZSAnaW5wdXQnIGxpc3RlbmVyIGluIFVJTWFuYWdlciBzaG91bGQgaGFuZGxlIHRoZSBwb3B1cC5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNIT1JUQ1VUIEhBTkRMRVI6IElucHV0IGZpZWxkIElTIGFjdGl2ZSBlbGVtZW50LiBMZXR0aW5nIGRlZmF1bHQgJ0AnIGJlaGF2aW9yIHByb2NlZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBDdHJsK0wgKGluc2VydCBzZWxlY3Rpb24gb3IgY2VsbClcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9ICgwLCBub3RlYm9va19pbnRlZ3JhdGlvbl8xLmdldFNlbGVjdGVkVGV4dCkoKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGNlbGxDb250ZW50ID0gZ2V0Q3VycmVudENlbGxDb250ZW50KCk7IC8vIFdlIGRvbid0IG5lZWQgdGhlIGNvbnRlbnQgaXRzZWxmIGFueW1vcmVcbiAgICAgICAgICAgIGNvbnN0IGlzQ2VsbEZvY3VzZWQgPSAoMCwgbm90ZWJvb2tfaW50ZWdyYXRpb25fMS5pc0luTm90ZWJvb2tDZWxsQW5kRWRpdG9yRm9jdXNlZCkoKTsgLy8gSWYgdGhlIGN1cnNvciBpcyBpbiB0aGUgZWRpdG9yIG1vZGVcbiAgICAgICAgICAgIGNvbnN0IGlzQ2VsbFNlbGVjdGVkID0gKDAsIG5vdGVib29rX2ludGVncmF0aW9uXzEuaXNJbk5vdGVib29rQ2VsbCkoKTsgLy8gSWYgdGhlIGN1cnNvciBpcyBpbiB0aGUgbm90ZWJvb2sgY2VsbFxuICAgICAgICAgICAgY29uc3QgYWN0aXZlQ2VsbEluZGV4ID0gKF9jID0gKF9iID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFdpZGdldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY3RpdmVDZWxsSW5kZXg7IC8vIEdldCBpbmRleFxuICAgICAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFByaW9yaXR5IDE6IFNlbGVjdGVkIHRleHQgaW4gYW4gYWN0aXZlIGNlbGwgZWRpdG9yXG4gICAgICAgICAgICBpZiAoaXNDZWxsRm9jdXNlZCAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIG5ldyBJbnB1dEhhbmRsZXIgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcmVmZXJlbmNlIGFuZCBpbnNlcnQgaXRzIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgaW5wdXRIYW5kbGVyLmhhbmRsZUluc2VydENvZGVSZWZlcmVuY2VGcm9tU2hvcnRjdXQoc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHNob3dJbmRpY2F0b3IoJ0NvZGUgcmVmZXJlbmNlIGluc2VydGVkJyk7IC8vIFVwZGF0ZWQgaW5kaWNhdG9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBQcmlvcml0eSAyOiBBY3RpdmUgY2VsbCBzZWxlY3RlZCAobm90IG5lY2Vzc2FyaWx5IGVkaXRvciBmb2N1cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ2VsbFNlbGVjdGVkICYmIGFjdGl2ZUNlbGxJbmRleCAhPT0gdW5kZWZpbmVkICYmIGFjdGl2ZUNlbGxJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIG5ldyBJbnB1dEhhbmRsZXIgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcmVmZXJlbmNlIGFuZCBpbnNlcnQgaXRzIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgaW5wdXRIYW5kbGVyLmhhbmRsZUluc2VydENlbGxSZWZlcmVuY2VGcm9tU2hvcnRjdXQoKTtcbiAgICAgICAgICAgICAgICBzaG93SW5kaWNhdG9yKCdDZWxsIHJlZmVyZW5jZSBpbnNlcnRlZCcpOyAvLyBNZXNzYWdlIHJlbWFpbnMgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWQgY29udGV4dCBmb3IgdGhlIHNob3J0Y3V0XG4gICAgICAgICAgICAgICAgc2hvd0luZGljYXRvcignQ2Fubm90IGluc2VydCByZWZlcmVuY2U6IFNlbGVjdCBjb2RlIG9yIGFuIGFjdGl2ZSBjZWxsLicpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlOyAvLyBTdGlsbCBoYW5kbGVkIHRoZSBzaG9ydGN1dCwganVzdCBzaG93ZWQgYSB3YXJuaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZGViYXIgaXMgdmlzaWJsZSBhbmQgaW5wdXQgaXMgZm9jdXNlZCBvbmx5IGlmIGFuIGFjdGlvbiB3YXMgdGFrZW5cbiAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgc2hvd1dpZGdldCgpOyAvLyBVc2UgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBmb2N1c0lucHV0KCk7IC8vIFVzZSBjYWxsYmFja1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBkb2N1bWVudFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBfaGFuZGxlS2V5RG93bik7XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGdsb2JhbCBrZXlib2FyZCBzaG9ydGN1dCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2hvcnRjdXRzKCkge1xuICAgIGlmIChfaGFuZGxlS2V5RG93bikge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgX2hhbmRsZUtleURvd24pO1xuICAgICAgICBfaGFuZGxlS2V5RG93biA9IG51bGw7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdmVkIGtleWJvYXJkIHNob3J0Y3V0cy4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQXR0ZW1wdGVkIHRvIHJlbW92ZSBzaG9ydGN1dHMsIGJ1dCBub25lIHdlcmUgYWN0aXZlLicpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcGlDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBsYXVuY2hlcl8xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2xhdW5jaGVyXCIpO1xuY29uc3QgYXBwdXRpbHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9hcHB1dGlsc1wiKTtcbmNvbnN0IG5vdGVib29rXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbm90ZWJvb2tcIik7XG5jb25zdCBkb2NtYW5hZ2VyXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvZG9jbWFuYWdlclwiKTtcbmNvbnN0IHNpZGViYXJfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9zaWRlYmFyLXdpZGdldFwiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvZ2xvYmFsc1wiKTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kc1wiKTtcbmNvbnN0IGNlbGxfY29udGV4dF90cmFja2VyXzEgPSByZXF1aXJlKFwiLi9jZWxsLWNvbnRleHQtdHJhY2tlclwiKTtcbi8vIGltcG9ydCB7IEFwaUNsaWVudCB9IGZyb20gJy4vYXBpLWNsaWVudCc7XG4vLyBJbXBvcnQgdGhlIG1haW4gQ1NTIGZpbGVcbnJlcXVpcmUoXCIuLi9zdHlsZS9pbmRleC5jc3NcIik7XG4vLyBFeHBvcnQgQXBpQ2xpZW50IGZvciB1c2UgYnkgb3RoZXIgY29tcG9uZW50c1xudmFyIGFwaV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYXBpLWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwaUNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBpX2NsaWVudF8xLkFwaUNsaWVudDsgfSB9KTtcbi8qKlxuICogSW5pdGlhbGl6YXRpb24gZGF0YSBmb3IgdGhlIGp1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbiBleHRlbnNpb24uXG4gKi9cbmNvbnN0IHBsdWdpbiA9IHtcbiAgICBpZDogJ2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbjpwbHVnaW4nLFxuICAgIGF1dG9TdGFydDogdHJ1ZSxcbiAgICByZXF1aXJlczogW2xhdW5jaGVyXzEuSUxhdW5jaGVyLCBhcHB1dGlsc18xLklDb21tYW5kUGFsZXR0ZSwgbm90ZWJvb2tfMS5JTm90ZWJvb2tUcmFja2VyLCBkb2NtYW5hZ2VyXzEuSURvY3VtZW50TWFuYWdlcl0sXG4gICAgYWN0aXZhdGU6IChqdXB5dGVyQXBwLCBsYXVuY2hlciwgcGFsZXR0ZSwgdHJhY2tlciwgZG9jTWFuYWdlcikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnSnVweXRlckxhYiBleHRlbnNpb24ganVweXRlci1zaW1wbGUtZXh0ZW5zaW9uIGlzIGFjdGl2YXRlZCEnKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBnbG9iYWwgcmVmZXJlbmNlc1xuICAgICAgICAoMCwgZ2xvYmFsc18xLmluaXRHbG9iYWxzKShqdXB5dGVyQXBwLCB0cmFja2VyKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjZWxsIGNvbnRleHQgdHJhY2tlclxuICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIgPSBuZXcgY2VsbF9jb250ZXh0X3RyYWNrZXJfMS5DZWxsQ29udGV4dFRyYWNrZXIoanVweXRlckFwcCwgdHJhY2tlcik7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHNpZGViYXIgd2lkZ2V0XG4gICAgICAgIGNvbnN0IHNpZGViYXJXaWRnZXQgPSBuZXcgc2lkZWJhcl93aWRnZXRfMS5TaW1wbGVTaWRlYmFyV2lkZ2V0KGRvY01hbmFnZXIpO1xuICAgICAgICBqdXB5dGVyQXBwLnNoZWxsLmFkZChzaWRlYmFyV2lkZ2V0LCAnbGVmdCcsIHsgcmFuazogOTk5OSB9KTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgY29tbWFuZHNcbiAgICAgICAgKDAsIGNvbW1hbmRzXzEucmVnaXN0ZXJDb21tYW5kcykoanVweXRlckFwcCwgcGFsZXR0ZSwgbGF1bmNoZXIsIHNpZGViYXJXaWRnZXQpO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBwbHVnaW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlU2lkZWJhcldpZGdldCA9IHZvaWQgMDtcbmNvbnN0IHdpZGdldHNfMSA9IHJlcXVpcmUoXCJAbHVtaW5vL3dpZGdldHNcIik7XG5jb25zdCBpY29uc18xID0gcmVxdWlyZShcIi4vY29yZS9pY29uc1wiKTtcbmNvbnN0IGFwaV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYXBpLWNsaWVudFwiKTtcbmNvbnN0IHBvcHVwX21lbnVfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvcG9wdXAtbWVudS1tYW5hZ2VyXCIpO1xuY29uc3Qgc2hvcnRjdXRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvc2hvcnRjdXQtaGFuZGxlclwiKTtcbmNvbnN0IGxheW91dF9idWlsZGVyXzEgPSByZXF1aXJlKFwiLi91aS9sYXlvdXQtYnVpbGRlclwiKTtcbmNvbnN0IHNldHRpbmdzX21vZGFsXzEgPSByZXF1aXJlKFwiLi91aS9zZXR0aW5ncy1tb2RhbFwiKTtcbmNvbnN0IGNoYXRfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3N0YXRlL2NoYXQtc3RhdGVcIik7XG5jb25zdCBzZXR0aW5nc19zdGF0ZV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc2V0dGluZ3Mtc3RhdGVcIik7XG5jb25zdCBpbnB1dF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9pbnB1dC1oYW5kbGVyXCIpO1xuY29uc3QgbWVzc2FnZV9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9tZXNzYWdlLWhhbmRsZXJcIik7XG5jb25zdCBoaXN0b3J5X2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL2hpc3RvcnktaGFuZGxlclwiKTtcbmNvbnN0IHNldHRpbmdzX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL3NldHRpbmdzLWhhbmRsZXJcIik7XG5jb25zdCB1aV9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi91aS91aS1tYW5hZ2VyXCIpO1xuY29uc3QgdWlfY29tcG9uZW50c18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL3VpLWNvbXBvbmVudHNcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9jb3JlL2dsb2JhbHNcIik7XG5jb25zdCBub3RlX3N0YXRlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9ub3RlLXN0YXRlXCIpO1xuY29uc3Qgbm90ZV9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9ub3RlLWhhbmRsZXJcIik7XG4vLyAtLS0gSW1wb3J0IFV0aWxpdHkgRnVuY3Rpb25zIC0tLVxuY29uc3QgY2xpcGJvYXJkXzEgPSByZXF1aXJlKFwiLi91dGlscy9jbGlwYm9hcmRcIik7XG5jb25zdCBub3RlYm9va19pbnRlZ3JhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb25cIik7XG4vKipcbiAqIE1haW4gc2lkZWJhciB3aWRnZXQgZm9yIHRoZSBBSSBjaGF0IGludGVyZmFjZSAtIE5vdyBhY3RzIGFzIGFuIG9yY2hlc3RyYXRvci5cbiAqL1xuY2xhc3MgU2ltcGxlU2lkZWJhcldpZGdldCBleHRlbmRzIHdpZGdldHNfMS5XaWRnZXQge1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byByZXBsYWNlIGEgdGV4dCByYW5nZSB3aXRoIGEgbm9uLWVkaXRhYmxlIHdpZGdldCBzcGFuLlxuICAgICAqL1xuICAgIGNyZWF0ZVdpZGdldFNwYW4ocmFuZ2UsIHJlZlRleHQpIHtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gRXh0cmFjdCBhIGRpc3BsYXktZnJpZW5kbHkgdmVyc2lvbiAoZS5nLiwgZmlsZW5hbWUgZnJvbSBwYXRoKVxuICAgICAgICBsZXQgZGlzcGxheUxhYmVsID0gcmVmVGV4dDtcbiAgICAgICAgaWYgKHJlZlRleHQuc3RhcnRzV2l0aCgnQGZpbGUgJykgfHwgcmVmVGV4dC5zdGFydHNXaXRoKCdAZGlyICcpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHJlZlRleHQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gcGFydHNbMV0uc3BsaXQoL1tcXFxcL10vKTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TGFiZWwgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdIHx8IHBhcnRzWzFdOyAvLyBVc2UgbGFzdCBwYXJ0IG9mIHBhdGggb3IgZnVsbCBwYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmVGV4dC5zdGFydHNXaXRoKCdAQ2VsbCAnKSkge1xuICAgICAgICAgICAgZGlzcGxheUxhYmVsID0gcmVmVGV4dC5zdWJzdHJpbmcoMSk7IC8vIFJlbW92ZSBsZWFkaW5nICdAJ1xuICAgICAgICB9IC8vIEFkZCBtb3JlIGNvbmRpdGlvbnMgZm9yIG90aGVyIHR5cGVzIGlmIG5lZWRlZFxuICAgICAgICAvLyBDcmVhdGUgdGhlIHdpZGdldCBzcGFuXG4gICAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcmVmLXdpZGdldCc7IC8vIENsYXNzIGZvciBzdHlsaW5nXG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTsgLy8gTWFrZSBpdCBub24tZWRpdGFibGVcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVmLXRleHQnLCByZWZUZXh0KTsgLy8gU3RvcmUgb3JpZ2luYWwgdGV4dCBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gZGlzcGxheUxhYmVsOyAvLyBTZXQgdmlzaWJsZSB0ZXh0XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIHJhbmdlIGNvbnRlbnQgd2l0aCB0aGUgc3BhblxuICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKHNwYW4pO1xuICAgICAgICAvLyBNb3ZlIGN1cnNvciBhZnRlciB0aGUgaW5zZXJ0ZWQgc3BhblxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIG5ld1JhbmdlLnNldFN0YXJ0QWZ0ZXIoc3Bhbik7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRFbmRBZnRlcihzcGFuKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jTWFuYWdlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBQbGFjZWhvbGRlciBmb3IgaGFuZGxlciBtZXRob2RzIHVzZWQgaW4gVUlNYW5hZ2VyIGNhbGxiYWNrc1xuICAgICAgICB0aGlzLmhhbmRsZU5ld0NoYXQgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIE5ldyBDaGF0IGNsaWNrZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoYXQgPSB0aGlzLmNoYXRTdGF0ZS5jcmVhdGVOZXdDaGF0KCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmhpc3RvcnlIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9hZENoYXQobmV3Q2hhdC5pZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9nZ2xlSGlzdG9yeSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGUgVG9nZ2xlIEhpc3RvcnkgY2xpY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5SGFuZGxlci50b2dnbGVIaXN0b3J5VmlldygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvZ2dsZU5vdGVzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hhbmRsZSBUb2dnbGUgTm90ZXMgY2xpY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5ub3RlSGFuZGxlci50b2dnbGVOb3Rlc1ZpZXcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZW5kTWVzc2FnZSA9IChtZXNzYWdlLCBpc01hcmtkb3duID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIEdldCB0aGUgY3VycmVudCB0ZXh0IGZyb20gdGhlIGlucHV0IGZpZWxkIHZpYSBVSU1hbmFnZXIgb3IgTGF5b3V0RWxlbWVudHNcbiAgICAgICAgICAgIC8vIGNvbnN0IHRleHQgPSB0aGlzLmxheW91dEVsZW1lbnRzLmlucHV0RmllbGQudmFsdWU7IC8vIE5vIGxvbmdlciBuZWVkZWQsIHRleHQgaXMgcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UudHJpbSgpKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3Qgc2VuZCBlbXB0eSBtZXNzYWdlcyAoY2hlY2sgdGhlIHBhc3NlZCBtZXNzYWdlKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtXaWRnZXRdIGhhbmRsZVNlbmRNZXNzYWdlOiBUZXh0PScke21lc3NhZ2V9JywgTWFya2Rvd249JHtpc01hcmtkb3dufWApOyAvLyBEZWJ1ZyBsb2cgdXNpbmcgcGFzc2VkIG1lc3NhZ2VcbiAgICAgICAgICAgIC8vIDMuIENhbGwgdGhlIE1lc3NhZ2VIYW5kbGVyJ3Mgc2VuZCBtZXRob2Qgd2l0aCB0ZXh0IGFuZCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlci5oYW5kbGVTZW5kTWVzc2FnZShtZXNzYWdlLCBpc01hcmtkb3duKTsgLy8gUGFzcyB0aGUgcmVjZWl2ZWQgbWVzc2FnZSBhbmQgbWFya2Rvd24gc3RhdGVcbiAgICAgICAgICAgIC8vIE5PVEU6IElucHV0IGNsZWFyaW5nIGlzIG5vdyBoYW5kbGVkIGJ5IFVJTWFuYWdlciBhZnRlciB0aGlzIGNhbGxiYWNrIHJldHVybnMuXG4gICAgICAgICAgICAvLyBEbyBOT1QgY2xlYXIgaW5wdXQgaGVyZSBvciBpbiBNZXNzYWdlSGFuZGxlci5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTaG93U2V0dGluZ3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGUgU2hvdyBTZXR0aW5ncyBjbGlja2VkJyk7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzSGFuZGxlci5zaG93TW9kYWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTaG93UG9wdXBNZW51ID0gKGV2ZW50LCB0YXJnZXRCdXR0b24pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGUgU2hvdyBQb3B1cCBNZW51IGNsaWNrZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuc2hvd1BvcHVwTWVudSh7IHg6IHJlY3QubGVmdCwgeTogcmVjdC5ib3R0b20gKyA1IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVVwZGF0ZVRpdGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbmV3VGl0bGUgPSAoKF9hID0gdGhpcy5sYXlvdXRFbGVtZW50cy50aXRsZUlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpIHx8ICdDaGF0JztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGUgVXBkYXRlIFRpdGxlIGNhbGxlZDonLCBuZXdUaXRsZSk7XG4gICAgICAgICAgICB0aGlzLmNoYXRTdGF0ZS51cGRhdGVDdXJyZW50Q2hhdFRpdGxlKG5ld1RpdGxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICAgICAgdGhpcy5pZCA9ICdzaW1wbGUtc2lkZWJhcic7XG4gICAgICAgIHRoaXMudGl0bGUubGFiZWwgPSAnJztcbiAgICAgICAgdGhpcy50aXRsZS5jYXB0aW9uID0gJ0FJIENoYXQgSW50ZXJmYWNlJztcbiAgICAgICAgdGhpcy50aXRsZS5pY29uID0gaWNvbnNfMS5leHRlbnNpb25JY29uO1xuICAgICAgICB0aGlzLnRpdGxlLmNsb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnanAtbGxtLWV4dC1zaWRlYmFyJyk7XG4gICAgICAgIC8vIC0tLSAxLiBJbml0aWFsaXplIENvcmUgQ29tcG9uZW50cyAmIFN0YXRlIC0tLVxuICAgICAgICB0aGlzLnNldHRpbmdzU3RhdGUgPSBuZXcgc2V0dGluZ3Nfc3RhdGVfMS5TZXR0aW5nc1N0YXRlKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3NTdGF0ZS5nZXRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBhcGlfY2xpZW50XzEuQXBpQ2xpZW50KChpbml0aWFsU2V0dGluZ3MgPT09IG51bGwgfHwgaW5pdGlhbFNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsU2V0dGluZ3MuYXBpVXJsKSB8fCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmNoYXRTdGF0ZSA9IG5ldyBjaGF0X3N0YXRlXzEuQ2hhdFN0YXRlKCk7XG4gICAgICAgIHRoaXMubm90ZVN0YXRlID0gbmV3IG5vdGVfc3RhdGVfMS5Ob3RlU3RhdGUoKTtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyID0gbmV3IHBvcHVwX21lbnVfbWFuYWdlcl8xLlBvcHVwTWVudU1hbmFnZXIodGhpcy5kb2NNYW5hZ2VyLCB0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgIGluc2VydENvZGU6IChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0SGFuZGxlciB8fCAhZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE5vdGVib29rUGFuZWwgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROb3RlYm9va1BhbmVsIHx8ICFjdXJyZW50Tm90ZWJvb2tQYW5lbC5jb250ZXh0IHx8ICFjdXJyZW50Tm90ZWJvb2tQYW5lbC5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGdldCBub3RlYm9vayBjb250ZXh0IGZvciBjb2RlIHJlZmVyZW5jZSwgaW5zZXJ0aW5nIHJhdyBjb2RlIGFzIGZhbGxiYWNrLicpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcGVuZFRvSW5wdXQoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYXRoID0gY3VycmVudE5vdGVib29rUGFuZWwuY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTmFtZSA9ICgoX2IgPSBub3RlYm9va1BhdGguc3BsaXQoJy8nKS5wb3AoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNwbGl0KCcuJylbMF0pIHx8ICdub3RlYm9vayc7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBjdXJyZW50Tm90ZWJvb2tQYW5lbC5jb250ZW50LmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBnZXQgYWN0aXZlIGNlbGwgZm9yIGNvZGUgcmVmZXJlbmNlLCBpbnNlcnRpbmcgcmF3IGNvZGUgYXMgZmFsbGJhY2suJyk7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYXBwZW5kVG9JbnB1dChjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBjdXJyZW50Tm90ZWJvb2tQYW5lbC5jb250ZW50LmFjdGl2ZUNlbGxJbmRleDtcbiAgICAgICAgICAgICAgICBsZXQgbGluZU51bWJlciA9IDE7IC8vIERlZmF1bHQgbGluZSBudW1iZXJcbiAgICAgICAgICAgICAgICBsZXQgbGluZUVuZE51bWJlciA9IDE7IC8vIERlZmF1bHQgZW5kIGxpbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgLy8gLS0tIERFQlVHIExPRyAtLS0gXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FyZSB3ZSBjdXJyZW50bHkgaW4gYSBjb2RlIGNlbGw/Jyk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgY3VycmVudENlbGwgaXMgaW4gZWRpdG9yIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRDZWxsLmVkaXRvcik7XG4gICAgICAgICAgICAgICAgLy8gLS0tIEVORCBERUJVRyBMT0cgLS0tXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjdXJyZW50Q2VsbC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNtRWRpdG9yID0gZWRpdG9yLmVkaXRvcjsgLy8gQWNjZXNzIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlIChFZGl0b3JWaWV3KVxuICAgICAgICAgICAgICAgICAgICBpZiAoY21FZGl0b3IgJiYgY21FZGl0b3Iuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY21FZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciA9IHN0YXRlLmRvYy5saW5lQXQoc2VsZWN0aW9uLmZyb20pLm51bWJlcjsgLy8gMS1iYXNlZCBzdGFydCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUVuZE51bWJlciA9IHN0YXRlLmRvYy5saW5lQXQoc2VsZWN0aW9uLnRvKS5udW1iZXI7IC8vIDEtYmFzZWQgZW5kIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBjdXJzb3IgcG9zaXRpb24gaWYgbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyID0gY3Vyc29yLmxpbmUgKyAxOyAvLyAxLWJhc2VkIGxpbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVFbmROdW1iZXIgPSBsaW5lTnVtYmVyOyAvLyBTdGFydCBhbmQgZW5kIGFyZSB0aGUgc2FtZSBmb3IgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgaWYgY21FZGl0b3Igb3Igc3RhdGUgaXMgbm90IGF2YWlsYWJsZSAoc2hvdWxkIG5vdCBoYXBwZW4gb2Z0ZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBhY2Nlc3MgQ29kZU1pcnJvciBzdGF0ZSBmb3IgbGluZSBudW1iZXJzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciA9IGN1cnNvci5saW5lICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lRW5kTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgYWNjZXNzIGNlbGwgZWRpdG9yIGZvciBsaW5lIG51bWJlcnMuJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgZGVmYXVsdCBsaW5lIG51bWJlcnMgMSwgMSBpZiBlZGl0b3IgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLS0gREVCVUcgTE9HIC0tLSBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1NpbXBsZVNpZGViYXJXaWRnZXQuaW5zZXJ0Q29kZV0gRGV0ZXJtaW5lZCBsaW5lczogU3RhcnQ9JHtsaW5lTnVtYmVyfSwgRW5kPSR7bGluZUVuZE51bWJlcn1gKTtcbiAgICAgICAgICAgICAgICAvLyAtLS0gRU5EIERFQlVHIExPRyAtLS1cbiAgICAgICAgICAgICAgICAvLyBQYXNzIGJvdGggc3RhcnQgYW5kIGVuZCBsaW5lIG51bWJlcnNcbiAgICAgICAgICAgICAgICBjb25zdCByZWZJZCA9IHRoaXMuaW5wdXRIYW5kbGVyLmFkZENvZGVSZWZlcmVuY2UoY29kZSwgbm90ZWJvb2tOYW1lLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIGxpbmVFbmROdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYEBjb2RlWyR7cmVmSWR9XWA7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIuYXBwZW5kVG9JbnB1dChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zZXJ0Q2VsbDogKGNvbnRlbnQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KGBAY2VsbCAke2NvbnRlbnR9YCk7IH0sXG4gICAgICAgICAgICBoYW5kbGVJbnNlcnRGaWxlV2lkZ2V0OiAocGF0aCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbmRsZUluc2VydEZpbGVXaWRnZXQocGF0aCk7IH0sXG4gICAgICAgICAgICBoYW5kbGVJbnNlcnREaXJXaWRnZXQ6IChwYXRoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlSW5zZXJ0RGlyV2lkZ2V0KHBhdGgpOyB9LFxuICAgICAgICAgICAgZ2V0U2VsZWN0ZWRUZXh0OiBub3RlYm9va19pbnRlZ3JhdGlvbl8xLmdldFNlbGVjdGVkVGV4dCxcbiAgICAgICAgICAgIGdldEN1cnJlbnRDZWxsQ29udGVudDogbm90ZWJvb2tfaW50ZWdyYXRpb25fMS5nZXRDdXJyZW50Q2VsbENvbnRlbnQsXG4gICAgICAgICAgICBpbnNlcnRDZWxsQnlJbmRleDogKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlSW5zZXJ0Q2VsbFdpZGdldEZyb21Qb3B1cChpbmRleCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVE9ETzogaW5zZXJ0Q29sbGFwc2VkQ29kZVJlZiBzaG91bGQgbGF0ZXIgYmUgbWVyZ2VkIHdpdGggaW5zZXJ0Q29kZVxuICAgICAgICAgICAgLy8gYXMgd2Ugb25seSBleHBlY3Qgb25lIGtpbmQgb2YgYmVoYXZpb3IgZnJvbSB0aGUgaW5wdXQgaGFuZGxlci5cbiAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIHdpbGwgYWxzbyBpbnZvbHZlIHVpIGNoYW5nZXNcbiAgICAgICAgICAgIGluc2VydENvbGxhcHNlZENvZGVSZWY6IChjb2RlLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dEhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SGFuZGxlci5oYW5kbGVJbnNlcnRDb2RlV2lkZ2V0RnJvbVBvcHVwKGNvZGUsIG5vdGVib29rTmFtZSwgY2VsbEluZGV4LCBsaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLSAyLiBEZWZpbmUgQ2FsbGJhY2tzICh1c2VkIGJ5IGJ1aWxkTGF5b3V0IGFuZCBIYW5kbGVycykgLS0tXG4gICAgICAgIC8vIENhbGxiYWNrcyBmb3IgVUkgYWN0aW9ucyAocGFzc2VkIHRvIGJ1aWxkTGF5b3V0KVxuICAgICAgICBjb25zdCBjcmVhdGVOZXdDaGF0Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGF0ID0gdGhpcy5jaGF0U3RhdGUuY3JlYXRlTmV3Q2hhdCgpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5oaXN0b3J5SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvYWRDaGF0KG5ld0NoYXQuaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b2dnbGVIaXN0b3J5Q2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmhpc3RvcnlIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9nZ2xlSGlzdG9yeVZpZXcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9nZ2xlTm90ZXNDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm90ZUhhbmRsZXIudG9nZ2xlTm90ZXNWaWV3KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3dTZXR0aW5nc0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zZXR0aW5nc0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93TW9kYWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2hvd1BvcHVwTWVudUNhbGxiYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUoeyB4OiByZWN0LmxlZnQgKyA2MCwgeTogcmVjdC50b3AgLSAyMCB9KTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2VuZE1lc3NhZ2VWaWFCdXR0b25DYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMubGF5b3V0RWxlbWVudHMuaW5wdXRGaWVsZDtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleXByZXNzJywgeyBrZXk6ICdFbnRlcicsIGJ1YmJsZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvZ2dsZU1hcmtkb3duTW9kZUNhbGxiYWNrID0gKGlzTWFya2Rvd24pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TWFya2Rvd25Nb2RlKGlzTWFya2Rvd24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b2dnbGVFeHBhbmRJbnB1dENhbGxiYWNrID0gKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2dnbGVJbnB1dEV4cGFuc2lvbigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxsYmFja3MgZm9yIE1lc3NhZ2UgUmVuZGVyaW5nIChwYXNzZWQgdG8gTWVzc2FnZUhhbmRsZXIgLT4gVUlNYW5hZ2VyIC0+IHJlbmRlcmVycylcbiAgICAgICAgY29uc3QgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgc2hvd0NvcHlGZWVkYmFjazogKGJ1dHRvbiwgc3VjY2VzcyA9IHRydWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhUTUwgPSBidXR0b24uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBzdWNjZXNzID8gJ0NvcGllZCEnIDogJ0ZhaWxlZCEnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBvcmlnaW5hbEhUTUw7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZE1lc3NhZ2VUb0NlbGw6IG5vdGVib29rX2ludGVncmF0aW9uXzEuYWRkTWVzc2FnZVRvQ2VsbCxcbiAgICAgICAgICAgIGNvcHlUb0NsaXBib2FyZDogKHRleHQsIGZlZWRiYWNrQ2IpID0+IHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKCgpID0+IGZlZWRiYWNrQ2IgPT09IG51bGwgfHwgZmVlZGJhY2tDYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYigpKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSB0ZXh0OiAnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBmZWVkYmFja0NiID09PSBudWxsIHx8IGZlZWRiYWNrQ2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2IoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3B5SW1hZ2VUb0NsaXBib2FyZDogKGltYWdlVXJsLCBmZWVkYmFja0NiKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNsaXBib2FyZF8xLmNvcHlJbWFnZVRvQ2xpcGJvYXJkKShpbWFnZVVybCwgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2tDYiA9PT0gbnVsbCB8fCBmZWVkYmFja0NiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NiKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29weU1lc3NhZ2VUb0NsaXBib2FyZDogKHRleHQsIGZlZWRiYWNrQ2IpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgY2xpcGJvYXJkXzEuY29weU1lc3NhZ2VUb0NsaXBib2FyZCkodGV4dCwgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2tDYigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUNvbmZpcm1JbnRlcnJ1cHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5tZXNzYWdlSGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbmRsZVNlbmRBdXRvTWVzc2FnZSgnY29uZmlybWVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlUmVqZWN0SW50ZXJydXB0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubWVzc2FnZUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVTZW5kQXV0b01lc3NhZ2UoJ3JlamVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldHRpbmdzTW9kYWxDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBoYW5kbGVTYXZlOiAoKSA9PiB7IHZhciBfYTsgKF9hID0gdGhpcy5zZXR0aW5nc0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zYXZlU2V0dGluZ3MoKTsgfSxcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbDogKCkgPT4geyB2YXIgX2E7IChfYSA9IHRoaXMuc2V0dGluZ3NIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZU1vZGFsKCk7IH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGlzdG9yeUhhbmRsZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICB1cGRhdGVUaXRsZUlucHV0OiAodGl0bGUpID0+IHRoaXMudWlNYW5hZ2VyLnVwZGF0ZVRpdGxlSW5wdXQodGl0bGUpLFxuICAgICAgICAgICAgY2xlYXJNZXNzYWdlQ29udGFpbmVyOiAoKSA9PiB0aGlzLnVpTWFuYWdlci5jbGVhck1lc3NhZ2VDb250YWluZXIoKSxcbiAgICAgICAgICAgIGFkZFJlbmRlcmVkTWVzc2FnZTogKG1lc3NhZ2VFbGVtZW50KSA9PiB0aGlzLnVpTWFuYWdlci5hZGRDaGF0TWVzc2FnZUVsZW1lbnQobWVzc2FnZUVsZW1lbnQpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vdGVIYW5kbGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgdXBkYXRlVGl0bGVJbnB1dDogKHRpdGxlKSA9PiB0aGlzLnVpTWFuYWdlci51cGRhdGVUaXRsZUlucHV0KHRpdGxlKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbnB1dEhhbmRsZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBoYW5kbGVTZW5kTWVzc2FnZTogKG1lc3NhZ2UsIGlzTWFya2Rvd24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UsIGlzTWFya2Rvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWVzc2FnZUhhbmRsZXIgbm90IGluaXRpYWxpemVkIHdoZW4gdHJ5aW5nIHRvIHNlbmQgbWVzc2FnZSBmcm9tIElucHV0SGFuZGxlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93UG9wdXBNZW51OiAobGVmdCwgdG9wKSA9PiB0aGlzLnBvcHVwTWVudU1hbmFnZXIuc2hvd1BvcHVwTWVudSh7IHg6IGxlZnQsIHk6IHRvcCB9KSxcbiAgICAgICAgICAgIGhpZGVQb3B1cE1lbnU6ICgpID0+IHRoaXMucG9wdXBNZW51TWFuYWdlci5oaWRlUG9wdXBNZW51KCksXG4gICAgICAgICAgICB1cGRhdGVQbGFjZWhvbGRlcjogKGlzTWFya2Rvd24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgZGF0YXNldCBmb3IgZGF0YS1wbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLmlucHV0RmllbGQuZGF0YXNldC5wbGFjZWhvbGRlciA9IGlzTWFya2Rvd24gPyAnRW50ZXIgbWFya2Rvd24uLi4nIDogJ0FzayBhbnl0aGluZy4uLic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlSW5wdXRFeHBhbnNpb25VSTogKGlzRXhwYW5kZWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b24gPSB0aGlzLmxheW91dEVsZW1lbnRzLmV4cGFuZEJ1dHRvbjtcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50ICh0ZXh0IG9yIG9sZCBpY29uKVxuICAgICAgICAgICAgICAgIHdoaWxlIChidXR0b24uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlQ2hpbGQoYnV0dG9uLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGFwcHJvcHJpYXRlIGljb24gdXNpbmcgTGFiSWNvbi5yZXNvbHZlXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGlzRXhwYW5kZWRcbiAgICAgICAgICAgICAgICAgICAgPyB1aV9jb21wb25lbnRzXzEuTGFiSWNvbi5yZXNvbHZlKHsgaWNvbjogJ3VpLWNvbXBvbmVudHM6Y2FyZXQtdXAnIH0pXG4gICAgICAgICAgICAgICAgICAgIDogdWlfY29tcG9uZW50c18xLkxhYkljb24ucmVzb2x2ZSh7IGljb246ICd1aS1jb21wb25lbnRzOmNhcmV0LWRvd24nIH0pO1xuICAgICAgICAgICAgICAgIGljb24uZWxlbWVudCh7IGNvbnRhaW5lcjogYnV0dG9uLCB0YWc6ICdzcGFuJyB9KTsgLy8gQWRkIGljb24gdG8gYnV0dG9uXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRpdGxlIGZvciBhY2Nlc3NpYmlsaXR5XG4gICAgICAgICAgICAgICAgYnV0dG9uLnRpdGxlID0gaXNFeHBhbmRlZCA/ICdDb2xsYXBzZSBpbnB1dCcgOiAnRXhwYW5kIGlucHV0JztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb2RlUmVmTWFwOiAoKSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvZGVSZWZlcmVuY2VNYXAoKSkgfHwgbmV3IE1hcCgpOyB9LFxuICAgICAgICAgICAgcmVzZXRDb2RlUmVmTWFwOiAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXRDb2RlUmVmZXJlbmNlcygpOyB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3J0Y3V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgc2hvd0luZGljYXRvcjogKHRleHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy51aU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93SW5kaWNhdG9yKHRleHQpOyB9LFxuICAgICAgICAgICAgYXBwZW5kVG9JbnB1dDogKHRleHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KHRleHQpOyB9LFxuICAgICAgICAgICAgc2hvd1dpZGdldDogKCkgPT4geyBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgZm9jdXNJbnB1dDogKCkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5sYXlvdXRFbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0RmllbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb2N1cygpOyB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIC0tLSAzLiBCdWlsZCBVSSBMYXlvdXQgLS0tXG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMgPSAoMCwgbGF5b3V0X2J1aWxkZXJfMS5idWlsZExheW91dCkoe1xuICAgICAgICAgICAgb25OZXdDaGF0Q2xpY2s6IGNyZWF0ZU5ld0NoYXRDYWxsYmFjayxcbiAgICAgICAgICAgIG9uSGlzdG9yeVRvZ2dsZUNsaWNrOiB0b2dnbGVIaXN0b3J5Q2FsbGJhY2ssXG4gICAgICAgICAgICBvbk5vdGVzQ2xpY2s6IHRvZ2dsZU5vdGVzQ2FsbGJhY2ssXG4gICAgICAgICAgICBvblNldHRpbmdzQ2xpY2s6IHNob3dTZXR0aW5nc0NhbGxiYWNrLFxuICAgICAgICAgICAgb25UaXRsZUNoYW5nZTogdGhpcy5oYW5kbGVVcGRhdGVUaXRsZSxcbiAgICAgICAgICAgIG9uQXRCdXR0b25DbGljazogc2hvd1BvcHVwTWVudUNhbGxiYWNrLFxuICAgICAgICAgICAgb25TZW5kTWVzc2FnZUNsaWNrOiBzZW5kTWVzc2FnZVZpYUJ1dHRvbkNhbGxiYWNrLFxuICAgICAgICAgICAgb25NYXJrZG93blRvZ2dsZUNoYW5nZTogdG9nZ2xlTWFya2Rvd25Nb2RlQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbkV4cGFuZFRvZ2dsZUNsaWNrOiB0b2dnbGVFeHBhbmRJbnB1dENhbGxiYWNrLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyID0gKDAsIHNldHRpbmdzX21vZGFsXzEuY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQpKHNldHRpbmdzTW9kYWxDYWxsYmFja3MpO1xuICAgICAgICAvLyAtLS0gSW5pdGlhbGl6ZSBTdGF0ZSBNYW5hZ2VycyAtLS1cbiAgICAgICAgdGhpcy5jaGF0U3RhdGUgPSBuZXcgY2hhdF9zdGF0ZV8xLkNoYXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLnNldHRpbmdzU3RhdGUgPSBuZXcgc2V0dGluZ3Nfc3RhdGVfMS5TZXR0aW5nc1N0YXRlKCk7XG4gICAgICAgIHRoaXMubm90ZVN0YXRlID0gbmV3IG5vdGVfc3RhdGVfMS5Ob3RlU3RhdGUoKTtcbiAgICAgICAgLy8gLS0tIEluaXRpYWxpemUgQ29yZSBDb21wb25lbnRzIC0tLVxuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBhcGlfY2xpZW50XzEuQXBpQ2xpZW50KCk7XG4gICAgICAgIC8vIC0tLSBJbml0aWFsaXplIFVJIE1hbmFnZXIgKG5lZWRzIGRlcGVuZGVuY2llcykgLS0tXG4gICAgICAgIGNvbnN0IHVpTWFuYWdlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGhhbmRsZU5ld0NoYXQ6IHRoaXMuaGFuZGxlTmV3Q2hhdCxcbiAgICAgICAgICAgIGhhbmRsZVRvZ2dsZUhpc3Rvcnk6IHRoaXMuaGFuZGxlVG9nZ2xlSGlzdG9yeSxcbiAgICAgICAgICAgIGhhbmRsZVRvZ2dsZU5vdGVzOiB0aGlzLmhhbmRsZVRvZ2dsZU5vdGVzLFxuICAgICAgICAgICAgaGFuZGxlU2VuZE1lc3NhZ2U6IHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICBoYW5kbGVTaG93U2V0dGluZ3M6IHRoaXMuaGFuZGxlU2hvd1NldHRpbmdzLFxuICAgICAgICAgICAgaGFuZGxlU2hvd1BvcHVwTWVudTogdGhpcy5oYW5kbGVTaG93UG9wdXBNZW51LFxuICAgICAgICAgICAgaGFuZGxlVXBkYXRlVGl0bGU6IHRoaXMuaGFuZGxlVXBkYXRlVGl0bGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIgPSBuZXcgdWlfbWFuYWdlcl8xLlVJTWFuYWdlcih0aGlzLnBvcHVwTWVudU1hbmFnZXIsIHVpTWFuYWdlckNhbGxiYWNrcywgdGhpcy5sYXlvdXRFbGVtZW50cyk7XG4gICAgICAgIC8vIC0tLSA0LiBJbml0aWFsaXplIEhhbmRsZXJzICh1c2luZyBVSSBlbGVtZW50cyBhbmQgY29yZSBjb21wb25lbnRzKSAtLS1cbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBuZXcgaW5wdXRfaGFuZGxlcl8xLklucHV0SGFuZGxlcih0aGlzLmxheW91dEVsZW1lbnRzLmlucHV0RmllbGQsIGlucHV0SGFuZGxlckNhbGxiYWNrcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBuZXcgbWVzc2FnZV9oYW5kbGVyXzEuTWVzc2FnZUhhbmRsZXIodGhpcy5hcGlDbGllbnQsIHRoaXMuY2hhdFN0YXRlLCB0aGlzLnVpTWFuYWdlciwgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzLCB0aGlzLmlucHV0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZXIgPSBuZXcgaGlzdG9yeV9oYW5kbGVyXzEuSGlzdG9yeUhhbmRsZXIodGhpcy5jaGF0U3RhdGUsIHRoaXMudWlNYW5hZ2VyLCBoaXN0b3J5SGFuZGxlckNhbGxiYWNrcywgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgdGhpcy5ub3RlSGFuZGxlciA9IG5ldyBub3RlX2hhbmRsZXJfMS5Ob3RlSGFuZGxlcih0aGlzLm5vdGVTdGF0ZSwgdGhpcy51aU1hbmFnZXIsIG5vdGVIYW5kbGVyQ2FsbGJhY2tzLCB0aGlzLm5vZGUpO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBsYXlvdXQncyBub3RlcyBjb250YWluZXIgd2l0aCB0aGUgb25lIGZyb20gTm90ZUhhbmRsZXJcbiAgICAgICAgY29uc3Qgbm90ZUNvbnRhaW5lciA9IHRoaXMubm90ZUhhbmRsZXIuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIGNvbnN0IGxheW91dE5vdGVDb250YWluZXIgPSB0aGlzLmxheW91dEVsZW1lbnRzLm5vdGVzQ29udGFpbmVyO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBsYXlvdXROb3RlQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobm90ZUNvbnRhaW5lciwgbGF5b3V0Tm90ZUNvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlZmVyZW5jZSBpbiBsYXlvdXRFbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5ub3Rlc0NvbnRhaW5lciA9IG5vdGVDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR0aW5nc0hhbmRsZXIgPSBuZXcgc2V0dGluZ3NfaGFuZGxlcl8xLlNldHRpbmdzSGFuZGxlcih0aGlzLnNldHRpbmdzU3RhdGUsIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciwgdGhpcy51aU1hbmFnZXIpO1xuICAgICAgICAvLyAtLS0gNS4gRmluYWwgU2V0dXAgKEF0dGFjaCBldmVudCBsaXN0ZW5lcnMsIGNvbm5lY3Qgc2lnbmFscywgZXRjLikgLS0tXG4gICAgICAgIGNvbnN0IGluaXRpYWxDaGF0SWQgPSB0aGlzLmNoYXRTdGF0ZS5nZXRDdXJyZW50Q2hhdElkKCk7XG4gICAgICAgIGlmIChpbml0aWFsQ2hhdElkKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlIYW5kbGVyLmxvYWRDaGF0KGluaXRpYWxDaGF0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHRoaXMuY2hhdFN0YXRlLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZXIubG9hZENoYXQobmV3Q2hhdC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dXAgZ2xvYmFsIGtleWJvYXJkIHNob3J0Y3V0cyB3aXRoIHRoZSBVSU1hbmFnZXIgZm9yIHByb3BlciBAIGtleSBoYW5kbGluZ1xuICAgICAgICAoMCwgc2hvcnRjdXRfaGFuZGxlcl8xLnNldHVwU2hvcnRjdXRzKSh0aGlzLmlucHV0SGFuZGxlciwgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLCBzaG9ydGN1dENhbGxiYWNrcyk7XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxheW91dEVsZW1lbnRzLm1haW5FbGVtZW50KTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHNob3J0Y3V0X2hhbmRsZXJfMS5yZW1vdmVTaG9ydGN1dHMpKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnBvcHVwTWVudU1hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59IC8vIEVuZCBvZiBTaW1wbGVTaWRlYmFyV2lkZ2V0IGNsYXNzXG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSBTaW1wbGVTaWRlYmFyV2lkZ2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBvZiBjaGF0IGhpc3RvcnkgYW5kIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gKi9cbmNsYXNzIENoYXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBudWxsO1xuICAgICAgICAvLyBQb3RlbnRpYWw6IExvYWQgaW5pdGlhbCBzdGF0ZSBmcm9tIHN0b3JhZ2UgaWYgcGVyc2lzdGVuY2UgaXMgYWRkZWQgbGF0ZXJcbiAgICAgICAgaWYgKHRoaXMuY2hhdEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU5ld0NoYXQoJ1dlbGNvbWUgQ2hhdCcpOyAvLyBDcmVhdGUgYW4gaW5pdGlhbCBjaGF0IGlmIG5vbmUgZXhpc3RzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSAoKF9hID0gdGhpcy5jaGF0SGlzdG9yeVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSB8fCBudWxsOyAvLyBTZXQgY3VycmVudCBjaGF0IHRvIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvbiBhbmQgc2V0cyBpdCBhcyB0aGUgY3VycmVudCBjaGF0LlxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFRoZSBpbml0aWFsIHRpdGxlIGZvciB0aGUgbmV3IGNoYXQuXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgY2hhdCBpdGVtLlxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQodGl0bGUgPSAnTmV3IENoYXQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXRJZCA9IGBjaGF0LSR7KDAsIHV1aWRfMS52NCkoKX1gOyAvLyBVc2UgVVVJRCBmb3IgYmV0dGVyIHVuaXF1ZW5lc3NcbiAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHtcbiAgICAgICAgICAgIGlkOiBjaGF0SWQsXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICAvLyBPcHRpb25hbDogQWRkIHRpbWVzdGFtcCBvciBvdGhlciBtZXRhZGF0YSBpZiBuZWVkZWQgbGF0ZXJcbiAgICAgICAgICAgIC8vIGNyZWF0ZWRBdDogRGF0ZTsgXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhdElkID0gY2hhdElkO1xuICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRlZCBuZXcgY2hhdDonLCBuZXdDaGF0KTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgY2hhdCBJRC5cbiAgICAgKiBAcGFyYW0gY2hhdElkIC0gVGhlIElEIG9mIHRoZSBjaGF0IHRvIHNldCBhcyBjdXJyZW50LlxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDaGF0SWQoY2hhdElkKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXRIaXN0b3J5LnNvbWUoY2hhdCA9PiBjaGF0LmlkID09PSBjaGF0SWQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENoYXQgSUQgJHtjaGF0SWR9IG5vdCBmb3VuZCBpbiBoaXN0b3J5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIElEIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgY2hhdCBJRCBvciBudWxsIGlmIG5vbmUgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDaGF0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHNwZWNpZmljIGNoYXQgYnkgaXRzIElELlxuICAgICAqIEBwYXJhbSBjaGF0SWQgLSBUaGUgSUQgb2YgdGhlIGNoYXQgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMgVGhlIGNoYXQgaXRlbSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldENoYXRCeUlkKGNoYXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGNoYXQgPT4gY2hhdC5pZCA9PT0gY2hhdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQgaXRlbS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBjaGF0IGl0ZW0gb3IgdW5kZWZpbmVkIGlmIG5vIGNoYXQgaXMgYWN0aXZlIG9yIGZvdW5kLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0KCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudENoYXRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGF0QnlJZCh0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBjaGF0LlxuICAgICAqIEBwYXJhbSBuZXdUaXRsZSAtIFRoZSBuZXcgdGl0bGUgZm9yIHRoZSBjaGF0LlxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUobmV3VGl0bGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXQgPSB0aGlzLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgY3VycmVudENoYXQudGl0bGUgPSBuZXdUaXRsZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIHRpdGxlIGZvciBjaGF0ICR7dGhpcy5jdXJyZW50Q2hhdElkfSB0byBcIiR7bmV3VGl0bGV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHVwZGF0ZSB0aXRsZTogTm8gY3VycmVudCBjaGF0IHNlbGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvYmplY3QgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2VUb0N1cnJlbnRDaGF0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXQgPSB0aGlzLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgY3VycmVudENoYXQubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGFkZCBtZXNzYWdlOiBObyBjdXJyZW50IGNoYXQgc2VsZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjaGF0LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG1lc3NhZ2VzIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vIGNoYXQgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGF0ID0gdGhpcy5nZXRDdXJyZW50Q2hhdCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudENoYXQgPyBjdXJyZW50Q2hhdC5tZXNzYWdlcyA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbnRpcmUgY2hhdCBoaXN0b3J5LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBjaGF0IGhpc3RvcnkgaXRlbXMuXG4gICAgICovXG4gICAgZ2V0Q2hhdEhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5jaGF0SGlzdG9yeV07IC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBkaXJlY3QgbW9kaWZpY2F0aW9uXG4gICAgfVxufVxuZXhwb3J0cy5DaGF0U3RhdGUgPSBDaGF0U3RhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90ZVN0YXRlID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIG9mIG5vdGVzIGFuZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vdGUuXG4gKi9cbmNsYXNzIE5vdGVTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubm90ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm90ZUlkID0gbnVsbDtcbiAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgbG9hZCBub3RlcyBmcm9tIHBlcnNpc3RlbnQgc3RvcmFnZSBoZXJlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbm90ZS5cbiAgICAgKiBAcGFyYW0gdGl0bGUgLSBUaGUgdGl0bGUgZm9yIHRoZSBuZXcgbm90ZS5cbiAgICAgKiBAcGFyYW0gY29udGVudCAtIFRoZSBjb250ZW50IGZvciB0aGUgbmV3IG5vdGUuXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgbm90ZS5cbiAgICAgKi9cbiAgICBjcmVhdGVOZXdOb3RlKHRpdGxlLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbmV3Tm90ZSA9IHtcbiAgICAgICAgICAgIGlkOiAoMCwgdXVpZF8xLnY0KSgpLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgY3JlYXRlZEF0OiB0aW1lc3RhbXAsXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IHRpbWVzdGFtcFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vdGVzLnB1c2gobmV3Tm90ZSk7XG4gICAgICAgIHRoaXMuY3VycmVudE5vdGVJZCA9IG5ld05vdGUuaWQ7XG4gICAgICAgIHJldHVybiBuZXdOb3RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm90ZSBJRC5cbiAgICAgKiBAcGFyYW0gbm90ZUlkIC0gVGhlIElEIG9mIHRoZSBub3RlIHRvIHNldCBhcyBjdXJyZW50LlxuICAgICAqL1xuICAgIHNldEN1cnJlbnROb3RlSWQobm90ZUlkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE5vdGVJZCA9IG5vdGVJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgSUQgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub3RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IG5vdGUgSUQgb3IgbnVsbCBpZiBub25lIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnROb3RlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnROb3RlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHNwZWNpZmljIG5vdGUgYnkgaXRzIElELlxuICAgICAqIEBwYXJhbSBub3RlSWQgLSBUaGUgSUQgb2YgdGhlIG5vdGUgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMgVGhlIG5vdGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXROb3RlQnlJZChub3RlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90ZXMuZmluZChub3RlID0+IG5vdGUuaWQgPT09IG5vdGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vdGUuXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgbm90ZSBvciB1bmRlZmluZWQgaWYgbm8gbm90ZSBpcyBzZWxlY3RlZCBvciBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Tm90ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnROb3RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm90ZUJ5SWQodGhpcy5jdXJyZW50Tm90ZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIG5vdGUncyB0aXRsZSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gbm90ZUlkIC0gVGhlIElEIG9mIHRoZSBub3RlIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gdGl0bGUgLSBUaGUgbmV3IHRpdGxlIGZvciB0aGUgbm90ZS5cbiAgICAgKiBAcGFyYW0gY29udGVudCAtIFRoZSBuZXcgY29udGVudCBmb3IgdGhlIG5vdGUuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgbm90ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIHVwZGF0ZU5vdGUobm90ZUlkLCB0aXRsZSwgY29udGVudCkge1xuICAgICAgICBjb25zdCBub3RlSW5kZXggPSB0aGlzLm5vdGVzLmZpbmRJbmRleChub3RlID0+IG5vdGUuaWQgPT09IG5vdGVJZCk7XG4gICAgICAgIGlmIChub3RlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90ZXNbbm90ZUluZGV4XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ub3Rlc1tub3RlSW5kZXhdKSwgeyB0aXRsZSxcbiAgICAgICAgICAgIGNvbnRlbnQsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3Rlc1tub3RlSW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbm90ZSBieSBpdHMgSUQuXG4gICAgICogQHBhcmFtIG5vdGVJZCAtIFRoZSBJRCBvZiB0aGUgbm90ZSB0byBkZWxldGUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm90ZSB3YXMgZm91bmQgYW5kIGRlbGV0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBkZWxldGVOb3RlKG5vdGVJZCkge1xuICAgICAgICBjb25zdCBpbml0aWFsTGVuZ3RoID0gdGhpcy5ub3Rlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubm90ZXMgPSB0aGlzLm5vdGVzLmZpbHRlcihub3RlID0+IG5vdGUuaWQgIT09IG5vdGVJZCk7XG4gICAgICAgIGlmICh0aGlzLm5vdGVzLmxlbmd0aCA8IGluaXRpYWxMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxldGVkIG5vdGUgd2FzIHRoZSBjdXJyZW50IG9uZSwgcmVzZXQgY3VycmVudCBvciBzZXQgdG8gdGhlIGZpcnN0IG5vdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROb3RlSWQgPT09IG5vdGVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVJZCA9IHRoaXMubm90ZXMubGVuZ3RoID4gMCA/IHRoaXMubm90ZXNbMF0uaWQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBub3Rlcy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgbm90ZXMuXG4gICAgICovXG4gICAgZ2V0QWxsTm90ZXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5ub3Rlc107IC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBkaXJlY3QgbXV0YXRpb25cbiAgICB9XG59XG5leHBvcnRzLk5vdGVTdGF0ZSA9IE5vdGVTdGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXR0aW5nc1N0YXRlID0gdm9pZCAwO1xuY29uc3QgU0VUVElOR1NfU1RPUkFHRV9LRVkgPSAnanAtbGxtLWV4dC1zZXR0aW5ncyc7XG4vKipcbiAqIE1hbmFnZXMgbG9hZGluZyBhbmQgc2F2aW5nIGFwcGxpY2F0aW9uIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZS5cbiAqL1xuY2xhc3MgU2V0dGluZ3NTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNldHRpbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2V0dGluZ3MgPSB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIHNldHRpbmdzIG9yIG51bGwgaWYgbm9uZSBhcmUgc2F2ZWQgb3IgYW4gZXJyb3Igb2NjdXJzLlxuICAgICAqL1xuICAgIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRTZXR0aW5ncyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNFVFRJTkdTX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgaWYgKHNhdmVkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBKU09OLnBhcnNlKHNhdmVkU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gKGNhbiBiZSBleHBhbmRlZClcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBzZXR0aW5nczonLCB0aGlzLmN1cnJlbnRTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXR0aW5ncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNhdmVkIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTRVRUSU5HU19TVE9SQUdFX0tFWSk7IC8vIENsZWFyIGNvcnJ1cHRlZCBkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ05vIHZhbGlkIHNldHRpbmdzIGZvdW5kIGluIGxvY2FsU3RvcmFnZS4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2UuXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIG9iamVjdCB0byBzYXZlLlxuICAgICAqL1xuICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VUVElOR1NfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTsgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQ6JywgdGhpcy5jdXJyZW50U2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBOb3RpZnkgdXNlciBvZiBzYXZlIGZhaWx1cmVcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgbG9hZGVkIHNldHRpbmdzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldHRpbmdzIG9iamVjdCBvciBudWxsIGlmIG5vdCBsb2FkZWQuXG4gICAgICovXG4gICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXR0aW5ncyA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY3VycmVudFNldHRpbmdzKSA6IG51bGw7IC8vIFJldHVybiBhIGNvcHlcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHNwZWNpZmljIHNldHRpbmcgdmFsdWUuXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIHNldHRpbmcgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgZ2V0U2V0dGluZyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNldHRpbmdzID8gdGhpcy5jdXJyZW50U2V0dGluZ3Nba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlNldHRpbmdzU3RhdGUgPSBTZXR0aW5nc1N0YXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURpdiA9IGNyZWF0ZURpdjtcbmV4cG9ydHMuY3JlYXRlQnV0dG9uID0gY3JlYXRlQnV0dG9uO1xuZXhwb3J0cy5jcmVhdGVTcGFuID0gY3JlYXRlU3BhbjtcbmV4cG9ydHMuY3JlYXRlVGV4dEFyZWEgPSBjcmVhdGVUZXh0QXJlYTtcbmV4cG9ydHMuY3JlYXRlSW5wdXRFbGVtZW50ID0gY3JlYXRlSW5wdXRFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVJbWFnZUVsZW1lbnQgPSBjcmVhdGVJbWFnZUVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZUFuY2hvckVsZW1lbnQgPSBjcmVhdGVBbmNob3JFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVMYWJlbEVsZW1lbnQgPSBjcmVhdGVMYWJlbEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZUZvcm1FbGVtZW50ID0gY3JlYXRlRm9ybUVsZW1lbnQ7XG4vKipcbiAqIEdlbmVyaWMgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIEhUTUxFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB0YWdOYW1lIC0gVGhlIEhUTUwgdGFnIG5hbWUgKGUuZy4sICdkaXYnLCAnYnV0dG9uJykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBlbGVtZW50LlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgSFRNTEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgZWxlbWVudC5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgICAgY29uc3QgY2xhc3Nlc1RvQWRkID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmNsYXNzZXMpXG4gICAgICAgICAgICA/IG9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICAgICAgOiBvcHRpb25zLmNsYXNzZXMuc3BsaXQoJyAnKS5maWx0ZXIoYyA9PiBjKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbnMudGV4dDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sOyAvLyBCZSBjYXV0aW91cyB3aXRoIEhUTUwgaW5qZWN0aW9uXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnN0eWxlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gb3B0aW9ucy5zdHlsZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICAgIG9wdGlvbnMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKiogQ3JlYXRlcyBhIDxkaXY+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVEaXYob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIG9wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYSA8YnV0dG9uPiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdidXR0b24nLCBvcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGEgPHNwYW4+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVTcGFuKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzcGFuJywgb3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhIDx0ZXh0YXJlYT4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHRBcmVhKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScsIG9wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYW4gPGlucHV0PiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRFbGVtZW50KG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBFbnN1cmUgdHlwZSBpcyBzZXQgaWYgcHJvdmlkZWQgaW4gYXR0cmlidXRlcywgb3RoZXJ3aXNlIGRlZmF1bHQgb3IgbGVhdmUgdW5zZXRcbiAgICBpZiAoKF9hID0gb3B0aW9ucy5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkge1xuICAgICAgICAvLyBUeXBlIGlzIGFscmVhZHkgc2V0IGluIGF0dHJpYnV0ZXMsIGRvIG5vdGhpbmcgZXh0cmFcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB7IHR5cGU6ICd0ZXh0JyB9OyAvLyBEZWZhdWx0IHRvIHRleHQgaWYgbm8gYXR0cmlidXRlcyBzcGVjaWZpZWRcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcy50eXBlKSB7XG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcy50eXBlID0gJ3RleHQnOyAvLyBEZWZhdWx0IHRvIHRleHQgaWYgdHlwZSBpcyBub3QgaW4gYXR0cmlidXRlc1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBvcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGFuIDxpbWc+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVJbWFnZUVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGltZ09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpbWdPcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYXR0cmlidXRlcyksIHsgc3JjOiBvcHRpb25zLnNyYyB9KTtcbiAgICBpZiAob3B0aW9ucy5hbHQpIHtcbiAgICAgICAgaW1nT3B0aW9ucy5hdHRyaWJ1dGVzLmFsdCA9IG9wdGlvbnMuYWx0O1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnaW1nJywgaW1nT3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhbiA8YT4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvckVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGFuY2hvck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBhbmNob3JPcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYXR0cmlidXRlcyksIHsgaHJlZjogb3B0aW9ucy5ocmVmIH0pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdhJywgYW5jaG9yT3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhIDxsYWJlbD4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxhYmVsRWxlbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaHRtbEZvcikge1xuICAgICAgICBsYWJlbE9wdGlvbnMuYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5hdHRyaWJ1dGVzKSwgeyBmb3I6IG9wdGlvbnMuaHRtbEZvciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2xhYmVsJywgbGFiZWxPcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGEgPGZvcm0+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JtRWxlbWVudChvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZm9ybScsIG9wdGlvbnMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkTGF5b3V0ID0gYnVpbGRMYXlvdXQ7XG5jb25zdCBkb21fZWxlbWVudHNfMSA9IHJlcXVpcmUoXCIuL2RvbS1lbGVtZW50c1wiKTtcbi8qKlxuICogQnVpbGRzIHRoZSBtYWluIEhUTUwgc3RydWN0dXJlIGZvciB0aGUgc2lkZWJhciB3aWRnZXQuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrcyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdmFyaW91cyBVSSBpbnRlcmFjdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFpbiB3aWRnZXQgSFRNTEVsZW1lbnQgYW5kIHJlZmVyZW5jZXMgdG8ga2V5IGludGVyYWN0aXZlIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBidWlsZExheW91dChjYWxsYmFja3MgPSB7fSkge1xuICAgIC8vIC0tLSBNYWluIENvbnRlbnQgV3JhcHBlciAtLS1cbiAgICBjb25zdCBtYWluRWxlbWVudCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ2pwLWxsbS1leHQtY29udGVudC13cmFwcGVyJ1xuICAgIH0pO1xuICAgIC8vIC0tLSBUaXRsZSBCYXIgLS0tXG4gICAgY29uc3QgdGl0bGVDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LXRpdGxlLWNvbnRhaW5lcicgfSk7XG4gICAgY29uc3QgdGl0bGVJbnB1dCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVJbnB1dEVsZW1lbnQpKHtcbiAgICAgICAgaWQ6ICdjaGF0LXRpdGxlLWlucHV0JyxcbiAgICAgICAgY2xhc3NlczogJ2NoYXQtdGl0bGUtaW5wdXQnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IHR5cGU6ICd0ZXh0JywgcGxhY2Vob2xkZXI6ICdDaGF0IHRpdGxlJywgdmFsdWU6ICdOZXcgQ2hhdCcgfVxuICAgIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25UaXRsZUNoYW5nZSkge1xuICAgICAgICB0aXRsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IGNhbGxiYWNrcy5vblRpdGxlQ2hhbmdlKHRpdGxlSW5wdXQudmFsdWUpKTtcbiAgICB9XG4gICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGVJbnB1dCk7XG4gICAgLy8gLS0tIE1lc3NhZ2UgJiBIaXN0b3J5IENvbnRhaW5lcnMgLS0tXG4gICAgY29uc3QgbWVzc2FnZUNvbnRhaW5lciA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtbWVzc2FnZS1jb250YWluZXInIH0pO1xuICAgIGNvbnN0IGhpc3RvcnlDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWhpc3RvcnktY29udGFpbmVyJyxcbiAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gLy8gSGlkZGVuIGJ5IGRlZmF1bHRcbiAgICB9KTtcbiAgICAvLyAtLS0gTm90ZXMgQ29udGFpbmVyIC0tLVxuICAgIGNvbnN0IG5vdGVzQ29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC1ub3Rlcy1jb250YWluZXInLCBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSB9KTtcbiAgICAvLyAtLS0gQm90dG9tIEJhciBBcmVhIC0tLVxuICAgIGNvbnN0IGJvdHRvbUJhckNvbnRhaW5lciA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtYm90dG9tLWJhci1jb250YWluZXInIH0pO1xuICAgIC8vIFJvdyAxOiBDb250cm9scyAoTWFya2Rvd24gVG9nZ2xlLCBALCBFeHBhbmQsIFNldHRpbmdzKVxuICAgIGNvbnN0IGNvbnRyb2xzUm93ID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWNvbnRyb2xzLXJvdycgfSk7XG4gICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWNvbnRyb2xzLWNvbnRhaW5lcicgfSk7XG4gICAgLy8gTWFya2Rvd24gVG9nZ2xlXG4gICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC10b2dnbGUtY29udGFpbmVyJyB9KTtcbiAgICBjb25zdCBtYXJrZG93blRvZ2dsZUJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVJbnB1dEVsZW1lbnQpKHtcbiAgICAgICAgaWQ6ICdtYXJrZG93bi10b2dnbGUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IHR5cGU6ICdjaGVja2JveCcgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRvZ2dsZUxhYmVsID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUxhYmVsRWxlbWVudCkoe1xuICAgICAgICB0ZXh0OiAnTWFya2Rvd24gbW9kZScsXG4gICAgICAgIGh0bWxGb3I6ICdtYXJrZG93bi10b2dnbGUnXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbk1hcmtkb3duVG9nZ2xlQ2hhbmdlKSB7XG4gICAgICAgIG1hcmtkb3duVG9nZ2xlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5vbk1hcmtkb3duVG9nZ2xlQ2hhbmdlKG1hcmtkb3duVG9nZ2xlQnV0dG9uLmNoZWNrZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9nZ2xlQ29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmtkb3duVG9nZ2xlQnV0dG9uKTtcbiAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlTGFiZWwpO1xuICAgIC8vIEFjdGlvbiBCdXR0b25zIChALCBFeHBhbmQsIFNldHRpbmdzKVxuICAgIGNvbnN0IGFjdGlvbkJ1dHRvbnNDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWFjdGlvbi1idXR0b25zLWNvbnRhaW5lcicgfSk7XG4gICAgY29uc3QgYXRCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7IHRleHQ6ICdAJywgYXR0cmlidXRlczogeyB0aXRsZTogJ0Jyb3dzZSBjZWxscywgY29kZSwgZmlsZXMsIGFuZCBtb3JlJyB9LCBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbicgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbkF0QnV0dG9uQ2xpY2spIHtcbiAgICAgICAgYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFja3Mub25BdEJ1dHRvbkNsaWNrKTtcbiAgICB9XG4gICAgY29uc3QgZXhwYW5kQnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoeyB0ZXh0OiAn4qSiJywgYXR0cmlidXRlczogeyB0aXRsZTogJ0V4cGFuZCBpbnB1dCcgfSwgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25FeHBhbmRUb2dnbGVDbGljaykge1xuICAgICAgICBleHBhbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBjYWxsYmFja3Mub25FeHBhbmRUb2dnbGVDbGljayhleHBhbmRCdXR0b24pKTtcbiAgICB9XG4gICAgY29uc3Qgc2V0dGluZ3NCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7IHRleHQ6ICfimpnvuI8nLCBhdHRyaWJ1dGVzOiB7IHRpdGxlOiAnU2V0dGluZ3MnIH0sIGNsYXNzZXM6ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJyB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uU2V0dGluZ3NDbGljaykge1xuICAgICAgICBzZXR0aW5nc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrcy5vblNldHRpbmdzQ2xpY2spO1xuICAgIH1cbiAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGF0QnV0dG9uKTtcbiAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGV4cGFuZEJ1dHRvbik7XG4gICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZXR0aW5nc0J1dHRvbik7XG4gICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlQ29udGFpbmVyKTtcbiAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b25zQ29udGFpbmVyKTtcbiAgICBjb250cm9sc1Jvdy5hcHBlbmRDaGlsZChjb250cm9sc0NvbnRhaW5lcik7XG4gICAgLy8gUm93IDI6IElucHV0IEZpZWxkXG4gICAgY29uc3QgaW5wdXRSb3cgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtaW5wdXQtcm93JyB9KTtcbiAgICBjb25zdCBpbnB1dEZpZWxkID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoe1xuICAgICAgICBjbGFzc2VzOiAnanAtbGxtLWV4dC1pbnB1dC1maWVsZCcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogJ3RydWUnLFxuICAgICAgICAgICAgcm9sZTogJ3RleHRib3gnLFxuICAgICAgICAgICAgJ2FyaWEtbXVsdGlsaW5lJzogJ3RydWUnLFxuICAgICAgICAgICAgJ2RhdGEtcGxhY2Vob2xkZXInOiAnQXNrIG1lIGFueXRoaW5nLi4uJ1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogeyBtaW5IZWlnaHQ6ICcyMHB4Jywgb3ZlcmZsb3dZOiAnaGlkZGVuJyB9XG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbklucHV0RmllbGRLZXlQcmVzcykge1xuICAgICAgICBpbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgY2FsbGJhY2tzLm9uSW5wdXRGaWVsZEtleVByZXNzKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrcy5vbklucHV0RmllbGRWYWx1ZUNoYW5nZSkge1xuICAgICAgICBpbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4gY2FsbGJhY2tzLm9uSW5wdXRGaWVsZFZhbHVlQ2hhbmdlKGlucHV0RmllbGQudGV4dENvbnRlbnQgfHwgJycpKTtcbiAgICB9XG4gICAgaW5wdXRSb3cuYXBwZW5kQ2hpbGQoaW5wdXRGaWVsZCk7XG4gICAgLy8gUm93IDM6IE1haW4gQnV0dG9ucyAoU2VuZCwgTmV3IENoYXQsIEhpc3RvcnkpXG4gICAgY29uc3QgYnV0dG9uc1JvdyA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtYm90dG9tLWJhci1yb3cganAtbGxtLWV4dC1idXR0b25zLXJvdycgfSk7XG4gICAgY29uc3Qgc2VuZEJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVCdXR0b24pKHtcbiAgICAgICAgdGV4dDogJ1NlbmQnLFxuICAgICAgICBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtc2VuZC1idXR0b24nXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vblNlbmRNZXNzYWdlQ2xpY2spIHtcbiAgICAgICAgc2VuZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrcy5vblNlbmRNZXNzYWdlQ2xpY2spO1xuICAgIH1cbiAgICBjb25zdCBuZXdDaGF0QnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoe1xuICAgICAgICB0ZXh0OiAnKyBOZXcgQ2hhdCcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdTdGFydCBhIG5ldyBjaGF0JyB9LFxuICAgICAgICBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbidcbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uTmV3Q2hhdENsaWNrKSB7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFja3Mub25OZXdDaGF0Q2xpY2spO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5QnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoe1xuICAgICAgICB0ZXh0OiAnSGlzdG9yeScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdWaWV3IGNoYXQgaGlzdG9yeScgfSxcbiAgICAgICAgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbkhpc3RvcnlUb2dnbGVDbGljaykge1xuICAgICAgICBoaXN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FsbGJhY2tzLm9uSGlzdG9yeVRvZ2dsZUNsaWNrKTtcbiAgICB9XG4gICAgLy8gTm90ZXMgYnV0dG9uXG4gICAgY29uc3Qgbm90ZXNCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7XG4gICAgICAgIHRleHQ6ICdOb3RlcycsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdWaWV3IG5vdGVzJyB9LFxuICAgICAgICBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbidcbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uTm90ZXNDbGljaykge1xuICAgICAgICBub3Rlc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrcy5vbk5vdGVzQ2xpY2spO1xuICAgIH1cbiAgICBidXR0b25zUm93LmFwcGVuZENoaWxkKHNlbmRCdXR0b24pO1xuICAgIGJ1dHRvbnNSb3cuYXBwZW5kQ2hpbGQobmV3Q2hhdEJ1dHRvbik7XG4gICAgYnV0dG9uc1Jvdy5hcHBlbmRDaGlsZChoaXN0b3J5QnV0dG9uKTtcbiAgICBidXR0b25zUm93LmFwcGVuZENoaWxkKG5vdGVzQnV0dG9uKTtcbiAgICAvLyBBc3NlbWJsZSBCb3R0b20gQmFyXG4gICAgYm90dG9tQmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xzUm93KTtcbiAgICBib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXRSb3cpO1xuICAgIGJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b25zUm93KTtcbiAgICAvLyAtLS0gQXNzZW1ibGUgTWFpbiBFbGVtZW50IC0tLVxuICAgIG1haW5FbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcbiAgICBtYWluRWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlQ29udGFpbmVyKTtcbiAgICBtYWluRWxlbWVudC5hcHBlbmRDaGlsZChoaXN0b3J5Q29udGFpbmVyKTtcbiAgICBtYWluRWxlbWVudC5hcHBlbmRDaGlsZChub3Rlc0NvbnRhaW5lcik7XG4gICAgbWFpbkVsZW1lbnQuYXBwZW5kQ2hpbGQoYm90dG9tQmFyQ29udGFpbmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWluRWxlbWVudCxcbiAgICAgICAgdGl0bGVJbnB1dCxcbiAgICAgICAgbWVzc2FnZUNvbnRhaW5lcixcbiAgICAgICAgaGlzdG9yeUNvbnRhaW5lcixcbiAgICAgICAgbm90ZXNDb250YWluZXIsXG4gICAgICAgIGlucHV0RmllbGQsXG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lcixcbiAgICAgICAgc2VuZEJ1dHRvbixcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbixcbiAgICAgICAgaGlzdG9yeUJ1dHRvbixcbiAgICAgICAgbm90ZXNCdXR0b24sXG4gICAgICAgIG1hcmtkb3duVG9nZ2xlQnV0dG9uLFxuICAgICAgICBleHBhbmRCdXR0b24sXG4gICAgICAgIGF0QnV0dG9uLFxuICAgICAgICBzZXR0aW5nc0J1dHRvblxuICAgIH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVJlbmRlcmVyID0gdm9pZCAwO1xuZXhwb3J0cy5yZW5kZXJVc2VyTWVzc2FnZSA9IHJlbmRlclVzZXJNZXNzYWdlO1xuZXhwb3J0cy5yZW5kZXJCb3RNZXNzYWdlID0gcmVuZGVyQm90TWVzc2FnZTtcbmV4cG9ydHMucmVuZGVyQm90TWVzc2FnZVN0cmVhbWluZ1N0YXJ0ID0gcmVuZGVyQm90TWVzc2FnZVN0cmVhbWluZ1N0YXJ0O1xuZXhwb3J0cy5yZW5kZXJCb3RNZXNzYWdlU3RyZWFtaW5nVXBkYXRlID0gcmVuZGVyQm90TWVzc2FnZVN0cmVhbWluZ1VwZGF0ZTtcbmV4cG9ydHMucmVuZGVyQm90TWVzc2FnZUZpbmFsID0gcmVuZGVyQm90TWVzc2FnZUZpbmFsO1xuZXhwb3J0cy5yZW5kZXJSZWZlcmVuY2VXaWRnZXRJbmxpbmUgPSByZW5kZXJSZWZlcmVuY2VXaWRnZXRJbmxpbmU7XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG5jb25zdCBkb21wdXJpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tcHVyaWZ5XCIpKTtcbi8vIGltcG9ydCBobGpzIGZyb20gJ2hpZ2hsaWdodC5qcyc7IC8vIFJlbW92ZWQgdW51c2VkIGltcG9ydFxuY29uc3QgZG9tX2VsZW1lbnRzXzEgPSByZXF1aXJlKFwiLi9kb20tZWxlbWVudHNcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpOyAvLyBJbXBvcnQgZ2xvYmFsc1xuLy8gUmVtb3ZlZCB1bnVzZWQgaW1wb3J0IGJsb2NrIGZvciBjbGlwYm9hcmQgdXRpbHMgKHVzZWQgdmlhIGNhbGxiYWNrcylcbi8vIGltcG9ydCB7IGNvcHlUb0NsaXBib2FyZCwgY29weUltYWdlVG9DbGlwYm9hcmQsIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQgfSBmcm9tICcuLi91dGlscy9jbGlwYm9hcmQnO1xuLy8gUmVtb3ZlZCB1bnVzZWQgaW1wb3J0ICh1c2VkIHZpYSBjYWxsYmFja3MpXG4vLyBpbXBvcnQgeyBhZGRNZXNzYWdlVG9DZWxsIH0gZnJvbSAnLi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb24nO1xuY29uc3QgaGlnaGxpZ2h0aW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaGlnaGxpZ2h0aW5nXCIpO1xuY29uc3QgbWFya2Rvd25fY29uZmlnXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWFya2Rvd24tY29uZmlnXCIpO1xuLyoqXG4gKiBCYXNlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG1lc3NhZ2UgY29udGFpbmVyIGRpdi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZURpdihzZW5kZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbWVzc2FnZURpdi5jbGFzc05hbWUgPSBzZW5kZXIgPT09ICd1c2VyJyA/ICdqcC1sbG0tZXh0LXVzZXItbWVzc2FnZScgOiAnanAtbGxtLWV4dC1ib3QtbWVzc2FnZSc7XG4gICAgcmV0dXJuIG1lc3NhZ2VEaXY7XG59XG4vKipcbiAqIFJlbmRlcnMgYSB1c2VyIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclVzZXJNZXNzYWdlKHRleHQsIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2tzID0ge30pIHtcbiAgICBjb25zb2xlLmxvZyhgW3JlbmRlclVzZXJNZXNzYWdlXSBSZW5kZXJpbmcgd2l0aCBpc01hcmtkb3duOiAke29wdGlvbnMuaXNNYXJrZG93bn0sIHRleHQ6IFwiJHt0ZXh0fVwiYCk7XG4gICAgY29uc3QgbWVzc2FnZURpdiA9IGNyZWF0ZU1lc3NhZ2VEaXYoJ3VzZXInKTtcbiAgICBpZiAob3B0aW9ucy5pc01hcmtkb3duKSB7XG4gICAgICAgIC8vIFVzZSAnbWFya2Rvd24tY29udGVudCcgY2xhc3MgZm9yIGNvbnNpc3RlbnQgc3R5bGluZ1xuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ21hcmtkb3duLWNvbnRlbnQnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUHJlcHJvY2VzcywgcGFyc2UsIGFuZCBzYW5pdGl6ZSBsaWtlIGluIGJvdCBtZXNzYWdlc1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9ICgwLCBtYXJrZG93bl9jb25maWdfMS5wcmVwcm9jZXNzTWFya2Rvd24pKHRleHQpO1xuICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgLy8gQWRkIG1hcmtkb3duIGluZGljYXRvciAoc2ltaWxhciB0byBib3QgbWVzc2FnZXMpXG4gICAgICAgICAgICBjb25zdCBtYXJrZG93bkluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IudGV4dENvbnRlbnQgPSBcIk1EXCI7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci5jbGFzc05hbWUgPSAnbWFya2Rvd24taW5kaWNhdG9yJztcbiAgICAgICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgICAgICAgICAgLy8gRW5oYW5jZSBjb2RlIGJsb2NrcyBpZiB1c2VyIG1lc3NhZ2VzIGNhbiBjb250YWluIHRoZW1cbiAgICAgICAgICAgIGNvbnN0IGNvZGVCbG9ja3MgPSBjb250ZW50RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyk7XG4gICAgICAgICAgICBjb2RlQmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3Mgb25seSByZWxldmFudCBjYWxsYmFja3MgaWYgbmVlZGVkIGZvciB1c2VyIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgZW5oYW5jZUNvZGVCbG9jayhibG9jaywgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciB1c2VyIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHBsYWluIHRleHQgaWYgTWFya2Rvd24gcmVuZGVyaW5nIGZhaWxzXG4gICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm9uLU1hcmtkb3duIHVzZXIgbWVzc2FnZSAocGxhaW4gdGV4dClcbiAgICAgICAgLy8gUmVwbGFjZSBzaW1wbGUgdGV4dENvbnRlbnQgYXNzaWdubWVudCB3aXRoIHJlZi1hd2FyZSByZW5kZXJpbmdcbiAgICAgICAgLy8gbWVzc2FnZURpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIHJlbmRlck1lc3NhZ2VDb250ZW50V2l0aFJlZnMobWVzc2FnZURpdiwgdGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VEaXY7XG59XG4vKipcbiAqIE5FVzogUmVuZGVycyBtZXNzYWdlIGNvbnRlbnQsIHJlcGxhY2luZyBAcmVmZXJlbmNlcyB3aXRoIHdpZGdldHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1lc3NhZ2VDb250ZW50V2l0aFJlZnMoY29udGFpbmVyLCB0ZXh0LCBjYWxsYmFja3MpIHtcbiAgICAvLyAtLS0gREVCVUcgTE9HIC0tLSBcbiAgICBjb25zb2xlLmxvZygnW3JlbmRlck1lc3NhZ2VDb250ZW50V2l0aFJlZnNdIFByb2Nlc3NpbmcgdGV4dDonLCBKU09OLnN0cmluZ2lmeSh0ZXh0KSk7IC8vIExvZyBleGFjdCB0ZXh0XG4gICAgLy8gLS0tIEVORCBERUJVRyBMT0cgLS0tXG4gICAgLy8gUmVnZXggdG8gZmluZCBAZmlsZSwgQGRpciwgQENlbGwsIEBjb2RlIHJlZmVyZW5jZXMgKHdpdGggb3B0aW9uYWwgc3Vycm91bmRpbmcgd2hpdGVzcGFjZSlcbiAgICBjb25zdCByZWZSZWdleCA9IC9cXHMqKEAoZmlsZXxkaXJ8Q2VsbHxjb2RlKVxcWyhbXlxcXV0rPylcXF0pXFxzKi9nO1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGxldCBtYXRjaDtcbiAgICAvLyBSZXNldCByZWdleCBzdGF0ZSBqdXN0IGluIGNhc2VcbiAgICByZWZSZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWZSZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgdGV4dCBiZWZvcmUgdGhlIG1hdGNoXG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgbWF0Y2hlZCByZWZlcmVuY2VcbiAgICAgICAgY29uc3QgZnVsbE1hdGNoV2l0aFdoaXRlc3BhY2UgPSBtYXRjaFswXTsgLy8gSW5jbHVkZXMgcG90ZW50aWFsIHdoaXRlc3BhY2VcbiAgICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMV07IC8vIFRoZSBhY3R1YWwgQHR5cGVbdmFsdWVdIHBhcnRcbiAgICAgICAgY29uc3QgdHlwZSA9IG1hdGNoWzJdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoWzNdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0ID0gY3JlYXRlUmVmV2lkZ2V0KHR5cGUsIHZhbHVlLCBmdWxsTWF0Y2gsIGNhbGxiYWNrcyk7IC8vIFBhc3MgdGhlIGNsZWFuIG1hdGNoXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQod2lkZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgd2lkZ2V0IGZvciByZWZlcmVuY2U6ICR7ZnVsbE1hdGNofWAsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBhcHBlbmQgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZSB0ZXh0ICh3aXRoIHBvdGVudGlhbCB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGZ1bGxNYXRjaFdpdGhXaGl0ZXNwYWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gcmVmUmVnZXgubGFzdEluZGV4O1xuICAgIH1cbiAgICAvLyBBcHBlbmQgYW55IHJlbWFpbmluZyB0ZXh0IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBORVc6IENyZWF0ZXMgYSByZWZlcmVuY2Ugd2lkZ2V0IHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlZldpZGdldCh0eXBlLCB2YWx1ZSwgb3JpZ2luYWxSZWZUZXh0LCAvLyBUaGUgZnVsbCBAdHlwZVt2YWx1ZV0gc3RyaW5nXG5jYWxsYmFja3MpIHtcbiAgICBjb25zdCB3aWRnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgd2lkZ2V0LmNsYXNzTmFtZSA9IGBqcC1sbG0tZXh0LXJlZi13aWRnZXQgcmVmLSR7dHlwZS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgd2lkZ2V0LnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7XG4gICAgd2lkZ2V0LmRhdGFzZXQucmVmVGV4dCA9IG9yaWdpbmFsUmVmVGV4dDsgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZVxuICAgIGxldCBkaXNwbGF5VGV4dCA9ICcnO1xuICAgIGxldCB0aXRsZVRleHQgPSBvcmlnaW5hbFJlZlRleHQ7IC8vIERlZmF1bHQgdG9vbHRpcFxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ID0gdmFsdWUuc3BsaXQoL1tcXFxcL10vKS5wb3AoKSB8fCB2YWx1ZTsgLy8gRXh0cmFjdCBmaWxlbmFtZVxuICAgICAgICAgICAgdGl0bGVUZXh0ID0gYEZpbGU6ICR7dmFsdWV9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXInOlxuICAgICAgICAgICAgZGlzcGxheVRleHQgPSB2YWx1ZS5zcGxpdCgvW1xcXFwvXS8pLnBvcCgpIHx8IHZhbHVlIHx8ICcvJzsgLy8gRXh0cmFjdCBkaXJuYW1lLCBoYW5kbGUgcm9vdFxuICAgICAgICAgICAgdGl0bGVUZXh0ID0gYERpcmVjdG9yeTogJHt2YWx1ZX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0NlbGwnOiB7XG4gICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBwYXJzZUludCh2YWx1ZSkgLSAxOyAvLyBDb252ZXJ0IGJhY2sgdG8gMC1iYXNlZCBpbmRleFxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tDb250ZXh0ID0gY2FsbGJhY2tzLmdldEN1cnJlbnROb3RlYm9va0NvbnRleHQgPyBjYWxsYmFja3MuZ2V0Q3VycmVudE5vdGVib29rQ29udGV4dCgpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gLS0tIERFQlVHIExPRyAtLS0gXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVJlZldpZGdldCBAQ2VsbF0gSW5wdXQgVmFsdWU6ICR7dmFsdWV9LCBQYXJzZWQgSW5kZXg6ICR7Y2VsbEluZGV4fSwgTm90ZWJvb2sgQ29udGV4dDpgLCBub3RlYm9va0NvbnRleHQpO1xuICAgICAgICAgICAgLy8gLS0tIEVORCBERUJVRyBMT0cgLS0tIFxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tOYW1lID0gKG5vdGVib29rQ29udGV4dCA9PT0gbnVsbCB8fCBub3RlYm9va0NvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vdGVib29rQ29udGV4dC5uYW1lKSB8fCAnbm90ZWJvb2snO1xuICAgICAgICAgICAgbGV0IGNlbGxUeXBlQ2hhciA9ICc/JztcbiAgICAgICAgICAgIGlmIChub3RlYm9va0NvbnRleHQgJiYgZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE5vdGVib29rUGFuZWwgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuZmluZCh3aWRnZXQgPT4gd2lkZ2V0LmNvbnRleHQucGF0aCA9PT0gbm90ZWJvb2tDb250ZXh0LnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm90ZWJvb2tQYW5lbCAmJiBjdXJyZW50Tm90ZWJvb2tQYW5lbC5tb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsTW9kZWwgPSBjdXJyZW50Tm90ZWJvb2tQYW5lbC5tb2RlbC5jZWxscy5nZXQoY2VsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFR5cGVDaGFyID0gY2VsbE1vZGVsLnR5cGUgPT09ICdtYXJrZG93bicgPyAnTScgOiAnQyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5VGV4dCA9IGAke25vdGVib29rTmFtZX0tJHtjZWxsVHlwZUNoYXJ9LSR7dmFsdWV9YDsgLy8gdmFsdWUgaXMgMS1iYXNlZCBpbmRleFxuICAgICAgICAgICAgdGl0bGVUZXh0ID0gYENlbGwgJHt2YWx1ZX0gKCR7Y2VsbFR5cGVDaGFyID09PSAnTScgPyAnTWFya2Rvd24nIDogJ0NvZGUnfSkgaW4gJHtub3RlYm9va05hbWV9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICAgICAgICBjb25zdCByZWZJZCA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVmRGF0YSA9IGNhbGxiYWNrcy5nZXRDb2RlUmVmRGF0YSA/IGNhbGxiYWNrcy5nZXRDb2RlUmVmRGF0YShyZWZJZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyAtLS0gREVCVUcgTE9HIC0tLSBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlUmVmV2lkZ2V0IEBjb2RlXSBJbnB1dCBWYWx1ZSAocmVmSWQpOiAke3JlZklkfSwgUmVmIERhdGEgRm91bmQ6YCwgcmVmRGF0YSk7XG4gICAgICAgICAgICAvLyAtLS0gRU5EIERFQlVHIExPRyAtLS0gXG4gICAgICAgICAgICBpZiAocmVmRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBkaXNwbGF5IHRleHQgdXNpbmcgc3RhcnQgYW5kIGVuZCBsaW5lc1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IHJlZkRhdGEubGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gcmVmRGF0YS5saW5lRW5kTnVtYmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVQYXJ0ID0gc3RhcnRMaW5lID09PSBlbmRMaW5lID8gYCR7c3RhcnRMaW5lfWAgOiBgJHtzdGFydExpbmV9XyR7ZW5kTGluZX1gO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0ID0gYCR7cmVmRGF0YS5ub3RlYm9va05hbWV9LSR7cmVmRGF0YS5jZWxsSW5kZXggKyAxfS0ke2xpbmVQYXJ0fWA7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRpdGxlIHRleHQgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlTGluZVBhcnQgPSBzdGFydExpbmUgPT09IGVuZExpbmUgPyBgTGluZSAke3N0YXJ0TGluZX1gIDogYExpbmVzICR7c3RhcnRMaW5lfS0ke2VuZExpbmV9YDtcbiAgICAgICAgICAgICAgICB0aXRsZVRleHQgPSBgQ29kZSBSZWZlcmVuY2U6ICR7cmVmRGF0YS5ub3RlYm9va05hbWV9LCBDZWxsICR7cmVmRGF0YS5jZWxsSW5kZXggKyAxfSwgJHt0aXRsZUxpbmVQYXJ0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dCA9IGBjb2RlLXJlZi0ke3JlZklkfWA7IC8vIEZhbGxiYWNrIGRpc3BsYXlcbiAgICAgICAgICAgICAgICB0aXRsZVRleHQgPSBgQ29kZSBSZWZlcmVuY2UgSUQ6ICR7cmVmSWR9IChEYXRhIG5vdCBmb3VuZClgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2lkZ2V0LnRleHRDb250ZW50ID0gZGlzcGxheVRleHQ7XG4gICAgd2lkZ2V0LnRpdGxlID0gdGl0bGVUZXh0OyAvLyBBZGQgdG9vbHRpcFxuICAgIHJldHVybiB3aWRnZXQ7XG59XG4vKipcbiAqIE5FVzogUmVjdXJzaXZlbHkgZmluZHMgYW5kIHJlcGxhY2VzIEByZWZlcmVuY2VzIHdpdGhpbiB0ZXh0IG5vZGVzIG9mIGFuIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclJlZnNJbkVsZW1lbnQoZWxlbWVudCwgY2FsbGJhY2tzKSB7XG4gICAgLy8gVXNlIHRoZSBzYW1lIHVwZGF0ZWQgcmVnZXggaGVyZVxuICAgIGNvbnN0IHJlZlJlZ2V4ID0gL1xccyooQChmaWxlfGRpcnxDZWxsfGNvZGUpXFxbKFteXFxdXSs/KVxcXSlcXHMqL2c7XG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCk7XG4gICAgbGV0IG5vZGU7XG4gICAgY29uc3Qgbm9kZXNUb1Byb2Nlc3MgPSBbXTtcbiAgICB3aGlsZSAoKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmXG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICYmXG4gICAgICAgICAgICAhKG5vZGUucGFyZW50RWxlbWVudCAmJiBub2RlLnBhcmVudEVsZW1lbnQuY2xvc2VzdCgnLmpwLWxsbS1leHQtcmVmLXdpZGdldCcpKSkge1xuICAgICAgICAgICAgLy8gVGVzdCB3aXRoIHRoZSBzcGVjaWZpYyByZWdleCBiZWZvcmUgYWRkaW5nXG4gICAgICAgICAgICByZWZSZWdleC5sYXN0SW5kZXggPSAwOyAvLyBSZXNldCBiZWZvcmUgdGVzdFxuICAgICAgICAgICAgaWYgKHJlZlJlZ2V4LnRlc3Qobm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1RvUHJvY2Vzcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vdywgcHJvY2VzcyB0aGUgY29sbGVjdGVkIHRleHQgbm9kZXNcbiAgICBub2Rlc1RvUHJvY2Vzcy5mb3JFYWNoKHRleHROb2RlID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHJlZlJlZ2V4Lmxhc3RJbmRleCA9IDA7IC8vIFJlc2V0IHJlZ2V4IHN0YXRlIGZvciBlYWNoIG5vZGVcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZlJlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBBcHBlbmQgdGV4dCBiZWZvcmUgdGhlIG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgbWF0Y2hlZCByZWZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaFdpdGhXaGl0ZXNwYWNlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbM107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZGdldCA9IGNyZWF0ZVJlZldpZGdldCh0eXBlLCB2YWx1ZSwgZnVsbE1hdGNoLCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdpZGdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHdpZGdldCBmb3IgcmVmZXJlbmNlOiAke2Z1bGxNYXRjaH1gLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZnVsbE1hdGNoV2l0aFdoaXRlc3BhY2UpKTsgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHJlZlJlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgYW55IHJlbWFpbmluZyB0ZXh0IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIG9yaWdpbmFsIHRleHQgbm9kZSB3aXRoIHRoZSBmcmFnbWVudFxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LCB0ZXh0Tm9kZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJlbmRlcnMgYSBib3QgbWVzc2FnZSAodGV4dCwgbWFya2Rvd24sIGltYWdlcywgY29kZSBibG9ja3MpLlxuICovXG5mdW5jdGlvbiByZW5kZXJCb3RNZXNzYWdlKHRleHQsIG9wdGlvbnMgPSB7IGlzTWFya2Rvd246IHRydWUgfSwgY2FsbGJhY2tzID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlRGl2ID0gY3JlYXRlTWVzc2FnZURpdignYm90Jyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgaXMgYW4gaW1hZ2UgVVJMXG4gICAgY29uc3QgaXNJbWFnZVVybCA9IHRleHQudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJykgJiZcbiAgICAgICAgKHRleHQudHJpbSgpLmVuZHNXaXRoKCcucG5nJykgfHxcbiAgICAgICAgICAgIHRleHQudHJpbSgpLmVuZHNXaXRoKCcuanBnJykgfHxcbiAgICAgICAgICAgIHRleHQudHJpbSgpLmVuZHNXaXRoKCcuanBlZycpIHx8XG4gICAgICAgICAgICB0ZXh0LnRyaW0oKS5lbmRzV2l0aCgnLmdpZicpKTtcbiAgICBpZiAoaXNJbWFnZVVybCkge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgZnVsbCBVUkwgKFRPRE86IE1ha2UgYmFzZSBVUkwgY29uZmlndXJhYmxlKVxuICAgICAgICBjb25zdCBmdWxsSW1hZ2VVcmwgPSBgaHR0cDovLzEyNy4wLjAuMTo4MDAwJHt0ZXh0LnRyaW0oKX1gO1xuICAgICAgICAvLyBDYWxsIGRlZGljYXRlZCBpbWFnZSByZW5kZXJpbmcgZnVuY3Rpb25cbiAgICAgICAgcmVuZGVySW1hZ2VNZXNzYWdlKG1lc3NhZ2VEaXYsIGZ1bGxJbWFnZVVybCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5pc01hcmtkb3duKSB7XG4gICAgICAgIC8vIFJlbmRlciBhcyBtYXJrZG93biAobG9naWMgZnJvbSBhZGRNZXNzYWdlKVxuICAgICAgICBjb25zdCBtYXJrZG93bkluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXJrZG93bkluZGljYXRvci50ZXh0Q29udGVudCA9IFwiTURcIjtcbiAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IuY2xhc3NOYW1lID0gJ21hcmtkb3duLWluZGljYXRvcic7XG4gICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ21hcmtkb3duLWNvbnRlbnQnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9ICgwLCBtYXJrZG93bl9jb25maWdfMS5wcmVwcm9jZXNzTWFya2Rvd24pKHRleHQpO1xuICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgLy8gLS0tIE5FVzogUmVuZGVyIHJlZmVyZW5jZXMgd2l0aGluIHRoZSBzYW5pdGl6ZWQgSFRNTCAtLS0gXG4gICAgICAgICAgICByZW5kZXJSZWZzSW5FbGVtZW50KGNvbnRlbnREaXYsIGNhbGxiYWNrcyk7XG4gICAgICAgICAgICAvLyAtLS0gRW5kIE5FVyAtLS1cbiAgICAgICAgICAgIC8vIEVuaGFuY2UgY29kZSBibG9ja3MgYWZ0ZXIgc2V0dGluZyBpbm5lckhUTUwgYW5kIHJlbmRlcmluZyByZWZzXG4gICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBlbmhhbmNlQ29kZUJsb2NrKGJsb2NrLCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYW5kIHJlbmRlciBpbnRlcnJ1cHQgYnV0dG9uc1xuICAgICAgICAgICAgY29uc3QgaXNJbnRlcnJ1cHQgPSB0ZXh0LnN0YXJ0c1dpdGgoJyoqW0lOVEVSUlVQVF0qKicpO1xuICAgICAgICAgICAgaWYgKGlzSW50ZXJydXB0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVySW50ZXJydXB0QnV0dG9ucyhjb250ZW50RGl2LCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29udGVudERpdi50ZXh0Q29udGVudCA9IHRleHQ7IC8vIEZhbGxiYWNrIHRvIHBsYWluIHRleHRcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgIC8vIEFkZCBvdmVyYWxsIG1lc3NhZ2UgYWN0aW9uIGJ1dHRvbnMgQUZURVIgY29udGVudCBpcyBhZGRlZFxuICAgICAgICBhZGRCb3RNZXNzYWdlQWN0aW9ucyhtZXNzYWdlRGl2LCB0ZXh0LCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVuZGVyIGFzIHBsYWluIHRleHRcbiAgICAgICAgbWVzc2FnZURpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIC8vIEFkZCBvdmVyYWxsIG1lc3NhZ2UgYWN0aW9uIGJ1dHRvbnMgZXZlbiBmb3IgcGxhaW4gdGV4dCBib3QgbWVzc2FnZXNcbiAgICAgICAgYWRkQm90TWVzc2FnZUFjdGlvbnMobWVzc2FnZURpdiwgdGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VEaXY7XG59XG4vLyBEZWZpbmUgY3JlYXRlTWVzc2FnZVdyYXBwZXIgYmFzZWQgb24gY3JlYXRlTWVzc2FnZURpdlxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZVdyYXBwZXIoc2VuZGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2VEaXYoc2VuZGVyKTtcbn1cbi8vIC0tLSBNb3JlIHNwZWNpZmljIHJlbmRlcmluZyBmdW5jdGlvbnMgb3IgaGVscGVycyBjYW4gYmUgYWRkZWQgYmVsb3cgLS0tXG4vKipcbiAqIFJlbmRlcnMgYW4gaW1hZ2UgbWVzc2FnZSB3aXRoIGFjdGlvbiBidXR0b25zIGluc2lkZSBhIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIFRoZSBwYXJlbnQgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgaW1hZ2UgbWVzc2FnZSB0by5cbiAqIEBwYXJhbSBpbWFnZVVybCBUaGUgZnVsbCBVUkwgb2YgdGhlIGltYWdlIHRvIHJlbmRlci5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBhY3Rpb25zIGxpa2UgY29weSBpbWFnZSwgYWRkIHBhdGguXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckltYWdlTWVzc2FnZShjb250YWluZXIsIGltYWdlVXJsLCBjYWxsYmFja3MgPSB7fSkge1xuICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhlIGltYWdlIHRoYXQgYWxsb3dzIHBvc2l0aW9uaW5nIHRoZSBidXR0b25zXG4gICAgY29uc3QgaW1hZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbWFnZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1jb250YWluZXInO1xuICAgIGltYWdlQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAvLyBSZW5kZXIgYXMgYW4gaW1hZ2UgdGFnXG4gICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgaW1nLnNyYyA9IGltYWdlVXJsO1xuICAgIGltZy5hbHQgPSAnSW1hZ2UgZnJvbSBib3QnO1xuICAgIGltZy5zdHlsZS5tYXhXaWR0aCA9ICcxMDAlJzsgLy8gRW5zdXJlIGltYWdlIGZpdHMgd2l0aGluIHRoZSBjb250YWluZXJcbiAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgIGltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGltZyk7XG4gICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIGZvciB0aGUgaW1hZ2VcbiAgICBjb25zdCBpbWdBY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW1nQWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb25zJztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmJvdHRvbSA9ICcxMHB4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnJpZ2h0ID0gJzEwcHgnO1xuICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmdhcCA9ICc4cHgnO1xuICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC42KSc7IC8vIEFkZGVkIHNsaWdodCBiYWNrZ3JvdW5kIGZvciB2aXNpYmlsaXR5XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcbiAgICAvLyBDb3B5IGltYWdlIGJ1dHRvbiAodXNpbmcgY2FsbGJhY2spXG4gICAgaWYgKGNhbGxiYWNrcy5jb3B5SW1hZ2VUb0NsaXBib2FyZCAmJiBjYWxsYmFja3Muc2hvd0NvcHlGZWVkYmFjaykge1xuICAgICAgICBjb25zdCBjb3B5SW1nQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGNvcHlJbWdCdG4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW1hZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGNvcHlJbWdCdG4uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGNvcHlJbWdCdG4udGl0bGUgPSAnQ29weSBpbWFnZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICBjb25zdCBmZWVkYmFja0NiID0gKCkgPT4gY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2soY29weUltZ0J0bik7XG4gICAgICAgIGNvcHlJbWdCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLmNvcHlJbWFnZVRvQ2xpcGJvYXJkKGltYWdlVXJsLCBmZWVkYmFja0NiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGltZ0FjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUltZ0J0bik7XG4gICAgfVxuICAgIC8vIEFkZCBmaWxlIHBhdGggYnV0dG9uICh1c2luZyBjYWxsYmFjaylcbiAgICBpZiAoY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwpIHtcbiAgICAgICAgY29uc3QgYWRkUGF0aEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBhZGRQYXRoQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBhZGRQYXRoQnRuLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlwiPjwvcGF0aD48cmVjdCB4PVwiOFwiIHk9XCIyXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMVwiIHJ5PVwiMVwiPjwvcmVjdD48cGF0aCBkPVwiTTEyIDExdjZcIj48L3BhdGg+PHBhdGggZD1cIk05IDE0aDZcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgYWRkUGF0aEJ0bi50aXRsZSA9ICdBZGQgaW1hZ2UgcGF0aCB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICBhZGRQYXRoQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIGltYWdlIFVSTCAod2hpY2ggaXMgdGhlIG1lc3NhZ2UgdGV4dCBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICBjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbChpbWFnZVVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbWdBY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFBhdGhCdG4pO1xuICAgIH1cbiAgICAvLyBPbmx5IGFkZCB0aGUgYWN0aW9ucyBkaXYgaWYgaXQgaGFzIGJ1dHRvbnNcbiAgICBpZiAoaW1nQWN0aW9uc0Rpdi5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nQWN0aW9uc0Rpdik7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgaW1hZ2UgY29udGFpbmVyIHRvIHRoZSBtYWluIG1lc3NhZ2UgZGl2XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGltYWdlQ29udGFpbmVyKTtcbn1cbi8qKlxuICogQ3JlYXRlcyB0aGUgaW5pdGlhbCBzdHJ1Y3R1cmUgZm9yIGEgYm90IG1lc3NhZ2UgdGhhdCB3aWxsIHJlY2VpdmUgc3RyZWFtaW5nIGNvbnRlbnQuXG4gKlxuICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHdyYXBwZXIsIHN0cmVhbWluZyBkaXYsIGFuZCBmaW5hbCBjb250ZW50IGRpdi5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQm90TWVzc2FnZVN0cmVhbWluZ1N0YXJ0KCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVNZXNzYWdlV3JhcHBlcignYm90Jyk7XG4gICAgY29uc3QgbWFya2Rvd25JbmRpY2F0b3IgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7XG4gICAgICAgIHRleHQ6ICdNRCcsXG4gICAgICAgIGNsYXNzZXM6ICdtYXJrZG93bi1pbmRpY2F0b3InXG4gICAgfSk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChtYXJrZG93bkluZGljYXRvcik7XG4gICAgY29uc3Qgc3RyZWFtaW5nRGl2ID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoe1xuICAgICAgICBjbGFzc2VzOiAnc3RyZWFtaW5nLWNvbnRlbnQnLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLFxuICAgICAgICAgICAgZm9udFNpemU6ICcwLjllbSdcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc3RyZWFtaW5nRGl2KTtcbiAgICBjb25zdCBjb250ZW50RGl2ID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoe1xuICAgICAgICBjbGFzc2VzOiAnbWFya2Rvd24tY29udGVudCcsXG4gICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICB9KTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgIHJldHVybiB7IHdyYXBwZXIsIHN0cmVhbWluZ0RpdiwgY29udGVudERpdiB9O1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdHJlYW1pbmcgZGl2IHdpdGggYSBuZXcgY2h1bmsgb2YgdGV4dC5cbiAqXG4gKiBAcGFyYW0gc3RyZWFtaW5nRGl2IC0gVGhlIGRpdiBkaXNwbGF5aW5nIHN0cmVhbWluZyBjb250ZW50LlxuICogQHBhcmFtIGNodW5rIC0gVGhlIG5ldyB0ZXh0IGNodW5rIHRvIGFwcGVuZC5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQm90TWVzc2FnZVN0cmVhbWluZ1VwZGF0ZShzdHJlYW1pbmdEaXYsIGNodW5rKSB7XG4gICAgLy8gU2ltcGxlIGFwcGVuZCwgbWlnaHQgbmVlZCByZWZpbmVtZW50IGZvciBjb21wbGV4IHN0cmVhbXNcbiAgICBzdHJlYW1pbmdEaXYudGV4dENvbnRlbnQgKz0gY2h1bms7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhlIGZpbmFsIGNvbnRlbnQgb2YgYSBib3QgbWVzc2FnZSBhZnRlciBzdHJlYW1pbmcgaXMgY29tcGxldGUuXG4gKiBIYW5kbGVzIG1hcmtkb3duLCBpbWFnZXMsIGNvZGUgYmxvY2tzLCBhbmQgaW50ZXJydXB0cy5cbiAqXG4gKiBAcGFyYW0gY29udGVudERpdiAtIFRoZSBkaXYgd2hlcmUgdGhlIGZpbmFsIGNvbnRlbnQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHN0cmVhbWluZ0RpdiAtIFRoZSBkaXYgdGhhdCB3YXMgdXNlZCBmb3Igc3RyZWFtaW5nICh3aWxsIGJlIGhpZGRlbikuXG4gKiBAcGFyYW0gY29tcGxldGVSZXNwb25zZSAtIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBib3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zIGluY2x1ZGluZyBjYWxsYmFja3MgZm9yIGFjdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgcG9wdWxhdGVkIGNvbnRlbnREaXYuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJvdE1lc3NhZ2VGaW5hbChjb250ZW50RGl2LCBzdHJlYW1pbmdEaXYsIGNvbXBsZXRlUmVzcG9uc2UsIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2tzID0ge30pIHtcbiAgICAvLyBIaWRlIHN0cmVhbWluZyBkaXYsIHNob3cgZmluYWwgY29udGVudCBkaXZcbiAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIC8vIENvbnNvbGlkYXRlIGNhbGxiYWNrcyBhY2Nlc3NcbiAgICBjb25zdCBlZmZlY3RpdmVDYWxsYmFja3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCBjYWxsYmFja3MpO1xuICAgIC8vIC0tLSBJbWFnZSBIYW5kbGluZyAtLS1cbiAgICBjb25zdCBpc0ltYWdlVXJsID0gY29tcGxldGVSZXNwb25zZS50cmltKCkuc3RhcnRzV2l0aCgnL2ltYWdlcy8nKSAmJlxuICAgICAgICAoY29tcGxldGVSZXNwb25zZS50cmltKCkuZW5kc1dpdGgoJy5wbmcnKSB8fFxuICAgICAgICAgICAgY29tcGxldGVSZXNwb25zZS50cmltKCkuZW5kc1dpdGgoJy5qcGcnKSB8fFxuICAgICAgICAgICAgY29tcGxldGVSZXNwb25zZS50cmltKCkuZW5kc1dpdGgoJy5qcGVnJykgfHxcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcuZ2lmJykpO1xuICAgIGlmIChpc0ltYWdlVXJsKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxJbWFnZVVybCA9IGBodHRwOi8vMTI3LjAuMC4xOjgwMDAke2NvbXBsZXRlUmVzcG9uc2UudHJpbSgpfWA7IC8vIFRPRE86IE1ha2UgYmFzZSBVUkwgY29uZmlndXJhYmxlXG4gICAgICAgIHJlbmRlckltYWdlTWVzc2FnZShjb250ZW50RGl2LCBmdWxsSW1hZ2VVcmwsIGVmZmVjdGl2ZUNhbGxiYWNrcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyAtLS0gTWFya2Rvd24gJiBDb2RlIEJsb2NrIEhhbmRsaW5nIC0tLVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVGV4dCA9ICgwLCBtYXJrZG93bl9jb25maWdfMS5wcmVwcm9jZXNzTWFya2Rvd24pKGNvbXBsZXRlUmVzcG9uc2UpO1xuICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgLy8gLS0tIE5FVzogUmVuZGVyIHJlZmVyZW5jZXMgd2l0aGluIHRoZSBzYW5pdGl6ZWQgSFRNTCAtLS0gXG4gICAgICAgICAgICByZW5kZXJSZWZzSW5FbGVtZW50KGNvbnRlbnREaXYsIGVmZmVjdGl2ZUNhbGxiYWNrcyk7XG4gICAgICAgICAgICAvLyAtLS0gRW5kIE5FVyAtLS1cbiAgICAgICAgICAgIC8vIC0tLSBJbnRlcnJ1cHQgSGFuZGxpbmcgLS0tXG4gICAgICAgICAgICBjb25zdCBpc0ludGVycnVwdCA9IGNvbXBsZXRlUmVzcG9uc2Uuc3RhcnRzV2l0aCgnKipbSU5URVJSVVBUXSoqJyk7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcnJ1cHQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbnRlcnJ1cHRCdXR0b25zKGNvbnRlbnREaXYsIGVmZmVjdGl2ZUNhbGxiYWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0gQ29kZSBCbG9jayBFbmhhbmNlbWVudHMgLS0tXG4gICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBlbmhhbmNlQ29kZUJsb2NrKGJsb2NrLCBlZmZlY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgY29udGVudERpdi50ZXh0Q29udGVudCA9IGNvbXBsZXRlUmVzcG9uc2U7IC8vIEZhbGxiYWNrIHRvIHBsYWluIHRleHRcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGVudERpdjtcbn1cbi8qKlxuICogRW5oYW5jZXMgYSBjb2RlIGJsb2NrIGVsZW1lbnQgd2l0aCBoaWdobGlnaHRpbmcgYW5kIGFjdGlvbiBidXR0b25zLlxuICpcbiAqIEBwYXJhbSBjb2RlQmxvY2tFbGVtZW50IFRoZSA8Y29kZT4gZWxlbWVudCB3aXRoaW4gYSA8cHJlPi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBhY3Rpb25zIGxpa2UgY29weSBjb2RlLCBhZGQgdG8gY2VsbC5cbiAqL1xuZnVuY3Rpb24gZW5oYW5jZUNvZGVCbG9jayhjb2RlQmxvY2tFbGVtZW50LCBjYWxsYmFja3MgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmVFbGVtZW50ID0gY29kZUJsb2NrRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghcHJlRWxlbWVudCB8fCBwcmVFbGVtZW50LnRhZ05hbWUgIT09ICdQUkUnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29kZSBibG9jayBlbmhhbmNlbWVudCBjYWxsZWQgb24gZWxlbWVudCBub3Qgd2l0aGluIGEgPHByZT4gdGFnLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFkZCBzdGFuZGFyZCBKdXB5dGVyTGFiIGNsYXNzZXMgZm9yIGNvbnNpc3RlbmN5XG4gICAgY29kZUJsb2NrRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZFRleHQnKTtcbiAgICBwcmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgIC8vIEdldCBjb2RlIGNvbnRlbnRcbiAgICBjb25zdCBjb2RlQ29udGVudCA9IGNvZGVCbG9ja0VsZW1lbnQudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgLy8gQ3JlYXRlIGNvZGUgYmxvY2sgaGVhZGVyIGZvciBidXR0b25zIGFuZCBsYW5ndWFnZSBpbmRpY2F0b3JcbiAgICBjb25zdCBjb2RlSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29kZUhlYWRlci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWhlYWRlcic7XG4gICAgLy8gQWRkIGxhbmd1YWdlIGluZGljYXRvciBpZiBkZXRlY3RlZFxuICAgIGNvbnN0IGxhbmd1YWdlID0gKDAsIGhpZ2hsaWdodGluZ18xLmRldGVjdExhbmd1YWdlKShjb2RlQ29udGVudCk7IC8vIFVzZSBpbXBvcnRlZCB1dGlsXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgIGNvbnN0IGxhbmdJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxhbmdJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1sYW5ndWFnZSc7XG4gICAgICAgIGxhbmdJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBsYW5ndWFnZTtcbiAgICAgICAgY29kZUhlYWRlci5hcHBlbmRDaGlsZChsYW5nSW5kaWNhdG9yKTtcbiAgICAgICAgY29kZUJsb2NrRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBsYW5ndWFnZS0ke2xhbmd1YWdlfWApO1xuICAgIH1cbiAgICAvLyBBcHBseSBzeW50YXggaGlnaGxpZ2h0aW5nXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVXNlIGltcG9ydGVkIHV0aWwgKGhhbmRsZXMgYXV0by1kZXRlY3Rpb24gaWYgbGFuZ3VhZ2UgaXMgZW1wdHkpXG4gICAgICAgIGNvZGVCbG9ja0VsZW1lbnQuaW5uZXJIVE1MID0gKDAsIGhpZ2hsaWdodGluZ18xLmhpZ2hsaWdodENvZGUpKGNvZGVDb250ZW50LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyBzeW50YXggaGlnaGxpZ2h0aW5nOicsIGVycm9yKTtcbiAgICAgICAgLy8gY29kZUJsb2NrRWxlbWVudCBtaWdodCBjb250YWluIG9yaWdpbmFsIHRleHQgb3IgcGFydGlhbGx5IGhpZ2hsaWdodGVkXG4gICAgfVxuICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyB0byB0aGUgY29kZSBoZWFkZXJcbiAgICBjb25zdCBhY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbnMnO1xuICAgIC8vIENvcHkgYnV0dG9uXG4gICAgaWYgKGNhbGxiYWNrcy5jb3B5VG9DbGlwYm9hcmQgJiYgY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2spIHtcbiAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBjb2RlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrQ2IgPSAoKSA9PiBjYWxsYmFja3Muc2hvd0NvcHlGZWVkYmFjayhjb3B5QnV0dG9uKTtcbiAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuY29weVRvQ2xpcGJvYXJkKGNvZGVDb250ZW50LCBmZWVkYmFja0NiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgfVxuICAgIC8vIEFkZCB0byBjZWxsIGJ1dHRvblxuICAgIGlmIChjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbCkge1xuICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBhZGRUb0J1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBhZGRUb0J1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBjb2RlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgIGFkZFRvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5hZGRNZXNzYWdlVG9DZWxsKGNvZGVDb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoYWRkVG9CdXR0b24pO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGFjdGlvbnMgdG8gdGhlIGhlYWRlciwgYW5kIGluc2VydCBoZWFkZXIgYmVmb3JlIHRoZSA8cHJlPlxuICAgIGlmIChhY3Rpb25zRGl2Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjb2RlSGVhZGVyLmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgIH1cbiAgICBpZiAoY29kZUhlYWRlci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgKF9hID0gcHJlRWxlbWVudC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5zZXJ0QmVmb3JlKGNvZGVIZWFkZXIsIHByZUVsZW1lbnQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVuZGVycyBDb25maXJtL1JlamVjdCBidXR0b25zIGZvciBhbiBpbnRlcnJ1cHQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIFRoZSBwYXJlbnQgSFRNTCBlbGVtZW50IChtZXNzYWdlIGNvbnRlbnQgZGl2KSB0byBhcHBlbmQgYnV0dG9ucyB0by5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBjb25maXJtIGFuZCByZWplY3QgYWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVySW50ZXJydXB0QnV0dG9ucyhjb250YWluZXIsIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgaWYgKCFjYWxsYmFja3MuaGFuZGxlQ29uZmlybUludGVycnVwdCB8fCAhY2FsbGJhY2tzLmhhbmRsZVJlamVjdEludGVycnVwdCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludGVycnVwdCBtZXNzYWdlIG5lZWRzIGNvbmZpcm0vcmVqZWN0IGNhbGxiYWNrcy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidXR0b25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbnRlcnJ1cHQtYnV0dG9ucyc7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3AgPSAnMTJweCc7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIGJ1dHRvbnNDb250YWluZXIuc3R5bGUuZ2FwID0gJzhweCc7XG4gICAgLy8gQ3JlYXRlIGNvbmZpcm0gYnV0dG9uXG4gICAgY29uc3QgY29uZmlybUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGNvbmZpcm1CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29uZmlybS1idXR0b24nO1xuICAgIGNvbmZpcm1CdXR0b24udGV4dENvbnRlbnQgPSAnQ29uZmlybSc7XG4gICAgLy8gQXBwbHkgc3BlY2lmaWMgc3R5bGluZyAoY2FuIGJlIG1vdmVkIHRvIENTUylcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLnBhZGRpbmcgPSAnNnB4IDEycHgnO1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuYmFja2dyb3VuZCA9ICcjNENBRjUwJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAvLyBDcmVhdGUgcmVqZWN0IGJ1dHRvblxuICAgIGNvbnN0IHJlamVjdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHJlamVjdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1yZWplY3QtYnV0dG9uJztcbiAgICByZWplY3RCdXR0b24udGV4dENvbnRlbnQgPSAnUmVqZWN0JztcbiAgICAvLyBBcHBseSBzcGVjaWZpYyBzdHlsaW5nIChjYW4gYmUgbW92ZWQgdG8gQ1NTKVxuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5wYWRkaW5nID0gJzZweCAxMnB4JztcbiAgICByZWplY3RCdXR0b24uc3R5bGUuYmFja2dyb3VuZCA9ICcjRjQ0MzM2JztcbiAgICByZWplY3RCdXR0b24uc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgcmVqZWN0QnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgcmVqZWN0QnV0dG9uLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIGNvbmZpcm1CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgY2FsbGJhY2tzLmhhbmRsZUNvbmZpcm1JbnRlcnJ1cHQoKTtcbiAgICB9KTtcbiAgICByZWplY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgY2FsbGJhY2tzLmhhbmRsZVJlamVjdEludGVycnVwdCgpO1xuICAgIH0pO1xuICAgIC8vIEFkZCBidXR0b25zIHRvIGNvbnRhaW5lciBhbmQgY29udGFpbmVyIHRvIG1lc3NhZ2VcbiAgICBidXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbmZpcm1CdXR0b24pO1xuICAgIGJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQocmVqZWN0QnV0dG9uKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uc0NvbnRhaW5lcik7XG59XG4vKipcbiAqIEFkZHMgb3ZlcmFsbCBhY3Rpb24gYnV0dG9ucyAoQ29weSwgQWRkIHRvIENlbGwpIHRvIGEgYm90IG1lc3NhZ2UgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGl2IFRoZSBtYWluIGRpdiBjb250YWluZXIgZm9yIHRoZSBib3QgbWVzc2FnZS5cbiAqIEBwYXJhbSBtZXNzYWdlVGV4dCBUaGUgcmF3IHRleHQgY29udGVudCBvZiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBhY3Rpb25zIGxpa2UgY29weSBtZXNzYWdlLCBhZGQgdG8gY2VsbC5cbiAqL1xuZnVuY3Rpb24gYWRkQm90TWVzc2FnZUFjdGlvbnMobWVzc2FnZURpdiwgbWVzc2FnZVRleHQsIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgLy8gT25seSBhZGQgYWN0aW9ucyBpZiBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcyBhcmUgcHJvdmlkZWRcbiAgICBpZiAoIWNhbGxiYWNrcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkICYmICFjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgYWN0aW9uIGJ1dHRvbnMgdG8gYm90IG1lc3NhZ2UnKTsgLy8gS2VlcCBkZWJ1ZyBsb2cgZm9yIG5vd1xuICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9ucyc7XG4gICAgLy8gYWN0aW9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBFbnN1cmUgZGlzcGxheSB2aWEgQ1NTIGlmIG5lZWRlZFxuICAgIC8vIENvcHkgTWVzc2FnZSBidXR0b25cbiAgICBpZiAoY2FsbGJhY2tzLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQgJiYgY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2spIHtcbiAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrQ2IgPSAoKSA9PiBjYWxsYmFja3Muc2hvd0NvcHlGZWVkYmFjayhjb3B5QnV0dG9uKTtcbiAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuY29weU1lc3NhZ2VUb0NsaXBib2FyZChtZXNzYWdlVGV4dCwgZmVlZGJhY2tDYik7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgIH1cbiAgICAvLyBBZGQgdG8gQ2VsbCBidXR0b25cbiAgICBpZiAoY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwpIHtcbiAgICAgICAgY29uc3QgYWRkVG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbChtZXNzYWdlVGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIHRoZSBhY3Rpb25zIGNvbnRhaW5lciBpZiBpdCBoYXMgYW55IGJ1dHRvbnNcbiAgICBpZiAoYWN0aW9uc0Rpdi5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICAgICAgY29uc29sZS5sb2coJ0FjdGlvbiBidXR0b25zIGFkZGVkIHRvIGJvdCBtZXNzYWdlOicsIGFjdGlvbnNEaXYpOyAvLyBLZWVwIGRlYnVnIGxvZ1xuICAgIH1cbn1cbi8qKlxuICogUmVuZGVycyBhIHJlZmVyZW5jZSB3aWRnZXQgYXMgYW4gSFRNTEVsZW1lbnQgc3VpdGFibGUgZm9yIGlubGluZSBkaXNwbGF5XG4gKiAoZS5nLiwgd2l0aGluIHRoZSBpbnB1dCBmaWVsZCBvciBhIG1lc3NhZ2UpLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgcmVmZXJlbmNlICgnY29kZScsICdjZWxsJywgJ2ZpbGUnLCAnZGlyJykuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVmZXJlbmNlIChDb2RlUmVmRGF0YSwgcGF0aCBzdHJpbmcsIGV0Yy4pLlxuICogQHBhcmFtIHJlZklkIC0gT3B0aW9uYWwgcmVmZXJlbmNlIElEIChlLmcuLCAncmVmLTEnKSB0byBzdG9yZSBvbiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIEFuIEhUTUxFbGVtZW50IHJlcHJlc2VudGluZyB0aGUgd2lkZ2V0LlxuICovXG5mdW5jdGlvbiByZW5kZXJSZWZlcmVuY2VXaWRnZXRJbmxpbmUodHlwZSwgZGF0YSwgLy8gc3RyaW5nIGZvciBmaWxlL2RpciBwYXRoc1xucGxhY2Vob2xkZXIsIC8vIEFEREVEOiBUaGUgb3JpZ2luYWwgcGxhY2Vob2xkZXIgdGV4dCAoZS5nLiwgQGNvZGVbcmVmLTFdKVxucmVmSWQgLy8gS2VlcCByZWZJZCBzZXBhcmF0ZSBmb3IgbWFwIGxvb2t1cHMgaWYgbmVlZGVkXG4pIHtcbiAgICBjb25zdCB3aWRnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgd2lkZ2V0LmNsYXNzTGlzdC5hZGQoJ2pwLWxsbS1leHQtcmVmLXdpZGdldCcsIGBqcC1sbG0tZXh0LXJlZi0ke3R5cGV9YCk7XG4gICAgd2lkZ2V0LmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7IC8vIE1ha2UgdGhlIHdpZGdldCBub24tZWRpdGFibGUgaXRzZWxmXG4gICAgd2lkZ2V0LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJzsgLy8gRW5zdXJlIGl0IGJlaGF2ZXMgbGlrZSBhIGJsb2NrIGZvciBzdHlsaW5nL3NlbGVjdGlvblxuICAgIHdpZGdldC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7IC8vIENoYW5nZSBjdXJzb3IgdG8gcG9pbnRlciB0byBpbmRpY2F0ZSBjbGlja2FiaWxpdHlcbiAgICB3aWRnZXQuZGF0YXNldC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyOyAvLyBBRERFRDogU3RvcmUgdGhlIHBsYWNlaG9sZGVyXG4gICAgY29uc3QgZGlzcGxheVRleHRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyAvLyBTcGFuIGZvciB0aGUgbWFpbiB0ZXh0XG4gICAgY29uc3QgcHJldmlld0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBEaXYgZm9yIHRoZSBwcmV2aWV3IGNvbnRlbnRcbiAgICBwcmV2aWV3RGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXJlZi1wcmV2aWV3JztcbiAgICBwcmV2aWV3RGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICBwcmV2aWV3RGl2LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tanAtYm9yZGVyLWNvbG9yMSknO1xuICAgIHByZXZpZXdEaXYuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgIHByZXZpZXdEaXYuc3R5bGUubWFyZ2luVG9wID0gJzJweCc7XG4gICAgcHJldmlld0Rpdi5zdHlsZS5mb250U2l6ZSA9ICcwLjllbSc7XG4gICAgcHJldmlld0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndmFyKC0tanAtbGF5b3V0LWNvbG9yMCknO1xuICAgIHByZXZpZXdEaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7IC8vIFByZXNlcnZlIGxpbmUgYnJlYWtzXG4gICAgcHJldmlld0Rpdi5zdHlsZS5mb250RmFtaWx5ID0gJ21vbm9zcGFjZSc7XG4gICAgcHJldmlld0Rpdi5zdHlsZS5jdXJzb3IgPSAndGV4dCc7IC8vIEtlZXAgdGV4dCBjdXJzb3IgZm9yIHByZXZpZXdcbiAgICBsZXQgZGlzcGxheVRleHQgPSAnJztcbiAgICBsZXQgYmFzZVRpdGxlID0gJyc7IC8vIFRvb2x0aXAgZm9yIHRoZSBtYWluIHdpZGdldCB0ZXh0LCB3aXRob3V0IHByZXZpZXdcbiAgICBsZXQgcHJldmlld0NvbnRlbnQgPSAnJztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgIGNhc2UgJ2NlbGwnOiB7IC8vIENvbWJpbmUgbG9naWMgZm9yIGNvZGUgYW5kIGNlbGwgcHJldmlld3NcbiAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgY29uc3QgaXNDb2RlID0gdHlwZSA9PT0gJ2NvZGUnO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSByZWZEYXRhLmxpbmVOdW1iZXIgPT09IHJlZkRhdGEubGluZUVuZE51bWJlclxuICAgICAgICAgICAgICAgID8gYEwke3JlZkRhdGEubGluZU51bWJlcn1gXG4gICAgICAgICAgICAgICAgOiBgTCR7cmVmRGF0YS5saW5lTnVtYmVyfS0ke3JlZkRhdGEubGluZUVuZE51bWJlcn1gO1xuICAgICAgICAgICAgZGlzcGxheVRleHQgPSBpc0NvZGVcbiAgICAgICAgICAgICAgICA/IGBAY29kZSAoJHtyZWZEYXRhLm5vdGVib29rTmFtZX06JHtsaW5lc30pYFxuICAgICAgICAgICAgICAgIDogYEBDZWxsICgke3JlZkRhdGEubm90ZWJvb2tOYW1lfTpDZWxsICR7cmVmRGF0YS5jZWxsSW5kZXggKyAxfSlgO1xuICAgICAgICAgICAgYmFzZVRpdGxlID0gaXNDb2RlXG4gICAgICAgICAgICAgICAgPyBgQ29kZTogJHtyZWZEYXRhLm5vdGVib29rTmFtZX0sIENlbGwgJHtyZWZEYXRhLmNlbGxJbmRleCArIDF9LCAke2xpbmVzfWBcbiAgICAgICAgICAgICAgICA6IGBDZWxsOiAke3JlZkRhdGEubm90ZWJvb2tOYW1lfSwgSW5kZXggJHtyZWZEYXRhLmNlbGxJbmRleCArIDF9YDtcbiAgICAgICAgICAgIGlmIChyZWZJZClcbiAgICAgICAgICAgICAgICB3aWRnZXQuZGF0YXNldC5yZWZJZCA9IHJlZklkO1xuICAgICAgICAgICAgd2lkZ2V0LmRhdGFzZXQubm90ZWJvb2tOYW1lID0gcmVmRGF0YS5ub3RlYm9va05hbWU7XG4gICAgICAgICAgICB3aWRnZXQuZGF0YXNldC5jZWxsSW5kZXggPSBTdHJpbmcocmVmRGF0YS5jZWxsSW5kZXgpO1xuICAgICAgICAgICAgd2lkZ2V0LmRhdGFzZXQuY29udGVudCA9IHJlZkRhdGEuY29udGVudDsgLy8gU3RvcmUgY29udGVudFxuICAgICAgICAgICAgaWYgKGlzQ29kZSkge1xuICAgICAgICAgICAgICAgIHdpZGdldC5kYXRhc2V0LnN0YXJ0TGluZSA9IFN0cmluZyhyZWZEYXRhLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHdpZGdldC5kYXRhc2V0LmVuZExpbmUgPSBTdHJpbmcocmVmRGF0YS5saW5lRW5kTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXBhcmUgcHJldmlldyBjb250ZW50XG4gICAgICAgICAgICBpZiAocmVmRGF0YS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudExpbmVzID0gcmVmRGF0YS5jb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBwcmV2aWV3Q29udGVudCA9IGNvbnRlbnRMaW5lcy5zbGljZSgwLCAzKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudExpbmVzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlld0NvbnRlbnQgKz0gJ1xcbi4uLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGVQYXRoLnNwbGl0KC9bXFwvXFxcXF0vKS5wb3AoKSB8fCBmaWxlUGF0aDsgLy8gSGFuZGxlIHdpbmRvd3MgcGF0aHNcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ID0gYEBmaWxlICgke2ZpbGVOYW1lfSlgO1xuICAgICAgICAgICAgYmFzZVRpdGxlID0gYEZpbGU6ICR7ZmlsZVBhdGh9YDsgLy8gVG9vbHRpcCBzaG93cyBmdWxsIHBhdGhcbiAgICAgICAgICAgIHdpZGdldC5kYXRhc2V0LnBhdGggPSBmaWxlUGF0aDsgLy8gU3RvcmUgZnVsbCBwYXRoXG4gICAgICAgICAgICAvLyBObyBwcmV2aWV3IGZvciBmaWxlcy9kaXJzXG4gICAgICAgICAgICB3aWRnZXQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnOyAvLyBObyBleHBhbnNpb24gZm9yIGZpbGUvZGlyXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGlyJzpcbiAgICAgICAgICAgIGNvbnN0IGRpclBhdGggPSBkYXRhO1xuICAgICAgICAgICAgY29uc3QgZGlyTmFtZSA9IGRpclBhdGguc3BsaXQoL1tcXC9cXFxcXS8pLnBvcCgpIHx8IGRpclBhdGggfHwgJy8nOyAvLyBIYW5kbGUgd2luZG93cyBwYXRoc1xuICAgICAgICAgICAgZGlzcGxheVRleHQgPSBgQGRpciAoJHtkaXJOYW1lfSlgO1xuICAgICAgICAgICAgYmFzZVRpdGxlID0gYERpcmVjdG9yeTogJHtkaXJQYXRofWA7IC8vIFRvb2x0aXAgc2hvd3MgZnVsbCBwYXRoXG4gICAgICAgICAgICB3aWRnZXQuZGF0YXNldC5wYXRoID0gZGlyUGF0aDsgLy8gU3RvcmUgZnVsbCBwYXRoXG4gICAgICAgICAgICAvLyBObyBwcmV2aWV3IGZvciBmaWxlcy9kaXJzXG4gICAgICAgICAgICB3aWRnZXQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnOyAvLyBObyBleHBhbnNpb24gZm9yIGZpbGUvZGlyXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ID0gJ0B1bmtub3duLXJlZic7XG4gICAgICAgICAgICBiYXNlVGl0bGUgPSAnVW5rbm93biBSZWZlcmVuY2UnO1xuICAgICAgICAgICAgd2lkZ2V0LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICB9XG4gICAgZGlzcGxheVRleHRTcGFuLnRleHRDb250ZW50ID0gZGlzcGxheVRleHQ7XG4gICAgd2lkZ2V0LnRpdGxlID0gYmFzZVRpdGxlOyAvLyBTZXQgYmFzZSB0b29sdGlwIGZvciB0aGUgbWFpbiBwYXJ0XG4gICAgd2lkZ2V0LmFwcGVuZENoaWxkKGRpc3BsYXlUZXh0U3Bhbik7XG4gICAgLy8gQWRkIHByZXZpZXcgZGl2IGFuZCBjbGljayBsaXN0ZW5lciBvbmx5IGlmIHRoZXJlJ3MgcHJldmlldyBjb250ZW50XG4gICAgaWYgKHByZXZpZXdDb250ZW50KSB7XG4gICAgICAgIHByZXZpZXdEaXYudGV4dENvbnRlbnQgPSBwcmV2aWV3Q29udGVudDtcbiAgICAgICAgd2lkZ2V0LmFwcGVuZENoaWxkKHByZXZpZXdEaXYpO1xuICAgICAgICAvLyBBZGQgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIG1haW4gd2lkZ2V0IHNwYW4gdG8gdG9nZ2xlIHByZXZpZXdcbiAgICAgICAgd2lkZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSBjbGljayBmcm9tIHByb3BhZ2F0aW5nIHRvIHRoZSBpbnB1dCBkaXYgbGlzdGVuZXIgaWYgbmVlZGVkXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSGlkZGVuID0gcHJldmlld0Rpdi5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZSc7XG4gICAgICAgICAgICBwcmV2aWV3RGl2LnN0eWxlLmRpc3BsYXkgPSBpc0hpZGRlbiA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICAgICAgICAvLyBPcHRpb25hbDogQ2hhbmdlIGFuIGluZGljYXRvciBpY29uIGhlcmVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFByZXZlbnQgY2xpY2tzICppbnNpZGUqIHRoZSBwcmV2aWV3IGRpdiBmcm9tIGNsb3NpbmcgaXRcbiAgICAgICAgcHJldmlld0Rpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRW5zdXJlIGN1cnNvciByZW1haW5zIGRlZmF1bHQgaWYgbm8gcHJldmlldy9leHBhbnNpb25cbiAgICAgICAgd2lkZ2V0LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICB9XG4gICAgcmV0dXJuIHdpZGdldDtcbn1cbi8vIFBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb25zOlxuLy8gLSByZW5kZXJFcnJvck1lc3NhZ2Vcbi8vIC0gcmVuZGVyU3lzdGVtTWVzc2FnZVxuLy8gLSBBIG1haW4gcmVuZGVyTWVzc2FnZSBmdW5jdGlvbiB0aGF0IGRlbGVnYXRlcyBiYXNlZCBvbiB0eXBlPyBcbi8qKlxuICogSGFuZGxlcyByZW5kZXJpbmcgaW5kaXZpZHVhbCBtZXNzYWdlcyAodXNlciwgYm90LCBzeXN0ZW0pIGludG8gSFRNTCBlbGVtZW50cy5cbiAqL1xuY2xhc3MgTWVzc2FnZVJlbmRlcmVyIHtcbiAgICAvLyBwcml2YXRlIGNhbGxiYWNrczogTWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzOyAvLyBSZW1vdmVkIHVudXNlZCBtZW1iZXJcbiAgICAvLyBwcml2YXRlIHVpTWFuYWdlcjogVUlNYW5hZ2VyOyAvLyBNaWdodCBub3QgYmUgbmVlZGVkIGRpcmVjdGx5IGlmIGNhbGxiYWNrcyBoYW5kbGUgVUkgdXBkYXRlc1xuICAgIGNvbnN0cnVjdG9yKCAvKiBjYWxsYmFja3M6IE1lc3NhZ2VSZW5kZXJlckNhbGxiYWNrcyAqLyAvKiAsIHVpTWFuYWdlcjogVUlNYW5hZ2VyICovKSB7XG4gICAgICAgIC8vIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzOyAvLyBSZW1vdmVkIHVudXNlZCBhc3NpZ25tZW50XG4gICAgICAgIC8vIHRoaXMudWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZVJlbmRlcmVyID0gTWVzc2FnZVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU5vdGVNb2RhbEVsZW1lbnQgPSBjcmVhdGVOb3RlTW9kYWxFbGVtZW50O1xuLyoqXG4gKiBDcmVhdGVzIGEgbm90ZSBtb2RhbCBlbGVtZW50LlxuICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBtb2RhbCBhY3Rpb25zLlxuICogQHBhcmFtIGluaXRpYWxUaXRsZSBPcHRpb25hbCBpbml0aWFsIHRpdGxlIGZvciBlZGl0aW5nLlxuICogQHBhcmFtIGluaXRpYWxDb250ZW50IE9wdGlvbmFsIGluaXRpYWwgY29udGVudCBmb3IgZWRpdGluZy5cbiAqIEByZXR1cm5zIFRoZSBtb2RhbCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb3RlTW9kYWxFbGVtZW50KGNhbGxiYWNrcywgaW5pdGlhbFRpdGxlID0gJycsIGluaXRpYWxDb250ZW50ID0gJycpIHtcbiAgICAvLyBDcmVhdGUgYmFja2Ryb3AgZm9yIHRoZSBtb2RhbFxuICAgIGNvbnN0IG1vZGFsQmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtb2RhbEJhY2tkcm9wLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtbW9kYWwtYmFja2Ryb3AnO1xuICAgIC8vIENyZWF0ZSBtb2RhbCBjb250YWluZXJcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG1vZGFsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtbW9kYWwnO1xuICAgIC8vIENyZWF0ZSBtb2RhbCBjb250ZW50XG4gICAgY29uc3QgbW9kYWxDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbW9kYWxDb250ZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtbW9kYWwtY29udGVudCc7XG4gICAgLy8gQ3JlYXRlIG1vZGFsIHRpdGxlXG4gICAgY29uc3QgbW9kYWxUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgbW9kYWxUaXRsZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLW1vZGFsLXRpdGxlJztcbiAgICBtb2RhbFRpdGxlLnRleHRDb250ZW50ID0gaW5pdGlhbFRpdGxlID8gJ0VkaXQgTm90ZScgOiAnQWRkIE5ldyBOb3RlJztcbiAgICBtb2RhbENvbnRlbnQuYXBwZW5kQ2hpbGQobW9kYWxUaXRsZSk7XG4gICAgLy8gQ3JlYXRlIGZvcm1cbiAgICBjb25zdCBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIGZvcm0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbm90ZS1tb2RhbC1mb3JtJztcbiAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgdGl0bGVJbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcignLmpwLWxsbS1leHQtbm90ZS1tb2RhbC1pbnB1dCcpO1xuICAgICAgICBjb25zdCBjb250ZW50VGV4dGFyZWEgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LW5vdGUtbW9kYWwtdGV4dGFyZWEnKTtcbiAgICAgICAgaWYgKHRpdGxlSW5wdXQgJiYgY29udGVudFRleHRhcmVhKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MuaGFuZGxlU2F2ZSh0aXRsZUlucHV0LnZhbHVlLCBjb250ZW50VGV4dGFyZWEudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQ3JlYXRlIHRpdGxlIGlucHV0XG4gICAgY29uc3QgdGl0bGVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdGl0bGVMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLW1vZGFsLWxhYmVsJztcbiAgICB0aXRsZUxhYmVsLnRleHRDb250ZW50ID0gJ1RpdGxlJztcbiAgICB0aXRsZUxhYmVsLmh0bWxGb3IgPSAnbm90ZS10aXRsZS1pbnB1dCc7XG4gICAgY29uc3QgdGl0bGVJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGl0bGVJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLW1vZGFsLWlucHV0JztcbiAgICB0aXRsZUlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgdGl0bGVJbnB1dC5pZCA9ICdub3RlLXRpdGxlLWlucHV0JztcbiAgICB0aXRsZUlucHV0LnBsYWNlaG9sZGVyID0gJ0VudGVyIG5vdGUgdGl0bGUnO1xuICAgIHRpdGxlSW5wdXQudmFsdWUgPSBpbml0aWFsVGl0bGU7XG4gICAgdGl0bGVJbnB1dC5yZXF1aXJlZCA9IHRydWU7XG4gICAgLy8gQ3JlYXRlIGNvbnRlbnQgdGV4dGFyZWFcbiAgICBjb25zdCBjb250ZW50TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGNvbnRlbnRMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLW1vZGFsLWxhYmVsJztcbiAgICBjb250ZW50TGFiZWwudGV4dENvbnRlbnQgPSAnQ29udGVudCAoTWFya2Rvd24gc3VwcG9ydGVkKSc7XG4gICAgY29udGVudExhYmVsLmh0bWxGb3IgPSAnbm90ZS1jb250ZW50LXRleHRhcmVhJztcbiAgICBjb25zdCBjb250ZW50VGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIGNvbnRlbnRUZXh0YXJlYS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ub3RlLW1vZGFsLXRleHRhcmVhJztcbiAgICBjb250ZW50VGV4dGFyZWEuaWQgPSAnbm90ZS1jb250ZW50LXRleHRhcmVhJztcbiAgICBjb250ZW50VGV4dGFyZWEucGxhY2Vob2xkZXIgPSAnRW50ZXIgbm90ZSBjb250ZW50IChzdXBwb3J0cyBNYXJrZG93biknO1xuICAgIGNvbnRlbnRUZXh0YXJlYS52YWx1ZSA9IGluaXRpYWxDb250ZW50O1xuICAgIGNvbnRlbnRUZXh0YXJlYS5yZXF1aXJlZCA9IHRydWU7XG4gICAgY29udGVudFRleHRhcmVhLnJvd3MgPSAxMDtcbiAgICAvLyBDcmVhdGUgYnV0dG9uc1xuICAgIGNvbnN0IGJ1dHRvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidXR0b25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW5vdGUtbW9kYWwtYnV0dG9ucyc7XG4gICAgY29uc3QgY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1ub3RlLW1vZGFsLWNhbmNlbCc7XG4gICAgY2FuY2VsQnV0dG9uLnRleHRDb250ZW50ID0gJ0NhbmNlbCc7XG4gICAgY2FuY2VsQnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcbiAgICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrcy5oYW5kbGVDYW5jZWwoKTtcbiAgICB9KTtcbiAgICBjb25zdCBzYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtbm90ZS1tb2RhbC1zYXZlJztcbiAgICBzYXZlQnV0dG9uLnRleHRDb250ZW50ID0gJ1NhdmUnO1xuICAgIHNhdmVCdXR0b24udHlwZSA9ICdzdWJtaXQnO1xuICAgIC8vIEFkZCBlbGVtZW50cyB0byBmb3JtXG4gICAgZm9ybS5hcHBlbmRDaGlsZCh0aXRsZUxhYmVsKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHRpdGxlSW5wdXQpO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY29udGVudExhYmVsKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKGNvbnRlbnRUZXh0YXJlYSk7XG4gICAgYnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW5jZWxCdXR0b24pO1xuICAgIGJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoc2F2ZUJ1dHRvbik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChidXR0b25zQ29udGFpbmVyKTtcbiAgICBtb2RhbENvbnRlbnQuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgbW9kYWwuYXBwZW5kQ2hpbGQobW9kYWxDb250ZW50KTtcbiAgICBtb2RhbEJhY2tkcm9wLmFwcGVuZENoaWxkKG1vZGFsKTtcbiAgICAvLyBBdXRvLWZvY3VzIHRoZSB0aXRsZSBpbnB1dCB3aGVuIHRoZSBtb2RhbCBpcyBzaG93blxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aXRsZUlucHV0LmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuIG1vZGFsQmFja2Ryb3A7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2V0dGluZ3NNb2RhbCA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQgPSBjcmVhdGVTZXR0aW5nc01vZGFsRWxlbWVudDtcbi8qKlxuICogQ3JlYXRlcyB0aGUgSFRNTCBlbGVtZW50IGZvciB0aGUgc2V0dGluZ3MgbW9kYWwuXG4gKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3Igc2F2ZSBhbmQgY2FuY2VsIGFjdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgbWFpbiBtb2RhbCBIVE1MRWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQoY2FsbGJhY2tzKSB7XG4gICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtb2RhbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1tb2RhbCc7XG4gICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pdGlhbGx5IGhpZGRlblxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWNvbnRlbnQnO1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICB0aXRsZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy10aXRsZSc7XG4gICAgdGl0bGUudGV4dENvbnRlbnQgPSAnU2V0dGluZ3MnO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgZm9ybS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1mb3JtJztcbiAgICAvLyBQcm92aWRlciBzZWxlY3Rpb25cbiAgICBjb25zdCBwcm92aWRlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBwcm92aWRlckxhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICBwcm92aWRlckxhYmVsLnRleHRDb250ZW50ID0gJ0FQSSBQcm92aWRlcjonO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQocHJvdmlkZXJMYWJlbCk7XG4gICAgY29uc3QgcHJvdmlkZXJTZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBwcm92aWRlclNlbGVjdC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1zZWxlY3QnO1xuICAgIHByb3ZpZGVyU2VsZWN0LmlkID0gJ3NldHRpbmdzLXByb3ZpZGVyJzsgLy8gS2VlcCBJRCBmb3IgcmV0cmlldmFsXG4gICAgWydPcGVuQUknLCAnSHVnZ2luZ0ZhY2UnLCAnTG9jYWwnXS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBvcHQ7XG4gICAgICAgIG9wdGlvbi50ZXh0Q29udGVudCA9IG9wdDtcbiAgICAgICAgcHJvdmlkZXJTZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9KTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHByb3ZpZGVyU2VsZWN0KTtcbiAgICAvLyBBUEkgS2V5IGlucHV0XG4gICAgY29uc3QgYXBpS2V5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGFwaUtleUxhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICBhcGlLZXlMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgS2V5Oic7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcGlLZXlMYWJlbCk7XG4gICAgY29uc3QgYXBpS2V5SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGFwaUtleUlucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWlucHV0JztcbiAgICBhcGlLZXlJbnB1dC50eXBlID0gJ3Bhc3N3b3JkJztcbiAgICBhcGlLZXlJbnB1dC5pZCA9ICdzZXR0aW5ncy1hcGkta2V5JzsgLy8gS2VlcCBJRCBmb3IgcmV0cmlldmFsXG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcGlLZXlJbnB1dCk7XG4gICAgLy8gQVBJIFVSTCBpbnB1dFxuICAgIGNvbnN0IGFwaVVybExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBhcGlVcmxMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgYXBpVXJsTGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIFVSTCAob3B0aW9uYWwpOic7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcGlVcmxMYWJlbCk7XG4gICAgY29uc3QgYXBpVXJsSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGFwaVVybElucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWlucHV0JztcbiAgICBhcGlVcmxJbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIGFwaVVybElucHV0LmlkID0gJ3NldHRpbmdzLWFwaS11cmwnOyAvLyBLZWVwIElEIGZvciByZXRyaWV2YWxcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFwaVVybElucHV0KTtcbiAgICAvLyBSdWxlcyBpbnB1dFxuICAgIGNvbnN0IHJ1bGVzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHJ1bGVzTGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgIHJ1bGVzTGFiZWwudGV4dENvbnRlbnQgPSAnQ3VzdG9tIFJ1bGVzIChvcHRpb25hbCk6JztcbiAgICBmb3JtLmFwcGVuZENoaWxkKHJ1bGVzTGFiZWwpO1xuICAgIGNvbnN0IHJ1bGVzSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHJ1bGVzSW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtdGV4dGFyZWEnO1xuICAgIHJ1bGVzSW5wdXQuaWQgPSAnc2V0dGluZ3MtcnVsZXMnOyAvLyBLZWVwIElEIGZvciByZXRyaWV2YWxcbiAgICBmb3JtLmFwcGVuZENoaWxkKHJ1bGVzSW5wdXQpO1xuICAgIC8vIEJ1dHRvbnMgY29udGFpbmVyXG4gICAgY29uc3QgYnRuQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYnRuQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWJ1dHRvbnMnO1xuICAgIGNvbnN0IHNhdmVCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBzYXZlQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWJ1dHRvbiBqcC1sbG0tZXh0LXNldHRpbmdzLXNhdmUtYnV0dG9uJztcbiAgICBzYXZlQnRuLnRleHRDb250ZW50ID0gJ1NhdmUnO1xuICAgIHNhdmVCdG4udHlwZSA9ICdidXR0b24nOyAvLyBQcmV2ZW50IGRlZmF1bHQgZm9ybSBzdWJtaXNzaW9uXG4gICAgc2F2ZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgaW1wbGVtZW50YXRpb24gd2lsbCBoYW5kbGUgcmVhZGluZyB2YWx1ZXMgYW5kIHNhdmluZ1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIGFwaUtleTogYXBpS2V5SW5wdXQudmFsdWUsXG4gICAgICAgICAgICBhcGlVcmw6IGFwaVVybElucHV0LnZhbHVlLFxuICAgICAgICAgICAgcnVsZXM6IHJ1bGVzSW5wdXQudmFsdWUsXG4gICAgICAgICAgICBwcm92aWRlcjogcHJvdmlkZXJTZWxlY3QudmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tzLmhhbmRsZVNhdmUoc2V0dGluZ3MpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGNhbmNlbEJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1idXR0b24ganAtbGxtLWV4dC1zZXR0aW5ncy1jYW5jZWwtYnV0dG9uJztcbiAgICBjYW5jZWxCdG4udGV4dENvbnRlbnQgPSAnQ2FuY2VsJztcbiAgICBjYW5jZWxCdG4udHlwZSA9ICdidXR0b24nOyAvLyBQcmV2ZW50IGRlZmF1bHQgZm9ybSBzdWJtaXNzaW9uXG4gICAgY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbGxiYWNrcy5oYW5kbGVDYW5jZWwoKTtcbiAgICB9KTtcbiAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoc2F2ZUJ0bik7XG4gICAgYnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbmNlbEJ0bik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChidG5Db250YWluZXIpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgbW9kYWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgcmV0dXJuIG1vZGFsO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuZCBtYW5hZ2VzIHRoZSBzZXR0aW5ncyBtb2RhbCBkaWFsb2cuXG4gKi9cbmNsYXNzIFNldHRpbmdzTW9kYWwge1xuICAgIC8vIHByaXZhdGUgbW9kYWxFbGVtZW50OiBIVE1MRGl2RWxlbWVudDsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZFxuICAgIC8vIHByaXZhdGUgc2V0dGluZ3M6IEFwcFNldHRpbmdzOyAvLyBDb21tZW50ZWQgb3V0IC0gdW51c2VkXG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIHRoaXMubW9kYWxFbGVtZW50ID0gY3JlYXRlU2V0dGluZ3NNb2RhbEVsZW1lbnQoY2FsbGJhY2tzKTsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZCBhc3NpZ25tZW50XG4gICAgICAgIC8vIHRoaXMuc2V0dGluZ3MgPSB7IC8vIENvbW1lbnRlZCBvdXQgLSB1bnVzZWQgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgLy8gICAgIHByb3ZpZGVyOiAnJywgXG4gICAgICAgIC8vICAgICBhcGlLZXk6ICcnLCBcbiAgICAgICAgLy8gICAgIGFwaVVybDogJycsIFxuICAgICAgICAvLyAgICAgcnVsZXM6ICcnIFxuICAgICAgICAvLyB9OyBcbiAgICB9XG59XG5leHBvcnRzLlNldHRpbmdzTW9kYWwgPSBTZXR0aW5nc01vZGFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVJTWFuYWdlciA9IHZvaWQgMDtcbi8qKlxuICogTWFuYWdlcyBVSSBlbGVtZW50cyBhbmQgdHJhbnNpdGlvbnMgZm9yIHRoZSBjaGF0IGludGVyZmFjZS5cbiAqIFRoaXMgYWN0cyBhcyBhIGNlbnRyYWwgcG9pbnQgZm9yIFVJIG1hbmlwdWxhdGlvbnMsIHNpbXBsaWZ5aW5nIGRlcGVuZGVuY2llcyBmb3IgaGFuZGxlcnMuXG4gKi9cbmNsYXNzIFVJTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocG9wdXBNZW51TWFuYWdlciwgY2FsbGJhY2tzLCBsYXlvdXRFbGVtZW50cykge1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSBudWxsOyAvLyBUaW1lb3V0IGZvciB0aGUgc2hvcnRjdXQgaW5kaWNhdG9yXG4gICAgICAgIC8vIEludGVybmFsIFVJIHN0YXRlXG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyID0gcG9wdXBNZW51TWFuYWdlcjtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMgPSBsYXlvdXRFbGVtZW50czsgLy8gU3RvcmUgdGhlIGxheW91dCBlbGVtZW50cyBwYXNzZWQgaW5cbiAgICAgICAgLy8gQXNzaWduIGNsYXNzIHByb3BlcnRpZXMgZGlyZWN0bHkgZnJvbSB0aGUgcGFzc2VkIGxheW91dEVsZW1lbnRzXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IGxheW91dEVsZW1lbnRzLmlucHV0RmllbGQ7IC8vIFVzZSBwcm92aWRlZCBpbnB1dCBmaWVsZFxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIgPSBsYXlvdXRFbGVtZW50cy5tZXNzYWdlQ29udGFpbmVyO1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIgPSBsYXlvdXRFbGVtZW50cy5oaXN0b3J5Q29udGFpbmVyO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQgPSBsYXlvdXRFbGVtZW50cy50aXRsZUlucHV0O1xuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lciA9IGxheW91dEVsZW1lbnRzLmJvdHRvbUJhckNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5ub3Rlc0NvbnRhaW5lciA9IGxheW91dEVsZW1lbnRzLm5vdGVzQ29udGFpbmVyO1xuICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBhcHBlbmQgdGhlIGtleWJvYXJkIHNob3J0Y3V0IGluZGljYXRvclxuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNob3J0Y3V0LWluZGljYXRvcic7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBIaWRkZW4gYnkgZGVmYXVsdFxuICAgICAgICAvLyBBcHBlbmQgdGhlIGluZGljYXRvciB0byB0aGUgbWFpbiBsYXlvdXQgb3IgYW5vdGhlciBhcHByb3ByaWF0ZSBwbGFjZVxuICAgICAgICAvLyBFbnN1cmUgdGhlIG5lY2Vzc2FyeSBlbGVtZW50IChlLmcuLCBib3R0b21CYXJDb250YWluZXIpIGV4aXN0cyBiZWZvcmUgYXBwZW5kaW5nXG4gICAgICAgIGlmICh0aGlzLmJvdHRvbUJhckNvbnRhaW5lcikgeyAvLyBDaGVjayBpZiBib3R0b21CYXJDb250YWluZXIgZXhpc3RzIGZyb20gbGF5b3V0RWxlbWVudHNcbiAgICAgICAgICAgIC8vIFByZXBlbmQgd2l0aGluIHRoZSBtYWluIGNvbnRlbnQgd3JhcHBlciwgYmVmb3JlIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBPciBhcHBlbmQgdG8gYm90dG9tIGJhciwgZGVwZW5kaW5nIG9uIGRlc2lyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIEFwcGVuZGluZyBhZnRlciBib3R0b21CYXJDb250YWluZXIgc2VlbXMgcmVhc29uYWJsZVxuICAgICAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBib3R0b21CYXJDb250YWluZXIgaXMgbm90IGF2YWlsYWJsZSwgbWF5YmUgYXBwZW5kIHRvIG1haW5FbGVtZW50PyBcbiAgICAgICAgICAgIC8vIE9yIGxvZyBhbiBlcnJvciBpZiBpdCdzIGVzc2VudGlhbC5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VJTWFuYWdlcjogYm90dG9tQmFyQ29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kIGR1cmluZyBpbmRpY2F0b3IgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29yZSBsYXlvdXQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZ2V0VUlFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0RWxlbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1haW4gbGF5b3V0IHN0cnVjdHVyZSBmb3IgdGhlIHNpZGViYXIuXG4gICAgICogQHJldHVybnMgUmVmZXJlbmNlcyB0byBrZXkgRE9NIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYWluQ29udGVudC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb250ZW50LXdyYXBwZXInO1xuICAgICAgICAvLyAtLS0gVGl0bGUgQ29udGFpbmVyIC0tLVxuICAgICAgICBjb25zdCB0aXRsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aXRsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10aXRsZS1jb250YWluZXInO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQuY2xhc3NOYW1lID0gJ2NoYXQtdGl0bGUtaW5wdXQnO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnBsYWNlaG9sZGVyID0gJ0NoYXQgdGl0bGUnO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSAnTmV3IENoYXQnOyAvLyBEZWZhdWx0IHZhbHVlLCB3aWRnZXQgbWlnaHQgdXBkYXRlIGxhdGVyXG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmNhbGxiYWNrcy5oYW5kbGVVcGRhdGVUaXRsZSk7XG4gICAgICAgIHRpdGxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGl0bGVJbnB1dCk7XG4gICAgICAgIC8vIC0tLSBNZXNzYWdlICYgSGlzdG9yeSBDb250YWluZXJzIC0tLVxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgICAgIC8vIC0tLSBCb3R0b20gQmFyIC0tLVxuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENvbnRyb2xzIFJvdyAoTWFya2Rvd24gVG9nZ2xlLCBBY3Rpb24gQnV0dG9ucylcbiAgICAgICAgY29uc3QgdG9wUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvcFJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWNvbnRyb2xzLXJvdyc7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpOyAvLyBDcmVhdGVzIG1hcmtkb3duIHRvZ2dsZSwgQCwgZXhwYW5kLCBzZXR0aW5nc1xuICAgICAgICB0b3BSb3cuYXBwZW5kQ2hpbGQoY29udHJvbHNDb250YWluZXIpO1xuICAgICAgICAvLyBJbnB1dCBSb3dcbiAgICAgICAgY29uc3QgbWlkZGxlUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1pZGRsZVJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWlucHV0LXJvdyc7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RleHRib3gnKTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1tdWx0aWxpbmUnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlaG9sZGVyJywgJ0FzayBtZSBhbnl0aGluZy4uLicpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtZmllbGQnO1xuICAgICAgICAvLyAtLS0gSW5wdXQgRXZlbnQgTGlzdGVuZXIgZm9yIEAgZGV0ZWN0aW9uIC0tLVxuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5wdXRGb3JSZWZlcmVuY2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLSBFbmQgSW5wdXQgRXZlbnQgTGlzdGVuZXIgLS0tXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVUlfTUFOQUdFUiBLZXlEb3duOiBLZXk9JyR7ZXZlbnQua2V5fScsIFNoaWZ0PScke2V2ZW50LnNoaWZ0S2V5fScsIENvZGU9JyR7ZXZlbnQuY29kZX0nYCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAvLyAtLS0gQmFja3NwYWNlIGhhbmRsaW5nIGZvciB3aWRnZXRzIC0tLVxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0JhY2tzcGFjZScgJiYgc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUJlZm9yZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbcmFuZ2Uuc3RhcnRPZmZzZXQgLSAxXSB8fCByYW5nZS5zdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgbm9kZUJlZm9yZSBtb3JlIGNhcmVmdWxseVxuICAgICAgICAgICAgICAgIGxldCBwb3RlbnRpYWxXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydE9mZnNldCA+IDAgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPj0gcmFuZ2Uuc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsV2lkZ2V0ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tyYW5nZS5zdGFydE9mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5zdGFydE9mZnNldCA9PT0gMCAmJiByYW5nZS5zdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsV2lkZ2V0ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5zdGFydENvbnRhaW5lciAhPT0gdGhpcy5pbnB1dEZpZWxkICYmIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMuaW5wdXRGaWVsZCAmJiByYW5nZS5zdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDdXJzb3IgbWlnaHQgYmUgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlIGZvbGxvd2luZyBhIHdpZGdldFxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxXaWRnZXQgPSByYW5nZS5zdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxXaWRnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsV2lkZ2V0Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJlxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxXaWRnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcC1sbG0tZXh0LXJlZi13aWRnZXQnKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIGRlZmF1bHQgYmFja3NwYWNlXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFdpZGdldC5yZW1vdmUoKTsgLy8gUmVtb3ZlIHRoZSBlbnRpcmUgd2lkZ2V0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgdHJpZ2dlciBpbnB1dCBldmVudCBmb3IgY29uc2lzdGVuY3k/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgZnVydGhlciBwcm9jZXNzaW5nIGZvciB0aGlzIGtleWRvd25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0gRW5kIEJhY2tzcGFjZSBoYW5kbGluZyAtLS1cbiAgICAgICAgICAgIC8vIC0tLSBAIEtleSBEaXJlY3QgSGFuZGxpbmcgLS0tXG4gICAgICAgICAgICAvLyBSRU1PVkVEOiBUaGlzIGxvZ2ljIGlzIG5vdyBjZW50cmFsaXplZCBpbiBzaG9ydGN1dC1oYW5kbGVyLnRzXG4gICAgICAgICAgICAvLyAtLS0gRW5kIEAgS2V5IERpcmVjdCBIYW5kbGluZyAtLS1cbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IG5ld2xpbmUgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0U2VyaWFsaXplZElucHV0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbVUlNYW5hZ2VyXSBTZW5kaW5nIG1lc3NhZ2Ugd2l0aCBtYXJrZG93biBtb2RlOiAke3RoaXMuaXNNYXJrZG93bk1vZGV9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UsIHRoaXMuaXNNYXJrZG93bk1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5wdXRGaWVsZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLSBOZXc6IEhhbmRsZSBUYWIvRXNjYXBlIGZvciBwb3B1cCBpbnRlcmFjdGlvbiAtLS1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucG9wdXBNZW51TWFuYWdlci5pc1BvcHVwTWVudVZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInIHx8IGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dVcCcgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IHRoZSBQb3B1cE1lbnVNYW5hZ2VyJ3MgZG9jdW1lbnQga2V5ZG93biBoYW5kbGVyIG1hbmFnZSB0aGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBqdXN0IG5lZWQgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBpbnB1dCBmaWVsZCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7IC8vIEFsbG93IEVudGVyIHRvIHBvdGVudGlhbGx5IHdvcmsgaWYgbWVudSBkb2Vzbid0IGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHN0b3AgcHJvcGFnYXRpb24gaGVyZTsgbGV0IHRoZSBkb2N1bWVudCBoYW5kbGVyIGluIFBvcHVwTWVudU1hbmFnZXIgcmVjZWl2ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLSBFbmQgTmV3IC0tLVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gLS0tIENvcHkvUGFzdGUgRXZlbnQgTGlzdGVuZXJzIC0tLVxuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb3B5KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXN0ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAtLS0gRW5kIENvcHkvUGFzdGUgLS0tXG4gICAgICAgIG1pZGRsZVJvdy5hcHBlbmRDaGlsZCh0aGlzLmlucHV0RmllbGQpO1xuICAgICAgICAvLyBCdXR0b25zIFJvdyAoU2VuZCwgTmV3IENoYXQsIEhpc3RvcnkpXG4gICAgICAgIGNvbnN0IGJvdHRvbVJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBib3R0b21Sb3cuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYm90dG9tLWJhci1yb3cganAtbGxtLWV4dC1idXR0b25zLXJvdyc7XG4gICAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbignU2VuZCcsICdTZW5kIG1lc3NhZ2UnKTtcbiAgICAgICAgc2VuZEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdqcC1sbG0tZXh0LXNlbmQtYnV0dG9uJyk7IC8vIFNwZWNpZmljIGNsYXNzIGZvciBzZW5kXG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZXRTZXJpYWxpemVkSW5wdXQoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbVUlNYW5hZ2VyXSBTZW5kaW5nIG1lc3NhZ2UgZnJvbSBidXR0b24gY2xpY2sgd2l0aCBtYXJrZG93biBtb2RlOiAke3RoaXMuaXNNYXJrZG93bk1vZGV9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaGFuZGxlU2VuZE1lc3NhZ2UobWVzc2FnZSwgdGhpcy5pc01hcmtkb3duTW9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcklucHV0RmllbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5ld0NoYXRCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbignKyBOZXcgQ2hhdCcsICdTdGFydCBhIG5ldyBjaGF0Jyk7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNhbGxiYWNrcy5oYW5kbGVOZXdDaGF0KTtcbiAgICAgICAgY29uc3QgaGlzdG9yeUJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKCdIaXN0b3J5JywgJ1ZpZXcgY2hhdCBoaXN0b3J5Jyk7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNhbGxiYWNrcy5oYW5kbGVUb2dnbGVIaXN0b3J5KTtcbiAgICAgICAgYm90dG9tUm93LmFwcGVuZENoaWxkKHNlbmRCdXR0b24pO1xuICAgICAgICBib3R0b21Sb3cuYXBwZW5kQ2hpbGQobmV3Q2hhdEJ1dHRvbik7XG4gICAgICAgIGJvdHRvbVJvdy5hcHBlbmRDaGlsZChoaXN0b3J5QnV0dG9uKTtcbiAgICAgICAgLy8gQXNzZW1ibGUgQm90dG9tIEJhclxuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b3BSb3cpO1xuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChtaWRkbGVSb3cpO1xuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChib3R0b21Sb3cpO1xuICAgICAgICAvLyAtLS0gQXNzZW1ibGUgTWFpbiBDb250ZW50IC0tLVxuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZCh0aXRsZUNvbnRhaW5lcik7XG4gICAgICAgIG1haW5Db250ZW50LmFwcGVuZENoaWxkKHRoaXMubWVzc2FnZUNvbnRhaW5lcik7XG4gICAgICAgIG1haW5Db250ZW50LmFwcGVuZENoaWxkKHRoaXMuaGlzdG9yeUNvbnRhaW5lcik7XG4gICAgICAgIG1haW5Db250ZW50LmFwcGVuZENoaWxkKHRoaXMuYm90dG9tQmFyQ29udGFpbmVyKTtcbiAgICAgICAgLy8gUmV0dXJuIHJlZmVyZW5jZXMgdG8ga2V5IGVsZW1lbnRzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYWluTGF5b3V0OiBtYWluQ29udGVudCxcbiAgICAgICAgICAgIG1lc3NhZ2VDb250YWluZXI6IHRoaXMubWVzc2FnZUNvbnRhaW5lcixcbiAgICAgICAgICAgIGlucHV0RmllbGQ6IHRoaXMuaW5wdXRGaWVsZCxcbiAgICAgICAgICAgIHRpdGxlSW5wdXQ6IHRoaXMudGl0bGVJbnB1dCxcbiAgICAgICAgICAgIGhpc3RvcnlDb250YWluZXI6IHRoaXMuaGlzdG9yeUNvbnRhaW5lcixcbiAgICAgICAgICAgIGJvdHRvbUJhckNvbnRhaW5lcjogdGhpcy5ib3R0b21CYXJDb250YWluZXIsXG4gICAgICAgICAgICBub3Rlc0NvbnRhaW5lcjogdGhpcy5ub3Rlc0NvbnRhaW5lcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgY29udHJvbHMgY29udGFpbmVyIHdpdGggdG9nZ2xlcyBhbmQgYWN0aW9uIGJ1dHRvbnMuXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJvbHNDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRyb2xzQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbnRyb2xzLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIC0tLSBNYXJrZG93biBUb2dnbGUgLS0tXG4gICAgICAgIGNvbnN0IHRvZ2dsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdG9nZ2xlLWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMubWFya2Rvd25Ub2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLm1hcmtkb3duVG9nZ2xlLnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICB0aGlzLm1hcmtkb3duVG9nZ2xlLmlkID0gJ21hcmtkb3duLXRvZ2dsZSc7IC8vIEVuc3VyZSB1bmlxdWUgSUQgb3IgaGFuZGxlIGRpZmZlcmVudGx5XG4gICAgICAgIHRoaXMubWFya2Rvd25Ub2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pc01hcmtkb3duTW9kZSA9IHRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtVSU1hbmFnZXJdIE1hcmtkb3duIG1vZGUgY2hhbmdlZCB0bzogJHt0aGlzLmlzTWFya2Rvd25Nb2RlfWApO1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJUZXh0ID0gdGhpcy5pc01hcmtkb3duTW9kZVxuICAgICAgICAgICAgICAgID8gJ1dyaXRlIG1hcmtkb3duIGhlcmUuLi5cXFxcblxcXFxuIyBFeGFtcGxlIGhlYWRpbmdcXFxcbi0gTGlzdCBpdGVtXFxcXG5cXFxcbmBgYGNvZGUgYmxvY2tgYGAnXG4gICAgICAgICAgICAgICAgOiAnQXNrIG1lIGFueXRoaW5nLi4uJztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInLCBwbGFjZWhvbGRlclRleHQpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmJsdXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9nZ2xlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICB0b2dnbGVMYWJlbC5odG1sRm9yID0gJ21hcmtkb3duLXRvZ2dsZSc7XG4gICAgICAgIHRvZ2dsZUxhYmVsLnRleHRDb250ZW50ID0gJ01hcmtkb3duIG1vZGUnO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5tYXJrZG93blRvZ2dsZSk7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b2dnbGVMYWJlbCk7XG4gICAgICAgIC8vIC0tLSBBY3Rpb24gQnV0dG9ucyAoQCwgRXhwYW5kLCBTZXR0aW5ncykgLS0tXG4gICAgICAgIGNvbnN0IGFjdGlvbkJ1dHRvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1hY3Rpb24tYnV0dG9ucy1jb250YWluZXInO1xuICAgICAgICAvLyAnQCcgQnV0dG9uXG4gICAgICAgIGNvbnN0IGF0QnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oJ0AnLCAnQnJvd3NlIGNlbGxzLCBjb2RlLCBmaWxlcywgYW5kIG1vcmUnKTtcbiAgICAgICAgYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhhbmRsZVNob3dQb3B1cE1lbnUoZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRXhwYW5kIEJ1dHRvbiAoc3RvcmUgcmVmZXJlbmNlKVxuICAgICAgICB0aGlzLmV4cGFuZEJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKCfipKInLCAnRXhwYW5kIGlucHV0Jyk7XG4gICAgICAgIHRoaXMuZXhwYW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy50b2dnbGVJbnB1dEV4cGFuc2lvbigpKTtcbiAgICAgICAgLy8gU2V0dGluZ3MgQnV0dG9uXG4gICAgICAgIGNvbnN0IHNldHRpbmdzQnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oJ+Kame+4jycsICdTZXR0aW5ncycpO1xuICAgICAgICBzZXR0aW5nc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2FsbGJhY2tzLmhhbmRsZVNob3dTZXR0aW5ncyk7XG4gICAgICAgIC8vIEFkZCBidXR0b25zIHRvIGNvbnRhaW5lclxuICAgICAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGF0QnV0dG9uKTtcbiAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmV4cGFuZEJ1dHRvbik7XG4gICAgICAgIGFjdGlvbkJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoc2V0dGluZ3NCdXR0b24pO1xuICAgICAgICAvLyBBc3NlbWJsZSBDb250cm9scyBDb250YWluZXJcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlQ29udGFpbmVyKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQoYWN0aW9uQnV0dG9uc0NvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250cm9sc0NvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgKi9cbiAgICB0b2dnbGVJbnB1dEV4cGFuc2lvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0RmllbGQgfHwgIXRoaXMuZXhwYW5kQnV0dG9uKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBFbnN1cmUgZWxlbWVudHMgZXhpc3RcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSAhdGhpcy5pc0lucHV0RXhwYW5kZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcyMDBweCc7IC8vIEtlZXAgZm9yIG5vdywgY29uc2lkZXIgQ1NTIGNsYXNzZXNcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5yZXNpemUgPSAndmVydGljYWwnOyAvLyBXb3JrcyBvbiBkaXZzIHRvbyAoaWYgb3ZlcmZsb3cgdmlzaWJsZS9hdXRvKVxuICAgICAgICAgICAgdGhpcy5leHBhbmRCdXR0b24udGV4dENvbnRlbnQgPSAn4qShJztcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kQnV0dG9uLnRpdGxlID0gJ0NvbGxhcHNlIGlucHV0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnJzsgLy8gUmVzZXQgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUucmVzaXplID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRCdXR0b24udGV4dENvbnRlbnQgPSAn4qSiJztcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kQnV0dG9uLnRpdGxlID0gJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnV0dXJlOiBOb3RpZnkgd2lkZ2V0L2hhbmRsZXIgaWYgbmVlZGVkOiB0aGlzLmNhbGxiYWNrcy5oYW5kbGVUb2dnbGVFeHBhbnNpb24odGhpcy5pc0lucHV0RXhwYW5kZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3R5bGVkIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b24odGV4dCwgdG9vbHRpcCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICAgICAgLy8gQXBwbHkgYmFzZSBKdXB5dGVyTGFiIGJ1dHRvbiBjbGFzcyBhbmQgb3VyIHNwZWNpZmljIGNsYXNzXG4gICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBuZXcgY2hhdCBtZXNzYWdlIGVsZW1lbnQgdG8gdGhlIG1lc3NhZ2UgY29udGFpbmVyIGFuZCBzY3JvbGxzIGRvd24uXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIG1lc3NhZ2UgZWxlbWVudCAodXNlciBvciBib3QpIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRDaGF0TWVzc2FnZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvQm90dG9tKCk7IC8vIFNjcm9sbCBhZnRlciBhZGRpbmcgdGhlIG5ldyBlbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNZXNzYWdlIGNvbnRhaW5lciBub3QgaW5pdGlhbGl6ZWQgaW4gVUlNYW5hZ2VyLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdGhlIG1lc3NhZ2UgY29udGFpbmVyIHRvIHRoZSBib3R0b20uXG4gICAgICovXG4gICAgc2Nyb2xsVG9Cb3R0b20oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWVzc2FnZSBjb250YWluZXIgbm90IGluaXRpYWxpemVkIGluIFVJTWFuYWdlci4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgdmlldyB0byBzaG93IHRoZSBub3Rlcy5cbiAgICAgKi9cbiAgICBzaG93Tm90ZXNWaWV3KCkge1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMubm90ZXNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSB2aWV3IHRvIHNob3cgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKi9cbiAgICBzaG93SGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMubWVzc2FnZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMubm90ZXNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5ib3R0b21CYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gT3B0aW9uYWxseSB1cGRhdGUgaGVhZGVyL3RpdGxlIGVsZW1lbnRzIGlmIG5lZWRlZFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgdmlldyB0byBzaG93IHRoZSBtYWluIGNoYXQgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHNob3dDaGF0VmlldygpIHtcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMubm90ZXNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLmJvdHRvbUJhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBBc3N1bWluZyBmbGV4IGRpc3BsYXlcbiAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpOyAvLyBTY3JvbGwgZG93biB3aGVuIHNob3dpbmcgY2hhdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIG1lc3NhZ2VzIGZyb20gdGhlIG1lc3NhZ2UgY29udGFpbmVyLlxuICAgICAqL1xuICAgIGNsZWFyTWVzc2FnZUNvbnRhaW5lcigpIHtcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5tZXNzYWdlQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgdGl0bGUgaW5wdXQgZmllbGQuXG4gICAgICovXG4gICAgdXBkYXRlVGl0bGVJbnB1dCh0aXRsZSkge1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRFbGVtZW50cy50aXRsZUlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLnRpdGxlSW5wdXQudmFsdWUgPSB0aXRsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY29udGFpbmVyIHN0cnVjdHVyZSBmb3IgYSBib3QgbWVzc2FnZSxcbiAgICAgKiBpbmNsdWRpbmcgZWxlbWVudHMgZm9yIHN0cmVhbWluZyB0ZXh0IGFuZCBmaW5hbCByZW5kZXJlZCBjb250ZW50LlxuICAgICAqIFRoaXMgaGVscHMgbWFuYWdlIHRoZSB0cmFuc2l0aW9uIGZyb20gc3RyZWFtaW5nIHRvIGZpbmFsIG1lc3NhZ2UgZGlzcGxheS5cbiAgICAgKi9cbiAgICBjcmVhdGVCb3RNZXNzYWdlQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBib3RNZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYm90LW1lc3NhZ2UnOyAvLyBCYXNlIGNsYXNzXG4gICAgICAgIC8vIERpdiBmb3Igc3RyZWFtaW5nIGNvbnRlbnQgKGluaXRpYWxseSB2aXNpYmxlKVxuICAgICAgICBjb25zdCBzdHJlYW1pbmdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3RyZWFtaW5nRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXN0cmVhbWluZy1jb250ZW50JztcbiAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBTaG93IHN0cmVhbWluZyBpbml0aWFsbHlcbiAgICAgICAgLy8gRGl2IGZvciBmaW5hbCByZW5kZXJlZCBjb250ZW50IChpbml0aWFsbHkgaGlkZGVuKVxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcmVuZGVyZWQtY29udGVudCc7XG4gICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSGlkZSBmaW5hbCBjb250ZW50IGluaXRpYWxseVxuICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgIC8vIEFkZCB0aGUgd2hvbGUgY29udGFpbmVyIHRvIHRoZSBtZXNzYWdlIGxpc3QgKmJlZm9yZSogc3RyZWFtaW5nIHN0YXJ0c1xuICAgICAgICB0aGlzLmFkZENoYXRNZXNzYWdlRWxlbWVudChib3RNZXNzYWdlRGl2KTtcbiAgICAgICAgcmV0dXJuIHsgYm90TWVzc2FnZURpdiwgc3RyZWFtaW5nRGl2LCBjb250ZW50RGl2IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGEgdGVtcG9yYXJ5IG5vdGlmaWNhdGlvbiBtZXNzYWdlLlxuICAgICAqIFRPRE86IEltcGxlbWVudCBhIG1vcmUgcm9idXN0IG5vdGlmaWNhdGlvbiBzeXN0ZW0gKGUuZy4sIHRvYXN0KS5cbiAgICAgKi9cbiAgICBzaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2UsIHR5cGUsIGR1cmF0aW9uID0gMzAwMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgTm90aWZpY2F0aW9uICgke3R5cGV9KTogJHttZXNzYWdlfWApO1xuICAgICAgICAvLyBCYXNpYyB0ZW1wb3JhcnkgaW1wbGVtZW50YXRpb24gdXNpbmcgdGhlIGV4aXN0aW5nIGluZGljYXRvciBlbGVtZW50XG4gICAgICAgIGNvbnN0IGluZGljYXRvciA9IHRoaXMubGF5b3V0RWxlbWVudHMubWFpbkVsZW1lbnQucXVlcnlTZWxlY3RvcignLmpwLWxsbS1leHQta2V5Ym9hcmQtc2hvcnRjdXQtaW5kaWNhdG9yJyk7XG4gICAgICAgIGlmIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ub3RpZmljYXRpb25UaW1lb3V0KTsgLy8gQ2xlYXIgcHJldmlvdXMgdGltZW91dFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNhdG9yLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGluZGljYXRvci5jbGFzc05hbWUgPSBganAtbGxtLWV4dC1rZXlib2FyZC1zaG9ydGN1dC1pbmRpY2F0b3IgdmlzaWJsZSBqcC1sbG0tZXh0LW5vdGlmaWNhdGlvbi0ke3R5cGV9YDsgLy8gQWRkIHR5cGUgY2xhc3NcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vdGlmaWNhdGlvbiBpbmRpY2F0b3IgZWxlbWVudCBub3QgZm91bmQgZm9yIFVJTWFuYWdlci4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHZpc3VhbCBpbmRpY2F0b3IgZm9yIGtleWJvYXJkIHNob3J0Y3V0cy5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBkaXNwbGF5IGluIHRoZSBpbmRpY2F0b3IuXG4gICAgICovXG4gICAgc2hvd0luZGljYXRvcih0ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBHdWFyZFxuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dCB0byBwcmV2ZW50IG11bHRpcGxlIHRpbWVvdXRzIHJ1bm5pbmdcbiAgICAgICAgaWYgKHRoaXMubm90aWZpY2F0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm90aWZpY2F0aW9uVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5ldyB0aW1lb3V0IHRvIGhpZGUgdGhlIGluZGljYXRvclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKSB7IC8vIENoZWNrIGlmIGVsZW1lbnQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgIH0sIDEwMDApOyAvLyBIaWRlIGFmdGVyIDEgc2Vjb25kXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgaW5kaWNhdG9yIGltbWVkaWF0ZWx5IGFuZCBjYW5jZWxzIGFueSBwZW5kaW5nIGhpZGUgdGltZW91dC5cbiAgICAgKiBVc2VmdWwgaWYgdGhlIHdpZGdldCBpcyBoaWRkZW4gd2hpbGUgdGhlIGluZGljYXRvciBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBjbGVhckluZGljYXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5ub3RpZmljYXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ub3RpZmljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBpbnB1dCBmaWVsZCBjb250ZW50IGFuZCBjdXJzb3IgcG9zaXRpb24gdG8gZGV0ZXJtaW5lIGlmXG4gICAgICogdGhlIHJlZmVyZW5jZSBzdWdnZXN0aW9uIHBvcHVwIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gICAgICogVHJpZ2dlcmVkIG9uICdpbnB1dCcgZXZlbnRzLlxuICAgICAqL1xuICAgIGhhbmRsZUlucHV0Rm9yUmVmZXJlbmNlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAvLyBOZWVkIGEgY29sbGFwc2VkIHNlbGVjdGlvbiAoY3Vyc29yKSBpbnNpZGUgdGhlIGlucHV0IGZpZWxkXG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBjdXJzb3IgaXMgd2l0aGluIHRoZSBpbnB1dCBmaWVsZCBpdHNlbGZcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0RmllbGQuY29udGFpbnMoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21iaW5lIHRleHQgY29udGVudCBmcm9tIHByZWNlZGluZyBzaWJsaW5ncyBpZiBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlXG4gICAgICAgIGxldCB0ZXh0QmVmb3JlQ3Vyc29yID0gJyc7XG4gICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBsZXQgY3VycmVudE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHRleHRCZWZvcmVDdXJzb3IgPSAoKF9hID0gY3VycmVudENvbnRhaW5lci50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnN0cmluZygwLCBjdXJyZW50T2Zmc2V0KSkgKyB0ZXh0QmVmb3JlQ3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY3VycmVudENvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoJ2pwLWxsbS1leHQtcmVmLXdpZGdldCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGEgd2lkZ2V0IGJlZm9yZSB0aGUgY3Vyc29yLCB3ZSBjYW4ndCBiZSByaWdodCBhZnRlciAnQCdcbiAgICAgICAgICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gJ1t3aWRnZXRdJyArIHRleHRCZWZvcmVDdXJzb3I7IC8vIEFkZCBwbGFjZWhvbGRlciB0byBicmVhayAnQCcgc2VxdWVuY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGN1cnJlbnRDb250YWluZXIudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgICAgICAgIHRleHRCZWZvcmVDdXJzb3IgPSAnXFxuJyArIHRleHRCZWZvcmVDdXJzb3I7IC8vIFRyZWF0IEJSIGFzIG5ld2xpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgb3IgcGFyZW50J3MgcHJldmlvdXMgc2libGluZ1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IGN1cnJlbnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIC8vIElmIG1vdmluZyB0byBhIG5ldyBub2RlLCB0YWtlIGl0cyBmdWxsIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjdXJyZW50T2Zmc2V0ID0gKGN1cnJlbnRDb250YWluZXIudGV4dENvbnRlbnQgfHwgJycpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdXAgdG8gcGFyZW50LCBjb250aW51ZSBzZWFyY2ggZnJvbSBiZWZvcmUgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBjdXJyZW50Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgPT09IHRoaXMuaW5wdXRGaWVsZCB8fCAhY3VycmVudENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiB3ZSByZWFjaGVkIHRoZSBpbnB1dCBmaWVsZCBvciB0b3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudE9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoKChfYiA9IGN1cnJlbnRDb250YWluZXIucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoaWxkTm9kZXMpIHx8IFtdLCBjdXJyZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgVUlfTUFOQUdFUiBoYW5kbGVJbnB1dDogVGV4dCBiZWZvcmUgY3Vyc29yOiBcIiR7dGV4dEJlZm9yZUN1cnNvcn1cImApO1xuICAgICAgICAvLyAtLS0gQ2hlY2sgZm9yIHRyaWdnZXIgY29uZGl0aW9ucyAtLS0gXG4gICAgICAgIGNvbnN0IGVuZHNXaXRoQXQgPSB0ZXh0QmVmb3JlQ3Vyc29yLmVuZHNXaXRoKCdAJyk7XG4gICAgICAgIGNvbnN0IGVuZHNXaXRoQXRTcGFjZSA9IHRleHRCZWZvcmVDdXJzb3IuZW5kc1dpdGgoJ0AgJyk7XG4gICAgICAgIGlmIChlbmRzV2l0aEF0IHx8IGVuZHNXaXRoQXRTcGFjZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51TWFuYWdlci5pc1BvcHVwTWVudVZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IElmIHZpc2libGUsIG1heWJlIGp1c3QgdXBkYXRlIHRoZSBxdWVyeSBpbiB0aGUgcG9wdXA/XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VJX01BTkFHRVIgaGFuZGxlSW5wdXQ6IFBvcHVwIGFscmVhZHkgdmlzaWJsZSwgc2tpcHBpbmcgc2hvdy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBxdWVyeSAoYWZ0ZXIgJ0AnIG9yICdAICcpXG4gICAgICAgICAgICAgICAgY29uc3QgYXRJbmRleCA9IHRleHRCZWZvcmVDdXJzb3IubGFzdEluZGV4T2YoJ0AnKTtcbiAgICAgICAgICAgICAgICBsZXQgcXVlcnlTdGFydEluZGV4ID0gYXRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQXRTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0YXJ0SW5kZXggPSBhdEluZGV4ICsgMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSB0ZXh0QmVmb3JlQ3Vyc29yLnN1YnN0cmluZyhxdWVyeVN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vIC0tLSBJbnNlcnQgdGVtcG9yYXJ5IHNwYW4gdG8gZ2V0IHJlbGlhYmxlIGNvb3JkaW5hdGVzIC0tLSBcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQW5jaG9ySWQgPSAnanAtbGxtLXRlbXAtcG9wdXAtYW5jaG9yJztcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFNwYW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wQW5jaG9ySWQpO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wU3BhbilcbiAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4ucmVtb3ZlKCk7IC8vIENsZWFuIHVwIHByZXZpb3VzIGlmIGFueVxuICAgICAgICAgICAgICAgIHRlbXBTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIHRlbXBTcGFuLmlkID0gdGVtcEFuY2hvcklkO1xuICAgICAgICAgICAgICAgIC8vIFN0eWxlIHRvIGJlIGludmlzaWJsZSBhbmQgdGFrZSBubyBzcGFjZVxuICAgICAgICAgICAgICAgIHRlbXBTcGFuLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5zdHlsZS53aWR0aCA9ICcwJztcbiAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgICAgICAgICAgICAgdGVtcFNwYW4uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICB0ZW1wU3Bhbi50ZXh0Q29udGVudCA9ICdcXHUyMDBCJzsgLy8gWmVyby13aWR0aCBzcGFjZSBtaWdodCBoZWxwIHJlbmRlcmluZ1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgc3BhbiBhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHRlbXBTcGFuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuUmVjdCA9IHRlbXBTcGFuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRlbXBTcGFuLnJlbW92ZSgpOyAvLyBSZW1vdmUgaW1tZWRpYXRlbHkgYWZ0ZXIgZ2V0dGluZyBjb29yZHNcbiAgICAgICAgICAgICAgICAvLyAtLS0gRW5kIHRlbXBvcmFyeSBzcGFuIGxvZ2ljIC0tLVxuICAgICAgICAgICAgICAgIGlmIChzcGFuUmVjdC50b3AgPT09IDAgJiYgc3BhblJlY3QubGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVUlfTUFOQUdFUiBoYW5kbGVJbnB1dDogRmFpbGVkIHRvIGdldCB2YWxpZCBjb29yZGluYXRlcyBmcm9tIHRlbXAgYW5jaG9yIHNwYW4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBvciBhbHRlcm5hdGl2ZSBwb3NpdGlvbmluZyBtaWdodCBiZSBuZWVkZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBpbnB1dCBmaWVsZCBib3R0b20tbGVmdD9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmhpZGVQb3B1cE1lbnUoKTsgLy8gRG9uJ3Qgc2hvdyBpZiBjb29yZHMgYXJlIGJhZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVJX01BTkFHRVIgaGFuZGxlSW5wdXQ6IEFuY2hvciBjb29yZHMgZnJvbSB0ZW1wIHNwYW46IFRvcD0ke3NwYW5SZWN0LnRvcH0sIExlZnQ9JHtzcGFuUmVjdC5sZWZ0fWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSBUT1AgTEVWRUwgc3VnZ2VzdGlvbnMgdXNpbmcgdGhlIHJlbGlhYmxlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIGNvb3JkaW5hdGVzIGRpcmVjdGx5IHRvIHNob3dQb3B1cE1lbnVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUoeyB4OiBzcGFuUmVjdC5sZWZ0LCB5OiBzcGFuUmVjdC50b3AgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGV4dCBkb2Vzbid0IGVuZCB3aXRoIEAgb3IgQC1zcGFjZSwgaGlkZSB0aGUgcG9wdXBcbiAgICAgICAgICAgIC8vIE9ubHkgaGlkZSBpZiBpdCB3YXMgcHJldmlvdXNseSBzaG93aW5nIHRoZSAndG9wJyBvciAncmVmZXJlbmNlcycgbWVudSB0cmlnZ2VyZWQgYnkgJ0AnXG4gICAgICAgICAgICAvLyBBdm9pZCBoaWRpbmcgbWVudXMgdHJpZ2dlcmVkIGJ5IHRoZSBidXR0b24gY2xpY2sgdW5uZWNlc3NhcmlseVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51TWFuYWdlci5pc1BvcHVwTWVudVZpc2libGUoKSkgeyAvLyAmJiAodGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmdldEN1cnJlbnRNZW51TGV2ZWwoKSA9PT0gJ3JlZmVyZW5jZXMnIHx8IC8qIE5lZWQgd2F5IHRvIGtub3cgaWYgdHJpZ2dlcmVkIGJ5IEAgKi8gKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVSV9NQU5BR0VSIGhhbmRsZUlucHV0OiBIaWRpbmcgcG9wdXAsIHRyaWdnZXIgY29uZGl0aW9uIG5vIGxvbmdlciBtZXQuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVcGRhdGUgcG9wdXAgcXVlcnkgaWYgaXQncyBhbHJlYWR5IHZpc2libGUgYW5kIHRoZSB0ZXh0IGFmdGVyIEAgY2hhbmdlc1xuICAgICAgICAvLyAoTmVlZCBtb3JlIHJvYnVzdCBsb2dpYyBoZXJlLCBjb25zaWRlcmluZyBiYWNrc3BhY2UsIGV0Yy4pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGlucHV0IGZpZWxkLCBjb252ZXJ0aW5nIGtub3duIHdpZGdldHNcbiAgICAgKiBiYWNrIHRvIHRoZWlyIHJlZmVyZW5jZSBzdHJpbmdzIChlLmcuLCBAZmlsZTpwYXRoL3RvL2ZpbGUudHh0KS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgY3VycmVudGx5IHVzZXMgYSBzaW1wbGUgdGV4dCBzZXJpYWxpemF0aW9uLiBGb3IgZnVsbCBmaWRlbGl0eVxuICAgICAqIHByZXNlcnZpbmcgc3RydWN0dXJlIChsaWtlIG11bHRpcGxlIHBhcmFncmFwaHMpLCBhIG1vcmUgY29tcGxleCBhcHByb2FjaFxuICAgICAqIChlLmcuLCBIVE1MIHByb2Nlc3Npbmcgb3IgYSBkZWRpY2F0ZWQgZWRpdG9yIG1vZGVsKSB3b3VsZCBiZSBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VyaWFsaXplZCBwbGFpbiB0ZXh0IGNvbnRlbnQgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgICAqL1xuICAgIGdldFNlcmlhbGl6ZWRJbnB1dCgpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQgPSAnJztcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLmlucHV0RmllbGQuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2pwLWxsbS1leHQtcmVmLXdpZGdldCcpICYmIGVsZW1lbnQuZGF0YXNldC5yZWZlcmVuY2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVmZXJlbmNlIHRleHQgc3RvcmVkIGluIHRoZSBkYXRhIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9IGVsZW1lbnQuZGF0YXNldC5yZWZlcmVuY2VUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBCUiB0YWdzIGJhY2sgdG8gbmV3bGluZXNcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnRElWJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgRElWIGVsZW1lbnRzIChtaWdodCBiZSBpbnNlcnRlZCBieSBicm93c2VyIG9uIHBhc3RlL2VudGVyKVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3bGluZSBiZWZvcmUgaWYgbmVlZGVkLCB0aGVuIHNlcmlhbGl6ZSBjaGlsZHJlbiByZWN1cnNpdmVseT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7IC8vIEFkZCBuZXdsaW5lIG9ubHkgaWYgbm90IHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gdGhpcy5zZXJpYWxpemVOb2RlQ2hpbGRyZW4oZWxlbWVudCk7IC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB0ZXh0IGNvbnRlbnQgb2Ygb3RoZXIgdW5leHBlY3RlZCBlbGVtZW50cywgYnV0IGxvZyBhIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVSU1hbmFnZXIgZ2V0U2VyaWFsaXplZElucHV0OiBFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIGVsZW1lbnQ6JywgZWxlbWVudC50YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gSWdub3JlIG90aGVyIG5vZGUgdHlwZXMgKGNvbW1lbnRzLCBldGMuKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkLnRyaW0oKTsgLy8gVHJpbSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICB9XG4gICAgLy8gSGVscGVyIHRvIHNlcmlhbGl6ZSBjaGlsZHJlbiBvZiBhIG5vZGUgKGUuZy4sIGZvciBESVZzKVxuICAgIHNlcmlhbGl6ZU5vZGVDaGlsZHJlbihwYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnanAtbGxtLWV4dC1yZWYtd2lkZ2V0JykgJiYgZWxlbWVudC5kYXRhc2V0LnJlZmVyZW5jZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCArPSBlbGVtZW50LmRhdGFzZXQucmVmZXJlbmNlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBoYW5kbGUgbmVzdGVkIGVsZW1lbnRzIGlmIG5lY2Vzc2FyeSwgb3IganVzdCBnZXQgdGV4dCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5zZXJpYWxpemVOb2RlQ2hpbGRyZW4oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBjbGVhcklucHV0RmllbGQoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5pbm5lckhUTUwgPSAnJzsgLy8gQ2xlYXIgYWxsIGNvbnRlbnRcbiAgICAgICAgLy8gUmVzZXQgZXhwYW5zaW9uIHN0YXRlIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5pc0lucHV0RXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSW5wdXRFeHBhbnNpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgcGxhY2Vob2xkZXIgcmVhcHBlYXJzIGlmIHVzaW5nIENTUyBmb3IgaXRcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcpKTsgLy8gVHJpZ2dlciBldmVudCB0byB1cGRhdGUgVUkgc3RhdGUgaWYgbmVjZXNzYXJ5XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlICdjb3B5JyBldmVudCB0byBwdXQgc2VyaWFsaXplZCBwbGFpbiB0ZXh0IG9udG8gdGhlIGNsaXBib2FyZC5cbiAgICAgKi9cbiAgICBoYW5kbGVDb3B5KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkIHx8ICFldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgc2VsZWN0ZWQgb3Igbm8gY2xpcGJvYXJkIGRhdGEgb2JqZWN0XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIG91ciBpbnB1dCBmaWVsZFxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRGaWVsZC5jb250YWlucyhyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLnNlcmlhbGl6ZVJhbmdlQ29udGVudChyYW5nZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBjb3B5IGJlaGF2aW9yXG4gICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNlbGVjdGVkVGV4dCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVSU1hbmFnZXIgaGFuZGxlQ29weTogQ29waWVkIHNlcmlhbGl6ZWQgdGV4dDonLCBzZWxlY3RlZFRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSAncGFzdGUnIGV2ZW50IHRvIGluc2VydCBwbGFpbiB0ZXh0IGNvbnRlbnQuXG4gICAgICovXG4gICAgaGFuZGxlUGFzdGUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgcGFzdGUgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgcGxhaW4gdGV4dCBhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpOyAvLyBEZWxldGUgc2VsZWN0ZWQgY29udGVudCBpZiBhbnlcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIGluc2VydGVkIHRleHRcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKHRleHROb2RlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNjcm9sbCBpbnRvIHZpZXcgYW5kIHRyaWdnZXIgaW5wdXQgZXZlbnQgZm9yIHBvdGVudGlhbCB1cGRhdGVzXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdGV4dE5vZGUucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICduZWFyZXN0JyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVSU1hbmFnZXIgaGFuZGxlUGFzdGU6IFBhc3RlZCB0ZXh0OicsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLSBNZXRob2RzIGZvciB1cGRhdGluZyBVSSBlbGVtZW50cyB3aWxsIGJlIGFkZGVkIGxhdGVyIC0tLVxuICAgIC8vIGUuZy4sIHVwZGF0ZU1lc3NhZ2VDb250YWluZXIoaHRtbDogc3RyaW5nKSwgc2hvd0hpc3RvcnlWaWV3KCksIHNob3dDaGF0VmlldygpXG4gICAgLy8gLS0tIFBvdGVudGlhbGx5IGFkZCBtZXRob2RzIHRvIGdldCBlbGVtZW50IHJlZmVyZW5jZXMgaWYgbmVlZGVkIGV4dGVybmFsbHkgLS0tXG4gICAgLy8gcHVibGljIGdldElucHV0RmllbGQoKTogSFRNTFRleHRBcmVhRWxlbWVudCB7IHJldHVybiB0aGlzLmlucHV0RmllbGQ7IH1cbiAgICAvLyBldGMuXG4gICAgLy8gSGVscGVyIHRvIHNlcmlhbGl6ZSBhIHJhbmdlIChuZWVkZWQgZm9yIGNvcHkpXG4gICAgc2VyaWFsaXplUmFuZ2VDb250ZW50KHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICBsZXQgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZW1wRGl2LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgLy8gTm93LCBzZXJpYWxpemUgdGVtcERpdidzIGNvbnRlbnQgbGlrZSB3ZSBkbyBmb3IgZ2V0U2VyaWFsaXplZElucHV0XG4gICAgICAgIGxldCBzZXJpYWxpemVkID0gJyc7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGVtcERpdi5jaGlsZE5vZGVzO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVOb2RlID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcC1sbG0tZXh0LXJlZi13aWRnZXQnKSAmJiBlbGVtZW50LmRhdGFzZXQucmVmZXJlbmNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9IGVsZW1lbnQuZGF0YXNldC5yZWZlcmVuY2VUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIEZvciBvdGhlciBlbGVtZW50cyAobGlrZSBESVZzIHBvdGVudGlhbGx5IGluIGZyYWdtZW50KSwgc2VyaWFsaXplIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplTm9kZShjaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VyaWFsaXplTm9kZShub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5VSU1hbmFnZXIgPSBVSU1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29weVRvQ2xpcGJvYXJkID0gY29weVRvQ2xpcGJvYXJkO1xuZXhwb3J0cy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkID0gY29weU1lc3NhZ2VUb0NsaXBib2FyZDtcbmV4cG9ydHMuY29weUltYWdlVG9DbGlwYm9hcmQgPSBjb3B5SW1hZ2VUb0NsaXBib2FyZDtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvcHkgdGV4dCB0byBjbGlwYm9hcmQuXG4gKiBQcm92aWRlcyB2aXN1YWwgZmVlZGJhY2sgdmlhIGNvbnNvbGUgbG9ncyBhbmQgb3B0aW9uYWxseSBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dCwgZmVlZGJhY2tDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRlbnQgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKCk7IC8vIENhbGwgb3B0aW9uYWwgZmVlZGJhY2sgY2FsbGJhY2tcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IHRleHQ6ICcsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29weWluZyB0ZXh0IHRvIGNsaXBib2FyZDonLCBlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBDb3BpZXMgbWVzc2FnZSBjb250ZW50IHRvIGNsaXBib2FyZC5cbiAqIFByb3ZpZGVzIHZpc3VhbCBmZWVkYmFjayB2aWEgY29uc29sZSBsb2dzIGFuZCBvcHRpb25hbGx5IGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQodGV4dCwgZmVlZGJhY2tDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01lc3NhZ2UgY29udGVudCBjb3BpZWQgdG8gY2xpcGJvYXJkJyk7XG4gICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2sodHJ1ZSk7IC8vIEluZGljYXRlIHN1Y2Nlc3NcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IG1lc3NhZ2UgdGV4dDogJywgZXJyKTtcbiAgICAgICAgICAgIGZlZWRiYWNrQ2FsbGJhY2sgPT09IG51bGwgfHwgZmVlZGJhY2tDYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYWxsYmFjayhmYWxzZSk7IC8vIEluZGljYXRlIGZhaWx1cmVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb3B5aW5nIG1lc3NhZ2UgdG8gY2xpcGJvYXJkOicsIGVycm9yKTtcbiAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKGZhbHNlKTsgLy8gSW5kaWNhdGUgZmFpbHVyZVxuICAgIH1cbn1cbi8qKlxuICogQ29waWVzIGFuIGltYWdlIHRvIHRoZSBjbGlwYm9hcmQgZnJvbSBhIGdpdmVuIFVSTC5cbiAqIFByb3ZpZGVzIHZpc3VhbCBmZWVkYmFjayB2aWEgY29uc29sZSBsb2dzIGFuZCBvcHRpb25hbGx5IGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGNvcHlJbWFnZVRvQ2xpcGJvYXJkKGltYWdlVXJsLCBmZWVkYmFja0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZmV0Y2goaW1hZ2VVcmwpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIENsaXBib2FyZEl0ZW0gd2l0aCB0aGUgaW1hZ2UgYmxvYlxuICAgICAgICAgICAgLy8gTm90ZTogQ2xpcGJvYXJkSXRlbSBtaWdodCBub3QgYmUgZGVmaW5lZCBpbiBhbGwgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBZb3UgbWlnaHQgbmVlZCB0byBhZGQgYFwiZG9tLml0ZXJhYmxlXCJgIHRvIHRzY29uZmlnIGxpYiBvciBoYW5kbGUgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgQ2xpcGJvYXJkSXRlbSh7IFtibG9iLnR5cGVdOiBibG9iIH0pO1xuICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZShbaXRlbV0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbWFnZSBjb3BpZWQgdG8gY2xpcGJvYXJkJyk7XG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKHRydWUpOyAvLyBJbmRpY2F0ZSBzdWNjZXNzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IGltYWdlIHRvIGNsaXBib2FyZDogJywgZXJyKTtcbiAgICAgICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIGNvcHkgaW1hZ2U6ICcgKyBlcnIubWVzc2FnZSk7IC8vIEtlZXAgYWxlcnQgZm9yIGNyaXRpY2FsIHVzZXIgZmVlZGJhY2tcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG9yIHByb2Nlc3MgaW1hZ2U6ICcsIGVycik7XG4gICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIGZldGNoIGltYWdlOiAnICsgZXJyLm1lc3NhZ2UpOyAvLyBLZWVwIGFsZXJ0IGZvciBjcml0aWNhbCB1c2VyIGZlZWRiYWNrXG4gICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJlcGFyaW5nIGltYWdlIGNvcHk6JywgZXJyb3IpO1xuICAgICAgICBhbGVydCgnRXJyb3IgY29weWluZyBpbWFnZTogJyArIGVycm9yKTsgLy8gS2VlcCBhbGVydCBmb3IgY3JpdGljYWwgdXNlciBmZWVkYmFja1xuICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENhcmV0UG9zaXRpb24gPSBnZXRDYXJldFBvc2l0aW9uO1xuZXhwb3J0cy5zZXRDYXJldFBvc2l0aW9uID0gc2V0Q2FyZXRQb3NpdGlvbjtcbi8qKlxuICogR2V0cyB0aGUgY2FyZXQgcG9zaXRpb24gd2l0aGluIGEgY29udGVudGVkaXRhYmxlIGVsZW1lbnQuXG4gKiBSZXR1cm5zIHRoZSBsaW5lYXIgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiBnZXRDYXJldFBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDAgfHwgIWVsZW1lbnQuY29udGFpbnMoc2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGlvbiBpcyB3aXRoaW4gdGhlIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgLy8gQ3JlYXRlIGEgcmFuZ2UgdGhhdCBzcGFucyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGVsZW1lbnQgdG8gdGhlIGNhcmV0XG4gICAgY29uc3QgcHJlQ2FyZXRSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICBwcmVDYXJldFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhlbGVtZW50KTtcbiAgICBwcmVDYXJldFJhbmdlLnNldEVuZChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgIC8vIFRoZSBsZW5ndGggb2YgdGhlIHRleHQgY29udGVudCB3aXRoaW4gdGhpcyBwcmUtY2FyZXQgcmFuZ2UgaXMgdGhlIHBvc2l0aW9uXG4gICAgLy8gVXNpbmcgdG9TdHJpbmcoKSBpcyBnZW5lcmFsbHkgbW9yZSByZWxpYWJsZSB0aGFuIHRleHRDb250ZW50IGZvciByYW5nZSBsZW5ndGhcbiAgICByZXR1cm4gcHJlQ2FyZXRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbi8qKlxuICogU2V0cyB0aGUgY2FyZXQgcG9zaXRpb24gd2l0aGluIGEgY29udGVudGVkaXRhYmxlIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWxlbWVudCBUaGUgY29udGVudGVkaXRhYmxlIGVsZW1lbnQuXG4gKiBAcGFyYW0gcG9zaXRpb24gVGhlIGRlc2lyZWQgbGluZWFyIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiBzZXRDYXJldFBvc2l0aW9uKGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBsZXQgY2hhckNvdW50ID0gMDtcbiAgICBsZXQgZm91bmROb2RlID0gZmFsc2U7XG4gICAgbGV0IG5vZGVTdGFjayA9IFtlbGVtZW50XTsgLy8gVXNlIGEgc3RhY2sgZm9yIERGUyB0cmF2ZXJzYWxcbiAgICAvLyBEZXB0aC1maXJzdCBzZWFyY2ggdG8gZmluZCB0aGUgY29ycmVjdCB0ZXh0IG5vZGUgYW5kIG9mZnNldFxuICAgIHdoaWxlIChub2RlU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSAoKF9hID0gbm9kZS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjaGFyQ291bnQgJiYgcG9zaXRpb24gPD0gY2hhckNvdW50ICsgdGV4dExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIHBvc2l0aW9uIC0gY2hhckNvdW50KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgcG9zaXRpb24gLSBjaGFyQ291bnQpO1xuICAgICAgICAgICAgICAgIGZvdW5kTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kIHRoZSBub2RlLCBleGl0IGxvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJDb3VudCArPSB0ZXh0TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoZWxlbWVudE5vZGUudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gY2hhckNvdW50KSB7IC8vIFBvc2l0aW9uIGlzIHJpZ2h0IGJlZm9yZSBCUlxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhckNvdW50ICs9IDE7IC8vIFRyZWF0IEJSIGFzIG9uZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnROb2RlLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmVhdCBub24tZWRpdGFibGUgZWxlbWVudHMgKGxpa2Ugb3VyIHdpZGdldHMpIGFzIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBjaGFyQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gaXMgcmlnaHQgYmVmb3JlIHRoZSB3aWRnZXRcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGNoaWxkIG5vZGVzIHRvIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyIGZvciBjb3JyZWN0IERGU1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlU3RhY2sucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBwb3NpdGlvbiBpcyBiZXlvbmQgdGhlIGNvbnRlbnQgb3Igd2Fzbid0IGZvdW5kLCBwbGFjZSBjdXJzb3IgYXQgdGhlIGVuZFxuICAgIGlmICghZm91bmROb2RlKSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhlbGVtZW50KTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpOyAvLyBDb2xsYXBzZSB0byB0aGUgZW5kXG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIC8vIFJlc3RvcmUgZm9jdXMgb25seSBpZiB0aGUgZWxlbWVudCB3YXMgcHJldmlvdXNseSBmb2N1c2VkIG9yIGlzIHRoZSB0YXJnZXRcbiAgICAvLyBUaGlzIGF2b2lkcyBzdGVhbGluZyBmb2N1cyB1bm5lY2Vzc2FyaWx5XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7IC8vIHByZXZlbnRTY3JvbGwgaGVscHMgYXZvaWQganVtcGluZ1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXRlY3RMYW5ndWFnZSA9IGRldGVjdExhbmd1YWdlO1xuZXhwb3J0cy5oaWdobGlnaHRDb2RlID0gaGlnaGxpZ2h0Q29kZTtcbmNvbnN0IGhpZ2hsaWdodF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJoaWdobGlnaHQuanNcIikpO1xuLyoqXG4gKiBEZXRlY3RzIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZSBmcm9tIGNvZGUgYmxvY2sgY29udGVudCB1c2luZyBoaWdobGlnaHQuanNcbiAqIGFuZCBjdXN0b20gcGF0dGVybiBtYXRjaGluZyBmb3IgY29tbW9uIGxhbmd1YWdlcy5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0TGFuZ3VhZ2UoY29kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSBhdXRvIGRldGVjdGlvbiBmaXJzdCB3aXRoIGEgbGltaXRlZCBzZXQgb2YgY29tbW9uIGxhbmd1YWdlc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmhpZ2hsaWdodEF1dG8oY29kZSwgW1xuICAgICAgICAgICAgJ3B5dGhvbicsICdqYXZhc2NyaXB0JywgJ3R5cGVzY3JpcHQnLCAnamF2YScsXG4gICAgICAgICAgICAnaHRtbCcsICdjc3MnLCAnY3BwJywgJ2NzaGFycCcsICdzcWwnLCAncnVzdCcsXG4gICAgICAgICAgICAncGhwJywgJ2Jhc2gnLCAnanNvbicsICd4bWwnLCAnbWFya2Rvd24nXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBJZiBjb25maWRlbmNlIGlzIHJlYXNvbmFibHkgaGlnaCwgdXNlIHRoYXQgbGFuZ3VhZ2VcbiAgICAgICAgaWYgKHJlc3VsdC5yZWxldmFuY2UgPiA1ICYmIHJlc3VsdC5sYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5sYW5ndWFnZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gYmFzaWMgcGF0dGVybiBtYXRjaGluZyBmb3IgYmV0dGVyIGFjY3VyYWN5IG9uIGFtYmlndW91cyBjYXNlc1xuICAgICAgICBpZiAoL14oPzpcXHMqKT8oPzppbXBvcnRcXHMrW147XSs7fHBhY2thZ2VcXHMrW147XSs7fHB1YmxpY1xccytjbGFzcykvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnamF2YSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oaW1wb3J0fGZyb218ZGVmfGNsYXNzfGlmIF9fbmFtZV9fKS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdweXRob24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86ZnVuY3Rpb258Y29uc3R8bGV0fHZhcnxpbXBvcnR8ZXhwb3J0fD0+KS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgLy8gQnJvYWRlciBjaGVjayBmb3IgSlMvVFNcbiAgICAgICAgICAgIGlmICgvXig/OlxccyopPyg/OmltcG9ydFxccy4rfGV4cG9ydFxccy4rfGludGVyZmFjZXx0eXBlfGVudW18ZGVjbGFyZXw6fFxcczwpLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0eXBlc2NyaXB0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnamF2YXNjcmlwdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzo8IURPQ1RZUEV8PGh0bWx8PGhlYWR8PGJvZHkpL2kudGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdodG1sJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyNpbmNsdWRlLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NwcCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzp1c2luZ1xccytTeXN0ZW18bmFtZXNwYWNlfHB1YmxpY1xccytzdGF0aWNcXHMrdm9pZFxccytNYWluKS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdjc2hhcnAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86U0VMRUNUfElOU0VSVHxVUERBVEV8REVMRVRFfENSRUFURXxBTFRFUilcXHMvaS50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NxbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzpmbnxsZXR8c3RydWN0fGVudW18dHJhaXR8aW1wbHxtb2QpXFxzLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3J1c3QnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86PFxcP3BocHx1c2VcXHMrW1xcd1xcXFxdKzspLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3BocCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzojXFxzKiFcXC9iaW5cXC8oPzpiYXNofHNofHpzaCl8XFwkKS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdiYXNoJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXlxccypcXHsvLnRlc3QoY29kZSkgJiYgL1xcfVxccyokLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUgY2hlY2sgZm9yIEpTT04tbGlrZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHJldHVybiAnanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL15cXHMqPFxcP3htbC8udGVzdChjb2RlKSB8fCAvXlxccyo8XFx3Ky8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIGNoZWNrIGZvciBYTUwvSFRNTCBsaWtlIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0dXJuICd4bWwnO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHNwZWNpZmljIGxhbmd1YWdlIGRldGVjdGVkLCByZXR1cm4gZW1wdHkgc3RyaW5nIGZvciBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGVjdGluZyBsYW5ndWFnZTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiAnJzsgLy8gUmV0dXJuIGVtcHR5IG9uIGVycm9yXG4gICAgfVxufVxuLyoqXG4gKiBIaWdobGlnaHRzIGNvZGUgdXNpbmcgaGlnaGxpZ2h0LmpzLlxuICogRmFsbHMgYmFjayB0byBhdXRvLWRldGVjdGlvbiBpZiB0aGUgc3BlY2lmaWVkIGxhbmd1YWdlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobGFuZ3VhZ2UgJiYgaGlnaGxpZ2h0X2pzXzEuZGVmYXVsdC5nZXRMYW5ndWFnZShsYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmhpZ2hsaWdodChjb2RlLCB7IGxhbmd1YWdlLCBpZ25vcmVJbGxlZ2FsczogdHJ1ZSB9KS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGF1dG8tZGV0ZWN0aW9uIGlmIGxhbmd1YWdlIGlzIGVtcHR5IG9yIG5vdCByZWdpc3RlcmVkXG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0X2pzXzEuZGVmYXVsdC5oaWdobGlnaHRBdXRvKGNvZGUpLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBoaWdobGlnaHRpbmcgY29kZSAobGFuZ3VhZ2U6ICR7bGFuZ3VhZ2UgfHwgJ2F1dG8nfSk6YCwgZXJyb3IpO1xuICAgICAgICAvLyBSZXR1cm4gb3JpZ2luYWwgY29kZSBlc2NhcGVkIGZvciBzYWZldHkgb24gZXJyb3JcbiAgICAgICAgcmV0dXJuIGNvZGUucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbmZpZ3VyZU1hcmtlZCA9IGNvbmZpZ3VyZU1hcmtlZDtcbmV4cG9ydHMucHJlcHJvY2Vzc01hcmtkb3duID0gcHJlcHJvY2Vzc01hcmtkb3duO1xuY29uc3QgbWFya2VkXzEgPSByZXF1aXJlKFwibWFya2VkXCIpO1xuLyoqXG4gKiBDb25maWd1cmUgbWFya2VkIHdpdGggYmV0dGVyIHJlbmRlcmluZyBvcHRpb25zIGZvciBjb2RlIGJsb2Nrc1xuICovXG5mdW5jdGlvbiBjb25maWd1cmVNYXJrZWQoKSB7XG4gICAgLy8gQ29uZmlndXJlIG1hcmtlZCBvcHRpb25zXG4gICAgbWFya2VkXzEubWFya2VkLnNldE9wdGlvbnMoe1xuICAgICAgICBnZm06IHRydWUsIC8vIEVuYWJsZSBHaXRIdWIgRmxhdm9yZWQgTWFya2Rvd25cbiAgICAgICAgYnJlYWtzOiB0cnVlLCAvLyBBZGQgPGJyPiBvbiBzaW5nbGUgbGluZSBicmVha3NcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLCAvLyBDb25mb3JtIHRvIG9yaWdpbmFsIG1hcmtkb3duIHNwZWNcbiAgICAgICAgYXN5bmM6IGZhbHNlLCAvLyBEaXNhYmxlIGFzeW5jIHJlbmRlcmluZ1xuICAgICAgICBzaWxlbnQ6IGZhbHNlIC8vIEVuYWJsZSBlcnJvciByZXBvcnRpbmdcbiAgICB9KTtcbn1cbi8qKlxuICogUHJlLXByb2Nlc3MgbWFya2Rvd24gdGV4dCB0byBmaXggY29tbW9uIGlzc3VlcyB3aXRoIHN0cmVhbWluZyBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIHByZXByb2Nlc3NNYXJrZG93bih0ZXh0KSB7XG4gICAgLy8gTm9ybWFsaXplIGxpbmUgZW5kaW5nc1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgIC8vIEhhbmRsZSBjb2RlIGJsb2NrcyBmaXJzdFxuICAgIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVzID0gbm9ybWFsaXplZFRleHQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHByb2Nlc3NlZExpbmVzID0gbGluZXMubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlIGJsb2NrIG1hcmtlcnNcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2BgYCcpKSB7XG4gICAgICAgICAgICBpbkNvZGVCbG9jayA9ICFpbkNvZGVCbG9jaztcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxhbmd1YWdlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIGNvZGUgYmxvY2ssIHByZXNlcnZlIHRoZSBsaW5lIGFzIGlzXG4gICAgICAgIGlmIChpbkNvZGVCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3V0c2lkZSBjb2RlIGJsb2NrczpcbiAgICAgICAgLy8gMS4gSGFuZGxlIGxpc3QgaXRlbXMgd2l0aCBwcm9wZXIgc3BhY2luZ1xuICAgICAgICAvLyAyLiBUcmltIGV4Y2Vzc2l2ZSB3aGl0ZXNwYWNlIGF0IHN0YXJ0IGFuZCBlbmQsIGJ1dCBwcmVzZXJ2ZSBpbmRlbnRhdGlvbiB3aXRoaW4gbGluZXNcbiAgICAgICAgbGV0IHByb2Nlc3NlZCA9IGxpbmU7XG4gICAgICAgIC8vIEhhbmRsZSBkYXNoIGxpc3QgaXRlbXMgYnkgZW5zdXJpbmcgdGhleSBoYXZlIGEgc3BhY2UgYWZ0ZXIgdGhlIGRhc2hcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UoLyhcXHMqKS0oXFxTKS9nLCAnJDEtICQyJyk7XG4gICAgICAgIC8vIEhhbmRsZSBtaXhlZCBzcGFjZS9kYXNoIGlzc3VlcyAtIGVuc3VyZSBwcm9wZXIgbmV3bGluZXMgYmVmb3JlIGxpc3QgaXRlbXNcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UoLyhbXlxcblxcc10pLVxccy9nLCAnJDFcXG4tICcpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgIH0pO1xuICAgIC8vIEpvaW4gbGluZXMgYW5kIGVuc3VyZSBjb2RlIGJsb2NrcyBhcmUgcHJvcGVybHkgZm9ybWF0dGVkXG4gICAgbGV0IHJlc3VsdCA9IHByb2Nlc3NlZExpbmVzLmpvaW4oJ1xcbicpO1xuICAgIC8vIEhhbmRsZSBlbXB0eSBjb2RlIGJsb2NrcyAoYWRkIGEgc3BhY2Ugc28gdGhleSByZW5kZXIgcHJvcGVybHkpXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL2BgYCguKilcXG5gYGAvZywgJ2BgYCQxXFxuIFxcbmBgYCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVuZGVyTWFya2Rvd24gPSByZW5kZXJNYXJrZG93bjtcbi8qKlxuICogUmVuZGVycyBtYXJrZG93biB0ZXh0IHRvIEhUTUwuXG4gKiBAcGFyYW0gbWFya2Rvd25UZXh0IFRoZSBtYXJrZG93biB0ZXh0IHRvIHJlbmRlclxuICogQHJldHVybnMgSFRNTCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcmVuZGVyTWFya2Rvd24obWFya2Rvd25UZXh0KSB7XG4gICAgLy8gVGhpcyBpcyBhIHNpbXBsZSBpbXBsZW1lbnRhdGlvbi4gSW4gYSByZWFsIGFwcCwgeW91IHdvdWxkIHVzZSBhIGxpYnJhcnkgbGlrZSBtYXJrZWQuanNcbiAgICBpZiAoIW1hcmtkb3duVGV4dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIEJhc2ljIG1hcmtkb3duIGNvbnZlcnNpb25cbiAgICBsZXQgaHRtbCA9IG1hcmtkb3duVGV4dFxuICAgICAgICAvLyBIYW5kbGUgaGVhZGVyc1xuICAgICAgICAucmVwbGFjZSgvXiMgKC4qJCkvZ20sICc8aDE+JDE8L2gxPicpXG4gICAgICAgIC5yZXBsYWNlKC9eIyMgKC4qJCkvZ20sICc8aDI+JDE8L2gyPicpXG4gICAgICAgIC5yZXBsYWNlKC9eIyMjICguKiQpL2dtLCAnPGgzPiQxPC9oMz4nKVxuICAgICAgICAucmVwbGFjZSgvXiMjIyMgKC4qJCkvZ20sICc8aDQ+JDE8L2g0PicpXG4gICAgICAgIC5yZXBsYWNlKC9eIyMjIyMgKC4qJCkvZ20sICc8aDU+JDE8L2g1PicpXG4gICAgICAgIC5yZXBsYWNlKC9eIyMjIyMjICguKiQpL2dtLCAnPGg2PiQxPC9oNj4nKVxuICAgICAgICAvLyBIYW5kbGUgYm9sZFxuICAgICAgICAucmVwbGFjZSgvXFwqXFwqKC4qPylcXCpcXCovZywgJzxzdHJvbmc+JDE8L3N0cm9uZz4nKVxuICAgICAgICAucmVwbGFjZSgvX18oLio/KV9fL2csICc8c3Ryb25nPiQxPC9zdHJvbmc+JylcbiAgICAgICAgLy8gSGFuZGxlIGl0YWxpY1xuICAgICAgICAucmVwbGFjZSgvXFwqKC4qPylcXCovZywgJzxlbT4kMTwvZW0+JylcbiAgICAgICAgLnJlcGxhY2UoL18oLio/KV8vZywgJzxlbT4kMTwvZW0+JylcbiAgICAgICAgLy8gSGFuZGxlIGxpbmtzXG4gICAgICAgIC5yZXBsYWNlKC9cXFsoLio/KVxcXVxcKCguKj8pXFwpL2csICc8YSBocmVmPVwiJDJcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lclwiPiQxPC9hPicpXG4gICAgICAgIC8vIEhhbmRsZSBjb2RlIGJsb2Nrc1xuICAgICAgICAucmVwbGFjZSgvYGBgKFtcXHNcXFNdKj8pYGBgL2csICc8cHJlPjxjb2RlPiQxPC9jb2RlPjwvcHJlPicpXG4gICAgICAgIC8vIEhhbmRsZSBpbmxpbmUgY29kZVxuICAgICAgICAucmVwbGFjZSgvYCguKj8pYC9nLCAnPGNvZGU+JDE8L2NvZGU+JylcbiAgICAgICAgLy8gSGFuZGxlIGhvcml6b250YWwgcnVsZXNcbiAgICAgICAgLnJlcGxhY2UoL14tLS0kL2dtLCAnPGhyPicpXG4gICAgICAgIC8vIEhhbmRsZSB1bm9yZGVyZWQgbGlzdHNcbiAgICAgICAgLnJlcGxhY2UoL15cXCogKC4qJCkvZ20sICc8dWw+PGxpPiQxPC9saT48L3VsPicpXG4gICAgICAgIC5yZXBsYWNlKC9eLSAoLiokKS9nbSwgJzx1bD48bGk+JDE8L2xpPjwvdWw+JylcbiAgICAgICAgLy8gSGFuZGxlIG9yZGVyZWQgbGlzdHNcbiAgICAgICAgLnJlcGxhY2UoL15cXGQrXFwuICguKiQpL2dtLCAnPG9sPjxsaT4kMTwvbGk+PC9vbD4nKVxuICAgICAgICAvLyBIYW5kbGUgYmxvY2txdW90ZXNcbiAgICAgICAgLnJlcGxhY2UoL14+ICguKiQpL2dtLCAnPGJsb2NrcXVvdGU+JDE8L2Jsb2NrcXVvdGU+JylcbiAgICAgICAgLy8gSGFuZGxlIHBhcmFncmFwaHMgLSBlbnN1cmVzIGRvdWJsZSBuZXdsaW5lcyBjcmVhdGUgcCB0YWdzXG4gICAgICAgIC5yZXBsYWNlKC9cXG5cXG4vZywgJzwvcD48cD4nKTtcbiAgICAvLyBXcmFwIGluIHBhcmFncmFwaCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXG4gICAgaWYgKCFodG1sLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgICBodG1sID0gJzxwPicgKyBodG1sICsgJzwvcD4nO1xuICAgIH1cbiAgICAvLyBGaXggbmVzdGVkIGxpc3QgaXRlbXNcbiAgICBodG1sID0gaHRtbFxuICAgICAgICAucmVwbGFjZSgvPFxcL3VsPlxccyo8dWw+L2csICcnKVxuICAgICAgICAucmVwbGFjZSgvPFxcL29sPlxccyo8b2w+L2csICcnKTtcbiAgICByZXR1cm4gaHRtbDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRNZXNzYWdlVG9DZWxsID0gYWRkTWVzc2FnZVRvQ2VsbDtcbmV4cG9ydHMuZ2V0U2VsZWN0ZWRUZXh0ID0gZ2V0U2VsZWN0ZWRUZXh0O1xuZXhwb3J0cy5pc0luTm90ZWJvb2tDZWxsID0gaXNJbk5vdGVib29rQ2VsbDtcbmV4cG9ydHMuaXNJbk5vdGVib29rQ2VsbEFuZEVkaXRvckZvY3VzZWQgPSBpc0luTm90ZWJvb2tDZWxsQW5kRWRpdG9yRm9jdXNlZDtcbmV4cG9ydHMuaXNDb2RlQ2VsbCA9IGlzQ29kZUNlbGw7XG5leHBvcnRzLmlzT3V0cHV0QXJlYSA9IGlzT3V0cHV0QXJlYTtcbmV4cG9ydHMuZ2V0Q3VycmVudENlbGxDb250ZW50ID0gZ2V0Q3VycmVudENlbGxDb250ZW50O1xuZXhwb3J0cy5pbnNlcnRDZWxsQ29udGVudEJ5SW5kZXggPSBpbnNlcnRDZWxsQ29udGVudEJ5SW5kZXg7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpO1xuLyoqXG4gKiBBZGRzIG1lc3NhZ2UgY29udGVudCB0byB0aGUgY3VycmVudCBjZWxsIGluIHRoZSBhY3RpdmUgbm90ZWJvb2suXG4gKi9cbmZ1bmN0aW9uIGFkZE1lc3NhZ2VUb0NlbGwodGV4dCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICBpZiAoIWNlbGwgfHwgIWNlbGwuZWRpdG9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGFkZCBtZXNzYWdlOiBObyBhY3RpdmUgY2VsbCBvciBlZGl0b3IgZm91bmQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgIC8vIEFjY2VzcyB0aGUgdW5kZXJseWluZyBDb2RlTWlycm9yIGVkaXRvciB2aWV3IChhZGp1c3QgaWYgdXNpbmcgYSBkaWZmZXJlbnQgZWRpdG9yKVxuICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBhZGQgbWVzc2FnZTogQ29kZU1pcnJvciB2aWV3IG5vdCBhY2Nlc3NpYmxlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgY3Vyc29yUG9zID0gc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgLy8gSW5zZXJ0IG5ld2xpbmUgYW5kIG1lc3NhZ2UgY29udGVudCBhdCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgICAgIGZyb206IGN1cnNvclBvcyxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IGBcXG4ke3RleHR9YFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgbW92ZSBjdXJzb3IgdG8gZW5kIG9mIGluc2VydGVkIHRleHRcbiAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGN1cnNvclBvcyArIHRleHQubGVuZ3RoICsgMSB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBtZXNzYWdlIHRvIGNlbGw6JywgZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgZnJvbTpcbiAqICAtIHRoZSBhY3RpdmUgbm90ZWJvb2sgY2VsbFxuICogIC0gdGhlIHRleHQgZWRpdG9yXG4gKiAgLSB0aGUgb3V0cHV0IGFyZWEgb2YgYSBjb2RlIGNlbGxcbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRUZXh0KCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIGlmIChpc091dHB1dEFyZWEoKSkge1xuICAgIC8vICAgLy8gVE9ETzogcmV0dXJuIHdoYXQncyBzZWxlY3RlZCBpbiB0aGUgb3V0cHV0IGFyZWFcbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICBpZiAoY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLmVkaXRvcikge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IuZWRpdG9yOyAvLyBBY2Nlc3MgQ29kZU1pcnJvciBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgaWYgKGNtRWRpdG9yICYmIGNtRWRpdG9yLnN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNtRWRpdG9yLnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmVtcHR5ID8gbnVsbCA6IHN0YXRlLmRvYy5zbGljZVN0cmluZyhzZWxlY3Rpb24uZnJvbSwgc2VsZWN0aW9uLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgYWNjZXNzIENvZGVNaXJyb3Igc3RhdGUgdG8gZ2V0IHNlbGVjdGlvbi5cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1ub3RlYm9vayBlZGl0b3JzIChlLmcuLCB0ZXh0IGVkaXRvcilcbiAgICAgICAgY29uc3QgYWN0aXZlV2lkZ2V0ID0gKF9jID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuYXBwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hlbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBpZiAoYWN0aXZlV2lkZ2V0ICYmICdjb250ZW50JyBpbiBhY3RpdmVXaWRnZXQgJiYgYWN0aXZlV2lkZ2V0LmNvbnRlbnQuZWRpdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVXaWRnZXQuY29udGVudC5lZGl0b3I7XG4gICAgICAgICAgICBjb25zdCBjbUVkaXRvciA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICBpZiAoY21FZGl0b3IgJiYgY21FZGl0b3Iuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNtRWRpdG9yLnN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uZW1wdHkgPyBudWxsIDogc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFjY2VzcyBDb2RlTWlycm9yIHN0YXRlIGZvciBub24tbm90ZWJvb2sgZWRpdG9yIHNlbGVjdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBpbiBhIG5vdGVib29rIGNlbGwuXG4qL1xuZnVuY3Rpb24gaXNJbk5vdGVib29rQ2VsbCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWN0aXZlQ2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgcmV0dXJuIGFjdGl2ZUNlbGwgIT09IG51bGw7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBub3RlYm9vayBjZWxsIGFuZCB0aGUgZWRpdG9yIGlzIGZvY3VzZWQ6XG4gKiBtZWFuaW5nIHRoYXQgdGhlIGN1cnNvciBpcyBpbiB0aGUgZWRpdG9yLlxuKi9cbmZ1bmN0aW9uIGlzSW5Ob3RlYm9va0NlbGxBbmRFZGl0b3JGb2N1c2VkKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhY3RpdmVDZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICBpZiAoYWN0aXZlQ2VsbCA9PT0gbnVsbCB8fCBhY3RpdmVDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVDZWxsLmVkaXRvcikge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVDZWxsLmVkaXRvcjtcbiAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IuZWRpdG9yOyAvLyBBY2Nlc3MgQ29kZU1pcnJvciBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgcmV0dXJuIGNtRWRpdG9yICYmIGNtRWRpdG9yLnN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnRseSBhY3RpdmUgY2VsbCBpcyBhIGNvZGUgY2VsbC5cbiovXG5mdW5jdGlvbiBpc0NvZGVDZWxsKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYWN0aXZlQ2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgcmV0dXJuICgoX2IgPSBhY3RpdmVDZWxsID09PSBudWxsIHx8IGFjdGl2ZUNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUNlbGwubW9kZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gJ2NvZGUnO1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJzb3IgaXMgaW4gdGhlIG91dHB1dCBhcmVhIG9mIGEgY29kZSBjZWxsLlxuICogVGhpcyBmdW5jdGlvbiBzcGVjaWZpY2FsbHkgY2hlY2tzIGlmIHdlJ3JlIGluIGEgY29kZSBjZWxsJ3Mgb3V0cHV0IGFyZWEsXG4gKiBub3QganVzdCBhbnkgb3V0cHV0IGFyZWEuXG4gKi9cbmZ1bmN0aW9uIGlzT3V0cHV0QXJlYSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWN0aXZlQ2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgaWYgKCEoYWN0aXZlQ2VsbCA9PT0gbnVsbCB8fCBhY3RpdmVDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVDZWxsLm1vZGVsKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGl0J3MgYSBjb2RlIGNlbGxcbiAgICBpZiAoYWN0aXZlQ2VsbC5tb2RlbC50eXBlICE9PSAnY29kZScpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBUaGVuIGNoZWNrIGlmIHdlJ3JlIGluIHRoZSBvdXRwdXQgYXJlYVxuICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZUNlbGwuZWRpdG9yO1xuICAgIGlmICghZWRpdG9yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IuZWRpdG9yO1xuICAgIGlmICghKGNtRWRpdG9yID09PSBudWxsIHx8IGNtRWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbUVkaXRvci5zdGF0ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBHZXQgdGhlIGVkaXRvcidzIERPTSBlbGVtZW50XG4gICAgY29uc3QgZWRpdG9yRWxlbWVudCA9IGNtRWRpdG9yLmRvbTtcbiAgICBpZiAoIWVkaXRvckVsZW1lbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgd2l0aGluIHRoZSBvdXRwdXQgYXJlYVxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghYWN0aXZlRWxlbWVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFRoZSBvdXRwdXQgYXJlYSBpcyB0eXBpY2FsbHkgYSBzaWJsaW5nIG9mIHRoZSBlZGl0b3IgZWxlbWVudFxuICAgIGNvbnN0IG91dHB1dEFyZWEgPSBlZGl0b3JFbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcbiAgICBpZiAoIW91dHB1dEFyZWEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb3V0cHV0QXJlYS5jb250YWlucyhhY3RpdmVFbGVtZW50KTtcbn1cbi8qKlxuICogR2V0cyB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBub3RlYm9vayBjZWxsIG9yIHRleHQgZWRpdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50Q2VsbENvbnRlbnQoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBhY3RpdmVDZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICBpZiAoYWN0aXZlQ2VsbCA9PT0gbnVsbCB8fCBhY3RpdmVDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVDZWxsLm1vZGVsKSB7XG4gICAgICAgIC8vIFRyeSB1c2luZyBzaGFyZWRNb2RlbCBmaXJzdCAobW9yZSByb2J1c3QpXG4gICAgICAgIGlmIChhY3RpdmVDZWxsLm1vZGVsLnNoYXJlZE1vZGVsICYmIHR5cGVvZiBhY3RpdmVDZWxsLm1vZGVsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUNlbGwubW9kZWwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2s6IFRyeSB1c2luZyB0b0pTT04oKS5zb3VyY2VcbiAgICAgICAgY29uc3QgY2VsbEpzb24gPSBhY3RpdmVDZWxsLm1vZGVsLnRvSlNPTigpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlO1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBnZXQgY2VsbCBjb250ZW50IHZpYSBzaGFyZWRNb2RlbCBvciB0b0pTT04oKS5zb3VyY2VcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLW5vdGVib29rIGVkaXRvcnMgaWYgbmVlZGVkXG4gICAgY29uc3QgYWN0aXZlV2lkZ2V0ID0gKF9jID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuYXBwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hlbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50V2lkZ2V0O1xuICAgIGlmIChhY3RpdmVXaWRnZXQgJiYgJ2NvbnRlbnQnIGluIGFjdGl2ZVdpZGdldCAmJiBhY3RpdmVXaWRnZXQuY29udGVudC5tb2RlbCkge1xuICAgICAgICAvLyBBc3N1bWluZyBtb2RlbC52YWx1ZS50ZXh0IGZvciBnZW5lcmljIHRleHQgZWRpdG9yc1xuICAgICAgICByZXR1cm4gKF9lID0gKF9kID0gYWN0aXZlV2lkZ2V0LmNvbnRlbnQubW9kZWwudmFsdWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50ZXh0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2V0cyBjZWxsIGNvbnRlbnQgYnkgaW5kZXggZnJvbSB0aGUgY3VycmVudCBub3RlYm9vayBhbmQgY2FsbHMgYSBjYWxsYmFjayB0byBpbnNlcnQgaXQuXG4gKiBOT1RFOiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gY2FsbGVkIGB0aGlzLmFwcGVuZFRvSW5wdXRgLiBUaGlzIGZ1bmN0aW9uYWxpdHkgbmVlZHNcbiAqICAgICAgIHRvIGJlIHByb3ZpZGVkIHZpYSB0aGUgYGluc2VydENhbGxiYWNrYC5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q2VsbENvbnRlbnRCeUluZGV4KGluZGV4LCBpbnNlcnRDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyIHx8ICFnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gYWN0aXZlIG5vdGVib29rIGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90ZWJvb2tQYW5lbCA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBjb25zdCBtb2RlbCA9IG5vdGVib29rUGFuZWwuY29udGVudC5tb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbCB8fCAhbW9kZWwuY2VsbHMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IG1vZGVsLmNlbGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBjZWxsIGluZGV4OiAke2luZGV4fWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGwgPSBtb2RlbC5jZWxscy5nZXQoaW5kZXgpO1xuICAgICAgICBsZXQgY2VsbENvbnRlbnQgPSAnJztcbiAgICAgICAgLy8gR2V0IGNlbGwgY29udGVudCAtIGhhbmRsZSBkaWZmZXJlbnQgd2F5cyBjb250ZW50IG1pZ2h0IGJlIHN0b3JlZFxuICAgICAgICBpZiAoY2VsbC5zaGFyZWRNb2RlbCAmJiB0eXBlb2YgY2VsbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNlbGxDb250ZW50ID0gY2VsbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxKc29uID0gY2VsbC50b0pTT04oKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGNlbGxKc29uID09PSBudWxsIHx8IGNlbGxKc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsSnNvbi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNlbGxDb250ZW50ID0gc291cmNlLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCBjZWxsIHJlZmVyZW5jZSB3aXRoIGNvbnRlbnQgdXNpbmcgdGhlIGNhbGxiYWNrXG4gICAgICAgIGluc2VydENhbGxiYWNrKGBjZWxsICR7Y2VsbENvbnRlbnR9YCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbnNlcnRpbmcgY2VsbCBieSBpbmRleDonLCBlcnJvcik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9