"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_apl_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/apl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/apl.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   apl: () => (/* binding */ apl)
/* harmony export */ });
var builtInFuncs = {
  "+": ["conjugate", "add"],
  "−": ["negate", "subtract"],
  "×": ["signOf", "multiply"],
  "÷": ["reciprocal", "divide"],
  "⌈": ["ceiling", "greaterOf"],
  "⌊": ["floor", "lesserOf"],
  "∣": ["absolute", "residue"],
  "⍳": ["indexGenerate", "indexOf"],
  "?": ["roll", "deal"],
  "⋆": ["exponentiate", "toThePowerOf"],
  "⍟": ["naturalLog", "logToTheBase"],
  "○": ["piTimes", "circularFuncs"],
  "!": ["factorial", "binomial"],
  "⌹": ["matrixInverse", "matrixDivide"],
  "<": [null, "lessThan"],
  "≤": [null, "lessThanOrEqual"],
  "=": [null, "equals"],
  ">": [null, "greaterThan"],
  "≥": [null, "greaterThanOrEqual"],
  "≠": [null, "notEqual"],
  "≡": ["depth", "match"],
  "≢": [null, "notMatch"],
  "∈": ["enlist", "membership"],
  "⍷": [null, "find"],
  "∪": ["unique", "union"],
  "∩": [null, "intersection"],
  "∼": ["not", "without"],
  "∨": [null, "or"],
  "∧": [null, "and"],
  "⍱": [null, "nor"],
  "⍲": [null, "nand"],
  "⍴": ["shapeOf", "reshape"],
  ",": ["ravel", "catenate"],
  "⍪": [null, "firstAxisCatenate"],
  "⌽": ["reverse", "rotate"],
  "⊖": ["axis1Reverse", "axis1Rotate"],
  "⍉": ["transpose", null],
  "↑": ["first", "take"],
  "↓": [null, "drop"],
  "⊂": ["enclose", "partitionWithAxis"],
  "⊃": ["diclose", "pick"],
  "⌷": [null, "index"],
  "⍋": ["gradeUp", null],
  "⍒": ["gradeDown", null],
  "⊤": ["encode", null],
  "⊥": ["decode", null],
  "⍕": ["format", "formatByExample"],
  "⍎": ["execute", null],
  "⊣": ["stop", "left"],
  "⊢": ["pass", "right"]
};

var isOperator = /[\.\/⌿⍀¨⍣]/;
var isNiladic = /⍬/;
var isFunction = /[\+−×÷⌈⌊∣⍳\?⋆⍟○!⌹<≤=>≥≠≡≢∈⍷∪∩∼∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⌷⍋⍒⊤⊥⍕⍎⊣⊢]/;
var isArrow = /←/;
var isComment = /[⍝#].*$/;

var stringEater = function(type) {
  var prev;
  prev = false;
  return function(c) {
    prev = c;
    if (c === type) {
      return prev === "\\";
    }
    return true;
  };
};

const apl = {
  name: "apl",
  startState: function() {
    return {
      prev: false,
      func: false,
      op: false,
      string: false,
      escape: false
    };
  },
  token: function(stream, state) {
    var ch;
    if (stream.eatSpace()) {
      return null;
    }
    ch = stream.next();
    if (ch === '"' || ch === "'") {
      stream.eatWhile(stringEater(ch));
      stream.next();
      state.prev = true;
      return "string";
    }
    if (/[\[{\(]/.test(ch)) {
      state.prev = false;
      return null;
    }
    if (/[\]}\)]/.test(ch)) {
      state.prev = true;
      return null;
    }
    if (isNiladic.test(ch)) {
      state.prev = false;
      return "atom";
    }
    if (/[¯\d]/.test(ch)) {
      if (state.func) {
        state.func = false;
        state.prev = false;
      } else {
        state.prev = true;
      }
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (isOperator.test(ch)) {
      return "operator"
    }
    if (isArrow.test(ch)) {
      return "operator";
    }
    if (isFunction.test(ch)) {
      state.func = true;
      state.prev = false;
      return builtInFuncs[ch] ? "variableName.function.standard" : "variableName.function"
    }
    if (isComment.test(ch)) {
      stream.skipToEnd();
      return "comment";
    }
    if (ch === "∘" && stream.peek() === ".") {
      stream.next();
      return "variableName.function";
    }
    stream.eatWhile(/[\w\$_]/);
    state.prev = true;
    return "keyword";
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfYXBsX2pzLjA1YzhjMGIxNzliODdmOTljMWY4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvYXBsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBidWlsdEluRnVuY3MgPSB7XG4gIFwiK1wiOiBbXCJjb25qdWdhdGVcIiwgXCJhZGRcIl0sXG4gIFwi4oiSXCI6IFtcIm5lZ2F0ZVwiLCBcInN1YnRyYWN0XCJdLFxuICBcIsOXXCI6IFtcInNpZ25PZlwiLCBcIm11bHRpcGx5XCJdLFxuICBcIsO3XCI6IFtcInJlY2lwcm9jYWxcIiwgXCJkaXZpZGVcIl0sXG4gIFwi4oyIXCI6IFtcImNlaWxpbmdcIiwgXCJncmVhdGVyT2ZcIl0sXG4gIFwi4oyKXCI6IFtcImZsb29yXCIsIFwibGVzc2VyT2ZcIl0sXG4gIFwi4oijXCI6IFtcImFic29sdXRlXCIsIFwicmVzaWR1ZVwiXSxcbiAgXCLijbNcIjogW1wiaW5kZXhHZW5lcmF0ZVwiLCBcImluZGV4T2ZcIl0sXG4gIFwiP1wiOiBbXCJyb2xsXCIsIFwiZGVhbFwiXSxcbiAgXCLii4ZcIjogW1wiZXhwb25lbnRpYXRlXCIsIFwidG9UaGVQb3dlck9mXCJdLFxuICBcIuKNn1wiOiBbXCJuYXR1cmFsTG9nXCIsIFwibG9nVG9UaGVCYXNlXCJdLFxuICBcIuKXi1wiOiBbXCJwaVRpbWVzXCIsIFwiY2lyY3VsYXJGdW5jc1wiXSxcbiAgXCIhXCI6IFtcImZhY3RvcmlhbFwiLCBcImJpbm9taWFsXCJdLFxuICBcIuKMuVwiOiBbXCJtYXRyaXhJbnZlcnNlXCIsIFwibWF0cml4RGl2aWRlXCJdLFxuICBcIjxcIjogW251bGwsIFwibGVzc1RoYW5cIl0sXG4gIFwi4omkXCI6IFtudWxsLCBcImxlc3NUaGFuT3JFcXVhbFwiXSxcbiAgXCI9XCI6IFtudWxsLCBcImVxdWFsc1wiXSxcbiAgXCI+XCI6IFtudWxsLCBcImdyZWF0ZXJUaGFuXCJdLFxuICBcIuKJpVwiOiBbbnVsbCwgXCJncmVhdGVyVGhhbk9yRXF1YWxcIl0sXG4gIFwi4omgXCI6IFtudWxsLCBcIm5vdEVxdWFsXCJdLFxuICBcIuKJoVwiOiBbXCJkZXB0aFwiLCBcIm1hdGNoXCJdLFxuICBcIuKJolwiOiBbbnVsbCwgXCJub3RNYXRjaFwiXSxcbiAgXCLiiIhcIjogW1wiZW5saXN0XCIsIFwibWVtYmVyc2hpcFwiXSxcbiAgXCLijbdcIjogW251bGwsIFwiZmluZFwiXSxcbiAgXCLiiKpcIjogW1widW5pcXVlXCIsIFwidW5pb25cIl0sXG4gIFwi4oipXCI6IFtudWxsLCBcImludGVyc2VjdGlvblwiXSxcbiAgXCLiiLxcIjogW1wibm90XCIsIFwid2l0aG91dFwiXSxcbiAgXCLiiKhcIjogW251bGwsIFwib3JcIl0sXG4gIFwi4oinXCI6IFtudWxsLCBcImFuZFwiXSxcbiAgXCLijbFcIjogW251bGwsIFwibm9yXCJdLFxuICBcIuKNslwiOiBbbnVsbCwgXCJuYW5kXCJdLFxuICBcIuKNtFwiOiBbXCJzaGFwZU9mXCIsIFwicmVzaGFwZVwiXSxcbiAgXCIsXCI6IFtcInJhdmVsXCIsIFwiY2F0ZW5hdGVcIl0sXG4gIFwi4o2qXCI6IFtudWxsLCBcImZpcnN0QXhpc0NhdGVuYXRlXCJdLFxuICBcIuKMvVwiOiBbXCJyZXZlcnNlXCIsIFwicm90YXRlXCJdLFxuICBcIuKKllwiOiBbXCJheGlzMVJldmVyc2VcIiwgXCJheGlzMVJvdGF0ZVwiXSxcbiAgXCLijYlcIjogW1widHJhbnNwb3NlXCIsIG51bGxdLFxuICBcIuKGkVwiOiBbXCJmaXJzdFwiLCBcInRha2VcIl0sXG4gIFwi4oaTXCI6IFtudWxsLCBcImRyb3BcIl0sXG4gIFwi4oqCXCI6IFtcImVuY2xvc2VcIiwgXCJwYXJ0aXRpb25XaXRoQXhpc1wiXSxcbiAgXCLiioNcIjogW1wiZGljbG9zZVwiLCBcInBpY2tcIl0sXG4gIFwi4oy3XCI6IFtudWxsLCBcImluZGV4XCJdLFxuICBcIuKNi1wiOiBbXCJncmFkZVVwXCIsIG51bGxdLFxuICBcIuKNklwiOiBbXCJncmFkZURvd25cIiwgbnVsbF0sXG4gIFwi4oqkXCI6IFtcImVuY29kZVwiLCBudWxsXSxcbiAgXCLiiqVcIjogW1wiZGVjb2RlXCIsIG51bGxdLFxuICBcIuKNlVwiOiBbXCJmb3JtYXRcIiwgXCJmb3JtYXRCeUV4YW1wbGVcIl0sXG4gIFwi4o2OXCI6IFtcImV4ZWN1dGVcIiwgbnVsbF0sXG4gIFwi4oqjXCI6IFtcInN0b3BcIiwgXCJsZWZ0XCJdLFxuICBcIuKKolwiOiBbXCJwYXNzXCIsIFwicmlnaHRcIl1cbn07XG5cbnZhciBpc09wZXJhdG9yID0gL1tcXC5cXC/ijL/ijYDCqOKNo10vO1xudmFyIGlzTmlsYWRpYyA9IC/ijawvO1xudmFyIGlzRnVuY3Rpb24gPSAvW1xcK+KIksOXw7fijIjijIriiKPijbNcXD/ii4bijZ/il4sh4oy5POKJpD0+4oml4omg4omh4omi4oiI4o234oiq4oip4oi84oio4oin4o2x4o2y4o20LOKNquKMveKKluKNieKGkeKGk+KKguKKg+KMt+KNi+KNkuKKpOKKpeKNleKNjuKKo+KKol0vO1xudmFyIGlzQXJyb3cgPSAv4oaQLztcbnZhciBpc0NvbW1lbnQgPSAvW+KNnSNdLiokLztcblxudmFyIHN0cmluZ0VhdGVyID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcHJldjtcbiAgcHJldiA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oYykge1xuICAgIHByZXYgPSBjO1xuICAgIGlmIChjID09PSB0eXBlKSB7XG4gICAgICByZXR1cm4gcHJldiA9PT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFwbCA9IHtcbiAgbmFtZTogXCJhcGxcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZXY6IGZhbHNlLFxuICAgICAgZnVuYzogZmFsc2UsXG4gICAgICBvcDogZmFsc2UsXG4gICAgICBzdHJpbmc6IGZhbHNlLFxuICAgICAgZXNjYXBlOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoc3RyaW5nRWF0ZXIoY2gpKTtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdGF0ZS5wcmV2ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoL1tcXFt7XFwoXS8udGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLnByZXYgPSBmYWxzZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoL1tcXF19XFwpXS8udGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLnByZXYgPSB0cnVlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc05pbGFkaWMudGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLnByZXYgPSBmYWxzZTtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9XG4gICAgaWYgKC9bwq9cXGRdLy50ZXN0KGNoKSkge1xuICAgICAgaWYgKHN0YXRlLmZ1bmMpIHtcbiAgICAgICAgc3RhdGUuZnVuYyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wcmV2ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wcmV2ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICBpZiAoaXNPcGVyYXRvci50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIlxuICAgIH1cbiAgICBpZiAoaXNBcnJvdy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24udGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLmZ1bmMgPSB0cnVlO1xuICAgICAgc3RhdGUucHJldiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGJ1aWx0SW5GdW5jc1tjaF0gPyBcInZhcmlhYmxlTmFtZS5mdW5jdGlvbi5zdGFuZGFyZFwiIDogXCJ2YXJpYWJsZU5hbWUuZnVuY3Rpb25cIlxuICAgIH1cbiAgICBpZiAoaXNDb21tZW50LnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIGlmIChjaCA9PT0gXCLiiJhcIiAmJiBzdHJlYW0ucGVlaygpID09PSBcIi5cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlTmFtZS5mdW5jdGlvblwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgIHN0YXRlLnByZXYgPSB0cnVlO1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9