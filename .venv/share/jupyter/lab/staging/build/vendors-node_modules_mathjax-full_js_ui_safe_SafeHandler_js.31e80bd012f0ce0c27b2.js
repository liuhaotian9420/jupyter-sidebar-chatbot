"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_ui_safe_SafeHandler_js"],{

/***/ "./node_modules/mathjax-full/js/ui/safe/SafeHandler.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/ui/safe/SafeHandler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeHandler = exports.SafeMathDocumentMixin = void 0;
var safe_js_1 = __webpack_require__(/*! ./safe.js */ "./node_modules/mathjax-full/js/ui/safe/safe.js");
function SafeMathDocumentMixin(BaseDocument) {
    var _a;
    return _a = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var e_1, _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
                _this.safe = new _this.options.SafeClass(_this, _this.options.safeOptions);
                var ProcessBits = _this.constructor.ProcessBits;
                if (!ProcessBits.has('safe')) {
                    ProcessBits.allocate('safe');
                }
                try {
                    for (var _b = __values(_this.inputJax), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var jax = _c.value;
                        if (jax.name.match(/MathML/)) {
                            jax.mathml.filterAttribute = _this.safe.mmlAttribute.bind(_this.safe);
                            jax.mathml.filterClassList = _this.safe.mmlClassList.bind(_this.safe);
                        }
                        else if (jax.name.match(/TeX/)) {
                            jax.postFilters.add(_this.sanitize.bind(jax), -5.5);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return _this;
            }
            class_1.prototype.sanitize = function (data) {
                data.math.root = this.parseOptions.root;
                data.document.safe.sanitize(data.math, data.document);
            };
            return class_1;
        }(BaseDocument)),
        _a.OPTIONS = __assign(__assign({}, BaseDocument.OPTIONS), { safeOptions: __assign({}, safe_js_1.Safe.OPTIONS), SafeClass: safe_js_1.Safe }),
        _a;
}
exports.SafeMathDocumentMixin = SafeMathDocumentMixin;
function SafeHandler(handler) {
    handler.documentClass = SafeMathDocumentMixin(handler.documentClass);
    return handler;
}
exports.SafeHandler = SafeHandler;
//# sourceMappingURL=SafeHandler.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/ui/safe/SafeMethods.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/ui/safe/SafeMethods.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeMethods = void 0;
var lengths_js_1 = __webpack_require__(/*! ../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
exports.SafeMethods = {
    filterURL: function (safe, url) {
        var protocol = (url.match(/^\s*([a-z]+):/i) || [null, ''])[1].toLowerCase();
        var allow = safe.allow.URLs;
        return (allow === 'all' || (allow === 'safe' &&
            (safe.options.safeProtocols[protocol] || !protocol))) ? url : null;
    },
    filterClassList: function (safe, list) {
        var _this = this;
        var classes = list.trim().replace(/\s\s+/g, ' ').split(/ /);
        return classes.map(function (name) { return _this.filterClass(safe, name) || ''; }).join(' ').trim().replace(/\s\s+/g, '');
    },
    filterClass: function (safe, CLASS) {
        var allow = safe.allow.classes;
        return (allow === 'all' || (allow === 'safe' && CLASS.match(safe.options.classPattern))) ? CLASS : null;
    },
    filterID: function (safe, id) {
        var allow = safe.allow.cssIDs;
        return (allow === 'all' || (allow === 'safe' && id.match(safe.options.idPattern))) ? id : null;
    },
    filterStyles: function (safe, styles) {
        var e_1, _a, e_2, _b;
        if (safe.allow.styles === 'all')
            return styles;
        if (safe.allow.styles !== 'safe')
            return null;
        var adaptor = safe.adaptor;
        var options = safe.options;
        try {
            var div1 = adaptor.node('div', { style: styles });
            var div2 = adaptor.node('div');
            try {
                for (var _c = __values(Object.keys(options.safeStyles)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var style = _d.value;
                    if (options.styleParts[style]) {
                        try {
                            for (var _e = (e_2 = void 0, __values(['Top', 'Right', 'Bottom', 'Left'])), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var sufix = _f.value;
                                var name_1 = style + sufix;
                                var value = this.filterStyle(safe, name_1, div1);
                                if (value) {
                                    adaptor.setStyle(div2, name_1, value);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    else {
                        var value = this.filterStyle(safe, style, div1);
                        if (value) {
                            adaptor.setStyle(div2, style, value);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            styles = adaptor.allStyles(div2);
        }
        catch (err) {
            styles = '';
        }
        return styles;
    },
    filterStyle: function (safe, style, div) {
        var value = safe.adaptor.getStyle(div, style);
        if (typeof value !== 'string' || value === '' || value.match(/^\s*calc/) ||
            (value.match(/javascript:/) && !safe.options.safeProtocols.javascript) ||
            (value.match(/data:/) && !safe.options.safeProtocols.data)) {
            return null;
        }
        var name = style.replace(/Top|Right|Left|Bottom/, '');
        if (!safe.options.safeStyles[style] && !safe.options.safeStyles[name]) {
            return null;
        }
        return this.filterStyleValue(safe, style, value, div);
    },
    filterStyleValue: function (safe, style, value, div) {
        var name = safe.options.styleLengths[style];
        if (!name) {
            return value;
        }
        if (typeof name !== 'string') {
            return this.filterStyleLength(safe, style, value);
        }
        var length = this.filterStyleLength(safe, name, safe.adaptor.getStyle(div, name));
        if (!length) {
            return null;
        }
        safe.adaptor.setStyle(div, name, length);
        return safe.adaptor.getStyle(div, style);
    },
    filterStyleLength: function (safe, style, value) {
        if (!value.match(/^(.+)(em|ex|ch|rem|px|mm|cm|in|pt|pc|%)$/))
            return null;
        var em = (0, lengths_js_1.length2em)(value, 1);
        var lengths = safe.options.styleLengths[style];
        var _a = __read((Array.isArray(lengths) ? lengths : [-safe.options.lengthMax, safe.options.lengthMax]), 2), m = _a[0], M = _a[1];
        return (m <= em && em <= M ? value : (em < m ? m : M).toFixed(3).replace(/\.?0+$/, '') + 'em');
    },
    filterFontSize: function (safe, size) {
        return this.filterStyleLength(safe, 'fontSize', size);
    },
    filterSizeMultiplier: function (safe, size) {
        var _a = __read(safe.options.scriptsizemultiplierRange || [-Infinity, Infinity], 2), m = _a[0], M = _a[1];
        return Math.min(M, Math.max(m, parseFloat(size))).toString();
    },
    filterScriptLevel: function (safe, level) {
        var _a = __read(safe.options.scriptlevelRange || [-Infinity, Infinity], 2), m = _a[0], M = _a[1];
        return Math.min(M, Math.max(m, parseInt(level))).toString();
    },
    filterData: function (safe, value, id) {
        return (id.match(safe.options.dataPattern) ? value : null);
    }
};
//# sourceMappingURL=SafeMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/ui/safe/safe.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/ui/safe/safe.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Safe = void 0;
var Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var SafeMethods_js_1 = __webpack_require__(/*! ./SafeMethods.js */ "./node_modules/mathjax-full/js/ui/safe/SafeMethods.js");
var Safe = (function () {
    function Safe(document, options) {
        this.filterAttributes = new Map([
            ['href', 'filterURL'],
            ['src', 'filterURL'],
            ['altimg', 'filterURL'],
            ['class', 'filterClassList'],
            ['style', 'filterStyles'],
            ['id', 'filterID'],
            ['fontsize', 'filterFontSize'],
            ['mathsize', 'filterFontSize'],
            ['scriptminsize', 'filterFontSize'],
            ['scriptsizemultiplier', 'filterSizeMultiplier'],
            ['scriptlevel', 'filterScriptLevel'],
            ['data-', 'filterData']
        ]);
        this.filterMethods = __assign({}, SafeMethods_js_1.SafeMethods);
        this.adaptor = document.adaptor;
        this.options = options;
        this.allow = this.options.allow;
    }
    Safe.prototype.sanitize = function (math, document) {
        try {
            math.root.walkTree(this.sanitizeNode.bind(this));
        }
        catch (err) {
            document.options.compileError(document, math, err);
        }
    };
    Safe.prototype.sanitizeNode = function (node) {
        var e_1, _a;
        var attributes = node.attributes.getAllAttributes();
        try {
            for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var id = _c.value;
                var method = this.filterAttributes.get(id);
                if (method) {
                    var value = this.filterMethods[method](this, attributes[id]);
                    if (value) {
                        if (value !== (typeof value === 'number' ? parseFloat(attributes[id]) : attributes[id])) {
                            attributes[id] = value;
                        }
                    }
                    else {
                        delete attributes[id];
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Safe.prototype.mmlAttribute = function (id, value) {
        if (id === 'class')
            return null;
        var method = this.filterAttributes.get(id);
        var filter = (method || (id.substr(0, 5) === 'data-' ? this.filterAttributes.get('data-') : null));
        if (!filter) {
            return value;
        }
        var result = this.filterMethods[filter](this, value, id);
        return (typeof result === 'number' || typeof result === 'boolean' ? String(result) : result);
    };
    Safe.prototype.mmlClassList = function (list) {
        var _this = this;
        return list.map(function (name) { return _this.filterMethods.filterClass(_this, name); })
            .filter(function (value) { return value !== null; });
    };
    Safe.OPTIONS = {
        allow: {
            URLs: 'safe',
            classes: 'safe',
            cssIDs: 'safe',
            styles: 'safe'
        },
        lengthMax: 3,
        scriptsizemultiplierRange: [.6, 1],
        scriptlevelRange: [-2, 2],
        classPattern: /^mjx-[-a-zA-Z0-9_.]+$/,
        idPattern: /^mjx-[-a-zA-Z0-9_.]+$/,
        dataPattern: /^data-mjx-/,
        safeProtocols: (0, Options_js_1.expandable)({
            http: true,
            https: true,
            file: true,
            javascript: false,
            data: false
        }),
        safeStyles: (0, Options_js_1.expandable)({
            color: true,
            backgroundColor: true,
            border: true,
            cursor: true,
            margin: true,
            padding: true,
            textShadow: true,
            fontFamily: true,
            fontSize: true,
            fontStyle: true,
            fontWeight: true,
            opacity: true,
            outline: true
        }),
        styleParts: (0, Options_js_1.expandable)({
            border: true,
            padding: true,
            margin: true,
            outline: true
        }),
        styleLengths: (0, Options_js_1.expandable)({
            borderTop: 'borderTopWidth',
            borderRight: 'borderRightWidth',
            borderBottom: 'borderBottomWidth',
            borderLeft: 'borderLeftWidth',
            paddingTop: true,
            paddingRight: true,
            paddingBottom: true,
            paddingLeft: true,
            marginTop: true,
            marginRight: true,
            marginBottom: true,
            marginLeft: true,
            outlineTop: true,
            outlineRight: true,
            outlineBottom: true,
            outlineLeft: true,
            fontSize: [.707, 1.44]
        })
    };
    return Safe;
}());
exports.Safe = Safe;
//# sourceMappingURL=safe.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/Options.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/Options.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lookup = exports.separateOptions = exports.selectOptionsFromKeys = exports.selectOptions = exports.userOptions = exports.defaultOptions = exports.insert = exports.copy = exports.keys = exports.makeArray = exports.expandable = exports.Expandable = exports.OPTIONS = exports.REMOVE = exports.APPEND = exports.isObject = void 0;
var OBJECT = {}.constructor;
function isObject(obj) {
    return typeof obj === 'object' && obj !== null &&
        (obj.constructor === OBJECT || obj.constructor === Expandable);
}
exports.isObject = isObject;
exports.APPEND = '[+]';
exports.REMOVE = '[-]';
exports.OPTIONS = {
    invalidOption: 'warn',
    optionError: function (message, _key) {
        if (exports.OPTIONS.invalidOption === 'fatal') {
            throw new Error(message);
        }
        console.warn('MathJax: ' + message);
    }
};
var Expandable = (function () {
    function Expandable() {
    }
    return Expandable;
}());
exports.Expandable = Expandable;
function expandable(def) {
    return Object.assign(Object.create(Expandable.prototype), def);
}
exports.expandable = expandable;
function makeArray(x) {
    return Array.isArray(x) ? x : [x];
}
exports.makeArray = makeArray;
function keys(def) {
    if (!def) {
        return [];
    }
    return Object.keys(def).concat(Object.getOwnPropertySymbols(def));
}
exports.keys = keys;
function copy(def) {
    var e_1, _a;
    var props = {};
    try {
        for (var _b = __values(keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var prop = Object.getOwnPropertyDescriptor(def, key);
            var value = prop.value;
            if (Array.isArray(value)) {
                prop.value = insert([], value, false);
            }
            else if (isObject(value)) {
                prop.value = copy(value);
            }
            if (prop.enumerable) {
                props[key] = prop;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);
}
exports.copy = copy;
function insert(dst, src, warn) {
    var e_2, _a;
    if (warn === void 0) { warn = true; }
    var _loop_1 = function (key) {
        if (warn && dst[key] === undefined && dst.constructor !== Expandable) {
            if (typeof key === 'symbol') {
                key = key.toString();
            }
            exports.OPTIONS.optionError("Invalid option \"".concat(key, "\" (no default value)."), key);
            return "continue";
        }
        var sval = src[key], dval = dst[key];
        if (isObject(sval) && dval !== null &&
            (typeof dval === 'object' || typeof dval === 'function')) {
            var ids = keys(sval);
            if (Array.isArray(dval) &&
                ((ids.length === 1 && (ids[0] === exports.APPEND || ids[0] === exports.REMOVE) && Array.isArray(sval[ids[0]])) ||
                    (ids.length === 2 && ids.sort().join(',') === exports.APPEND + ',' + exports.REMOVE &&
                        Array.isArray(sval[exports.APPEND]) && Array.isArray(sval[exports.REMOVE])))) {
                if (sval[exports.REMOVE]) {
                    dval = dst[key] = dval.filter(function (x) { return sval[exports.REMOVE].indexOf(x) < 0; });
                }
                if (sval[exports.APPEND]) {
                    dst[key] = __spreadArray(__spreadArray([], __read(dval), false), __read(sval[exports.APPEND]), false);
                }
            }
            else {
                insert(dval, sval, warn);
            }
        }
        else if (Array.isArray(sval)) {
            dst[key] = [];
            insert(dst[key], sval, false);
        }
        else if (isObject(sval)) {
            dst[key] = copy(sval);
        }
        else {
            dst[key] = sval;
        }
    };
    try {
        for (var _b = __values(keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            _loop_1(key);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return dst;
}
exports.insert = insert;
function defaultOptions(options) {
    var defs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defs[_i - 1] = arguments[_i];
    }
    defs.forEach(function (def) { return insert(options, def, false); });
    return options;
}
exports.defaultOptions = defaultOptions;
function userOptions(options) {
    var defs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defs[_i - 1] = arguments[_i];
    }
    defs.forEach(function (def) { return insert(options, def, true); });
    return options;
}
exports.userOptions = userOptions;
function selectOptions(options) {
    var e_3, _a;
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var subset = {};
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            if (options.hasOwnProperty(key)) {
                subset[key] = options[key];
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return subset;
}
exports.selectOptions = selectOptions;
function selectOptionsFromKeys(options, object) {
    return selectOptions.apply(void 0, __spreadArray([options], __read(Object.keys(object)), false));
}
exports.selectOptionsFromKeys = selectOptionsFromKeys;
function separateOptions(options) {
    var e_4, _a, e_5, _b;
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var results = [];
    try {
        for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {
            var object = objects_1_1.value;
            var exists = {}, missing = {};
            try {
                for (var _c = (e_5 = void 0, __values(Object.keys(options || {}))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    (object[key] === undefined ? missing : exists)[key] = options[key];
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            results.push(exists);
            options = missing;
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    results.unshift(options);
    return results;
}
exports.separateOptions = separateOptions;
function lookup(name, lookup, def) {
    if (def === void 0) { def = null; }
    return (lookup.hasOwnProperty(name) ? lookup[name] : def);
}
exports.lookup = lookup;
//# sourceMappingURL=Options.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/lengths.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/lengths.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.px = exports.emRounded = exports.em = exports.percent = exports.length2em = exports.MATHSPACE = exports.RELUNITS = exports.UNITS = exports.BIGDIMEN = void 0;
exports.BIGDIMEN = 1000000;
exports.UNITS = {
    px: 1,
    'in': 96,
    cm: 96 / 2.54,
    mm: 96 / 25.4
};
exports.RELUNITS = {
    em: 1,
    ex: .431,
    pt: 1 / 10,
    pc: 12 / 10,
    mu: 1 / 18
};
exports.MATHSPACE = {
    veryverythinmathspace: 1 / 18,
    verythinmathspace: 2 / 18,
    thinmathspace: 3 / 18,
    mediummathspace: 4 / 18,
    thickmathspace: 5 / 18,
    verythickmathspace: 6 / 18,
    veryverythickmathspace: 7 / 18,
    negativeveryverythinmathspace: -1 / 18,
    negativeverythinmathspace: -2 / 18,
    negativethinmathspace: -3 / 18,
    negativemediummathspace: -4 / 18,
    negativethickmathspace: -5 / 18,
    negativeverythickmathspace: -6 / 18,
    negativeveryverythickmathspace: -7 / 18,
    thin: .04,
    medium: .06,
    thick: .1,
    normal: 1,
    big: 2,
    small: 1 / Math.sqrt(2),
    infinity: exports.BIGDIMEN
};
function length2em(length, size, scale, em) {
    if (size === void 0) { size = 0; }
    if (scale === void 0) { scale = 1; }
    if (em === void 0) { em = 16; }
    if (typeof length !== 'string') {
        length = String(length);
    }
    if (length === '' || length == null) {
        return size;
    }
    if (exports.MATHSPACE[length]) {
        return exports.MATHSPACE[length];
    }
    var match = length.match(/^\s*([-+]?(?:\.\d+|\d+(?:\.\d*)?))?(pt|em|ex|mu|px|pc|in|mm|cm|%)?/);
    if (!match) {
        return size;
    }
    var m = parseFloat(match[1] || '1'), unit = match[2];
    if (exports.UNITS.hasOwnProperty(unit)) {
        return m * exports.UNITS[unit] / em / scale;
    }
    if (exports.RELUNITS.hasOwnProperty(unit)) {
        return m * exports.RELUNITS[unit];
    }
    if (unit === '%') {
        return m / 100 * size;
    }
    return m * size;
}
exports.length2em = length2em;
function percent(m) {
    return (100 * m).toFixed(1).replace(/\.?0+$/, '') + '%';
}
exports.percent = percent;
function em(m) {
    if (Math.abs(m) < .001)
        return '0';
    return (m.toFixed(3).replace(/\.?0+$/, '')) + 'em';
}
exports.em = em;
function emRounded(m, em) {
    if (em === void 0) { em = 16; }
    m = (Math.round(m * em) + .05) / em;
    if (Math.abs(m) < .001)
        return '0em';
    return m.toFixed(3).replace(/\.?0+$/, '') + 'em';
}
exports.emRounded = emRounded;
function px(m, M, em) {
    if (M === void 0) { M = -exports.BIGDIMEN; }
    if (em === void 0) { em = 16; }
    m *= em;
    if (M && m < M)
        m = M;
    if (Math.abs(m) < .1)
        return '0';
    return m.toFixed(1).replace(/\.0$/, '') + 'px';
}
exports.px = px;
//# sourceMappingURL=lengths.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX3VpX3NhZmVfU2FmZUhhbmRsZXJfanMuMzFlODBiZDAxMmYwY2UwYzI3YjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyw2QkFBNkI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3VpL3NhZmUvU2FmZUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91aS9zYWZlL1NhZmVNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdWkvc2FmZS9zYWZlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9PcHRpb25zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9sZW5ndGhzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNhZmVIYW5kbGVyID0gZXhwb3J0cy5TYWZlTWF0aERvY3VtZW50TWl4aW4gPSB2b2lkIDA7XG52YXIgc2FmZV9qc18xID0gcmVxdWlyZShcIi4vc2FmZS5qc1wiKTtcbmZ1bmN0aW9uIFNhZmVNYXRoRG9jdW1lbnRNaXhpbihCYXNlRG9jdW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9hID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIF90aGlzLnNhZmUgPSBuZXcgX3RoaXMub3B0aW9ucy5TYWZlQ2xhc3MoX3RoaXMsIF90aGlzLm9wdGlvbnMuc2FmZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBQcm9jZXNzQml0cyA9IF90aGlzLmNvbnN0cnVjdG9yLlByb2Nlc3NCaXRzO1xuICAgICAgICAgICAgICAgIGlmICghUHJvY2Vzc0JpdHMuaGFzKCdzYWZlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvY2Vzc0JpdHMuYWxsb2NhdGUoJ3NhZmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5pbnB1dEpheCksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqYXggPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqYXgubmFtZS5tYXRjaCgvTWF0aE1MLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYXgubWF0aG1sLmZpbHRlckF0dHJpYnV0ZSA9IF90aGlzLnNhZmUubW1sQXR0cmlidXRlLmJpbmQoX3RoaXMuc2FmZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgamF4Lm1hdGhtbC5maWx0ZXJDbGFzc0xpc3QgPSBfdGhpcy5zYWZlLm1tbENsYXNzTGlzdC5iaW5kKF90aGlzLnNhZmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoamF4Lm5hbWUubWF0Y2goL1RlWC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgamF4LnBvc3RGaWx0ZXJzLmFkZChfdGhpcy5zYW5pdGl6ZS5iaW5kKGpheCksIC01LjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5tYXRoLnJvb3QgPSB0aGlzLnBhcnNlT3B0aW9ucy5yb290O1xuICAgICAgICAgICAgICAgIGRhdGEuZG9jdW1lbnQuc2FmZS5zYW5pdGl6ZShkYXRhLm1hdGgsIGRhdGEuZG9jdW1lbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgICAgICB9KEJhc2VEb2N1bWVudCkpLFxuICAgICAgICBfYS5PUFRJT05TID0gX19hc3NpZ24oX19hc3NpZ24oe30sIEJhc2VEb2N1bWVudC5PUFRJT05TKSwgeyBzYWZlT3B0aW9uczogX19hc3NpZ24oe30sIHNhZmVfanNfMS5TYWZlLk9QVElPTlMpLCBTYWZlQ2xhc3M6IHNhZmVfanNfMS5TYWZlIH0pLFxuICAgICAgICBfYTtcbn1cbmV4cG9ydHMuU2FmZU1hdGhEb2N1bWVudE1peGluID0gU2FmZU1hdGhEb2N1bWVudE1peGluO1xuZnVuY3Rpb24gU2FmZUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGhhbmRsZXIuZG9jdW1lbnRDbGFzcyA9IFNhZmVNYXRoRG9jdW1lbnRNaXhpbihoYW5kbGVyLmRvY3VtZW50Q2xhc3MpO1xuICAgIHJldHVybiBoYW5kbGVyO1xufVxuZXhwb3J0cy5TYWZlSGFuZGxlciA9IFNhZmVIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2FmZUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNhZmVNZXRob2RzID0gdm9pZCAwO1xudmFyIGxlbmd0aHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xlbmd0aHMuanNcIik7XG5leHBvcnRzLlNhZmVNZXRob2RzID0ge1xuICAgIGZpbHRlclVSTDogZnVuY3Rpb24gKHNhZmUsIHVybCkge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSAodXJsLm1hdGNoKC9eXFxzKihbYS16XSspOi9pKSB8fCBbbnVsbCwgJyddKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgYWxsb3cgPSBzYWZlLmFsbG93LlVSTHM7XG4gICAgICAgIHJldHVybiAoYWxsb3cgPT09ICdhbGwnIHx8IChhbGxvdyA9PT0gJ3NhZmUnICYmXG4gICAgICAgICAgICAoc2FmZS5vcHRpb25zLnNhZmVQcm90b2NvbHNbcHJvdG9jb2xdIHx8ICFwcm90b2NvbCkpKSA/IHVybCA6IG51bGw7XG4gICAgfSxcbiAgICBmaWx0ZXJDbGFzc0xpc3Q6IGZ1bmN0aW9uIChzYWZlLCBsaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjbGFzc2VzID0gbGlzdC50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpLnNwbGl0KC8gLyk7XG4gICAgICAgIHJldHVybiBjbGFzc2VzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuZmlsdGVyQ2xhc3Moc2FmZSwgbmFtZSkgfHwgJyc7IH0pLmpvaW4oJyAnKS50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnJyk7XG4gICAgfSxcbiAgICBmaWx0ZXJDbGFzczogZnVuY3Rpb24gKHNhZmUsIENMQVNTKSB7XG4gICAgICAgIHZhciBhbGxvdyA9IHNhZmUuYWxsb3cuY2xhc3NlcztcbiAgICAgICAgcmV0dXJuIChhbGxvdyA9PT0gJ2FsbCcgfHwgKGFsbG93ID09PSAnc2FmZScgJiYgQ0xBU1MubWF0Y2goc2FmZS5vcHRpb25zLmNsYXNzUGF0dGVybikpKSA/IENMQVNTIDogbnVsbDtcbiAgICB9LFxuICAgIGZpbHRlcklEOiBmdW5jdGlvbiAoc2FmZSwgaWQpIHtcbiAgICAgICAgdmFyIGFsbG93ID0gc2FmZS5hbGxvdy5jc3NJRHM7XG4gICAgICAgIHJldHVybiAoYWxsb3cgPT09ICdhbGwnIHx8IChhbGxvdyA9PT0gJ3NhZmUnICYmIGlkLm1hdGNoKHNhZmUub3B0aW9ucy5pZFBhdHRlcm4pKSkgPyBpZCA6IG51bGw7XG4gICAgfSxcbiAgICBmaWx0ZXJTdHlsZXM6IGZ1bmN0aW9uIChzYWZlLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIGlmIChzYWZlLmFsbG93LnN0eWxlcyA9PT0gJ2FsbCcpXG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICBpZiAoc2FmZS5hbGxvdy5zdHlsZXMgIT09ICdzYWZlJylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgYWRhcHRvciA9IHNhZmUuYWRhcHRvcjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBzYWZlLm9wdGlvbnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGl2MSA9IGFkYXB0b3Iubm9kZSgnZGl2JywgeyBzdHlsZTogc3R5bGVzIH0pO1xuICAgICAgICAgICAgdmFyIGRpdjIgPSBhZGFwdG9yLm5vZGUoJ2RpdicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKG9wdGlvbnMuc2FmZVN0eWxlcykpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHlsZVBhcnRzW3N0eWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzIgPSB2b2lkIDAsIF9fdmFsdWVzKFsnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdMZWZ0J10pKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VmaXggPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHN0eWxlICsgc3VmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZmlsdGVyU3R5bGUoc2FmZSwgbmFtZV8xLCBkaXYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKGRpdjIsIG5hbWVfMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5maWx0ZXJTdHlsZShzYWZlLCBzdHlsZSwgZGl2MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKGRpdjIsIHN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXMgPSBhZGFwdG9yLmFsbFN0eWxlcyhkaXYyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdHlsZXMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG4gICAgZmlsdGVyU3R5bGU6IGZ1bmN0aW9uIChzYWZlLCBzdHlsZSwgZGl2KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNhZmUuYWRhcHRvci5nZXRTdHlsZShkaXYsIHN0eWxlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUgPT09ICcnIHx8IHZhbHVlLm1hdGNoKC9eXFxzKmNhbGMvKSB8fFxuICAgICAgICAgICAgKHZhbHVlLm1hdGNoKC9qYXZhc2NyaXB0Oi8pICYmICFzYWZlLm9wdGlvbnMuc2FmZVByb3RvY29scy5qYXZhc2NyaXB0KSB8fFxuICAgICAgICAgICAgKHZhbHVlLm1hdGNoKC9kYXRhOi8pICYmICFzYWZlLm9wdGlvbnMuc2FmZVByb3RvY29scy5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBzdHlsZS5yZXBsYWNlKC9Ub3B8UmlnaHR8TGVmdHxCb3R0b20vLCAnJyk7XG4gICAgICAgIGlmICghc2FmZS5vcHRpb25zLnNhZmVTdHlsZXNbc3R5bGVdICYmICFzYWZlLm9wdGlvbnMuc2FmZVN0eWxlc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU3R5bGVWYWx1ZShzYWZlLCBzdHlsZSwgdmFsdWUsIGRpdik7XG4gICAgfSxcbiAgICBmaWx0ZXJTdHlsZVZhbHVlOiBmdW5jdGlvbiAoc2FmZSwgc3R5bGUsIHZhbHVlLCBkaXYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzYWZlLm9wdGlvbnMuc3R5bGVMZW5ndGhzW3N0eWxlXTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU3R5bGVMZW5ndGgoc2FmZSwgc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5maWx0ZXJTdHlsZUxlbmd0aChzYWZlLCBuYW1lLCBzYWZlLmFkYXB0b3IuZ2V0U3R5bGUoZGl2LCBuYW1lKSk7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzYWZlLmFkYXB0b3Iuc2V0U3R5bGUoZGl2LCBuYW1lLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2FmZS5hZGFwdG9yLmdldFN0eWxlKGRpdiwgc3R5bGUpO1xuICAgIH0sXG4gICAgZmlsdGVyU3R5bGVMZW5ndGg6IGZ1bmN0aW9uIChzYWZlLCBzdHlsZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5tYXRjaCgvXiguKykoZW18ZXh8Y2h8cmVtfHB4fG1tfGNtfGlufHB0fHBjfCUpJC8pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBlbSA9ICgwLCBsZW5ndGhzX2pzXzEubGVuZ3RoMmVtKSh2YWx1ZSwgMSk7XG4gICAgICAgIHZhciBsZW5ndGhzID0gc2FmZS5vcHRpb25zLnN0eWxlTGVuZ3Roc1tzdHlsZV07XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCgoQXJyYXkuaXNBcnJheShsZW5ndGhzKSA/IGxlbmd0aHMgOiBbLXNhZmUub3B0aW9ucy5sZW5ndGhNYXgsIHNhZmUub3B0aW9ucy5sZW5ndGhNYXhdKSwgMiksIG0gPSBfYVswXSwgTSA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gKG0gPD0gZW0gJiYgZW0gPD0gTSA/IHZhbHVlIDogKGVtIDwgbSA/IG0gOiBNKS50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgKyAnZW0nKTtcbiAgICB9LFxuICAgIGZpbHRlckZvbnRTaXplOiBmdW5jdGlvbiAoc2FmZSwgc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJTdHlsZUxlbmd0aChzYWZlLCAnZm9udFNpemUnLCBzaXplKTtcbiAgICB9LFxuICAgIGZpbHRlclNpemVNdWx0aXBsaWVyOiBmdW5jdGlvbiAoc2FmZSwgc2l6ZSkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoc2FmZS5vcHRpb25zLnNjcmlwdHNpemVtdWx0aXBsaWVyUmFuZ2UgfHwgWy1JbmZpbml0eSwgSW5maW5pdHldLCAyKSwgbSA9IF9hWzBdLCBNID0gX2FbMV07XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNLCBNYXRoLm1heChtLCBwYXJzZUZsb2F0KHNpemUpKSkudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGZpbHRlclNjcmlwdExldmVsOiBmdW5jdGlvbiAoc2FmZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHNhZmUub3B0aW9ucy5zY3JpcHRsZXZlbFJhbmdlIHx8IFstSW5maW5pdHksIEluZmluaXR5XSwgMiksIG0gPSBfYVswXSwgTSA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTSwgTWF0aC5tYXgobSwgcGFyc2VJbnQobGV2ZWwpKSkudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGZpbHRlckRhdGE6IGZ1bmN0aW9uIChzYWZlLCB2YWx1ZSwgaWQpIHtcbiAgICAgICAgcmV0dXJuIChpZC5tYXRjaChzYWZlLm9wdGlvbnMuZGF0YVBhdHRlcm4pID8gdmFsdWUgOiBudWxsKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2FmZU1ldGhvZHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZlID0gdm9pZCAwO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgU2FmZU1ldGhvZHNfanNfMSA9IHJlcXVpcmUoXCIuL1NhZmVNZXRob2RzLmpzXCIpO1xudmFyIFNhZmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhZmUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJBdHRyaWJ1dGVzID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbJ2hyZWYnLCAnZmlsdGVyVVJMJ10sXG4gICAgICAgICAgICBbJ3NyYycsICdmaWx0ZXJVUkwnXSxcbiAgICAgICAgICAgIFsnYWx0aW1nJywgJ2ZpbHRlclVSTCddLFxuICAgICAgICAgICAgWydjbGFzcycsICdmaWx0ZXJDbGFzc0xpc3QnXSxcbiAgICAgICAgICAgIFsnc3R5bGUnLCAnZmlsdGVyU3R5bGVzJ10sXG4gICAgICAgICAgICBbJ2lkJywgJ2ZpbHRlcklEJ10sXG4gICAgICAgICAgICBbJ2ZvbnRzaXplJywgJ2ZpbHRlckZvbnRTaXplJ10sXG4gICAgICAgICAgICBbJ21hdGhzaXplJywgJ2ZpbHRlckZvbnRTaXplJ10sXG4gICAgICAgICAgICBbJ3NjcmlwdG1pbnNpemUnLCAnZmlsdGVyRm9udFNpemUnXSxcbiAgICAgICAgICAgIFsnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnZmlsdGVyU2l6ZU11bHRpcGxpZXInXSxcbiAgICAgICAgICAgIFsnc2NyaXB0bGV2ZWwnLCAnZmlsdGVyU2NyaXB0TGV2ZWwnXSxcbiAgICAgICAgICAgIFsnZGF0YS0nLCAnZmlsdGVyRGF0YSddXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmZpbHRlck1ldGhvZHMgPSBfX2Fzc2lnbih7fSwgU2FmZU1ldGhvZHNfanNfMS5TYWZlTWV0aG9kcyk7XG4gICAgICAgIHRoaXMuYWRhcHRvciA9IGRvY3VtZW50LmFkYXB0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYWxsb3cgPSB0aGlzLm9wdGlvbnMuYWxsb3c7XG4gICAgfVxuICAgIFNhZmUucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKG1hdGgsIGRvY3VtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRoLnJvb3Qud2Fsa1RyZWUodGhpcy5zYW5pdGl6ZU5vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZG9jdW1lbnQub3B0aW9ucy5jb21waWxlRXJyb3IoZG9jdW1lbnQsIG1hdGgsIGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmUucHJvdG90eXBlLnNhbml0aXplTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRBbGxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLmZpbHRlckF0dHJpYnV0ZXMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZmlsdGVyTWV0aG9kc1ttZXRob2RdKHRoaXMsIGF0dHJpYnV0ZXNbaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChhdHRyaWJ1dGVzW2lkXSkgOiBhdHRyaWJ1dGVzW2lkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2lkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmUucHJvdG90eXBlLm1tbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlkID09PSAnY2xhc3MnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBtZXRob2QgPSB0aGlzLmZpbHRlckF0dHJpYnV0ZXMuZ2V0KGlkKTtcbiAgICAgICAgdmFyIGZpbHRlciA9IChtZXRob2QgfHwgKGlkLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGEtJyA/IHRoaXMuZmlsdGVyQXR0cmlidXRlcy5nZXQoJ2RhdGEtJykgOiBudWxsKSk7XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmlsdGVyTWV0aG9kc1tmaWx0ZXJdKHRoaXMsIHZhbHVlLCBpZCk7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nID8gU3RyaW5nKHJlc3VsdCkgOiByZXN1bHQpO1xuICAgIH07XG4gICAgU2FmZS5wcm90b3R5cGUubW1sQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpc3QubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5maWx0ZXJNZXRob2RzLmZpbHRlckNsYXNzKF90aGlzLCBuYW1lKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPT0gbnVsbDsgfSk7XG4gICAgfTtcbiAgICBTYWZlLk9QVElPTlMgPSB7XG4gICAgICAgIGFsbG93OiB7XG4gICAgICAgICAgICBVUkxzOiAnc2FmZScsXG4gICAgICAgICAgICBjbGFzc2VzOiAnc2FmZScsXG4gICAgICAgICAgICBjc3NJRHM6ICdzYWZlJyxcbiAgICAgICAgICAgIHN0eWxlczogJ3NhZmUnXG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aE1heDogMyxcbiAgICAgICAgc2NyaXB0c2l6ZW11bHRpcGxpZXJSYW5nZTogWy42LCAxXSxcbiAgICAgICAgc2NyaXB0bGV2ZWxSYW5nZTogWy0yLCAyXSxcbiAgICAgICAgY2xhc3NQYXR0ZXJuOiAvXm1qeC1bLWEtekEtWjAtOV8uXSskLyxcbiAgICAgICAgaWRQYXR0ZXJuOiAvXm1qeC1bLWEtekEtWjAtOV8uXSskLyxcbiAgICAgICAgZGF0YVBhdHRlcm46IC9eZGF0YS1tangtLyxcbiAgICAgICAgc2FmZVByb3RvY29sczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBodHRwOiB0cnVlLFxuICAgICAgICAgICAgaHR0cHM6IHRydWUsXG4gICAgICAgICAgICBmaWxlOiB0cnVlLFxuICAgICAgICAgICAgamF2YXNjcmlwdDogZmFsc2UsXG4gICAgICAgICAgICBkYXRhOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgc2FmZVN0eWxlczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvcmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpbjogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0ZXh0U2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdHJ1ZSxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0cnVlLFxuICAgICAgICAgICAgZm9udFN0eWxlOiB0cnVlLFxuICAgICAgICAgICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHlsZVBhcnRzOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHtcbiAgICAgICAgICAgIGJvcmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICBtYXJnaW46IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHlsZUxlbmd0aHM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoe1xuICAgICAgICAgICAgYm9yZGVyVG9wOiAnYm9yZGVyVG9wV2lkdGgnLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6ICdib3JkZXJSaWdodFdpZHRoJyxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJ2JvcmRlckJvdHRvbVdpZHRoJyxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6ICdib3JkZXJMZWZ0V2lkdGgnLFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHRydWUsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpblRvcDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luQm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIG91dGxpbmVUb3A6IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lQm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgb3V0bGluZUxlZnQ6IHRydWUsXG4gICAgICAgICAgICBmb250U2l6ZTogWy43MDcsIDEuNDRdXG4gICAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gU2FmZTtcbn0oKSk7XG5leHBvcnRzLlNhZmUgPSBTYWZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9va3VwID0gZXhwb3J0cy5zZXBhcmF0ZU9wdGlvbnMgPSBleHBvcnRzLnNlbGVjdE9wdGlvbnNGcm9tS2V5cyA9IGV4cG9ydHMuc2VsZWN0T3B0aW9ucyA9IGV4cG9ydHMudXNlck9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5pbnNlcnQgPSBleHBvcnRzLmNvcHkgPSBleHBvcnRzLmtleXMgPSBleHBvcnRzLm1ha2VBcnJheSA9IGV4cG9ydHMuZXhwYW5kYWJsZSA9IGV4cG9ydHMuRXhwYW5kYWJsZSA9IGV4cG9ydHMuT1BUSU9OUyA9IGV4cG9ydHMuUkVNT1ZFID0gZXhwb3J0cy5BUFBFTkQgPSBleHBvcnRzLmlzT2JqZWN0ID0gdm9pZCAwO1xudmFyIE9CSkVDVCA9IHt9LmNvbnN0cnVjdG9yO1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAob2JqLmNvbnN0cnVjdG9yID09PSBPQkpFQ1QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBFeHBhbmRhYmxlKTtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuQVBQRU5EID0gJ1srXSc7XG5leHBvcnRzLlJFTU9WRSA9ICdbLV0nO1xuZXhwb3J0cy5PUFRJT05TID0ge1xuICAgIGludmFsaWRPcHRpb246ICd3YXJuJyxcbiAgICBvcHRpb25FcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UsIF9rZXkpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuT1BUSU9OUy5pbnZhbGlkT3B0aW9uID09PSAnZmF0YWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdNYXRoSmF4OiAnICsgbWVzc2FnZSk7XG4gICAgfVxufTtcbnZhciBFeHBhbmRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHBhbmRhYmxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gRXhwYW5kYWJsZTtcbn0oKSk7XG5leHBvcnRzLkV4cGFuZGFibGUgPSBFeHBhbmRhYmxlO1xuZnVuY3Rpb24gZXhwYW5kYWJsZShkZWYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKEV4cGFuZGFibGUucHJvdG90eXBlKSwgZGVmKTtcbn1cbmV4cG9ydHMuZXhwYW5kYWJsZSA9IGV4cGFuZGFibGU7XG5mdW5jdGlvbiBtYWtlQXJyYXkoeCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XTtcbn1cbmV4cG9ydHMubWFrZUFycmF5ID0gbWFrZUFycmF5O1xuZnVuY3Rpb24ga2V5cyhkZWYpIHtcbiAgICBpZiAoIWRlZikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkZWYpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGRlZikpO1xufVxuZXhwb3J0cy5rZXlzID0ga2V5cztcbmZ1bmN0aW9uIGNvcHkoZGVmKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhrZXlzKGRlZikpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmLCBrZXkpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHByb3AudmFsdWUgPSBpbnNlcnQoW10sIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gY29weSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcC5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZWYuY29uc3RydWN0b3IgPT09IEV4cGFuZGFibGUgPyBleHBhbmRhYmxlKHt9KSA6IHt9LCBwcm9wcyk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZnVuY3Rpb24gaW5zZXJ0KGRzdCwgc3JjLCB3YXJuKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgaWYgKHdhcm4gPT09IHZvaWQgMCkgeyB3YXJuID0gdHJ1ZTsgfVxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAod2FybiAmJiBkc3Rba2V5XSA9PT0gdW5kZWZpbmVkICYmIGRzdC5jb25zdHJ1Y3RvciAhPT0gRXhwYW5kYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLk9QVElPTlMub3B0aW9uRXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIChubyBkZWZhdWx0IHZhbHVlKS5cIiksIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdmFsID0gc3JjW2tleV0sIGR2YWwgPSBkc3Rba2V5XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN2YWwpICYmIGR2YWwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICh0eXBlb2YgZHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGR2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB2YXIgaWRzID0ga2V5cyhzdmFsKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGR2YWwpICYmXG4gICAgICAgICAgICAgICAgKChpZHMubGVuZ3RoID09PSAxICYmIChpZHNbMF0gPT09IGV4cG9ydHMuQVBQRU5EIHx8IGlkc1swXSA9PT0gZXhwb3J0cy5SRU1PVkUpICYmIEFycmF5LmlzQXJyYXkoc3ZhbFtpZHNbMF1dKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlkcy5sZW5ndGggPT09IDIgJiYgaWRzLnNvcnQoKS5qb2luKCcsJykgPT09IGV4cG9ydHMuQVBQRU5EICsgJywnICsgZXhwb3J0cy5SRU1PVkUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc3ZhbFtleHBvcnRzLkFQUEVORF0pICYmIEFycmF5LmlzQXJyYXkoc3ZhbFtleHBvcnRzLlJFTU9WRV0pKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ZhbFtleHBvcnRzLlJFTU9WRV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZHZhbCA9IGRzdFtrZXldID0gZHZhbC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHN2YWxbZXhwb3J0cy5SRU1PVkVdLmluZGV4T2YoeCkgPCAwOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN2YWxbZXhwb3J0cy5BUFBFTkRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtrZXldID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZHZhbCksIGZhbHNlKSwgX19yZWFkKHN2YWxbZXhwb3J0cy5BUFBFTkRdKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydChkdmFsLCBzdmFsLCB3YXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN2YWwpKSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0KGRzdFtrZXldLCBzdmFsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gY29weShzdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gc3ZhbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhrZXlzKHNyYykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICBfbG9vcF8xKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59XG5leHBvcnRzLmluc2VydCA9IGluc2VydDtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGRlZnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGRlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBpbnNlcnQob3B0aW9ucywgZGVmLCBmYWxzZSk7IH0pO1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuZnVuY3Rpb24gdXNlck9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBkZWZzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZGVmc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIGluc2VydChvcHRpb25zLCBkZWYsIHRydWUpOyB9KTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMudXNlck9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbmZ1bmN0aW9uIHNlbGVjdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBlXzMsIF9hO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAga2V5c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHN1YnNldCA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGtleXNfMSA9IF9fdmFsdWVzKGtleXMpLCBrZXlzXzFfMSA9IGtleXNfMS5uZXh0KCk7ICFrZXlzXzFfMS5kb25lOyBrZXlzXzFfMSA9IGtleXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzdWJzZXRba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGtleXNfMV8xICYmICFrZXlzXzFfMS5kb25lICYmIChfYSA9IGtleXNfMS5yZXR1cm4pKSBfYS5jYWxsKGtleXNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic2V0O1xufVxuZXhwb3J0cy5zZWxlY3RPcHRpb25zID0gc2VsZWN0T3B0aW9ucztcbmZ1bmN0aW9uIHNlbGVjdE9wdGlvbnNGcm9tS2V5cyhvcHRpb25zLCBvYmplY3QpIHtcbiAgICByZXR1cm4gc2VsZWN0T3B0aW9ucy5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW29wdGlvbnNdLCBfX3JlYWQoT2JqZWN0LmtleXMob2JqZWN0KSksIGZhbHNlKSk7XG59XG5leHBvcnRzLnNlbGVjdE9wdGlvbnNGcm9tS2V5cyA9IHNlbGVjdE9wdGlvbnNGcm9tS2V5cztcbmZ1bmN0aW9uIHNlcGFyYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGVfNCwgX2EsIGVfNSwgX2I7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIG9iamVjdHNfMSA9IF9fdmFsdWVzKG9iamVjdHMpLCBvYmplY3RzXzFfMSA9IG9iamVjdHNfMS5uZXh0KCk7ICFvYmplY3RzXzFfMS5kb25lOyBvYmplY3RzXzFfMSA9IG9iamVjdHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBleGlzdHMgPSB7fSwgbWlzc2luZyA9IHt9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IChlXzUgPSB2b2lkIDAsIF9fdmFsdWVzKE9iamVjdC5rZXlzKG9wdGlvbnMgfHwge30pKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAob2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCA/IG1pc3NpbmcgOiBleGlzdHMpW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2IgPSBfYy5yZXR1cm4pKSBfYi5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGV4aXN0cyk7XG4gICAgICAgICAgICBvcHRpb25zID0gbWlzc2luZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG9iamVjdHNfMV8xICYmICFvYmplY3RzXzFfMS5kb25lICYmIChfYSA9IG9iamVjdHNfMS5yZXR1cm4pKSBfYS5jYWxsKG9iamVjdHNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgIH1cbiAgICByZXN1bHRzLnVuc2hpZnQob3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnRzLnNlcGFyYXRlT3B0aW9ucyA9IHNlcGFyYXRlT3B0aW9ucztcbmZ1bmN0aW9uIGxvb2t1cChuYW1lLCBsb29rdXAsIGRlZikge1xuICAgIGlmIChkZWYgPT09IHZvaWQgMCkgeyBkZWYgPSBudWxsOyB9XG4gICAgcmV0dXJuIChsb29rdXAuaGFzT3duUHJvcGVydHkobmFtZSkgPyBsb29rdXBbbmFtZV0gOiBkZWYpO1xufVxuZXhwb3J0cy5sb29rdXAgPSBsb29rdXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5weCA9IGV4cG9ydHMuZW1Sb3VuZGVkID0gZXhwb3J0cy5lbSA9IGV4cG9ydHMucGVyY2VudCA9IGV4cG9ydHMubGVuZ3RoMmVtID0gZXhwb3J0cy5NQVRIU1BBQ0UgPSBleHBvcnRzLlJFTFVOSVRTID0gZXhwb3J0cy5VTklUUyA9IGV4cG9ydHMuQklHRElNRU4gPSB2b2lkIDA7XG5leHBvcnRzLkJJR0RJTUVOID0gMTAwMDAwMDtcbmV4cG9ydHMuVU5JVFMgPSB7XG4gICAgcHg6IDEsXG4gICAgJ2luJzogOTYsXG4gICAgY206IDk2IC8gMi41NCxcbiAgICBtbTogOTYgLyAyNS40XG59O1xuZXhwb3J0cy5SRUxVTklUUyA9IHtcbiAgICBlbTogMSxcbiAgICBleDogLjQzMSxcbiAgICBwdDogMSAvIDEwLFxuICAgIHBjOiAxMiAvIDEwLFxuICAgIG11OiAxIC8gMThcbn07XG5leHBvcnRzLk1BVEhTUEFDRSA9IHtcbiAgICB2ZXJ5dmVyeXRoaW5tYXRoc3BhY2U6IDEgLyAxOCxcbiAgICB2ZXJ5dGhpbm1hdGhzcGFjZTogMiAvIDE4LFxuICAgIHRoaW5tYXRoc3BhY2U6IDMgLyAxOCxcbiAgICBtZWRpdW1tYXRoc3BhY2U6IDQgLyAxOCxcbiAgICB0aGlja21hdGhzcGFjZTogNSAvIDE4LFxuICAgIHZlcnl0aGlja21hdGhzcGFjZTogNiAvIDE4LFxuICAgIHZlcnl2ZXJ5dGhpY2ttYXRoc3BhY2U6IDcgLyAxOCxcbiAgICBuZWdhdGl2ZXZlcnl2ZXJ5dGhpbm1hdGhzcGFjZTogLTEgLyAxOCxcbiAgICBuZWdhdGl2ZXZlcnl0aGlubWF0aHNwYWNlOiAtMiAvIDE4LFxuICAgIG5lZ2F0aXZldGhpbm1hdGhzcGFjZTogLTMgLyAxOCxcbiAgICBuZWdhdGl2ZW1lZGl1bW1hdGhzcGFjZTogLTQgLyAxOCxcbiAgICBuZWdhdGl2ZXRoaWNrbWF0aHNwYWNlOiAtNSAvIDE4LFxuICAgIG5lZ2F0aXZldmVyeXRoaWNrbWF0aHNwYWNlOiAtNiAvIDE4LFxuICAgIG5lZ2F0aXZldmVyeXZlcnl0aGlja21hdGhzcGFjZTogLTcgLyAxOCxcbiAgICB0aGluOiAuMDQsXG4gICAgbWVkaXVtOiAuMDYsXG4gICAgdGhpY2s6IC4xLFxuICAgIG5vcm1hbDogMSxcbiAgICBiaWc6IDIsXG4gICAgc21hbGw6IDEgLyBNYXRoLnNxcnQoMiksXG4gICAgaW5maW5pdHk6IGV4cG9ydHMuQklHRElNRU5cbn07XG5mdW5jdGlvbiBsZW5ndGgyZW0obGVuZ3RoLCBzaXplLCBzY2FsZSwgZW0pIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7IHNpemUgPSAwOyB9XG4gICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxOyB9XG4gICAgaWYgKGVtID09PSB2b2lkIDApIHsgZW0gPSAxNjsgfVxuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnc3RyaW5nJykge1xuICAgICAgICBsZW5ndGggPSBTdHJpbmcobGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgbGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLk1BVEhTUEFDRVtsZW5ndGhdKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk1BVEhTUEFDRVtsZW5ndGhdO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBsZW5ndGgubWF0Y2goL15cXHMqKFstK10/KD86XFwuXFxkK3xcXGQrKD86XFwuXFxkKik/KSk/KHB0fGVtfGV4fG11fHB4fHBjfGlufG1tfGNtfCUpPy8pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHZhciBtID0gcGFyc2VGbG9hdChtYXRjaFsxXSB8fCAnMScpLCB1bml0ID0gbWF0Y2hbMl07XG4gICAgaWYgKGV4cG9ydHMuVU5JVFMuaGFzT3duUHJvcGVydHkodW5pdCkpIHtcbiAgICAgICAgcmV0dXJuIG0gKiBleHBvcnRzLlVOSVRTW3VuaXRdIC8gZW0gLyBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuUkVMVU5JVFMuaGFzT3duUHJvcGVydHkodW5pdCkpIHtcbiAgICAgICAgcmV0dXJuIG0gKiBleHBvcnRzLlJFTFVOSVRTW3VuaXRdO1xuICAgIH1cbiAgICBpZiAodW5pdCA9PT0gJyUnKSB7XG4gICAgICAgIHJldHVybiBtIC8gMTAwICogc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiBzaXplO1xufVxuZXhwb3J0cy5sZW5ndGgyZW0gPSBsZW5ndGgyZW07XG5mdW5jdGlvbiBwZXJjZW50KG0pIHtcbiAgICByZXR1cm4gKDEwMCAqIG0pLnRvRml4ZWQoMSkucmVwbGFjZSgvXFwuPzArJC8sICcnKSArICclJztcbn1cbmV4cG9ydHMucGVyY2VudCA9IHBlcmNlbnQ7XG5mdW5jdGlvbiBlbShtKSB7XG4gICAgaWYgKE1hdGguYWJzKG0pIDwgLjAwMSlcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICByZXR1cm4gKG0udG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpKSArICdlbSc7XG59XG5leHBvcnRzLmVtID0gZW07XG5mdW5jdGlvbiBlbVJvdW5kZWQobSwgZW0pIHtcbiAgICBpZiAoZW0gPT09IHZvaWQgMCkgeyBlbSA9IDE2OyB9XG4gICAgbSA9IChNYXRoLnJvdW5kKG0gKiBlbSkgKyAuMDUpIC8gZW07XG4gICAgaWYgKE1hdGguYWJzKG0pIDwgLjAwMSlcbiAgICAgICAgcmV0dXJuICcwZW0nO1xuICAgIHJldHVybiBtLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSArICdlbSc7XG59XG5leHBvcnRzLmVtUm91bmRlZCA9IGVtUm91bmRlZDtcbmZ1bmN0aW9uIHB4KG0sIE0sIGVtKSB7XG4gICAgaWYgKE0gPT09IHZvaWQgMCkgeyBNID0gLWV4cG9ydHMuQklHRElNRU47IH1cbiAgICBpZiAoZW0gPT09IHZvaWQgMCkgeyBlbSA9IDE2OyB9XG4gICAgbSAqPSBlbTtcbiAgICBpZiAoTSAmJiBtIDwgTSlcbiAgICAgICAgbSA9IE07XG4gICAgaWYgKE1hdGguYWJzKG0pIDwgLjEpXG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgcmV0dXJuIG0udG9GaXhlZCgxKS5yZXBsYWNlKC9cXC4wJC8sICcnKSArICdweCc7XG59XG5leHBvcnRzLnB4ID0gcHg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5ndGhzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==