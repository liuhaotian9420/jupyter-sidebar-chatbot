"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_lezer_generator_dist_index_js"],{

/***/ "./node_modules/@lezer/generator/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/generator/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenError: () => (/* binding */ GenError),
/* harmony export */   buildParser: () => (/* binding */ buildParser),
/* harmony export */   buildParserFile: () => (/* binding */ buildParserFile)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ "webpack/sharing/consume/default/@lezer/common/@lezer/common");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lezer_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/lr */ "./node_modules/@lezer/lr/dist/index.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");



class Node {
    constructor(start) {
        this.start = start;
    }
}
class GrammarDeclaration extends Node {
    constructor(start, rules, topRules, tokens, localTokens, context, externalTokens, externalSpecializers, externalPropSources, precedences, mainSkip, scopedSkip, dialects, externalProps, autoDelim) {
        super(start);
        this.rules = rules;
        this.topRules = topRules;
        this.tokens = tokens;
        this.localTokens = localTokens;
        this.context = context;
        this.externalTokens = externalTokens;
        this.externalSpecializers = externalSpecializers;
        this.externalPropSources = externalPropSources;
        this.precedences = precedences;
        this.mainSkip = mainSkip;
        this.scopedSkip = scopedSkip;
        this.dialects = dialects;
        this.externalProps = externalProps;
        this.autoDelim = autoDelim;
    }
    toString() { return Object.values(this.rules).join("\n"); }
}
class RuleDeclaration extends Node {
    constructor(start, id, props, params, expr) {
        super(start);
        this.id = id;
        this.props = props;
        this.params = params;
        this.expr = expr;
    }
    toString() {
        return this.id.name + (this.params.length ? `<${this.params.join()}>` : "") + " -> " + this.expr;
    }
}
class PrecDeclaration extends Node {
    constructor(start, items) {
        super(start);
        this.items = items;
    }
}
class TokenPrecDeclaration extends Node {
    constructor(start, items) {
        super(start);
        this.items = items;
    }
}
class TokenConflictDeclaration extends Node {
    constructor(start, a, b) {
        super(start);
        this.a = a;
        this.b = b;
    }
}
class TokenDeclaration extends Node {
    constructor(start, precedences, conflicts, rules, literals) {
        super(start);
        this.precedences = precedences;
        this.conflicts = conflicts;
        this.rules = rules;
        this.literals = literals;
    }
}
class LocalTokenDeclaration extends Node {
    constructor(start, precedences, rules, fallback) {
        super(start);
        this.precedences = precedences;
        this.rules = rules;
        this.fallback = fallback;
    }
}
class LiteralDeclaration extends Node {
    constructor(start, literal, props) {
        super(start);
        this.literal = literal;
        this.props = props;
    }
}
class ContextDeclaration extends Node {
    constructor(start, id, source) {
        super(start);
        this.id = id;
        this.source = source;
    }
}
class ExternalTokenDeclaration extends Node {
    constructor(start, id, source, tokens) {
        super(start);
        this.id = id;
        this.source = source;
        this.tokens = tokens;
    }
}
class ExternalSpecializeDeclaration extends Node {
    constructor(start, type, token, id, source, tokens) {
        super(start);
        this.type = type;
        this.token = token;
        this.id = id;
        this.source = source;
        this.tokens = tokens;
    }
}
class ExternalPropSourceDeclaration extends Node {
    constructor(start, id, source) {
        super(start);
        this.id = id;
        this.source = source;
    }
}
class ExternalPropDeclaration extends Node {
    constructor(start, id, externalID, source) {
        super(start);
        this.id = id;
        this.externalID = externalID;
        this.source = source;
    }
}
class Identifier extends Node {
    constructor(start, name) {
        super(start);
        this.name = name;
    }
    toString() { return this.name; }
}
class Expression extends Node {
    walk(f) { return f(this); }
    eq(_other) { return false; }
}
Expression.prototype.prec = 10;
class NameExpression extends Expression {
    constructor(start, id, args) {
        super(start);
        this.id = id;
        this.args = args;
    }
    toString() { return this.id.name + (this.args.length ? `<${this.args.join()}>` : ""); }
    eq(other) {
        return this.id.name == other.id.name && exprsEq(this.args, other.args);
    }
    walk(f) {
        let args = walkExprs(this.args, f);
        return f(args == this.args ? this : new NameExpression(this.start, this.id, args));
    }
}
class SpecializeExpression extends Expression {
    constructor(start, type, props, token, content) {
        super(start);
        this.type = type;
        this.props = props;
        this.token = token;
        this.content = content;
    }
    toString() { return `@${this.type}[${this.props.join(",")}]<${this.token}, ${this.content}>`; }
    eq(other) {
        return this.type == other.type && Prop.eqProps(this.props, other.props) && exprEq(this.token, other.token) &&
            exprEq(this.content, other.content);
    }
    walk(f) {
        let token = this.token.walk(f), content = this.content.walk(f);
        return f(token == this.token && content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content));
    }
}
class InlineRuleExpression extends Expression {
    constructor(start, rule) {
        super(start);
        this.rule = rule;
    }
    toString() {
        let rule = this.rule;
        return `${rule.id}${rule.props.length ? `[${rule.props.join(",")}]` : ""} { ${rule.expr} }`;
    }
    eq(other) {
        let rule = this.rule, oRule = other.rule;
        return exprEq(rule.expr, oRule.expr) && rule.id.name == oRule.id.name && Prop.eqProps(rule.props, oRule.props);
    }
    walk(f) {
        let rule = this.rule, expr = rule.expr.walk(f);
        return f(expr == rule.expr ? this :
            new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)));
    }
}
class ChoiceExpression extends Expression {
    constructor(start, exprs) {
        super(start);
        this.exprs = exprs;
    }
    toString() { return this.exprs.map(e => maybeParens(e, this)).join(" | "); }
    eq(other) {
        return exprsEq(this.exprs, other.exprs);
    }
    walk(f) {
        let exprs = walkExprs(this.exprs, f);
        return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs));
    }
}
ChoiceExpression.prototype.prec = 1;
class SequenceExpression extends Expression {
    constructor(start, exprs, markers, empty = false) {
        super(start);
        this.exprs = exprs;
        this.markers = markers;
        this.empty = empty;
    }
    toString() { return this.empty ? "()" : this.exprs.map(e => maybeParens(e, this)).join(" "); }
    eq(other) {
        return exprsEq(this.exprs, other.exprs) && this.markers.every((m, i) => {
            let om = other.markers[i];
            return m.length == om.length && m.every((x, i) => x.eq(om[i]));
        });
    }
    walk(f) {
        let exprs = walkExprs(this.exprs, f);
        return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers, this.empty && !exprs.length));
    }
}
SequenceExpression.prototype.prec = 2;
class ConflictMarker extends Node {
    constructor(start, id, type) {
        super(start);
        this.id = id;
        this.type = type;
    }
    toString() { return (this.type == "ambig" ? "~" : "!") + this.id.name; }
    eq(other) { return this.id.name == other.id.name && this.type == other.type; }
}
class RepeatExpression extends Expression {
    constructor(start, expr, kind) {
        super(start);
        this.expr = expr;
        this.kind = kind;
    }
    toString() { return maybeParens(this.expr, this) + this.kind; }
    eq(other) {
        return exprEq(this.expr, other.expr) && this.kind == other.kind;
    }
    walk(f) {
        let expr = this.expr.walk(f);
        return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind));
    }
}
RepeatExpression.prototype.prec = 3;
class LiteralExpression extends Expression {
    // value.length is always > 0
    constructor(start, value) {
        super(start);
        this.value = value;
    }
    toString() { return JSON.stringify(this.value); }
    eq(other) { return this.value == other.value; }
}
class SetExpression extends Expression {
    constructor(start, ranges, inverted) {
        super(start);
        this.ranges = ranges;
        this.inverted = inverted;
    }
    toString() {
        return `[${this.inverted ? "^" : ""}${this.ranges.map(([a, b]) => {
            return String.fromCodePoint(a) + (b == a + 1 ? "" : "-" + String.fromCodePoint(b));
        })}]`;
    }
    eq(other) {
        return this.inverted == other.inverted && this.ranges.length == other.ranges.length &&
            this.ranges.every(([a, b], i) => { let [x, y] = other.ranges[i]; return a == x && b == y; });
    }
}
class AnyExpression extends Expression {
    constructor(start) {
        super(start);
    }
    toString() { return "_"; }
    eq() { return true; }
}
function walkExprs(exprs, f) {
    let result = null;
    for (let i = 0; i < exprs.length; i++) {
        let expr = exprs[i].walk(f);
        if (expr != exprs[i] && !result)
            result = exprs.slice(0, i);
        if (result)
            result.push(expr);
    }
    return result || exprs;
}
const CharClasses = {
    asciiLetter: [[65, 91], [97, 123]],
    asciiLowercase: [[97, 123]],
    asciiUppercase: [[65, 91]],
    digit: [[48, 58]],
    whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],
        [8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]],
    eof: [[0xffff, 0xffff]]
};
class CharClass extends Expression {
    constructor(start, type) {
        super(start);
        this.type = type;
    }
    toString() { return "@" + this.type; }
    eq(expr) { return this.type == expr.type; }
}
function exprEq(a, b) {
    return a.constructor == b.constructor && a.eq(b);
}
function exprsEq(a, b) {
    return a.length == b.length && a.every((e, i) => exprEq(e, b[i]));
}
class Prop extends Node {
    constructor(start, at, name, value) {
        super(start);
        this.at = at;
        this.name = name;
        this.value = value;
    }
    eq(other) {
        return this.name == other.name && this.value.length == other.value.length &&
            this.value.every((v, i) => v.value == other.value[i].value && v.name == other.value[i].name);
    }
    toString() {
        let result = (this.at ? "@" : "") + this.name;
        if (this.value.length) {
            result += "=";
            for (let { name, value } of this.value)
                result += name ? `{${name}}` : /[^\w-]/.test(value) ? JSON.stringify(value) : value;
        }
        return result;
    }
    static eqProps(a, b) {
        return a.length == b.length && a.every((p, i) => p.eq(b[i]));
    }
}
class PropPart extends Node {
    constructor(start, value, name) {
        super(start);
        this.value = value;
        this.name = name;
    }
}
function maybeParens(node, parent) {
    return node.prec < parent.prec ? "(" + node.toString() + ")" : node.toString();
}

/**
The type of error raised when the parser generator finds an issue.
*/
class GenError extends Error {
}

function hasProps(props) {
    for (let _p in props)
        return true;
    return false;
}
let termHash = 0;
class Term {
    constructor(name, flags, nodeName, props = {}) {
        this.name = name;
        this.flags = flags;
        this.nodeName = nodeName;
        this.props = props;
        this.hash = ++termHash; // Used for sorting and hashing during parser generation
        this.id = -1; // Assigned in a later stage, used in actual output
        // Filled in only after the rules are simplified, used in automaton.ts
        this.rules = [];
    }
    toString() { return this.name; }
    get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated; }
    get terminal() { return (this.flags & 1 /* TermFlag.Terminal */) > 0; }
    get eof() { return (this.flags & 4 /* TermFlag.Eof */) > 0; }
    get error() { return "error" in this.props; }
    get top() { return (this.flags & 2 /* TermFlag.Top */) > 0; }
    get interesting() { return this.flags > 0 || this.nodeName != null; }
    get repeated() { return (this.flags & 16 /* TermFlag.Repeated */) > 0; }
    set preserve(value) { this.flags = value ? this.flags | 8 /* TermFlag.Preserve */ : this.flags & ~8 /* TermFlag.Preserve */; }
    get preserve() { return (this.flags & 8 /* TermFlag.Preserve */) > 0; }
    set inline(value) { this.flags = value ? this.flags | 32 /* TermFlag.Inline */ : this.flags & ~32 /* TermFlag.Inline */; }
    get inline() { return (this.flags & 32 /* TermFlag.Inline */) > 0; }
    cmp(other) { return this.hash - other.hash; }
}
class TermSet {
    constructor() {
        this.terms = [];
        // Map from term names to Term instances
        this.names = Object.create(null);
        this.tops = [];
        this.eof = this.term("␄", null, 1 /* TermFlag.Terminal */ | 4 /* TermFlag.Eof */);
        this.error = this.term("⚠", "⚠", 8 /* TermFlag.Preserve */);
    }
    term(name, nodeName, flags = 0, props = {}) {
        let term = new Term(name, flags, nodeName, props);
        this.terms.push(term);
        this.names[name] = term;
        return term;
    }
    makeTop(nodeName, props) {
        const term = this.term("@top", nodeName, 2 /* TermFlag.Top */, props);
        this.tops.push(term);
        return term;
    }
    makeTerminal(name, nodeName, props = {}) {
        return this.term(name, nodeName, 1 /* TermFlag.Terminal */, props);
    }
    makeNonTerminal(name, nodeName, props = {}) {
        return this.term(name, nodeName, 0, props);
    }
    makeRepeat(name) {
        return this.term(name, null, 16 /* TermFlag.Repeated */);
    }
    uniqueName(name) {
        for (let i = 0;; i++) {
            let cur = i ? `${name}-${i}` : name;
            if (!this.names[cur])
                return cur;
        }
    }
    finish(rules) {
        for (let rule of rules)
            rule.name.rules.push(rule);
        this.terms = this.terms.filter(t => t.terminal || t.preserve || rules.some(r => r.name == t || r.parts.includes(t)));
        let names = {};
        let nodeTypes = [this.error];
        this.error.id = 0 /* T.Err */;
        let nextID = 0 /* T.Err */ + 1;
        // Assign ids to terms that represent node types
        for (let term of this.terms)
            if (term.id < 0 && term.nodeType && !term.repeated) {
                term.id = nextID++;
                nodeTypes.push(term);
            }
        // Put all repeated terms after the regular node types
        let minRepeatTerm = nextID;
        for (let term of this.terms)
            if (term.repeated) {
                term.id = nextID++;
                nodeTypes.push(term);
            }
        // Then comes the EOF term
        this.eof.id = nextID++;
        // And then the remaining (non-node, non-repeat) terms.
        for (let term of this.terms) {
            if (term.id < 0)
                term.id = nextID++;
            if (term.name)
                names[term.id] = term.name;
        }
        if (nextID >= 0xfffe)
            throw new GenError("Too many terms");
        return { nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1 };
    }
}
function cmpSet(a, b, cmp) {
    if (a.length != b.length)
        return a.length - b.length;
    for (let i = 0; i < a.length; i++) {
        let diff = cmp(a[i], b[i]);
        if (diff)
            return diff;
    }
    return 0;
}
const none$3 = [];
class Conflicts {
    constructor(precedence, ambigGroups = none$3, cut = 0) {
        this.precedence = precedence;
        this.ambigGroups = ambigGroups;
        this.cut = cut;
    }
    join(other) {
        if (this == Conflicts.none || this == other)
            return other;
        if (other == Conflicts.none)
            return this;
        return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups), Math.max(this.cut, other.cut));
    }
    cmp(other) {
        return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) => a < b ? -1 : a > b ? 1 : 0) ||
            this.cut - other.cut;
    }
}
Conflicts.none = new Conflicts(0);
function union(a, b) {
    if (a.length == 0 || a == b)
        return b;
    if (b.length == 0)
        return a;
    let result = a.slice();
    for (let value of b)
        if (!a.includes(value))
            result.push(value);
    return result.sort();
}
let ruleID = 0;
class Rule {
    constructor(name, parts, conflicts, skip) {
        this.name = name;
        this.parts = parts;
        this.conflicts = conflicts;
        this.skip = skip;
        this.id = ruleID++;
    }
    cmp(rule) {
        return this.id - rule.id;
    }
    cmpNoName(rule) {
        return this.parts.length - rule.parts.length ||
            this.skip.hash - rule.skip.hash ||
            this.parts.reduce((r, s, i) => r || s.cmp(rule.parts[i]), 0) ||
            cmpSet(this.conflicts, rule.conflicts, (a, b) => a.cmp(b));
    }
    toString() {
        return this.name + " -> " + this.parts.join(" ");
    }
    get isRepeatWrap() {
        return this.name.repeated && this.parts.length == 2 && this.parts[0] == this.name;
    }
    sameReduce(other) {
        return this.name == other.name && this.parts.length == other.parts.length && this.isRepeatWrap == other.isRepeatWrap;
    }
}

const MAX_CHAR = 0xffff;
class Edge {
    constructor(from, to, target) {
        this.from = from;
        this.to = to;
        this.target = target;
    }
    toString() {
        return `-> ${this.target.id}[label=${JSON.stringify(this.from < 0 ? "ε" : charFor(this.from) +
            (this.to > this.from + 1 ? "-" + charFor(this.to - 1) : ""))}]`;
    }
}
function charFor(n) {
    return n > MAX_CHAR ? "∞"
        : n == 10 ? "\\n"
            : n == 13 ? "\\r"
                : n < 32 || n >= 0xd800 && n < 0xdfff ? "\\u{" + n.toString(16) + "}"
                    : String.fromCharCode(n);
}
function minimize(states, start) {
    let partition = Object.create(null);
    let byAccepting = Object.create(null);
    for (let state of states) {
        let id = ids(state.accepting);
        let group = byAccepting[id] || (byAccepting[id] = []);
        group.push(state);
        partition[state.id] = group;
    }
    for (;;) {
        let split = false, newPartition = Object.create(null);
        for (let state of states) {
            if (newPartition[state.id])
                continue;
            let group = partition[state.id];
            if (group.length == 1) {
                newPartition[group[0].id] = group;
                continue;
            }
            let parts = [];
            groups: for (let state of group) {
                for (let p of parts) {
                    if (isEquivalent(state, p[0], partition)) {
                        p.push(state);
                        continue groups;
                    }
                }
                parts.push([state]);
            }
            if (parts.length > 1)
                split = true;
            for (let p of parts)
                for (let s of p)
                    newPartition[s.id] = p;
        }
        if (!split)
            return applyMinimization(states, start, partition);
        partition = newPartition;
    }
}
function isEquivalent(a, b, partition) {
    if (a.edges.length != b.edges.length)
        return false;
    for (let i = 0; i < a.edges.length; i++) {
        let eA = a.edges[i], eB = b.edges[i];
        if (eA.from != eB.from || eA.to != eB.to || partition[eA.target.id] != partition[eB.target.id])
            return false;
    }
    return true;
}
function applyMinimization(states, start, partition) {
    for (let state of states) {
        for (let i = 0; i < state.edges.length; i++) {
            let edge = state.edges[i], target = partition[edge.target.id][0];
            if (target != edge.target)
                state.edges[i] = new Edge(edge.from, edge.to, target);
        }
    }
    return partition[start.id][0];
}
let stateID = 1;
let State$1 = class State {
    constructor(accepting = [], id = stateID++) {
        this.accepting = accepting;
        this.id = id;
        this.edges = [];
    }
    edge(from, to, target) {
        this.edges.push(new Edge(from, to, target));
    }
    nullEdge(target) { this.edge(-1, -1, target); }
    compile() {
        let labeled = Object.create(null), localID = 0;
        let startState = explore(this.closure().sort((a, b) => a.id - b.id));
        return minimize(Object.values(labeled), startState);
        function explore(states) {
            let newState = labeled[ids(states)] =
                new State(states.reduce((a, s) => union(a, s.accepting), []), localID++);
            let out = [];
            for (let state of states)
                for (let edge of state.edges) {
                    if (edge.from >= 0)
                        out.push(edge);
                }
            let transitions = mergeEdges(out);
            for (let merged of transitions) {
                let targets = merged.targets.sort((a, b) => a.id - b.id);
                newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets));
            }
            return newState;
        }
    }
    closure() {
        let result = [], seen = Object.create(null);
        function explore(state) {
            if (seen[state.id])
                return;
            seen[state.id] = true;
            // States with only epsilon edges and no accepting term that
            // isn't also in the next states are left out to help reduce the
            // number of unique state combinations
            if (state.edges.some(e => e.from >= 0) ||
                (state.accepting.length > 0 && !state.edges.some(e => sameSet$1(state.accepting, e.target.accepting))))
                result.push(state);
            for (let edge of state.edges)
                if (edge.from < 0)
                    explore(edge.target);
        }
        explore(this);
        return result;
    }
    findConflicts(occurTogether) {
        let conflicts = [], cycleTerms = this.cycleTerms();
        function add(a, b, soft, aEdges, bEdges) {
            if (a.id < b.id) {
                [a, b] = [b, a];
                soft = -soft;
            }
            let found = conflicts.find(c => c.a == a && c.b == b);
            if (!found)
                conflicts.push(new Conflict$1(a, b, soft, exampleFromEdges(aEdges), bEdges && exampleFromEdges(bEdges)));
            else if (found.soft != soft)
                found.soft = 0;
        }
        this.reachable((state, edges) => {
            if (state.accepting.length == 0)
                return;
            for (let i = 0; i < state.accepting.length; i++)
                for (let j = i + 1; j < state.accepting.length; j++)
                    add(state.accepting[i], state.accepting[j], 0, edges);
            state.reachable((s, es) => {
                if (s != state)
                    for (let term of s.accepting) {
                        let hasCycle = cycleTerms.includes(term);
                        for (let orig of state.accepting)
                            if (term != orig)
                                add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ? 0 : 1, edges, edges.concat(es));
                    }
            });
        });
        return conflicts;
    }
    cycleTerms() {
        let work = [];
        this.reachable(state => {
            for (let { target } of state.edges)
                work.push(state, target);
        });
        let table = new Map;
        let haveCycle = [];
        for (let i = 0; i < work.length;) {
            let from = work[i++], to = work[i++];
            let entry = table.get(from);
            if (!entry)
                table.set(from, entry = []);
            if (entry.includes(to))
                continue;
            if (from == to) {
                if (!haveCycle.includes(from))
                    haveCycle.push(from);
            }
            else {
                for (let next of entry)
                    work.push(from, next);
                entry.push(to);
            }
        }
        let result = [];
        for (let state of haveCycle) {
            for (let term of state.accepting) {
                if (!result.includes(term))
                    result.push(term);
            }
        }
        return result;
    }
    reachable(f) {
        let seen = [], edges = [];
        (function explore(s) {
            f(s, edges);
            seen.push(s);
            for (let edge of s.edges)
                if (!seen.includes(edge.target)) {
                    edges.push(edge);
                    explore(edge.target);
                    edges.pop();
                }
        })(this);
    }
    toString() {
        let out = "digraph {\n";
        this.reachable(state => {
            if (state.accepting.length)
                out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\n`;
            for (let edge of state.edges)
                out += `  ${state.id} ${edge};\n`;
        });
        return out + "}";
    }
    // Tokenizer data is represented as a single flat array. This
    // contains regions for each tokenizer state. Region offsets are
    // used to identify states.
    //
    // Each state is laid out as:
    //  - Token group mask
    //  - Offset of the end of the accepting data
    //  - Number of outgoing edges in the state
    //  - Pairs of token masks and term ids that indicate the accepting
    //    states, sorted by precedence
    //  - Triples for the edges: each with a low and high bound and the
    //    offset of the next state.
    toArray(groupMasks, precedence) {
        let offsets = []; // Used to 'link' the states after building the arrays
        let data = [];
        this.reachable(state => {
            let start = data.length;
            let acceptEnd = start + 3 + state.accepting.length * 2;
            offsets[state.id] = start;
            data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length);
            state.accepting.sort((a, b) => precedence.indexOf(a.id) - precedence.indexOf(b.id));
            for (let term of state.accepting)
                data.push(term.id, groupMasks[term.id] || 0xffff);
            for (let edge of state.edges)
                data.push(edge.from, edge.to, -edge.target.id - 1);
        });
        // Replace negative numbers with resolved state offsets
        for (let i = 0; i < data.length; i++)
            if (data[i] < 0)
                data[i] = offsets[-data[i] - 1];
        if (data.length > Math.pow(2, 16))
            throw new GenError("Tokenizer tables too big to represent with 16-bit offsets.");
        return Uint16Array.from(data);
    }
    stateMask(groupMasks) {
        let mask = 0;
        this.reachable(state => {
            for (let term of state.accepting)
                mask |= (groupMasks[term.id] || 0xffff);
        });
        return mask;
    }
};
let Conflict$1 = class Conflict {
    constructor(a, b, 
    // Conflicts between two non-cyclic tokens are marked as
    // 'soft', with a negative number if a is shorter than
    // b, and a positive if b is shorter than a.
    soft, exampleA, exampleB) {
        this.a = a;
        this.b = b;
        this.soft = soft;
        this.exampleA = exampleA;
        this.exampleB = exampleB;
    }
};
function exampleFromEdges(edges) {
    let str = "";
    for (let i = 0; i < edges.length; i++)
        str += String.fromCharCode(edges[i].from);
    return str;
}
function ids(elts) {
    let result = "";
    for (let elt of elts) {
        if (result.length)
            result += "-";
        result += elt.id;
    }
    return result;
}
function sameSet$1(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i])
            return false;
    return true;
}
class MergedEdge {
    constructor(from, to, targets) {
        this.from = from;
        this.to = to;
        this.targets = targets;
    }
}
// Merge multiple edges (tagged by character ranges) into a set of
// mutually exclusive ranges pointing at all target states for that
// range
function mergeEdges(edges) {
    let separate = [], result = [];
    for (let edge of edges) {
        if (!separate.includes(edge.from))
            separate.push(edge.from);
        if (!separate.includes(edge.to))
            separate.push(edge.to);
    }
    separate.sort((a, b) => a - b);
    for (let i = 1; i < separate.length; i++) {
        let from = separate[i - 1], to = separate[i];
        let found = [];
        for (let edge of edges)
            if (edge.to > from && edge.from < to) {
                for (let target of edge.target.closure())
                    if (!found.includes(target))
                        found.push(target);
            }
        if (found.length)
            result.push(new MergedEdge(from, to, found));
    }
    let eof = edges.filter(e => e.from == 65535 /* Seq.End */ && e.to == 65535 /* Seq.End */);
    if (eof.length) {
        let found = [];
        for (let edge of eof)
            for (let target of edge.target.closure())
                if (!found.includes(target))
                    found.push(target);
        if (found.length)
            result.push(new MergedEdge(65535 /* Seq.End */, 65535 /* Seq.End */, found));
    }
    return result;
}

// Note that this is the parser for grammar files, not the generated parser
let word = /[\w_-]+/gy;
// Some engines (specifically SpiderMonkey) have still not implemented \p
try {
    word = /[\p{Alphabetic}\d_-]+/ugy;
}
catch (_) { }
const none$2 = [];
class Input {
    constructor(string, fileName = null) {
        this.string = string;
        this.fileName = fileName;
        this.type = "sof";
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.next();
    }
    lineInfo(pos) {
        for (let line = 1, cur = 0;;) {
            let next = this.string.indexOf("\n", cur);
            if (next > -1 && next < pos) {
                ++line;
                cur = next + 1;
            }
            else {
                return { line, ch: pos - cur };
            }
        }
    }
    message(msg, pos = -1) {
        let posInfo = this.fileName || "";
        if (pos > -1) {
            let info = this.lineInfo(pos);
            posInfo += (posInfo ? " " : "") + info.line + ":" + info.ch;
        }
        return posInfo ? msg + ` (${posInfo})` : msg;
    }
    raise(msg, pos = -1) {
        throw new GenError(this.message(msg, pos));
    }
    match(pos, re) {
        let match = re.exec(this.string.slice(pos));
        return match ? pos + match[0].length : -1;
    }
    next() {
        let start = this.match(this.end, /^(\s|\/\/.*|\/\*[^]*?\*\/)*/);
        if (start == this.string.length)
            return this.set("eof", null, start, start);
        let next = this.string[start];
        if (next == '"') {
            let end = this.match(start + 1, /^(\\.|[^"\\])*"/);
            if (end == -1)
                this.raise("Unterminated string literal", start);
            return this.set("string", readString(this.string.slice(start + 1, end - 1)), start, end);
        }
        else if (next == "'") {
            let end = this.match(start + 1, /^(\\.|[^'\\])*'/);
            if (end == -1)
                this.raise("Unterminated string literal", start);
            return this.set("string", readString(this.string.slice(start + 1, end - 1)), start, end);
        }
        else if (next == "@") {
            word.lastIndex = start + 1;
            let m = word.exec(this.string);
            if (!m)
                return this.raise("@ without a name", start);
            return this.set("at", m[0], start, start + 1 + m[0].length);
        }
        else if ((next == "$" || next == "!") && this.string[start + 1] == "[") {
            let end = this.match(start + 2, /^(?:\\.|[^\]\\])*\]/);
            if (end == -1)
                this.raise("Unterminated character set", start);
            return this.set("set", this.string.slice(start + 2, end - 1), start, end);
        }
        else if (/[\[\]()!~+*?{}<>\.,|:$=]/.test(next)) {
            return this.set(next, null, start, start + 1);
        }
        else {
            word.lastIndex = start;
            let m = word.exec(this.string);
            if (!m)
                return this.raise("Unexpected character " + JSON.stringify(next), start);
            return this.set("id", m[0], start, start + m[0].length);
        }
    }
    set(type, value, start, end) {
        this.type = type;
        this.value = value;
        this.start = start;
        this.end = end;
    }
    eat(type, value = null) {
        if (this.type == type && (value == null || this.value === value)) {
            this.next();
            return true;
        }
        else {
            return false;
        }
    }
    unexpected() {
        return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start);
    }
    expect(type, value = null) {
        let val = this.value;
        if (this.type != type || !(value == null || val === value))
            this.unexpected();
        this.next();
        return val;
    }
    parse() {
        return parseGrammar(this);
    }
}
function parseGrammar(input) {
    let start = input.start;
    let rules = [];
    let prec = null;
    let tokens = null;
    let localTokens = [];
    let mainSkip = null;
    let scopedSkip = [];
    let dialects = [];
    let context = null;
    let external = [];
    let specialized = [];
    let props = [];
    let propSources = [];
    let tops = [];
    let sawTop = false;
    let autoDelim = false;
    while (input.type != "eof") {
        let start = input.start;
        if (input.eat("at", "top")) {
            if (input.type != "id")
                input.raise(`Top rules must have a name`, input.start);
            tops.push(parseRule(input, parseIdent(input)));
            sawTop = true;
        }
        else if (input.type == "at" && input.value == "tokens") {
            if (tokens)
                input.raise(`Multiple @tokens declaractions`, input.start);
            else
                tokens = parseTokens(input);
        }
        else if (input.eat("at", "local")) {
            input.expect("id", "tokens");
            localTokens.push(parseLocalTokens(input, start));
        }
        else if (input.eat("at", "context")) {
            if (context)
                input.raise(`Multiple @context declarations`, start);
            let id = parseIdent(input);
            input.expect("id", "from");
            let source = input.expect("string");
            context = new ContextDeclaration(start, id, source);
        }
        else if (input.eat("at", "external")) {
            if (input.eat("id", "tokens"))
                external.push(parseExternalTokens(input, start));
            else if (input.eat("id", "prop"))
                props.push(parseExternalProp(input, start));
            else if (input.eat("id", "extend"))
                specialized.push(parseExternalSpecialize(input, "extend", start));
            else if (input.eat("id", "specialize"))
                specialized.push(parseExternalSpecialize(input, "specialize", start));
            else if (input.eat("id", "propSource"))
                propSources.push(parseExternalPropSource(input, start));
            else
                input.unexpected();
        }
        else if (input.eat("at", "dialects")) {
            input.expect("{");
            for (let first = true; !input.eat("}"); first = false) {
                if (!first)
                    input.eat(",");
                dialects.push(parseIdent(input));
            }
        }
        else if (input.type == "at" && input.value == "precedence") {
            if (prec)
                input.raise(`Multiple precedence declarations`, input.start);
            prec = parsePrecedence(input);
        }
        else if (input.eat("at", "detectDelim")) {
            autoDelim = true;
        }
        else if (input.eat("at", "skip")) {
            let skip = parseBracedExpr(input);
            if (input.type == "{") {
                input.next();
                let rules = [], topRules = [];
                while (!input.eat("}")) {
                    if (input.eat("at", "top")) {
                        topRules.push(parseRule(input, parseIdent(input)));
                        sawTop = true;
                    }
                    else {
                        rules.push(parseRule(input));
                    }
                }
                scopedSkip.push({ expr: skip, topRules, rules });
            }
            else {
                if (mainSkip)
                    input.raise(`Multiple top-level skip declarations`, input.start);
                mainSkip = skip;
            }
        }
        else {
            rules.push(parseRule(input));
        }
    }
    if (!sawTop)
        return input.raise(`Missing @top declaration`);
    return new GrammarDeclaration(start, rules, tops, tokens, localTokens, context, external, specialized, propSources, prec, mainSkip, scopedSkip, dialects, props, autoDelim);
}
function parseRule(input, named) {
    let start = named ? named.start : input.start;
    let id = named || parseIdent(input);
    let props = parseProps(input);
    let params = [];
    if (input.eat("<"))
        while (!input.eat(">")) {
            if (params.length)
                input.expect(",");
            params.push(parseIdent(input));
        }
    let expr = parseBracedExpr(input);
    return new RuleDeclaration(start, id, props, params, expr);
}
function parseProps(input) {
    if (input.type != "[")
        return none$2;
    let props = [];
    input.expect("[");
    while (!input.eat("]")) {
        if (props.length)
            input.expect(",");
        props.push(parseProp(input));
    }
    return props;
}
function parseProp(input) {
    let start = input.start, value = [], name = input.value, at = input.type == "at";
    if (!input.eat("at") && !input.eat("id"))
        input.unexpected();
    if (input.eat("="))
        for (;;) {
            if (input.type == "string" || input.type == "id") {
                value.push(new PropPart(input.start, input.value, null));
                input.next();
            }
            else if (input.eat(".")) {
                value.push(new PropPart(input.start, ".", null));
            }
            else if (input.eat("{")) {
                value.push(new PropPart(input.start, null, input.expect("id")));
                input.expect("}");
            }
            else {
                break;
            }
        }
    return new Prop(start, at, name, value);
}
function parseBracedExpr(input) {
    input.expect("{");
    let expr = parseExprChoice(input);
    input.expect("}");
    return expr;
}
const SET_MARKER = "\ufdda"; // (Invalid unicode character)
function parseExprInner(input) {
    let start = input.start;
    if (input.eat("(")) {
        if (input.eat(")"))
            return new SequenceExpression(start, none$2, [none$2, none$2]);
        let expr = parseExprChoice(input);
        input.expect(")");
        return expr;
    }
    else if (input.type == "string") {
        let value = input.value;
        input.next();
        if (value.length == 0)
            return new SequenceExpression(start, none$2, [none$2, none$2]);
        return new LiteralExpression(start, value);
    }
    else if (input.eat("id", "_")) {
        return new AnyExpression(start);
    }
    else if (input.type == "set") {
        let content = input.value, invert = input.string[input.start] == "!";
        let unescaped = readString(content.replace(/\\.|-|"/g, (m) => {
            return m == "-" ? SET_MARKER : m == '"' ? '\\"' : m;
        }));
        let ranges = [];
        for (let pos = 0; pos < unescaped.length;) {
            let code = unescaped.codePointAt(pos);
            pos += code > 0xffff ? 2 : 1;
            if (pos < unescaped.length - 1 && unescaped[pos] == SET_MARKER) {
                let end = unescaped.codePointAt(pos + 1);
                pos += end > 0xffff ? 3 : 2;
                if (end < code)
                    input.raise("Invalid character range", input.start);
                addRange(input, ranges, code, end + 1);
            }
            else {
                if (code == SET_MARKER.charCodeAt(0))
                    code = 45;
                addRange(input, ranges, code, code + 1);
            }
        }
        input.next();
        return new SetExpression(start, ranges.sort((a, b) => a[0] - b[0]), invert);
    }
    else if (input.type == "at" && (input.value == "specialize" || input.value == "extend")) {
        let { start, value } = input;
        input.next();
        let props = parseProps(input);
        input.expect("<");
        let token = parseExprChoice(input), content;
        if (input.eat(",")) {
            content = parseExprChoice(input);
        }
        else if (token instanceof LiteralExpression) {
            content = token;
        }
        else {
            input.raise(`@${value} requires two arguments when its first argument isn't a literal string`);
        }
        input.expect(">");
        return new SpecializeExpression(start, value, props, token, content);
    }
    else if (input.type == "at" && CharClasses.hasOwnProperty(input.value)) {
        let cls = new CharClass(input.start, input.value);
        input.next();
        return cls;
    }
    else if (input.type == "[") {
        let rule = parseRule(input, new Identifier(start, "_anon"));
        if (rule.params.length)
            input.raise(`Inline rules can't have parameters`, rule.start);
        return new InlineRuleExpression(start, rule);
    }
    else {
        let id = parseIdent(input);
        if (input.type == "[" || input.type == "{") {
            let rule = parseRule(input, id);
            if (rule.params.length)
                input.raise(`Inline rules can't have parameters`, rule.start);
            return new InlineRuleExpression(start, rule);
        }
        else {
            if (input.eat(".") && id.name == "std" && CharClasses.hasOwnProperty(input.value)) {
                let cls = new CharClass(start, input.value);
                input.next();
                return cls;
            }
            return new NameExpression(start, id, parseArgs(input));
        }
    }
}
function parseArgs(input) {
    let args = [];
    if (input.eat("<"))
        while (!input.eat(">")) {
            if (args.length)
                input.expect(",");
            args.push(parseExprChoice(input));
        }
    return args;
}
function addRange(input, ranges, from, to) {
    if (!ranges.every(([a, b]) => b <= from || a >= to))
        input.raise("Overlapping character range", input.start);
    ranges.push([from, to]);
}
function parseExprSuffix(input) {
    let start = input.start;
    let expr = parseExprInner(input);
    for (;;) {
        let kind = input.type;
        if (input.eat("*") || input.eat("?") || input.eat("+"))
            expr = new RepeatExpression(start, expr, kind);
        else
            return expr;
    }
}
function endOfSequence(input) {
    return input.type == "}" || input.type == ")" || input.type == "|" || input.type == "/" ||
        input.type == "/\\" || input.type == "{" || input.type == "," || input.type == ">";
}
function parseExprSequence(input) {
    let start = input.start, exprs = [], markers = [none$2];
    do {
        // Add markers at this position
        for (;;) {
            let localStart = input.start, markerType;
            if (input.eat("~"))
                markerType = "ambig";
            else if (input.eat("!"))
                markerType = "prec";
            else
                break;
            markers[markers.length - 1] =
                markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType));
        }
        if (endOfSequence(input))
            break;
        exprs.push(parseExprSuffix(input));
        markers.push(none$2);
    } while (!endOfSequence(input));
    if (exprs.length == 1 && markers.every(ms => ms.length == 0))
        return exprs[0];
    return new SequenceExpression(start, exprs, markers, !exprs.length);
}
function parseExprChoice(input) {
    let start = input.start, left = parseExprSequence(input);
    if (!input.eat("|"))
        return left;
    let exprs = [left];
    do {
        exprs.push(parseExprSequence(input));
    } while (input.eat("|"));
    let empty = exprs.find(s => s instanceof SequenceExpression && s.empty);
    if (empty)
        input.raise("Empty expression in choice operator. If this is intentional, use () to make it explicit.", empty.start);
    return new ChoiceExpression(start, exprs);
}
function parseIdent(input) {
    if (input.type != "id")
        input.unexpected();
    let start = input.start, name = input.value;
    input.next();
    return new Identifier(start, name);
}
function parsePrecedence(input) {
    let start = input.start;
    input.next();
    input.expect("{");
    let items = [];
    while (!input.eat("}")) {
        if (items.length)
            input.eat(",");
        items.push({
            id: parseIdent(input),
            type: input.eat("at", "left") ? "left" : input.eat("at", "right") ? "right" : input.eat("at", "cut") ? "cut" : null
        });
    }
    return new PrecDeclaration(start, items);
}
function parseTokens(input) {
    let start = input.start;
    input.next();
    input.expect("{");
    let tokenRules = [];
    let literals = [];
    let precedences = [];
    let conflicts = [];
    while (!input.eat("}")) {
        if (input.type == "at" && input.value == "precedence") {
            precedences.push(parseTokenPrecedence(input));
        }
        else if (input.type == "at" && input.value == "conflict") {
            conflicts.push(parseTokenConflict(input));
        }
        else if (input.type == "string") {
            literals.push(new LiteralDeclaration(input.start, input.expect("string"), parseProps(input)));
        }
        else {
            tokenRules.push(parseRule(input));
        }
    }
    return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals);
}
function parseLocalTokens(input, start) {
    input.expect("{");
    let tokenRules = [];
    let precedences = [];
    let fallback = null;
    while (!input.eat("}")) {
        if (input.type == "at" && input.value == "precedence") {
            precedences.push(parseTokenPrecedence(input));
        }
        else if (input.eat("at", "else") && !fallback) {
            fallback = { id: parseIdent(input), props: parseProps(input) };
        }
        else {
            tokenRules.push(parseRule(input));
        }
    }
    return new LocalTokenDeclaration(start, precedences, tokenRules, fallback);
}
function parseTokenPrecedence(input) {
    let start = input.start;
    input.next();
    input.expect("{");
    let tokens = [];
    while (!input.eat("}")) {
        if (tokens.length)
            input.eat(",");
        let expr = parseExprInner(input);
        if (expr instanceof LiteralExpression || expr instanceof NameExpression)
            tokens.push(expr);
        else
            input.raise(`Invalid expression in token precedences`, expr.start);
    }
    return new TokenPrecDeclaration(start, tokens);
}
function parseTokenConflict(input) {
    let start = input.start;
    input.next();
    input.expect("{");
    let a = parseExprInner(input);
    if (!(a instanceof LiteralExpression || a instanceof NameExpression))
        input.raise(`Invalid expression in token conflict`, a.start);
    input.eat(",");
    let b = parseExprInner(input);
    if (!(b instanceof LiteralExpression || b instanceof NameExpression))
        input.raise(`Invalid expression in token conflict`, b.start);
    input.expect("}");
    return new TokenConflictDeclaration(start, a, b);
}
function parseExternalTokenSet(input) {
    let tokens = [];
    input.expect("{");
    while (!input.eat("}")) {
        if (tokens.length)
            input.eat(",");
        let id = parseIdent(input);
        let props = parseProps(input);
        tokens.push({ id, props });
    }
    return tokens;
}
function parseExternalTokens(input, start) {
    let id = parseIdent(input);
    input.expect("id", "from");
    let from = input.expect("string");
    return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input));
}
function parseExternalSpecialize(input, type, start) {
    let token = parseBracedExpr(input);
    let id = parseIdent(input);
    input.expect("id", "from");
    let from = input.expect("string");
    return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input));
}
function parseExternalPropSource(input, start) {
    let id = parseIdent(input);
    input.expect("id", "from");
    return new ExternalPropSourceDeclaration(start, id, input.expect("string"));
}
function parseExternalProp(input, start) {
    let externalID = parseIdent(input);
    let id = input.eat("id", "as") ? parseIdent(input) : externalID;
    input.expect("id", "from");
    let from = input.expect("string");
    return new ExternalPropDeclaration(start, id, externalID, from);
}
function readString(string) {
    let point = /\\(?:u\{([\da-f]+)\}|u([\da-f]{4})|x([\da-f]{2})|([ntbrf0])|(.))|[^]/yig;
    let out = "", m;
    while (m = point.exec(string)) {
        let [all, u1, u2, u3, single, unknown] = m;
        if (u1 || u2 || u3)
            out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16));
        else if (single)
            out += single == "n" ? "\n" : single == "t" ? "\t" : single == "0" ? "\0" : single == "r" ? "\r" : single == "f" ? "\f" : "\b";
        else if (unknown)
            out += unknown;
        else
            out += all;
    }
    return out;
}

function hash(a, b) { return (a << 5) + a + b; }
function hashString(h, s) {
    for (let i = 0; i < s.length; i++)
        h = hash(h, s.charCodeAt(i));
    return h;
}

const verbose = (typeof process != "undefined" && process.env.LOG) || "";
const timing = /\btime\b/.test(verbose);
const time = timing ? (label, f) => {
    let t0 = Date.now();
    let result = f();
    console.log(`${label} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);
    return result;
} : (_label, f) => f();

class Pos {
    constructor(rule, pos, 
    // NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called
    ahead, ambigAhead, skipAhead, via) {
        this.rule = rule;
        this.pos = pos;
        this.ahead = ahead;
        this.ambigAhead = ambigAhead;
        this.skipAhead = skipAhead;
        this.via = via;
        this.hash = 0;
    }
    finish() {
        let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash);
        for (let a of this.ahead)
            h = hash(h, a.hash);
        for (let group of this.ambigAhead)
            h = hashString(h, group);
        this.hash = h;
        return this;
    }
    get next() {
        return this.pos < this.rule.parts.length ? this.rule.parts[this.pos] : null;
    }
    advance() {
        return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish();
    }
    get skip() {
        return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip;
    }
    cmp(pos) {
        return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||
            cmpSet(this.ahead, pos.ahead, (a, b) => a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr);
    }
    eqSimple(pos) {
        return pos.rule == this.rule && pos.pos == this.pos;
    }
    toString() {
        let parts = this.rule.parts.map(t => t.name);
        parts.splice(this.pos, 0, "·");
        return `${this.rule.name} -> ${parts.join(" ")}`;
    }
    eq(other) {
        return this == other ||
            this.hash == other.hash && this.rule == other.rule && this.pos == other.pos && this.skipAhead == other.skipAhead &&
                sameSet(this.ahead, other.ahead) &&
                sameSet(this.ambigAhead, other.ambigAhead);
    }
    trail(maxLen = 60) {
        let result = [];
        for (let pos = this; pos; pos = pos.via) {
            for (let i = pos.pos - 1; i >= 0; i--)
                result.push(pos.rule.parts[i]);
        }
        let value = result.reverse().join(" ");
        if (value.length > maxLen)
            value = value.slice(value.length - maxLen).replace(/.*? /, "… ");
        return value;
    }
    conflicts(pos = this.pos) {
        let result = this.rule.conflicts[pos];
        if (pos == this.rule.parts.length && this.ambigAhead.length)
            result = result.join(new Conflicts(0, this.ambigAhead));
        return result;
    }
    static addOrigins(group, context) {
        let result = group.slice();
        for (let i = 0; i < result.length; i++) {
            let next = result[i];
            if (next.pos == 0)
                for (let pos of context) {
                    if (pos.next == next.rule.name && !result.includes(pos))
                        result.push(pos);
                }
        }
        return result;
    }
}
function conflictsAt(group) {
    let result = Conflicts.none;
    for (let pos of group)
        result = result.join(pos.conflicts());
    return result;
}
// Applies automatic action precedence based on repeat productions.
// These are left-associative, so reducing the `R -> R R` rule has
// higher precedence.
function compareRepeatPrec(a, b) {
    for (let pos of a)
        if (pos.rule.name.repeated) {
            for (let posB of b)
                if (posB.rule.name == pos.rule.name) {
                    if (pos.rule.isRepeatWrap && pos.pos == 2)
                        return 1;
                    if (posB.rule.isRepeatWrap && posB.pos == 2)
                        return -1;
                }
        }
    return 0;
}
function cmpStr(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function termsAhead(rule, pos, after, first) {
    let found = [];
    for (let i = pos + 1; i < rule.parts.length; i++) {
        let next = rule.parts[i], cont = false;
        if (next.terminal) {
            addTo(next, found);
        }
        else
            for (let term of first[next.name]) {
                if (term == null)
                    cont = true;
                else
                    addTo(term, found);
            }
        if (!cont)
            return found;
    }
    for (let a of after)
        addTo(a, found);
    return found;
}
function eqSet(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].eq(b[i]))
            return false;
    return true;
}
function sameSet(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i])
            return false;
    return true;
}
class Shift {
    constructor(term, target) {
        this.term = term;
        this.target = target;
    }
    eq(other) { return other instanceof Shift && this.term == other.term && other.target.id == this.target.id; }
    cmp(other) { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id; }
    matches(other, mapping) {
        return other instanceof Shift && mapping[other.target.id] == mapping[this.target.id];
    }
    toString() { return "s" + this.target.id; }
    map(mapping, states) {
        let mapped = states[mapping[this.target.id]];
        return mapped == this.target ? this : new Shift(this.term, mapped);
    }
}
class Reduce {
    constructor(term, rule) {
        this.term = term;
        this.rule = rule;
    }
    eq(other) {
        return other instanceof Reduce && this.term == other.term && other.rule.sameReduce(this.rule);
    }
    cmp(other) {
        return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||
            this.rule.parts.length - other.rule.parts.length;
    }
    matches(other, mapping) {
        return other instanceof Reduce && other.rule.sameReduce(this.rule);
    }
    toString() { return `${this.rule.name.name}(${this.rule.parts.length})`; }
    map() { return this; }
}
function hashPositions(set) {
    let h = 5381;
    for (let pos of set)
        h = hash(h, pos.hash);
    return h;
}
class ConflictContext {
    constructor(first) {
        this.first = first;
        this.conflicts = [];
    }
}
class State {
    constructor(id, set, flags = 0, skip, hash = hashPositions(set), startRule = null) {
        this.id = id;
        this.set = set;
        this.flags = flags;
        this.skip = skip;
        this.hash = hash;
        this.startRule = startRule;
        this.actions = [];
        this.actionPositions = [];
        this.goto = [];
        this.tokenGroup = -1;
        this.defaultReduce = null;
        this._actionsByTerm = null;
    }
    toString() {
        let actions = this.actions.map(t => t.term + "=" + t).join(",") +
            (this.goto.length ? " | " + this.goto.map(g => g.term + "=" + g).join(",") : "");
        return this.id + ": " + this.set.filter(p => p.pos > 0).join() +
            (this.defaultReduce ? `\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`
                : actions.length ? "\n  " + actions : "");
    }
    addActionInner(value, positions) {
        check: for (let i = 0; i < this.actions.length; i++) {
            let action = this.actions[i];
            if (action.term == value.term) {
                if (action.eq(value))
                    return null;
                let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set);
                let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos);
                let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence;
                if (diff > 0) { // Drop the existing action
                    this.actions.splice(i, 1);
                    this.actionPositions.splice(i, 1);
                    i--;
                    continue check;
                }
                else if (diff < 0) { // Drop this one
                    return null;
                }
                else if (conflicts.ambigGroups.some(g => actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity
                    continue check;
                }
                else { // Not resolved
                    return action;
                }
            }
        }
        this.actions.push(value);
        this.actionPositions.push(positions);
        return null;
    }
    addAction(value, positions, context) {
        let conflict = this.addActionInner(value, positions);
        if (conflict) {
            let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0];
            let rules = [positions[0].rule.name, conflictPos.rule.name];
            if (context.conflicts.some(c => c.rules.some(r => rules.includes(r))))
                return;
            let error;
            if (conflict instanceof Shift)
                error = `shift/reduce conflict between\n  ${conflictPos}\nand\n  ${positions[0].rule}`;
            else
                error = `reduce/reduce conflict between\n  ${conflictPos.rule}\nand\n  ${positions[0].rule}`;
            error += `\nWith input:\n  ${positions[0].trail(70)} · ${value.term} …`;
            if (conflict instanceof Shift)
                error += findConflictShiftSource(positions[0], conflict.term, context.first);
            error += findConflictOrigin(conflictPos, positions[0]);
            context.conflicts.push(new Conflict(error, rules));
        }
    }
    getGoto(term) {
        return this.goto.find(a => a.term == term);
    }
    hasSet(set) {
        return eqSet(this.set, set);
    }
    actionsByTerm() {
        let result = this._actionsByTerm;
        if (!result) {
            this._actionsByTerm = result = Object.create(null);
            for (let action of this.actions)
                (result[action.term.id] || (result[action.term.id] = [])).push(action);
        }
        return result;
    }
    finish() {
        if (this.actions.length) {
            let first = this.actions[0];
            if (first instanceof Reduce) {
                let { rule } = first;
                if (this.actions.every(a => a instanceof Reduce && a.rule.sameReduce(rule)))
                    this.defaultReduce = rule;
            }
        }
        this.actions.sort((a, b) => a.cmp(b));
        this.goto.sort((a, b) => a.cmp(b));
    }
    eq(other) {
        let dThis = this.defaultReduce, dOther = other.defaultReduce;
        if (dThis || dOther)
            return dThis && dOther ? dThis.sameReduce(dOther) : false;
        return this.skip == other.skip &&
            this.tokenGroup == other.tokenGroup &&
            eqSet(this.actions, other.actions) &&
            eqSet(this.goto, other.goto);
    }
}
function closure(set, first) {
    let added = [], redo = [];
    function addFor(name, ahead, ambigAhead, skipAhead, via) {
        for (let rule of name.rules) {
            let add = added.find(a => a.rule == rule);
            if (!add) {
                let existing = set.find(p => p.pos == 0 && p.rule == rule);
                add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)
                    : new Pos(rule, 0, [], none$1, skipAhead, via);
                added.push(add);
            }
            if (add.skipAhead != skipAhead)
                throw new GenError("Inconsistent skip sets after " + via.trail());
            add.ambigAhead = union(add.ambigAhead, ambigAhead);
            for (let term of ahead)
                if (!add.ahead.includes(term)) {
                    add.ahead.push(term);
                    if (add.rule.parts.length && !add.rule.parts[0].terminal)
                        addTo(add, redo);
                }
        }
    }
    for (let pos of set) {
        let next = pos.next;
        if (next && !next.terminal)
            addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first), pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip, pos);
    }
    while (redo.length) {
        let add = redo.pop();
        addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first), union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none$1), add.rule.parts.length == 1 ? add.skipAhead : add.rule.skip, add);
    }
    let result = set.slice();
    for (let add of added) {
        add.ahead.sort((a, b) => a.hash - b.hash);
        add.finish();
        let origIndex = set.findIndex(p => p.pos == 0 && p.rule == add.rule);
        if (origIndex > -1)
            result[origIndex] = add;
        else
            result.push(add);
    }
    return result.sort((a, b) => a.cmp(b));
}
function addTo(value, array) {
    if (!array.includes(value))
        array.push(value);
}
function computeFirstSets(terms) {
    let table = Object.create(null);
    for (let t of terms.terms)
        if (!t.terminal)
            table[t.name] = [];
    for (;;) {
        let change = false;
        for (let nt of terms.terms)
            if (!nt.terminal)
                for (let rule of nt.rules) {
                    let set = table[nt.name];
                    let found = false, startLen = set.length;
                    for (let part of rule.parts) {
                        found = true;
                        if (part.terminal) {
                            addTo(part, set);
                        }
                        else {
                            for (let t of table[part.name]) {
                                if (t == null)
                                    found = false;
                                else
                                    addTo(t, set);
                            }
                        }
                        if (found)
                            break;
                    }
                    if (!found)
                        addTo(null, set);
                    if (set.length > startLen)
                        change = true;
                }
        if (!change)
            return table;
    }
}
class Core {
    constructor(set, state) {
        this.set = set;
        this.state = state;
    }
}
class Conflict {
    constructor(error, rules) {
        this.error = error;
        this.rules = rules;
    }
}
function findConflictOrigin(a, b) {
    if (a.eqSimple(b))
        return "";
    function via(root, start) {
        let hist = [];
        for (let p = start.via; !p.eqSimple(root); p = p.via)
            hist.push(p);
        if (!hist.length)
            return "";
        hist.unshift(start);
        return hist.reverse().map((p, i) => "\n" + "  ".repeat(i + 1) + (p == start ? "" : "via ") + p).join("");
    }
    for (let p = a; p; p = p.via)
        for (let p2 = b; p2; p2 = p2.via) {
            if (p.eqSimple(p2))
                return "\nShared origin: " + p + via(p, a) + via(p, b);
        }
    return "";
}
// Search for the reason that a given 'after' token exists at the
// given pos, by scanning up the trail of positions. Because the `via`
// link is only one source of a pos, of potentially many, this
// requires a re-simulation of the whole path up to the pos.
function findConflictShiftSource(conflictPos, termAfter, first) {
    let pos = conflictPos, path = [];
    for (;;) {
        for (let i = pos.pos - 1; i >= 0; i--)
            path.push(pos.rule.parts[i]);
        if (!pos.via)
            break;
        pos = pos.via;
    }
    path.reverse();
    let seen = new Set();
    function explore(pos, i, hasMatch) {
        if (i == path.length && hasMatch && !pos.next)
            return `\nThe reduction of ${conflictPos.rule.name} is allowed before ${termAfter} because of this rule:\n  ${hasMatch}`;
        for (let next; next = pos.next;) {
            if (i < path.length && next == path[i]) {
                let inner = explore(pos.advance(), i + 1, hasMatch);
                if (inner)
                    return inner;
            }
            let after = pos.rule.parts[pos.pos + 1], match = pos.pos + 1 == pos.rule.parts.length ? hasMatch : null;
            if (after && (after.terminal ? after == termAfter : first[after.name].includes(termAfter)))
                match = pos.advance();
            for (let rule of next.rules) {
                let hash = (rule.id << 5) + i + (match ? 555 : 0);
                if (!seen.has(hash)) {
                    seen.add(hash);
                    let inner = explore(new Pos(rule, 0, [], [], next, pos), i, match);
                    if (inner)
                        return inner;
                }
            }
            if (!next.terminal && first[next.name].includes(null))
                pos = pos.advance();
            else
                break;
        }
        return "";
    }
    return explore(pos, 0, null);
}
// Builds a full LR(1) automaton
function buildFullAutomaton(terms, startTerms, first) {
    let states = [], statesBySetHash = {};
    let cores = {};
    let t0 = Date.now();
    function getState(core, top) {
        if (core.length == 0)
            return null;
        let coreHash = hashPositions(core), byHash = cores[coreHash];
        let skip;
        for (let pos of core) {
            if (!skip)
                skip = pos.skip;
            else if (skip != pos.skip)
                throw new GenError("Inconsistent skip sets after " + pos.trail());
        }
        if (byHash)
            for (let known of byHash)
                if (eqSet(core, known.set)) {
                    if (known.state.skip != skip)
                        throw new GenError("Inconsistent skip sets after " + known.set[0].trail());
                    return known.state;
                }
        let set = closure(core, first);
        let hash = hashPositions(set), forHash = statesBySetHash[hash] || (statesBySetHash[hash] = []);
        let found;
        if (!top)
            for (let state of forHash)
                if (state.hasSet(set))
                    found = state;
        if (!found) {
            found = new State(states.length, set, 0, skip, hash, top);
            forHash.push(found);
            states.push(found);
            if (timing && states.length % 500 == 0)
                console.log(`${states.length} states after ${((Date.now() - t0) / 1000).toFixed(2)}s`);
        }
        (cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found));
        return found;
    }
    for (const startTerm of startTerms) {
        const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names["%noskip"];
        getState(startTerm.rules.map(rule => new Pos(rule, 0, [terms.eof], none$1, startSkip, null).finish()), startTerm);
    }
    let conflicts = new ConflictContext(first);
    for (let filled = 0; filled < states.length; filled++) {
        let state = states[filled];
        let byTerm = [], byTermPos = [], atEnd = [];
        for (let pos of state.set) {
            if (pos.pos == pos.rule.parts.length) {
                if (!pos.rule.name.top)
                    atEnd.push(pos);
            }
            else {
                let next = pos.rule.parts[pos.pos];
                let index = byTerm.indexOf(next);
                if (index < 0) {
                    byTerm.push(next);
                    byTermPos.push([pos]);
                }
                else {
                    byTermPos[index].push(pos);
                }
            }
        }
        for (let i = 0; i < byTerm.length; i++) {
            let term = byTerm[i], positions = byTermPos[i].map(p => p.advance());
            if (term.terminal) {
                let set = applyCut(positions);
                let next = getState(set);
                if (next)
                    state.addAction(new Shift(term, next), byTermPos[i], conflicts);
            }
            else {
                let goto = getState(positions);
                if (goto)
                    state.goto.push(new Shift(term, goto));
            }
        }
        let replaced = false;
        for (let pos of atEnd)
            for (let ahead of pos.ahead) {
                let count = state.actions.length;
                state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts);
                if (state.actions.length == count)
                    replaced = true;
            }
        // If some actions were replaced by others, double-check whether
        // goto entries are now superfluous (for example, in an operator
        // precedence-related state that has a shift for `*` but only a
        // reduce for `+`, we don't need a goto entry for rules that start
        // with `+`)
        if (replaced)
            for (let i = 0; i < state.goto.length; i++) {
                let start = first[state.goto[i].term.name];
                if (!start.some(term => state.actions.some(a => a.term == term && (a instanceof Shift))))
                    state.goto.splice(i--, 1);
            }
    }
    if (conflicts.conflicts.length)
        throw new GenError(conflicts.conflicts.map(c => c.error).join("\n\n"));
    // Resolve alwaysReduce and sort actions
    for (let state of states)
        state.finish();
    if (timing)
        console.log(`${states.length} states total.`);
    return states;
}
function applyCut(set) {
    let found = null, cut = 1;
    for (let pos of set) {
        let value = pos.rule.conflicts[pos.pos - 1].cut;
        if (value < cut)
            continue;
        if (!found || value > cut) {
            cut = value;
            found = [];
        }
        found.push(pos);
    }
    return found || set;
}
// Verify that there are no conflicting actions or goto entries in the
// two given states (using the state ID remapping provided in mapping)
function canMerge(a, b, mapping) {
    // If a goto for the same term differs, that makes the states
    // incompatible
    for (let goto of a.goto)
        for (let other of b.goto) {
            if (goto.term == other.term && mapping[goto.target.id] != mapping[other.target.id])
                return false;
        }
    // If there is an action where a conflicting action exists in the
    // other state, the merge is only allowed when both states have the
    // exact same set of actions for this term.
    let byTerm = b.actionsByTerm();
    for (let action of a.actions) {
        let setB = byTerm[action.term.id];
        if (setB && setB.some(other => !other.matches(action, mapping))) {
            if (setB.length == 1)
                return false;
            let setA = a.actionsByTerm()[action.term.id];
            if (setA.length != setB.length || setA.some(a1 => !setB.some(a2 => a1.matches(a2, mapping))))
                return false;
        }
    }
    return true;
}
function mergeStates(states, mapping) {
    let newStates = [];
    for (let state of states) {
        let newID = mapping[state.id];
        if (!newStates[newID]) {
            newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule);
            newStates[newID].tokenGroup = state.tokenGroup;
            newStates[newID].defaultReduce = state.defaultReduce;
        }
    }
    for (let state of states) {
        let newID = mapping[state.id], target = newStates[newID];
        target.flags |= state.flags;
        for (let i = 0; i < state.actions.length; i++) {
            let action = state.actions[i].map(mapping, newStates);
            if (!target.actions.some(a => a.eq(action))) {
                target.actions.push(action);
                target.actionPositions.push(state.actionPositions[i]);
            }
        }
        for (let goto of state.goto) {
            let mapped = goto.map(mapping, newStates);
            if (!target.goto.some(g => g.eq(mapped)))
                target.goto.push(mapped);
        }
    }
    return newStates;
}
class Group {
    constructor(origin, member) {
        this.origin = origin;
        this.members = [member];
    }
}
function samePosSet(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].eqSimple(b[i]))
            return false;
    return true;
}
// Collapse an LR(1) automaton to an LALR-like automaton
function collapseAutomaton(states) {
    let mapping = [], groups = [];
    assignGroups: for (let i = 0; i < states.length; i++) {
        let state = states[i];
        if (!state.startRule)
            for (let j = 0; j < groups.length; j++) {
                let group = groups[j], other = states[group.members[0]];
                if (state.tokenGroup == other.tokenGroup &&
                    state.skip == other.skip &&
                    !other.startRule &&
                    samePosSet(state.set, other.set)) {
                    group.members.push(i);
                    mapping.push(j);
                    continue assignGroups;
                }
            }
        mapping.push(groups.length);
        groups.push(new Group(groups.length, i));
    }
    function spill(groupIndex, index) {
        let group = groups[groupIndex], state = states[group.members[index]];
        let pop = group.members.pop();
        if (index != group.members.length)
            group.members[index] = pop;
        for (let i = groupIndex + 1; i < groups.length; i++) {
            mapping[state.id] = i;
            if (groups[i].origin == group.origin &&
                groups[i].members.every(id => canMerge(state, states[id], mapping))) {
                groups[i].members.push(state.id);
                return;
            }
        }
        mapping[state.id] = groups.length;
        groups.push(new Group(group.origin, state.id));
    }
    for (let pass = 1;; pass++) {
        let conflicts = false, t0 = Date.now();
        for (let g = 0, startLen = groups.length; g < startLen; g++) {
            let group = groups[g];
            for (let i = 0; i < group.members.length - 1; i++) {
                for (let j = i + 1; j < group.members.length; j++) {
                    let idA = group.members[i], idB = group.members[j];
                    if (!canMerge(states[idA], states[idB], mapping)) {
                        conflicts = true;
                        spill(g, j--);
                    }
                }
            }
        }
        if (timing)
            console.log(`Collapse pass ${pass}${conflicts ? `` : `, done`} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);
        if (!conflicts)
            return mergeStates(states, mapping);
    }
}
function mergeIdentical(states) {
    for (let pass = 1;; pass++) {
        let mapping = [], didMerge = false, t0 = Date.now();
        let newStates = [];
        // Find states that either have the same alwaysReduce or the same
        // actions, and merge them.
        for (let i = 0; i < states.length; i++) {
            let state = states[i];
            let match = newStates.findIndex(s => state.eq(s));
            if (match < 0) {
                mapping[i] = newStates.length;
                newStates.push(state);
            }
            else {
                mapping[i] = match;
                didMerge = true;
                let other = newStates[match], add = null;
                for (let pos of state.set)
                    if (!other.set.some(p => p.eqSimple(pos)))
                        (add || (add = [])).push(pos);
                if (add)
                    other.set = add.concat(other.set).sort((a, b) => a.cmp(b));
            }
        }
        if (timing)
            console.log(`Merge identical pass ${pass}${didMerge ? "" : ", done"} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);
        if (!didMerge)
            return states;
        // Make sure actions point at merged state objects
        for (let state of newStates)
            if (!state.defaultReduce) {
                state.actions = state.actions.map(a => a.map(mapping, newStates));
                state.goto = state.goto.map(a => a.map(mapping, newStates));
            }
        // Renumber ids
        for (let i = 0; i < newStates.length; i++)
            newStates[i].id = i;
        states = newStates;
    }
}
const none$1 = [];
function finishAutomaton(full) {
    return mergeIdentical(collapseAutomaton(full));
}

// Encode numbers as groups of printable ascii characters
//
// - 0xffff, which is often used as placeholder, is encoded as "~"
//
// - The characters from " " (32) to "}" (125), excluding '"' and
//   "\\", indicate values from 0 to 92
//
// - The first bit in a 'digit' is used to indicate whether this is
//   the end of a number.
//
// - That leaves 46 other values, which are actually significant.
//
// - The digits in a number are ordered from high to low significance.
function digitToChar(digit) {
    let ch = digit + 32 /* Encode.Start */;
    if (ch >= 34 /* Encode.Gap1 */)
        ch++;
    if (ch >= 92 /* Encode.Gap2 */)
        ch++;
    return String.fromCharCode(ch);
}
function encode(value, max = 0xffff) {
    if (value > max)
        throw new Error("Trying to encode a number that's too big: " + value);
    if (value == 65535 /* Encode.BigVal */)
        return String.fromCharCode(126 /* Encode.BigValCode */);
    let result = "";
    for (let first = 46 /* Encode.Base */;; first = 0) {
        let low = value % 46 /* Encode.Base */, rest = value - low;
        result = digitToChar(low + first) + result;
        if (rest == 0)
            break;
        value = rest / 46 /* Encode.Base */;
    }
    return result;
}
function encodeArray(values, max = 0xffff) {
    let result = '"' + encode(values.length, 0xffffffff);
    for (let i = 0; i < values.length; i++)
        result += encode(values[i], max);
    result += '"';
    return result;
}

const none = [];
class Parts {
    constructor(terms, conflicts) {
        this.terms = terms;
        this.conflicts = conflicts;
    }
    concat(other) {
        if (this == Parts.none)
            return other;
        if (other == Parts.none)
            return this;
        let conflicts = null;
        if (this.conflicts || other.conflicts) {
            conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();
            let otherConflicts = other.ensureConflicts();
            conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0]);
            for (let i = 1; i < otherConflicts.length; i++)
                conflicts.push(otherConflicts[i]);
        }
        return new Parts(this.terms.concat(other.terms), conflicts);
    }
    withConflicts(pos, conflicts) {
        if (conflicts == Conflicts.none)
            return this;
        let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();
        array[pos] = array[pos].join(conflicts);
        return new Parts(this.terms, array);
    }
    ensureConflicts() {
        if (this.conflicts)
            return this.conflicts;
        let empty = [];
        for (let i = 0; i <= this.terms.length; i++)
            empty.push(Conflicts.none);
        return empty;
    }
}
Parts.none = new Parts(none, null);
function p(...terms) { return new Parts(terms, null); }
class BuiltRule {
    constructor(id, args, term) {
        this.id = id;
        this.args = args;
        this.term = term;
    }
    matches(expr) {
        return this.id == expr.id.name && exprsEq(expr.args, this.args);
    }
    matchesRepeat(expr) {
        return this.id == "+" && exprEq(expr.expr, this.args[0]);
    }
}
class Builder {
    constructor(text, options) {
        this.options = options;
        this.terms = new TermSet;
        this.specialized = Object.create(null);
        this.tokenOrigins = Object.create(null);
        this.rules = [];
        this.built = [];
        this.ruleNames = Object.create(null);
        this.namespaces = Object.create(null);
        this.namedTerms = Object.create(null);
        this.termTable = Object.create(null);
        this.knownProps = Object.create(null);
        this.dynamicRulePrecedences = [];
        this.definedGroups = [];
        this.astRules = [];
        this.currentSkip = [];
        time("Parse", () => {
            this.input = new Input(text, options.fileName);
            this.ast = this.input.parse();
        });
        let NP = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp;
        for (let prop in NP) {
            if (NP[prop] instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp && !NP[prop].perNode)
                this.knownProps[prop] = { prop: NP[prop], source: { name: prop, from: null } };
        }
        for (let prop of this.ast.externalProps) {
            this.knownProps[prop.id.name] = {
                prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp(),
                source: { name: prop.externalID.name, from: prop.source }
            };
        }
        this.dialects = this.ast.dialects.map(d => d.name);
        this.tokens = new MainTokenSet(this, this.ast.tokens);
        this.localTokens = this.ast.localTokens.map(g => new LocalTokenSet(this, g));
        this.externalTokens = this.ast.externalTokens.map(ext => new ExternalTokenSet(this, ext));
        this.externalSpecializers = this.ast.externalSpecializers.map(decl => new ExternalSpecializer(this, decl));
        time("Build rules", () => {
            let noSkip = this.newName("%noskip", true);
            this.defineRule(noSkip, []);
            let mainSkip = this.ast.mainSkip ? this.newName("%mainskip", true) : noSkip;
            let scopedSkip = [], topRules = [];
            for (let rule of this.ast.rules)
                this.astRules.push({ skip: mainSkip, rule });
            for (let rule of this.ast.topRules)
                topRules.push({ skip: mainSkip, rule });
            for (let scoped of this.ast.scopedSkip) {
                let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) => i < scopedSkip.length && exprEq(sc.expr, scoped.expr));
                if (found > -1)
                    skip = scopedSkip[found];
                else if (this.ast.mainSkip && exprEq(scoped.expr, this.ast.mainSkip))
                    skip = mainSkip;
                else if (!isEmpty(scoped.expr))
                    skip = this.newName("%skip", true);
                scopedSkip.push(skip);
                for (let rule of scoped.rules)
                    this.astRules.push({ skip, rule });
                for (let rule of scoped.topRules)
                    topRules.push({ skip, rule });
            }
            for (let { rule } of this.astRules) {
                this.unique(rule.id);
            }
            this.currentSkip.push(noSkip);
            this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip];
            if (mainSkip != noSkip)
                this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip));
            for (let i = 0; i < this.ast.scopedSkip.length; i++) {
                let skip = scopedSkip[i];
                if (!this.skipRules.includes(skip)) {
                    this.skipRules.push(skip);
                    if (skip != noSkip)
                        this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr));
                }
            }
            this.currentSkip.pop();
            for (let { rule, skip } of topRules.sort((a, b) => a.rule.start - b.rule.start)) {
                this.unique(rule.id);
                this.used(rule.id.name);
                this.currentSkip.push(skip);
                let { name, props } = this.nodeInfo(rule.props, "a", rule.id.name, none, none, rule.expr);
                let term = this.terms.makeTop(name, props);
                this.namedTerms[name] = term;
                this.defineRule(term, this.normalizeExpr(rule.expr));
                this.currentSkip.pop();
            }
            for (let ext of this.externalSpecializers)
                ext.finish();
            for (let { skip, rule } of this.astRules) {
                if (this.ruleNames[rule.id.name] && isExported(rule) && !rule.params.length) {
                    this.buildRule(rule, [], skip, false);
                    if (rule.expr instanceof SequenceExpression && rule.expr.exprs.length == 0)
                        this.used(rule.id.name);
                }
            }
        });
        for (let name in this.ruleNames) {
            let value = this.ruleNames[name];
            if (value)
                this.warn(`Unused rule '${value.name}'`, value.start);
        }
        this.tokens.takePrecedences();
        this.tokens.takeConflicts();
        for (let lt of this.localTokens)
            lt.takePrecedences();
        for (let { name, group, rule } of this.definedGroups)
            this.defineGroup(name, group, rule);
        this.checkGroups();
    }
    unique(id) {
        if (id.name in this.ruleNames)
            this.raise(`Duplicate definition of rule '${id.name}'`, id.start);
        this.ruleNames[id.name] = id;
    }
    used(name) {
        this.ruleNames[name] = null;
    }
    newName(base, nodeName = null, props = {}) {
        for (let i = nodeName ? 0 : 1;; i++) {
            let name = i ? `${base}-${i}` : base;
            if (!this.terms.names[name])
                return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props);
        }
    }
    prepareParser() {
        let rules = time("Simplify rules", () => simplifyRules(this.rules, [
            ...this.skipRules,
            ...this.terms.tops
        ]));
        let { nodeTypes, names: termNames, minRepeatTerm, maxTerm } = this.terms.finish(rules);
        for (let prop in this.namedTerms)
            this.termTable[prop] = this.namedTerms[prop].id;
        if (/\bgrammar\b/.test(verbose))
            console.log(rules.join("\n"));
        let startTerms = this.terms.tops.slice();
        let first = computeFirstSets(this.terms);
        let skipInfo = this.skipRules.map((name, id) => {
            let skip = [], startTokens = [], rules = [];
            for (let rule of name.rules) {
                if (!rule.parts.length)
                    continue;
                let start = rule.parts[0];
                for (let t of start.terminal ? [start] : first[start.name] || [])
                    if (t && !startTokens.includes(t))
                        startTokens.push(t);
                if (start.terminal && rule.parts.length == 1 && !rules.some(r => r != rule && r.parts[0] == start))
                    skip.push(start);
                else
                    rules.push(rule);
            }
            name.rules = rules;
            if (rules.length)
                startTerms.push(name);
            return { skip, rule: rules.length ? name : null, startTokens, id };
        });
        let fullTable = time("Build full automaton", () => buildFullAutomaton(this.terms, startTerms, first));
        let localTokens = this.localTokens
            .map((grp, i) => grp.buildLocalGroup(fullTable, skipInfo, i));
        let { tokenGroups, tokenPrec, tokenData } = time("Build token groups", () => this.tokens.buildTokenGroups(fullTable, skipInfo, localTokens.length));
        let table = time("Finish automaton", () => finishAutomaton(fullTable));
        let skipState = findSkipStates(table, this.terms.tops);
        if (/\blr\b/.test(verbose))
            console.log(table.join("\n"));
        let specialized = [];
        for (let ext of this.externalSpecializers)
            specialized.push(ext);
        for (let name in this.specialized)
            specialized.push({ token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name]) });
        let tokStart = (tokenizer) => {
            if (tokenizer instanceof ExternalTokenSet)
                return tokenizer.ast.start;
            return this.tokens.ast ? this.tokens.ast.start : -1;
        };
        let tokenizers = tokenGroups
            .concat(this.externalTokens)
            .sort((a, b) => tokStart(a) - tokStart(b))
            .concat(localTokens);
        let data = new DataBuilder;
        let skipData = skipInfo.map(info => {
            let actions = [];
            for (let term of info.skip)
                actions.push(term.id, 0, 262144 /* Action.StayFlag */ >> 16);
            if (info.rule) {
                let state = table.find(s => s.startRule == info.rule);
                for (let action of state.actions)
                    actions.push(action.term.id, state.id, 131072 /* Action.GotoFlag */ >> 16);
            }
            actions.push(65535 /* Seq.End */, 0 /* Seq.Done */);
            return data.storeArray(actions);
        });
        let states = time("Finish states", () => {
            let states = new Uint32Array(table.length * 6 /* ParseState.Size */);
            let forceReductions = this.computeForceReductions(table, skipInfo);
            let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this);
            for (let s of table)
                finishCx.finish(s, skipState(s.id), forceReductions[s.id]);
            return states;
        });
        let dialects = Object.create(null);
        for (let i = 0; i < this.dialects.length; i++)
            dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t => t.id).concat(65535 /* Seq.End */));
        let dynamicPrecedences = null;
        if (this.dynamicRulePrecedences.length) {
            dynamicPrecedences = Object.create(null);
            for (let { rule, prec } of this.dynamicRulePrecedences)
                dynamicPrecedences[rule.id] = prec;
        }
        let topRules = Object.create(null);
        for (let term of this.terms.tops)
            topRules[term.nodeName] = [table.find(state => state.startRule == term).id, term.id];
        let precTable = data.storeArray(tokenPrec.concat(65535 /* Seq.End */));
        let { nodeProps, skippedTypes } = this.gatherNodeProps(nodeTypes);
        return {
            states,
            stateData: data.finish(),
            goto: computeGotoTable(table),
            nodeNames: nodeTypes.filter(t => t.id < minRepeatTerm).map(t => t.nodeName).join(" "),
            nodeProps,
            skippedTypes,
            maxTerm,
            repeatNodeCount: nodeTypes.length - minRepeatTerm,
            tokenizers,
            tokenData,
            topRules,
            dialects,
            dynamicPrecedences,
            specialized,
            tokenPrec: precTable,
            termNames
        };
    }
    getParser() {
        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers, tokenData, topRules, dialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();
        let specialized = rawSpecialized.map(v => {
            if (v instanceof ExternalSpecializer) {
                let ext = this.options.externalSpecializer(v.ast.id.name, this.termTable);
                return {
                    term: v.term.id,
                    get: (value, stack) => (ext(value, stack) << 1) |
                        (v.ast.type == "extend" ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */),
                    external: ext,
                    extend: v.ast.type == "extend"
                };
            }
            else {
                return { term: v.token.id, get: (value) => v.table[value] || -1 };
            }
        });
        return _lezer_lr__WEBPACK_IMPORTED_MODULE_1__.LRParser.deserialize({
            version: 14 /* File.Version */,
            states,
            stateData,
            goto,
            nodeNames,
            maxTerm,
            repeatNodeCount,
            nodeProps: rawNodeProps.map(({ prop, terms }) => [this.knownProps[prop].prop, ...terms]),
            propSources: !this.options.externalPropSource ? undefined
                : this.ast.externalPropSources.map(s => this.options.externalPropSource(s.id.name)),
            skippedNodes: skippedTypes,
            tokenData,
            tokenizers: tokenizers.map(tok => tok.create()),
            context: !this.ast.context ? undefined
                : typeof this.options.contextTracker == "function" ? this.options.contextTracker(this.termTable)
                    : this.options.contextTracker,
            topRules,
            dialects,
            dynamicPrecedences,
            specialized,
            tokenPrec,
            termNames
        });
    }
    getParserFile() {
        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers: rawTokenizers, tokenData, topRules, dialects: rawDialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();
        let mod = this.options.moduleStyle || "es";
        let gen = "// This file was generated by lezer-generator. You probably shouldn't edit it.\n", head = gen;
        let imports = {}, imported = Object.create(null);
        let defined = Object.create(null);
        for (let word of KEYWORDS)
            defined[word] = true;
        let exportName = this.options.exportName || "parser";
        defined[exportName] = true;
        let getName = (prefix) => {
            for (let i = 0;; i++) {
                let id = prefix + (i ? "_" + i : "");
                if (!defined[id])
                    return id;
            }
        };
        let importName = (name, source, prefix = name) => {
            let spec = name + " from " + source;
            if (imported[spec])
                return imported[spec];
            let src = JSON.stringify(source), varName = name;
            if (name in defined) {
                varName = getName(prefix);
                name += `${mod == "cjs" ? ":" : " as"} ${varName}`;
            }
            defined[varName] = true;
            (imports[src] || (imports[src] = [])).push(name);
            return imported[spec] = varName;
        };
        let lrParser = importName("LRParser", "@lezer/lr");
        let tokenizers = rawTokenizers.map(tok => tok.createSource(importName));
        let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source) : null;
        let nodeProps = rawNodeProps.map(({ prop, terms }) => {
            let { source } = this.knownProps[prop];
            let propID = source.from ? importName(source.name, source.from) : JSON.stringify(source.name);
            return `[${propID}, ${terms.map(serializePropValue).join(",")}]`;
        });
        function specializationTableString(table) {
            return "{__proto__:null," + Object.keys(table).map(key => `${/^(\d+|[a-zA-Z_]\w*)$/.test(key) ? key : JSON.stringify(key)}:${table[key]}`)
                .join(", ") + "}";
        }
        let specHead = "";
        let specialized = rawSpecialized.map(v => {
            if (v instanceof ExternalSpecializer) {
                let name = importName(v.ast.id.name, v.ast.source);
                let ts = this.options.typeScript ? ": any" : "";
                return `{term: ${v.term.id}, get: (value${ts}, stack${ts}) => (${name}(value, stack) << 1)${v.ast.type == "extend" ? ` | ${1 /* Specialize.Extend */}` : ''}, external: ${name}${v.ast.type == "extend" ? ', extend: true' : ''}}`;
            }
            else {
                let tableName = getName("spec_" + v.token.name.replace(/\W/g, ""));
                defined[tableName] = true;
                specHead += `const ${tableName} = ${specializationTableString(v.table)}\n`;
                let ts = this.options.typeScript ? `: keyof typeof ${tableName}` : "";
                return `{term: ${v.token.id}, get: (value${ts}) => ${tableName}[value] || -1}`;
            }
        });
        let propSources = this.ast.externalPropSources.map(s => importName(s.id.name, s.source));
        for (let source in imports) {
            if (mod == "cjs")
                head += `const {${imports[source].join(", ")}} = require(${source})\n`;
            else
                head += `import {${imports[source].join(", ")}} from ${source}\n`;
        }
        head += specHead;
        function serializePropValue(value) {
            return typeof value != "string" || /^(true|false|\d+(\.\d+)?|\.\d+)$/.test(value) ? value : JSON.stringify(value);
        }
        let dialects = Object.keys(rawDialects).map(d => `${d}: ${rawDialects[d]}`);
        let parserStr = `${lrParser}.deserialize({
  version: ${14 /* File.Version */},
  states: ${encodeArray(states, 0xffffffff)},
  stateData: ${encodeArray(stateData)},
  goto: ${encodeArray(goto)},
  nodeNames: ${JSON.stringify(nodeNames)},
  maxTerm: ${maxTerm}${context ? `,
  context: ${context}` : ""}${nodeProps.length ? `,
  nodeProps: [
    ${nodeProps.join(",\n    ")}
  ]` : ""}${propSources.length ? `,
  propSources: [${propSources.join()}]` : ""}${skippedTypes.length ? `,
  skippedNodes: ${JSON.stringify(skippedTypes)}` : ""},
  repeatNodeCount: ${repeatNodeCount},
  tokenData: ${encodeArray(tokenData)},
  tokenizers: [${tokenizers.join(", ")}],
  topRules: ${JSON.stringify(topRules)}${dialects.length ? `,
  dialects: {${dialects.join(", ")}}` : ""}${dynamicPrecedences ? `,
  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : ""}${specialized.length ? `,
  specialized: [${specialized.join(",")}]` : ""},
  tokenPrec: ${tokenPrec}${this.options.includeNames ? `,
  termNames: ${JSON.stringify(termNames)}` : ''}
})`;
        let terms = [];
        for (let name in this.termTable) {
            let id = name;
            if (KEYWORDS.includes(id))
                for (let i = 1;; i++) {
                    id = "_".repeat(i) + name;
                    if (!(id in this.termTable))
                        break;
                }
            else if (!/^[\w$]+$/.test(name)) {
                continue;
            }
            terms.push(`${id}${mod == "cjs" ? ":" : " ="} ${this.termTable[name]}`);
        }
        for (let id = 0; id < this.dialects.length; id++)
            terms.push(`Dialect_${this.dialects[id]}${mod == "cjs" ? ":" : " ="} ${id}`);
        return {
            parser: head + (mod == "cjs" ? `exports.${exportName} = ${parserStr}\n` : `export const ${exportName} = ${parserStr}\n`),
            terms: mod == "cjs" ? `${gen}module.exports = {\n  ${terms.join(",\n  ")}\n}`
                : `${gen}export const\n  ${terms.join(",\n  ")}\n`
        };
    }
    gatherNonSkippedNodes() {
        let seen = Object.create(null);
        let work = [];
        let add = (term) => {
            if (!seen[term.id]) {
                seen[term.id] = true;
                work.push(term);
            }
        };
        this.terms.tops.forEach(add);
        for (let i = 0; i < work.length; i++) {
            for (let rule of work[i].rules)
                for (let part of rule.parts)
                    add(part);
        }
        return seen;
    }
    gatherNodeProps(nodeTypes) {
        let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = [];
        let nodeProps = [];
        for (let type of nodeTypes) {
            if (!notSkipped[type.id] && !type.error)
                skippedTypes.push(type.id);
            for (let prop in type.props) {
                let known = this.knownProps[prop];
                if (!known)
                    throw new GenError("No known prop type for " + prop);
                if (known.source.from == null && (known.source.name == "repeated" || known.source.name == "error"))
                    continue;
                let rec = nodeProps.find(r => r.prop == prop);
                if (!rec)
                    nodeProps.push(rec = { prop, values: {} });
                (rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id);
            }
        }
        return {
            nodeProps: nodeProps.map(({ prop, values }) => {
                let terms = [];
                for (let val in values) {
                    let ids = values[val];
                    if (ids.length == 1) {
                        terms.push(ids[0], val);
                    }
                    else {
                        terms.push(-ids.length);
                        for (let id of ids)
                            terms.push(id);
                        terms.push(val);
                    }
                }
                return { prop, terms };
            }),
            skippedTypes
        };
    }
    makeTerminal(name, tag, props) {
        return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props);
    }
    computeForceReductions(states, skipInfo) {
        // This finds a forced reduction for every state, trying to guard
        // against cyclic forced reductions, where a given parse stack can
        // endlessly continue running forced reductions without making any
        // progress.
        //
        // This occurs with length-1 reductions. We never generate
        // length-0 reductions, and length-2+ reductions always shrink the
        // stack, so they are guaranteed to make progress.
        //
        // If there are states S1 and S2 whose forced reductions reduce
        // terms T1 and T2 respectively, both with a length of 1, _and_
        // there is a state S3, which has goto entries T1 -> S2, T2 -> S1,
        // you can get cyclic reductions. Of course, the cycle may also
        // contain more than two steps.
        let reductions = [];
        let candidates = [];
        // A map from terms to states that they are mapped to in goto
        // entries.
        let gotoEdges = Object.create(null);
        for (let state of states) {
            reductions.push(0);
            for (let edge of state.goto) {
                let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = []);
                let found = array.find(o => o.target == edge.target.id);
                if (found)
                    found.parents.push(state.id);
                else
                    array.push({ parents: [state.id], target: edge.target.id });
            }
            candidates[state.id] = state.set.filter(pos => pos.pos > 0 && !pos.rule.name.top)
                .sort((a, b) => b.pos - a.pos || a.rule.parts.length - b.rule.parts.length);
        }
        // Mapping from state ids to terms that that state has a length-1
        // forced reduction for.
        let length1Reductions = Object.create(null);
        function createsCycle(term, startState, parents = null) {
            let edges = gotoEdges[term];
            if (!edges)
                return false;
            return edges.some(val => {
                let parentIntersection = parents ? parents.filter(id => val.parents.includes(id)) : val.parents;
                if (parentIntersection.length == 0)
                    return false;
                if (val.target == startState)
                    return true;
                let found = length1Reductions[val.target];
                return found != null && createsCycle(found, startState, parentIntersection);
            });
        }
        for (let state of states) {
            if (state.defaultReduce && state.defaultReduce.parts.length > 0) {
                reductions[state.id] = reduceAction(state.defaultReduce, skipInfo);
                if (state.defaultReduce.parts.length == 1)
                    length1Reductions[state.id] = state.defaultReduce.name.id;
            }
        }
        // To avoid painting states that only have one potential forced
        // reduction into a corner, reduction assignment is done by
        // candidate size, starting with the states with fewer candidates.
        for (let setSize = 1;; setSize++) {
            let done = true;
            for (let state of states) {
                if (state.defaultReduce)
                    continue;
                let set = candidates[state.id];
                if (set.length != setSize) {
                    if (set.length > setSize)
                        done = false;
                    continue;
                }
                for (let pos of set) {
                    if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {
                        reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos);
                        if (pos.pos == 1)
                            length1Reductions[state.id] = pos.rule.name.id;
                        break;
                    }
                }
            }
            if (done)
                break;
        }
        return reductions;
    }
    substituteArgs(expr, args, params) {
        if (args.length == 0)
            return expr;
        return expr.walk(expr => {
            let found;
            if (expr instanceof NameExpression &&
                (found = params.findIndex(p => p.name == expr.id.name)) > -1) {
                let arg = args[found];
                if (expr.args.length) {
                    if (arg instanceof NameExpression && !arg.args.length)
                        return new NameExpression(expr.start, arg.id, expr.args);
                    this.raise(`Passing arguments to a parameter that already has arguments`, expr.start);
                }
                return arg;
            }
            else if (expr instanceof InlineRuleExpression) {
                let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params);
                return props == r.props ? expr :
                    new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr));
            }
            else if (expr instanceof SpecializeExpression) {
                let props = this.substituteArgsInProps(expr.props, args, params);
                return props == expr.props ? expr :
                    new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content);
            }
            return expr;
        });
    }
    substituteArgsInProps(props, args, params) {
        let substituteInValue = (value) => {
            let result = value;
            for (let i = 0; i < value.length; i++) {
                let part = value[i];
                if (!part.name)
                    continue;
                let found = params.findIndex(p => p.name == part.name);
                if (found < 0)
                    continue;
                if (result == value)
                    result = value.slice();
                let expr = args[found];
                if (expr instanceof NameExpression && !expr.args.length)
                    result[i] = new PropPart(part.start, expr.id.name, null);
                else if (expr instanceof LiteralExpression)
                    result[i] = new PropPart(part.start, expr.value, null);
                else
                    this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start);
            }
            return result;
        };
        let result = props;
        for (let i = 0; i < props.length; i++) {
            let prop = props[i], value = substituteInValue(prop.value);
            if (value != prop.value) {
                if (result == props)
                    result = props.slice();
                result[i] = new Prop(prop.start, prop.at, prop.name, value);
            }
        }
        return result;
    }
    conflictsFor(markers) {
        let here = Conflicts.none, atEnd = Conflicts.none;
        for (let marker of markers) {
            if (marker.type == "ambig") {
                here = here.join(new Conflicts(0, [marker.id.name]));
            }
            else {
                let precs = this.ast.precedences;
                let index = precs ? precs.items.findIndex(item => item.id.name == marker.id.name) : -1;
                if (index < 0)
                    this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start);
                let prec = precs.items[index], value = precs.items.length - index;
                if (prec.type == "cut") {
                    here = here.join(new Conflicts(0, none, value));
                }
                else {
                    here = here.join(new Conflicts(value << 2));
                    atEnd = atEnd.join(new Conflicts((value << 2) + (prec.type == "left" ? 1 : prec.type == "right" ? -1 : 0)));
                }
            }
        }
        return { here, atEnd };
    }
    raise(message, pos = 1) {
        return this.input.raise(message, pos);
    }
    warn(message, pos = -1) {
        let msg = this.input.message(message, pos);
        if (this.options.warn)
            this.options.warn(msg);
        else
            console.warn(msg);
    }
    defineRule(name, choices) {
        let skip = this.currentSkip[this.currentSkip.length - 1];
        for (let choice of choices)
            this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip));
    }
    resolve(expr) {
        for (let built of this.built)
            if (built.matches(expr))
                return [p(built.term)];
        let found = this.tokens.getToken(expr);
        if (found)
            return [p(found)];
        for (let grp of this.localTokens) {
            let found = grp.getToken(expr);
            if (found)
                return [p(found)];
        }
        for (let ext of this.externalTokens) {
            let found = ext.getToken(expr);
            if (found)
                return [p(found)];
        }
        for (let ext of this.externalSpecializers) {
            let found = ext.getToken(expr);
            if (found)
                return [p(found)];
        }
        let known = this.astRules.find(r => r.rule.id.name == expr.id.name);
        if (!known)
            return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start);
        if (known.rule.params.length != expr.args.length)
            this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start);
        this.used(known.rule.id.name);
        return [p(this.buildRule(known.rule, expr.args, known.skip))];
    }
    // For tree-balancing reasons, repeat expressions X+ have to be
    // normalized to something like
    //
    //     R -> X | R R
    //
    // Returns the `R` term.
    normalizeRepeat(expr) {
        let known = this.built.find(b => b.matchesRepeat(expr));
        if (known)
            return p(known.term);
        let name = expr.expr.prec < expr.prec ? `(${expr.expr})+` : `${expr.expr}+`;
        let term = this.terms.makeRepeat(this.terms.uniqueName(name));
        this.built.push(new BuiltRule("+", [expr.expr], term));
        this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)));
        return p(term);
    }
    normalizeSequence(expr) {
        let result = expr.exprs.map(e => this.normalizeExpr(e));
        let builder = this;
        function complete(start, from, endConflicts) {
            let { here, atEnd } = builder.conflictsFor(expr.markers[from]);
            if (from == result.length)
                return [start.withConflicts(start.terms.length, here.join(endConflicts))];
            let choices = [];
            for (let choice of result[from]) {
                for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here), from + 1, endConflicts.join(atEnd)))
                    choices.push(full);
            }
            return choices;
        }
        return complete(Parts.none, 0, Conflicts.none);
    }
    normalizeExpr(expr) {
        if (expr instanceof RepeatExpression && expr.kind == "?") {
            return [Parts.none, ...this.normalizeExpr(expr.expr)];
        }
        else if (expr instanceof RepeatExpression) {
            let repeated = this.normalizeRepeat(expr);
            return expr.kind == "+" ? [repeated] : [Parts.none, repeated];
        }
        else if (expr instanceof ChoiceExpression) {
            return expr.exprs.reduce((o, e) => o.concat(this.normalizeExpr(e)), []);
        }
        else if (expr instanceof SequenceExpression) {
            return this.normalizeSequence(expr);
        }
        else if (expr instanceof LiteralExpression) {
            return [p(this.tokens.getLiteral(expr))];
        }
        else if (expr instanceof NameExpression) {
            return this.resolve(expr);
        }
        else if (expr instanceof SpecializeExpression) {
            return [p(this.resolveSpecialization(expr))];
        }
        else if (expr instanceof InlineRuleExpression) {
            return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))];
        }
        else {
            return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start);
        }
    }
    buildRule(rule, args, skip, inline = false) {
        let expr = this.substituteArgs(rule.expr, args, rule.params);
        let { name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported } = this.nodeInfo(rule.props || none, inline ? "pg" : "pgi", rule.id.name, args, rule.params, rule.expr);
        if (exported && rule.params.length)
            this.warn(`Can't export parameterized rules`, rule.start);
        if (exported && inline)
            this.warn(`Can't export inline rule`, rule.start);
        let name = this.newName(rule.id.name + (args.length ? "<" + args.join(",") + ">" : ""), nodeName || true, props);
        if (explicitInline)
            name.inline = true;
        if (dynamicPrec)
            this.registerDynamicPrec(name, dynamicPrec);
        if ((name.nodeType || exported) && rule.params.length == 0) {
            if (!nodeName)
                name.preserve = true;
            if (!inline)
                this.namedTerms[exported || rule.id.name] = name;
        }
        if (!inline)
            this.built.push(new BuiltRule(rule.id.name, args, name));
        this.currentSkip.push(skip);
        let parts = this.normalizeExpr(expr);
        if (parts.length > 100 * (expr instanceof ChoiceExpression ? expr.exprs.length : 1))
            this.warn(`Rule ${rule.id.name} is generating a lot (${parts.length}) of choices.\n  Consider splitting it up or reducing the amount of ? or | operator uses.`, rule.start);
        if (/\brulesize\b/.test(verbose) && parts.length > 10)
            console.log(`Rule ${rule.id.name}: ${parts.length} variants`);
        this.defineRule(name, parts);
        this.currentSkip.pop();
        if (group)
            this.definedGroups.push({ name, group, rule });
        return name;
    }
    nodeInfo(props, 
    // p for dynamic precedence, d for dialect, i for inline, g for group, a for disabling the ignore test for default name
    allow, defaultName = null, args = none, params = none, expr, defaultProps) {
        let result = {};
        let name = defaultName && (allow.indexOf("a") > -1 || !ignored(defaultName)) && !/ /.test(defaultName) ? defaultName : null;
        let dialect = null, dynamicPrec = 0, inline = false, group = null, exported = null;
        for (let prop of props) {
            if (!prop.at) {
                if (!this.knownProps[prop.name]) {
                    let builtin = ["name", "dialect", "dynamicPrecedence", "export", "isGroup"].includes(prop.name)
                        ? ` (did you mean '@${prop.name}'?)` : "";
                    this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start);
                }
                result[prop.name] = this.finishProp(prop, args, params);
            }
            else if (prop.name == "name") {
                name = this.finishProp(prop, args, params);
                if (/ /.test(name))
                    this.raise(`Node names cannot have spaces ('${name}')`, prop.start);
            }
            else if (prop.name == "dialect") {
                if (allow.indexOf("d") < 0)
                    this.raise("Can't specify a dialect on non-token rules", props[0].start);
                if (prop.value.length != 1 && !prop.value[0].value)
                    this.raise("The '@dialect' rule prop must hold a plain string value");
                let dialectID = this.dialects.indexOf(prop.value[0].value);
                if (dialectID < 0)
                    this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start);
                dialect = dialectID;
            }
            else if (prop.name == "dynamicPrecedence") {
                if (allow.indexOf("p") < 0)
                    this.raise("Dynamic precedence can only be specified on nonterminals");
                if (prop.value.length != 1 || !/^-?(?:10|\d)$/.test(prop.value[0].value))
                    this.raise("The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10");
                dynamicPrec = +prop.value[0].value;
            }
            else if (prop.name == "inline") {
                if (prop.value.length)
                    this.raise("'@inline' doesn't take a value", prop.value[0].start);
                if (allow.indexOf("i") < 0)
                    this.raise("Inline can only be specified on nonterminals");
                inline = true;
            }
            else if (prop.name == "isGroup") {
                if (allow.indexOf("g") < 0)
                    this.raise("'@isGroup' can only be specified on nonterminals");
                group = prop.value.length ? this.finishProp(prop, args, params) : defaultName;
            }
            else if (prop.name == "export") {
                if (prop.value.length)
                    exported = this.finishProp(prop, args, params);
                else
                    exported = defaultName;
            }
            else {
                this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start);
            }
        }
        if (expr && this.ast.autoDelim && (name || hasProps(result))) {
            let delim = this.findDelimiters(expr);
            if (delim) {
                addToProp(delim[0], "closedBy", delim[1].nodeName);
                addToProp(delim[1], "openedBy", delim[0].nodeName);
            }
        }
        if (defaultProps && hasProps(defaultProps)) {
            for (let prop in defaultProps)
                if (!(prop in result))
                    result[prop] = defaultProps[prop];
        }
        if (hasProps(result) && !name)
            this.raise(`Node has properties but no name`, props.length ? props[0].start : expr.start);
        if (inline && (hasProps(result) || dialect || dynamicPrec))
            this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start);
        if (inline && name)
            name = null;
        return { name, props: result, dialect, dynamicPrec, inline, group, exported };
    }
    finishProp(prop, args, params) {
        return prop.value.map(part => {
            if (part.value)
                return part.value;
            let pos = params.findIndex(param => param.name == part.name);
            if (pos < 0)
                this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start);
            let expr = args[pos];
            if (expr instanceof NameExpression && !expr.args.length)
                return expr.id.name;
            if (expr instanceof LiteralExpression)
                return expr.value;
            return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start);
        }).join("");
    }
    resolveSpecialization(expr) {
        let type = expr.type;
        let { name, props, dialect, exported } = this.nodeInfo(expr.props, "d");
        let terminal = this.normalizeExpr(expr.token);
        if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)
            this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start);
        let values;
        if (expr.content instanceof LiteralExpression)
            values = [expr.content.value];
        else if ((expr.content instanceof ChoiceExpression) && expr.content.exprs.every(e => e instanceof LiteralExpression))
            values = expr.content.exprs.map(expr => expr.value);
        else
            return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start);
        let term = terminal[0].terms[0], token = null;
        let table = this.specialized[term.name] || (this.specialized[term.name] = []);
        for (let value of values) {
            let known = table.find(sp => sp.value == value);
            if (known == null) {
                if (!token) {
                    token = this.makeTerminal(term.name + "/" + JSON.stringify(value), name, props);
                    if (dialect != null)
                        (this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token);
                }
                table.push({ value, term: token, type, dialect, name });
                this.tokenOrigins[token.name] = { spec: term };
                if (name || exported) {
                    if (!name)
                        token.preserve = true;
                    this.namedTerms[exported || name] = token;
                }
            }
            else {
                if (known.type != type)
                    this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`, expr.start);
                if (known.dialect != dialect)
                    this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);
                if (known.name != name)
                    this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);
                if (token && known.term != token)
                    this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start);
                token = known.term;
            }
        }
        return token;
    }
    findDelimiters(expr) {
        if (!(expr instanceof SequenceExpression) || expr.exprs.length < 2)
            return null;
        let findToken = (expr) => {
            if (expr instanceof LiteralExpression)
                return { term: this.tokens.getLiteral(expr), str: expr.value };
            if (expr instanceof NameExpression && expr.args.length == 0) {
                let rule = this.ast.rules.find(r => r.id.name == expr.id.name);
                if (rule)
                    return findToken(rule.expr);
                let token = this.tokens.rules.find(r => r.id.name == expr.id.name);
                if (token && token.expr instanceof LiteralExpression)
                    return { term: this.tokens.getToken(expr), str: token.expr.value };
            }
            return null;
        };
        let lastToken = findToken(expr.exprs[expr.exprs.length - 1]);
        if (!lastToken || !lastToken.term.nodeName)
            return null;
        const brackets = ["()", "[]", "{}", "<>"];
        let bracket = brackets.find(b => lastToken.str.indexOf(b[1]) > -1 && lastToken.str.indexOf(b[0]) < 0);
        if (!bracket)
            return null;
        let firstToken = findToken(expr.exprs[0]);
        if (!firstToken || !firstToken.term.nodeName ||
            firstToken.str.indexOf(bracket[0]) < 0 || firstToken.str.indexOf(bracket[1]) > -1)
            return null;
        return [firstToken.term, lastToken.term];
    }
    registerDynamicPrec(term, prec) {
        this.dynamicRulePrecedences.push({ rule: term, prec });
        term.preserve = true;
    }
    defineGroup(rule, group, ast) {
        var _a;
        let recur = [];
        let getNamed = (rule) => {
            if (rule.nodeName)
                return [rule];
            if (recur.includes(rule))
                this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`, ast.start);
            let result = [];
            recur.push(rule);
            for (let r of this.rules)
                if (r.name == rule) {
                    let names = r.parts.map(getNamed).filter(x => x.length);
                    if (names.length > 1)
                        this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start);
                    if (names.length == 1)
                        for (let n of names[0])
                            result.push(n);
                }
            recur.pop();
            return result;
        };
        for (let name of getNamed(rule))
            name.props["group"] = (((_a = name.props["group"]) === null || _a === void 0 ? void 0 : _a.split(" ")) || []).concat(group).sort().join(" ");
    }
    checkGroups() {
        let groups = Object.create(null), nodeNames = Object.create(null);
        for (let term of this.terms.terms)
            if (term.nodeName) {
                nodeNames[term.nodeName] = true;
                if (term.props["group"])
                    for (let group of term.props["group"].split(" ")) {
                        (groups[group] || (groups[group] = [])).push(term);
                    }
            }
        let names = Object.keys(groups);
        for (let i = 0; i < names.length; i++) {
            let name = names[i], terms = groups[name];
            if (nodeNames[name])
                this.warn(`Group name '${name}' conflicts with a node of the same name`);
            for (let j = i + 1; j < names.length; j++) {
                let other = groups[names[j]];
                if (terms.some(t => other.includes(t)) &&
                    (terms.length > other.length ? other.some(t => !terms.includes(t)) : terms.some(t => !other.includes(t))))
                    this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`);
            }
        }
    }
}
const MinSharedActions = 5;
class FinishStateContext {
    constructor(tokenizers, data, stateArray, skipData, skipInfo, states, builder) {
        this.tokenizers = tokenizers;
        this.data = data;
        this.stateArray = stateArray;
        this.skipData = skipData;
        this.skipInfo = skipInfo;
        this.states = states;
        this.builder = builder;
        this.sharedActions = [];
    }
    findSharedActions(state) {
        if (state.actions.length < MinSharedActions)
            return null;
        let found = null;
        for (let shared of this.sharedActions) {
            if ((!found || shared.actions.length > found.actions.length) &&
                shared.actions.every(a => state.actions.some(b => b.eq(a))))
                found = shared;
        }
        if (found)
            return found;
        let max = null, scratch = [];
        for (let i = state.id + 1; i < this.states.length; i++) {
            let other = this.states[i], fill = 0;
            if (other.defaultReduce || other.actions.length < MinSharedActions)
                continue;
            for (let a of state.actions)
                for (let b of other.actions)
                    if (a.eq(b))
                        scratch[fill++] = a;
            if (fill >= MinSharedActions && (!max || max.length < fill)) {
                max = scratch;
                scratch = [];
            }
        }
        if (!max)
            return null;
        let result = { actions: max, addr: this.storeActions(max, -1, null) };
        this.sharedActions.push(result);
        return result;
    }
    storeActions(actions, skipReduce, shared) {
        if (skipReduce < 0 && shared && shared.actions.length == actions.length)
            return shared.addr;
        let data = [];
        for (let action of actions) {
            if (shared && shared.actions.some(a => a.eq(action)))
                continue;
            if (action instanceof Shift) {
                data.push(action.term.id, action.target.id, 0);
            }
            else {
                let code = reduceAction(action.rule, this.skipInfo);
                if (code != skipReduce)
                    data.push(action.term.id, code & 65535 /* Action.ValueMask */, code >> 16);
            }
        }
        data.push(65535 /* Seq.End */);
        if (skipReduce > -1)
            data.push(2 /* Seq.Other */, skipReduce & 65535 /* Action.ValueMask */, skipReduce >> 16);
        else if (shared)
            data.push(1 /* Seq.Next */, shared.addr & 0xffff, shared.addr >> 16);
        else
            data.push(0 /* Seq.Done */);
        return this.data.storeArray(data);
    }
    finish(state, isSkip, forcedReduce) {
        let b = this.builder;
        let skipID = b.skipRules.indexOf(state.skip);
        let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens;
        let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0;
        let flags = isSkip ? 1 /* StateFlag.Skipped */ : 0;
        let skipReduce = -1, shared = null;
        if (defaultReduce == 0) {
            if (isSkip)
                for (const action of state.actions)
                    if (action instanceof Reduce && action.term.eof)
                        skipReduce = reduceAction(action.rule, this.skipInfo);
            if (skipReduce < 0)
                shared = this.findSharedActions(state);
        }
        if (state.set.some(p => p.rule.name.top && p.pos == p.rule.parts.length))
            flags |= 2 /* StateFlag.Accepting */;
        let external = [];
        for (let i = 0; i < state.actions.length + skipTerms.length; i++) {
            let term = i < state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length];
            for (;;) {
                let orig = b.tokenOrigins[term.name];
                if (orig && orig.spec) {
                    term = orig.spec;
                    continue;
                }
                if (orig && (orig.external instanceof ExternalTokenSet))
                    addToSet(external, orig.external);
                break;
            }
        }
        let tokenizerMask = 0;
        for (let i = 0; i < this.tokenizers.length; i++) {
            let tok = this.tokenizers[i];
            if (external.includes(tok) || tok.groupID == state.tokenGroup)
                tokenizerMask |= (1 << i);
        }
        let base = state.id * 6 /* ParseState.Size */;
        this.stateArray[base + 0 /* ParseState.Flags */] = flags;
        this.stateArray[base + 1 /* ParseState.Actions */] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared);
        this.stateArray[base + 2 /* ParseState.Skip */] = skipTable;
        this.stateArray[base + 3 /* ParseState.TokenizerMask */] = tokenizerMask;
        this.stateArray[base + 4 /* ParseState.DefaultReduce */] = defaultReduce;
        this.stateArray[base + 5 /* ParseState.ForcedReduce */] = forcedReduce;
    }
}
function addToProp(term, prop, value) {
    let cur = term.props[prop];
    if (!cur || cur.split(" ").indexOf(value) < 0)
        term.props[prop] = cur ? cur + " " + value : value;
}
function buildSpecializeTable(spec) {
    let table = Object.create(null);
    for (let { value, term, type } of spec) {
        let code = type == "specialize" ? 0 /* Specialize.Specialize */ : 1 /* Specialize.Extend */;
        table[value] = (term.id << 1) | code;
    }
    return table;
}
function reduceAction(rule, skipInfo, depth = rule.parts.length) {
    return rule.name.id | 65536 /* Action.ReduceFlag */ |
        (rule.isRepeatWrap && depth == rule.parts.length ? 131072 /* Action.RepeatFlag */ : 0) |
        (skipInfo.some(i => i.rule == rule.name) ? 262144 /* Action.StayFlag */ : 0) |
        (depth << 19 /* Action.ReduceDepthShift */);
}
function findArray(data, value) {
    search: for (let i = 0;;) {
        let next = data.indexOf(value[0], i);
        if (next == -1 || next + value.length > data.length)
            break;
        for (let j = 1; j < value.length; j++) {
            if (value[j] != data[next + j]) {
                i = next + 1;
                continue search;
            }
        }
        return next;
    }
    return -1;
}
function findSkipStates(table, startRules) {
    let nonSkip = Object.create(null);
    let work = [];
    let add = (state) => {
        if (!nonSkip[state.id]) {
            nonSkip[state.id] = true;
            work.push(state);
        }
    };
    for (let state of table)
        if (state.startRule && startRules.includes(state.startRule))
            add(state);
    for (let i = 0; i < work.length; i++) {
        for (let a of work[i].actions)
            if (a instanceof Shift)
                add(a.target);
        for (let a of work[i].goto)
            add(a.target);
    }
    return (id) => !nonSkip[id];
}
class DataBuilder {
    constructor() {
        this.data = [];
    }
    storeArray(data) {
        let found = findArray(this.data, data);
        if (found > -1)
            return found;
        let pos = this.data.length;
        for (let num of data)
            this.data.push(num);
        return pos;
    }
    finish() {
        return Uint16Array.from(this.data);
    }
}
// The goto table maps a start state + a term to a new state, and is
// used to determine the new state when reducing. Because this allows
// more more efficient representation and access, unlike the action
// tables, the goto table is organized by term, with groups of start
// states that map to a given end state enumerated for each term.
// Since many terms only have a single valid goto target, this makes
// it cheaper to look those up.
//
// (Unfortunately, though the standard LR parsing mechanism never
// looks up invalid goto states, the incremental parsing mechanism
// needs accurate goto information for a state/term pair, so we do
// need to store state ids even for terms that have only one target.)
//
// - First comes the amount of terms in the table
//
// - Then, for each term, the offset of the term's data
//
// - At these offsets, there's a record for each target state
//
//   - Such a record starts with the amount of start states that go to
//     this target state, shifted one to the left, with the first bit
//     only set if this is the last record for this term.
//
//   - Then follows the target state id
//
//   - And then the start state ids
function computeGotoTable(states) {
    let goto = {};
    let maxTerm = 0;
    for (let state of states) {
        for (let entry of state.goto) {
            maxTerm = Math.max(entry.term.id, maxTerm);
            let set = goto[entry.term.id] || (goto[entry.term.id] = {});
            (set[entry.target.id] || (set[entry.target.id] = [])).push(state.id);
        }
    }
    let data = new DataBuilder;
    let index = [];
    let offset = maxTerm + 2; // Offset of the data, taking index size into account
    for (let term = 0; term <= maxTerm; term++) {
        let entries = goto[term];
        if (!entries) {
            index.push(1);
            continue;
        }
        let termTable = [];
        let keys = Object.keys(entries);
        for (let target of keys) {
            let list = entries[target];
            termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length << 1));
            termTable.push(+target);
            for (let source of list)
                termTable.push(source);
        }
        index.push(data.storeArray(termTable) + offset);
    }
    if (index.some(n => n > 0xffff))
        throw new GenError("Goto table too large");
    return Uint16Array.from([maxTerm + 1, ...index, ...data.data]);
}
class TokenGroup {
    constructor(tokens, groupID) {
        this.tokens = tokens;
        this.groupID = groupID;
    }
    create() { return this.groupID; }
    createSource() { return String(this.groupID); }
}
function addToSet(set, value) {
    if (!set.includes(value))
        set.push(value);
}
function buildTokenMasks(groups) {
    let masks = Object.create(null);
    for (let group of groups) {
        let groupMask = 1 << group.groupID;
        for (let term of group.tokens) {
            masks[term.id] = (masks[term.id] || 0) | groupMask;
        }
    }
    return masks;
}
class TokenArg {
    constructor(name, expr, scope) {
        this.name = name;
        this.expr = expr;
        this.scope = scope;
    }
}
class BuildingRule {
    constructor(name, start, to, args) {
        this.name = name;
        this.start = start;
        this.to = to;
        this.args = args;
    }
}
class TokenSet {
    constructor(b, ast) {
        this.b = b;
        this.ast = ast;
        this.startState = new State$1;
        this.built = [];
        this.building = []; // Used for recursion check
        this.byDialect = Object.create(null);
        this.precedenceRelations = [];
        this.rules = ast ? ast.rules : none;
        for (let rule of this.rules)
            b.unique(rule.id);
    }
    getToken(expr) {
        for (let built of this.built)
            if (built.matches(expr))
                return built.term;
        let name = expr.id.name;
        let rule = this.rules.find(r => r.id.name == name);
        if (!rule)
            return null;
        let { name: nodeName, props, dialect, exported } = this.b.nodeInfo(rule.props, "d", name, expr.args, rule.params.length != expr.args.length ? none : rule.params);
        let term = this.b.makeTerminal(expr.toString(), nodeName, props);
        if (dialect != null)
            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);
        if ((term.nodeType || exported) && rule.params.length == 0) {
            if (!term.nodeType)
                term.preserve = true;
            this.b.namedTerms[exported || name] = term;
        }
        this.buildRule(rule, expr, this.startState, new State$1([term]));
        this.built.push(new BuiltRule(name, expr.args, term));
        return term;
    }
    buildRule(rule, expr, from, to, args = none) {
        let name = expr.id.name;
        if (rule.params.length != expr.args.length)
            this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start);
        let building = this.building.find(b => b.name == name && exprsEq(expr.args, b.args));
        if (building) {
            if (building.to == to) {
                from.nullEdge(building.start);
                return;
            }
            let lastIndex = this.building.length - 1;
            while (this.building[lastIndex].name != name)
                lastIndex--;
            this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(lastIndex).map(b => b.name).join(" -> ")}`, expr.start);
        }
        this.b.used(rule.id.name);
        let start = new State$1;
        from.nullEdge(start);
        this.building.push(new BuildingRule(name, start, to, expr.args));
        this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to, expr.args.map((e, i) => new TokenArg(rule.params[i].name, e, args)));
        this.building.pop();
    }
    build(expr, from, to, args) {
        if (expr instanceof NameExpression) {
            let name = expr.id.name, arg = args.find(a => a.name == name);
            if (arg)
                return this.build(arg.expr, from, to, arg.scope);
            let rule;
            for (let i = 0, lt = this.b.localTokens; i <= lt.length; i++) {
                let set = i == lt.length ? this.b.tokens : lt[i];
                rule = set.rules.find(r => r.id.name == name);
            }
            if (!rule)
                return this.b.raise(`Reference to token rule '${expr.id.name}', which isn't found`, expr.start);
            this.buildRule(rule, expr, from, to, args);
        }
        else if (expr instanceof CharClass) {
            for (let [a, b] of CharClasses[expr.type])
                from.edge(a, b, to);
        }
        else if (expr instanceof ChoiceExpression) {
            for (let choice of expr.exprs)
                this.build(choice, from, to, args);
        }
        else if (isEmpty(expr)) {
            from.nullEdge(to);
        }
        else if (expr instanceof SequenceExpression) {
            let conflict = expr.markers.find(c => c.length > 0);
            if (conflict)
                this.b.raise("Conflict marker in token expression", conflict[0].start);
            for (let i = 0; i < expr.exprs.length; i++) {
                let next = i == expr.exprs.length - 1 ? to : new State$1;
                this.build(expr.exprs[i], from, next, args);
                from = next;
            }
        }
        else if (expr instanceof RepeatExpression) {
            if (expr.kind == "*") {
                let loop = new State$1;
                from.nullEdge(loop);
                this.build(expr.expr, loop, loop, args);
                loop.nullEdge(to);
            }
            else if (expr.kind == "+") {
                let loop = new State$1;
                this.build(expr.expr, from, loop, args);
                this.build(expr.expr, loop, loop, args);
                loop.nullEdge(to);
            }
            else { // expr.kind == "?"
                from.nullEdge(to);
                this.build(expr.expr, from, to, args);
            }
        }
        else if (expr instanceof SetExpression) {
            for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)
                rangeEdges(from, to, a, b);
        }
        else if (expr instanceof LiteralExpression) {
            for (let i = 0; i < expr.value.length; i++) {
                let ch = expr.value.charCodeAt(i);
                let next = i == expr.value.length - 1 ? to : new State$1;
                from.edge(ch, ch + 1, next);
                from = next;
            }
        }
        else if (expr instanceof AnyExpression) {
            let mid = new State$1;
            from.edge(0, 0xDC00, to);
            from.edge(0xDC00, MAX_CHAR + 1, to);
            from.edge(0xD800, 0xDC00, mid);
            mid.edge(0xDC00, 0xE000, to);
        }
        else {
            return this.b.raise(`Unrecognized expression type in token`, expr.start);
        }
    }
    takePrecedences() {
        let rel = this.precedenceRelations = [];
        if (this.ast)
            for (let group of this.ast.precedences) {
                let prev = [];
                for (let item of group.items) {
                    let level = [];
                    if (item instanceof NameExpression) {
                        for (let built of this.built)
                            if (item.args.length ? built.matches(item) : built.id == item.id.name)
                                level.push(built.term);
                    }
                    else {
                        let id = JSON.stringify(item.value), found = this.built.find(b => b.id == id);
                        if (found)
                            level.push(found.term);
                    }
                    if (!level.length)
                        this.b.warn(`Precedence specified for unknown token ${item}`, item.start);
                    for (let term of level)
                        addRel(rel, term, prev);
                    prev = prev.concat(level);
                }
            }
    }
    precededBy(a, b) {
        let found = this.precedenceRelations.find(r => r.term == a);
        return found && found.after.includes(b);
    }
    buildPrecTable(softConflicts) {
        let precTable = [], rel = this.precedenceRelations.slice();
        // Add entries for soft-conflicting tokens that are in the
        // precedence table, to make sure they'll appear in the right
        // order and don't mess up the longer-wins default rule.
        for (let { a, b, soft } of softConflicts)
            if (soft) {
                if (!rel.some(r => r.term == a) || !rel.some(r => r.term == b))
                    continue;
                if (soft < 0)
                    [a, b] = [b, a]; // Now a is longer than b (and should thus take precedence)
                addRel(rel, b, [a]);
                addRel(rel, a, []);
            }
        add: while (rel.length) {
            for (let i = 0; i < rel.length; i++) {
                let record = rel[i];
                if (record.after.every(t => precTable.includes(t.id))) {
                    precTable.push(record.term.id);
                    if (rel.length == 1)
                        break add;
                    rel[i] = rel.pop();
                    continue add;
                }
            }
            this.b.raise(`Cyclic token precedence relation between ${rel.map(r => r.term).join(", ")}`);
        }
        return precTable;
    }
}
class MainTokenSet extends TokenSet {
    constructor() {
        super(...arguments);
        this.explicitConflicts = [];
    }
    getLiteral(expr) {
        let id = JSON.stringify(expr.value);
        for (let built of this.built)
            if (built.id == id)
                return built.term;
        let name = null, props = {}, dialect = null, exported = null;
        let decl = this.ast ? this.ast.literals.find(l => l.literal == expr.value) : null;
        if (decl)
            ({ name, props, dialect, exported } = this.b.nodeInfo(decl.props, "da", expr.value));
        let term = this.b.makeTerminal(id, name, props);
        if (dialect != null)
            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);
        if (exported)
            this.b.namedTerms[exported] = term;
        this.build(expr, this.startState, new State$1([term]), none);
        this.built.push(new BuiltRule(id, none, term));
        return term;
    }
    takeConflicts() {
        var _a;
        let resolve = (expr) => {
            if (expr instanceof NameExpression) {
                for (let built of this.built)
                    if (built.matches(expr))
                        return built.term;
            }
            else {
                let id = JSON.stringify(expr.value), found = this.built.find(b => b.id == id);
                if (found)
                    return found.term;
            }
            this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start);
            return null;
        };
        for (let c of ((_a = this.ast) === null || _a === void 0 ? void 0 : _a.conflicts) || []) {
            let a = resolve(c.a), b = resolve(c.b);
            if (a && b) {
                if (a.id < b.id)
                    [a, b] = [b, a];
                this.explicitConflicts.push({ a, b });
            }
        }
    }
    // Token groups are a mechanism for allowing conflicting (matching
    // overlapping input, without an explicit precedence being given)
    // tokens to exist in a grammar _if_ they don't occur in the same
    // place (aren't used in the same states).
    //
    // States that use tokens that conflict will raise an error when any
    // of the conflicting pairs of tokens both occur in that state.
    // Otherwise, they are assigned a token group, which includes all
    // the potentially-conflicting tokens they use. If there's already a
    // group that doesn't have any conflicts with those tokens, that is
    // reused, otherwise a new group is created.
    //
    // So each state has zero or one token groups, and each conflicting
    // token may belong to one or more groups. Tokens get assigned a
    // 16-bit bitmask with the groups they belong to set to 1 (all-1s
    // for non-conflicting tokens). When tokenizing, that mask is
    // compared to the current state's group (again using all-1s for
    // group-less states) to determine whether a token is applicable for
    // this state.
    //
    // Extended/specialized tokens are treated as their parent token for
    // this purpose.
    buildTokenGroups(states, skipInfo, startID) {
        let tokens = this.startState.compile();
        if (tokens.accepting.length)
            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);
        if (/\btokens\b/.test(verbose))
            console.log(tokens.toString());
        // If there is a precedence specified for the pair, the conflict is resolved
        let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))
            .filter(({ a, b }) => !this.precededBy(a, b) && !this.precededBy(b, a));
        for (let { a, b } of this.explicitConflicts) {
            if (!allConflicts.some(c => c.a == a && c.b == b))
                allConflicts.push(new Conflict$1(a, b, 0, "", ""));
        }
        let softConflicts = allConflicts.filter(c => c.soft), conflicts = allConflicts.filter(c => !c.soft);
        let errors = [];
        let groups = [];
        for (let state of states) {
            if (state.defaultReduce || state.tokenGroup > -1)
                continue;
            // Find potentially-conflicting terms (in terms) and the things
            // they conflict with (in conflicts), and raise an error if
            // there's a token conflict directly in this state.
            let terms = [], incompatible = [];
            let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;
            for (let term of skip)
                if (state.actions.some(a => a.term == term))
                    this.b.raise(`Use of token ${term.name} conflicts with skip rule`);
            let stateTerms = [];
            for (let i = 0; i < state.actions.length + (skip ? skip.length : 0); i++) {
                let term = i < state.actions.length ? state.actions[i].term : skip[i - state.actions.length];
                let orig = this.b.tokenOrigins[term.name];
                if (orig && orig.spec)
                    term = orig.spec;
                else if (orig && orig.external)
                    continue;
                addToSet(stateTerms, term);
            }
            if (stateTerms.length == 0)
                continue;
            for (let term of stateTerms) {
                for (let conflict of conflicts) {
                    let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null;
                    if (!conflicting)
                        continue;
                    if (stateTerms.includes(conflicting) && !errors.some(e => e.conflict == conflict)) {
                        let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : ""})` : "";
                        errors.push({
                            error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}\n` +
                                `After: ${state.set[0].trail()}`,
                            conflict
                        });
                    }
                    addToSet(terms, term);
                    addToSet(incompatible, conflicting);
                }
            }
            let tokenGroup = null;
            for (let group of groups) {
                if (incompatible.some(term => group.tokens.includes(term)))
                    continue;
                for (let term of terms)
                    addToSet(group.tokens, term);
                tokenGroup = group;
                break;
            }
            if (!tokenGroup) {
                tokenGroup = new TokenGroup(terms, groups.length + startID);
                groups.push(tokenGroup);
            }
            state.tokenGroup = tokenGroup.groupID;
        }
        if (errors.length)
            this.b.raise(errors.map(e => e.error).join("\n\n"));
        if (groups.length + startID > 16)
            this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);
        let precTable = this.buildPrecTable(softConflicts);
        return {
            tokenGroups: groups,
            tokenPrec: precTable,
            tokenData: tokens.toArray(buildTokenMasks(groups), precTable)
        };
    }
}
class LocalTokenSet extends TokenSet {
    constructor(b, ast) {
        super(b, ast);
        this.fallback = null;
        if (ast.fallback)
            b.unique(ast.fallback.id);
    }
    getToken(expr) {
        let term = null;
        if (this.ast.fallback && this.ast.fallback.id.name == expr.id.name) {
            if (expr.args.length)
                this.b.raise(`Incorrect number of arguments for ${expr.id.name}`, expr.start);
            if (!this.fallback) {
                let { name: nodeName, props, exported } = this.b.nodeInfo(this.ast.fallback.props, "", expr.id.name, none, none);
                let term = this.fallback = this.b.makeTerminal(expr.id.name, nodeName, props);
                if (term.nodeType || exported) {
                    if (!term.nodeType)
                        term.preserve = true;
                    this.b.namedTerms[exported || expr.id.name] = term;
                }
                this.b.used(expr.id.name);
            }
            term = this.fallback;
        }
        else {
            term = super.getToken(expr);
        }
        if (term && !this.b.tokenOrigins[term.name])
            this.b.tokenOrigins[term.name] = { group: this };
        return term;
    }
    buildLocalGroup(states, skipInfo, id) {
        let tokens = this.startState.compile();
        if (tokens.accepting.length)
            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);
        for (let { a, b, exampleA } of tokens.findConflicts(() => true)) {
            if (!this.precededBy(a, b) && !this.precededBy(b, a))
                this.b.raise(`Overlapping tokens ${a.name} and ${b.name} in local token group${exampleA ? ` (example: ${JSON.stringify(exampleA)})` : ''}`);
        }
        for (let state of states) {
            if (state.defaultReduce)
                continue;
            // See if this state uses any of the tokens in this group, and
            // if so, make sure it *only* uses tokens from this group.
            let usesThis = null;
            let usesOther = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens[0];
            for (let { term } of state.actions) {
                let orig = this.b.tokenOrigins[term.name];
                if ((orig === null || orig === void 0 ? void 0 : orig.group) == this)
                    usesThis = term;
                else
                    usesOther = term;
            }
            if (usesThis) {
                if (usesOther)
                    this.b.raise(`Tokens from a local token group used together with other tokens (${usesThis.name} with ${usesOther.name})`);
                state.tokenGroup = id;
            }
        }
        let precTable = this.buildPrecTable(none);
        let tokenData = tokens.toArray({ [id]: 65535 /* Seq.End */ }, precTable);
        let precOffset = tokenData.length;
        let fullData = new Uint16Array(tokenData.length + precTable.length + 1);
        fullData.set(tokenData, 0);
        fullData.set(precTable, precOffset);
        fullData[fullData.length - 1] = 65535 /* Seq.End */;
        return {
            groupID: id,
            create: () => new _lezer_lr__WEBPACK_IMPORTED_MODULE_1__.LocalTokenGroup(fullData, precOffset, this.fallback ? this.fallback.id : undefined),
            createSource: importName => `new ${importName("LocalTokenGroup", "@lezer/lr")}(${encodeArray(fullData)}, ${precOffset}${this.fallback ? `, ${this.fallback.id}` : ''})`
        };
    }
}
function checkTogether(states, b, skipInfo) {
    let cache = Object.create(null);
    function hasTerm(state, term) {
        return state.actions.some(a => a.term == term) ||
            skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term);
    }
    return (a, b) => {
        if (a.id < b.id)
            [a, b] = [b, a];
        let key = a.id | (b.id << 16), cached = cache[key];
        if (cached != null)
            return cached;
        return cache[key] = states.some(state => hasTerm(state, a) && hasTerm(state, b));
    };
}
function invertRanges(ranges) {
    let pos = 0, result = [];
    for (let [a, b] of ranges) {
        if (a > pos)
            result.push([pos, a]);
        pos = b;
    }
    if (pos <= MAX_CODE)
        result.push([pos, MAX_CODE + 1]);
    return result;
}
const ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff;
const LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff;
// Create intermediate states for astral characters in a range, if
// necessary, since the tokenizer acts on UTF16 characters
function rangeEdges(from, to, low, hi) {
    if (low < ASTRAL) {
        if (low < GAP_START)
            from.edge(low, Math.min(hi, GAP_START), to);
        if (hi > GAP_END)
            from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to);
        low = ASTRAL;
    }
    if (hi <= ASTRAL)
        return;
    let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1);
    let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1);
    let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1);
    if (lowA == hiA) { // Share the first char code
        let hop = new State$1;
        from.edge(lowA, lowA + 1, hop);
        hop.edge(lowB, hiB + 1, to);
    }
    else {
        let midStart = lowA, midEnd = hiA;
        if (lowB > LOW_SURR_B) {
            midStart++;
            let hop = new State$1;
            from.edge(lowA, lowA + 1, hop);
            hop.edge(lowB, HIGH_SURR_B + 1, to);
        }
        if (hiB < HIGH_SURR_B) {
            midEnd--;
            let hop = new State$1;
            from.edge(hiA, hiA + 1, hop);
            hop.edge(LOW_SURR_B, hiB + 1, to);
        }
        if (midStart <= midEnd) {
            let hop = new State$1;
            from.edge(midStart, midEnd + 1, hop);
            hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to);
        }
    }
}
function isEmpty(expr) {
    return expr instanceof SequenceExpression && expr.exprs.length == 0;
}
function gatherExtTokens(b, tokens) {
    let result = Object.create(null);
    for (let token of tokens) {
        b.unique(token.id);
        let { name, props, dialect } = b.nodeInfo(token.props, "d", token.id.name);
        let term = b.makeTerminal(token.id.name, name, props);
        if (dialect != null)
            (b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term);
        b.namedTerms[token.id.name] = result[token.id.name] = term;
    }
    return result;
}
function findExtToken(b, tokens, expr) {
    let found = tokens[expr.id.name];
    if (!found)
        return null;
    if (expr.args.length)
        b.raise("External tokens cannot take arguments", expr.args[0].start);
    b.used(expr.id.name);
    return found;
}
function addRel(rel, term, after) {
    let found = rel.findIndex(r => r.term == term);
    if (found < 0)
        rel.push({ term, after });
    else
        rel[found] = { term, after: rel[found].after.concat(after) };
}
class ExternalTokenSet {
    constructor(b, ast) {
        this.b = b;
        this.ast = ast;
        this.tokens = gatherExtTokens(b, ast.tokens);
        for (let name in this.tokens)
            this.b.tokenOrigins[this.tokens[name].name] = { external: this };
    }
    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }
    create() {
        return this.b.options.externalTokenizer(this.ast.id.name, this.b.termTable);
    }
    createSource(importName) {
        let { source, id: { name } } = this.ast;
        return importName(name, source);
    }
}
class ExternalSpecializer {
    constructor(b, ast) {
        this.b = b;
        this.ast = ast;
        this.term = null;
        this.tokens = gatherExtTokens(b, ast.tokens);
    }
    finish() {
        let terms = this.b.normalizeExpr(this.ast.token);
        if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)
            this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start);
        this.term = terms[0].terms[0];
        for (let name in this.tokens)
            this.b.tokenOrigins[this.tokens[name].name] = { spec: this.term, external: this };
    }
    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }
}
function inlineRules(rules, preserve) {
    for (let pass = 0;; pass++) {
        let inlinable = Object.create(null), found;
        if (pass == 0)
            for (let rule of rules) {
                if (rule.name.inline && !inlinable[rule.name.name]) {
                    let group = rules.filter(r => r.name == rule.name);
                    if (group.some(r => r.parts.includes(rule.name)))
                        continue;
                    found = inlinable[rule.name.name] = group;
                }
            }
        for (let i = 0; i < rules.length; i++) {
            let rule = rules[i];
            if (!rule.name.interesting && !rule.parts.includes(rule.name) && rule.parts.length < 3 &&
                !preserve.includes(rule.name) &&
                (rule.parts.length == 1 || rules.every(other => other.skip == rule.skip || !other.parts.includes(rule.name))) &&
                !rule.parts.some(p => !!inlinable[p.name]) &&
                !rules.some((r, j) => j != i && r.name == rule.name))
                found = inlinable[rule.name.name] = [rule];
        }
        if (!found)
            return rules;
        let newRules = [];
        for (let rule of rules) {
            if (inlinable[rule.name.name])
                continue;
            if (!rule.parts.some(p => !!inlinable[p.name])) {
                newRules.push(rule);
                continue;
            }
            function expand(at, conflicts, parts) {
                if (at == rule.parts.length) {
                    newRules.push(new Rule(rule.name, parts, conflicts, rule.skip));
                    return;
                }
                let next = rule.parts[at], replace = inlinable[next.name];
                if (!replace) {
                    expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next));
                    return;
                }
                for (let r of replace)
                    expand(at + 1, conflicts.slice(0, conflicts.length - 1)
                        .concat(conflicts[at].join(r.conflicts[0]))
                        .concat(r.conflicts.slice(1, r.conflicts.length - 1))
                        .concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])), parts.concat(r.parts));
            }
            expand(0, [rule.conflicts[0]], []);
        }
        rules = newRules;
    }
}
function mergeRules(rules) {
    let merged = Object.create(null), found;
    for (let i = 0; i < rules.length;) {
        let groupStart = i;
        let name = rules[i++].name;
        while (i < rules.length && rules[i].name == name)
            i++;
        let size = i - groupStart;
        if (name.interesting)
            continue;
        for (let j = i; j < rules.length;) {
            let otherStart = j, otherName = rules[j++].name;
            while (j < rules.length && rules[j].name == otherName)
                j++;
            if (j - otherStart != size || otherName.interesting)
                continue;
            let match = true;
            for (let k = 0; k < size && match; k++) {
                let a = rules[groupStart + k], b = rules[otherStart + k];
                if (a.cmpNoName(b) != 0)
                    match = false;
            }
            if (match)
                found = merged[name.name] = otherName;
        }
    }
    if (!found)
        return rules;
    let newRules = [];
    for (let rule of rules)
        if (!merged[rule.name.name]) {
            newRules.push(rule.parts.every(p => !merged[p.name]) ? rule :
                new Rule(rule.name, rule.parts.map(p => merged[p.name] || p), rule.conflicts, rule.skip));
        }
    return newRules;
}
function simplifyRules(rules, preserve) {
    return mergeRules(inlineRules(rules, preserve));
}
/**
Build an in-memory parser instance for a given grammar. This is
mostly useful for testing. If your grammar uses external
tokenizers, you'll have to provide the `externalTokenizer` option
for the returned parser to be able to parse anything.
*/
function buildParser(text, options = {}) {
    let builder = new Builder(text, options), parser = builder.getParser();
    parser.termTable = builder.termTable;
    return parser;
}
const KEYWORDS = ["await", "break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally",
    "for", "function", "if", "return", "switch", "throw", "try", "var", "while", "with",
    "null", "true", "false", "instanceof", "typeof", "void", "delete", "new", "in", "this",
    "const", "class", "extends", "export", "import", "super", "enum", "implements", "interface",
    "let", "package", "private", "protected", "public", "static", "yield", "require"];
/**
Build the code that represents the parser tables for a given
grammar description. The `parser` property in the return value
holds the main file that exports the `Parser` instance. The
`terms` property holds a declaration file that defines constants
for all of the named terms in grammar, holding their ids as value.
This is useful when external code, such as a tokenizer, needs to
be able to use these ids. It is recommended to run a tree-shaking
bundler when importing this file, since you usually only need a
handful of the many terms in your code.
*/
function buildParserFile(text, options = {}) {
    return new Builder(text, options).getParserFile();
}
function ignored(name) {
    let first = name[0];
    return first == "_" || first.toUpperCase() != first;
}
function isExported(rule) {
    return rule.props.some(p => p.at && p.name == "export");
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbGV6ZXJfZ2VuZXJhdG9yX2Rpc3RfaW5kZXhfanMuYzUyN2Y5NTY0MjhjNDA0ZWZiYTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNhOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBOEMsaUJBQWlC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BsZXplci9nZW5lcmF0b3IvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCB9IGZyb20gJ0BsZXplci9scic7XG5cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBHcmFtbWFyRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgcnVsZXMsIHRvcFJ1bGVzLCB0b2tlbnMsIGxvY2FsVG9rZW5zLCBjb250ZXh0LCBleHRlcm5hbFRva2VucywgZXh0ZXJuYWxTcGVjaWFsaXplcnMsIGV4dGVybmFsUHJvcFNvdXJjZXMsIHByZWNlZGVuY2VzLCBtYWluU2tpcCwgc2NvcGVkU2tpcCwgZGlhbGVjdHMsIGV4dGVybmFsUHJvcHMsIGF1dG9EZWxpbSkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHRvcFJ1bGVzO1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5sb2NhbFRva2VucyA9IGxvY2FsVG9rZW5zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmV4dGVybmFsVG9rZW5zID0gZXh0ZXJuYWxUb2tlbnM7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxTcGVjaWFsaXplcnMgPSBleHRlcm5hbFNwZWNpYWxpemVycztcbiAgICAgICAgdGhpcy5leHRlcm5hbFByb3BTb3VyY2VzID0gZXh0ZXJuYWxQcm9wU291cmNlcztcbiAgICAgICAgdGhpcy5wcmVjZWRlbmNlcyA9IHByZWNlZGVuY2VzO1xuICAgICAgICB0aGlzLm1haW5Ta2lwID0gbWFpblNraXA7XG4gICAgICAgIHRoaXMuc2NvcGVkU2tpcCA9IHNjb3BlZFNraXA7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBkaWFsZWN0cztcbiAgICAgICAgdGhpcy5leHRlcm5hbFByb3BzID0gZXh0ZXJuYWxQcm9wcztcbiAgICAgICAgdGhpcy5hdXRvRGVsaW0gPSBhdXRvRGVsaW07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnJ1bGVzKS5qb2luKFwiXFxuXCIpOyB9XG59XG5jbGFzcyBSdWxlRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgaWQsIHByb3BzLCBwYXJhbXMsIGV4cHIpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZC5uYW1lICsgKHRoaXMucGFyYW1zLmxlbmd0aCA/IGA8JHt0aGlzLnBhcmFtcy5qb2luKCl9PmAgOiBcIlwiKSArIFwiIC0+IFwiICsgdGhpcy5leHByO1xuICAgIH1cbn1cbmNsYXNzIFByZWNEZWNsYXJhdGlvbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBpdGVtcykge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB9XG59XG5jbGFzcyBUb2tlblByZWNEZWNsYXJhdGlvbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBpdGVtcykge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB9XG59XG5jbGFzcyBUb2tlbkNvbmZsaWN0RGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgYSwgYikge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgfVxufVxuY2xhc3MgVG9rZW5EZWNsYXJhdGlvbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBwcmVjZWRlbmNlcywgY29uZmxpY3RzLCBydWxlcywgbGl0ZXJhbHMpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQpO1xuICAgICAgICB0aGlzLnByZWNlZGVuY2VzID0gcHJlY2VkZW5jZXM7XG4gICAgICAgIHRoaXMuY29uZmxpY3RzID0gY29uZmxpY3RzO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIHRoaXMubGl0ZXJhbHMgPSBsaXRlcmFscztcbiAgICB9XG59XG5jbGFzcyBMb2NhbFRva2VuRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgcHJlY2VkZW5jZXMsIHJ1bGVzLCBmYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMucHJlY2VkZW5jZXMgPSBwcmVjZWRlbmNlcztcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gZmFsbGJhY2s7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGxpdGVyYWwsIHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5saXRlcmFsID0gbGl0ZXJhbDtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIH1cbn1cbmNsYXNzIENvbnRleHREZWNsYXJhdGlvbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBpZCwgc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG59XG5jbGFzcyBFeHRlcm5hbFRva2VuRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgaWQsIHNvdXJjZSwgdG9rZW5zKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxufVxuY2xhc3MgRXh0ZXJuYWxTcGVjaWFsaXplRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgdHlwZSwgdG9rZW4sIGlkLCBzb3VyY2UsIHRva2Vucykge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxufVxuY2xhc3MgRXh0ZXJuYWxQcm9wU291cmNlRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgaWQsIHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxufVxuY2xhc3MgRXh0ZXJuYWxQcm9wRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgaWQsIGV4dGVybmFsSUQsIHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5leHRlcm5hbElEID0gZXh0ZXJuYWxJRDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxufVxuY2xhc3MgSWRlbnRpZmllciBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLm5hbWU7IH1cbn1cbmNsYXNzIEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlIHtcbiAgICB3YWxrKGYpIHsgcmV0dXJuIGYodGhpcyk7IH1cbiAgICBlcShfb3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5FeHByZXNzaW9uLnByb3RvdHlwZS5wcmVjID0gMTA7XG5jbGFzcyBOYW1lRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBpZCwgYXJncykge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmlkLm5hbWUgKyAodGhpcy5hcmdzLmxlbmd0aCA/IGA8JHt0aGlzLmFyZ3Muam9pbigpfT5gIDogXCJcIik7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pZC5uYW1lID09IG90aGVyLmlkLm5hbWUgJiYgZXhwcnNFcSh0aGlzLmFyZ3MsIG90aGVyLmFyZ3MpO1xuICAgIH1cbiAgICB3YWxrKGYpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSB3YWxrRXhwcnModGhpcy5hcmdzLCBmKTtcbiAgICAgICAgcmV0dXJuIGYoYXJncyA9PSB0aGlzLmFyZ3MgPyB0aGlzIDogbmV3IE5hbWVFeHByZXNzaW9uKHRoaXMuc3RhcnQsIHRoaXMuaWQsIGFyZ3MpKTtcbiAgICB9XG59XG5jbGFzcyBTcGVjaWFsaXplRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCB0eXBlLCBwcm9wcywgdG9rZW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgQCR7dGhpcy50eXBlfVske3RoaXMucHJvcHMuam9pbihcIixcIil9XTwke3RoaXMudG9rZW59LCAke3RoaXMuY29udGVudH0+YDsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiBQcm9wLmVxUHJvcHModGhpcy5wcm9wcywgb3RoZXIucHJvcHMpICYmIGV4cHJFcSh0aGlzLnRva2VuLCBvdGhlci50b2tlbikgJiZcbiAgICAgICAgICAgIGV4cHJFcSh0aGlzLmNvbnRlbnQsIG90aGVyLmNvbnRlbnQpO1xuICAgIH1cbiAgICB3YWxrKGYpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy50b2tlbi53YWxrKGYpLCBjb250ZW50ID0gdGhpcy5jb250ZW50LndhbGsoZik7XG4gICAgICAgIHJldHVybiBmKHRva2VuID09IHRoaXMudG9rZW4gJiYgY29udGVudCA9PSB0aGlzLmNvbnRlbnQgPyB0aGlzIDogbmV3IFNwZWNpYWxpemVFeHByZXNzaW9uKHRoaXMuc3RhcnQsIHRoaXMudHlwZSwgdGhpcy5wcm9wcywgdG9rZW4sIGNvbnRlbnQpKTtcbiAgICB9XG59XG5jbGFzcyBJbmxpbmVSdWxlRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBydWxlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBydWxlID0gdGhpcy5ydWxlO1xuICAgICAgICByZXR1cm4gYCR7cnVsZS5pZH0ke3J1bGUucHJvcHMubGVuZ3RoID8gYFske3J1bGUucHJvcHMuam9pbihcIixcIil9XWAgOiBcIlwifSB7ICR7cnVsZS5leHByfSB9YDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnJ1bGUsIG9SdWxlID0gb3RoZXIucnVsZTtcbiAgICAgICAgcmV0dXJuIGV4cHJFcShydWxlLmV4cHIsIG9SdWxlLmV4cHIpICYmIHJ1bGUuaWQubmFtZSA9PSBvUnVsZS5pZC5uYW1lICYmIFByb3AuZXFQcm9wcyhydWxlLnByb3BzLCBvUnVsZS5wcm9wcyk7XG4gICAgfVxuICAgIHdhbGsoZikge1xuICAgICAgICBsZXQgcnVsZSA9IHRoaXMucnVsZSwgZXhwciA9IHJ1bGUuZXhwci53YWxrKGYpO1xuICAgICAgICByZXR1cm4gZihleHByID09IHJ1bGUuZXhwciA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IElubGluZVJ1bGVFeHByZXNzaW9uKHRoaXMuc3RhcnQsIG5ldyBSdWxlRGVjbGFyYXRpb24ocnVsZS5zdGFydCwgcnVsZS5pZCwgcnVsZS5wcm9wcywgW10sIGV4cHIpKSk7XG4gICAgfVxufVxuY2xhc3MgQ2hvaWNlRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBleHBycykge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuZXhwcnMgPSBleHBycztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmV4cHJzLm1hcChlID0+IG1heWJlUGFyZW5zKGUsIHRoaXMpKS5qb2luKFwiIHwgXCIpOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJzRXEodGhpcy5leHBycywgb3RoZXIuZXhwcnMpO1xuICAgIH1cbiAgICB3YWxrKGYpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gd2Fsa0V4cHJzKHRoaXMuZXhwcnMsIGYpO1xuICAgICAgICByZXR1cm4gZihleHBycyA9PSB0aGlzLmV4cHJzID8gdGhpcyA6IG5ldyBDaG9pY2VFeHByZXNzaW9uKHRoaXMuc3RhcnQsIGV4cHJzKSk7XG4gICAgfVxufVxuQ2hvaWNlRXhwcmVzc2lvbi5wcm90b3R5cGUucHJlYyA9IDE7XG5jbGFzcyBTZXF1ZW5jZUV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZXhwcnMsIG1hcmtlcnMsIGVtcHR5ID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQpO1xuICAgICAgICB0aGlzLmV4cHJzID0gZXhwcnM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgICAgIHRoaXMuZW1wdHkgPSBlbXB0eTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gXCIoKVwiIDogdGhpcy5leHBycy5tYXAoZSA9PiBtYXliZVBhcmVucyhlLCB0aGlzKSkuam9pbihcIiBcIik7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gZXhwcnNFcSh0aGlzLmV4cHJzLCBvdGhlci5leHBycykgJiYgdGhpcy5tYXJrZXJzLmV2ZXJ5KChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb20gPSBvdGhlci5tYXJrZXJzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIG0ubGVuZ3RoID09IG9tLmxlbmd0aCAmJiBtLmV2ZXJ5KCh4LCBpKSA9PiB4LmVxKG9tW2ldKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWxrKGYpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gd2Fsa0V4cHJzKHRoaXMuZXhwcnMsIGYpO1xuICAgICAgICByZXR1cm4gZihleHBycyA9PSB0aGlzLmV4cHJzID8gdGhpcyA6IG5ldyBTZXF1ZW5jZUV4cHJlc3Npb24odGhpcy5zdGFydCwgZXhwcnMsIHRoaXMubWFya2VycywgdGhpcy5lbXB0eSAmJiAhZXhwcnMubGVuZ3RoKSk7XG4gICAgfVxufVxuU2VxdWVuY2VFeHByZXNzaW9uLnByb3RvdHlwZS5wcmVjID0gMjtcbmNsYXNzIENvbmZsaWN0TWFya2VyIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGlkLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gXCJhbWJpZ1wiID8gXCJ+XCIgOiBcIiFcIikgKyB0aGlzLmlkLm5hbWU7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5pZC5uYW1lID09IG90aGVyLmlkLm5hbWUgJiYgdGhpcy50eXBlID09IG90aGVyLnR5cGU7IH1cbn1cbmNsYXNzIFJlcGVhdEV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZXhwciwga2luZCkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gbWF5YmVQYXJlbnModGhpcy5leHByLCB0aGlzKSArIHRoaXMua2luZDsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBleHByRXEodGhpcy5leHByLCBvdGhlci5leHByKSAmJiB0aGlzLmtpbmQgPT0gb3RoZXIua2luZDtcbiAgICB9XG4gICAgd2FsayhmKSB7XG4gICAgICAgIGxldCBleHByID0gdGhpcy5leHByLndhbGsoZik7XG4gICAgICAgIHJldHVybiBmKGV4cHIgPT0gdGhpcy5leHByID8gdGhpcyA6IG5ldyBSZXBlYXRFeHByZXNzaW9uKHRoaXMuc3RhcnQsIGV4cHIsIHRoaXMua2luZCkpO1xuICAgIH1cbn1cblJlcGVhdEV4cHJlc3Npb24ucHJvdG90eXBlLnByZWMgPSAzO1xuY2xhc3MgTGl0ZXJhbEV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICAvLyB2YWx1ZS5sZW5ndGggaXMgYWx3YXlzID4gMFxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKTsgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLnZhbHVlID09IG90aGVyLnZhbHVlOyB9XG59XG5jbGFzcyBTZXRFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIHJhbmdlcywgaW52ZXJ0ZWQpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQpO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLmludmVydGVkID8gXCJeXCIgOiBcIlwifSR7dGhpcy5yYW5nZXMubWFwKChbYSwgYl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChhKSArIChiID09IGEgKyAxID8gXCJcIiA6IFwiLVwiICsgU3RyaW5nLmZyb21Db2RlUG9pbnQoYikpO1xuICAgICAgICB9KX1dYDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQgPT0gb3RoZXIuaW52ZXJ0ZWQgJiYgdGhpcy5yYW5nZXMubGVuZ3RoID09IG90aGVyLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMucmFuZ2VzLmV2ZXJ5KChbYSwgYl0sIGkpID0+IHsgbGV0IFt4LCB5XSA9IG90aGVyLnJhbmdlc1tpXTsgcmV0dXJuIGEgPT0geCAmJiBiID09IHk7IH0pO1xuICAgIH1cbn1cbmNsYXNzIEFueUV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCJfXCI7IH1cbiAgICBlcSgpIHsgcmV0dXJuIHRydWU7IH1cbn1cbmZ1bmN0aW9uIHdhbGtFeHBycyhleHBycywgZikge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGV4cHIgPSBleHByc1tpXS53YWxrKGYpO1xuICAgICAgICBpZiAoZXhwciAhPSBleHByc1tpXSAmJiAhcmVzdWx0KVxuICAgICAgICAgICAgcmVzdWx0ID0gZXhwcnMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBleHBycztcbn1cbmNvbnN0IENoYXJDbGFzc2VzID0ge1xuICAgIGFzY2lpTGV0dGVyOiBbWzY1LCA5MV0sIFs5NywgMTIzXV0sXG4gICAgYXNjaWlMb3dlcmNhc2U6IFtbOTcsIDEyM11dLFxuICAgIGFzY2lpVXBwZXJjYXNlOiBbWzY1LCA5MV1dLFxuICAgIGRpZ2l0OiBbWzQ4LCA1OF1dLFxuICAgIHdoaXRlc3BhY2U6IFtbOSwgMTRdLCBbMzIsIDMzXSwgWzEzMywgMTM0XSwgWzE2MCwgMTYxXSwgWzU3NjAsIDU3NjFdLCBbODE5MiwgODIwM10sXG4gICAgICAgIFs4MjMyLCA4MjM0XSwgWzgyMzksIDgyNDBdLCBbODI4NywgODI4OF0sIFsxMjI4OCwgMTIyODldXSxcbiAgICBlb2Y6IFtbMHhmZmZmLCAweGZmZmZdXVxufTtcbmNsYXNzIENoYXJDbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBcIkBcIiArIHRoaXMudHlwZTsgfVxuICAgIGVxKGV4cHIpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHByLnR5cGU7IH1cbn1cbmZ1bmN0aW9uIGV4cHJFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuZnVuY3Rpb24gZXhwcnNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGV4cHJFcShlLCBiW2ldKSk7XG59XG5jbGFzcyBQcm9wIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGF0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihzdGFydCk7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09IG90aGVyLm5hbWUgJiYgdGhpcy52YWx1ZS5sZW5ndGggPT0gb3RoZXIudmFsdWUubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLnZhbHVlLmV2ZXJ5KCh2LCBpKSA9PiB2LnZhbHVlID09IG90aGVyLnZhbHVlW2ldLnZhbHVlICYmIHYubmFtZSA9PSBvdGhlci52YWx1ZVtpXS5uYW1lKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAodGhpcy5hdCA/IFwiQFwiIDogXCJcIikgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiPVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBuYW1lLCB2YWx1ZSB9IG9mIHRoaXMudmFsdWUpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5hbWUgPyBgeyR7bmFtZX19YCA6IC9bXlxcdy1dLy50ZXN0KHZhbHVlKSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBlcVByb3BzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHAsIGkpID0+IHAuZXEoYltpXSkpO1xuICAgIH1cbn1cbmNsYXNzIFByb3BQYXJ0IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1heWJlUGFyZW5zKG5vZGUsIHBhcmVudCkge1xuICAgIHJldHVybiBub2RlLnByZWMgPCBwYXJlbnQucHJlYyA/IFwiKFwiICsgbm9kZS50b1N0cmluZygpICsgXCIpXCIgOiBub2RlLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuVGhlIHR5cGUgb2YgZXJyb3IgcmFpc2VkIHdoZW4gdGhlIHBhcnNlciBnZW5lcmF0b3IgZmluZHMgYW4gaXNzdWUuXG4qL1xuY2xhc3MgR2VuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmZ1bmN0aW9uIGhhc1Byb3BzKHByb3BzKSB7XG4gICAgZm9yIChsZXQgX3AgaW4gcHJvcHMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmxldCB0ZXJtSGFzaCA9IDA7XG5jbGFzcyBUZXJtIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBmbGFncywgbm9kZU5hbWUsIHByb3BzID0ge30pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5oYXNoID0gKyt0ZXJtSGFzaDsgLy8gVXNlZCBmb3Igc29ydGluZyBhbmQgaGFzaGluZyBkdXJpbmcgcGFyc2VyIGdlbmVyYXRpb25cbiAgICAgICAgdGhpcy5pZCA9IC0xOyAvLyBBc3NpZ25lZCBpbiBhIGxhdGVyIHN0YWdlLCB1c2VkIGluIGFjdHVhbCBvdXRwdXRcbiAgICAgICAgLy8gRmlsbGVkIGluIG9ubHkgYWZ0ZXIgdGhlIHJ1bGVzIGFyZSBzaW1wbGlmaWVkLCB1c2VkIGluIGF1dG9tYXRvbi50c1xuICAgICAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9XG4gICAgZ2V0IG5vZGVUeXBlKCkgeyByZXR1cm4gdGhpcy50b3AgfHwgdGhpcy5ub2RlTmFtZSAhPSBudWxsIHx8IGhhc1Byb3BzKHRoaXMucHJvcHMpIHx8IHRoaXMucmVwZWF0ZWQ7IH1cbiAgICBnZXQgdGVybWluYWwoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVGVybUZsYWcuVGVybWluYWwgKi8pID4gMDsgfVxuICAgIGdldCBlb2YoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogVGVybUZsYWcuRW9mICovKSA+IDA7IH1cbiAgICBnZXQgZXJyb3IoKSB7IHJldHVybiBcImVycm9yXCIgaW4gdGhpcy5wcm9wczsgfVxuICAgIGdldCB0b3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogVGVybUZsYWcuVG9wICovKSA+IDA7IH1cbiAgICBnZXQgaW50ZXJlc3RpbmcoKSB7IHJldHVybiB0aGlzLmZsYWdzID4gMCB8fCB0aGlzLm5vZGVOYW1lICE9IG51bGw7IH1cbiAgICBnZXQgcmVwZWF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDE2IC8qIFRlcm1GbGFnLlJlcGVhdGVkICovKSA+IDA7IH1cbiAgICBzZXQgcHJlc2VydmUodmFsdWUpIHsgdGhpcy5mbGFncyA9IHZhbHVlID8gdGhpcy5mbGFncyB8IDggLyogVGVybUZsYWcuUHJlc2VydmUgKi8gOiB0aGlzLmZsYWdzICYgfjggLyogVGVybUZsYWcuUHJlc2VydmUgKi87IH1cbiAgICBnZXQgcHJlc2VydmUoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogVGVybUZsYWcuUHJlc2VydmUgKi8pID4gMDsgfVxuICAgIHNldCBpbmxpbmUodmFsdWUpIHsgdGhpcy5mbGFncyA9IHZhbHVlID8gdGhpcy5mbGFncyB8IDMyIC8qIFRlcm1GbGFnLklubGluZSAqLyA6IHRoaXMuZmxhZ3MgJiB+MzIgLyogVGVybUZsYWcuSW5saW5lICovOyB9XG4gICAgZ2V0IGlubGluZSgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMzIgLyogVGVybUZsYWcuSW5saW5lICovKSA+IDA7IH1cbiAgICBjbXAob3RoZXIpIHsgcmV0dXJuIHRoaXMuaGFzaCAtIG90aGVyLmhhc2g7IH1cbn1cbmNsYXNzIFRlcm1TZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRlcm1zID0gW107XG4gICAgICAgIC8vIE1hcCBmcm9tIHRlcm0gbmFtZXMgdG8gVGVybSBpbnN0YW5jZXNcbiAgICAgICAgdGhpcy5uYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudG9wcyA9IFtdO1xuICAgICAgICB0aGlzLmVvZiA9IHRoaXMudGVybShcIuKQhFwiLCBudWxsLCAxIC8qIFRlcm1GbGFnLlRlcm1pbmFsICovIHwgNCAvKiBUZXJtRmxhZy5Fb2YgKi8pO1xuICAgICAgICB0aGlzLmVycm9yID0gdGhpcy50ZXJtKFwi4pqgXCIsIFwi4pqgXCIsIDggLyogVGVybUZsYWcuUHJlc2VydmUgKi8pO1xuICAgIH1cbiAgICB0ZXJtKG5hbWUsIG5vZGVOYW1lLCBmbGFncyA9IDAsIHByb3BzID0ge30pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBuZXcgVGVybShuYW1lLCBmbGFncywgbm9kZU5hbWUsIHByb3BzKTtcbiAgICAgICAgdGhpcy50ZXJtcy5wdXNoKHRlcm0pO1xuICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0gdGVybTtcbiAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgfVxuICAgIG1ha2VUb3Aobm9kZU5hbWUsIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHRlcm0gPSB0aGlzLnRlcm0oXCJAdG9wXCIsIG5vZGVOYW1lLCAyIC8qIFRlcm1GbGFnLlRvcCAqLywgcHJvcHMpO1xuICAgICAgICB0aGlzLnRvcHMucHVzaCh0ZXJtKTtcbiAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgfVxuICAgIG1ha2VUZXJtaW5hbChuYW1lLCBub2RlTmFtZSwgcHJvcHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtKG5hbWUsIG5vZGVOYW1lLCAxIC8qIFRlcm1GbGFnLlRlcm1pbmFsICovLCBwcm9wcyk7XG4gICAgfVxuICAgIG1ha2VOb25UZXJtaW5hbChuYW1lLCBub2RlTmFtZSwgcHJvcHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtKG5hbWUsIG5vZGVOYW1lLCAwLCBwcm9wcyk7XG4gICAgfVxuICAgIG1ha2VSZXBlYXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtKG5hbWUsIG51bGwsIDE2IC8qIFRlcm1GbGFnLlJlcGVhdGVkICovKTtcbiAgICB9XG4gICAgdW5pcXVlTmFtZShuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gaSA/IGAke25hbWV9LSR7aX1gIDogbmFtZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lc1tjdXJdKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKHJ1bGVzKSB7XG4gICAgICAgIGZvciAobGV0IHJ1bGUgb2YgcnVsZXMpXG4gICAgICAgICAgICBydWxlLm5hbWUucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy50ZXJtcyA9IHRoaXMudGVybXMuZmlsdGVyKHQgPT4gdC50ZXJtaW5hbCB8fCB0LnByZXNlcnZlIHx8IHJ1bGVzLnNvbWUociA9PiByLm5hbWUgPT0gdCB8fCByLnBhcnRzLmluY2x1ZGVzKHQpKSk7XG4gICAgICAgIGxldCBuYW1lcyA9IHt9O1xuICAgICAgICBsZXQgbm9kZVR5cGVzID0gW3RoaXMuZXJyb3JdO1xuICAgICAgICB0aGlzLmVycm9yLmlkID0gMCAvKiBULkVyciAqLztcbiAgICAgICAgbGV0IG5leHRJRCA9IDAgLyogVC5FcnIgKi8gKyAxO1xuICAgICAgICAvLyBBc3NpZ24gaWRzIHRvIHRlcm1zIHRoYXQgcmVwcmVzZW50IG5vZGUgdHlwZXNcbiAgICAgICAgZm9yIChsZXQgdGVybSBvZiB0aGlzLnRlcm1zKVxuICAgICAgICAgICAgaWYgKHRlcm0uaWQgPCAwICYmIHRlcm0ubm9kZVR5cGUgJiYgIXRlcm0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXJtLmlkID0gbmV4dElEKys7XG4gICAgICAgICAgICAgICAgbm9kZVR5cGVzLnB1c2godGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFB1dCBhbGwgcmVwZWF0ZWQgdGVybXMgYWZ0ZXIgdGhlIHJlZ3VsYXIgbm9kZSB0eXBlc1xuICAgICAgICBsZXQgbWluUmVwZWF0VGVybSA9IG5leHRJRDtcbiAgICAgICAgZm9yIChsZXQgdGVybSBvZiB0aGlzLnRlcm1zKVxuICAgICAgICAgICAgaWYgKHRlcm0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXJtLmlkID0gbmV4dElEKys7XG4gICAgICAgICAgICAgICAgbm9kZVR5cGVzLnB1c2godGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFRoZW4gY29tZXMgdGhlIEVPRiB0ZXJtXG4gICAgICAgIHRoaXMuZW9mLmlkID0gbmV4dElEKys7XG4gICAgICAgIC8vIEFuZCB0aGVuIHRoZSByZW1haW5pbmcgKG5vbi1ub2RlLCBub24tcmVwZWF0KSB0ZXJtcy5cbiAgICAgICAgZm9yIChsZXQgdGVybSBvZiB0aGlzLnRlcm1zKSB7XG4gICAgICAgICAgICBpZiAodGVybS5pZCA8IDApXG4gICAgICAgICAgICAgICAgdGVybS5pZCA9IG5leHRJRCsrO1xuICAgICAgICAgICAgaWYgKHRlcm0ubmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1t0ZXJtLmlkXSA9IHRlcm0ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dElEID49IDB4ZmZmZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5FcnJvcihcIlRvbyBtYW55IHRlcm1zXCIpO1xuICAgICAgICByZXR1cm4geyBub2RlVHlwZXMsIG5hbWVzLCBtaW5SZXBlYXRUZXJtLCBtYXhUZXJtOiBuZXh0SUQgLSAxIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY21wU2V0KGEsIGIsIGNtcCkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkaWZmID0gY21wKGFbaV0sIGJbaV0pO1xuICAgICAgICBpZiAoZGlmZilcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IG5vbmUkMyA9IFtdO1xuY2xhc3MgQ29uZmxpY3RzIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVjZWRlbmNlLCBhbWJpZ0dyb3VwcyA9IG5vbmUkMywgY3V0ID0gMCkge1xuICAgICAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICAgICAgICB0aGlzLmFtYmlnR3JvdXBzID0gYW1iaWdHcm91cHM7XG4gICAgICAgIHRoaXMuY3V0ID0gY3V0O1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09IENvbmZsaWN0cy5ub25lIHx8IHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGlmIChvdGhlciA9PSBDb25mbGljdHMubm9uZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZsaWN0cyhNYXRoLm1heCh0aGlzLnByZWNlZGVuY2UsIG90aGVyLnByZWNlZGVuY2UpLCB1bmlvbih0aGlzLmFtYmlnR3JvdXBzLCBvdGhlci5hbWJpZ0dyb3VwcyksIE1hdGgubWF4KHRoaXMuY3V0LCBvdGhlci5jdXQpKTtcbiAgICB9XG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2UgLSBvdGhlci5wcmVjZWRlbmNlIHx8IGNtcFNldCh0aGlzLmFtYmlnR3JvdXBzLCBvdGhlci5hbWJpZ0dyb3VwcywgKGEsIGIpID0+IGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwKSB8fFxuICAgICAgICAgICAgdGhpcy5jdXQgLSBvdGhlci5jdXQ7XG4gICAgfVxufVxuQ29uZmxpY3RzLm5vbmUgPSBuZXcgQ29uZmxpY3RzKDApO1xuZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA9PSAwIHx8IGEgPT0gYilcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKGIubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBhO1xuICAgIGxldCByZXN1bHQgPSBhLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgYilcbiAgICAgICAgaWYgKCFhLmluY2x1ZGVzKHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbn1cbmxldCBydWxlSUQgPSAwO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcGFydHMsIGNvbmZsaWN0cywgc2tpcCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHRoaXMuY29uZmxpY3RzID0gY29uZmxpY3RzO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLmlkID0gcnVsZUlEKys7XG4gICAgfVxuICAgIGNtcChydWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkIC0gcnVsZS5pZDtcbiAgICB9XG4gICAgY21wTm9OYW1lKHJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydHMubGVuZ3RoIC0gcnVsZS5wYXJ0cy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuc2tpcC5oYXNoIC0gcnVsZS5za2lwLmhhc2ggfHxcbiAgICAgICAgICAgIHRoaXMucGFydHMucmVkdWNlKChyLCBzLCBpKSA9PiByIHx8IHMuY21wKHJ1bGUucGFydHNbaV0pLCAwKSB8fFxuICAgICAgICAgICAgY21wU2V0KHRoaXMuY29uZmxpY3RzLCBydWxlLmNvbmZsaWN0cywgKGEsIGIpID0+IGEuY21wKGIpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIiAtPiBcIiArIHRoaXMucGFydHMuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGdldCBpc1JlcGVhdFdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUucmVwZWF0ZWQgJiYgdGhpcy5wYXJ0cy5sZW5ndGggPT0gMiAmJiB0aGlzLnBhcnRzWzBdID09IHRoaXMubmFtZTtcbiAgICB9XG4gICAgc2FtZVJlZHVjZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09IG90aGVyLm5hbWUgJiYgdGhpcy5wYXJ0cy5sZW5ndGggPT0gb3RoZXIucGFydHMubGVuZ3RoICYmIHRoaXMuaXNSZXBlYXRXcmFwID09IG90aGVyLmlzUmVwZWF0V3JhcDtcbiAgICB9XG59XG5cbmNvbnN0IE1BWF9DSEFSID0gMHhmZmZmO1xuY2xhc3MgRWRnZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHRhcmdldCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAtPiAke3RoaXMudGFyZ2V0LmlkfVtsYWJlbD0ke0pTT04uc3RyaW5naWZ5KHRoaXMuZnJvbSA8IDAgPyBcIs61XCIgOiBjaGFyRm9yKHRoaXMuZnJvbSkgK1xuICAgICAgICAgICAgKHRoaXMudG8gPiB0aGlzLmZyb20gKyAxID8gXCItXCIgKyBjaGFyRm9yKHRoaXMudG8gLSAxKSA6IFwiXCIpKX1dYDtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGFyRm9yKG4pIHtcbiAgICByZXR1cm4gbiA+IE1BWF9DSEFSID8gXCLiiJ5cIlxuICAgICAgICA6IG4gPT0gMTAgPyBcIlxcXFxuXCJcbiAgICAgICAgICAgIDogbiA9PSAxMyA/IFwiXFxcXHJcIlxuICAgICAgICAgICAgICAgIDogbiA8IDMyIHx8IG4gPj0gMHhkODAwICYmIG4gPCAweGRmZmYgPyBcIlxcXFx1e1wiICsgbi50b1N0cmluZygxNikgKyBcIn1cIlxuICAgICAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG59XG5mdW5jdGlvbiBtaW5pbWl6ZShzdGF0ZXMsIHN0YXJ0KSB7XG4gICAgbGV0IHBhcnRpdGlvbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGJ5QWNjZXB0aW5nID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICAgICAgbGV0IGlkID0gaWRzKHN0YXRlLmFjY2VwdGluZyk7XG4gICAgICAgIGxldCBncm91cCA9IGJ5QWNjZXB0aW5nW2lkXSB8fCAoYnlBY2NlcHRpbmdbaWRdID0gW10pO1xuICAgICAgICBncm91cC5wdXNoKHN0YXRlKTtcbiAgICAgICAgcGFydGl0aW9uW3N0YXRlLmlkXSA9IGdyb3VwO1xuICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBzcGxpdCA9IGZhbHNlLCBuZXdQYXJ0aXRpb24gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBzdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICAgICAgICAgIGlmIChuZXdQYXJ0aXRpb25bc3RhdGUuaWRdKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gcGFydGl0aW9uW3N0YXRlLmlkXTtcbiAgICAgICAgICAgIGlmIChncm91cC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIG5ld1BhcnRpdGlvbltncm91cFswXS5pZF0gPSBncm91cDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgZ3JvdXBzOiBmb3IgKGxldCBzdGF0ZSBvZiBncm91cCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXF1aXZhbGVudChzdGF0ZSwgcFswXSwgcGFydGl0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtzdGF0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwYXJ0cylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzIG9mIHApXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcnRpdGlvbltzLmlkXSA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcGxpdClcbiAgICAgICAgICAgIHJldHVybiBhcHBseU1pbmltaXphdGlvbihzdGF0ZXMsIHN0YXJ0LCBwYXJ0aXRpb24pO1xuICAgICAgICBwYXJ0aXRpb24gPSBuZXdQYXJ0aXRpb247XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFcXVpdmFsZW50KGEsIGIsIHBhcnRpdGlvbikge1xuICAgIGlmIChhLmVkZ2VzLmxlbmd0aCAhPSBiLmVkZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZUEgPSBhLmVkZ2VzW2ldLCBlQiA9IGIuZWRnZXNbaV07XG4gICAgICAgIGlmIChlQS5mcm9tICE9IGVCLmZyb20gfHwgZUEudG8gIT0gZUIudG8gfHwgcGFydGl0aW9uW2VBLnRhcmdldC5pZF0gIT0gcGFydGl0aW9uW2VCLnRhcmdldC5pZF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXBwbHlNaW5pbWl6YXRpb24oc3RhdGVzLCBzdGFydCwgcGFydGl0aW9uKSB7XG4gICAgZm9yIChsZXQgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlZGdlID0gc3RhdGUuZWRnZXNbaV0sIHRhcmdldCA9IHBhcnRpdGlvbltlZGdlLnRhcmdldC5pZF1bMF07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9IGVkZ2UudGFyZ2V0KVxuICAgICAgICAgICAgICAgIHN0YXRlLmVkZ2VzW2ldID0gbmV3IEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aXRpb25bc3RhcnQuaWRdWzBdO1xufVxubGV0IHN0YXRlSUQgPSAxO1xubGV0IFN0YXRlJDEgPSBjbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWNjZXB0aW5nID0gW10sIGlkID0gc3RhdGVJRCsrKSB7XG4gICAgICAgIHRoaXMuYWNjZXB0aW5nID0gYWNjZXB0aW5nO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZWRnZXMgPSBbXTtcbiAgICB9XG4gICAgZWRnZShmcm9tLCB0bywgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChuZXcgRWRnZShmcm9tLCB0bywgdGFyZ2V0KSk7XG4gICAgfVxuICAgIG51bGxFZGdlKHRhcmdldCkgeyB0aGlzLmVkZ2UoLTEsIC0xLCB0YXJnZXQpOyB9XG4gICAgY29tcGlsZSgpIHtcbiAgICAgICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBsb2NhbElEID0gMDtcbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSBleHBsb3JlKHRoaXMuY2xvc3VyZSgpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIHJldHVybiBtaW5pbWl6ZShPYmplY3QudmFsdWVzKGxhYmVsZWQpLCBzdGFydFN0YXRlKTtcbiAgICAgICAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZSA9IGxhYmVsZWRbaWRzKHN0YXRlcyldID1cbiAgICAgICAgICAgICAgICBuZXcgU3RhdGUoc3RhdGVzLnJlZHVjZSgoYSwgcykgPT4gdW5pb24oYSwgcy5hY2NlcHRpbmcpLCBbXSksIGxvY2FsSUQrKyk7XG4gICAgICAgICAgICBsZXQgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSBvZiBzdGF0ZXMpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZWRnZSBvZiBzdGF0ZS5lZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5mcm9tID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChlZGdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSBtZXJnZUVkZ2VzKG91dCk7XG4gICAgICAgICAgICBmb3IgKGxldCBtZXJnZWQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0cyA9IG1lcmdlZC50YXJnZXRzLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5lZGdlKG1lcmdlZC5mcm9tLCBtZXJnZWQudG8sIGxhYmVsZWRbaWRzKHRhcmdldHMpXSB8fCBleHBsb3JlKHRhcmdldHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zdXJlKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzdGF0ZS5pZF0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VlbltzdGF0ZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gU3RhdGVzIHdpdGggb25seSBlcHNpbG9uIGVkZ2VzIGFuZCBubyBhY2NlcHRpbmcgdGVybSB0aGF0XG4gICAgICAgICAgICAvLyBpc24ndCBhbHNvIGluIHRoZSBuZXh0IHN0YXRlcyBhcmUgbGVmdCBvdXQgdG8gaGVscCByZWR1Y2UgdGhlXG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgdW5pcXVlIHN0YXRlIGNvbWJpbmF0aW9uc1xuICAgICAgICAgICAgaWYgKHN0YXRlLmVkZ2VzLnNvbWUoZSA9PiBlLmZyb20gPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAoc3RhdGUuYWNjZXB0aW5nLmxlbmd0aCA+IDAgJiYgIXN0YXRlLmVkZ2VzLnNvbWUoZSA9PiBzYW1lU2V0JDEoc3RhdGUuYWNjZXB0aW5nLCBlLnRhcmdldC5hY2NlcHRpbmcpKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgZm9yIChsZXQgZWRnZSBvZiBzdGF0ZS5lZGdlcylcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5mcm9tIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShlZGdlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwbG9yZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmluZENvbmZsaWN0cyhvY2N1clRvZ2V0aGVyKSB7XG4gICAgICAgIGxldCBjb25mbGljdHMgPSBbXSwgY3ljbGVUZXJtcyA9IHRoaXMuY3ljbGVUZXJtcygpO1xuICAgICAgICBmdW5jdGlvbiBhZGQoYSwgYiwgc29mdCwgYUVkZ2VzLCBiRWRnZXMpIHtcbiAgICAgICAgICAgIGlmIChhLmlkIDwgYi5pZCkge1xuICAgICAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcbiAgICAgICAgICAgICAgICBzb2Z0ID0gLXNvZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjb25mbGljdHMuZmluZChjID0+IGMuYSA9PSBhICYmIGMuYiA9PSBiKTtcbiAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2gobmV3IENvbmZsaWN0JDEoYSwgYiwgc29mdCwgZXhhbXBsZUZyb21FZGdlcyhhRWRnZXMpLCBiRWRnZXMgJiYgZXhhbXBsZUZyb21FZGdlcyhiRWRnZXMpKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmb3VuZC5zb2Z0ICE9IHNvZnQpXG4gICAgICAgICAgICAgICAgZm91bmQuc29mdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFjaGFibGUoKHN0YXRlLCBlZGdlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjY2VwdGluZy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmFjY2VwdGluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBzdGF0ZS5hY2NlcHRpbmcubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGFkZChzdGF0ZS5hY2NlcHRpbmdbaV0sIHN0YXRlLmFjY2VwdGluZ1tqXSwgMCwgZWRnZXMpO1xuICAgICAgICAgICAgc3RhdGUucmVhY2hhYmxlKChzLCBlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzICE9IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ZXJtIG9mIHMuYWNjZXB0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ3ljbGUgPSBjeWNsZVRlcm1zLmluY2x1ZGVzKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb3JpZyBvZiBzdGF0ZS5hY2NlcHRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlcm0gIT0gb3JpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHRlcm0sIG9yaWcsIGhhc0N5Y2xlIHx8IGN5Y2xlVGVybXMuaW5jbHVkZXMob3JpZykgfHwgIW9jY3VyVG9nZXRoZXIodGVybSwgb3JpZykgPyAwIDogMSwgZWRnZXMsIGVkZ2VzLmNvbmNhdChlcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25mbGljdHM7XG4gICAgfVxuICAgIGN5Y2xlVGVybXMoKSB7XG4gICAgICAgIGxldCB3b3JrID0gW107XG4gICAgICAgIHRoaXMucmVhY2hhYmxlKHN0YXRlID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgdGFyZ2V0IH0gb2Ygc3RhdGUuZWRnZXMpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKHN0YXRlLCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRhYmxlID0gbmV3IE1hcDtcbiAgICAgICAgbGV0IGhhdmVDeWNsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmsubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSB3b3JrW2krK10sIHRvID0gd29ya1tpKytdO1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gdGFibGUuZ2V0KGZyb20pO1xuICAgICAgICAgICAgaWYgKCFlbnRyeSlcbiAgICAgICAgICAgICAgICB0YWJsZS5zZXQoZnJvbSwgZW50cnkgPSBbXSk7XG4gICAgICAgICAgICBpZiAoZW50cnkuaW5jbHVkZXModG8pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVDeWNsZS5pbmNsdWRlcyhmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgaGF2ZUN5Y2xlLnB1c2goZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuZXh0IG9mIGVudHJ5KVxuICAgICAgICAgICAgICAgICAgICB3b3JrLnB1c2goZnJvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgZW50cnkucHVzaCh0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBzdGF0ZSBvZiBoYXZlQ3ljbGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRlcm0gb2Ygc3RhdGUuYWNjZXB0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuaW5jbHVkZXModGVybSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlYWNoYWJsZShmKSB7XG4gICAgICAgIGxldCBzZWVuID0gW10sIGVkZ2VzID0gW107XG4gICAgICAgIChmdW5jdGlvbiBleHBsb3JlKHMpIHtcbiAgICAgICAgICAgIGYocywgZWRnZXMpO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZWRnZSBvZiBzLmVkZ2VzKVxuICAgICAgICAgICAgICAgIGlmICghc2Vlbi5pbmNsdWRlcyhlZGdlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSkodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgb3V0ID0gXCJkaWdyYXBoIHtcXG5cIjtcbiAgICAgICAgdGhpcy5yZWFjaGFibGUoc3RhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjY2VwdGluZy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgb3V0ICs9IGAgICR7c3RhdGUuaWR9IFtsYWJlbD0ke0pTT04uc3RyaW5naWZ5KHN0YXRlLmFjY2VwdGluZy5qb2luKCkpfV07XFxuYDtcbiAgICAgICAgICAgIGZvciAobGV0IGVkZ2Ugb2Ygc3RhdGUuZWRnZXMpXG4gICAgICAgICAgICAgICAgb3V0ICs9IGAgICR7c3RhdGUuaWR9ICR7ZWRnZX07XFxuYDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXQgKyBcIn1cIjtcbiAgICB9XG4gICAgLy8gVG9rZW5pemVyIGRhdGEgaXMgcmVwcmVzZW50ZWQgYXMgYSBzaW5nbGUgZmxhdCBhcnJheS4gVGhpc1xuICAgIC8vIGNvbnRhaW5zIHJlZ2lvbnMgZm9yIGVhY2ggdG9rZW5pemVyIHN0YXRlLiBSZWdpb24gb2Zmc2V0cyBhcmVcbiAgICAvLyB1c2VkIHRvIGlkZW50aWZ5IHN0YXRlcy5cbiAgICAvL1xuICAgIC8vIEVhY2ggc3RhdGUgaXMgbGFpZCBvdXQgYXM6XG4gICAgLy8gIC0gVG9rZW4gZ3JvdXAgbWFza1xuICAgIC8vICAtIE9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhY2NlcHRpbmcgZGF0YVxuICAgIC8vICAtIE51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBpbiB0aGUgc3RhdGVcbiAgICAvLyAgLSBQYWlycyBvZiB0b2tlbiBtYXNrcyBhbmQgdGVybSBpZHMgdGhhdCBpbmRpY2F0ZSB0aGUgYWNjZXB0aW5nXG4gICAgLy8gICAgc3RhdGVzLCBzb3J0ZWQgYnkgcHJlY2VkZW5jZVxuICAgIC8vICAtIFRyaXBsZXMgZm9yIHRoZSBlZGdlczogZWFjaCB3aXRoIGEgbG93IGFuZCBoaWdoIGJvdW5kIGFuZCB0aGVcbiAgICAvLyAgICBvZmZzZXQgb2YgdGhlIG5leHQgc3RhdGUuXG4gICAgdG9BcnJheShncm91cE1hc2tzLCBwcmVjZWRlbmNlKSB7XG4gICAgICAgIGxldCBvZmZzZXRzID0gW107IC8vIFVzZWQgdG8gJ2xpbmsnIHRoZSBzdGF0ZXMgYWZ0ZXIgYnVpbGRpbmcgdGhlIGFycmF5c1xuICAgICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlYWNoYWJsZShzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBhY2NlcHRFbmQgPSBzdGFydCArIDMgKyBzdGF0ZS5hY2NlcHRpbmcubGVuZ3RoICogMjtcbiAgICAgICAgICAgIG9mZnNldHNbc3RhdGUuaWRdID0gc3RhcnQ7XG4gICAgICAgICAgICBkYXRhLnB1c2goc3RhdGUuc3RhdGVNYXNrKGdyb3VwTWFza3MpLCBhY2NlcHRFbmQsIHN0YXRlLmVkZ2VzLmxlbmd0aCk7XG4gICAgICAgICAgICBzdGF0ZS5hY2NlcHRpbmcuc29ydCgoYSwgYikgPT4gcHJlY2VkZW5jZS5pbmRleE9mKGEuaWQpIC0gcHJlY2VkZW5jZS5pbmRleE9mKGIuaWQpKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRlcm0gb2Ygc3RhdGUuYWNjZXB0aW5nKVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh0ZXJtLmlkLCBncm91cE1hc2tzW3Rlcm0uaWRdIHx8IDB4ZmZmZik7XG4gICAgICAgICAgICBmb3IgKGxldCBlZGdlIG9mIHN0YXRlLmVkZ2VzKVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChlZGdlLmZyb20sIGVkZ2UudG8sIC1lZGdlLnRhcmdldC5pZCAtIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVwbGFjZSBuZWdhdGl2ZSBudW1iZXJzIHdpdGggcmVzb2x2ZWQgc3RhdGUgb2Zmc2V0c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoZGF0YVtpXSA8IDApXG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IG9mZnNldHNbLWRhdGFbaV0gLSAxXTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gTWF0aC5wb3coMiwgMTYpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbkVycm9yKFwiVG9rZW5pemVyIHRhYmxlcyB0b28gYmlnIHRvIHJlcHJlc2VudCB3aXRoIDE2LWJpdCBvZmZzZXRzLlwiKTtcbiAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5LmZyb20oZGF0YSk7XG4gICAgfVxuICAgIHN0YXRlTWFzayhncm91cE1hc2tzKSB7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgdGhpcy5yZWFjaGFibGUoc3RhdGUgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgdGVybSBvZiBzdGF0ZS5hY2NlcHRpbmcpXG4gICAgICAgICAgICAgICAgbWFzayB8PSAoZ3JvdXBNYXNrc1t0ZXJtLmlkXSB8fCAweGZmZmYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxufTtcbmxldCBDb25mbGljdCQxID0gY2xhc3MgQ29uZmxpY3Qge1xuICAgIGNvbnN0cnVjdG9yKGEsIGIsIFxuICAgIC8vIENvbmZsaWN0cyBiZXR3ZWVuIHR3byBub24tY3ljbGljIHRva2VucyBhcmUgbWFya2VkIGFzXG4gICAgLy8gJ3NvZnQnLCB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlmIGEgaXMgc2hvcnRlciB0aGFuXG4gICAgLy8gYiwgYW5kIGEgcG9zaXRpdmUgaWYgYiBpcyBzaG9ydGVyIHRoYW4gYS5cbiAgICBzb2Z0LCBleGFtcGxlQSwgZXhhbXBsZUIpIHtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5zb2Z0ID0gc29mdDtcbiAgICAgICAgdGhpcy5leGFtcGxlQSA9IGV4YW1wbGVBO1xuICAgICAgICB0aGlzLmV4YW1wbGVCID0gZXhhbXBsZUI7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGV4YW1wbGVGcm9tRWRnZXMoZWRnZXMpIHtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlZGdlc1tpXS5mcm9tKTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gaWRzKGVsdHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBlbHQgb2YgZWx0cykge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcbiAgICAgICAgcmVzdWx0ICs9IGVsdC5pZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNhbWVTZXQkMShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgTWVyZ2VkRWRnZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHRhcmdldHMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgIH1cbn1cbi8vIE1lcmdlIG11bHRpcGxlIGVkZ2VzICh0YWdnZWQgYnkgY2hhcmFjdGVyIHJhbmdlcykgaW50byBhIHNldCBvZlxuLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHJhbmdlcyBwb2ludGluZyBhdCBhbGwgdGFyZ2V0IHN0YXRlcyBmb3IgdGhhdFxuLy8gcmFuZ2VcbmZ1bmN0aW9uIG1lcmdlRWRnZXMoZWRnZXMpIHtcbiAgICBsZXQgc2VwYXJhdGUgPSBbXSwgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBpZiAoIXNlcGFyYXRlLmluY2x1ZGVzKGVkZ2UuZnJvbSkpXG4gICAgICAgICAgICBzZXBhcmF0ZS5wdXNoKGVkZ2UuZnJvbSk7XG4gICAgICAgIGlmICghc2VwYXJhdGUuaW5jbHVkZXMoZWRnZS50bykpXG4gICAgICAgICAgICBzZXBhcmF0ZS5wdXNoKGVkZ2UudG8pO1xuICAgIH1cbiAgICBzZXBhcmF0ZS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZXBhcmF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZnJvbSA9IHNlcGFyYXRlW2kgLSAxXSwgdG8gPSBzZXBhcmF0ZVtpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGVkZ2Ugb2YgZWRnZXMpXG4gICAgICAgICAgICBpZiAoZWRnZS50byA+IGZyb20gJiYgZWRnZS5mcm9tIDwgdG8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0YXJnZXQgb2YgZWRnZS50YXJnZXQuY2xvc3VyZSgpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmluY2x1ZGVzKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgTWVyZ2VkRWRnZShmcm9tLCB0bywgZm91bmQpKTtcbiAgICB9XG4gICAgbGV0IGVvZiA9IGVkZ2VzLmZpbHRlcihlID0+IGUuZnJvbSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmIGUudG8gPT0gNjU1MzUgLyogU2VxLkVuZCAqLyk7XG4gICAgaWYgKGVvZi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGVkZ2Ugb2YgZW9mKVxuICAgICAgICAgICAgZm9yIChsZXQgdGFyZ2V0IG9mIGVkZ2UudGFyZ2V0LmNsb3N1cmUoKSlcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmluY2x1ZGVzKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2godGFyZ2V0KTtcbiAgICAgICAgaWYgKGZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBNZXJnZWRFZGdlKDY1NTM1IC8qIFNlcS5FbmQgKi8sIDY1NTM1IC8qIFNlcS5FbmQgKi8sIGZvdW5kKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIE5vdGUgdGhhdCB0aGlzIGlzIHRoZSBwYXJzZXIgZm9yIGdyYW1tYXIgZmlsZXMsIG5vdCB0aGUgZ2VuZXJhdGVkIHBhcnNlclxubGV0IHdvcmQgPSAvW1xcd18tXSsvZ3k7XG4vLyBTb21lIGVuZ2luZXMgKHNwZWNpZmljYWxseSBTcGlkZXJNb25rZXkpIGhhdmUgc3RpbGwgbm90IGltcGxlbWVudGVkIFxccFxudHJ5IHtcbiAgICB3b3JkID0gL1tcXHB7QWxwaGFiZXRpY31cXGRfLV0rL3VneTtcbn1cbmNhdGNoIChfKSB7IH1cbmNvbnN0IG5vbmUkMiA9IFtdO1xuY2xhc3MgSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgZmlsZU5hbWUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic29mXCI7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5lbmQgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbGluZUluZm8ocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdHJpbmcuaW5kZXhPZihcIlxcblwiLCBjdXIpO1xuICAgICAgICAgICAgaWYgKG5leHQgPiAtMSAmJiBuZXh0IDwgcG9zKSB7XG4gICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5leHQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZSwgY2g6IHBvcyAtIGN1ciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1lc3NhZ2UobXNnLCBwb3MgPSAtMSkge1xuICAgICAgICBsZXQgcG9zSW5mbyA9IHRoaXMuZmlsZU5hbWUgfHwgXCJcIjtcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMubGluZUluZm8ocG9zKTtcbiAgICAgICAgICAgIHBvc0luZm8gKz0gKHBvc0luZm8gPyBcIiBcIiA6IFwiXCIpICsgaW5mby5saW5lICsgXCI6XCIgKyBpbmZvLmNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NJbmZvID8gbXNnICsgYCAoJHtwb3NJbmZvfSlgIDogbXNnO1xuICAgIH1cbiAgICByYWlzZShtc2csIHBvcyA9IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBHZW5FcnJvcih0aGlzLm1lc3NhZ2UobXNnLCBwb3MpKTtcbiAgICB9XG4gICAgbWF0Y2gocG9zLCByZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSByZS5leGVjKHRoaXMuc3RyaW5nLnNsaWNlKHBvcykpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBwb3MgKyBtYXRjaFswXS5sZW5ndGggOiAtMTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5tYXRjaCh0aGlzLmVuZCwgL14oXFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChcImVvZlwiLCBudWxsLCBzdGFydCwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RyaW5nW3N0YXJ0XTtcbiAgICAgICAgaWYgKG5leHQgPT0gJ1wiJykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMubWF0Y2goc3RhcnQgKyAxLCAvXihcXFxcLnxbXlwiXFxcXF0pKlwiLyk7XG4gICAgICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGxpdGVyYWxcIiwgc3RhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KFwic3RyaW5nXCIsIHJlYWRTdHJpbmcodGhpcy5zdHJpbmcuc2xpY2Uoc3RhcnQgKyAxLCBlbmQgLSAxKSksIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5leHQgPT0gXCInXCIpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLm1hdGNoKHN0YXJ0ICsgMSwgL14oXFxcXC58W14nXFxcXF0pKicvKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT0gLTEpXG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZShcIlVudGVybWluYXRlZCBzdHJpbmcgbGl0ZXJhbFwiLCBzdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoXCJzdHJpbmdcIiwgcmVhZFN0cmluZyh0aGlzLnN0cmluZy5zbGljZShzdGFydCArIDEsIGVuZCAtIDEpKSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV4dCA9PSBcIkBcIikge1xuICAgICAgICAgICAgd29yZC5sYXN0SW5kZXggPSBzdGFydCArIDE7XG4gICAgICAgICAgICBsZXQgbSA9IHdvcmQuZXhlYyh0aGlzLnN0cmluZyk7XG4gICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFpc2UoXCJAIHdpdGhvdXQgYSBuYW1lXCIsIHN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChcImF0XCIsIG1bMF0sIHN0YXJ0LCBzdGFydCArIDEgKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG5leHQgPT0gXCIkXCIgfHwgbmV4dCA9PSBcIiFcIikgJiYgdGhpcy5zdHJpbmdbc3RhcnQgKyAxXSA9PSBcIltcIikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMubWF0Y2goc3RhcnQgKyAyLCAvXig/OlxcXFwufFteXFxdXFxcXF0pKlxcXS8pO1xuICAgICAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBzZXRcIiwgc3RhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KFwic2V0XCIsIHRoaXMuc3RyaW5nLnNsaWNlKHN0YXJ0ICsgMiwgZW5kIC0gMSksIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9bXFxbXFxdKCkhfisqP3t9PD5cXC4sfDokPV0vLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChuZXh0LCBudWxsLCBzdGFydCwgc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdvcmQubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICBsZXQgbSA9IHdvcmQuZXhlYyh0aGlzLnN0cmluZyk7XG4gICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFpc2UoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBcIiArIEpTT04uc3RyaW5naWZ5KG5leHQpLCBzdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoXCJpZFwiLCBtWzBdLCBzdGFydCwgc3RhcnQgKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHR5cGUsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgZWF0KHR5cGUsIHZhbHVlID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IHR5cGUgJiYgKHZhbHVlID09IG51bGwgfHwgdGhpcy52YWx1ZSA9PT0gdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZXhwZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhaXNlKGBVbmV4cGVjdGVkIHRva2VuICcke3RoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKX0nYCwgdGhpcy5zdGFydCk7XG4gICAgfVxuICAgIGV4cGVjdCh0eXBlLCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT0gdHlwZSB8fCAhKHZhbHVlID09IG51bGwgfHwgdmFsID09PSB2YWx1ZSkpXG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHBhcnNlKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VHcmFtbWFyKHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR3JhbW1hcihpbnB1dCkge1xuICAgIGxldCBzdGFydCA9IGlucHV0LnN0YXJ0O1xuICAgIGxldCBydWxlcyA9IFtdO1xuICAgIGxldCBwcmVjID0gbnVsbDtcbiAgICBsZXQgdG9rZW5zID0gbnVsbDtcbiAgICBsZXQgbG9jYWxUb2tlbnMgPSBbXTtcbiAgICBsZXQgbWFpblNraXAgPSBudWxsO1xuICAgIGxldCBzY29wZWRTa2lwID0gW107XG4gICAgbGV0IGRpYWxlY3RzID0gW107XG4gICAgbGV0IGNvbnRleHQgPSBudWxsO1xuICAgIGxldCBleHRlcm5hbCA9IFtdO1xuICAgIGxldCBzcGVjaWFsaXplZCA9IFtdO1xuICAgIGxldCBwcm9wcyA9IFtdO1xuICAgIGxldCBwcm9wU291cmNlcyA9IFtdO1xuICAgIGxldCB0b3BzID0gW107XG4gICAgbGV0IHNhd1RvcCA9IGZhbHNlO1xuICAgIGxldCBhdXRvRGVsaW0gPSBmYWxzZTtcbiAgICB3aGlsZSAoaW5wdXQudHlwZSAhPSBcImVvZlwiKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGlucHV0LnN0YXJ0O1xuICAgICAgICBpZiAoaW5wdXQuZWF0KFwiYXRcIiwgXCJ0b3BcIikpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlICE9IFwiaWRcIilcbiAgICAgICAgICAgICAgICBpbnB1dC5yYWlzZShgVG9wIHJ1bGVzIG11c3QgaGF2ZSBhIG5hbWVgLCBpbnB1dC5zdGFydCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocGFyc2VSdWxlKGlucHV0LCBwYXJzZUlkZW50KGlucHV0KSkpO1xuICAgICAgICAgICAgc2F3VG9wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC50eXBlID09IFwiYXRcIiAmJiBpbnB1dC52YWx1ZSA9PSBcInRva2Vuc1wiKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5zKVxuICAgICAgICAgICAgICAgIGlucHV0LnJhaXNlKGBNdWx0aXBsZSBAdG9rZW5zIGRlY2xhcmFjdGlvbnNgLCBpbnB1dC5zdGFydCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdG9rZW5zID0gcGFyc2VUb2tlbnMoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LmVhdChcImF0XCIsIFwibG9jYWxcIikpIHtcbiAgICAgICAgICAgIGlucHV0LmV4cGVjdChcImlkXCIsIFwidG9rZW5zXCIpO1xuICAgICAgICAgICAgbG9jYWxUb2tlbnMucHVzaChwYXJzZUxvY2FsVG9rZW5zKGlucHV0LCBzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LmVhdChcImF0XCIsIFwiY29udGV4dFwiKSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgaW5wdXQucmFpc2UoYE11bHRpcGxlIEBjb250ZXh0IGRlY2xhcmF0aW9uc2AsIHN0YXJ0KTtcbiAgICAgICAgICAgIGxldCBpZCA9IHBhcnNlSWRlbnQoaW5wdXQpO1xuICAgICAgICAgICAgaW5wdXQuZXhwZWN0KFwiaWRcIiwgXCJmcm9tXCIpO1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IGlucHV0LmV4cGVjdChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dERlY2xhcmF0aW9uKHN0YXJ0LCBpZCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCJhdFwiLCBcImV4dGVybmFsXCIpKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZWF0KFwiaWRcIiwgXCJ0b2tlbnNcIikpXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWwucHVzaChwYXJzZUV4dGVybmFsVG9rZW5zKGlucHV0LCBzdGFydCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQuZWF0KFwiaWRcIiwgXCJwcm9wXCIpKVxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2gocGFyc2VFeHRlcm5hbFByb3AoaW5wdXQsIHN0YXJ0KSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCJpZFwiLCBcImV4dGVuZFwiKSlcbiAgICAgICAgICAgICAgICBzcGVjaWFsaXplZC5wdXNoKHBhcnNlRXh0ZXJuYWxTcGVjaWFsaXplKGlucHV0LCBcImV4dGVuZFwiLCBzdGFydCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQuZWF0KFwiaWRcIiwgXCJzcGVjaWFsaXplXCIpKVxuICAgICAgICAgICAgICAgIHNwZWNpYWxpemVkLnB1c2gocGFyc2VFeHRlcm5hbFNwZWNpYWxpemUoaW5wdXQsIFwic3BlY2lhbGl6ZVwiLCBzdGFydCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQuZWF0KFwiaWRcIiwgXCJwcm9wU291cmNlXCIpKVxuICAgICAgICAgICAgICAgIHByb3BTb3VyY2VzLnB1c2gocGFyc2VFeHRlcm5hbFByb3BTb3VyY2UoaW5wdXQsIHN0YXJ0KSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5wdXQudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LmVhdChcImF0XCIsIFwiZGlhbGVjdHNcIikpIHtcbiAgICAgICAgICAgIGlucHV0LmV4cGVjdChcIntcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBmaXJzdCA9IHRydWU7ICFpbnB1dC5lYXQoXCJ9XCIpOyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuZWF0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICBkaWFsZWN0cy5wdXNoKHBhcnNlSWRlbnQoaW5wdXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC50eXBlID09IFwiYXRcIiAmJiBpbnB1dC52YWx1ZSA9PSBcInByZWNlZGVuY2VcIikge1xuICAgICAgICAgICAgaWYgKHByZWMpXG4gICAgICAgICAgICAgICAgaW5wdXQucmFpc2UoYE11bHRpcGxlIHByZWNlZGVuY2UgZGVjbGFyYXRpb25zYCwgaW5wdXQuc3RhcnQpO1xuICAgICAgICAgICAgcHJlYyA9IHBhcnNlUHJlY2VkZW5jZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQuZWF0KFwiYXRcIiwgXCJkZXRlY3REZWxpbVwiKSkge1xuICAgICAgICAgICAgYXV0b0RlbGltID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCJhdFwiLCBcInNraXBcIikpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gcGFyc2VCcmFjZWRFeHByKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IFtdLCB0b3BSdWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICghaW5wdXQuZWF0KFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZWF0KFwiYXRcIiwgXCJ0b3BcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcFJ1bGVzLnB1c2gocGFyc2VSdWxlKGlucHV0LCBwYXJzZUlkZW50KGlucHV0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2F3VG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2gocGFyc2VSdWxlKGlucHV0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGVkU2tpcC5wdXNoKHsgZXhwcjogc2tpcCwgdG9wUnVsZXMsIHJ1bGVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1haW5Ta2lwKVxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yYWlzZShgTXVsdGlwbGUgdG9wLWxldmVsIHNraXAgZGVjbGFyYXRpb25zYCwgaW5wdXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIG1haW5Ta2lwID0gc2tpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVzLnB1c2gocGFyc2VSdWxlKGlucHV0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzYXdUb3ApXG4gICAgICAgIHJldHVybiBpbnB1dC5yYWlzZShgTWlzc2luZyBAdG9wIGRlY2xhcmF0aW9uYCk7XG4gICAgcmV0dXJuIG5ldyBHcmFtbWFyRGVjbGFyYXRpb24oc3RhcnQsIHJ1bGVzLCB0b3BzLCB0b2tlbnMsIGxvY2FsVG9rZW5zLCBjb250ZXh0LCBleHRlcm5hbCwgc3BlY2lhbGl6ZWQsIHByb3BTb3VyY2VzLCBwcmVjLCBtYWluU2tpcCwgc2NvcGVkU2tpcCwgZGlhbGVjdHMsIHByb3BzLCBhdXRvRGVsaW0pO1xufVxuZnVuY3Rpb24gcGFyc2VSdWxlKGlucHV0LCBuYW1lZCkge1xuICAgIGxldCBzdGFydCA9IG5hbWVkID8gbmFtZWQuc3RhcnQgOiBpbnB1dC5zdGFydDtcbiAgICBsZXQgaWQgPSBuYW1lZCB8fCBwYXJzZUlkZW50KGlucHV0KTtcbiAgICBsZXQgcHJvcHMgPSBwYXJzZVByb3BzKGlucHV0KTtcbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgaWYgKGlucHV0LmVhdChcIjxcIikpXG4gICAgICAgIHdoaWxlICghaW5wdXQuZWF0KFwiPlwiKSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaW5wdXQuZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlSWRlbnQoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgIGxldCBleHByID0gcGFyc2VCcmFjZWRFeHByKGlucHV0KTtcbiAgICByZXR1cm4gbmV3IFJ1bGVEZWNsYXJhdGlvbihzdGFydCwgaWQsIHByb3BzLCBwYXJhbXMsIGV4cHIpO1xufVxuZnVuY3Rpb24gcGFyc2VQcm9wcyhpbnB1dCkge1xuICAgIGlmIChpbnB1dC50eXBlICE9IFwiW1wiKVxuICAgICAgICByZXR1cm4gbm9uZSQyO1xuICAgIGxldCBwcm9wcyA9IFtdO1xuICAgIGlucHV0LmV4cGVjdChcIltcIik7XG4gICAgd2hpbGUgKCFpbnB1dC5lYXQoXCJdXCIpKSB7XG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICBpbnB1dC5leHBlY3QoXCIsXCIpO1xuICAgICAgICBwcm9wcy5wdXNoKHBhcnNlUHJvcChpbnB1dCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBwYXJzZVByb3AoaW5wdXQpIHtcbiAgICBsZXQgc3RhcnQgPSBpbnB1dC5zdGFydCwgdmFsdWUgPSBbXSwgbmFtZSA9IGlucHV0LnZhbHVlLCBhdCA9IGlucHV0LnR5cGUgPT0gXCJhdFwiO1xuICAgIGlmICghaW5wdXQuZWF0KFwiYXRcIikgJiYgIWlucHV0LmVhdChcImlkXCIpKVxuICAgICAgICBpbnB1dC51bmV4cGVjdGVkKCk7XG4gICAgaWYgKGlucHV0LmVhdChcIj1cIikpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlID09IFwic3RyaW5nXCIgfHwgaW5wdXQudHlwZSA9PSBcImlkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKG5ldyBQcm9wUGFydChpbnB1dC5zdGFydCwgaW5wdXQudmFsdWUsIG51bGwpKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChuZXcgUHJvcFBhcnQoaW5wdXQuc3RhcnQsIFwiLlwiLCBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCJ7XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChuZXcgUHJvcFBhcnQoaW5wdXQuc3RhcnQsIG51bGwsIGlucHV0LmV4cGVjdChcImlkXCIpKSk7XG4gICAgICAgICAgICAgICAgaW5wdXQuZXhwZWN0KFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9wKHN0YXJ0LCBhdCwgbmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2VCcmFjZWRFeHByKGlucHV0KSB7XG4gICAgaW5wdXQuZXhwZWN0KFwie1wiKTtcbiAgICBsZXQgZXhwciA9IHBhcnNlRXhwckNob2ljZShpbnB1dCk7XG4gICAgaW5wdXQuZXhwZWN0KFwifVwiKTtcbiAgICByZXR1cm4gZXhwcjtcbn1cbmNvbnN0IFNFVF9NQVJLRVIgPSBcIlxcdWZkZGFcIjsgLy8gKEludmFsaWQgdW5pY29kZSBjaGFyYWN0ZXIpXG5mdW5jdGlvbiBwYXJzZUV4cHJJbm5lcihpbnB1dCkge1xuICAgIGxldCBzdGFydCA9IGlucHV0LnN0YXJ0O1xuICAgIGlmIChpbnB1dC5lYXQoXCIoXCIpKSB7XG4gICAgICAgIGlmIChpbnB1dC5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUV4cHJlc3Npb24oc3RhcnQsIG5vbmUkMiwgW25vbmUkMiwgbm9uZSQyXSk7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByQ2hvaWNlKGlucHV0KTtcbiAgICAgICAgaW5wdXQuZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LnR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlRXhwcmVzc2lvbihzdGFydCwgbm9uZSQyLCBbbm9uZSQyLCBub25lJDJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihzdGFydCwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCJpZFwiLCBcIl9cIikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbnlFeHByZXNzaW9uKHN0YXJ0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5wdXQudmFsdWUsIGludmVydCA9IGlucHV0LnN0cmluZ1tpbnB1dC5zdGFydF0gPT0gXCIhXCI7XG4gICAgICAgIGxldCB1bmVzY2FwZWQgPSByZWFkU3RyaW5nKGNvbnRlbnQucmVwbGFjZSgvXFxcXC58LXxcIi9nLCAobSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG0gPT0gXCItXCIgPyBTRVRfTUFSS0VSIDogbSA9PSAnXCInID8gJ1xcXFxcIicgOiBtO1xuICAgICAgICB9KSk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgdW5lc2NhcGVkLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBjb2RlID0gdW5lc2NhcGVkLmNvZGVQb2ludEF0KHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gY29kZSA+IDB4ZmZmZiA/IDIgOiAxO1xuICAgICAgICAgICAgaWYgKHBvcyA8IHVuZXNjYXBlZC5sZW5ndGggLSAxICYmIHVuZXNjYXBlZFtwb3NdID09IFNFVF9NQVJLRVIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gdW5lc2NhcGVkLmNvZGVQb2ludEF0KHBvcyArIDEpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBlbmQgPiAweGZmZmYgPyAzIDogMjtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgY29kZSlcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciByYW5nZVwiLCBpbnB1dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgYWRkUmFuZ2UoaW5wdXQsIHJhbmdlcywgY29kZSwgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSBTRVRfTUFSS0VSLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSA0NTtcbiAgICAgICAgICAgICAgICBhZGRSYW5nZShpbnB1dCwgcmFuZ2VzLCBjb2RlLCBjb2RlICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICByZXR1cm4gbmV3IFNldEV4cHJlc3Npb24oc3RhcnQsIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSksIGludmVydCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LnR5cGUgPT0gXCJhdFwiICYmIChpbnB1dC52YWx1ZSA9PSBcInNwZWNpYWxpemVcIiB8fCBpbnB1dC52YWx1ZSA9PSBcImV4dGVuZFwiKSkge1xuICAgICAgICBsZXQgeyBzdGFydCwgdmFsdWUgfSA9IGlucHV0O1xuICAgICAgICBpbnB1dC5uZXh0KCk7XG4gICAgICAgIGxldCBwcm9wcyA9IHBhcnNlUHJvcHMoaW5wdXQpO1xuICAgICAgICBpbnB1dC5leHBlY3QoXCI8XCIpO1xuICAgICAgICBsZXQgdG9rZW4gPSBwYXJzZUV4cHJDaG9pY2UoaW5wdXQpLCBjb250ZW50O1xuICAgICAgICBpZiAoaW5wdXQuZWF0KFwiLFwiKSkge1xuICAgICAgICAgICAgY29udGVudCA9IHBhcnNlRXhwckNob2ljZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4gaW5zdGFuY2VvZiBMaXRlcmFsRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgY29udGVudCA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQucmFpc2UoYEAke3ZhbHVlfSByZXF1aXJlcyB0d28gYXJndW1lbnRzIHdoZW4gaXRzIGZpcnN0IGFyZ3VtZW50IGlzbid0IGEgbGl0ZXJhbCBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5leHBlY3QoXCI+XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNwZWNpYWxpemVFeHByZXNzaW9uKHN0YXJ0LCB2YWx1ZSwgcHJvcHMsIHRva2VuLCBjb250ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQudHlwZSA9PSBcImF0XCIgJiYgQ2hhckNsYXNzZXMuaGFzT3duUHJvcGVydHkoaW5wdXQudmFsdWUpKSB7XG4gICAgICAgIGxldCBjbHMgPSBuZXcgQ2hhckNsYXNzKGlucHV0LnN0YXJ0LCBpbnB1dC52YWx1ZSk7XG4gICAgICAgIGlucHV0Lm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGNscztcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQudHlwZSA9PSBcIltcIikge1xuICAgICAgICBsZXQgcnVsZSA9IHBhcnNlUnVsZShpbnB1dCwgbmV3IElkZW50aWZpZXIoc3RhcnQsIFwiX2Fub25cIikpO1xuICAgICAgICBpZiAocnVsZS5wYXJhbXMubGVuZ3RoKVxuICAgICAgICAgICAgaW5wdXQucmFpc2UoYElubGluZSBydWxlcyBjYW4ndCBoYXZlIHBhcmFtZXRlcnNgLCBydWxlLnN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVSdWxlRXhwcmVzc2lvbihzdGFydCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgaWQgPSBwYXJzZUlkZW50KGlucHV0KTtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUgPT0gXCJbXCIgfHwgaW5wdXQudHlwZSA9PSBcIntcIikge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSBwYXJzZVJ1bGUoaW5wdXQsIGlkKTtcbiAgICAgICAgICAgIGlmIChydWxlLnBhcmFtcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaW5wdXQucmFpc2UoYElubGluZSBydWxlcyBjYW4ndCBoYXZlIHBhcmFtZXRlcnNgLCBydWxlLnN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lUnVsZUV4cHJlc3Npb24oc3RhcnQsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlucHV0LmVhdChcIi5cIikgJiYgaWQubmFtZSA9PSBcInN0ZFwiICYmIENoYXJDbGFzc2VzLmhhc093blByb3BlcnR5KGlucHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBuZXcgQ2hhckNsYXNzKHN0YXJ0LCBpbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaW5wdXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hbWVFeHByZXNzaW9uKHN0YXJ0LCBpZCwgcGFyc2VBcmdzKGlucHV0KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUFyZ3MoaW5wdXQpIHtcbiAgICBsZXQgYXJncyA9IFtdO1xuICAgIGlmIChpbnB1dC5lYXQoXCI8XCIpKVxuICAgICAgICB3aGlsZSAoIWlucHV0LmVhdChcIj5cIikpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpbnB1dC5leHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlRXhwckNob2ljZShpbnB1dCkpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShpbnB1dCwgcmFuZ2VzLCBmcm9tLCB0bykge1xuICAgIGlmICghcmFuZ2VzLmV2ZXJ5KChbYSwgYl0pID0+IGIgPD0gZnJvbSB8fCBhID49IHRvKSlcbiAgICAgICAgaW5wdXQucmFpc2UoXCJPdmVybGFwcGluZyBjaGFyYWN0ZXIgcmFuZ2VcIiwgaW5wdXQuc3RhcnQpO1xuICAgIHJhbmdlcy5wdXNoKFtmcm9tLCB0b10pO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3VmZml4KGlucHV0KSB7XG4gICAgbGV0IHN0YXJ0ID0gaW5wdXQuc3RhcnQ7XG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJJbm5lcihpbnB1dCk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQga2luZCA9IGlucHV0LnR5cGU7XG4gICAgICAgIGlmIChpbnB1dC5lYXQoXCIqXCIpIHx8IGlucHV0LmVhdChcIj9cIikgfHwgaW5wdXQuZWF0KFwiK1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgUmVwZWF0RXhwcmVzc2lvbihzdGFydCwgZXhwciwga2luZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuZE9mU2VxdWVuY2UoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQudHlwZSA9PSBcIn1cIiB8fCBpbnB1dC50eXBlID09IFwiKVwiIHx8IGlucHV0LnR5cGUgPT0gXCJ8XCIgfHwgaW5wdXQudHlwZSA9PSBcIi9cIiB8fFxuICAgICAgICBpbnB1dC50eXBlID09IFwiL1xcXFxcIiB8fCBpbnB1dC50eXBlID09IFwie1wiIHx8IGlucHV0LnR5cGUgPT0gXCIsXCIgfHwgaW5wdXQudHlwZSA9PSBcIj5cIjtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcXVlbmNlKGlucHV0KSB7XG4gICAgbGV0IHN0YXJ0ID0gaW5wdXQuc3RhcnQsIGV4cHJzID0gW10sIG1hcmtlcnMgPSBbbm9uZSQyXTtcbiAgICBkbyB7XG4gICAgICAgIC8vIEFkZCBtYXJrZXJzIGF0IHRoaXMgcG9zaXRpb25cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhcnQgPSBpbnB1dC5zdGFydCwgbWFya2VyVHlwZTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5lYXQoXCJ+XCIpKVxuICAgICAgICAgICAgICAgIG1hcmtlclR5cGUgPSBcImFtYmlnXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5lYXQoXCIhXCIpKVxuICAgICAgICAgICAgICAgIG1hcmtlclR5cGUgPSBcInByZWNcIjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSA9XG4gICAgICAgICAgICAgICAgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdLmNvbmNhdChuZXcgQ29uZmxpY3RNYXJrZXIobG9jYWxTdGFydCwgcGFyc2VJZGVudChpbnB1dCksIG1hcmtlclR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kT2ZTZXF1ZW5jZShpbnB1dCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWZmaXgoaW5wdXQpKTtcbiAgICAgICAgbWFya2Vycy5wdXNoKG5vbmUkMik7XG4gICAgfSB3aGlsZSAoIWVuZE9mU2VxdWVuY2UoaW5wdXQpKTtcbiAgICBpZiAoZXhwcnMubGVuZ3RoID09IDEgJiYgbWFya2Vycy5ldmVyeShtcyA9PiBtcy5sZW5ndGggPT0gMCkpXG4gICAgICAgIHJldHVybiBleHByc1swXTtcbiAgICByZXR1cm4gbmV3IFNlcXVlbmNlRXhwcmVzc2lvbihzdGFydCwgZXhwcnMsIG1hcmtlcnMsICFleHBycy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQ2hvaWNlKGlucHV0KSB7XG4gICAgbGV0IHN0YXJ0ID0gaW5wdXQuc3RhcnQsIGxlZnQgPSBwYXJzZUV4cHJTZXF1ZW5jZShpbnB1dCk7XG4gICAgaWYgKCFpbnB1dC5lYXQoXCJ8XCIpKVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICBsZXQgZXhwcnMgPSBbbGVmdF07XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcXVlbmNlKGlucHV0KSk7XG4gICAgfSB3aGlsZSAoaW5wdXQuZWF0KFwifFwiKSk7XG4gICAgbGV0IGVtcHR5ID0gZXhwcnMuZmluZChzID0+IHMgaW5zdGFuY2VvZiBTZXF1ZW5jZUV4cHJlc3Npb24gJiYgcy5lbXB0eSk7XG4gICAgaWYgKGVtcHR5KVxuICAgICAgICBpbnB1dC5yYWlzZShcIkVtcHR5IGV4cHJlc3Npb24gaW4gY2hvaWNlIG9wZXJhdG9yLiBJZiB0aGlzIGlzIGludGVudGlvbmFsLCB1c2UgKCkgdG8gbWFrZSBpdCBleHBsaWNpdC5cIiwgZW1wdHkuc3RhcnQpO1xuICAgIHJldHVybiBuZXcgQ2hvaWNlRXhwcmVzc2lvbihzdGFydCwgZXhwcnMpO1xufVxuZnVuY3Rpb24gcGFyc2VJZGVudChpbnB1dCkge1xuICAgIGlmIChpbnB1dC50eXBlICE9IFwiaWRcIilcbiAgICAgICAgaW5wdXQudW5leHBlY3RlZCgpO1xuICAgIGxldCBzdGFydCA9IGlucHV0LnN0YXJ0LCBuYW1lID0gaW5wdXQudmFsdWU7XG4gICAgaW5wdXQubmV4dCgpO1xuICAgIHJldHVybiBuZXcgSWRlbnRpZmllcihzdGFydCwgbmFtZSk7XG59XG5mdW5jdGlvbiBwYXJzZVByZWNlZGVuY2UoaW5wdXQpIHtcbiAgICBsZXQgc3RhcnQgPSBpbnB1dC5zdGFydDtcbiAgICBpbnB1dC5uZXh0KCk7XG4gICAgaW5wdXQuZXhwZWN0KFwie1wiKTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICB3aGlsZSAoIWlucHV0LmVhdChcIn1cIikpIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aClcbiAgICAgICAgICAgIGlucHV0LmVhdChcIixcIik7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHBhcnNlSWRlbnQoaW5wdXQpLFxuICAgICAgICAgICAgdHlwZTogaW5wdXQuZWF0KFwiYXRcIiwgXCJsZWZ0XCIpID8gXCJsZWZ0XCIgOiBpbnB1dC5lYXQoXCJhdFwiLCBcInJpZ2h0XCIpID8gXCJyaWdodFwiIDogaW5wdXQuZWF0KFwiYXRcIiwgXCJjdXRcIikgPyBcImN1dFwiIDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcmVjRGVjbGFyYXRpb24oc3RhcnQsIGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKGlucHV0KSB7XG4gICAgbGV0IHN0YXJ0ID0gaW5wdXQuc3RhcnQ7XG4gICAgaW5wdXQubmV4dCgpO1xuICAgIGlucHV0LmV4cGVjdChcIntcIik7XG4gICAgbGV0IHRva2VuUnVsZXMgPSBbXTtcbiAgICBsZXQgbGl0ZXJhbHMgPSBbXTtcbiAgICBsZXQgcHJlY2VkZW5jZXMgPSBbXTtcbiAgICBsZXQgY29uZmxpY3RzID0gW107XG4gICAgd2hpbGUgKCFpbnB1dC5lYXQoXCJ9XCIpKSB7XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09IFwiYXRcIiAmJiBpbnB1dC52YWx1ZSA9PSBcInByZWNlZGVuY2VcIikge1xuICAgICAgICAgICAgcHJlY2VkZW5jZXMucHVzaChwYXJzZVRva2VuUHJlY2VkZW5jZShpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnR5cGUgPT0gXCJhdFwiICYmIGlucHV0LnZhbHVlID09IFwiY29uZmxpY3RcIikge1xuICAgICAgICAgICAgY29uZmxpY3RzLnB1c2gocGFyc2VUb2tlbkNvbmZsaWN0KGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQudHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsaXRlcmFscy5wdXNoKG5ldyBMaXRlcmFsRGVjbGFyYXRpb24oaW5wdXQuc3RhcnQsIGlucHV0LmV4cGVjdChcInN0cmluZ1wiKSwgcGFyc2VQcm9wcyhpbnB1dCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuUnVsZXMucHVzaChwYXJzZVJ1bGUoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuRGVjbGFyYXRpb24oc3RhcnQsIHByZWNlZGVuY2VzLCBjb25mbGljdHMsIHRva2VuUnVsZXMsIGxpdGVyYWxzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9jYWxUb2tlbnMoaW5wdXQsIHN0YXJ0KSB7XG4gICAgaW5wdXQuZXhwZWN0KFwie1wiKTtcbiAgICBsZXQgdG9rZW5SdWxlcyA9IFtdO1xuICAgIGxldCBwcmVjZWRlbmNlcyA9IFtdO1xuICAgIGxldCBmYWxsYmFjayA9IG51bGw7XG4gICAgd2hpbGUgKCFpbnB1dC5lYXQoXCJ9XCIpKSB7XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09IFwiYXRcIiAmJiBpbnB1dC52YWx1ZSA9PSBcInByZWNlZGVuY2VcIikge1xuICAgICAgICAgICAgcHJlY2VkZW5jZXMucHVzaChwYXJzZVRva2VuUHJlY2VkZW5jZShpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LmVhdChcImF0XCIsIFwiZWxzZVwiKSAmJiAhZmFsbGJhY2spIHtcbiAgICAgICAgICAgIGZhbGxiYWNrID0geyBpZDogcGFyc2VJZGVudChpbnB1dCksIHByb3BzOiBwYXJzZVByb3BzKGlucHV0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5SdWxlcy5wdXNoKHBhcnNlUnVsZShpbnB1dCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9jYWxUb2tlbkRlY2xhcmF0aW9uKHN0YXJ0LCBwcmVjZWRlbmNlcywgdG9rZW5SdWxlcywgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24gcGFyc2VUb2tlblByZWNlZGVuY2UoaW5wdXQpIHtcbiAgICBsZXQgc3RhcnQgPSBpbnB1dC5zdGFydDtcbiAgICBpbnB1dC5uZXh0KCk7XG4gICAgaW5wdXQuZXhwZWN0KFwie1wiKTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgd2hpbGUgKCFpbnB1dC5lYXQoXCJ9XCIpKSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKVxuICAgICAgICAgICAgaW5wdXQuZWF0KFwiLFwiKTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJJbm5lcihpbnB1dCk7XG4gICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24gfHwgZXhwciBpbnN0YW5jZW9mIE5hbWVFeHByZXNzaW9uKVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goZXhwcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlucHV0LnJhaXNlKGBJbnZhbGlkIGV4cHJlc3Npb24gaW4gdG9rZW4gcHJlY2VkZW5jZXNgLCBleHByLnN0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlblByZWNEZWNsYXJhdGlvbihzdGFydCwgdG9rZW5zKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9rZW5Db25mbGljdChpbnB1dCkge1xuICAgIGxldCBzdGFydCA9IGlucHV0LnN0YXJ0O1xuICAgIGlucHV0Lm5leHQoKTtcbiAgICBpbnB1dC5leHBlY3QoXCJ7XCIpO1xuICAgIGxldCBhID0gcGFyc2VFeHBySW5uZXIoaW5wdXQpO1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBMaXRlcmFsRXhwcmVzc2lvbiB8fCBhIGluc3RhbmNlb2YgTmFtZUV4cHJlc3Npb24pKVxuICAgICAgICBpbnB1dC5yYWlzZShgSW52YWxpZCBleHByZXNzaW9uIGluIHRva2VuIGNvbmZsaWN0YCwgYS5zdGFydCk7XG4gICAgaW5wdXQuZWF0KFwiLFwiKTtcbiAgICBsZXQgYiA9IHBhcnNlRXhwcklubmVyKGlucHV0KTtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24gfHwgYiBpbnN0YW5jZW9mIE5hbWVFeHByZXNzaW9uKSlcbiAgICAgICAgaW5wdXQucmFpc2UoYEludmFsaWQgZXhwcmVzc2lvbiBpbiB0b2tlbiBjb25mbGljdGAsIGIuc3RhcnQpO1xuICAgIGlucHV0LmV4cGVjdChcIn1cIik7XG4gICAgcmV0dXJuIG5ldyBUb2tlbkNvbmZsaWN0RGVjbGFyYXRpb24oc3RhcnQsIGEsIGIpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFRva2VuU2V0KGlucHV0KSB7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGlucHV0LmV4cGVjdChcIntcIik7XG4gICAgd2hpbGUgKCFpbnB1dC5lYXQoXCJ9XCIpKSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKVxuICAgICAgICAgICAgaW5wdXQuZWF0KFwiLFwiKTtcbiAgICAgICAgbGV0IGlkID0gcGFyc2VJZGVudChpbnB1dCk7XG4gICAgICAgIGxldCBwcm9wcyA9IHBhcnNlUHJvcHMoaW5wdXQpO1xuICAgICAgICB0b2tlbnMucHVzaCh7IGlkLCBwcm9wcyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIHBhcnNlRXh0ZXJuYWxUb2tlbnMoaW5wdXQsIHN0YXJ0KSB7XG4gICAgbGV0IGlkID0gcGFyc2VJZGVudChpbnB1dCk7XG4gICAgaW5wdXQuZXhwZWN0KFwiaWRcIiwgXCJmcm9tXCIpO1xuICAgIGxldCBmcm9tID0gaW5wdXQuZXhwZWN0KFwic3RyaW5nXCIpO1xuICAgIHJldHVybiBuZXcgRXh0ZXJuYWxUb2tlbkRlY2xhcmF0aW9uKHN0YXJ0LCBpZCwgZnJvbSwgcGFyc2VFeHRlcm5hbFRva2VuU2V0KGlucHV0KSk7XG59XG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsU3BlY2lhbGl6ZShpbnB1dCwgdHlwZSwgc3RhcnQpIHtcbiAgICBsZXQgdG9rZW4gPSBwYXJzZUJyYWNlZEV4cHIoaW5wdXQpO1xuICAgIGxldCBpZCA9IHBhcnNlSWRlbnQoaW5wdXQpO1xuICAgIGlucHV0LmV4cGVjdChcImlkXCIsIFwiZnJvbVwiKTtcbiAgICBsZXQgZnJvbSA9IGlucHV0LmV4cGVjdChcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gbmV3IEV4dGVybmFsU3BlY2lhbGl6ZURlY2xhcmF0aW9uKHN0YXJ0LCB0eXBlLCB0b2tlbiwgaWQsIGZyb20sIHBhcnNlRXh0ZXJuYWxUb2tlblNldChpbnB1dCkpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFByb3BTb3VyY2UoaW5wdXQsIHN0YXJ0KSB7XG4gICAgbGV0IGlkID0gcGFyc2VJZGVudChpbnB1dCk7XG4gICAgaW5wdXQuZXhwZWN0KFwiaWRcIiwgXCJmcm9tXCIpO1xuICAgIHJldHVybiBuZXcgRXh0ZXJuYWxQcm9wU291cmNlRGVjbGFyYXRpb24oc3RhcnQsIGlkLCBpbnB1dC5leHBlY3QoXCJzdHJpbmdcIikpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFByb3AoaW5wdXQsIHN0YXJ0KSB7XG4gICAgbGV0IGV4dGVybmFsSUQgPSBwYXJzZUlkZW50KGlucHV0KTtcbiAgICBsZXQgaWQgPSBpbnB1dC5lYXQoXCJpZFwiLCBcImFzXCIpID8gcGFyc2VJZGVudChpbnB1dCkgOiBleHRlcm5hbElEO1xuICAgIGlucHV0LmV4cGVjdChcImlkXCIsIFwiZnJvbVwiKTtcbiAgICBsZXQgZnJvbSA9IGlucHV0LmV4cGVjdChcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gbmV3IEV4dGVybmFsUHJvcERlY2xhcmF0aW9uKHN0YXJ0LCBpZCwgZXh0ZXJuYWxJRCwgZnJvbSk7XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nKHN0cmluZykge1xuICAgIGxldCBwb2ludCA9IC9cXFxcKD86dVxceyhbXFxkYS1mXSspXFx9fHUoW1xcZGEtZl17NH0pfHgoW1xcZGEtZl17Mn0pfChbbnRicmYwXSl8KC4pKXxbXl0veWlnO1xuICAgIGxldCBvdXQgPSBcIlwiLCBtO1xuICAgIHdoaWxlIChtID0gcG9pbnQuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIGxldCBbYWxsLCB1MSwgdTIsIHUzLCBzaW5nbGUsIHVua25vd25dID0gbTtcbiAgICAgICAgaWYgKHUxIHx8IHUyIHx8IHUzKVxuICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHUxIHx8IHUyIHx8IHUzLCAxNikpO1xuICAgICAgICBlbHNlIGlmIChzaW5nbGUpXG4gICAgICAgICAgICBvdXQgKz0gc2luZ2xlID09IFwiblwiID8gXCJcXG5cIiA6IHNpbmdsZSA9PSBcInRcIiA/IFwiXFx0XCIgOiBzaW5nbGUgPT0gXCIwXCIgPyBcIlxcMFwiIDogc2luZ2xlID09IFwiclwiID8gXCJcXHJcIiA6IHNpbmdsZSA9PSBcImZcIiA/IFwiXFxmXCIgOiBcIlxcYlwiO1xuICAgICAgICBlbHNlIGlmICh1bmtub3duKVxuICAgICAgICAgICAgb3V0ICs9IHVua25vd247XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG91dCArPSBhbGw7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGhhc2goYSwgYikgeyByZXR1cm4gKGEgPDwgNSkgKyBhICsgYjsgfVxuZnVuY3Rpb24gaGFzaFN0cmluZyhoLCBzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKVxuICAgICAgICBoID0gaGFzaChoLCBzLmNoYXJDb2RlQXQoaSkpO1xuICAgIHJldHVybiBoO1xufVxuXG5jb25zdCB2ZXJib3NlID0gKHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTE9HKSB8fCBcIlwiO1xuY29uc3QgdGltaW5nID0gL1xcYnRpbWVcXGIvLnRlc3QodmVyYm9zZSk7XG5jb25zdCB0aW1lID0gdGltaW5nID8gKGxhYmVsLCBmKSA9PiB7XG4gICAgbGV0IHQwID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgcmVzdWx0ID0gZigpO1xuICAgIGNvbnNvbGUubG9nKGAke2xhYmVsfSAoJHsoKERhdGUubm93KCkgLSB0MCkgLyAxMDAwKS50b0ZpeGVkKDIpfXMpYCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0gOiAoX2xhYmVsLCBmKSA9PiBmKCk7XG5cbmNsYXNzIFBvcyB7XG4gICAgY29uc3RydWN0b3IocnVsZSwgcG9zLCBcbiAgICAvLyBOT1RFIGBhaGVhZGAgYW5kIGBhbWJpZ0FoZWFkYCBhcmVuJ3QgbXV0YXRlZCBhbnltb3JlIGFmdGVyIGBmaW5pc2goKWAgaGFzIGJlZW4gY2FsbGVkXG4gICAgYWhlYWQsIGFtYmlnQWhlYWQsIHNraXBBaGVhZCwgdmlhKSB7XG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmFoZWFkID0gYWhlYWQ7XG4gICAgICAgIHRoaXMuYW1iaWdBaGVhZCA9IGFtYmlnQWhlYWQ7XG4gICAgICAgIHRoaXMuc2tpcEFoZWFkID0gc2tpcEFoZWFkO1xuICAgICAgICB0aGlzLnZpYSA9IHZpYTtcbiAgICAgICAgdGhpcy5oYXNoID0gMDtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgaCA9IGhhc2goaGFzaCh0aGlzLnJ1bGUuaWQsIHRoaXMucG9zKSwgdGhpcy5za2lwQWhlYWQuaGFzaCk7XG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5haGVhZClcbiAgICAgICAgICAgIGggPSBoYXNoKGgsIGEuaGFzaCk7XG4gICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHRoaXMuYW1iaWdBaGVhZClcbiAgICAgICAgICAgIGggPSBoYXNoU3RyaW5nKGgsIGdyb3VwKTtcbiAgICAgICAgdGhpcy5oYXNoID0gaDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPCB0aGlzLnJ1bGUucGFydHMubGVuZ3RoID8gdGhpcy5ydWxlLnBhcnRzW3RoaXMucG9zXSA6IG51bGw7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zKHRoaXMucnVsZSwgdGhpcy5wb3MgKyAxLCB0aGlzLmFoZWFkLCB0aGlzLmFtYmlnQWhlYWQsIHRoaXMuc2tpcEFoZWFkLCB0aGlzLnZpYSkuZmluaXNoKCk7XG4gICAgfVxuICAgIGdldCBza2lwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5ydWxlLnBhcnRzLmxlbmd0aCA/IHRoaXMuc2tpcEFoZWFkIDogdGhpcy5ydWxlLnNraXA7XG4gICAgfVxuICAgIGNtcChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZS5jbXAocG9zLnJ1bGUpIHx8IHRoaXMucG9zIC0gcG9zLnBvcyB8fCB0aGlzLnNraXBBaGVhZC5oYXNoIC0gcG9zLnNraXBBaGVhZC5oYXNoIHx8XG4gICAgICAgICAgICBjbXBTZXQodGhpcy5haGVhZCwgcG9zLmFoZWFkLCAoYSwgYikgPT4gYS5jbXAoYikpIHx8IGNtcFNldCh0aGlzLmFtYmlnQWhlYWQsIHBvcy5hbWJpZ0FoZWFkLCBjbXBTdHIpO1xuICAgIH1cbiAgICBlcVNpbXBsZShwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcy5ydWxlID09IHRoaXMucnVsZSAmJiBwb3MucG9zID09IHRoaXMucG9zO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5ydWxlLnBhcnRzLm1hcCh0ID0+IHQubmFtZSk7XG4gICAgICAgIHBhcnRzLnNwbGljZSh0aGlzLnBvcywgMCwgXCLCt1wiKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucnVsZS5uYW1lfSAtPiAke3BhcnRzLmpvaW4oXCIgXCIpfWA7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICB0aGlzLmhhc2ggPT0gb3RoZXIuaGFzaCAmJiB0aGlzLnJ1bGUgPT0gb3RoZXIucnVsZSAmJiB0aGlzLnBvcyA9PSBvdGhlci5wb3MgJiYgdGhpcy5za2lwQWhlYWQgPT0gb3RoZXIuc2tpcEFoZWFkICYmXG4gICAgICAgICAgICAgICAgc2FtZVNldCh0aGlzLmFoZWFkLCBvdGhlci5haGVhZCkgJiZcbiAgICAgICAgICAgICAgICBzYW1lU2V0KHRoaXMuYW1iaWdBaGVhZCwgb3RoZXIuYW1iaWdBaGVhZCk7XG4gICAgfVxuICAgIHRyYWlsKG1heExlbiA9IDYwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpczsgcG9zOyBwb3MgPSBwb3MudmlhKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcG9zLnBvcyAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvcy5ydWxlLnBhcnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWUgPSByZXN1bHQucmV2ZXJzZSgpLmpvaW4oXCIgXCIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gbWF4TGVuKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBtYXhMZW4pLnJlcGxhY2UoLy4qPyAvLCBcIuKApiBcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uZmxpY3RzKHBvcyA9IHRoaXMucG9zKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJ1bGUuY29uZmxpY3RzW3Bvc107XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5ydWxlLnBhcnRzLmxlbmd0aCAmJiB0aGlzLmFtYmlnQWhlYWQubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmpvaW4obmV3IENvbmZsaWN0cygwLCB0aGlzLmFtYmlnQWhlYWQpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGFkZE9yaWdpbnMoZ3JvdXAsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdyb3VwLnNsaWNlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgIGlmIChuZXh0LnBvcyA9PSAwKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubmV4dCA9PSBuZXh0LnJ1bGUubmFtZSAmJiAhcmVzdWx0LmluY2x1ZGVzKHBvcykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmZsaWN0c0F0KGdyb3VwKSB7XG4gICAgbGV0IHJlc3VsdCA9IENvbmZsaWN0cy5ub25lO1xuICAgIGZvciAobGV0IHBvcyBvZiBncm91cClcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmpvaW4ocG9zLmNvbmZsaWN0cygpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbGllcyBhdXRvbWF0aWMgYWN0aW9uIHByZWNlZGVuY2UgYmFzZWQgb24gcmVwZWF0IHByb2R1Y3Rpb25zLlxuLy8gVGhlc2UgYXJlIGxlZnQtYXNzb2NpYXRpdmUsIHNvIHJlZHVjaW5nIHRoZSBgUiAtPiBSIFJgIHJ1bGUgaGFzXG4vLyBoaWdoZXIgcHJlY2VkZW5jZS5cbmZ1bmN0aW9uIGNvbXBhcmVSZXBlYXRQcmVjKGEsIGIpIHtcbiAgICBmb3IgKGxldCBwb3Mgb2YgYSlcbiAgICAgICAgaWYgKHBvcy5ydWxlLm5hbWUucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBvc0Igb2YgYilcbiAgICAgICAgICAgICAgICBpZiAocG9zQi5ydWxlLm5hbWUgPT0gcG9zLnJ1bGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLnJ1bGUuaXNSZXBlYXRXcmFwICYmIHBvcy5wb3MgPT0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zQi5ydWxlLmlzUmVwZWF0V3JhcCAmJiBwb3NCLnBvcyA9PSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY21wU3RyKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5mdW5jdGlvbiB0ZXJtc0FoZWFkKHJ1bGUsIHBvcywgYWZ0ZXIsIGZpcnN0KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IHBvcyArIDE7IGkgPCBydWxlLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gcnVsZS5wYXJ0c1tpXSwgY29udCA9IGZhbHNlO1xuICAgICAgICBpZiAobmV4dC50ZXJtaW5hbCkge1xuICAgICAgICAgICAgYWRkVG8obmV4dCwgZm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IHRlcm0gb2YgZmlyc3RbbmV4dC5uYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXJtID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYWRkVG8odGVybSwgZm91bmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnQpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGZvciAobGV0IGEgb2YgYWZ0ZXIpXG4gICAgICAgIGFkZFRvKGEsIGZvdW5kKTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBlcVNldChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzYW1lU2V0KGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBTaGlmdCB7XG4gICAgY29uc3RydWN0b3IodGVybSwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGVybSA9IHRlcm07XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBTaGlmdCAmJiB0aGlzLnRlcm0gPT0gb3RoZXIudGVybSAmJiBvdGhlci50YXJnZXQuaWQgPT0gdGhpcy50YXJnZXQuaWQ7IH1cbiAgICBjbXAob3RoZXIpIHsgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVkdWNlID8gLTEgOiB0aGlzLnRlcm0uaWQgLSBvdGhlci50ZXJtLmlkIHx8IHRoaXMudGFyZ2V0LmlkIC0gb3RoZXIudGFyZ2V0LmlkOyB9XG4gICAgbWF0Y2hlcyhvdGhlciwgbWFwcGluZykge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBTaGlmdCAmJiBtYXBwaW5nW290aGVyLnRhcmdldC5pZF0gPT0gbWFwcGluZ1t0aGlzLnRhcmdldC5pZF07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCJzXCIgKyB0aGlzLnRhcmdldC5pZDsgfVxuICAgIG1hcChtYXBwaW5nLCBzdGF0ZXMpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IHN0YXRlc1ttYXBwaW5nW3RoaXMudGFyZ2V0LmlkXV07XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT0gdGhpcy50YXJnZXQgPyB0aGlzIDogbmV3IFNoaWZ0KHRoaXMudGVybSwgbWFwcGVkKTtcbiAgICB9XG59XG5jbGFzcyBSZWR1Y2Uge1xuICAgIGNvbnN0cnVjdG9yKHRlcm0sIHJ1bGUpIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGVybTtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVkdWNlICYmIHRoaXMudGVybSA9PSBvdGhlci50ZXJtICYmIG90aGVyLnJ1bGUuc2FtZVJlZHVjZSh0aGlzLnJ1bGUpO1xuICAgIH1cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgU2hpZnQgPyAxIDogdGhpcy50ZXJtLmlkIC0gb3RoZXIudGVybS5pZCB8fCB0aGlzLnJ1bGUubmFtZS5pZCAtIG90aGVyLnJ1bGUubmFtZS5pZCB8fFxuICAgICAgICAgICAgdGhpcy5ydWxlLnBhcnRzLmxlbmd0aCAtIG90aGVyLnJ1bGUucGFydHMubGVuZ3RoO1xuICAgIH1cbiAgICBtYXRjaGVzKG90aGVyLCBtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJlZHVjZSAmJiBvdGhlci5ydWxlLnNhbWVSZWR1Y2UodGhpcy5ydWxlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgJHt0aGlzLnJ1bGUubmFtZS5uYW1lfSgke3RoaXMucnVsZS5wYXJ0cy5sZW5ndGh9KWA7IH1cbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9XG59XG5mdW5jdGlvbiBoYXNoUG9zaXRpb25zKHNldCkge1xuICAgIGxldCBoID0gNTM4MTtcbiAgICBmb3IgKGxldCBwb3Mgb2Ygc2V0KVxuICAgICAgICBoID0gaGFzaChoLCBwb3MuaGFzaCk7XG4gICAgcmV0dXJuIGg7XG59XG5jbGFzcyBDb25mbGljdENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGZpcnN0KSB7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBmaXJzdDtcbiAgICAgICAgdGhpcy5jb25mbGljdHMgPSBbXTtcbiAgICB9XG59XG5jbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIHNldCwgZmxhZ3MgPSAwLCBza2lwLCBoYXNoID0gaGFzaFBvc2l0aW9ucyhzZXQpLCBzdGFydFJ1bGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICAgICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGlvblBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmdvdG8gPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbkdyb3VwID0gLTE7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlZHVjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FjdGlvbnNCeVRlcm0gPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLmFjdGlvbnMubWFwKHQgPT4gdC50ZXJtICsgXCI9XCIgKyB0KS5qb2luKFwiLFwiKSArXG4gICAgICAgICAgICAodGhpcy5nb3RvLmxlbmd0aCA/IFwiIHwgXCIgKyB0aGlzLmdvdG8ubWFwKGcgPT4gZy50ZXJtICsgXCI9XCIgKyBnKS5qb2luKFwiLFwiKSA6IFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArIFwiOiBcIiArIHRoaXMuc2V0LmZpbHRlcihwID0+IHAucG9zID4gMCkuam9pbigpICtcbiAgICAgICAgICAgICh0aGlzLmRlZmF1bHRSZWR1Y2UgPyBgXFxuICBhbHdheXMgJHt0aGlzLmRlZmF1bHRSZWR1Y2UubmFtZX0oJHt0aGlzLmRlZmF1bHRSZWR1Y2UucGFydHMubGVuZ3RofSlgXG4gICAgICAgICAgICAgICAgOiBhY3Rpb25zLmxlbmd0aCA/IFwiXFxuICBcIiArIGFjdGlvbnMgOiBcIlwiKTtcbiAgICB9XG4gICAgYWRkQWN0aW9uSW5uZXIodmFsdWUsIHBvc2l0aW9ucykge1xuICAgICAgICBjaGVjazogZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnRlcm0gPT0gdmFsdWUudGVybSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24uZXEodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZnVsbFBvcyA9IFBvcy5hZGRPcmlnaW5zKHBvc2l0aW9ucywgdGhpcy5zZXQpLCBhY3Rpb25GdWxsUG9zID0gUG9zLmFkZE9yaWdpbnModGhpcy5hY3Rpb25Qb3NpdGlvbnNbaV0sIHRoaXMuc2V0KTtcbiAgICAgICAgICAgICAgICBsZXQgY29uZmxpY3RzID0gY29uZmxpY3RzQXQoZnVsbFBvcyksIGFjdGlvbkNvbmZsaWN0cyA9IGNvbmZsaWN0c0F0KGFjdGlvbkZ1bGxQb3MpO1xuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gY29tcGFyZVJlcGVhdFByZWMoZnVsbFBvcywgYWN0aW9uRnVsbFBvcykgfHwgY29uZmxpY3RzLnByZWNlZGVuY2UgLSBhY3Rpb25Db25mbGljdHMucHJlY2VkZW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDApIHsgLy8gRHJvcCB0aGUgZXhpc3RpbmcgYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUG9zaXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBjaGVjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlmZiA8IDApIHsgLy8gRHJvcCB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmxpY3RzLmFtYmlnR3JvdXBzLnNvbWUoZyA9PiBhY3Rpb25Db25mbGljdHMuYW1iaWdHcm91cHMuaW5jbHVkZXMoZykpKSB7IC8vIEV4cGxpY2l0bHkgYWxsb3dlZCBhbWJpZ3VpdHlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgY2hlY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBOb3QgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2godmFsdWUpO1xuICAgICAgICB0aGlzLmFjdGlvblBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhZGRBY3Rpb24odmFsdWUsIHBvc2l0aW9ucywgY29udGV4dCkge1xuICAgICAgICBsZXQgY29uZmxpY3QgPSB0aGlzLmFkZEFjdGlvbklubmVyKHZhbHVlLCBwb3NpdGlvbnMpO1xuICAgICAgICBpZiAoY29uZmxpY3QpIHtcbiAgICAgICAgICAgIGxldCBjb25mbGljdFBvcyA9IHRoaXMuYWN0aW9uUG9zaXRpb25zW3RoaXMuYWN0aW9ucy5pbmRleE9mKGNvbmZsaWN0KV1bMF07XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBbcG9zaXRpb25zWzBdLnJ1bGUubmFtZSwgY29uZmxpY3RQb3MucnVsZS5uYW1lXTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmNvbmZsaWN0cy5zb21lKGMgPT4gYy5ydWxlcy5zb21lKHIgPT4gcnVsZXMuaW5jbHVkZXMocikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICBpZiAoY29uZmxpY3QgaW5zdGFuY2VvZiBTaGlmdClcbiAgICAgICAgICAgICAgICBlcnJvciA9IGBzaGlmdC9yZWR1Y2UgY29uZmxpY3QgYmV0d2VlblxcbiAgJHtjb25mbGljdFBvc31cXG5hbmRcXG4gICR7cG9zaXRpb25zWzBdLnJ1bGV9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlcnJvciA9IGByZWR1Y2UvcmVkdWNlIGNvbmZsaWN0IGJldHdlZW5cXG4gICR7Y29uZmxpY3RQb3MucnVsZX1cXG5hbmRcXG4gICR7cG9zaXRpb25zWzBdLnJ1bGV9YDtcbiAgICAgICAgICAgIGVycm9yICs9IGBcXG5XaXRoIGlucHV0OlxcbiAgJHtwb3NpdGlvbnNbMF0udHJhaWwoNzApfSDCtyAke3ZhbHVlLnRlcm19IOKApmA7XG4gICAgICAgICAgICBpZiAoY29uZmxpY3QgaW5zdGFuY2VvZiBTaGlmdClcbiAgICAgICAgICAgICAgICBlcnJvciArPSBmaW5kQ29uZmxpY3RTaGlmdFNvdXJjZShwb3NpdGlvbnNbMF0sIGNvbmZsaWN0LnRlcm0sIGNvbnRleHQuZmlyc3QpO1xuICAgICAgICAgICAgZXJyb3IgKz0gZmluZENvbmZsaWN0T3JpZ2luKGNvbmZsaWN0UG9zLCBwb3NpdGlvbnNbMF0pO1xuICAgICAgICAgICAgY29udGV4dC5jb25mbGljdHMucHVzaChuZXcgQ29uZmxpY3QoZXJyb3IsIHJ1bGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0R290byh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdvdG8uZmluZChhID0+IGEudGVybSA9PSB0ZXJtKTtcbiAgICB9XG4gICAgaGFzU2V0KHNldCkge1xuICAgICAgICByZXR1cm4gZXFTZXQodGhpcy5zZXQsIHNldCk7XG4gICAgfVxuICAgIGFjdGlvbnNCeVRlcm0oKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9hY3Rpb25zQnlUZXJtO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uc0J5VGVybSA9IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgdGhpcy5hY3Rpb25zKVxuICAgICAgICAgICAgICAgIChyZXN1bHRbYWN0aW9uLnRlcm0uaWRdIHx8IChyZXN1bHRbYWN0aW9uLnRlcm0uaWRdID0gW10pKS5wdXNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5hY3Rpb25zWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgUmVkdWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgcnVsZSB9ID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9ucy5ldmVyeShhID0+IGEgaW5zdGFuY2VvZiBSZWR1Y2UgJiYgYS5ydWxlLnNhbWVSZWR1Y2UocnVsZSkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRSZWR1Y2UgPSBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucy5zb3J0KChhLCBiKSA9PiBhLmNtcChiKSk7XG4gICAgICAgIHRoaXMuZ290by5zb3J0KChhLCBiKSA9PiBhLmNtcChiKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGxldCBkVGhpcyA9IHRoaXMuZGVmYXVsdFJlZHVjZSwgZE90aGVyID0gb3RoZXIuZGVmYXVsdFJlZHVjZTtcbiAgICAgICAgaWYgKGRUaGlzIHx8IGRPdGhlcilcbiAgICAgICAgICAgIHJldHVybiBkVGhpcyAmJiBkT3RoZXIgPyBkVGhpcy5zYW1lUmVkdWNlKGRPdGhlcikgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcCA9PSBvdGhlci5za2lwICYmXG4gICAgICAgICAgICB0aGlzLnRva2VuR3JvdXAgPT0gb3RoZXIudG9rZW5Hcm91cCAmJlxuICAgICAgICAgICAgZXFTZXQodGhpcy5hY3Rpb25zLCBvdGhlci5hY3Rpb25zKSAmJlxuICAgICAgICAgICAgZXFTZXQodGhpcy5nb3RvLCBvdGhlci5nb3RvKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zdXJlKHNldCwgZmlyc3QpIHtcbiAgICBsZXQgYWRkZWQgPSBbXSwgcmVkbyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZEZvcihuYW1lLCBhaGVhZCwgYW1iaWdBaGVhZCwgc2tpcEFoZWFkLCB2aWEpIHtcbiAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBuYW1lLnJ1bGVzKSB7XG4gICAgICAgICAgICBsZXQgYWRkID0gYWRkZWQuZmluZChhID0+IGEucnVsZSA9PSBydWxlKTtcbiAgICAgICAgICAgIGlmICghYWRkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nID0gc2V0LmZpbmQocCA9PiBwLnBvcyA9PSAwICYmIHAucnVsZSA9PSBydWxlKTtcbiAgICAgICAgICAgICAgICBhZGQgPSBleGlzdGluZyA/IG5ldyBQb3MocnVsZSwgMCwgZXhpc3RpbmcuYWhlYWQuc2xpY2UoKSwgZXhpc3RpbmcuYW1iaWdBaGVhZCwgZXhpc3Rpbmcuc2tpcEFoZWFkLCBleGlzdGluZy52aWEpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFBvcyhydWxlLCAwLCBbXSwgbm9uZSQxLCBza2lwQWhlYWQsIHZpYSk7XG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChhZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZC5za2lwQWhlYWQgIT0gc2tpcEFoZWFkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW5FcnJvcihcIkluY29uc2lzdGVudCBza2lwIHNldHMgYWZ0ZXIgXCIgKyB2aWEudHJhaWwoKSk7XG4gICAgICAgICAgICBhZGQuYW1iaWdBaGVhZCA9IHVuaW9uKGFkZC5hbWJpZ0FoZWFkLCBhbWJpZ0FoZWFkKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRlcm0gb2YgYWhlYWQpXG4gICAgICAgICAgICAgICAgaWYgKCFhZGQuYWhlYWQuaW5jbHVkZXModGVybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkLmFoZWFkLnB1c2godGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGQucnVsZS5wYXJ0cy5sZW5ndGggJiYgIWFkZC5ydWxlLnBhcnRzWzBdLnRlcm1pbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG8oYWRkLCByZWRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgcG9zIG9mIHNldCkge1xuICAgICAgICBsZXQgbmV4dCA9IHBvcy5uZXh0O1xuICAgICAgICBpZiAobmV4dCAmJiAhbmV4dC50ZXJtaW5hbClcbiAgICAgICAgICAgIGFkZEZvcihuZXh0LCB0ZXJtc0FoZWFkKHBvcy5ydWxlLCBwb3MucG9zLCBwb3MuYWhlYWQsIGZpcnN0KSwgcG9zLmNvbmZsaWN0cyhwb3MucG9zICsgMSkuYW1iaWdHcm91cHMsIHBvcy5wb3MgPT0gcG9zLnJ1bGUucGFydHMubGVuZ3RoIC0gMSA/IHBvcy5za2lwQWhlYWQgOiBwb3MucnVsZS5za2lwLCBwb3MpO1xuICAgIH1cbiAgICB3aGlsZSAocmVkby5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGFkZCA9IHJlZG8ucG9wKCk7XG4gICAgICAgIGFkZEZvcihhZGQucnVsZS5wYXJ0c1swXSwgdGVybXNBaGVhZChhZGQucnVsZSwgMCwgYWRkLmFoZWFkLCBmaXJzdCksIHVuaW9uKGFkZC5ydWxlLmNvbmZsaWN0c1sxXS5hbWJpZ0dyb3VwcywgYWRkLnJ1bGUucGFydHMubGVuZ3RoID09IDEgPyBhZGQuYW1iaWdBaGVhZCA6IG5vbmUkMSksIGFkZC5ydWxlLnBhcnRzLmxlbmd0aCA9PSAxID8gYWRkLnNraXBBaGVhZCA6IGFkZC5ydWxlLnNraXAsIGFkZCk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBzZXQuc2xpY2UoKTtcbiAgICBmb3IgKGxldCBhZGQgb2YgYWRkZWQpIHtcbiAgICAgICAgYWRkLmFoZWFkLnNvcnQoKGEsIGIpID0+IGEuaGFzaCAtIGIuaGFzaCk7XG4gICAgICAgIGFkZC5maW5pc2goKTtcbiAgICAgICAgbGV0IG9yaWdJbmRleCA9IHNldC5maW5kSW5kZXgocCA9PiBwLnBvcyA9PSAwICYmIHAucnVsZSA9PSBhZGQucnVsZSk7XG4gICAgICAgIGlmIChvcmlnSW5kZXggPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdFtvcmlnSW5kZXhdID0gYWRkO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEuY21wKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFRvKHZhbHVlLCBhcnJheSkge1xuICAgIGlmICghYXJyYXkuaW5jbHVkZXModmFsdWUpKVxuICAgICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXJzdFNldHModGVybXMpIHtcbiAgICBsZXQgdGFibGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHQgb2YgdGVybXMudGVybXMpXG4gICAgICAgIGlmICghdC50ZXJtaW5hbClcbiAgICAgICAgICAgIHRhYmxlW3QubmFtZV0gPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgbnQgb2YgdGVybXMudGVybXMpXG4gICAgICAgICAgICBpZiAoIW50LnRlcm1pbmFsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJ1bGUgb2YgbnQucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNldCA9IHRhYmxlW250Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZSwgc3RhcnRMZW4gPSBzZXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHJ1bGUucGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG8ocGFydCwgc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGFibGVbcGFydC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG8odCwgc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvKG51bGwsIHNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID4gc3RhcnRMZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxufVxuY2xhc3MgQ29yZSB7XG4gICAgY29uc3RydWN0b3Ioc2V0LCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbn1cbmNsYXNzIENvbmZsaWN0IHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENvbmZsaWN0T3JpZ2luKGEsIGIpIHtcbiAgICBpZiAoYS5lcVNpbXBsZShiKSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZnVuY3Rpb24gdmlhKHJvb3QsIHN0YXJ0KSB7XG4gICAgICAgIGxldCBoaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSBzdGFydC52aWE7ICFwLmVxU2ltcGxlKHJvb3QpOyBwID0gcC52aWEpXG4gICAgICAgICAgICBoaXN0LnB1c2gocCk7XG4gICAgICAgIGlmICghaGlzdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgaGlzdC51bnNoaWZ0KHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIGhpc3QucmV2ZXJzZSgpLm1hcCgocCwgaSkgPT4gXCJcXG5cIiArIFwiICBcIi5yZXBlYXQoaSArIDEpICsgKHAgPT0gc3RhcnQgPyBcIlwiIDogXCJ2aWEgXCIpICsgcCkuam9pbihcIlwiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcCA9IGE7IHA7IHAgPSBwLnZpYSlcbiAgICAgICAgZm9yIChsZXQgcDIgPSBiOyBwMjsgcDIgPSBwMi52aWEpIHtcbiAgICAgICAgICAgIGlmIChwLmVxU2ltcGxlKHAyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXG5TaGFyZWQgb3JpZ2luOiBcIiArIHAgKyB2aWEocCwgYSkgKyB2aWEocCwgYik7XG4gICAgICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbi8vIFNlYXJjaCBmb3IgdGhlIHJlYXNvbiB0aGF0IGEgZ2l2ZW4gJ2FmdGVyJyB0b2tlbiBleGlzdHMgYXQgdGhlXG4vLyBnaXZlbiBwb3MsIGJ5IHNjYW5uaW5nIHVwIHRoZSB0cmFpbCBvZiBwb3NpdGlvbnMuIEJlY2F1c2UgdGhlIGB2aWFgXG4vLyBsaW5rIGlzIG9ubHkgb25lIHNvdXJjZSBvZiBhIHBvcywgb2YgcG90ZW50aWFsbHkgbWFueSwgdGhpc1xuLy8gcmVxdWlyZXMgYSByZS1zaW11bGF0aW9uIG9mIHRoZSB3aG9sZSBwYXRoIHVwIHRvIHRoZSBwb3MuXG5mdW5jdGlvbiBmaW5kQ29uZmxpY3RTaGlmdFNvdXJjZShjb25mbGljdFBvcywgdGVybUFmdGVyLCBmaXJzdCkge1xuICAgIGxldCBwb3MgPSBjb25mbGljdFBvcywgcGF0aCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5wb3MgLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIHBhdGgucHVzaChwb3MucnVsZS5wYXJ0c1tpXSk7XG4gICAgICAgIGlmICghcG9zLnZpYSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBwb3MudmlhO1xuICAgIH1cbiAgICBwYXRoLnJldmVyc2UoKTtcbiAgICBsZXQgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBleHBsb3JlKHBvcywgaSwgaGFzTWF0Y2gpIHtcbiAgICAgICAgaWYgKGkgPT0gcGF0aC5sZW5ndGggJiYgaGFzTWF0Y2ggJiYgIXBvcy5uZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGBcXG5UaGUgcmVkdWN0aW9uIG9mICR7Y29uZmxpY3RQb3MucnVsZS5uYW1lfSBpcyBhbGxvd2VkIGJlZm9yZSAke3Rlcm1BZnRlcn0gYmVjYXVzZSBvZiB0aGlzIHJ1bGU6XFxuICAke2hhc01hdGNofWA7XG4gICAgICAgIGZvciAobGV0IG5leHQ7IG5leHQgPSBwb3MubmV4dDspIHtcbiAgICAgICAgICAgIGlmIChpIDwgcGF0aC5sZW5ndGggJiYgbmV4dCA9PSBwYXRoW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gZXhwbG9yZShwb3MuYWR2YW5jZSgpLCBpICsgMSwgaGFzTWF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFmdGVyID0gcG9zLnJ1bGUucGFydHNbcG9zLnBvcyArIDFdLCBtYXRjaCA9IHBvcy5wb3MgKyAxID09IHBvcy5ydWxlLnBhcnRzLmxlbmd0aCA/IGhhc01hdGNoIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChhZnRlciAmJiAoYWZ0ZXIudGVybWluYWwgPyBhZnRlciA9PSB0ZXJtQWZ0ZXIgOiBmaXJzdFthZnRlci5uYW1lXS5pbmNsdWRlcyh0ZXJtQWZ0ZXIpKSlcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHBvcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIG5leHQucnVsZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaCA9IChydWxlLmlkIDw8IDUpICsgaSArIChtYXRjaCA/IDU1NSA6IDApO1xuICAgICAgICAgICAgICAgIGlmICghc2Vlbi5oYXMoaGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5hZGQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGV4cGxvcmUobmV3IFBvcyhydWxlLCAwLCBbXSwgW10sIG5leHQsIHBvcyksIGksIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dC50ZXJtaW5hbCAmJiBmaXJzdFtuZXh0Lm5hbWVdLmluY2x1ZGVzKG51bGwpKVxuICAgICAgICAgICAgICAgIHBvcyA9IHBvcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBleHBsb3JlKHBvcywgMCwgbnVsbCk7XG59XG4vLyBCdWlsZHMgYSBmdWxsIExSKDEpIGF1dG9tYXRvblxuZnVuY3Rpb24gYnVpbGRGdWxsQXV0b21hdG9uKHRlcm1zLCBzdGFydFRlcm1zLCBmaXJzdCkge1xuICAgIGxldCBzdGF0ZXMgPSBbXSwgc3RhdGVzQnlTZXRIYXNoID0ge307XG4gICAgbGV0IGNvcmVzID0ge307XG4gICAgbGV0IHQwID0gRGF0ZS5ub3coKTtcbiAgICBmdW5jdGlvbiBnZXRTdGF0ZShjb3JlLCB0b3ApIHtcbiAgICAgICAgaWYgKGNvcmUubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGNvcmVIYXNoID0gaGFzaFBvc2l0aW9ucyhjb3JlKSwgYnlIYXNoID0gY29yZXNbY29yZUhhc2hdO1xuICAgICAgICBsZXQgc2tpcDtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIGNvcmUpIHtcbiAgICAgICAgICAgIGlmICghc2tpcClcbiAgICAgICAgICAgICAgICBza2lwID0gcG9zLnNraXA7XG4gICAgICAgICAgICBlbHNlIGlmIChza2lwICE9IHBvcy5za2lwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW5FcnJvcihcIkluY29uc2lzdGVudCBza2lwIHNldHMgYWZ0ZXIgXCIgKyBwb3MudHJhaWwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5SGFzaClcbiAgICAgICAgICAgIGZvciAobGV0IGtub3duIG9mIGJ5SGFzaClcbiAgICAgICAgICAgICAgICBpZiAoZXFTZXQoY29yZSwga25vd24uc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa25vd24uc3RhdGUuc2tpcCAhPSBza2lwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdlbkVycm9yKFwiSW5jb25zaXN0ZW50IHNraXAgc2V0cyBhZnRlciBcIiArIGtub3duLnNldFswXS50cmFpbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtub3duLnN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHNldCA9IGNsb3N1cmUoY29yZSwgZmlyc3QpO1xuICAgICAgICBsZXQgaGFzaCA9IGhhc2hQb3NpdGlvbnMoc2V0KSwgZm9ySGFzaCA9IHN0YXRlc0J5U2V0SGFzaFtoYXNoXSB8fCAoc3RhdGVzQnlTZXRIYXNoW2hhc2hdID0gW10pO1xuICAgICAgICBsZXQgZm91bmQ7XG4gICAgICAgIGlmICghdG9wKVxuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGUgb2YgZm9ySGFzaClcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGFzU2V0KHNldCkpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gc3RhdGU7XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIGZvdW5kID0gbmV3IFN0YXRlKHN0YXRlcy5sZW5ndGgsIHNldCwgMCwgc2tpcCwgaGFzaCwgdG9wKTtcbiAgICAgICAgICAgIGZvckhhc2gucHVzaChmb3VuZCk7XG4gICAgICAgICAgICBzdGF0ZXMucHVzaChmb3VuZCk7XG4gICAgICAgICAgICBpZiAodGltaW5nICYmIHN0YXRlcy5sZW5ndGggJSA1MDAgPT0gMClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtzdGF0ZXMubGVuZ3RofSBzdGF0ZXMgYWZ0ZXIgJHsoKERhdGUubm93KCkgLSB0MCkgLyAxMDAwKS50b0ZpeGVkKDIpfXNgKTtcbiAgICAgICAgfVxuICAgICAgICAoY29yZXNbY29yZUhhc2hdIHx8IChjb3Jlc1tjb3JlSGFzaF0gPSBbXSkpLnB1c2gobmV3IENvcmUoY29yZSwgZm91bmQpKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN0YXJ0VGVybSBvZiBzdGFydFRlcm1zKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U2tpcCA9IHN0YXJ0VGVybS5ydWxlcy5sZW5ndGggPyBzdGFydFRlcm0ucnVsZXNbMF0uc2tpcCA6IHRlcm1zLm5hbWVzW1wiJW5vc2tpcFwiXTtcbiAgICAgICAgZ2V0U3RhdGUoc3RhcnRUZXJtLnJ1bGVzLm1hcChydWxlID0+IG5ldyBQb3MocnVsZSwgMCwgW3Rlcm1zLmVvZl0sIG5vbmUkMSwgc3RhcnRTa2lwLCBudWxsKS5maW5pc2goKSksIHN0YXJ0VGVybSk7XG4gICAgfVxuICAgIGxldCBjb25mbGljdHMgPSBuZXcgQ29uZmxpY3RDb250ZXh0KGZpcnN0KTtcbiAgICBmb3IgKGxldCBmaWxsZWQgPSAwOyBmaWxsZWQgPCBzdGF0ZXMubGVuZ3RoOyBmaWxsZWQrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSBzdGF0ZXNbZmlsbGVkXTtcbiAgICAgICAgbGV0IGJ5VGVybSA9IFtdLCBieVRlcm1Qb3MgPSBbXSwgYXRFbmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIHN0YXRlLnNldCkge1xuICAgICAgICAgICAgaWYgKHBvcy5wb3MgPT0gcG9zLnJ1bGUucGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb3MucnVsZS5uYW1lLnRvcClcbiAgICAgICAgICAgICAgICAgICAgYXRFbmQucHVzaChwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwb3MucnVsZS5wYXJ0c1twb3MucG9zXTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBieVRlcm0uaW5kZXhPZihuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5VGVybS5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBieVRlcm1Qb3MucHVzaChbcG9zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBieVRlcm1Qb3NbaW5kZXhdLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieVRlcm0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0ZXJtID0gYnlUZXJtW2ldLCBwb3NpdGlvbnMgPSBieVRlcm1Qb3NbaV0ubWFwKHAgPT4gcC5hZHZhbmNlKCkpO1xuICAgICAgICAgICAgaWYgKHRlcm0udGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2V0ID0gYXBwbHlDdXQocG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGdldFN0YXRlKHNldCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFkZEFjdGlvbihuZXcgU2hpZnQodGVybSwgbmV4dCksIGJ5VGVybVBvc1tpXSwgY29uZmxpY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBnb3RvID0gZ2V0U3RhdGUocG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoZ290bylcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ290by5wdXNoKG5ldyBTaGlmdCh0ZXJtLCBnb3RvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBhdEVuZClcbiAgICAgICAgICAgIGZvciAobGV0IGFoZWFkIG9mIHBvcy5haGVhZCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IHN0YXRlLmFjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFkZEFjdGlvbihuZXcgUmVkdWNlKGFoZWFkLCBwb3MucnVsZSksIFtwb3NdLCBjb25mbGljdHMpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hY3Rpb25zLmxlbmd0aCA9PSBjb3VudClcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBJZiBzb21lIGFjdGlvbnMgd2VyZSByZXBsYWNlZCBieSBvdGhlcnMsIGRvdWJsZS1jaGVjayB3aGV0aGVyXG4gICAgICAgIC8vIGdvdG8gZW50cmllcyBhcmUgbm93IHN1cGVyZmx1b3VzIChmb3IgZXhhbXBsZSwgaW4gYW4gb3BlcmF0b3JcbiAgICAgICAgLy8gcHJlY2VkZW5jZS1yZWxhdGVkIHN0YXRlIHRoYXQgaGFzIGEgc2hpZnQgZm9yIGAqYCBidXQgb25seSBhXG4gICAgICAgIC8vIHJlZHVjZSBmb3IgYCtgLCB3ZSBkb24ndCBuZWVkIGEgZ290byBlbnRyeSBmb3IgcnVsZXMgdGhhdCBzdGFydFxuICAgICAgICAvLyB3aXRoIGArYClcbiAgICAgICAgaWYgKHJlcGxhY2VkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5nb3RvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZmlyc3Rbc3RhdGUuZ290b1tpXS50ZXJtLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnQuc29tZSh0ZXJtID0+IHN0YXRlLmFjdGlvbnMuc29tZShhID0+IGEudGVybSA9PSB0ZXJtICYmIChhIGluc3RhbmNlb2YgU2hpZnQpKSkpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmdvdG8uc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb25mbGljdHMuY29uZmxpY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEdlbkVycm9yKGNvbmZsaWN0cy5jb25mbGljdHMubWFwKGMgPT4gYy5lcnJvcikuam9pbihcIlxcblxcblwiKSk7XG4gICAgLy8gUmVzb2x2ZSBhbHdheXNSZWR1Y2UgYW5kIHNvcnQgYWN0aW9uc1xuICAgIGZvciAobGV0IHN0YXRlIG9mIHN0YXRlcylcbiAgICAgICAgc3RhdGUuZmluaXNoKCk7XG4gICAgaWYgKHRpbWluZylcbiAgICAgICAgY29uc29sZS5sb2coYCR7c3RhdGVzLmxlbmd0aH0gc3RhdGVzIHRvdGFsLmApO1xuICAgIHJldHVybiBzdGF0ZXM7XG59XG5mdW5jdGlvbiBhcHBseUN1dChzZXQpIHtcbiAgICBsZXQgZm91bmQgPSBudWxsLCBjdXQgPSAxO1xuICAgIGZvciAobGV0IHBvcyBvZiBzZXQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcG9zLnJ1bGUuY29uZmxpY3RzW3Bvcy5wb3MgLSAxXS5jdXQ7XG4gICAgICAgIGlmICh2YWx1ZSA8IGN1dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWZvdW5kIHx8IHZhbHVlID4gY3V0KSB7XG4gICAgICAgICAgICBjdXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm91bmQucHVzaChwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQgfHwgc2V0O1xufVxuLy8gVmVyaWZ5IHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0aW5nIGFjdGlvbnMgb3IgZ290byBlbnRyaWVzIGluIHRoZVxuLy8gdHdvIGdpdmVuIHN0YXRlcyAodXNpbmcgdGhlIHN0YXRlIElEIHJlbWFwcGluZyBwcm92aWRlZCBpbiBtYXBwaW5nKVxuZnVuY3Rpb24gY2FuTWVyZ2UoYSwgYiwgbWFwcGluZykge1xuICAgIC8vIElmIGEgZ290byBmb3IgdGhlIHNhbWUgdGVybSBkaWZmZXJzLCB0aGF0IG1ha2VzIHRoZSBzdGF0ZXNcbiAgICAvLyBpbmNvbXBhdGlibGVcbiAgICBmb3IgKGxldCBnb3RvIG9mIGEuZ290bylcbiAgICAgICAgZm9yIChsZXQgb3RoZXIgb2YgYi5nb3RvKSB7XG4gICAgICAgICAgICBpZiAoZ290by50ZXJtID09IG90aGVyLnRlcm0gJiYgbWFwcGluZ1tnb3RvLnRhcmdldC5pZF0gIT0gbWFwcGluZ1tvdGhlci50YXJnZXQuaWRdKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGFjdGlvbiB3aGVyZSBhIGNvbmZsaWN0aW5nIGFjdGlvbiBleGlzdHMgaW4gdGhlXG4gICAgLy8gb3RoZXIgc3RhdGUsIHRoZSBtZXJnZSBpcyBvbmx5IGFsbG93ZWQgd2hlbiBib3RoIHN0YXRlcyBoYXZlIHRoZVxuICAgIC8vIGV4YWN0IHNhbWUgc2V0IG9mIGFjdGlvbnMgZm9yIHRoaXMgdGVybS5cbiAgICBsZXQgYnlUZXJtID0gYi5hY3Rpb25zQnlUZXJtKCk7XG4gICAgZm9yIChsZXQgYWN0aW9uIG9mIGEuYWN0aW9ucykge1xuICAgICAgICBsZXQgc2V0QiA9IGJ5VGVybVthY3Rpb24udGVybS5pZF07XG4gICAgICAgIGlmIChzZXRCICYmIHNldEIuc29tZShvdGhlciA9PiAhb3RoZXIubWF0Y2hlcyhhY3Rpb24sIG1hcHBpbmcpKSkge1xuICAgICAgICAgICAgaWYgKHNldEIubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNldEEgPSBhLmFjdGlvbnNCeVRlcm0oKVthY3Rpb24udGVybS5pZF07XG4gICAgICAgICAgICBpZiAoc2V0QS5sZW5ndGggIT0gc2V0Qi5sZW5ndGggfHwgc2V0QS5zb21lKGExID0+ICFzZXRCLnNvbWUoYTIgPT4gYTEubWF0Y2hlcyhhMiwgbWFwcGluZykpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtZXJnZVN0YXRlcyhzdGF0ZXMsIG1hcHBpbmcpIHtcbiAgICBsZXQgbmV3U3RhdGVzID0gW107XG4gICAgZm9yIChsZXQgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICAgIGxldCBuZXdJRCA9IG1hcHBpbmdbc3RhdGUuaWRdO1xuICAgICAgICBpZiAoIW5ld1N0YXRlc1tuZXdJRF0pIHtcbiAgICAgICAgICAgIG5ld1N0YXRlc1tuZXdJRF0gPSBuZXcgU3RhdGUobmV3SUQsIHN0YXRlLnNldCwgMCwgc3RhdGUuc2tpcCwgc3RhdGUuaGFzaCwgc3RhdGUuc3RhcnRSdWxlKTtcbiAgICAgICAgICAgIG5ld1N0YXRlc1tuZXdJRF0udG9rZW5Hcm91cCA9IHN0YXRlLnRva2VuR3JvdXA7XG4gICAgICAgICAgICBuZXdTdGF0ZXNbbmV3SURdLmRlZmF1bHRSZWR1Y2UgPSBzdGF0ZS5kZWZhdWx0UmVkdWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHN0YXRlIG9mIHN0YXRlcykge1xuICAgICAgICBsZXQgbmV3SUQgPSBtYXBwaW5nW3N0YXRlLmlkXSwgdGFyZ2V0ID0gbmV3U3RhdGVzW25ld0lEXTtcbiAgICAgICAgdGFyZ2V0LmZsYWdzIHw9IHN0YXRlLmZsYWdzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBzdGF0ZS5hY3Rpb25zW2ldLm1hcChtYXBwaW5nLCBuZXdTdGF0ZXMpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQuYWN0aW9ucy5zb21lKGEgPT4gYS5lcShhY3Rpb24pKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWN0aW9uUG9zaXRpb25zLnB1c2goc3RhdGUuYWN0aW9uUG9zaXRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBnb3RvIG9mIHN0YXRlLmdvdG8pIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBnb3RvLm1hcChtYXBwaW5nLCBuZXdTdGF0ZXMpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQuZ290by5zb21lKGcgPT4gZy5lcShtYXBwZWQpKSlcbiAgICAgICAgICAgICAgICB0YXJnZXQuZ290by5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlcztcbn1cbmNsYXNzIEdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIG1lbWJlcikge1xuICAgICAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW21lbWJlcl07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVBvc1NldChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uZXFTaW1wbGUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBDb2xsYXBzZSBhbiBMUigxKSBhdXRvbWF0b24gdG8gYW4gTEFMUi1saWtlIGF1dG9tYXRvblxuZnVuY3Rpb24gY29sbGFwc2VBdXRvbWF0b24oc3RhdGVzKSB7XG4gICAgbGV0IG1hcHBpbmcgPSBbXSwgZ3JvdXBzID0gW107XG4gICAgYXNzaWduR3JvdXBzOiBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgIGlmICghc3RhdGUuc3RhcnRSdWxlKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBncm91cHNbal0sIG90aGVyID0gc3RhdGVzW2dyb3VwLm1lbWJlcnNbMF1dO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50b2tlbkdyb3VwID09IG90aGVyLnRva2VuR3JvdXAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2tpcCA9PSBvdGhlci5za2lwICYmXG4gICAgICAgICAgICAgICAgICAgICFvdGhlci5zdGFydFJ1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2FtZVBvc1NldChzdGF0ZS5zZXQsIG90aGVyLnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAubWVtYmVycy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFzc2lnbkdyb3VwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIG1hcHBpbmcucHVzaChncm91cHMubGVuZ3RoKTtcbiAgICAgICAgZ3JvdXBzLnB1c2gobmV3IEdyb3VwKGdyb3Vwcy5sZW5ndGgsIGkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BpbGwoZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGdyb3VwID0gZ3JvdXBzW2dyb3VwSW5kZXhdLCBzdGF0ZSA9IHN0YXRlc1tncm91cC5tZW1iZXJzW2luZGV4XV07XG4gICAgICAgIGxldCBwb3AgPSBncm91cC5tZW1iZXJzLnBvcCgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gZ3JvdXAubWVtYmVycy5sZW5ndGgpXG4gICAgICAgICAgICBncm91cC5tZW1iZXJzW2luZGV4XSA9IHBvcDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGdyb3VwSW5kZXggKyAxOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtYXBwaW5nW3N0YXRlLmlkXSA9IGk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2ldLm9yaWdpbiA9PSBncm91cC5vcmlnaW4gJiZcbiAgICAgICAgICAgICAgICBncm91cHNbaV0ubWVtYmVycy5ldmVyeShpZCA9PiBjYW5NZXJnZShzdGF0ZSwgc3RhdGVzW2lkXSwgbWFwcGluZykpKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2ldLm1lbWJlcnMucHVzaChzdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcHBpbmdbc3RhdGUuaWRdID0gZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgZ3JvdXBzLnB1c2gobmV3IEdyb3VwKGdyb3VwLm9yaWdpbiwgc3RhdGUuaWQpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7OyBwYXNzKyspIHtcbiAgICAgICAgbGV0IGNvbmZsaWN0cyA9IGZhbHNlLCB0MCA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAobGV0IGcgPSAwLCBzdGFydExlbiA9IGdyb3Vwcy5sZW5ndGg7IGcgPCBzdGFydExlbjsgZysrKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSBncm91cHNbZ107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXAubWVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWRBID0gZ3JvdXAubWVtYmVyc1tpXSwgaWRCID0gZ3JvdXAubWVtYmVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5NZXJnZShzdGF0ZXNbaWRBXSwgc3RhdGVzW2lkQl0sIG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwoZywgai0tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltaW5nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYENvbGxhcHNlIHBhc3MgJHtwYXNzfSR7Y29uZmxpY3RzID8gYGAgOiBgLCBkb25lYH0gKCR7KChEYXRlLm5vdygpIC0gdDApIC8gMTAwMCkudG9GaXhlZCgyKX1zKWApO1xuICAgICAgICBpZiAoIWNvbmZsaWN0cylcbiAgICAgICAgICAgIHJldHVybiBtZXJnZVN0YXRlcyhzdGF0ZXMsIG1hcHBpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlSWRlbnRpY2FsKHN0YXRlcykge1xuICAgIGZvciAobGV0IHBhc3MgPSAxOzsgcGFzcysrKSB7XG4gICAgICAgIGxldCBtYXBwaW5nID0gW10sIGRpZE1lcmdlID0gZmFsc2UsIHQwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IG5ld1N0YXRlcyA9IFtdO1xuICAgICAgICAvLyBGaW5kIHN0YXRlcyB0aGF0IGVpdGhlciBoYXZlIHRoZSBzYW1lIGFsd2F5c1JlZHVjZSBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhY3Rpb25zLCBhbmQgbWVyZ2UgdGhlbS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG5ld1N0YXRlcy5maW5kSW5kZXgocyA9PiBzdGF0ZS5lcShzKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPCAwKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZ1tpXSA9IG5ld1N0YXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZ1tpXSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIGRpZE1lcmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGF0ZXNbbWF0Y2hdLCBhZGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBzdGF0ZS5zZXQpXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXIuc2V0LnNvbWUocCA9PiBwLmVxU2ltcGxlKHBvcykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKGFkZCB8fCAoYWRkID0gW10pKS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZClcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuc2V0ID0gYWRkLmNvbmNhdChvdGhlci5zZXQpLnNvcnQoKGEsIGIpID0+IGEuY21wKGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltaW5nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYE1lcmdlIGlkZW50aWNhbCBwYXNzICR7cGFzc30ke2RpZE1lcmdlID8gXCJcIiA6IFwiLCBkb25lXCJ9ICgkeygoRGF0ZS5ub3coKSAtIHQwKSAvIDEwMDApLnRvRml4ZWQoMil9cylgKTtcbiAgICAgICAgaWYgKCFkaWRNZXJnZSlcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhY3Rpb25zIHBvaW50IGF0IG1lcmdlZCBzdGF0ZSBvYmplY3RzXG4gICAgICAgIGZvciAobGV0IHN0YXRlIG9mIG5ld1N0YXRlcylcbiAgICAgICAgICAgIGlmICghc3RhdGUuZGVmYXVsdFJlZHVjZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGlvbnMgPSBzdGF0ZS5hY3Rpb25zLm1hcChhID0+IGEubWFwKG1hcHBpbmcsIG5ld1N0YXRlcykpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmdvdG8gPSBzdGF0ZS5nb3RvLm1hcChhID0+IGEubWFwKG1hcHBpbmcsIG5ld1N0YXRlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBSZW51bWJlciBpZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBuZXdTdGF0ZXNbaV0uaWQgPSBpO1xuICAgICAgICBzdGF0ZXMgPSBuZXdTdGF0ZXM7XG4gICAgfVxufVxuY29uc3Qgbm9uZSQxID0gW107XG5mdW5jdGlvbiBmaW5pc2hBdXRvbWF0b24oZnVsbCkge1xuICAgIHJldHVybiBtZXJnZUlkZW50aWNhbChjb2xsYXBzZUF1dG9tYXRvbihmdWxsKSk7XG59XG5cbi8vIEVuY29kZSBudW1iZXJzIGFzIGdyb3VwcyBvZiBwcmludGFibGUgYXNjaWkgY2hhcmFjdGVyc1xuLy9cbi8vIC0gMHhmZmZmLCB3aGljaCBpcyBvZnRlbiB1c2VkIGFzIHBsYWNlaG9sZGVyLCBpcyBlbmNvZGVkIGFzIFwiflwiXG4vL1xuLy8gLSBUaGUgY2hhcmFjdGVycyBmcm9tIFwiIFwiICgzMikgdG8gXCJ9XCIgKDEyNSksIGV4Y2x1ZGluZyAnXCInIGFuZFxuLy8gICBcIlxcXFxcIiwgaW5kaWNhdGUgdmFsdWVzIGZyb20gMCB0byA5MlxuLy9cbi8vIC0gVGhlIGZpcnN0IGJpdCBpbiBhICdkaWdpdCcgaXMgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgaXNcbi8vICAgdGhlIGVuZCBvZiBhIG51bWJlci5cbi8vXG4vLyAtIFRoYXQgbGVhdmVzIDQ2IG90aGVyIHZhbHVlcywgd2hpY2ggYXJlIGFjdHVhbGx5IHNpZ25pZmljYW50LlxuLy9cbi8vIC0gVGhlIGRpZ2l0cyBpbiBhIG51bWJlciBhcmUgb3JkZXJlZCBmcm9tIGhpZ2ggdG8gbG93IHNpZ25pZmljYW5jZS5cbmZ1bmN0aW9uIGRpZ2l0VG9DaGFyKGRpZ2l0KSB7XG4gICAgbGV0IGNoID0gZGlnaXQgKyAzMiAvKiBFbmNvZGUuU3RhcnQgKi87XG4gICAgaWYgKGNoID49IDM0IC8qIEVuY29kZS5HYXAxICovKVxuICAgICAgICBjaCsrO1xuICAgIGlmIChjaCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgY2grKztcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG59XG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIG1heCA9IDB4ZmZmZikge1xuICAgIGlmICh2YWx1ZSA+IG1heClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGVuY29kZSBhIG51bWJlciB0aGF0J3MgdG9vIGJpZzogXCIgKyB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi8pXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNiAvKiBFbmNvZGUuQmlnVmFsQ29kZSAqLyk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgZmlyc3QgPSA0NiAvKiBFbmNvZGUuQmFzZSAqLzs7IGZpcnN0ID0gMCkge1xuICAgICAgICBsZXQgbG93ID0gdmFsdWUgJSA0NiAvKiBFbmNvZGUuQmFzZSAqLywgcmVzdCA9IHZhbHVlIC0gbG93O1xuICAgICAgICByZXN1bHQgPSBkaWdpdFRvQ2hhcihsb3cgKyBmaXJzdCkgKyByZXN1bHQ7XG4gICAgICAgIGlmIChyZXN0ID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdmFsdWUgPSByZXN0IC8gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZXMsIG1heCA9IDB4ZmZmZikge1xuICAgIGxldCByZXN1bHQgPSAnXCInICsgZW5jb2RlKHZhbHVlcy5sZW5ndGgsIDB4ZmZmZmZmZmYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQgKz0gZW5jb2RlKHZhbHVlc1tpXSwgbWF4KTtcbiAgICByZXN1bHQgKz0gJ1wiJztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBub25lID0gW107XG5jbGFzcyBQYXJ0cyB7XG4gICAgY29uc3RydWN0b3IodGVybXMsIGNvbmZsaWN0cykge1xuICAgICAgICB0aGlzLnRlcm1zID0gdGVybXM7XG4gICAgICAgIHRoaXMuY29uZmxpY3RzID0gY29uZmxpY3RzO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gUGFydHMubm9uZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgaWYgKG90aGVyID09IFBhcnRzLm5vbmUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvbmZsaWN0cyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbmZsaWN0cyB8fCBvdGhlci5jb25mbGljdHMpIHtcbiAgICAgICAgICAgIGNvbmZsaWN0cyA9IHRoaXMuY29uZmxpY3RzID8gdGhpcy5jb25mbGljdHMuc2xpY2UoKSA6IHRoaXMuZW5zdXJlQ29uZmxpY3RzKCk7XG4gICAgICAgICAgICBsZXQgb3RoZXJDb25mbGljdHMgPSBvdGhlci5lbnN1cmVDb25mbGljdHMoKTtcbiAgICAgICAgICAgIGNvbmZsaWN0c1tjb25mbGljdHMubGVuZ3RoIC0gMV0gPSBjb25mbGljdHNbY29uZmxpY3RzLmxlbmd0aCAtIDFdLmpvaW4ob3RoZXJDb25mbGljdHNbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvdGhlckNvbmZsaWN0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaChvdGhlckNvbmZsaWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJ0cyh0aGlzLnRlcm1zLmNvbmNhdChvdGhlci50ZXJtcyksIGNvbmZsaWN0cyk7XG4gICAgfVxuICAgIHdpdGhDb25mbGljdHMocG9zLCBjb25mbGljdHMpIHtcbiAgICAgICAgaWYgKGNvbmZsaWN0cyA9PSBDb25mbGljdHMubm9uZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgYXJyYXkgPSB0aGlzLmNvbmZsaWN0cyA/IHRoaXMuY29uZmxpY3RzLnNsaWNlKCkgOiB0aGlzLmVuc3VyZUNvbmZsaWN0cygpO1xuICAgICAgICBhcnJheVtwb3NdID0gYXJyYXlbcG9zXS5qb2luKGNvbmZsaWN0cyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFydHModGhpcy50ZXJtcywgYXJyYXkpO1xuICAgIH1cbiAgICBlbnN1cmVDb25mbGljdHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZsaWN0cylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZsaWN0cztcbiAgICAgICAgbGV0IGVtcHR5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMudGVybXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbXB0eS5wdXNoKENvbmZsaWN0cy5ub25lKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbn1cblBhcnRzLm5vbmUgPSBuZXcgUGFydHMobm9uZSwgbnVsbCk7XG5mdW5jdGlvbiBwKC4uLnRlcm1zKSB7IHJldHVybiBuZXcgUGFydHModGVybXMsIG51bGwpOyB9XG5jbGFzcyBCdWlsdFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBhcmdzLCB0ZXJtKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy50ZXJtID0gdGVybTtcbiAgICB9XG4gICAgbWF0Y2hlcyhleHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkID09IGV4cHIuaWQubmFtZSAmJiBleHByc0VxKGV4cHIuYXJncywgdGhpcy5hcmdzKTtcbiAgICB9XG4gICAgbWF0Y2hlc1JlcGVhdChleHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkID09IFwiK1wiICYmIGV4cHJFcShleHByLmV4cHIsIHRoaXMuYXJnc1swXSk7XG4gICAgfVxufVxuY2xhc3MgQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnRlcm1zID0gbmV3IFRlcm1TZXQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRva2VuT3JpZ2lucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5idWlsdCA9IFtdO1xuICAgICAgICB0aGlzLnJ1bGVOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMubmFtZWRUZXJtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGVybVRhYmxlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5rbm93blByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5keW5hbWljUnVsZVByZWNlZGVuY2VzID0gW107XG4gICAgICAgIHRoaXMuZGVmaW5lZEdyb3VwcyA9IFtdO1xuICAgICAgICB0aGlzLmFzdFJ1bGVzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudFNraXAgPSBbXTtcbiAgICAgICAgdGltZShcIlBhcnNlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXQodGV4dCwgb3B0aW9ucy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFzdCA9IHRoaXMuaW5wdXQucGFyc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBOUCA9IE5vZGVQcm9wO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIE5QKSB7XG4gICAgICAgICAgICBpZiAoTlBbcHJvcF0gaW5zdGFuY2VvZiBOb2RlUHJvcCAmJiAhTlBbcHJvcF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmtub3duUHJvcHNbcHJvcF0gPSB7IHByb3A6IE5QW3Byb3BdLCBzb3VyY2U6IHsgbmFtZTogcHJvcCwgZnJvbTogbnVsbCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiB0aGlzLmFzdC5leHRlcm5hbFByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLmtub3duUHJvcHNbcHJvcC5pZC5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBwcm9wOiB0aGlzLm9wdGlvbnMuZXh0ZXJuYWxQcm9wID8gdGhpcy5vcHRpb25zLmV4dGVybmFsUHJvcChwcm9wLmlkLm5hbWUpIDogbmV3IE5vZGVQcm9wKCksXG4gICAgICAgICAgICAgICAgc291cmNlOiB7IG5hbWU6IHByb3AuZXh0ZXJuYWxJRC5uYW1lLCBmcm9tOiBwcm9wLnNvdXJjZSB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSB0aGlzLmFzdC5kaWFsZWN0cy5tYXAoZCA9PiBkLm5hbWUpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBNYWluVG9rZW5TZXQodGhpcywgdGhpcy5hc3QudG9rZW5zKTtcbiAgICAgICAgdGhpcy5sb2NhbFRva2VucyA9IHRoaXMuYXN0LmxvY2FsVG9rZW5zLm1hcChnID0+IG5ldyBMb2NhbFRva2VuU2V0KHRoaXMsIGcpKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbFRva2VucyA9IHRoaXMuYXN0LmV4dGVybmFsVG9rZW5zLm1hcChleHQgPT4gbmV3IEV4dGVybmFsVG9rZW5TZXQodGhpcywgZXh0KSk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxTcGVjaWFsaXplcnMgPSB0aGlzLmFzdC5leHRlcm5hbFNwZWNpYWxpemVycy5tYXAoZGVjbCA9PiBuZXcgRXh0ZXJuYWxTcGVjaWFsaXplcih0aGlzLCBkZWNsKSk7XG4gICAgICAgIHRpbWUoXCJCdWlsZCBydWxlc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9Ta2lwID0gdGhpcy5uZXdOYW1lKFwiJW5vc2tpcFwiLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lUnVsZShub1NraXAsIFtdKTtcbiAgICAgICAgICAgIGxldCBtYWluU2tpcCA9IHRoaXMuYXN0Lm1haW5Ta2lwID8gdGhpcy5uZXdOYW1lKFwiJW1haW5za2lwXCIsIHRydWUpIDogbm9Ta2lwO1xuICAgICAgICAgICAgbGV0IHNjb3BlZFNraXAgPSBbXSwgdG9wUnVsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHJ1bGUgb2YgdGhpcy5hc3QucnVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5hc3RSdWxlcy5wdXNoKHsgc2tpcDogbWFpblNraXAsIHJ1bGUgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIHRoaXMuYXN0LnRvcFJ1bGVzKVxuICAgICAgICAgICAgICAgIHRvcFJ1bGVzLnB1c2goeyBza2lwOiBtYWluU2tpcCwgcnVsZSB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHNjb3BlZCBvZiB0aGlzLmFzdC5zY29wZWRTa2lwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNraXAgPSBub1NraXAsIGZvdW5kID0gdGhpcy5hc3Quc2NvcGVkU2tpcC5maW5kSW5kZXgoKHNjLCBpKSA9PiBpIDwgc2NvcGVkU2tpcC5sZW5ndGggJiYgZXhwckVxKHNjLmV4cHIsIHNjb3BlZC5leHByKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNraXAgPSBzY29wZWRTa2lwW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFzdC5tYWluU2tpcCAmJiBleHByRXEoc2NvcGVkLmV4cHIsIHRoaXMuYXN0Lm1haW5Ta2lwKSlcbiAgICAgICAgICAgICAgICAgICAgc2tpcCA9IG1haW5Ta2lwO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtcHR5KHNjb3BlZC5leHByKSlcbiAgICAgICAgICAgICAgICAgICAgc2tpcCA9IHRoaXMubmV3TmFtZShcIiVza2lwXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNjb3BlZFNraXAucHVzaChza2lwKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIHNjb3BlZC5ydWxlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3RSdWxlcy5wdXNoKHsgc2tpcCwgcnVsZSB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIHNjb3BlZC50b3BSdWxlcylcbiAgICAgICAgICAgICAgICAgICAgdG9wUnVsZXMucHVzaCh7IHNraXAsIHJ1bGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB7IHJ1bGUgfSBvZiB0aGlzLmFzdFJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlxdWUocnVsZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTa2lwLnB1c2gobm9Ta2lwKTtcbiAgICAgICAgICAgIHRoaXMuc2tpcFJ1bGVzID0gbWFpblNraXAgPT0gbm9Ta2lwID8gW21haW5Ta2lwXSA6IFtub1NraXAsIG1haW5Ta2lwXTtcbiAgICAgICAgICAgIGlmIChtYWluU2tpcCAhPSBub1NraXApXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVSdWxlKG1haW5Ta2lwLCB0aGlzLm5vcm1hbGl6ZUV4cHIodGhpcy5hc3QubWFpblNraXApKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hc3Quc2NvcGVkU2tpcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBza2lwID0gc2NvcGVkU2tpcFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2tpcFJ1bGVzLmluY2x1ZGVzKHNraXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcFJ1bGVzLnB1c2goc2tpcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwICE9IG5vU2tpcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lUnVsZShza2lwLCB0aGlzLm5vcm1hbGl6ZUV4cHIodGhpcy5hc3Quc2NvcGVkU2tpcFtpXS5leHByKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2tpcC5wb3AoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgcnVsZSwgc2tpcCB9IG9mIHRvcFJ1bGVzLnNvcnQoKGEsIGIpID0+IGEucnVsZS5zdGFydCAtIGIucnVsZS5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXF1ZShydWxlLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZWQocnVsZS5pZC5uYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTa2lwLnB1c2goc2tpcCk7XG4gICAgICAgICAgICAgICAgbGV0IHsgbmFtZSwgcHJvcHMgfSA9IHRoaXMubm9kZUluZm8ocnVsZS5wcm9wcywgXCJhXCIsIHJ1bGUuaWQubmFtZSwgbm9uZSwgbm9uZSwgcnVsZS5leHByKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IHRoaXMudGVybXMubWFrZVRvcChuYW1lLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lZFRlcm1zW25hbWVdID0gdGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluZVJ1bGUodGVybSwgdGhpcy5ub3JtYWxpemVFeHByKHJ1bGUuZXhwcikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNraXAucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBleHQgb2YgdGhpcy5leHRlcm5hbFNwZWNpYWxpemVycylcbiAgICAgICAgICAgICAgICBleHQuZmluaXNoKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB7IHNraXAsIHJ1bGUgfSBvZiB0aGlzLmFzdFJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucnVsZU5hbWVzW3J1bGUuaWQubmFtZV0gJiYgaXNFeHBvcnRlZChydWxlKSAmJiAhcnVsZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRSdWxlKHJ1bGUsIFtdLCBza2lwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmV4cHIgaW5zdGFuY2VvZiBTZXF1ZW5jZUV4cHJlc3Npb24gJiYgcnVsZS5leHByLmV4cHJzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VkKHJ1bGUuaWQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnJ1bGVOYW1lcykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5ydWxlTmFtZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKGBVbnVzZWQgcnVsZSAnJHt2YWx1ZS5uYW1lfSdgLCB2YWx1ZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbnMudGFrZVByZWNlZGVuY2VzKCk7XG4gICAgICAgIHRoaXMudG9rZW5zLnRha2VDb25mbGljdHMoKTtcbiAgICAgICAgZm9yIChsZXQgbHQgb2YgdGhpcy5sb2NhbFRva2VucylcbiAgICAgICAgICAgIGx0LnRha2VQcmVjZWRlbmNlcygpO1xuICAgICAgICBmb3IgKGxldCB7IG5hbWUsIGdyb3VwLCBydWxlIH0gb2YgdGhpcy5kZWZpbmVkR3JvdXBzKVxuICAgICAgICAgICAgdGhpcy5kZWZpbmVHcm91cChuYW1lLCBncm91cCwgcnVsZSk7XG4gICAgICAgIHRoaXMuY2hlY2tHcm91cHMoKTtcbiAgICB9XG4gICAgdW5pcXVlKGlkKSB7XG4gICAgICAgIGlmIChpZC5uYW1lIGluIHRoaXMucnVsZU5hbWVzKVxuICAgICAgICAgICAgdGhpcy5yYWlzZShgRHVwbGljYXRlIGRlZmluaXRpb24gb2YgcnVsZSAnJHtpZC5uYW1lfSdgLCBpZC5zdGFydCk7XG4gICAgICAgIHRoaXMucnVsZU5hbWVzW2lkLm5hbWVdID0gaWQ7XG4gICAgfVxuICAgIHVzZWQobmFtZSkge1xuICAgICAgICB0aGlzLnJ1bGVOYW1lc1tuYW1lXSA9IG51bGw7XG4gICAgfVxuICAgIG5ld05hbWUoYmFzZSwgbm9kZU5hbWUgPSBudWxsLCBwcm9wcyA9IHt9KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlTmFtZSA/IDAgOiAxOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGkgPyBgJHtiYXNlfS0ke2l9YCA6IGJhc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGVybXMubmFtZXNbbmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVybXMubWFrZU5vblRlcm1pbmFsKG5hbWUsIG5vZGVOYW1lID09PSB0cnVlID8gbnVsbCA6IG5vZGVOYW1lLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZVBhcnNlcigpIHtcbiAgICAgICAgbGV0IHJ1bGVzID0gdGltZShcIlNpbXBsaWZ5IHJ1bGVzXCIsICgpID0+IHNpbXBsaWZ5UnVsZXModGhpcy5ydWxlcywgW1xuICAgICAgICAgICAgLi4udGhpcy5za2lwUnVsZXMsXG4gICAgICAgICAgICAuLi50aGlzLnRlcm1zLnRvcHNcbiAgICAgICAgXSkpO1xuICAgICAgICBsZXQgeyBub2RlVHlwZXMsIG5hbWVzOiB0ZXJtTmFtZXMsIG1pblJlcGVhdFRlcm0sIG1heFRlcm0gfSA9IHRoaXMudGVybXMuZmluaXNoKHJ1bGVzKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm5hbWVkVGVybXMpXG4gICAgICAgICAgICB0aGlzLnRlcm1UYWJsZVtwcm9wXSA9IHRoaXMubmFtZWRUZXJtc1twcm9wXS5pZDtcbiAgICAgICAgaWYgKC9cXGJncmFtbWFyXFxiLy50ZXN0KHZlcmJvc2UpKVxuICAgICAgICAgICAgY29uc29sZS5sb2cocnVsZXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgIGxldCBzdGFydFRlcm1zID0gdGhpcy50ZXJtcy50b3BzLnNsaWNlKCk7XG4gICAgICAgIGxldCBmaXJzdCA9IGNvbXB1dGVGaXJzdFNldHModGhpcy50ZXJtcyk7XG4gICAgICAgIGxldCBza2lwSW5mbyA9IHRoaXMuc2tpcFJ1bGVzLm1hcCgobmFtZSwgaWQpID0+IHtcbiAgICAgICAgICAgIGxldCBza2lwID0gW10sIHN0YXJ0VG9rZW5zID0gW10sIHJ1bGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIG5hbWUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUucGFydHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBydWxlLnBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2Ygc3RhcnQudGVybWluYWwgPyBbc3RhcnRdIDogZmlyc3Rbc3RhcnQubmFtZV0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmICFzdGFydFRva2Vucy5pbmNsdWRlcyh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VG9rZW5zLnB1c2godCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0LnRlcm1pbmFsICYmIHJ1bGUucGFydHMubGVuZ3RoID09IDEgJiYgIXJ1bGVzLnNvbWUociA9PiByICE9IHJ1bGUgJiYgci5wYXJ0c1swXSA9PSBzdGFydCkpXG4gICAgICAgICAgICAgICAgICAgIHNraXAucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZS5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAgICAgaWYgKHJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzdGFydFRlcm1zLnB1c2gobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4geyBza2lwLCBydWxlOiBydWxlcy5sZW5ndGggPyBuYW1lIDogbnVsbCwgc3RhcnRUb2tlbnMsIGlkIH07XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZnVsbFRhYmxlID0gdGltZShcIkJ1aWxkIGZ1bGwgYXV0b21hdG9uXCIsICgpID0+IGJ1aWxkRnVsbEF1dG9tYXRvbih0aGlzLnRlcm1zLCBzdGFydFRlcm1zLCBmaXJzdCkpO1xuICAgICAgICBsZXQgbG9jYWxUb2tlbnMgPSB0aGlzLmxvY2FsVG9rZW5zXG4gICAgICAgICAgICAubWFwKChncnAsIGkpID0+IGdycC5idWlsZExvY2FsR3JvdXAoZnVsbFRhYmxlLCBza2lwSW5mbywgaSkpO1xuICAgICAgICBsZXQgeyB0b2tlbkdyb3VwcywgdG9rZW5QcmVjLCB0b2tlbkRhdGEgfSA9IHRpbWUoXCJCdWlsZCB0b2tlbiBncm91cHNcIiwgKCkgPT4gdGhpcy50b2tlbnMuYnVpbGRUb2tlbkdyb3VwcyhmdWxsVGFibGUsIHNraXBJbmZvLCBsb2NhbFRva2Vucy5sZW5ndGgpKTtcbiAgICAgICAgbGV0IHRhYmxlID0gdGltZShcIkZpbmlzaCBhdXRvbWF0b25cIiwgKCkgPT4gZmluaXNoQXV0b21hdG9uKGZ1bGxUYWJsZSkpO1xuICAgICAgICBsZXQgc2tpcFN0YXRlID0gZmluZFNraXBTdGF0ZXModGFibGUsIHRoaXMudGVybXMudG9wcyk7XG4gICAgICAgIGlmICgvXFxibHJcXGIvLnRlc3QodmVyYm9zZSkpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0YWJsZS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgbGV0IHNwZWNpYWxpemVkID0gW107XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiB0aGlzLmV4dGVybmFsU3BlY2lhbGl6ZXJzKVxuICAgICAgICAgICAgc3BlY2lhbGl6ZWQucHVzaChleHQpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuc3BlY2lhbGl6ZWQpXG4gICAgICAgICAgICBzcGVjaWFsaXplZC5wdXNoKHsgdG9rZW46IHRoaXMudGVybXMubmFtZXNbbmFtZV0sIHRhYmxlOiBidWlsZFNwZWNpYWxpemVUYWJsZSh0aGlzLnNwZWNpYWxpemVkW25hbWVdKSB9KTtcbiAgICAgICAgbGV0IHRva1N0YXJ0ID0gKHRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuaXplciBpbnN0YW5jZW9mIEV4dGVybmFsVG9rZW5TZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuaXplci5hc3Quc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMuYXN0ID8gdGhpcy50b2tlbnMuYXN0LnN0YXJ0IDogLTE7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB0b2tlbml6ZXJzID0gdG9rZW5Hcm91cHNcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5leHRlcm5hbFRva2VucylcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB0b2tTdGFydChhKSAtIHRva1N0YXJ0KGIpKVxuICAgICAgICAgICAgLmNvbmNhdChsb2NhbFRva2Vucyk7XG4gICAgICAgIGxldCBkYXRhID0gbmV3IERhdGFCdWlsZGVyO1xuICAgICAgICBsZXQgc2tpcERhdGEgPSBza2lwSW5mby5tYXAoaW5mbyA9PiB7XG4gICAgICAgICAgICBsZXQgYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdGVybSBvZiBpbmZvLnNraXApXG4gICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHRlcm0uaWQsIDAsIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gPj4gMTYpO1xuICAgICAgICAgICAgaWYgKGluZm8ucnVsZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRhYmxlLmZpbmQocyA9PiBzLnN0YXJ0UnVsZSA9PSBpbmZvLnJ1bGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiBzdGF0ZS5hY3Rpb25zKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uLnRlcm0uaWQsIHN0YXRlLmlkLCAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovID4+IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbnMucHVzaCg2NTUzNSAvKiBTZXEuRW5kICovLCAwIC8qIFNlcS5Eb25lICovKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnN0b3JlQXJyYXkoYWN0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGVzID0gdGltZShcIkZpbmlzaCBzdGF0ZXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0YXRlcyA9IG5ldyBVaW50MzJBcnJheSh0YWJsZS5sZW5ndGggKiA2IC8qIFBhcnNlU3RhdGUuU2l6ZSAqLyk7XG4gICAgICAgICAgICBsZXQgZm9yY2VSZWR1Y3Rpb25zID0gdGhpcy5jb21wdXRlRm9yY2VSZWR1Y3Rpb25zKHRhYmxlLCBza2lwSW5mbyk7XG4gICAgICAgICAgICBsZXQgZmluaXNoQ3ggPSBuZXcgRmluaXNoU3RhdGVDb250ZXh0KHRva2VuaXplcnMsIGRhdGEsIHN0YXRlcywgc2tpcERhdGEsIHNraXBJbmZvLCB0YWJsZSwgdGhpcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBzIG9mIHRhYmxlKVxuICAgICAgICAgICAgICAgIGZpbmlzaEN4LmZpbmlzaChzLCBza2lwU3RhdGUocy5pZCksIGZvcmNlUmVkdWN0aW9uc1tzLmlkXSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGRpYWxlY3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpYWxlY3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZGlhbGVjdHNbdGhpcy5kaWFsZWN0c1tpXV0gPSBkYXRhLnN0b3JlQXJyYXkoKHRoaXMudG9rZW5zLmJ5RGlhbGVjdFtpXSB8fCBub25lKS5tYXAodCA9PiB0LmlkKS5jb25jYXQoNjU1MzUgLyogU2VxLkVuZCAqLykpO1xuICAgICAgICBsZXQgZHluYW1pY1ByZWNlZGVuY2VzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1J1bGVQcmVjZWRlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGR5bmFtaWNQcmVjZWRlbmNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCB7IHJ1bGUsIHByZWMgfSBvZiB0aGlzLmR5bmFtaWNSdWxlUHJlY2VkZW5jZXMpXG4gICAgICAgICAgICAgICAgZHluYW1pY1ByZWNlZGVuY2VzW3J1bGUuaWRdID0gcHJlYztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9wUnVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCB0ZXJtIG9mIHRoaXMudGVybXMudG9wcylcbiAgICAgICAgICAgIHRvcFJ1bGVzW3Rlcm0ubm9kZU5hbWVdID0gW3RhYmxlLmZpbmQoc3RhdGUgPT4gc3RhdGUuc3RhcnRSdWxlID09IHRlcm0pLmlkLCB0ZXJtLmlkXTtcbiAgICAgICAgbGV0IHByZWNUYWJsZSA9IGRhdGEuc3RvcmVBcnJheSh0b2tlblByZWMuY29uY2F0KDY1NTM1IC8qIFNlcS5FbmQgKi8pKTtcbiAgICAgICAgbGV0IHsgbm9kZVByb3BzLCBza2lwcGVkVHlwZXMgfSA9IHRoaXMuZ2F0aGVyTm9kZVByb3BzKG5vZGVUeXBlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZXMsXG4gICAgICAgICAgICBzdGF0ZURhdGE6IGRhdGEuZmluaXNoKCksXG4gICAgICAgICAgICBnb3RvOiBjb21wdXRlR290b1RhYmxlKHRhYmxlKSxcbiAgICAgICAgICAgIG5vZGVOYW1lczogbm9kZVR5cGVzLmZpbHRlcih0ID0+IHQuaWQgPCBtaW5SZXBlYXRUZXJtKS5tYXAodCA9PiB0Lm5vZGVOYW1lKS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgIG5vZGVQcm9wcyxcbiAgICAgICAgICAgIHNraXBwZWRUeXBlcyxcbiAgICAgICAgICAgIG1heFRlcm0sXG4gICAgICAgICAgICByZXBlYXROb2RlQ291bnQ6IG5vZGVUeXBlcy5sZW5ndGggLSBtaW5SZXBlYXRUZXJtLFxuICAgICAgICAgICAgdG9rZW5pemVycyxcbiAgICAgICAgICAgIHRva2VuRGF0YSxcbiAgICAgICAgICAgIHRvcFJ1bGVzLFxuICAgICAgICAgICAgZGlhbGVjdHMsXG4gICAgICAgICAgICBkeW5hbWljUHJlY2VkZW5jZXMsXG4gICAgICAgICAgICBzcGVjaWFsaXplZCxcbiAgICAgICAgICAgIHRva2VuUHJlYzogcHJlY1RhYmxlLFxuICAgICAgICAgICAgdGVybU5hbWVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFBhcnNlcigpIHtcbiAgICAgICAgbGV0IHsgc3RhdGVzLCBzdGF0ZURhdGEsIGdvdG8sIG5vZGVOYW1lcywgbm9kZVByb3BzOiByYXdOb2RlUHJvcHMsIHNraXBwZWRUeXBlcywgbWF4VGVybSwgcmVwZWF0Tm9kZUNvdW50LCB0b2tlbml6ZXJzLCB0b2tlbkRhdGEsIHRvcFJ1bGVzLCBkaWFsZWN0cywgZHluYW1pY1ByZWNlZGVuY2VzLCBzcGVjaWFsaXplZDogcmF3U3BlY2lhbGl6ZWQsIHRva2VuUHJlYywgdGVybU5hbWVzIH0gPSB0aGlzLnByZXBhcmVQYXJzZXIoKTtcbiAgICAgICAgbGV0IHNwZWNpYWxpemVkID0gcmF3U3BlY2lhbGl6ZWQubWFwKHYgPT4ge1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBFeHRlcm5hbFNwZWNpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dCA9IHRoaXMub3B0aW9ucy5leHRlcm5hbFNwZWNpYWxpemVyKHYuYXN0LmlkLm5hbWUsIHRoaXMudGVybVRhYmxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtOiB2LnRlcm0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKGV4dCh2YWx1ZSwgc3RhY2spIDw8IDEpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2LmFzdC50eXBlID09IFwiZXh0ZW5kXCIgPyAxIC8qIFNwZWNpYWxpemUuRXh0ZW5kICovIDogMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pLFxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbDogZXh0LFxuICAgICAgICAgICAgICAgICAgICBleHRlbmQ6IHYuYXN0LnR5cGUgPT0gXCJleHRlbmRcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXJtOiB2LnRva2VuLmlkLCBnZXQ6ICh2YWx1ZSkgPT4gdi50YWJsZVt2YWx1ZV0gfHwgLTEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxNCAvKiBGaWxlLlZlcnNpb24gKi8sXG4gICAgICAgICAgICBzdGF0ZXMsXG4gICAgICAgICAgICBzdGF0ZURhdGEsXG4gICAgICAgICAgICBnb3RvLFxuICAgICAgICAgICAgbm9kZU5hbWVzLFxuICAgICAgICAgICAgbWF4VGVybSxcbiAgICAgICAgICAgIHJlcGVhdE5vZGVDb3VudCxcbiAgICAgICAgICAgIG5vZGVQcm9wczogcmF3Tm9kZVByb3BzLm1hcCgoeyBwcm9wLCB0ZXJtcyB9KSA9PiBbdGhpcy5rbm93blByb3BzW3Byb3BdLnByb3AsIC4uLnRlcm1zXSksXG4gICAgICAgICAgICBwcm9wU291cmNlczogIXRoaXMub3B0aW9ucy5leHRlcm5hbFByb3BTb3VyY2UgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IHRoaXMuYXN0LmV4dGVybmFsUHJvcFNvdXJjZXMubWFwKHMgPT4gdGhpcy5vcHRpb25zLmV4dGVybmFsUHJvcFNvdXJjZShzLmlkLm5hbWUpKSxcbiAgICAgICAgICAgIHNraXBwZWROb2Rlczogc2tpcHBlZFR5cGVzLFxuICAgICAgICAgICAgdG9rZW5EYXRhLFxuICAgICAgICAgICAgdG9rZW5pemVyczogdG9rZW5pemVycy5tYXAodG9rID0+IHRvay5jcmVhdGUoKSksXG4gICAgICAgICAgICBjb250ZXh0OiAhdGhpcy5hc3QuY29udGV4dCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHRoaXMub3B0aW9ucy5jb250ZXh0VHJhY2tlciA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9wdGlvbnMuY29udGV4dFRyYWNrZXIodGhpcy50ZXJtVGFibGUpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmNvbnRleHRUcmFja2VyLFxuICAgICAgICAgICAgdG9wUnVsZXMsXG4gICAgICAgICAgICBkaWFsZWN0cyxcbiAgICAgICAgICAgIGR5bmFtaWNQcmVjZWRlbmNlcyxcbiAgICAgICAgICAgIHNwZWNpYWxpemVkLFxuICAgICAgICAgICAgdG9rZW5QcmVjLFxuICAgICAgICAgICAgdGVybU5hbWVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQYXJzZXJGaWxlKCkge1xuICAgICAgICBsZXQgeyBzdGF0ZXMsIHN0YXRlRGF0YSwgZ290bywgbm9kZU5hbWVzLCBub2RlUHJvcHM6IHJhd05vZGVQcm9wcywgc2tpcHBlZFR5cGVzLCBtYXhUZXJtLCByZXBlYXROb2RlQ291bnQsIHRva2VuaXplcnM6IHJhd1Rva2VuaXplcnMsIHRva2VuRGF0YSwgdG9wUnVsZXMsIGRpYWxlY3RzOiByYXdEaWFsZWN0cywgZHluYW1pY1ByZWNlZGVuY2VzLCBzcGVjaWFsaXplZDogcmF3U3BlY2lhbGl6ZWQsIHRva2VuUHJlYywgdGVybU5hbWVzIH0gPSB0aGlzLnByZXBhcmVQYXJzZXIoKTtcbiAgICAgICAgbGV0IG1vZCA9IHRoaXMub3B0aW9ucy5tb2R1bGVTdHlsZSB8fCBcImVzXCI7XG4gICAgICAgIGxldCBnZW4gPSBcIi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxcblwiLCBoZWFkID0gZ2VuO1xuICAgICAgICBsZXQgaW1wb3J0cyA9IHt9LCBpbXBvcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBkZWZpbmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgd29yZCBvZiBLRVlXT1JEUylcbiAgICAgICAgICAgIGRlZmluZWRbd29yZF0gPSB0cnVlO1xuICAgICAgICBsZXQgZXhwb3J0TmFtZSA9IHRoaXMub3B0aW9ucy5leHBvcnROYW1lIHx8IFwicGFyc2VyXCI7XG4gICAgICAgIGRlZmluZWRbZXhwb3J0TmFtZV0gPSB0cnVlO1xuICAgICAgICBsZXQgZ2V0TmFtZSA9IChwcmVmaXgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gcHJlZml4ICsgKGkgPyBcIl9cIiArIGkgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmluZWRbaWRdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpbXBvcnROYW1lID0gKG5hbWUsIHNvdXJjZSwgcHJlZml4ID0gbmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNwZWMgPSBuYW1lICsgXCIgZnJvbSBcIiArIHNvdXJjZTtcbiAgICAgICAgICAgIGlmIChpbXBvcnRlZFtzcGVjXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0ZWRbc3BlY107XG4gICAgICAgICAgICBsZXQgc3JjID0gSlNPTi5zdHJpbmdpZnkoc291cmNlKSwgdmFyTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBkZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyTmFtZSA9IGdldE5hbWUocHJlZml4KTtcbiAgICAgICAgICAgICAgICBuYW1lICs9IGAke21vZCA9PSBcImNqc1wiID8gXCI6XCIgOiBcIiBhc1wifSAke3Zhck5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZWRbdmFyTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgKGltcG9ydHNbc3JjXSB8fCAoaW1wb3J0c1tzcmNdID0gW10pKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydGVkW3NwZWNdID0gdmFyTmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxyUGFyc2VyID0gaW1wb3J0TmFtZShcIkxSUGFyc2VyXCIsIFwiQGxlemVyL2xyXCIpO1xuICAgICAgICBsZXQgdG9rZW5pemVycyA9IHJhd1Rva2VuaXplcnMubWFwKHRvayA9PiB0b2suY3JlYXRlU291cmNlKGltcG9ydE5hbWUpKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLmFzdC5jb250ZXh0ID8gaW1wb3J0TmFtZSh0aGlzLmFzdC5jb250ZXh0LmlkLm5hbWUsIHRoaXMuYXN0LmNvbnRleHQuc291cmNlKSA6IG51bGw7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSByYXdOb2RlUHJvcHMubWFwKCh7IHByb3AsIHRlcm1zIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZSB9ID0gdGhpcy5rbm93blByb3BzW3Byb3BdO1xuICAgICAgICAgICAgbGV0IHByb3BJRCA9IHNvdXJjZS5mcm9tID8gaW1wb3J0TmFtZShzb3VyY2UubmFtZSwgc291cmNlLmZyb20pIDogSlNPTi5zdHJpbmdpZnkoc291cmNlLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGBbJHtwcm9wSUR9LCAke3Rlcm1zLm1hcChzZXJpYWxpemVQcm9wVmFsdWUpLmpvaW4oXCIsXCIpfV1gO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gc3BlY2lhbGl6YXRpb25UYWJsZVN0cmluZyh0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwie19fcHJvdG9fXzpudWxsLFwiICsgT2JqZWN0LmtleXModGFibGUpLm1hcChrZXkgPT4gYCR7L14oXFxkK3xbYS16QS1aX11cXHcqKSQvLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSl9OiR7dGFibGVba2V5XX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLCBcIikgKyBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BlY0hlYWQgPSBcIlwiO1xuICAgICAgICBsZXQgc3BlY2lhbGl6ZWQgPSByYXdTcGVjaWFsaXplZC5tYXAodiA9PiB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIEV4dGVybmFsU3BlY2lhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGltcG9ydE5hbWUodi5hc3QuaWQubmFtZSwgdi5hc3Quc291cmNlKTtcbiAgICAgICAgICAgICAgICBsZXQgdHMgPSB0aGlzLm9wdGlvbnMudHlwZVNjcmlwdCA/IFwiOiBhbnlcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB7dGVybTogJHt2LnRlcm0uaWR9LCBnZXQ6ICh2YWx1ZSR7dHN9LCBzdGFjayR7dHN9KSA9PiAoJHtuYW1lfSh2YWx1ZSwgc3RhY2spIDw8IDEpJHt2LmFzdC50eXBlID09IFwiZXh0ZW5kXCIgPyBgIHwgJHsxIC8qIFNwZWNpYWxpemUuRXh0ZW5kICovfWAgOiAnJ30sIGV4dGVybmFsOiAke25hbWV9JHt2LmFzdC50eXBlID09IFwiZXh0ZW5kXCIgPyAnLCBleHRlbmQ6IHRydWUnIDogJyd9fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFibGVOYW1lID0gZ2V0TmFtZShcInNwZWNfXCIgKyB2LnRva2VuLm5hbWUucmVwbGFjZSgvXFxXL2csIFwiXCIpKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkW3RhYmxlTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNwZWNIZWFkICs9IGBjb25zdCAke3RhYmxlTmFtZX0gPSAke3NwZWNpYWxpemF0aW9uVGFibGVTdHJpbmcodi50YWJsZSl9XFxuYDtcbiAgICAgICAgICAgICAgICBsZXQgdHMgPSB0aGlzLm9wdGlvbnMudHlwZVNjcmlwdCA/IGA6IGtleW9mIHR5cGVvZiAke3RhYmxlTmFtZX1gIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHt0ZXJtOiAke3YudG9rZW4uaWR9LCBnZXQ6ICh2YWx1ZSR7dHN9KSA9PiAke3RhYmxlTmFtZX1bdmFsdWVdIHx8IC0xfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcHJvcFNvdXJjZXMgPSB0aGlzLmFzdC5leHRlcm5hbFByb3BTb3VyY2VzLm1hcChzID0+IGltcG9ydE5hbWUocy5pZC5uYW1lLCBzLnNvdXJjZSkpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaW1wb3J0cykge1xuICAgICAgICAgICAgaWYgKG1vZCA9PSBcImNqc1wiKVxuICAgICAgICAgICAgICAgIGhlYWQgKz0gYGNvbnN0IHske2ltcG9ydHNbc291cmNlXS5qb2luKFwiLCBcIil9fSA9IHJlcXVpcmUoJHtzb3VyY2V9KVxcbmA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGVhZCArPSBgaW1wb3J0IHske2ltcG9ydHNbc291cmNlXS5qb2luKFwiLCBcIil9fSBmcm9tICR7c291cmNlfVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZCArPSBzcGVjSGVhZDtcbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplUHJvcFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgL14odHJ1ZXxmYWxzZXxcXGQrKFxcLlxcZCspP3xcXC5cXGQrKSQvLnRlc3QodmFsdWUpID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpYWxlY3RzID0gT2JqZWN0LmtleXMocmF3RGlhbGVjdHMpLm1hcChkID0+IGAke2R9OiAke3Jhd0RpYWxlY3RzW2RdfWApO1xuICAgICAgICBsZXQgcGFyc2VyU3RyID0gYCR7bHJQYXJzZXJ9LmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogJHsxNCAvKiBGaWxlLlZlcnNpb24gKi99LFxuICBzdGF0ZXM6ICR7ZW5jb2RlQXJyYXkoc3RhdGVzLCAweGZmZmZmZmZmKX0sXG4gIHN0YXRlRGF0YTogJHtlbmNvZGVBcnJheShzdGF0ZURhdGEpfSxcbiAgZ290bzogJHtlbmNvZGVBcnJheShnb3RvKX0sXG4gIG5vZGVOYW1lczogJHtKU09OLnN0cmluZ2lmeShub2RlTmFtZXMpfSxcbiAgbWF4VGVybTogJHttYXhUZXJtfSR7Y29udGV4dCA/IGAsXG4gIGNvbnRleHQ6ICR7Y29udGV4dH1gIDogXCJcIn0ke25vZGVQcm9wcy5sZW5ndGggPyBgLFxuICBub2RlUHJvcHM6IFtcbiAgICAke25vZGVQcm9wcy5qb2luKFwiLFxcbiAgICBcIil9XG4gIF1gIDogXCJcIn0ke3Byb3BTb3VyY2VzLmxlbmd0aCA/IGAsXG4gIHByb3BTb3VyY2VzOiBbJHtwcm9wU291cmNlcy5qb2luKCl9XWAgOiBcIlwifSR7c2tpcHBlZFR5cGVzLmxlbmd0aCA/IGAsXG4gIHNraXBwZWROb2RlczogJHtKU09OLnN0cmluZ2lmeShza2lwcGVkVHlwZXMpfWAgOiBcIlwifSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAke3JlcGVhdE5vZGVDb3VudH0sXG4gIHRva2VuRGF0YTogJHtlbmNvZGVBcnJheSh0b2tlbkRhdGEpfSxcbiAgdG9rZW5pemVyczogWyR7dG9rZW5pemVycy5qb2luKFwiLCBcIil9XSxcbiAgdG9wUnVsZXM6ICR7SlNPTi5zdHJpbmdpZnkodG9wUnVsZXMpfSR7ZGlhbGVjdHMubGVuZ3RoID8gYCxcbiAgZGlhbGVjdHM6IHske2RpYWxlY3RzLmpvaW4oXCIsIFwiKX19YCA6IFwiXCJ9JHtkeW5hbWljUHJlY2VkZW5jZXMgPyBgLFxuICBkeW5hbWljUHJlY2VkZW5jZXM6ICR7SlNPTi5zdHJpbmdpZnkoZHluYW1pY1ByZWNlZGVuY2VzKX1gIDogXCJcIn0ke3NwZWNpYWxpemVkLmxlbmd0aCA/IGAsXG4gIHNwZWNpYWxpemVkOiBbJHtzcGVjaWFsaXplZC5qb2luKFwiLFwiKX1dYCA6IFwiXCJ9LFxuICB0b2tlblByZWM6ICR7dG9rZW5QcmVjfSR7dGhpcy5vcHRpb25zLmluY2x1ZGVOYW1lcyA/IGAsXG4gIHRlcm1OYW1lczogJHtKU09OLnN0cmluZ2lmeSh0ZXJtTmFtZXMpfWAgOiAnJ31cbn0pYDtcbiAgICAgICAgbGV0IHRlcm1zID0gW107XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy50ZXJtVGFibGUpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IG5hbWU7XG4gICAgICAgICAgICBpZiAoS0VZV09SRFMuaW5jbHVkZXMoaWQpKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gXCJfXCIucmVwZWF0KGkpICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaWQgaW4gdGhpcy50ZXJtVGFibGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIS9eW1xcdyRdKyQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlcm1zLnB1c2goYCR7aWR9JHttb2QgPT0gXCJjanNcIiA/IFwiOlwiIDogXCIgPVwifSAke3RoaXMudGVybVRhYmxlW25hbWVdfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGlkID0gMDsgaWQgPCB0aGlzLmRpYWxlY3RzLmxlbmd0aDsgaWQrKylcbiAgICAgICAgICAgIHRlcm1zLnB1c2goYERpYWxlY3RfJHt0aGlzLmRpYWxlY3RzW2lkXX0ke21vZCA9PSBcImNqc1wiID8gXCI6XCIgOiBcIiA9XCJ9ICR7aWR9YCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJzZXI6IGhlYWQgKyAobW9kID09IFwiY2pzXCIgPyBgZXhwb3J0cy4ke2V4cG9ydE5hbWV9ID0gJHtwYXJzZXJTdHJ9XFxuYCA6IGBleHBvcnQgY29uc3QgJHtleHBvcnROYW1lfSA9ICR7cGFyc2VyU3RyfVxcbmApLFxuICAgICAgICAgICAgdGVybXM6IG1vZCA9PSBcImNqc1wiID8gYCR7Z2VufW1vZHVsZS5leHBvcnRzID0ge1xcbiAgJHt0ZXJtcy5qb2luKFwiLFxcbiAgXCIpfVxcbn1gXG4gICAgICAgICAgICAgICAgOiBgJHtnZW59ZXhwb3J0IGNvbnN0XFxuICAke3Rlcm1zLmpvaW4oXCIsXFxuICBcIil9XFxuYFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnYXRoZXJOb25Ta2lwcGVkTm9kZXMoKSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHdvcmsgPSBbXTtcbiAgICAgICAgbGV0IGFkZCA9ICh0ZXJtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNlZW5bdGVybS5pZF0pIHtcbiAgICAgICAgICAgICAgICBzZWVuW3Rlcm0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrLnB1c2godGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGVybXMudG9wcy5mb3JFYWNoKGFkZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiB3b3JrW2ldLnJ1bGVzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgcnVsZS5wYXJ0cylcbiAgICAgICAgICAgICAgICAgICAgYWRkKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWVuO1xuICAgIH1cbiAgICBnYXRoZXJOb2RlUHJvcHMobm9kZVR5cGVzKSB7XG4gICAgICAgIGxldCBub3RTa2lwcGVkID0gdGhpcy5nYXRoZXJOb25Ta2lwcGVkTm9kZXMoKSwgc2tpcHBlZFR5cGVzID0gW107XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBvZiBub2RlVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICghbm90U2tpcHBlZFt0eXBlLmlkXSAmJiAhdHlwZS5lcnJvcilcbiAgICAgICAgICAgICAgICBza2lwcGVkVHlwZXMucHVzaCh0eXBlLmlkKTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gdHlwZS5wcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMua25vd25Qcm9wc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWtub3duKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2VuRXJyb3IoXCJObyBrbm93biBwcm9wIHR5cGUgZm9yIFwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duLnNvdXJjZS5mcm9tID09IG51bGwgJiYgKGtub3duLnNvdXJjZS5uYW1lID09IFwicmVwZWF0ZWRcIiB8fCBrbm93bi5zb3VyY2UubmFtZSA9PSBcImVycm9yXCIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgcmVjID0gbm9kZVByb3BzLmZpbmQociA9PiByLnByb3AgPT0gcHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWMpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKHJlYyA9IHsgcHJvcCwgdmFsdWVzOiB7fSB9KTtcbiAgICAgICAgICAgICAgICAocmVjLnZhbHVlc1t0eXBlLnByb3BzW3Byb3BdXSB8fCAocmVjLnZhbHVlc1t0eXBlLnByb3BzW3Byb3BdXSA9IFtdKSkucHVzaCh0eXBlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZVByb3BzOiBub2RlUHJvcHMubWFwKCh7IHByb3AsIHZhbHVlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWRzID0gdmFsdWVzW3ZhbF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zLnB1c2goaWRzWzBdLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybXMucHVzaCgtaWRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpZCBvZiBpZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybXMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvcCwgdGVybXMgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2tpcHBlZFR5cGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1ha2VUZXJtaW5hbChuYW1lLCB0YWcsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1zLm1ha2VUZXJtaW5hbCh0aGlzLnRlcm1zLnVuaXF1ZU5hbWUobmFtZSksIHRhZywgcHJvcHMpO1xuICAgIH1cbiAgICBjb21wdXRlRm9yY2VSZWR1Y3Rpb25zKHN0YXRlcywgc2tpcEluZm8pIHtcbiAgICAgICAgLy8gVGhpcyBmaW5kcyBhIGZvcmNlZCByZWR1Y3Rpb24gZm9yIGV2ZXJ5IHN0YXRlLCB0cnlpbmcgdG8gZ3VhcmRcbiAgICAgICAgLy8gYWdhaW5zdCBjeWNsaWMgZm9yY2VkIHJlZHVjdGlvbnMsIHdoZXJlIGEgZ2l2ZW4gcGFyc2Ugc3RhY2sgY2FuXG4gICAgICAgIC8vIGVuZGxlc3NseSBjb250aW51ZSBydW5uaW5nIGZvcmNlZCByZWR1Y3Rpb25zIHdpdGhvdXQgbWFraW5nIGFueVxuICAgICAgICAvLyBwcm9ncmVzcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBvY2N1cnMgd2l0aCBsZW5ndGgtMSByZWR1Y3Rpb25zLiBXZSBuZXZlciBnZW5lcmF0ZVxuICAgICAgICAvLyBsZW5ndGgtMCByZWR1Y3Rpb25zLCBhbmQgbGVuZ3RoLTIrIHJlZHVjdGlvbnMgYWx3YXlzIHNocmluayB0aGVcbiAgICAgICAgLy8gc3RhY2ssIHNvIHRoZXkgYXJlIGd1YXJhbnRlZWQgdG8gbWFrZSBwcm9ncmVzcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHN0YXRlcyBTMSBhbmQgUzIgd2hvc2UgZm9yY2VkIHJlZHVjdGlvbnMgcmVkdWNlXG4gICAgICAgIC8vIHRlcm1zIFQxIGFuZCBUMiByZXNwZWN0aXZlbHksIGJvdGggd2l0aCBhIGxlbmd0aCBvZiAxLCBfYW5kX1xuICAgICAgICAvLyB0aGVyZSBpcyBhIHN0YXRlIFMzLCB3aGljaCBoYXMgZ290byBlbnRyaWVzIFQxIC0+IFMyLCBUMiAtPiBTMSxcbiAgICAgICAgLy8geW91IGNhbiBnZXQgY3ljbGljIHJlZHVjdGlvbnMuIE9mIGNvdXJzZSwgdGhlIGN5Y2xlIG1heSBhbHNvXG4gICAgICAgIC8vIGNvbnRhaW4gbW9yZSB0aGFuIHR3byBzdGVwcy5cbiAgICAgICAgbGV0IHJlZHVjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gQSBtYXAgZnJvbSB0ZXJtcyB0byBzdGF0ZXMgdGhhdCB0aGV5IGFyZSBtYXBwZWQgdG8gaW4gZ290b1xuICAgICAgICAvLyBlbnRyaWVzLlxuICAgICAgICBsZXQgZ290b0VkZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICByZWR1Y3Rpb25zLnB1c2goMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBlZGdlIG9mIHN0YXRlLmdvdG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyYXkgPSBnb3RvRWRnZXNbZWRnZS50ZXJtLmlkXSB8fCAoZ290b0VkZ2VzW2VkZ2UudGVybS5pZF0gPSBbXSk7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gYXJyYXkuZmluZChvID0+IG8udGFyZ2V0ID09IGVkZ2UudGFyZ2V0LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnBhcmVudHMucHVzaChzdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHsgcGFyZW50czogW3N0YXRlLmlkXSwgdGFyZ2V0OiBlZGdlLnRhcmdldC5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbmRpZGF0ZXNbc3RhdGUuaWRdID0gc3RhdGUuc2V0LmZpbHRlcihwb3MgPT4gcG9zLnBvcyA+IDAgJiYgIXBvcy5ydWxlLm5hbWUudG9wKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnBvcyAtIGEucG9zIHx8IGEucnVsZS5wYXJ0cy5sZW5ndGggLSBiLnJ1bGUucGFydHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXBwaW5nIGZyb20gc3RhdGUgaWRzIHRvIHRlcm1zIHRoYXQgdGhhdCBzdGF0ZSBoYXMgYSBsZW5ndGgtMVxuICAgICAgICAvLyBmb3JjZWQgcmVkdWN0aW9uIGZvci5cbiAgICAgICAgbGV0IGxlbmd0aDFSZWR1Y3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlc0N5Y2xlKHRlcm0sIHN0YXJ0U3RhdGUsIHBhcmVudHMgPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZWRnZXMgPSBnb3RvRWRnZXNbdGVybV07XG4gICAgICAgICAgICBpZiAoIWVkZ2VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBlZGdlcy5zb21lKHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudEludGVyc2VjdGlvbiA9IHBhcmVudHMgPyBwYXJlbnRzLmZpbHRlcihpZCA9PiB2YWwucGFyZW50cy5pbmNsdWRlcyhpZCkpIDogdmFsLnBhcmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEludGVyc2VjdGlvbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh2YWwudGFyZ2V0ID09IHN0YXJ0U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGxlbmd0aDFSZWR1Y3Rpb25zW3ZhbC50YXJnZXRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCAhPSBudWxsICYmIGNyZWF0ZXNDeWNsZShmb3VuZCwgc3RhcnRTdGF0ZSwgcGFyZW50SW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHN0YXRlIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmRlZmF1bHRSZWR1Y2UgJiYgc3RhdGUuZGVmYXVsdFJlZHVjZS5wYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVkdWN0aW9uc1tzdGF0ZS5pZF0gPSByZWR1Y2VBY3Rpb24oc3RhdGUuZGVmYXVsdFJlZHVjZSwgc2tpcEluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5kZWZhdWx0UmVkdWNlLnBhcnRzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgxUmVkdWN0aW9uc1tzdGF0ZS5pZF0gPSBzdGF0ZS5kZWZhdWx0UmVkdWNlLm5hbWUuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gYXZvaWQgcGFpbnRpbmcgc3RhdGVzIHRoYXQgb25seSBoYXZlIG9uZSBwb3RlbnRpYWwgZm9yY2VkXG4gICAgICAgIC8vIHJlZHVjdGlvbiBpbnRvIGEgY29ybmVyLCByZWR1Y3Rpb24gYXNzaWdubWVudCBpcyBkb25lIGJ5XG4gICAgICAgIC8vIGNhbmRpZGF0ZSBzaXplLCBzdGFydGluZyB3aXRoIHRoZSBzdGF0ZXMgd2l0aCBmZXdlciBjYW5kaWRhdGVzLlxuICAgICAgICBmb3IgKGxldCBzZXRTaXplID0gMTs7IHNldFNpemUrKykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRlZmF1bHRSZWR1Y2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBzZXQgPSBjYW5kaWRhdGVzW3N0YXRlLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCAhPSBzZXRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID4gc2V0U2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5wb3MgIT0gMSB8fCAhY3JlYXRlc0N5Y2xlKHBvcy5ydWxlLm5hbWUuaWQsIHN0YXRlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVkdWN0aW9uc1tzdGF0ZS5pZF0gPSByZWR1Y2VBY3Rpb24ocG9zLnJ1bGUsIHNraXBJbmZvLCBwb3MucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MucG9zID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMVJlZHVjdGlvbnNbc3RhdGUuaWRdID0gcG9zLnJ1bGUubmFtZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZHVjdGlvbnM7XG4gICAgfVxuICAgIHN1YnN0aXR1dGVBcmdzKGV4cHIsIGFyZ3MsIHBhcmFtcykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICByZXR1cm4gZXhwci53YWxrKGV4cHIgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBOYW1lRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgIChmb3VuZCA9IHBhcmFtcy5maW5kSW5kZXgocCA9PiBwLm5hbWUgPT0gZXhwci5pZC5uYW1lKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZUV4cHJlc3Npb24gJiYgIWFyZy5hcmdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZUV4cHJlc3Npb24oZXhwci5zdGFydCwgYXJnLmlkLCBleHByLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKGBQYXNzaW5nIGFyZ3VtZW50cyB0byBhIHBhcmFtZXRlciB0aGF0IGFscmVhZHkgaGFzIGFyZ3VtZW50c2AsIGV4cHIuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIElubGluZVJ1bGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBleHByLnJ1bGUsIHByb3BzID0gdGhpcy5zdWJzdGl0dXRlQXJnc0luUHJvcHMoci5wcm9wcywgYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMgPT0gci5wcm9wcyA/IGV4cHIgOlxuICAgICAgICAgICAgICAgICAgICBuZXcgSW5saW5lUnVsZUV4cHJlc3Npb24oZXhwci5zdGFydCwgbmV3IFJ1bGVEZWNsYXJhdGlvbihyLnN0YXJ0LCByLmlkLCBwcm9wcywgci5wYXJhbXMsIHIuZXhwcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIFNwZWNpYWxpemVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3BzID0gdGhpcy5zdWJzdGl0dXRlQXJnc0luUHJvcHMoZXhwci5wcm9wcywgYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMgPT0gZXhwci5wcm9wcyA/IGV4cHIgOlxuICAgICAgICAgICAgICAgICAgICBuZXcgU3BlY2lhbGl6ZUV4cHJlc3Npb24oZXhwci5zdGFydCwgZXhwci50eXBlLCBwcm9wcywgZXhwci50b2tlbiwgZXhwci5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic3RpdHV0ZUFyZ3NJblByb3BzKHByb3BzLCBhcmdzLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IHN1YnN0aXR1dGVJblZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gcGFyYW1zLmZpbmRJbmRleChwID0+IHAubmFtZSA9PSBwYXJ0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGV4cHIgPSBhcmdzW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIE5hbWVFeHByZXNzaW9uICYmICFleHByLmFyZ3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBuZXcgUHJvcFBhcnQocGFydC5zdGFydCwgZXhwci5pZC5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ldyBQcm9wUGFydChwYXJ0LnN0YXJ0LCBleHByLnZhbHVlLCBudWxsKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoYFRyeWluZyB0byBpbnRlcnBvbGF0ZSBleHByZXNzaW9uICcke2V4cHJ9JyBpbnRvIGEgcHJvcGAsIHBhcnQuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHByb3BzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BzW2ldLCB2YWx1ZSA9IHN1YnN0aXR1dGVJblZhbHVlKHByb3AudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IHByb3AudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IHByb3BzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9wcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ldyBQcm9wKHByb3Auc3RhcnQsIHByb3AuYXQsIHByb3AubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbmZsaWN0c0ZvcihtYXJrZXJzKSB7XG4gICAgICAgIGxldCBoZXJlID0gQ29uZmxpY3RzLm5vbmUsIGF0RW5kID0gQ29uZmxpY3RzLm5vbmU7XG4gICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICBpZiAobWFya2VyLnR5cGUgPT0gXCJhbWJpZ1wiKSB7XG4gICAgICAgICAgICAgICAgaGVyZSA9IGhlcmUuam9pbihuZXcgQ29uZmxpY3RzKDAsIFttYXJrZXIuaWQubmFtZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmVjcyA9IHRoaXMuYXN0LnByZWNlZGVuY2VzO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHByZWNzID8gcHJlY3MuaXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5pZC5uYW1lID09IG1hcmtlci5pZC5uYW1lKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoYFJlZmVyZW5jZSB0byB1bmtub3duIHByZWNlZGVuY2U6ICcke21hcmtlci5pZC5uYW1lfSdgLCBtYXJrZXIuaWQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBwcmVjID0gcHJlY3MuaXRlbXNbaW5kZXhdLCB2YWx1ZSA9IHByZWNzLml0ZW1zLmxlbmd0aCAtIGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChwcmVjLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgICAgICAgICAgICBoZXJlID0gaGVyZS5qb2luKG5ldyBDb25mbGljdHMoMCwgbm9uZSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlcmUgPSBoZXJlLmpvaW4obmV3IENvbmZsaWN0cyh2YWx1ZSA8PCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGF0RW5kID0gYXRFbmQuam9pbihuZXcgQ29uZmxpY3RzKCh2YWx1ZSA8PCAyKSArIChwcmVjLnR5cGUgPT0gXCJsZWZ0XCIgPyAxIDogcHJlYy50eXBlID09IFwicmlnaHRcIiA/IC0xIDogMCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGVyZSwgYXRFbmQgfTtcbiAgICB9XG4gICAgcmFpc2UobWVzc2FnZSwgcG9zID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yYWlzZShtZXNzYWdlLCBwb3MpO1xuICAgIH1cbiAgICB3YXJuKG1lc3NhZ2UsIHBvcyA9IC0xKSB7XG4gICAgICAgIGxldCBtc2cgPSB0aGlzLmlucHV0Lm1lc3NhZ2UobWVzc2FnZSwgcG9zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53YXJuKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLndhcm4obXNnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfVxuICAgIGRlZmluZVJ1bGUobmFtZSwgY2hvaWNlcykge1xuICAgICAgICBsZXQgc2tpcCA9IHRoaXMuY3VycmVudFNraXBbdGhpcy5jdXJyZW50U2tpcC5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChsZXQgY2hvaWNlIG9mIGNob2ljZXMpXG4gICAgICAgICAgICB0aGlzLnJ1bGVzLnB1c2gobmV3IFJ1bGUobmFtZSwgY2hvaWNlLnRlcm1zLCBjaG9pY2UuZW5zdXJlQ29uZmxpY3RzKCksIHNraXApKTtcbiAgICB9XG4gICAgcmVzb2x2ZShleHByKSB7XG4gICAgICAgIGZvciAobGV0IGJ1aWx0IG9mIHRoaXMuYnVpbHQpXG4gICAgICAgICAgICBpZiAoYnVpbHQubWF0Y2hlcyhleHByKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW3AoYnVpbHQudGVybSldO1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnRva2Vucy5nZXRUb2tlbihleHByKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIFtwKGZvdW5kKV07XG4gICAgICAgIGZvciAobGV0IGdycCBvZiB0aGlzLmxvY2FsVG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBncnAuZ2V0VG9rZW4oZXhwcik7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwKGZvdW5kKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZXh0IG9mIHRoaXMuZXh0ZXJuYWxUb2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGV4dC5nZXRUb2tlbihleHByKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gW3AoZm91bmQpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBleHQgb2YgdGhpcy5leHRlcm5hbFNwZWNpYWxpemVycykge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZXh0LmdldFRva2VuKGV4cHIpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBbcChmb3VuZCldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrbm93biA9IHRoaXMuYXN0UnVsZXMuZmluZChyID0+IHIucnVsZS5pZC5uYW1lID09IGV4cHIuaWQubmFtZSk7XG4gICAgICAgIGlmICgha25vd24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYWlzZShgUmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBydWxlICcke2V4cHIuaWQubmFtZX0nYCwgZXhwci5zdGFydCk7XG4gICAgICAgIGlmIChrbm93bi5ydWxlLnBhcmFtcy5sZW5ndGggIT0gZXhwci5hcmdzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucmFpc2UoYFdyb25nIG51bWJlciBvciBhcmd1bWVudHMgZm9yICcke2V4cHIuaWQubmFtZX0nYCwgZXhwci5zdGFydCk7XG4gICAgICAgIHRoaXMudXNlZChrbm93bi5ydWxlLmlkLm5hbWUpO1xuICAgICAgICByZXR1cm4gW3AodGhpcy5idWlsZFJ1bGUoa25vd24ucnVsZSwgZXhwci5hcmdzLCBrbm93bi5za2lwKSldO1xuICAgIH1cbiAgICAvLyBGb3IgdHJlZS1iYWxhbmNpbmcgcmVhc29ucywgcmVwZWF0IGV4cHJlc3Npb25zIFgrIGhhdmUgdG8gYmVcbiAgICAvLyBub3JtYWxpemVkIHRvIHNvbWV0aGluZyBsaWtlXG4gICAgLy9cbiAgICAvLyAgICAgUiAtPiBYIHwgUiBSXG4gICAgLy9cbiAgICAvLyBSZXR1cm5zIHRoZSBgUmAgdGVybS5cbiAgICBub3JtYWxpemVSZXBlYXQoZXhwcikge1xuICAgICAgICBsZXQga25vd24gPSB0aGlzLmJ1aWx0LmZpbmQoYiA9PiBiLm1hdGNoZXNSZXBlYXQoZXhwcikpO1xuICAgICAgICBpZiAoa25vd24pXG4gICAgICAgICAgICByZXR1cm4gcChrbm93bi50ZXJtKTtcbiAgICAgICAgbGV0IG5hbWUgPSBleHByLmV4cHIucHJlYyA8IGV4cHIucHJlYyA/IGAoJHtleHByLmV4cHJ9KStgIDogYCR7ZXhwci5leHByfStgO1xuICAgICAgICBsZXQgdGVybSA9IHRoaXMudGVybXMubWFrZVJlcGVhdCh0aGlzLnRlcm1zLnVuaXF1ZU5hbWUobmFtZSkpO1xuICAgICAgICB0aGlzLmJ1aWx0LnB1c2gobmV3IEJ1aWx0UnVsZShcIitcIiwgW2V4cHIuZXhwcl0sIHRlcm0pKTtcbiAgICAgICAgdGhpcy5kZWZpbmVSdWxlKHRlcm0sIHRoaXMubm9ybWFsaXplRXhwcihleHByLmV4cHIpLmNvbmNhdChwKHRlcm0sIHRlcm0pKSk7XG4gICAgICAgIHJldHVybiBwKHRlcm0pO1xuICAgIH1cbiAgICBub3JtYWxpemVTZXF1ZW5jZShleHByKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBleHByLmV4cHJzLm1hcChlID0+IHRoaXMubm9ybWFsaXplRXhwcihlKSk7XG4gICAgICAgIGxldCBidWlsZGVyID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gY29tcGxldGUoc3RhcnQsIGZyb20sIGVuZENvbmZsaWN0cykge1xuICAgICAgICAgICAgbGV0IHsgaGVyZSwgYXRFbmQgfSA9IGJ1aWxkZXIuY29uZmxpY3RzRm9yKGV4cHIubWFya2Vyc1tmcm9tXSk7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSByZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc3RhcnQud2l0aENvbmZsaWN0cyhzdGFydC50ZXJtcy5sZW5ndGgsIGhlcmUuam9pbihlbmRDb25mbGljdHMpKV07XG4gICAgICAgICAgICBsZXQgY2hvaWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hvaWNlIG9mIHJlc3VsdFtmcm9tXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZ1bGwgb2YgY29tcGxldGUoc3RhcnQuY29uY2F0KGNob2ljZSkud2l0aENvbmZsaWN0cyhzdGFydC50ZXJtcy5sZW5ndGgsIGhlcmUpLCBmcm9tICsgMSwgZW5kQ29uZmxpY3RzLmpvaW4oYXRFbmQpKSlcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlcy5wdXNoKGZ1bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNob2ljZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlKFBhcnRzLm5vbmUsIDAsIENvbmZsaWN0cy5ub25lKTtcbiAgICB9XG4gICAgbm9ybWFsaXplRXhwcihleHByKSB7XG4gICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgUmVwZWF0RXhwcmVzc2lvbiAmJiBleHByLmtpbmQgPT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbUGFydHMubm9uZSwgLi4udGhpcy5ub3JtYWxpemVFeHByKGV4cHIuZXhwcildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBSZXBlYXRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgcmVwZWF0ZWQgPSB0aGlzLm5vcm1hbGl6ZVJlcGVhdChleHByKTtcbiAgICAgICAgICAgIHJldHVybiBleHByLmtpbmQgPT0gXCIrXCIgPyBbcmVwZWF0ZWRdIDogW1BhcnRzLm5vbmUsIHJlcGVhdGVkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQ2hvaWNlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHIuZXhwcnMucmVkdWNlKChvLCBlKSA9PiBvLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZUV4cHIoZSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIFNlcXVlbmNlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplU2VxdWVuY2UoZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gW3AodGhpcy50b2tlbnMuZ2V0TGl0ZXJhbChleHByKSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBOYW1lRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZShleHByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgU3BlY2lhbGl6ZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBbcCh0aGlzLnJlc29sdmVTcGVjaWFsaXphdGlvbihleHByKSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBJbmxpbmVSdWxlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIFtwKHRoaXMuYnVpbGRSdWxlKGV4cHIucnVsZSwgbm9uZSwgdGhpcy5jdXJyZW50U2tpcFt0aGlzLmN1cnJlbnRTa2lwLmxlbmd0aCAtIDFdLCB0cnVlKSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFpc2UoYFRoaXMgdHlwZSBvZiBleHByZXNzaW9uICgnJHtleHByfScpIG1heSBub3Qgb2NjdXIgaW4gbm9uLXRva2VuIHJ1bGVzYCwgZXhwci5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRSdWxlKHJ1bGUsIGFyZ3MsIHNraXAsIGlubGluZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBleHByID0gdGhpcy5zdWJzdGl0dXRlQXJncyhydWxlLmV4cHIsIGFyZ3MsIHJ1bGUucGFyYW1zKTtcbiAgICAgICAgbGV0IHsgbmFtZTogbm9kZU5hbWUsIHByb3BzLCBkeW5hbWljUHJlYywgaW5saW5lOiBleHBsaWNpdElubGluZSwgZ3JvdXAsIGV4cG9ydGVkIH0gPSB0aGlzLm5vZGVJbmZvKHJ1bGUucHJvcHMgfHwgbm9uZSwgaW5saW5lID8gXCJwZ1wiIDogXCJwZ2lcIiwgcnVsZS5pZC5uYW1lLCBhcmdzLCBydWxlLnBhcmFtcywgcnVsZS5leHByKTtcbiAgICAgICAgaWYgKGV4cG9ydGVkICYmIHJ1bGUucGFyYW1zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMud2FybihgQ2FuJ3QgZXhwb3J0IHBhcmFtZXRlcml6ZWQgcnVsZXNgLCBydWxlLnN0YXJ0KTtcbiAgICAgICAgaWYgKGV4cG9ydGVkICYmIGlubGluZSlcbiAgICAgICAgICAgIHRoaXMud2FybihgQ2FuJ3QgZXhwb3J0IGlubGluZSBydWxlYCwgcnVsZS5zdGFydCk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5uZXdOYW1lKHJ1bGUuaWQubmFtZSArIChhcmdzLmxlbmd0aCA/IFwiPFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiPlwiIDogXCJcIiksIG5vZGVOYW1lIHx8IHRydWUsIHByb3BzKTtcbiAgICAgICAgaWYgKGV4cGxpY2l0SW5saW5lKVxuICAgICAgICAgICAgbmFtZS5pbmxpbmUgPSB0cnVlO1xuICAgICAgICBpZiAoZHluYW1pY1ByZWMpXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRHluYW1pY1ByZWMobmFtZSwgZHluYW1pY1ByZWMpO1xuICAgICAgICBpZiAoKG5hbWUubm9kZVR5cGUgfHwgZXhwb3J0ZWQpICYmIHJ1bGUucGFyYW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGVOYW1lKVxuICAgICAgICAgICAgICAgIG5hbWUucHJlc2VydmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFpbmxpbmUpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lZFRlcm1zW2V4cG9ydGVkIHx8IHJ1bGUuaWQubmFtZV0gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5saW5lKVxuICAgICAgICAgICAgdGhpcy5idWlsdC5wdXNoKG5ldyBCdWlsdFJ1bGUocnVsZS5pZC5uYW1lLCBhcmdzLCBuYW1lKSk7XG4gICAgICAgIHRoaXMuY3VycmVudFNraXAucHVzaChza2lwKTtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5ub3JtYWxpemVFeHByKGV4cHIpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMTAwICogKGV4cHIgaW5zdGFuY2VvZiBDaG9pY2VFeHByZXNzaW9uID8gZXhwci5leHBycy5sZW5ndGggOiAxKSlcbiAgICAgICAgICAgIHRoaXMud2FybihgUnVsZSAke3J1bGUuaWQubmFtZX0gaXMgZ2VuZXJhdGluZyBhIGxvdCAoJHtwYXJ0cy5sZW5ndGh9KSBvZiBjaG9pY2VzLlxcbiAgQ29uc2lkZXIgc3BsaXR0aW5nIGl0IHVwIG9yIHJlZHVjaW5nIHRoZSBhbW91bnQgb2YgPyBvciB8IG9wZXJhdG9yIHVzZXMuYCwgcnVsZS5zdGFydCk7XG4gICAgICAgIGlmICgvXFxicnVsZXNpemVcXGIvLnRlc3QodmVyYm9zZSkgJiYgcGFydHMubGVuZ3RoID4gMTApXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUnVsZSAke3J1bGUuaWQubmFtZX06ICR7cGFydHMubGVuZ3RofSB2YXJpYW50c2ApO1xuICAgICAgICB0aGlzLmRlZmluZVJ1bGUobmFtZSwgcGFydHMpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTa2lwLnBvcCgpO1xuICAgICAgICBpZiAoZ3JvdXApXG4gICAgICAgICAgICB0aGlzLmRlZmluZWRHcm91cHMucHVzaCh7IG5hbWUsIGdyb3VwLCBydWxlIH0pO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgbm9kZUluZm8ocHJvcHMsIFxuICAgIC8vIHAgZm9yIGR5bmFtaWMgcHJlY2VkZW5jZSwgZCBmb3IgZGlhbGVjdCwgaSBmb3IgaW5saW5lLCBnIGZvciBncm91cCwgYSBmb3IgZGlzYWJsaW5nIHRoZSBpZ25vcmUgdGVzdCBmb3IgZGVmYXVsdCBuYW1lXG4gICAgYWxsb3csIGRlZmF1bHROYW1lID0gbnVsbCwgYXJncyA9IG5vbmUsIHBhcmFtcyA9IG5vbmUsIGV4cHIsIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBuYW1lID0gZGVmYXVsdE5hbWUgJiYgKGFsbG93LmluZGV4T2YoXCJhXCIpID4gLTEgfHwgIWlnbm9yZWQoZGVmYXVsdE5hbWUpKSAmJiAhLyAvLnRlc3QoZGVmYXVsdE5hbWUpID8gZGVmYXVsdE5hbWUgOiBudWxsO1xuICAgICAgICBsZXQgZGlhbGVjdCA9IG51bGwsIGR5bmFtaWNQcmVjID0gMCwgaW5saW5lID0gZmFsc2UsIGdyb3VwID0gbnVsbCwgZXhwb3J0ZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXByb3AuYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMua25vd25Qcm9wc1twcm9wLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBidWlsdGluID0gW1wibmFtZVwiLCBcImRpYWxlY3RcIiwgXCJkeW5hbWljUHJlY2VkZW5jZVwiLCBcImV4cG9ydFwiLCBcImlzR3JvdXBcIl0uaW5jbHVkZXMocHJvcC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgIChkaWQgeW91IG1lYW4gJ0Ake3Byb3AubmFtZX0nPylgIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWlzZShgVW5rbm93biBwcm9wIG5hbWUgJyR7cHJvcC5uYW1lfScke2J1aWx0aW59YCwgcHJvcC5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wLm5hbWVdID0gdGhpcy5maW5pc2hQcm9wKHByb3AsIGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wLm5hbWUgPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5maW5pc2hQcm9wKHByb3AsIGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKC8gLy50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKGBOb2RlIG5hbWVzIGNhbm5vdCBoYXZlIHNwYWNlcyAoJyR7bmFtZX0nKWAsIHByb3Auc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcC5uYW1lID09IFwiZGlhbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93LmluZGV4T2YoXCJkXCIpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWlzZShcIkNhbid0IHNwZWNpZnkgYSBkaWFsZWN0IG9uIG5vbi10b2tlbiBydWxlc1wiLCBwcm9wc1swXS5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudmFsdWUubGVuZ3RoICE9IDEgJiYgIXByb3AudmFsdWVbMF0udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoXCJUaGUgJ0BkaWFsZWN0JyBydWxlIHByb3AgbXVzdCBob2xkIGEgcGxhaW4gc3RyaW5nIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkaWFsZWN0SUQgPSB0aGlzLmRpYWxlY3RzLmluZGV4T2YocHJvcC52YWx1ZVswXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3RJRCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoYFVua25vd24gZGlhbGVjdCAnJHtwcm9wLnZhbHVlWzBdLnZhbHVlfSdgLCBwcm9wLnZhbHVlWzBdLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBkaWFsZWN0ID0gZGlhbGVjdElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcC5uYW1lID09IFwiZHluYW1pY1ByZWNlZGVuY2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvdy5pbmRleE9mKFwicFwiKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoXCJEeW5hbWljIHByZWNlZGVuY2UgY2FuIG9ubHkgYmUgc3BlY2lmaWVkIG9uIG5vbnRlcm1pbmFsc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcC52YWx1ZS5sZW5ndGggIT0gMSB8fCAhL14tPyg/OjEwfFxcZCkkLy50ZXN0KHByb3AudmFsdWVbMF0udmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKFwiVGhlICdAZHluYW1pY1ByZWNlZGVuY2UnIHJ1bGUgcHJvcCBtdXN0IGhvbGQgYW4gaW50ZWdlciBiZXR3ZWVuIC0xMCBhbmQgMTBcIik7XG4gICAgICAgICAgICAgICAgZHluYW1pY1ByZWMgPSArcHJvcC52YWx1ZVswXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3AubmFtZSA9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKFwiJ0BpbmxpbmUnIGRvZXNuJ3QgdGFrZSBhIHZhbHVlXCIsIHByb3AudmFsdWVbMF0uc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChhbGxvdy5pbmRleE9mKFwiaVwiKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoXCJJbmxpbmUgY2FuIG9ubHkgYmUgc3BlY2lmaWVkIG9uIG5vbnRlcm1pbmFsc1wiKTtcbiAgICAgICAgICAgICAgICBpbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcC5uYW1lID09IFwiaXNHcm91cFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93LmluZGV4T2YoXCJnXCIpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWlzZShcIidAaXNHcm91cCcgY2FuIG9ubHkgYmUgc3BlY2lmaWVkIG9uIG5vbnRlcm1pbmFsc1wiKTtcbiAgICAgICAgICAgICAgICBncm91cCA9IHByb3AudmFsdWUubGVuZ3RoID8gdGhpcy5maW5pc2hQcm9wKHByb3AsIGFyZ3MsIHBhcmFtcykgOiBkZWZhdWx0TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3AubmFtZSA9PSBcImV4cG9ydFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZCA9IHRoaXMuZmluaXNoUHJvcChwcm9wLCBhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWQgPSBkZWZhdWx0TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoYFVua25vd24gYnVpbHQtaW4gcHJvcCBuYW1lICdAJHtwcm9wLm5hbWV9J2AsIHByb3Auc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByICYmIHRoaXMuYXN0LmF1dG9EZWxpbSAmJiAobmFtZSB8fCBoYXNQcm9wcyhyZXN1bHQpKSkge1xuICAgICAgICAgICAgbGV0IGRlbGltID0gdGhpcy5maW5kRGVsaW1pdGVycyhleHByKTtcbiAgICAgICAgICAgIGlmIChkZWxpbSkge1xuICAgICAgICAgICAgICAgIGFkZFRvUHJvcChkZWxpbVswXSwgXCJjbG9zZWRCeVwiLCBkZWxpbVsxXS5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgYWRkVG9Qcm9wKGRlbGltWzFdLCBcIm9wZW5lZEJ5XCIsIGRlbGltWzBdLm5vZGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdFByb3BzICYmIGhhc1Byb3BzKGRlZmF1bHRQcm9wcykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gcmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gZGVmYXVsdFByb3BzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQcm9wcyhyZXN1bHQpICYmICFuYW1lKVxuICAgICAgICAgICAgdGhpcy5yYWlzZShgTm9kZSBoYXMgcHJvcGVydGllcyBidXQgbm8gbmFtZWAsIHByb3BzLmxlbmd0aCA/IHByb3BzWzBdLnN0YXJ0IDogZXhwci5zdGFydCk7XG4gICAgICAgIGlmIChpbmxpbmUgJiYgKGhhc1Byb3BzKHJlc3VsdCkgfHwgZGlhbGVjdCB8fCBkeW5hbWljUHJlYykpXG4gICAgICAgICAgICB0aGlzLnJhaXNlKGBJbmxpbmUgbm9kZXMgY2FuJ3QgaGF2ZSBwcm9wcywgZHluYW1pYyBwcmVjZWRlbmNlLCBvciBhIGRpYWxlY3RgLCBwcm9wc1swXS5zdGFydCk7XG4gICAgICAgIGlmIChpbmxpbmUgJiYgbmFtZSlcbiAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICByZXR1cm4geyBuYW1lLCBwcm9wczogcmVzdWx0LCBkaWFsZWN0LCBkeW5hbWljUHJlYywgaW5saW5lLCBncm91cCwgZXhwb3J0ZWQgfTtcbiAgICB9XG4gICAgZmluaXNoUHJvcChwcm9wLCBhcmdzLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHByb3AudmFsdWUubWFwKHBhcnQgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcnQudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudmFsdWU7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyYW1zLmZpbmRJbmRleChwYXJhbSA9PiBwYXJhbS5uYW1lID09IHBhcnQubmFtZSk7XG4gICAgICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKGBQcm9wZXJ0eSByZWZlcnMgdG8gJyR7cGFydC5uYW1lfScsIGJ1dCBubyBwYXJhbWV0ZXIgYnkgdGhhdCBuYW1lIGlzIGluIHNjb3BlYCwgcGFydC5zdGFydCk7XG4gICAgICAgICAgICBsZXQgZXhwciA9IGFyZ3NbcG9zXTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgTmFtZUV4cHJlc3Npb24gJiYgIWV4cHIuYXJncy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIuaWQubmFtZTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYWlzZShgRXhwcmVzc2lvbiAnJHtleHByfScgY2FuIG5vdCBiZSB1c2VkIGFzIHBhcnQgb2YgYSBwcm9wZXJ0eSB2YWx1ZWAsIHBhcnQuc3RhcnQpO1xuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXNvbHZlU3BlY2lhbGl6YXRpb24oZXhwcikge1xuICAgICAgICBsZXQgdHlwZSA9IGV4cHIudHlwZTtcbiAgICAgICAgbGV0IHsgbmFtZSwgcHJvcHMsIGRpYWxlY3QsIGV4cG9ydGVkIH0gPSB0aGlzLm5vZGVJbmZvKGV4cHIucHJvcHMsIFwiZFwiKTtcbiAgICAgICAgbGV0IHRlcm1pbmFsID0gdGhpcy5ub3JtYWxpemVFeHByKGV4cHIudG9rZW4pO1xuICAgICAgICBpZiAodGVybWluYWwubGVuZ3RoICE9IDEgfHwgdGVybWluYWxbMF0udGVybXMubGVuZ3RoICE9IDEgfHwgIXRlcm1pbmFsWzBdLnRlcm1zWzBdLnRlcm1pbmFsKVxuICAgICAgICAgICAgdGhpcy5yYWlzZShgVGhlIGZpcnN0IGFyZ3VtZW50IHRvICcke3R5cGV9JyBtdXN0IHJlc29sdmUgdG8gYSB0b2tlbmAsIGV4cHIudG9rZW4uc3RhcnQpO1xuICAgICAgICBsZXQgdmFsdWVzO1xuICAgICAgICBpZiAoZXhwci5jb250ZW50IGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pXG4gICAgICAgICAgICB2YWx1ZXMgPSBbZXhwci5jb250ZW50LnZhbHVlXTtcbiAgICAgICAgZWxzZSBpZiAoKGV4cHIuY29udGVudCBpbnN0YW5jZW9mIENob2ljZUV4cHJlc3Npb24pICYmIGV4cHIuY29udGVudC5leHBycy5ldmVyeShlID0+IGUgaW5zdGFuY2VvZiBMaXRlcmFsRXhwcmVzc2lvbikpXG4gICAgICAgICAgICB2YWx1ZXMgPSBleHByLmNvbnRlbnQuZXhwcnMubWFwKGV4cHIgPT4gZXhwci52YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhaXNlKGBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvICcke2V4cHIudHlwZX0nIG11c3QgYmUgYSBsaXRlcmFsIG9yIGNob2ljZSBvZiBsaXRlcmFsc2AsIGV4cHIuY29udGVudC5zdGFydCk7XG4gICAgICAgIGxldCB0ZXJtID0gdGVybWluYWxbMF0udGVybXNbMF0sIHRva2VuID0gbnVsbDtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5zcGVjaWFsaXplZFt0ZXJtLm5hbWVdIHx8ICh0aGlzLnNwZWNpYWxpemVkW3Rlcm0ubmFtZV0gPSBbXSk7XG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gdGFibGUuZmluZChzcCA9PiBzcC52YWx1ZSA9PSB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoa25vd24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm1ha2VUZXJtaW5hbCh0ZXJtLm5hbWUgKyBcIi9cIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbmFtZSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudG9rZW5zLmJ5RGlhbGVjdFtkaWFsZWN0XSB8fCAodGhpcy50b2tlbnMuYnlEaWFsZWN0W2RpYWxlY3RdID0gW10pKS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFibGUucHVzaCh7IHZhbHVlLCB0ZXJtOiB0b2tlbiwgdHlwZSwgZGlhbGVjdCwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuT3JpZ2luc1t0b2tlbi5uYW1lXSA9IHsgc3BlYzogdGVybSB9O1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIHx8IGV4cG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnByZXNlcnZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lZFRlcm1zW2V4cG9ydGVkIHx8IG5hbWVdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duLnR5cGUgIT0gdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWlzZShgQ29uZmxpY3Rpbmcgc3BlY2lhbGl6YXRpb24gdHlwZXMgZm9yICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSBvZiAke3Rlcm0ubmFtZX0gKCR7dHlwZX0gdnMgJHtrbm93bi50eXBlfSlgLCBleHByLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoa25vd24uZGlhbGVjdCAhPSBkaWFsZWN0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKGBDb25mbGljdGluZyBkaWFsZWN0cyBmb3Igc3BlY2lhbGl6YXRpb24gJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IG9mICR7dGVybS5uYW1lfWAsIGV4cHIuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93bi5uYW1lICE9IG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoYENvbmZsaWN0aW5nIG5hbWVzIGZvciBzcGVjaWFsaXphdGlvbiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gb2YgJHt0ZXJtLm5hbWV9YCwgZXhwci5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIGtub3duLnRlcm0gIT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoYENvbmZsaWN0aW5nIHNwZWNpYWxpemF0aW9uIHRva2VucyBmb3IgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IG9mICR7dGVybS5uYW1lfWAsIGV4cHIuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRva2VuID0ga25vd24udGVybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGZpbmREZWxpbWl0ZXJzKGV4cHIpIHtcbiAgICAgICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIFNlcXVlbmNlRXhwcmVzc2lvbikgfHwgZXhwci5leHBycy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmaW5kVG9rZW4gPSAoZXhwcikgPT4ge1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBMaXRlcmFsRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXJtOiB0aGlzLnRva2Vucy5nZXRMaXRlcmFsKGV4cHIpLCBzdHI6IGV4cHIudmFsdWUgfTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgTmFtZUV4cHJlc3Npb24gJiYgZXhwci5hcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLmFzdC5ydWxlcy5maW5kKHIgPT4gci5pZC5uYW1lID09IGV4cHIuaWQubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5kVG9rZW4ocnVsZS5leHByKTtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2Vucy5ydWxlcy5maW5kKHIgPT4gci5pZC5uYW1lID09IGV4cHIuaWQubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmV4cHIgaW5zdGFuY2VvZiBMaXRlcmFsRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGVybTogdGhpcy50b2tlbnMuZ2V0VG9rZW4oZXhwciksIHN0cjogdG9rZW4uZXhwci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXN0VG9rZW4gPSBmaW5kVG9rZW4oZXhwci5leHByc1tleHByLmV4cHJzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKCFsYXN0VG9rZW4gfHwgIWxhc3RUb2tlbi50ZXJtLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGJyYWNrZXRzID0gW1wiKClcIiwgXCJbXVwiLCBcInt9XCIsIFwiPD5cIl07XG4gICAgICAgIGxldCBicmFja2V0ID0gYnJhY2tldHMuZmluZChiID0+IGxhc3RUb2tlbi5zdHIuaW5kZXhPZihiWzFdKSA+IC0xICYmIGxhc3RUb2tlbi5zdHIuaW5kZXhPZihiWzBdKSA8IDApO1xuICAgICAgICBpZiAoIWJyYWNrZXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZpcnN0VG9rZW4gPSBmaW5kVG9rZW4oZXhwci5leHByc1swXSk7XG4gICAgICAgIGlmICghZmlyc3RUb2tlbiB8fCAhZmlyc3RUb2tlbi50ZXJtLm5vZGVOYW1lIHx8XG4gICAgICAgICAgICBmaXJzdFRva2VuLnN0ci5pbmRleE9mKGJyYWNrZXRbMF0pIDwgMCB8fCBmaXJzdFRva2VuLnN0ci5pbmRleE9mKGJyYWNrZXRbMV0pID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtmaXJzdFRva2VuLnRlcm0sIGxhc3RUb2tlbi50ZXJtXTtcbiAgICB9XG4gICAgcmVnaXN0ZXJEeW5hbWljUHJlYyh0ZXJtLCBwcmVjKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY1J1bGVQcmVjZWRlbmNlcy5wdXNoKHsgcnVsZTogdGVybSwgcHJlYyB9KTtcbiAgICAgICAgdGVybS5wcmVzZXJ2ZSA9IHRydWU7XG4gICAgfVxuICAgIGRlZmluZUdyb3VwKHJ1bGUsIGdyb3VwLCBhc3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVjdXIgPSBbXTtcbiAgICAgICAgbGV0IGdldE5hbWVkID0gKHJ1bGUpID0+IHtcbiAgICAgICAgICAgIGlmIChydWxlLm5vZGVOYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBbcnVsZV07XG4gICAgICAgICAgICBpZiAocmVjdXIuaW5jbHVkZXMocnVsZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZShgUnVsZSAnJHthc3QuaWQubmFtZX0nIGNhbm5vdCBkZWZpbmUgYSBncm91cCBiZWNhdXNlIGl0IGNvbnRhaW5zIGEgbm9uLW5hbWVkIHJlY3Vyc2l2ZSBydWxlICgnJHtydWxlLm5hbWV9JylgLCBhc3Quc3RhcnQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmVjdXIucHVzaChydWxlKTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5ydWxlcylcbiAgICAgICAgICAgICAgICBpZiAoci5uYW1lID09IHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVzID0gci5wYXJ0cy5tYXAoZ2V0TmFtZWQpLmZpbHRlcih4ID0+IHgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKGBSdWxlICcke2FzdC5pZC5uYW1lfScgY2Fubm90IGRlZmluZSBhIGdyb3VwIGJlY2F1c2Ugc29tZSBjaG9pY2VzIHByb2R1Y2UgbXVsdGlwbGUgbmFtZWQgbm9kZXNgLCBhc3Quc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuIG9mIG5hbWVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3VyLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBnZXROYW1lZChydWxlKSlcbiAgICAgICAgICAgIG5hbWUucHJvcHNbXCJncm91cFwiXSA9ICgoKF9hID0gbmFtZS5wcm9wc1tcImdyb3VwXCJdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoXCIgXCIpKSB8fCBbXSkuY29uY2F0KGdyb3VwKS5zb3J0KCkuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGNoZWNrR3JvdXBzKCkge1xuICAgICAgICBsZXQgZ3JvdXBzID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgbm9kZU5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgdGVybSBvZiB0aGlzLnRlcm1zLnRlcm1zKVxuICAgICAgICAgICAgaWYgKHRlcm0ubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZXNbdGVybS5ub2RlTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXJtLnByb3BzW1wiZ3JvdXBcIl0pXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHRlcm0ucHJvcHNbXCJncm91cFwiXS5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChncm91cHNbZ3JvdXBdIHx8IChncm91cHNbZ3JvdXBdID0gW10pKS5wdXNoKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lcyA9IE9iamVjdC5rZXlzKGdyb3Vwcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gbmFtZXNbaV0sIHRlcm1zID0gZ3JvdXBzW25hbWVdO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oYEdyb3VwIG5hbWUgJyR7bmFtZX0nIGNvbmZsaWN0cyB3aXRoIGEgbm9kZSBvZiB0aGUgc2FtZSBuYW1lYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IGdyb3Vwc1tuYW1lc1tqXV07XG4gICAgICAgICAgICAgICAgaWYgKHRlcm1zLnNvbWUodCA9PiBvdGhlci5pbmNsdWRlcyh0KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRlcm1zLmxlbmd0aCA+IG90aGVyLmxlbmd0aCA/IG90aGVyLnNvbWUodCA9PiAhdGVybXMuaW5jbHVkZXModCkpIDogdGVybXMuc29tZSh0ID0+ICFvdGhlci5pbmNsdWRlcyh0KSkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm4oYEdyb3VwcyAnJHtuYW1lfScgYW5kICcke25hbWVzW2pdfScgb3ZlcmxhcCB3aXRob3V0IG9uZSBiZWluZyBhIHN1cGVyc2V0IG9mIHRoZSBvdGhlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgTWluU2hhcmVkQWN0aW9ucyA9IDU7XG5jbGFzcyBGaW5pc2hTdGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuaXplcnMsIGRhdGEsIHN0YXRlQXJyYXksIHNraXBEYXRhLCBza2lwSW5mbywgc3RhdGVzLCBidWlsZGVyKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHRva2VuaXplcnM7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc3RhdGVBcnJheSA9IHN0YXRlQXJyYXk7XG4gICAgICAgIHRoaXMuc2tpcERhdGEgPSBza2lwRGF0YTtcbiAgICAgICAgdGhpcy5za2lwSW5mbyA9IHNraXBJbmZvO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgICAgICAgdGhpcy5zaGFyZWRBY3Rpb25zID0gW107XG4gICAgfVxuICAgIGZpbmRTaGFyZWRBY3Rpb25zKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5hY3Rpb25zLmxlbmd0aCA8IE1pblNoYXJlZEFjdGlvbnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgc2hhcmVkIG9mIHRoaXMuc2hhcmVkQWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKCghZm91bmQgfHwgc2hhcmVkLmFjdGlvbnMubGVuZ3RoID4gZm91bmQuYWN0aW9ucy5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgc2hhcmVkLmFjdGlvbnMuZXZlcnkoYSA9PiBzdGF0ZS5hY3Rpb25zLnNvbWUoYiA9PiBiLmVxKGEpKSkpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBzaGFyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICBsZXQgbWF4ID0gbnVsbCwgc2NyYXRjaCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUuaWQgKyAxOyBpIDwgdGhpcy5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IHRoaXMuc3RhdGVzW2ldLCBmaWxsID0gMDtcbiAgICAgICAgICAgIGlmIChvdGhlci5kZWZhdWx0UmVkdWNlIHx8IG90aGVyLmFjdGlvbnMubGVuZ3RoIDwgTWluU2hhcmVkQWN0aW9ucylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGEgb2Ygc3RhdGUuYWN0aW9ucylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiIG9mIG90aGVyLmFjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmVxKGIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyYXRjaFtmaWxsKytdID0gYTtcbiAgICAgICAgICAgIGlmIChmaWxsID49IE1pblNoYXJlZEFjdGlvbnMgJiYgKCFtYXggfHwgbWF4Lmxlbmd0aCA8IGZpbGwpKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gc2NyYXRjaDtcbiAgICAgICAgICAgICAgICBzY3JhdGNoID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgYWN0aW9uczogbWF4LCBhZGRyOiB0aGlzLnN0b3JlQWN0aW9ucyhtYXgsIC0xLCBudWxsKSB9O1xuICAgICAgICB0aGlzLnNoYXJlZEFjdGlvbnMucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdG9yZUFjdGlvbnMoYWN0aW9ucywgc2tpcFJlZHVjZSwgc2hhcmVkKSB7XG4gICAgICAgIGlmIChza2lwUmVkdWNlIDwgMCAmJiBzaGFyZWQgJiYgc2hhcmVkLmFjdGlvbnMubGVuZ3RoID09IGFjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZC5hZGRyO1xuICAgICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNoYXJlZCAmJiBzaGFyZWQuYWN0aW9ucy5zb21lKGEgPT4gYS5lcShhY3Rpb24pKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBTaGlmdCkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChhY3Rpb24udGVybS5pZCwgYWN0aW9uLnRhcmdldC5pZCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHJlZHVjZUFjdGlvbihhY3Rpb24ucnVsZSwgdGhpcy5za2lwSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gc2tpcFJlZHVjZSlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGFjdGlvbi50ZXJtLmlkLCBjb2RlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgY29kZSA+PiAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdXNoKDY1NTM1IC8qIFNlcS5FbmQgKi8pO1xuICAgICAgICBpZiAoc2tpcFJlZHVjZSA+IC0xKVxuICAgICAgICAgICAgZGF0YS5wdXNoKDIgLyogU2VxLk90aGVyICovLCBza2lwUmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgc2tpcFJlZHVjZSA+PiAxNik7XG4gICAgICAgIGVsc2UgaWYgKHNoYXJlZClcbiAgICAgICAgICAgIGRhdGEucHVzaCgxIC8qIFNlcS5OZXh0ICovLCBzaGFyZWQuYWRkciAmIDB4ZmZmZiwgc2hhcmVkLmFkZHIgPj4gMTYpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkYXRhLnB1c2goMCAvKiBTZXEuRG9uZSAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3RvcmVBcnJheShkYXRhKTtcbiAgICB9XG4gICAgZmluaXNoKHN0YXRlLCBpc1NraXAsIGZvcmNlZFJlZHVjZSkge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVpbGRlcjtcbiAgICAgICAgbGV0IHNraXBJRCA9IGIuc2tpcFJ1bGVzLmluZGV4T2Yoc3RhdGUuc2tpcCk7XG4gICAgICAgIGxldCBza2lwVGFibGUgPSB0aGlzLnNraXBEYXRhW3NraXBJRF0sIHNraXBUZXJtcyA9IHRoaXMuc2tpcEluZm9bc2tpcElEXS5zdGFydFRva2VucztcbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBzdGF0ZS5kZWZhdWx0UmVkdWNlID8gcmVkdWNlQWN0aW9uKHN0YXRlLmRlZmF1bHRSZWR1Y2UsIHRoaXMuc2tpcEluZm8pIDogMDtcbiAgICAgICAgbGV0IGZsYWdzID0gaXNTa2lwID8gMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLyA6IDA7XG4gICAgICAgIGxldCBza2lwUmVkdWNlID0gLTEsIHNoYXJlZCA9IG51bGw7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID09IDApIHtcbiAgICAgICAgICAgIGlmIChpc1NraXApXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2Ygc3RhdGUuYWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIFJlZHVjZSAmJiBhY3Rpb24udGVybS5lb2YpXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwUmVkdWNlID0gcmVkdWNlQWN0aW9uKGFjdGlvbi5ydWxlLCB0aGlzLnNraXBJbmZvKTtcbiAgICAgICAgICAgIGlmIChza2lwUmVkdWNlIDwgMClcbiAgICAgICAgICAgICAgICBzaGFyZWQgPSB0aGlzLmZpbmRTaGFyZWRBY3Rpb25zKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc2V0LnNvbWUocCA9PiBwLnJ1bGUubmFtZS50b3AgJiYgcC5wb3MgPT0gcC5ydWxlLnBhcnRzLmxlbmd0aCkpXG4gICAgICAgICAgICBmbGFncyB8PSAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi87XG4gICAgICAgIGxldCBleHRlcm5hbCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmFjdGlvbnMubGVuZ3RoICsgc2tpcFRlcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGVybSA9IGkgPCBzdGF0ZS5hY3Rpb25zLmxlbmd0aCA/IHN0YXRlLmFjdGlvbnNbaV0udGVybSA6IHNraXBUZXJtc1tpIC0gc3RhdGUuYWN0aW9ucy5sZW5ndGhdO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBvcmlnID0gYi50b2tlbk9yaWdpbnNbdGVybS5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZyAmJiBvcmlnLnNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybSA9IG9yaWcuc3BlYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcmlnICYmIChvcmlnLmV4dGVybmFsIGluc3RhbmNlb2YgRXh0ZXJuYWxUb2tlblNldCkpXG4gICAgICAgICAgICAgICAgICAgIGFkZFRvU2V0KGV4dGVybmFsLCBvcmlnLmV4dGVybmFsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9rZW5pemVyTWFzayA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbml6ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGV4dGVybmFsLmluY2x1ZGVzKHRvaykgfHwgdG9rLmdyb3VwSUQgPT0gc3RhdGUudG9rZW5Hcm91cClcbiAgICAgICAgICAgICAgICB0b2tlbml6ZXJNYXNrIHw9ICgxIDw8IGkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiYXNlID0gc3RhdGUuaWQgKiA2IC8qIFBhcnNlU3RhdGUuU2l6ZSAqLztcbiAgICAgICAgdGhpcy5zdGF0ZUFycmF5W2Jhc2UgKyAwIC8qIFBhcnNlU3RhdGUuRmxhZ3MgKi9dID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuc3RhdGVBcnJheVtiYXNlICsgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi9dID0gdGhpcy5zdG9yZUFjdGlvbnMoZGVmYXVsdFJlZHVjZSA/IG5vbmUgOiBzdGF0ZS5hY3Rpb25zLCBza2lwUmVkdWNlLCBzaGFyZWQpO1xuICAgICAgICB0aGlzLnN0YXRlQXJyYXlbYmFzZSArIDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovXSA9IHNraXBUYWJsZTtcbiAgICAgICAgdGhpcy5zdGF0ZUFycmF5W2Jhc2UgKyAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqL10gPSB0b2tlbml6ZXJNYXNrO1xuICAgICAgICB0aGlzLnN0YXRlQXJyYXlbYmFzZSArIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovXSA9IGRlZmF1bHRSZWR1Y2U7XG4gICAgICAgIHRoaXMuc3RhdGVBcnJheVtiYXNlICsgNSAvKiBQYXJzZVN0YXRlLkZvcmNlZFJlZHVjZSAqL10gPSBmb3JjZWRSZWR1Y2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkVG9Qcm9wKHRlcm0sIHByb3AsIHZhbHVlKSB7XG4gICAgbGV0IGN1ciA9IHRlcm0ucHJvcHNbcHJvcF07XG4gICAgaWYgKCFjdXIgfHwgY3VyLnNwbGl0KFwiIFwiKS5pbmRleE9mKHZhbHVlKSA8IDApXG4gICAgICAgIHRlcm0ucHJvcHNbcHJvcF0gPSBjdXIgPyBjdXIgKyBcIiBcIiArIHZhbHVlIDogdmFsdWU7XG59XG5mdW5jdGlvbiBidWlsZFNwZWNpYWxpemVUYWJsZShzcGVjKSB7XG4gICAgbGV0IHRhYmxlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCB7IHZhbHVlLCB0ZXJtLCB0eXBlIH0gb2Ygc3BlYykge1xuICAgICAgICBsZXQgY29kZSA9IHR5cGUgPT0gXCJzcGVjaWFsaXplXCIgPyAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLyA6IDEgLyogU3BlY2lhbGl6ZS5FeHRlbmQgKi87XG4gICAgICAgIHRhYmxlW3ZhbHVlXSA9ICh0ZXJtLmlkIDw8IDEpIHwgY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xufVxuZnVuY3Rpb24gcmVkdWNlQWN0aW9uKHJ1bGUsIHNraXBJbmZvLCBkZXB0aCA9IHJ1bGUucGFydHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJ1bGUubmFtZS5pZCB8IDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovIHxcbiAgICAgICAgKHJ1bGUuaXNSZXBlYXRXcmFwICYmIGRlcHRoID09IHJ1bGUucGFydHMubGVuZ3RoID8gMTMxMDcyIC8qIEFjdGlvbi5SZXBlYXRGbGFnICovIDogMCkgfFxuICAgICAgICAoc2tpcEluZm8uc29tZShpID0+IGkucnVsZSA9PSBydWxlLm5hbWUpID8gMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyA6IDApIHxcbiAgICAgICAgKGRlcHRoIDw8IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKTtcbn1cbmZ1bmN0aW9uIGZpbmRBcnJheShkYXRhLCB2YWx1ZSkge1xuICAgIHNlYXJjaDogZm9yIChsZXQgaSA9IDA7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IGRhdGEuaW5kZXhPZih2YWx1ZVswXSwgaSk7XG4gICAgICAgIGlmIChuZXh0ID09IC0xIHx8IG5leHQgKyB2YWx1ZS5sZW5ndGggPiBkYXRhLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbal0gIT0gZGF0YVtuZXh0ICsgal0pIHtcbiAgICAgICAgICAgICAgICBpID0gbmV4dCArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmaW5kU2tpcFN0YXRlcyh0YWJsZSwgc3RhcnRSdWxlcykge1xuICAgIGxldCBub25Ta2lwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgd29yayA9IFtdO1xuICAgIGxldCBhZGQgPSAoc3RhdGUpID0+IHtcbiAgICAgICAgaWYgKCFub25Ta2lwW3N0YXRlLmlkXSkge1xuICAgICAgICAgICAgbm9uU2tpcFtzdGF0ZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgd29yay5wdXNoKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQgc3RhdGUgb2YgdGFibGUpXG4gICAgICAgIGlmIChzdGF0ZS5zdGFydFJ1bGUgJiYgc3RhcnRSdWxlcy5pbmNsdWRlcyhzdGF0ZS5zdGFydFJ1bGUpKVxuICAgICAgICAgICAgYWRkKHN0YXRlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgYSBvZiB3b3JrW2ldLmFjdGlvbnMpXG4gICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFNoaWZ0KVxuICAgICAgICAgICAgICAgIGFkZChhLnRhcmdldCk7XG4gICAgICAgIGZvciAobGV0IGEgb2Ygd29ya1tpXS5nb3RvKVxuICAgICAgICAgICAgYWRkKGEudGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIChpZCkgPT4gIW5vblNraXBbaWRdO1xufVxuY2xhc3MgRGF0YUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgc3RvcmVBcnJheShkYXRhKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZpbmRBcnJheSh0aGlzLmRhdGEsIGRhdGEpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IG51bSBvZiBkYXRhKVxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2gobnVtKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICByZXR1cm4gVWludDE2QXJyYXkuZnJvbSh0aGlzLmRhdGEpO1xuICAgIH1cbn1cbi8vIFRoZSBnb3RvIHRhYmxlIG1hcHMgYSBzdGFydCBzdGF0ZSArIGEgdGVybSB0byBhIG5ldyBzdGF0ZSwgYW5kIGlzXG4vLyB1c2VkIHRvIGRldGVybWluZSB0aGUgbmV3IHN0YXRlIHdoZW4gcmVkdWNpbmcuIEJlY2F1c2UgdGhpcyBhbGxvd3Ncbi8vIG1vcmUgbW9yZSBlZmZpY2llbnQgcmVwcmVzZW50YXRpb24gYW5kIGFjY2VzcywgdW5saWtlIHRoZSBhY3Rpb25cbi8vIHRhYmxlcywgdGhlIGdvdG8gdGFibGUgaXMgb3JnYW5pemVkIGJ5IHRlcm0sIHdpdGggZ3JvdXBzIG9mIHN0YXJ0XG4vLyBzdGF0ZXMgdGhhdCBtYXAgdG8gYSBnaXZlbiBlbmQgc3RhdGUgZW51bWVyYXRlZCBmb3IgZWFjaCB0ZXJtLlxuLy8gU2luY2UgbWFueSB0ZXJtcyBvbmx5IGhhdmUgYSBzaW5nbGUgdmFsaWQgZ290byB0YXJnZXQsIHRoaXMgbWFrZXNcbi8vIGl0IGNoZWFwZXIgdG8gbG9vayB0aG9zZSB1cC5cbi8vXG4vLyAoVW5mb3J0dW5hdGVseSwgdGhvdWdoIHRoZSBzdGFuZGFyZCBMUiBwYXJzaW5nIG1lY2hhbmlzbSBuZXZlclxuLy8gbG9va3MgdXAgaW52YWxpZCBnb3RvIHN0YXRlcywgdGhlIGluY3JlbWVudGFsIHBhcnNpbmcgbWVjaGFuaXNtXG4vLyBuZWVkcyBhY2N1cmF0ZSBnb3RvIGluZm9ybWF0aW9uIGZvciBhIHN0YXRlL3Rlcm0gcGFpciwgc28gd2UgZG9cbi8vIG5lZWQgdG8gc3RvcmUgc3RhdGUgaWRzIGV2ZW4gZm9yIHRlcm1zIHRoYXQgaGF2ZSBvbmx5IG9uZSB0YXJnZXQuKVxuLy9cbi8vIC0gRmlyc3QgY29tZXMgdGhlIGFtb3VudCBvZiB0ZXJtcyBpbiB0aGUgdGFibGVcbi8vXG4vLyAtIFRoZW4sIGZvciBlYWNoIHRlcm0sIHRoZSBvZmZzZXQgb2YgdGhlIHRlcm0ncyBkYXRhXG4vL1xuLy8gLSBBdCB0aGVzZSBvZmZzZXRzLCB0aGVyZSdzIGEgcmVjb3JkIGZvciBlYWNoIHRhcmdldCBzdGF0ZVxuLy9cbi8vICAgLSBTdWNoIGEgcmVjb3JkIHN0YXJ0cyB3aXRoIHRoZSBhbW91bnQgb2Ygc3RhcnQgc3RhdGVzIHRoYXQgZ28gdG9cbi8vICAgICB0aGlzIHRhcmdldCBzdGF0ZSwgc2hpZnRlZCBvbmUgdG8gdGhlIGxlZnQsIHdpdGggdGhlIGZpcnN0IGJpdFxuLy8gICAgIG9ubHkgc2V0IGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVjb3JkIGZvciB0aGlzIHRlcm0uXG4vL1xuLy8gICAtIFRoZW4gZm9sbG93cyB0aGUgdGFyZ2V0IHN0YXRlIGlkXG4vL1xuLy8gICAtIEFuZCB0aGVuIHRoZSBzdGFydCBzdGF0ZSBpZHNcbmZ1bmN0aW9uIGNvbXB1dGVHb3RvVGFibGUoc3RhdGVzKSB7XG4gICAgbGV0IGdvdG8gPSB7fTtcbiAgICBsZXQgbWF4VGVybSA9IDA7XG4gICAgZm9yIChsZXQgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHN0YXRlLmdvdG8pIHtcbiAgICAgICAgICAgIG1heFRlcm0gPSBNYXRoLm1heChlbnRyeS50ZXJtLmlkLCBtYXhUZXJtKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBnb3RvW2VudHJ5LnRlcm0uaWRdIHx8IChnb3RvW2VudHJ5LnRlcm0uaWRdID0ge30pO1xuICAgICAgICAgICAgKHNldFtlbnRyeS50YXJnZXQuaWRdIHx8IChzZXRbZW50cnkudGFyZ2V0LmlkXSA9IFtdKSkucHVzaChzdGF0ZS5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBuZXcgRGF0YUJ1aWxkZXI7XG4gICAgbGV0IGluZGV4ID0gW107XG4gICAgbGV0IG9mZnNldCA9IG1heFRlcm0gKyAyOyAvLyBPZmZzZXQgb2YgdGhlIGRhdGEsIHRha2luZyBpbmRleCBzaXplIGludG8gYWNjb3VudFxuICAgIGZvciAobGV0IHRlcm0gPSAwOyB0ZXJtIDw9IG1heFRlcm07IHRlcm0rKykge1xuICAgICAgICBsZXQgZW50cmllcyA9IGdvdG9bdGVybV07XG4gICAgICAgIGlmICghZW50cmllcykge1xuICAgICAgICAgICAgaW5kZXgucHVzaCgxKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXJtVGFibGUgPSBbXTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhlbnRyaWVzKTtcbiAgICAgICAgZm9yIChsZXQgdGFyZ2V0IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGxldCBsaXN0ID0gZW50cmllc1t0YXJnZXRdO1xuICAgICAgICAgICAgdGVybVRhYmxlLnB1c2goKHRhcmdldCA9PSBrZXlzW2tleXMubGVuZ3RoIC0gMV0gPyAxIDogMCkgKyAobGlzdC5sZW5ndGggPDwgMSkpO1xuICAgICAgICAgICAgdGVybVRhYmxlLnB1c2goK3RhcmdldCk7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgbGlzdClcbiAgICAgICAgICAgICAgICB0ZXJtVGFibGUucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4LnB1c2goZGF0YS5zdG9yZUFycmF5KHRlcm1UYWJsZSkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAoaW5kZXguc29tZShuID0+IG4gPiAweGZmZmYpKVxuICAgICAgICB0aHJvdyBuZXcgR2VuRXJyb3IoXCJHb3RvIHRhYmxlIHRvbyBsYXJnZVwiKTtcbiAgICByZXR1cm4gVWludDE2QXJyYXkuZnJvbShbbWF4VGVybSArIDEsIC4uLmluZGV4LCAuLi5kYXRhLmRhdGFdKTtcbn1cbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKHRva2VucywgZ3JvdXBJRCkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5ncm91cElEID0gZ3JvdXBJRDtcbiAgICB9XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdGhpcy5ncm91cElEOyB9XG4gICAgY3JlYXRlU291cmNlKCkgeyByZXR1cm4gU3RyaW5nKHRoaXMuZ3JvdXBJRCk7IH1cbn1cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgdmFsdWUpIHtcbiAgICBpZiAoIXNldC5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgIHNldC5wdXNoKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVG9rZW5NYXNrcyhncm91cHMpIHtcbiAgICBsZXQgbWFza3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgICAgICBsZXQgZ3JvdXBNYXNrID0gMSA8PCBncm91cC5ncm91cElEO1xuICAgICAgICBmb3IgKGxldCB0ZXJtIG9mIGdyb3VwLnRva2Vucykge1xuICAgICAgICAgICAgbWFza3NbdGVybS5pZF0gPSAobWFza3NbdGVybS5pZF0gfHwgMCkgfCBncm91cE1hc2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tzO1xufVxuY2xhc3MgVG9rZW5Bcmcge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGV4cHIsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB9XG59XG5jbGFzcyBCdWlsZGluZ1J1bGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHN0YXJ0LCB0bywgYXJncykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG59XG5jbGFzcyBUb2tlblNldCB7XG4gICAgY29uc3RydWN0b3IoYiwgYXN0KSB7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBuZXcgU3RhdGUkMTtcbiAgICAgICAgdGhpcy5idWlsdCA9IFtdO1xuICAgICAgICB0aGlzLmJ1aWxkaW5nID0gW107IC8vIFVzZWQgZm9yIHJlY3Vyc2lvbiBjaGVja1xuICAgICAgICB0aGlzLmJ5RGlhbGVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucHJlY2VkZW5jZVJlbGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnJ1bGVzID0gYXN0ID8gYXN0LnJ1bGVzIDogbm9uZTtcbiAgICAgICAgZm9yIChsZXQgcnVsZSBvZiB0aGlzLnJ1bGVzKVxuICAgICAgICAgICAgYi51bmlxdWUocnVsZS5pZCk7XG4gICAgfVxuICAgIGdldFRva2VuKGV4cHIpIHtcbiAgICAgICAgZm9yIChsZXQgYnVpbHQgb2YgdGhpcy5idWlsdClcbiAgICAgICAgICAgIGlmIChidWlsdC5tYXRjaGVzKGV4cHIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsdC50ZXJtO1xuICAgICAgICBsZXQgbmFtZSA9IGV4cHIuaWQubmFtZTtcbiAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnJ1bGVzLmZpbmQociA9PiByLmlkLm5hbWUgPT0gbmFtZSk7XG4gICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBuYW1lOiBub2RlTmFtZSwgcHJvcHMsIGRpYWxlY3QsIGV4cG9ydGVkIH0gPSB0aGlzLmIubm9kZUluZm8ocnVsZS5wcm9wcywgXCJkXCIsIG5hbWUsIGV4cHIuYXJncywgcnVsZS5wYXJhbXMubGVuZ3RoICE9IGV4cHIuYXJncy5sZW5ndGggPyBub25lIDogcnVsZS5wYXJhbXMpO1xuICAgICAgICBsZXQgdGVybSA9IHRoaXMuYi5tYWtlVGVybWluYWwoZXhwci50b1N0cmluZygpLCBub2RlTmFtZSwgcHJvcHMpO1xuICAgICAgICBpZiAoZGlhbGVjdCAhPSBudWxsKVxuICAgICAgICAgICAgKHRoaXMuYnlEaWFsZWN0W2RpYWxlY3RdIHx8ICh0aGlzLmJ5RGlhbGVjdFtkaWFsZWN0XSA9IFtdKSkucHVzaCh0ZXJtKTtcbiAgICAgICAgaWYgKCh0ZXJtLm5vZGVUeXBlIHx8IGV4cG9ydGVkKSAmJiBydWxlLnBhcmFtcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKCF0ZXJtLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIHRlcm0ucHJlc2VydmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5iLm5hbWVkVGVybXNbZXhwb3J0ZWQgfHwgbmFtZV0gPSB0ZXJtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVpbGRSdWxlKHJ1bGUsIGV4cHIsIHRoaXMuc3RhcnRTdGF0ZSwgbmV3IFN0YXRlJDEoW3Rlcm1dKSk7XG4gICAgICAgIHRoaXMuYnVpbHQucHVzaChuZXcgQnVpbHRSdWxlKG5hbWUsIGV4cHIuYXJncywgdGVybSkpO1xuICAgICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gICAgYnVpbGRSdWxlKHJ1bGUsIGV4cHIsIGZyb20sIHRvLCBhcmdzID0gbm9uZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGV4cHIuaWQubmFtZTtcbiAgICAgICAgaWYgKHJ1bGUucGFyYW1zLmxlbmd0aCAhPSBleHByLmFyZ3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5iLnJhaXNlKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgdG9rZW4gJyR7bmFtZX0nYCwgZXhwci5zdGFydCk7XG4gICAgICAgIGxldCBidWlsZGluZyA9IHRoaXMuYnVpbGRpbmcuZmluZChiID0+IGIubmFtZSA9PSBuYW1lICYmIGV4cHJzRXEoZXhwci5hcmdzLCBiLmFyZ3MpKTtcbiAgICAgICAgaWYgKGJ1aWxkaW5nKSB7XG4gICAgICAgICAgICBpZiAoYnVpbGRpbmcudG8gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICBmcm9tLm51bGxFZGdlKGJ1aWxkaW5nLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5idWlsZGluZy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVpbGRpbmdbbGFzdEluZGV4XS5uYW1lICE9IG5hbWUpXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4LS07XG4gICAgICAgICAgICB0aGlzLmIucmFpc2UoYEludmFsaWQgKG5vbi10YWlsKSByZWN1cnNpb24gaW4gdG9rZW4gcnVsZXM6ICR7dGhpcy5idWlsZGluZy5zbGljZShsYXN0SW5kZXgpLm1hcChiID0+IGIubmFtZSkuam9pbihcIiAtPiBcIil9YCwgZXhwci5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iLnVzZWQocnVsZS5pZC5uYW1lKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbmV3IFN0YXRlJDE7XG4gICAgICAgIGZyb20ubnVsbEVkZ2Uoc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5nLnB1c2gobmV3IEJ1aWxkaW5nUnVsZShuYW1lLCBzdGFydCwgdG8sIGV4cHIuYXJncykpO1xuICAgICAgICB0aGlzLmJ1aWxkKHRoaXMuYi5zdWJzdGl0dXRlQXJncyhydWxlLmV4cHIsIGV4cHIuYXJncywgcnVsZS5wYXJhbXMpLCBzdGFydCwgdG8sIGV4cHIuYXJncy5tYXAoKGUsIGkpID0+IG5ldyBUb2tlbkFyZyhydWxlLnBhcmFtc1tpXS5uYW1lLCBlLCBhcmdzKSkpO1xuICAgICAgICB0aGlzLmJ1aWxkaW5nLnBvcCgpO1xuICAgIH1cbiAgICBidWlsZChleHByLCBmcm9tLCB0bywgYXJncykge1xuICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIE5hbWVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGV4cHIuaWQubmFtZSwgYXJnID0gYXJncy5maW5kKGEgPT4gYS5uYW1lID09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFyZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChhcmcuZXhwciwgZnJvbSwgdG8sIGFyZy5zY29wZSk7XG4gICAgICAgICAgICBsZXQgcnVsZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsdCA9IHRoaXMuYi5sb2NhbFRva2VuczsgaSA8PSBsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzZXQgPSBpID09IGx0Lmxlbmd0aCA/IHRoaXMuYi50b2tlbnMgOiBsdFtpXTtcbiAgICAgICAgICAgICAgICBydWxlID0gc2V0LnJ1bGVzLmZpbmQociA9PiByLmlkLm5hbWUgPT0gbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYi5yYWlzZShgUmVmZXJlbmNlIHRvIHRva2VuIHJ1bGUgJyR7ZXhwci5pZC5uYW1lfScsIHdoaWNoIGlzbid0IGZvdW5kYCwgZXhwci5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUnVsZShydWxlLCBleHByLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIENoYXJDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgW2EsIGJdIG9mIENoYXJDbGFzc2VzW2V4cHIudHlwZV0pXG4gICAgICAgICAgICAgICAgZnJvbS5lZGdlKGEsIGIsIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQ2hvaWNlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hvaWNlIG9mIGV4cHIuZXhwcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZChjaG9pY2UsIGZyb20sIHRvLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VtcHR5KGV4cHIpKSB7XG4gICAgICAgICAgICBmcm9tLm51bGxFZGdlKHRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgU2VxdWVuY2VFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgY29uZmxpY3QgPSBleHByLm1hcmtlcnMuZmluZChjID0+IGMubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBpZiAoY29uZmxpY3QpXG4gICAgICAgICAgICAgICAgdGhpcy5iLnJhaXNlKFwiQ29uZmxpY3QgbWFya2VyIGluIHRva2VuIGV4cHJlc3Npb25cIiwgY29uZmxpY3RbMF0uc3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByLmV4cHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSA/IHRvIDogbmV3IFN0YXRlJDE7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZChleHByLmV4cHJzW2ldLCBmcm9tLCBuZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgUmVwZWF0RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgaWYgKGV4cHIua2luZCA9PSBcIipcIikge1xuICAgICAgICAgICAgICAgIGxldCBsb29wID0gbmV3IFN0YXRlJDE7XG4gICAgICAgICAgICAgICAgZnJvbS5udWxsRWRnZShsb29wKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkKGV4cHIuZXhwciwgbG9vcCwgbG9vcCwgYXJncyk7XG4gICAgICAgICAgICAgICAgbG9vcC5udWxsRWRnZSh0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHByLmtpbmQgPT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbG9vcCA9IG5ldyBTdGF0ZSQxO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGQoZXhwci5leHByLCBmcm9tLCBsb29wLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkKGV4cHIuZXhwciwgbG9vcCwgbG9vcCwgYXJncyk7XG4gICAgICAgICAgICAgICAgbG9vcC5udWxsRWRnZSh0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gZXhwci5raW5kID09IFwiP1wiXG4gICAgICAgICAgICAgICAgZnJvbS5udWxsRWRnZSh0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZChleHByLmV4cHIsIGZyb20sIHRvLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgU2V0RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgZm9yIChsZXQgW2EsIGJdIG9mIGV4cHIuaW52ZXJ0ZWQgPyBpbnZlcnRSYW5nZXMoZXhwci5yYW5nZXMpIDogZXhwci5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VFZGdlcyhmcm9tLCB0bywgYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBleHByLnZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IGV4cHIudmFsdWUubGVuZ3RoIC0gMSA/IHRvIDogbmV3IFN0YXRlJDE7XG4gICAgICAgICAgICAgICAgZnJvbS5lZGdlKGNoLCBjaCArIDEsIG5leHQpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBbnlFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gbmV3IFN0YXRlJDE7XG4gICAgICAgICAgICBmcm9tLmVkZ2UoMCwgMHhEQzAwLCB0byk7XG4gICAgICAgICAgICBmcm9tLmVkZ2UoMHhEQzAwLCBNQVhfQ0hBUiArIDEsIHRvKTtcbiAgICAgICAgICAgIGZyb20uZWRnZSgweEQ4MDAsIDB4REMwMCwgbWlkKTtcbiAgICAgICAgICAgIG1pZC5lZGdlKDB4REMwMCwgMHhFMDAwLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iLnJhaXNlKGBVbnJlY29nbml6ZWQgZXhwcmVzc2lvbiB0eXBlIGluIHRva2VuYCwgZXhwci5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFrZVByZWNlZGVuY2VzKCkge1xuICAgICAgICBsZXQgcmVsID0gdGhpcy5wcmVjZWRlbmNlUmVsYXRpb25zID0gW107XG4gICAgICAgIGlmICh0aGlzLmFzdClcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHRoaXMuYXN0LnByZWNlZGVuY2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGdyb3VwLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZXZlbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5hbWVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBidWlsdCBvZiB0aGlzLmJ1aWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmFyZ3MubGVuZ3RoID8gYnVpbHQubWF0Y2hlcyhpdGVtKSA6IGJ1aWx0LmlkID09IGl0ZW0uaWQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwucHVzaChidWlsdC50ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZCA9IEpTT04uc3RyaW5naWZ5KGl0ZW0udmFsdWUpLCBmb3VuZCA9IHRoaXMuYnVpbHQuZmluZChiID0+IGIuaWQgPT0gaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLnB1c2goZm91bmQudGVybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZXZlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmIud2FybihgUHJlY2VkZW5jZSBzcGVjaWZpZWQgZm9yIHVua25vd24gdG9rZW4gJHtpdGVtfWAsIGl0ZW0uc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ZXJtIG9mIGxldmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVsKHJlbCwgdGVybSwgcHJldik7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LmNvbmNhdChsZXZlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBwcmVjZWRlZEJ5KGEsIGIpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5wcmVjZWRlbmNlUmVsYXRpb25zLmZpbmQociA9PiByLnRlcm0gPT0gYSk7XG4gICAgICAgIHJldHVybiBmb3VuZCAmJiBmb3VuZC5hZnRlci5pbmNsdWRlcyhiKTtcbiAgICB9XG4gICAgYnVpbGRQcmVjVGFibGUoc29mdENvbmZsaWN0cykge1xuICAgICAgICBsZXQgcHJlY1RhYmxlID0gW10sIHJlbCA9IHRoaXMucHJlY2VkZW5jZVJlbGF0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBBZGQgZW50cmllcyBmb3Igc29mdC1jb25mbGljdGluZyB0b2tlbnMgdGhhdCBhcmUgaW4gdGhlXG4gICAgICAgIC8vIHByZWNlZGVuY2UgdGFibGUsIHRvIG1ha2Ugc3VyZSB0aGV5J2xsIGFwcGVhciBpbiB0aGUgcmlnaHRcbiAgICAgICAgLy8gb3JkZXIgYW5kIGRvbid0IG1lc3MgdXAgdGhlIGxvbmdlci13aW5zIGRlZmF1bHQgcnVsZS5cbiAgICAgICAgZm9yIChsZXQgeyBhLCBiLCBzb2Z0IH0gb2Ygc29mdENvbmZsaWN0cylcbiAgICAgICAgICAgIGlmIChzb2Z0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWwuc29tZShyID0+IHIudGVybSA9PSBhKSB8fCAhcmVsLnNvbWUociA9PiByLnRlcm0gPT0gYikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChzb2Z0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgW2EsIGJdID0gW2IsIGFdOyAvLyBOb3cgYSBpcyBsb25nZXIgdGhhbiBiIChhbmQgc2hvdWxkIHRodXMgdGFrZSBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGFkZFJlbChyZWwsIGIsIFthXSk7XG4gICAgICAgICAgICAgICAgYWRkUmVsKHJlbCwgYSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICBhZGQ6IHdoaWxlIChyZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZWNvcmQgPSByZWxbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hZnRlci5ldmVyeSh0ID0+IHByZWNUYWJsZS5pbmNsdWRlcyh0LmlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY1RhYmxlLnB1c2gocmVjb3JkLnRlcm0uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVsLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYWRkO1xuICAgICAgICAgICAgICAgICAgICByZWxbaV0gPSByZWwucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmIucmFpc2UoYEN5Y2xpYyB0b2tlbiBwcmVjZWRlbmNlIHJlbGF0aW9uIGJldHdlZW4gJHtyZWwubWFwKHIgPT4gci50ZXJtKS5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWNUYWJsZTtcbiAgICB9XG59XG5jbGFzcyBNYWluVG9rZW5TZXQgZXh0ZW5kcyBUb2tlblNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXhwbGljaXRDb25mbGljdHMgPSBbXTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbChleHByKSB7XG4gICAgICAgIGxldCBpZCA9IEpTT04uc3RyaW5naWZ5KGV4cHIudmFsdWUpO1xuICAgICAgICBmb3IgKGxldCBidWlsdCBvZiB0aGlzLmJ1aWx0KVxuICAgICAgICAgICAgaWYgKGJ1aWx0LmlkID09IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsdC50ZXJtO1xuICAgICAgICBsZXQgbmFtZSA9IG51bGwsIHByb3BzID0ge30sIGRpYWxlY3QgPSBudWxsLCBleHBvcnRlZCA9IG51bGw7XG4gICAgICAgIGxldCBkZWNsID0gdGhpcy5hc3QgPyB0aGlzLmFzdC5saXRlcmFscy5maW5kKGwgPT4gbC5saXRlcmFsID09IGV4cHIudmFsdWUpIDogbnVsbDtcbiAgICAgICAgaWYgKGRlY2wpXG4gICAgICAgICAgICAoeyBuYW1lLCBwcm9wcywgZGlhbGVjdCwgZXhwb3J0ZWQgfSA9IHRoaXMuYi5ub2RlSW5mbyhkZWNsLnByb3BzLCBcImRhXCIsIGV4cHIudmFsdWUpKTtcbiAgICAgICAgbGV0IHRlcm0gPSB0aGlzLmIubWFrZVRlcm1pbmFsKGlkLCBuYW1lLCBwcm9wcyk7XG4gICAgICAgIGlmIChkaWFsZWN0ICE9IG51bGwpXG4gICAgICAgICAgICAodGhpcy5ieURpYWxlY3RbZGlhbGVjdF0gfHwgKHRoaXMuYnlEaWFsZWN0W2RpYWxlY3RdID0gW10pKS5wdXNoKHRlcm0pO1xuICAgICAgICBpZiAoZXhwb3J0ZWQpXG4gICAgICAgICAgICB0aGlzLmIubmFtZWRUZXJtc1tleHBvcnRlZF0gPSB0ZXJtO1xuICAgICAgICB0aGlzLmJ1aWxkKGV4cHIsIHRoaXMuc3RhcnRTdGF0ZSwgbmV3IFN0YXRlJDEoW3Rlcm1dKSwgbm9uZSk7XG4gICAgICAgIHRoaXMuYnVpbHQucHVzaChuZXcgQnVpbHRSdWxlKGlkLCBub25lLCB0ZXJtKSk7XG4gICAgICAgIHJldHVybiB0ZXJtO1xuICAgIH1cbiAgICB0YWtlQ29uZmxpY3RzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXNvbHZlID0gKGV4cHIpID0+IHtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgTmFtZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBidWlsdCBvZiB0aGlzLmJ1aWx0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVpbHQubWF0Y2hlcyhleHByKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsdC50ZXJtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gSlNPTi5zdHJpbmdpZnkoZXhwci52YWx1ZSksIGZvdW5kID0gdGhpcy5idWlsdC5maW5kKGIgPT4gYi5pZCA9PSBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQudGVybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYi53YXJuKGBQcmVjZWRlbmNlIHNwZWNpZmllZCBmb3IgdW5rbm93biB0b2tlbiAke2V4cHJ9YCwgZXhwci5zdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgYyBvZiAoKF9hID0gdGhpcy5hc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25mbGljdHMpIHx8IFtdKSB7XG4gICAgICAgICAgICBsZXQgYSA9IHJlc29sdmUoYy5hKSwgYiA9IHJlc29sdmUoYy5iKTtcbiAgICAgICAgICAgIGlmIChhICYmIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5pZCA8IGIuaWQpXG4gICAgICAgICAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGxpY2l0Q29uZmxpY3RzLnB1c2goeyBhLCBiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRva2VuIGdyb3VwcyBhcmUgYSBtZWNoYW5pc20gZm9yIGFsbG93aW5nIGNvbmZsaWN0aW5nIChtYXRjaGluZ1xuICAgIC8vIG92ZXJsYXBwaW5nIGlucHV0LCB3aXRob3V0IGFuIGV4cGxpY2l0IHByZWNlZGVuY2UgYmVpbmcgZ2l2ZW4pXG4gICAgLy8gdG9rZW5zIHRvIGV4aXN0IGluIGEgZ3JhbW1hciBfaWZfIHRoZXkgZG9uJ3Qgb2NjdXIgaW4gdGhlIHNhbWVcbiAgICAvLyBwbGFjZSAoYXJlbid0IHVzZWQgaW4gdGhlIHNhbWUgc3RhdGVzKS5cbiAgICAvL1xuICAgIC8vIFN0YXRlcyB0aGF0IHVzZSB0b2tlbnMgdGhhdCBjb25mbGljdCB3aWxsIHJhaXNlIGFuIGVycm9yIHdoZW4gYW55XG4gICAgLy8gb2YgdGhlIGNvbmZsaWN0aW5nIHBhaXJzIG9mIHRva2VucyBib3RoIG9jY3VyIGluIHRoYXQgc3RhdGUuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGV5IGFyZSBhc3NpZ25lZCBhIHRva2VuIGdyb3VwLCB3aGljaCBpbmNsdWRlcyBhbGxcbiAgICAvLyB0aGUgcG90ZW50aWFsbHktY29uZmxpY3RpbmcgdG9rZW5zIHRoZXkgdXNlLiBJZiB0aGVyZSdzIGFscmVhZHkgYVxuICAgIC8vIGdyb3VwIHRoYXQgZG9lc24ndCBoYXZlIGFueSBjb25mbGljdHMgd2l0aCB0aG9zZSB0b2tlbnMsIHRoYXQgaXNcbiAgICAvLyByZXVzZWQsIG90aGVyd2lzZSBhIG5ldyBncm91cCBpcyBjcmVhdGVkLlxuICAgIC8vXG4gICAgLy8gU28gZWFjaCBzdGF0ZSBoYXMgemVybyBvciBvbmUgdG9rZW4gZ3JvdXBzLCBhbmQgZWFjaCBjb25mbGljdGluZ1xuICAgIC8vIHRva2VuIG1heSBiZWxvbmcgdG8gb25lIG9yIG1vcmUgZ3JvdXBzLiBUb2tlbnMgZ2V0IGFzc2lnbmVkIGFcbiAgICAvLyAxNi1iaXQgYml0bWFzayB3aXRoIHRoZSBncm91cHMgdGhleSBiZWxvbmcgdG8gc2V0IHRvIDEgKGFsbC0xc1xuICAgIC8vIGZvciBub24tY29uZmxpY3RpbmcgdG9rZW5zKS4gV2hlbiB0b2tlbml6aW5nLCB0aGF0IG1hc2sgaXNcbiAgICAvLyBjb21wYXJlZCB0byB0aGUgY3VycmVudCBzdGF0ZSdzIGdyb3VwIChhZ2FpbiB1c2luZyBhbGwtMXMgZm9yXG4gICAgLy8gZ3JvdXAtbGVzcyBzdGF0ZXMpIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdG9rZW4gaXMgYXBwbGljYWJsZSBmb3JcbiAgICAvLyB0aGlzIHN0YXRlLlxuICAgIC8vXG4gICAgLy8gRXh0ZW5kZWQvc3BlY2lhbGl6ZWQgdG9rZW5zIGFyZSB0cmVhdGVkIGFzIHRoZWlyIHBhcmVudCB0b2tlbiBmb3JcbiAgICAvLyB0aGlzIHB1cnBvc2UuXG4gICAgYnVpbGRUb2tlbkdyb3VwcyhzdGF0ZXMsIHNraXBJbmZvLCBzdGFydElEKSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLnN0YXJ0U3RhdGUuY29tcGlsZSgpO1xuICAgICAgICBpZiAodG9rZW5zLmFjY2VwdGluZy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmIucmFpc2UoYEdyYW1tYXIgY29udGFpbnMgemVyby1sZW5ndGggdG9rZW5zIChpbiAnJHt0b2tlbnMuYWNjZXB0aW5nWzBdLm5hbWV9JylgLCB0aGlzLnJ1bGVzLmZpbmQociA9PiByLmlkLm5hbWUgPT0gdG9rZW5zLmFjY2VwdGluZ1swXS5uYW1lKS5zdGFydCk7XG4gICAgICAgIGlmICgvXFxidG9rZW5zXFxiLy50ZXN0KHZlcmJvc2UpKVxuICAgICAgICAgICAgY29uc29sZS5sb2codG9rZW5zLnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHByZWNlZGVuY2Ugc3BlY2lmaWVkIGZvciB0aGUgcGFpciwgdGhlIGNvbmZsaWN0IGlzIHJlc29sdmVkXG4gICAgICAgIGxldCBhbGxDb25mbGljdHMgPSB0b2tlbnMuZmluZENvbmZsaWN0cyhjaGVja1RvZ2V0aGVyKHN0YXRlcywgdGhpcy5iLCBza2lwSW5mbykpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IGEsIGIgfSkgPT4gIXRoaXMucHJlY2VkZWRCeShhLCBiKSAmJiAhdGhpcy5wcmVjZWRlZEJ5KGIsIGEpKTtcbiAgICAgICAgZm9yIChsZXQgeyBhLCBiIH0gb2YgdGhpcy5leHBsaWNpdENvbmZsaWN0cykge1xuICAgICAgICAgICAgaWYgKCFhbGxDb25mbGljdHMuc29tZShjID0+IGMuYSA9PSBhICYmIGMuYiA9PSBiKSlcbiAgICAgICAgICAgICAgICBhbGxDb25mbGljdHMucHVzaChuZXcgQ29uZmxpY3QkMShhLCBiLCAwLCBcIlwiLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvZnRDb25mbGljdHMgPSBhbGxDb25mbGljdHMuZmlsdGVyKGMgPT4gYy5zb2Z0KSwgY29uZmxpY3RzID0gYWxsQ29uZmxpY3RzLmZpbHRlcihjID0+ICFjLnNvZnQpO1xuICAgICAgICBsZXQgZXJyb3JzID0gW107XG4gICAgICAgIGxldCBncm91cHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZGVmYXVsdFJlZHVjZSB8fCBzdGF0ZS50b2tlbkdyb3VwID4gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBGaW5kIHBvdGVudGlhbGx5LWNvbmZsaWN0aW5nIHRlcm1zIChpbiB0ZXJtcykgYW5kIHRoZSB0aGluZ3NcbiAgICAgICAgICAgIC8vIHRoZXkgY29uZmxpY3Qgd2l0aCAoaW4gY29uZmxpY3RzKSwgYW5kIHJhaXNlIGFuIGVycm9yIGlmXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGEgdG9rZW4gY29uZmxpY3QgZGlyZWN0bHkgaW4gdGhpcyBzdGF0ZS5cbiAgICAgICAgICAgIGxldCB0ZXJtcyA9IFtdLCBpbmNvbXBhdGlibGUgPSBbXTtcbiAgICAgICAgICAgIGxldCBza2lwID0gc2tpcEluZm9bdGhpcy5iLnNraXBSdWxlcy5pbmRleE9mKHN0YXRlLnNraXApXS5zdGFydFRva2VucztcbiAgICAgICAgICAgIGZvciAobGV0IHRlcm0gb2Ygc2tpcClcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYWN0aW9ucy5zb21lKGEgPT4gYS50ZXJtID09IHRlcm0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIucmFpc2UoYFVzZSBvZiB0b2tlbiAke3Rlcm0ubmFtZX0gY29uZmxpY3RzIHdpdGggc2tpcCBydWxlYCk7XG4gICAgICAgICAgICBsZXQgc3RhdGVUZXJtcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5hY3Rpb25zLmxlbmd0aCArIChza2lwID8gc2tpcC5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBpIDwgc3RhdGUuYWN0aW9ucy5sZW5ndGggPyBzdGF0ZS5hY3Rpb25zW2ldLnRlcm0gOiBza2lwW2kgLSBzdGF0ZS5hY3Rpb25zLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgbGV0IG9yaWcgPSB0aGlzLmIudG9rZW5PcmlnaW5zW3Rlcm0ubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9yaWcgJiYgb3JpZy5zcGVjKVxuICAgICAgICAgICAgICAgICAgICB0ZXJtID0gb3JpZy5zcGVjO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWcgJiYgb3JpZy5leHRlcm5hbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgYWRkVG9TZXQoc3RhdGVUZXJtcywgdGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVUZXJtcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IHRlcm0gb2Ygc3RhdGVUZXJtcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZsaWN0IG9mIGNvbmZsaWN0cykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmxpY3RpbmcgPSBjb25mbGljdC5hID09IHRlcm0gPyBjb25mbGljdC5iIDogY29uZmxpY3QuYiA9PSB0ZXJtID8gY29uZmxpY3QuYSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmxpY3RpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlVGVybXMuaW5jbHVkZXMoY29uZmxpY3RpbmcpICYmICFlcnJvcnMuc29tZShlID0+IGUuY29uZmxpY3QgPT0gY29uZmxpY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhhbXBsZSA9IGNvbmZsaWN0LmV4YW1wbGVBID8gYCAoZXhhbXBsZTogJHtKU09OLnN0cmluZ2lmeShjb25mbGljdC5leGFtcGxlQSl9JHtjb25mbGljdC5leGFtcGxlQiA/IGAgdnMgJHtKU09OLnN0cmluZ2lmeShjb25mbGljdC5leGFtcGxlQil9YCA6IFwiXCJ9KWAgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgT3ZlcmxhcHBpbmcgdG9rZW5zICR7dGVybS5uYW1lfSBhbmQgJHtjb25mbGljdGluZy5uYW1lfSB1c2VkIGluIHNhbWUgY29udGV4dCR7ZXhhbXBsZX1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEFmdGVyOiAke3N0YXRlLnNldFswXS50cmFpbCgpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvU2V0KHRlcm1zLCB0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9TZXQoaW5jb21wYXRpYmxlLCBjb25mbGljdGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRva2VuR3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY29tcGF0aWJsZS5zb21lKHRlcm0gPT4gZ3JvdXAudG9rZW5zLmluY2x1ZGVzKHRlcm0pKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGVybSBvZiB0ZXJtcylcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9TZXQoZ3JvdXAudG9rZW5zLCB0ZXJtKTtcbiAgICAgICAgICAgICAgICB0b2tlbkdyb3VwID0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRva2VuR3JvdXApIHtcbiAgICAgICAgICAgICAgICB0b2tlbkdyb3VwID0gbmV3IFRva2VuR3JvdXAodGVybXMsIGdyb3Vwcy5sZW5ndGggKyBzdGFydElEKTtcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaCh0b2tlbkdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnRva2VuR3JvdXAgPSB0b2tlbkdyb3VwLmdyb3VwSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmIucmFpc2UoZXJyb3JzLm1hcChlID0+IGUuZXJyb3IpLmpvaW4oXCJcXG5cXG5cIikpO1xuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCArIHN0YXJ0SUQgPiAxNilcbiAgICAgICAgICAgIHRoaXMuYi5yYWlzZShgVG9vIG1hbnkgZGlmZmVyZW50IHRva2VuIGdyb3VwcyAoJHtncm91cHMubGVuZ3RofSkgdG8gcmVwcmVzZW50IHRoZW0gYXMgYSAxNi1iaXQgYml0ZmllbGRgKTtcbiAgICAgICAgbGV0IHByZWNUYWJsZSA9IHRoaXMuYnVpbGRQcmVjVGFibGUoc29mdENvbmZsaWN0cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbkdyb3VwczogZ3JvdXBzLFxuICAgICAgICAgICAgdG9rZW5QcmVjOiBwcmVjVGFibGUsXG4gICAgICAgICAgICB0b2tlbkRhdGE6IHRva2Vucy50b0FycmF5KGJ1aWxkVG9rZW5NYXNrcyhncm91cHMpLCBwcmVjVGFibGUpXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgTG9jYWxUb2tlblNldCBleHRlbmRzIFRva2VuU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihiLCBhc3QpIHtcbiAgICAgICAgc3VwZXIoYiwgYXN0KTtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmIChhc3QuZmFsbGJhY2spXG4gICAgICAgICAgICBiLnVuaXF1ZShhc3QuZmFsbGJhY2suaWQpO1xuICAgIH1cbiAgICBnZXRUb2tlbihleHByKSB7XG4gICAgICAgIGxldCB0ZXJtID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYXN0LmZhbGxiYWNrICYmIHRoaXMuYXN0LmZhbGxiYWNrLmlkLm5hbWUgPT0gZXhwci5pZC5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmIucmFpc2UoYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciAke2V4cHIuaWQubmFtZX1gLCBleHByLnN0YXJ0KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGxldCB7IG5hbWU6IG5vZGVOYW1lLCBwcm9wcywgZXhwb3J0ZWQgfSA9IHRoaXMuYi5ub2RlSW5mbyh0aGlzLmFzdC5mYWxsYmFjay5wcm9wcywgXCJcIiwgZXhwci5pZC5uYW1lLCBub25lLCBub25lKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IHRoaXMuZmFsbGJhY2sgPSB0aGlzLmIubWFrZVRlcm1pbmFsKGV4cHIuaWQubmFtZSwgbm9kZU5hbWUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAodGVybS5ub2RlVHlwZSB8fCBleHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm0ubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtLnByZXNlcnZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iLm5hbWVkVGVybXNbZXhwb3J0ZWQgfHwgZXhwci5pZC5uYW1lXSA9IHRlcm07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYi51c2VkKGV4cHIuaWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXJtID0gdGhpcy5mYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlcm0gPSBzdXBlci5nZXRUb2tlbihleHByKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybSAmJiAhdGhpcy5iLnRva2VuT3JpZ2luc1t0ZXJtLm5hbWVdKVxuICAgICAgICAgICAgdGhpcy5iLnRva2VuT3JpZ2luc1t0ZXJtLm5hbWVdID0geyBncm91cDogdGhpcyB9O1xuICAgICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gICAgYnVpbGRMb2NhbEdyb3VwKHN0YXRlcywgc2tpcEluZm8sIGlkKSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLnN0YXJ0U3RhdGUuY29tcGlsZSgpO1xuICAgICAgICBpZiAodG9rZW5zLmFjY2VwdGluZy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmIucmFpc2UoYEdyYW1tYXIgY29udGFpbnMgemVyby1sZW5ndGggdG9rZW5zIChpbiAnJHt0b2tlbnMuYWNjZXB0aW5nWzBdLm5hbWV9JylgLCB0aGlzLnJ1bGVzLmZpbmQociA9PiByLmlkLm5hbWUgPT0gdG9rZW5zLmFjY2VwdGluZ1swXS5uYW1lKS5zdGFydCk7XG4gICAgICAgIGZvciAobGV0IHsgYSwgYiwgZXhhbXBsZUEgfSBvZiB0b2tlbnMuZmluZENvbmZsaWN0cygoKSA9PiB0cnVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNlZGVkQnkoYSwgYikgJiYgIXRoaXMucHJlY2VkZWRCeShiLCBhKSlcbiAgICAgICAgICAgICAgICB0aGlzLmIucmFpc2UoYE92ZXJsYXBwaW5nIHRva2VucyAke2EubmFtZX0gYW5kICR7Yi5uYW1lfSBpbiBsb2NhbCB0b2tlbiBncm91cCR7ZXhhbXBsZUEgPyBgIChleGFtcGxlOiAke0pTT04uc3RyaW5naWZ5KGV4YW1wbGVBKX0pYCA6ICcnfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHN0YXRlIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmRlZmF1bHRSZWR1Y2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBTZWUgaWYgdGhpcyBzdGF0ZSB1c2VzIGFueSBvZiB0aGUgdG9rZW5zIGluIHRoaXMgZ3JvdXAsIGFuZFxuICAgICAgICAgICAgLy8gaWYgc28sIG1ha2Ugc3VyZSBpdCAqb25seSogdXNlcyB0b2tlbnMgZnJvbSB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgbGV0IHVzZXNUaGlzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB1c2VzT3RoZXIgPSBza2lwSW5mb1t0aGlzLmIuc2tpcFJ1bGVzLmluZGV4T2Yoc3RhdGUuc2tpcCldLnN0YXJ0VG9rZW5zWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgeyB0ZXJtIH0gb2Ygc3RhdGUuYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGxldCBvcmlnID0gdGhpcy5iLnRva2VuT3JpZ2luc1t0ZXJtLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICgob3JpZyA9PT0gbnVsbCB8fCBvcmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnLmdyb3VwKSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB1c2VzVGhpcyA9IHRlcm07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1c2VzT3RoZXIgPSB0ZXJtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXNUaGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXNPdGhlcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iLnJhaXNlKGBUb2tlbnMgZnJvbSBhIGxvY2FsIHRva2VuIGdyb3VwIHVzZWQgdG9nZXRoZXIgd2l0aCBvdGhlciB0b2tlbnMgKCR7dXNlc1RoaXMubmFtZX0gd2l0aCAke3VzZXNPdGhlci5uYW1lfSlgKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS50b2tlbkdyb3VwID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNUYWJsZSA9IHRoaXMuYnVpbGRQcmVjVGFibGUobm9uZSk7XG4gICAgICAgIGxldCB0b2tlbkRhdGEgPSB0b2tlbnMudG9BcnJheSh7IFtpZF06IDY1NTM1IC8qIFNlcS5FbmQgKi8gfSwgcHJlY1RhYmxlKTtcbiAgICAgICAgbGV0IHByZWNPZmZzZXQgPSB0b2tlbkRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgZnVsbERhdGEgPSBuZXcgVWludDE2QXJyYXkodG9rZW5EYXRhLmxlbmd0aCArIHByZWNUYWJsZS5sZW5ndGggKyAxKTtcbiAgICAgICAgZnVsbERhdGEuc2V0KHRva2VuRGF0YSwgMCk7XG4gICAgICAgIGZ1bGxEYXRhLnNldChwcmVjVGFibGUsIHByZWNPZmZzZXQpO1xuICAgICAgICBmdWxsRGF0YVtmdWxsRGF0YS5sZW5ndGggLSAxXSA9IDY1NTM1IC8qIFNlcS5FbmQgKi87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cElEOiBpZCxcbiAgICAgICAgICAgIGNyZWF0ZTogKCkgPT4gbmV3IExvY2FsVG9rZW5Hcm91cChmdWxsRGF0YSwgcHJlY09mZnNldCwgdGhpcy5mYWxsYmFjayA/IHRoaXMuZmFsbGJhY2suaWQgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgY3JlYXRlU291cmNlOiBpbXBvcnROYW1lID0+IGBuZXcgJHtpbXBvcnROYW1lKFwiTG9jYWxUb2tlbkdyb3VwXCIsIFwiQGxlemVyL2xyXCIpfSgke2VuY29kZUFycmF5KGZ1bGxEYXRhKX0sICR7cHJlY09mZnNldH0ke3RoaXMuZmFsbGJhY2sgPyBgLCAke3RoaXMuZmFsbGJhY2suaWR9YCA6ICcnfSlgXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tUb2dldGhlcihzdGF0ZXMsIGIsIHNraXBJbmZvKSB7XG4gICAgbGV0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBoYXNUZXJtKHN0YXRlLCB0ZXJtKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5hY3Rpb25zLnNvbWUoYSA9PiBhLnRlcm0gPT0gdGVybSkgfHxcbiAgICAgICAgICAgIHNraXBJbmZvW2Iuc2tpcFJ1bGVzLmluZGV4T2Yoc3RhdGUuc2tpcCldLnN0YXJ0VG9rZW5zLmluY2x1ZGVzKHRlcm0pO1xuICAgIH1cbiAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEuaWQgPCBiLmlkKVxuICAgICAgICAgICAgW2EsIGJdID0gW2IsIGFdO1xuICAgICAgICBsZXQga2V5ID0gYS5pZCB8IChiLmlkIDw8IDE2KSwgY2FjaGVkID0gY2FjaGVba2V5XTtcbiAgICAgICAgaWYgKGNhY2hlZCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgcmV0dXJuIGNhY2hlW2tleV0gPSBzdGF0ZXMuc29tZShzdGF0ZSA9PiBoYXNUZXJtKHN0YXRlLCBhKSAmJiBoYXNUZXJtKHN0YXRlLCBiKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludmVydFJhbmdlcyhyYW5nZXMpIHtcbiAgICBsZXQgcG9zID0gMCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgW2EsIGJdIG9mIHJhbmdlcykge1xuICAgICAgICBpZiAoYSA+IHBvcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtwb3MsIGFdKTtcbiAgICAgICAgcG9zID0gYjtcbiAgICB9XG4gICAgaWYgKHBvcyA8PSBNQVhfQ09ERSlcbiAgICAgICAgcmVzdWx0LnB1c2goW3BvcywgTUFYX0NPREUgKyAxXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEFTVFJBTCA9IDB4MTAwMDAsIEdBUF9TVEFSVCA9IDB4ZDgwMCwgR0FQX0VORCA9IDB4ZTAwMCwgTUFYX0NPREUgPSAweDEwZmZmZjtcbmNvbnN0IExPV19TVVJSX0IgPSAweGRjMDAsIEhJR0hfU1VSUl9CID0gMHhkZmZmO1xuLy8gQ3JlYXRlIGludGVybWVkaWF0ZSBzdGF0ZXMgZm9yIGFzdHJhbCBjaGFyYWN0ZXJzIGluIGEgcmFuZ2UsIGlmXG4vLyBuZWNlc3NhcnksIHNpbmNlIHRoZSB0b2tlbml6ZXIgYWN0cyBvbiBVVEYxNiBjaGFyYWN0ZXJzXG5mdW5jdGlvbiByYW5nZUVkZ2VzKGZyb20sIHRvLCBsb3csIGhpKSB7XG4gICAgaWYgKGxvdyA8IEFTVFJBTCkge1xuICAgICAgICBpZiAobG93IDwgR0FQX1NUQVJUKVxuICAgICAgICAgICAgZnJvbS5lZGdlKGxvdywgTWF0aC5taW4oaGksIEdBUF9TVEFSVCksIHRvKTtcbiAgICAgICAgaWYgKGhpID4gR0FQX0VORClcbiAgICAgICAgICAgIGZyb20uZWRnZShNYXRoLm1heChsb3csIEdBUF9FTkQpLCBNYXRoLm1pbihoaSwgTUFYX0NIQVIgKyAxKSwgdG8pO1xuICAgICAgICBsb3cgPSBBU1RSQUw7XG4gICAgfVxuICAgIGlmIChoaSA8PSBBU1RSQUwpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbG93U3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQobG93KSwgaGlTdHIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChoaSAtIDEpO1xuICAgIGxldCBsb3dBID0gbG93U3RyLmNoYXJDb2RlQXQoMCksIGxvd0IgPSBsb3dTdHIuY2hhckNvZGVBdCgxKTtcbiAgICBsZXQgaGlBID0gaGlTdHIuY2hhckNvZGVBdCgwKSwgaGlCID0gaGlTdHIuY2hhckNvZGVBdCgxKTtcbiAgICBpZiAobG93QSA9PSBoaUEpIHsgLy8gU2hhcmUgdGhlIGZpcnN0IGNoYXIgY29kZVxuICAgICAgICBsZXQgaG9wID0gbmV3IFN0YXRlJDE7XG4gICAgICAgIGZyb20uZWRnZShsb3dBLCBsb3dBICsgMSwgaG9wKTtcbiAgICAgICAgaG9wLmVkZ2UobG93QiwgaGlCICsgMSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG1pZFN0YXJ0ID0gbG93QSwgbWlkRW5kID0gaGlBO1xuICAgICAgICBpZiAobG93QiA+IExPV19TVVJSX0IpIHtcbiAgICAgICAgICAgIG1pZFN0YXJ0Kys7XG4gICAgICAgICAgICBsZXQgaG9wID0gbmV3IFN0YXRlJDE7XG4gICAgICAgICAgICBmcm9tLmVkZ2UobG93QSwgbG93QSArIDEsIGhvcCk7XG4gICAgICAgICAgICBob3AuZWRnZShsb3dCLCBISUdIX1NVUlJfQiArIDEsIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlCIDwgSElHSF9TVVJSX0IpIHtcbiAgICAgICAgICAgIG1pZEVuZC0tO1xuICAgICAgICAgICAgbGV0IGhvcCA9IG5ldyBTdGF0ZSQxO1xuICAgICAgICAgICAgZnJvbS5lZGdlKGhpQSwgaGlBICsgMSwgaG9wKTtcbiAgICAgICAgICAgIGhvcC5lZGdlKExPV19TVVJSX0IsIGhpQiArIDEsIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlkU3RhcnQgPD0gbWlkRW5kKSB7XG4gICAgICAgICAgICBsZXQgaG9wID0gbmV3IFN0YXRlJDE7XG4gICAgICAgICAgICBmcm9tLmVkZ2UobWlkU3RhcnQsIG1pZEVuZCArIDEsIGhvcCk7XG4gICAgICAgICAgICBob3AuZWRnZShMT1dfU1VSUl9CLCBISUdIX1NVUlJfQiArIDEsIHRvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRW1wdHkoZXhwcikge1xuICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgU2VxdWVuY2VFeHByZXNzaW9uICYmIGV4cHIuZXhwcnMubGVuZ3RoID09IDA7XG59XG5mdW5jdGlvbiBnYXRoZXJFeHRUb2tlbnMoYiwgdG9rZW5zKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGIudW5pcXVlKHRva2VuLmlkKTtcbiAgICAgICAgbGV0IHsgbmFtZSwgcHJvcHMsIGRpYWxlY3QgfSA9IGIubm9kZUluZm8odG9rZW4ucHJvcHMsIFwiZFwiLCB0b2tlbi5pZC5uYW1lKTtcbiAgICAgICAgbGV0IHRlcm0gPSBiLm1ha2VUZXJtaW5hbCh0b2tlbi5pZC5uYW1lLCBuYW1lLCBwcm9wcyk7XG4gICAgICAgIGlmIChkaWFsZWN0ICE9IG51bGwpXG4gICAgICAgICAgICAoYi50b2tlbnMuYnlEaWFsZWN0W2RpYWxlY3RdIHx8IChiLnRva2Vucy5ieURpYWxlY3RbZGlhbGVjdF0gPSBbXSkpLnB1c2godGVybSk7XG4gICAgICAgIGIubmFtZWRUZXJtc1t0b2tlbi5pZC5uYW1lXSA9IHJlc3VsdFt0b2tlbi5pZC5uYW1lXSA9IHRlcm07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kRXh0VG9rZW4oYiwgdG9rZW5zLCBleHByKSB7XG4gICAgbGV0IGZvdW5kID0gdG9rZW5zW2V4cHIuaWQubmFtZV07XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGV4cHIuYXJncy5sZW5ndGgpXG4gICAgICAgIGIucmFpc2UoXCJFeHRlcm5hbCB0b2tlbnMgY2Fubm90IHRha2UgYXJndW1lbnRzXCIsIGV4cHIuYXJnc1swXS5zdGFydCk7XG4gICAgYi51c2VkKGV4cHIuaWQubmFtZSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gYWRkUmVsKHJlbCwgdGVybSwgYWZ0ZXIpIHtcbiAgICBsZXQgZm91bmQgPSByZWwuZmluZEluZGV4KHIgPT4gci50ZXJtID09IHRlcm0pO1xuICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgIHJlbC5wdXNoKHsgdGVybSwgYWZ0ZXIgfSk7XG4gICAgZWxzZVxuICAgICAgICByZWxbZm91bmRdID0geyB0ZXJtLCBhZnRlcjogcmVsW2ZvdW5kXS5hZnRlci5jb25jYXQoYWZ0ZXIpIH07XG59XG5jbGFzcyBFeHRlcm5hbFRva2VuU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihiLCBhc3QpIHtcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMudG9rZW5zID0gZ2F0aGVyRXh0VG9rZW5zKGIsIGFzdC50b2tlbnMpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMudG9rZW5zKVxuICAgICAgICAgICAgdGhpcy5iLnRva2VuT3JpZ2luc1t0aGlzLnRva2Vuc1tuYW1lXS5uYW1lXSA9IHsgZXh0ZXJuYWw6IHRoaXMgfTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oZXhwcikgeyByZXR1cm4gZmluZEV4dFRva2VuKHRoaXMuYiwgdGhpcy50b2tlbnMsIGV4cHIpOyB9XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iLm9wdGlvbnMuZXh0ZXJuYWxUb2tlbml6ZXIodGhpcy5hc3QuaWQubmFtZSwgdGhpcy5iLnRlcm1UYWJsZSk7XG4gICAgfVxuICAgIGNyZWF0ZVNvdXJjZShpbXBvcnROYW1lKSB7XG4gICAgICAgIGxldCB7IHNvdXJjZSwgaWQ6IHsgbmFtZSB9IH0gPSB0aGlzLmFzdDtcbiAgICAgICAgcmV0dXJuIGltcG9ydE5hbWUobmFtZSwgc291cmNlKTtcbiAgICB9XG59XG5jbGFzcyBFeHRlcm5hbFNwZWNpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihiLCBhc3QpIHtcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5zID0gZ2F0aGVyRXh0VG9rZW5zKGIsIGFzdC50b2tlbnMpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGxldCB0ZXJtcyA9IHRoaXMuYi5ub3JtYWxpemVFeHByKHRoaXMuYXN0LnRva2VuKTtcbiAgICAgICAgaWYgKHRlcm1zLmxlbmd0aCAhPSAxIHx8IHRlcm1zWzBdLnRlcm1zLmxlbmd0aCAhPSAxIHx8ICF0ZXJtc1swXS50ZXJtc1swXS50ZXJtaW5hbClcbiAgICAgICAgICAgIHRoaXMuYi5yYWlzZShgVGhlIHRva2VuIGV4cHJlc3Npb24gdG8gJ0BleHRlcm5hbCAke3RoaXMuYXN0LnR5cGV9JyBtdXN0IHJlc29sdmUgdG8gYSB0b2tlbmAsIHRoaXMuYXN0LnRva2VuLnN0YXJ0KTtcbiAgICAgICAgdGhpcy50ZXJtID0gdGVybXNbMF0udGVybXNbMF07XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy50b2tlbnMpXG4gICAgICAgICAgICB0aGlzLmIudG9rZW5PcmlnaW5zW3RoaXMudG9rZW5zW25hbWVdLm5hbWVdID0geyBzcGVjOiB0aGlzLnRlcm0sIGV4dGVybmFsOiB0aGlzIH07XG4gICAgfVxuICAgIGdldFRva2VuKGV4cHIpIHsgcmV0dXJuIGZpbmRFeHRUb2tlbih0aGlzLmIsIHRoaXMudG9rZW5zLCBleHByKTsgfVxufVxuZnVuY3Rpb24gaW5saW5lUnVsZXMocnVsZXMsIHByZXNlcnZlKSB7XG4gICAgZm9yIChsZXQgcGFzcyA9IDA7OyBwYXNzKyspIHtcbiAgICAgICAgbGV0IGlubGluYWJsZSA9IE9iamVjdC5jcmVhdGUobnVsbCksIGZvdW5kO1xuICAgICAgICBpZiAocGFzcyA9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLm5hbWUuaW5saW5lICYmICFpbmxpbmFibGVbcnVsZS5uYW1lLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IHJ1bGVzLmZpbHRlcihyID0+IHIubmFtZSA9PSBydWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuc29tZShyID0+IHIucGFydHMuaW5jbHVkZXMocnVsZS5uYW1lKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpbmxpbmFibGVbcnVsZS5uYW1lLm5hbWVdID0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKCFydWxlLm5hbWUuaW50ZXJlc3RpbmcgJiYgIXJ1bGUucGFydHMuaW5jbHVkZXMocnVsZS5uYW1lKSAmJiBydWxlLnBhcnRzLmxlbmd0aCA8IDMgJiZcbiAgICAgICAgICAgICAgICAhcHJlc2VydmUuaW5jbHVkZXMocnVsZS5uYW1lKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLnBhcnRzLmxlbmd0aCA9PSAxIHx8IHJ1bGVzLmV2ZXJ5KG90aGVyID0+IG90aGVyLnNraXAgPT0gcnVsZS5za2lwIHx8ICFvdGhlci5wYXJ0cy5pbmNsdWRlcyhydWxlLm5hbWUpKSkgJiZcbiAgICAgICAgICAgICAgICAhcnVsZS5wYXJ0cy5zb21lKHAgPT4gISFpbmxpbmFibGVbcC5uYW1lXSkgJiZcbiAgICAgICAgICAgICAgICAhcnVsZXMuc29tZSgociwgaikgPT4gaiAhPSBpICYmIHIubmFtZSA9PSBydWxlLm5hbWUpKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gaW5saW5hYmxlW3J1bGUubmFtZS5uYW1lXSA9IFtydWxlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgICBsZXQgbmV3UnVsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgaWYgKGlubGluYWJsZVtydWxlLm5hbWUubmFtZV0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXJ1bGUucGFydHMuc29tZShwID0+ICEhaW5saW5hYmxlW3AubmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgbmV3UnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4cGFuZChhdCwgY29uZmxpY3RzLCBwYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChhdCA9PSBydWxlLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdSdWxlcy5wdXNoKG5ldyBSdWxlKHJ1bGUubmFtZSwgcGFydHMsIGNvbmZsaWN0cywgcnVsZS5za2lwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBydWxlLnBhcnRzW2F0XSwgcmVwbGFjZSA9IGlubGluYWJsZVtuZXh0Lm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghcmVwbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmQoYXQgKyAxLCBjb25mbGljdHMuY29uY2F0KHJ1bGUuY29uZmxpY3RzW2F0ICsgMV0pLCBwYXJ0cy5jb25jYXQobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmVwbGFjZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kKGF0ICsgMSwgY29uZmxpY3RzLnNsaWNlKDAsIGNvbmZsaWN0cy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjb25mbGljdHNbYXRdLmpvaW4oci5jb25mbGljdHNbMF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyLmNvbmZsaWN0cy5zbGljZSgxLCByLmNvbmZsaWN0cy5sZW5ndGggLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocnVsZS5jb25mbGljdHNbYXQgKyAxXS5qb2luKHIuY29uZmxpY3RzW3IuY29uZmxpY3RzLmxlbmd0aCAtIDFdKSksIHBhcnRzLmNvbmNhdChyLnBhcnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBhbmQoMCwgW3J1bGUuY29uZmxpY3RzWzBdXSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGVzID0gbmV3UnVsZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VSdWxlcyhydWxlcykge1xuICAgIGxldCBtZXJnZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBmb3VuZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGdyb3VwU3RhcnQgPSBpO1xuICAgICAgICBsZXQgbmFtZSA9IHJ1bGVzW2krK10ubmFtZTtcbiAgICAgICAgd2hpbGUgKGkgPCBydWxlcy5sZW5ndGggJiYgcnVsZXNbaV0ubmFtZSA9PSBuYW1lKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBsZXQgc2l6ZSA9IGkgLSBncm91cFN0YXJ0O1xuICAgICAgICBpZiAobmFtZS5pbnRlcmVzdGluZylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHJ1bGVzLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBvdGhlclN0YXJ0ID0gaiwgb3RoZXJOYW1lID0gcnVsZXNbaisrXS5uYW1lO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBydWxlcy5sZW5ndGggJiYgcnVsZXNbal0ubmFtZSA9PSBvdGhlck5hbWUpXG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgaWYgKGogLSBvdGhlclN0YXJ0ICE9IHNpemUgfHwgb3RoZXJOYW1lLmludGVyZXN0aW5nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2l6ZSAmJiBtYXRjaDsgaysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBydWxlc1tncm91cFN0YXJ0ICsga10sIGIgPSBydWxlc1tvdGhlclN0YXJ0ICsga107XG4gICAgICAgICAgICAgICAgaWYgKGEuY21wTm9OYW1lKGIpICE9IDApXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBtZXJnZWRbbmFtZS5uYW1lXSA9IG90aGVyTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgbGV0IG5ld1J1bGVzID0gW107XG4gICAgZm9yIChsZXQgcnVsZSBvZiBydWxlcylcbiAgICAgICAgaWYgKCFtZXJnZWRbcnVsZS5uYW1lLm5hbWVdKSB7XG4gICAgICAgICAgICBuZXdSdWxlcy5wdXNoKHJ1bGUucGFydHMuZXZlcnkocCA9PiAhbWVyZ2VkW3AubmFtZV0pID8gcnVsZSA6XG4gICAgICAgICAgICAgICAgbmV3IFJ1bGUocnVsZS5uYW1lLCBydWxlLnBhcnRzLm1hcChwID0+IG1lcmdlZFtwLm5hbWVdIHx8IHApLCBydWxlLmNvbmZsaWN0cywgcnVsZS5za2lwKSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbmV3UnVsZXM7XG59XG5mdW5jdGlvbiBzaW1wbGlmeVJ1bGVzKHJ1bGVzLCBwcmVzZXJ2ZSkge1xuICAgIHJldHVybiBtZXJnZVJ1bGVzKGlubGluZVJ1bGVzKHJ1bGVzLCBwcmVzZXJ2ZSkpO1xufVxuLyoqXG5CdWlsZCBhbiBpbi1tZW1vcnkgcGFyc2VyIGluc3RhbmNlIGZvciBhIGdpdmVuIGdyYW1tYXIuIFRoaXMgaXNcbm1vc3RseSB1c2VmdWwgZm9yIHRlc3RpbmcuIElmIHlvdXIgZ3JhbW1hciB1c2VzIGV4dGVybmFsXG50b2tlbml6ZXJzLCB5b3UnbGwgaGF2ZSB0byBwcm92aWRlIHRoZSBgZXh0ZXJuYWxUb2tlbml6ZXJgIG9wdGlvblxuZm9yIHRoZSByZXR1cm5lZCBwYXJzZXIgdG8gYmUgYWJsZSB0byBwYXJzZSBhbnl0aGluZy5cbiovXG5mdW5jdGlvbiBidWlsZFBhcnNlcih0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgYnVpbGRlciA9IG5ldyBCdWlsZGVyKHRleHQsIG9wdGlvbnMpLCBwYXJzZXIgPSBidWlsZGVyLmdldFBhcnNlcigpO1xuICAgIHBhcnNlci50ZXJtVGFibGUgPSBidWlsZGVyLnRlcm1UYWJsZTtcbiAgICByZXR1cm4gcGFyc2VyO1xufVxuY29uc3QgS0VZV09SRFMgPSBbXCJhd2FpdFwiLCBcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsXG4gICAgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIixcbiAgICBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiLCBcIm5ld1wiLCBcImluXCIsIFwidGhpc1wiLFxuICAgIFwiY29uc3RcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJzdXBlclwiLCBcImVudW1cIiwgXCJpbXBsZW1lbnRzXCIsIFwiaW50ZXJmYWNlXCIsXG4gICAgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCIsIFwicmVxdWlyZVwiXTtcbi8qKlxuQnVpbGQgdGhlIGNvZGUgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJzZXIgdGFibGVzIGZvciBhIGdpdmVuXG5ncmFtbWFyIGRlc2NyaXB0aW9uLiBUaGUgYHBhcnNlcmAgcHJvcGVydHkgaW4gdGhlIHJldHVybiB2YWx1ZVxuaG9sZHMgdGhlIG1haW4gZmlsZSB0aGF0IGV4cG9ydHMgdGhlIGBQYXJzZXJgIGluc3RhbmNlLiBUaGVcbmB0ZXJtc2AgcHJvcGVydHkgaG9sZHMgYSBkZWNsYXJhdGlvbiBmaWxlIHRoYXQgZGVmaW5lcyBjb25zdGFudHNcbmZvciBhbGwgb2YgdGhlIG5hbWVkIHRlcm1zIGluIGdyYW1tYXIsIGhvbGRpbmcgdGhlaXIgaWRzIGFzIHZhbHVlLlxuVGhpcyBpcyB1c2VmdWwgd2hlbiBleHRlcm5hbCBjb2RlLCBzdWNoIGFzIGEgdG9rZW5pemVyLCBuZWVkcyB0b1xuYmUgYWJsZSB0byB1c2UgdGhlc2UgaWRzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBydW4gYSB0cmVlLXNoYWtpbmdcbmJ1bmRsZXIgd2hlbiBpbXBvcnRpbmcgdGhpcyBmaWxlLCBzaW5jZSB5b3UgdXN1YWxseSBvbmx5IG5lZWQgYVxuaGFuZGZ1bCBvZiB0aGUgbWFueSB0ZXJtcyBpbiB5b3VyIGNvZGUuXG4qL1xuZnVuY3Rpb24gYnVpbGRQYXJzZXJGaWxlKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgQnVpbGRlcih0ZXh0LCBvcHRpb25zKS5nZXRQYXJzZXJGaWxlKCk7XG59XG5mdW5jdGlvbiBpZ25vcmVkKG5hbWUpIHtcbiAgICBsZXQgZmlyc3QgPSBuYW1lWzBdO1xuICAgIHJldHVybiBmaXJzdCA9PSBcIl9cIiB8fCBmaXJzdC50b1VwcGVyQ2FzZSgpICE9IGZpcnN0O1xufVxuZnVuY3Rpb24gaXNFeHBvcnRlZChydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUucHJvcHMuc29tZShwID0+IHAuYXQgJiYgcC5uYW1lID09IFwiZXhwb3J0XCIpO1xufVxuXG5leHBvcnQgeyBHZW5FcnJvciwgYnVpbGRQYXJzZXIsIGJ1aWxkUGFyc2VyRmlsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9