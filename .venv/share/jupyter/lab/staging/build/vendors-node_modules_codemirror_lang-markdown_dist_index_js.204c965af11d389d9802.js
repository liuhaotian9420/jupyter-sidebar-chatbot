"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_lang-markdown_dist_index_js"],{

/***/ "./node_modules/@codemirror/lang-markdown/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/lang-markdown/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   commonmarkLanguage: () => (/* binding */ commonmarkLanguage),
/* harmony export */   deleteMarkupBackward: () => (/* binding */ deleteMarkupBackward),
/* harmony export */   insertNewlineContinueMarkup: () => (/* binding */ insertNewlineContinueMarkup),
/* harmony export */   markdown: () => (/* binding */ markdown),
/* harmony export */   markdownKeymap: () => (/* binding */ markdownKeymap),
/* harmony export */   markdownLanguage: () => (/* binding */ markdownLanguage)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ "webpack/sharing/consume/default/@codemirror/state/@codemirror/state");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ "webpack/sharing/consume/default/@codemirror/view/@codemirror/view");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ "webpack/sharing/consume/default/@codemirror/language/@codemirror/language");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_codemirror_language__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/autocomplete */ "./node_modules/@codemirror/autocomplete/dist/index.js");
/* harmony import */ var _lezer_markdown__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lezer/markdown */ "./node_modules/@lezer/markdown/dist/index.js");
/* harmony import */ var _codemirror_lang_html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/lang-html */ "./node_modules/@codemirror/lang-html/dist/index.js");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lezer/common */ "webpack/sharing/consume/default/@lezer/common/@lezer/common");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lezer_common__WEBPACK_IMPORTED_MODULE_4__);








const data = /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.defineLanguageFacet)({ commentTokens: { block: { open: "<!--", close: "-->" } } });
const headingProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_4__.NodeProp();
const commonmark = /*@__PURE__*/_lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.parser.configure({
    props: [
        /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add(type => {
            return !type.is("Block") || type.is("Document") || isHeading(type) != null || isList(type) ? undefined
                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });
        }),
        /*@__PURE__*/headingProp.add(isHeading),
        /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentNodeProp.add({
            Document: () => null
        }),
        /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.languageDataProp.add({
            Document: data
        })
    ]
});
function isHeading(type) {
    let match = /^(?:ATX|Setext)Heading(\d)$/.exec(type.name);
    return match ? +match[1] : undefined;
}
function isList(type) {
    return type.name == "OrderedList" || type.name == "BulletList";
}
function findSectionEnd(headerNode, level) {
    let last = headerNode;
    for (;;) {
        let next = last.nextSibling, heading;
        if (!next || (heading = isHeading(next.type)) != null && heading <= level)
            break;
        last = next;
    }
    return last.to;
}
const headerIndent = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldService.of((state, start, end) => {
    for (let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state).resolveInner(end, -1); node; node = node.parent) {
        if (node.from < start)
            break;
        let heading = node.type.prop(headingProp);
        if (heading == null)
            continue;
        let upto = findSectionEnd(node, heading);
        if (upto > end)
            return { from: end, to: upto };
    }
    return null;
});
function mkLang(parser) {
    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.Language(data, parser, [headerIndent], "markdown");
}
/**
Language support for strict CommonMark.
*/
const commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);
const extended = /*@__PURE__*/commonmark.configure([_lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.GFM, _lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.Subscript, _lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.Superscript, _lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.Emoji, {
        props: [
            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add({
                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })
            })
        ]
    }]);
/**
Language support for [GFM](https://github.github.com/gfm/) plus
subscript, superscript, and emoji syntax.
*/
const markdownLanguage = /*@__PURE__*/mkLang(extended);
function getCodeParser(languages, defaultLanguage) {
    return (info) => {
        if (info && languages) {
            let found = null;
            // Strip anything after whitespace
            info = /\S*/.exec(info)[0];
            if (typeof languages == "function")
                found = languages(info);
            else
                found = _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageDescription.matchLanguageName(languages, info, true);
            if (found instanceof _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageDescription)
                return found.support ? found.support.language.parser : _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.ParseContext.getSkippingParser(found.load());
            else if (found)
                return found.parser;
        }
        return defaultLanguage ? defaultLanguage.parser : null;
    };
}

class Context {
    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {
        this.node = node;
        this.from = from;
        this.to = to;
        this.spaceBefore = spaceBefore;
        this.spaceAfter = spaceAfter;
        this.type = type;
        this.item = item;
    }
    blank(maxWidth, trailing = true) {
        let result = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
        if (maxWidth != null) {
            while (result.length < maxWidth)
                result += " ";
            return result;
        }
        else {
            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
                result += " ";
            return result + (trailing ? this.spaceAfter : "");
        }
    }
    marker(doc, add) {
        let number = this.node.name == "OrderedList" ? String((+itemNumber(this.item, doc)[2] + add)) : "";
        return this.spaceBefore + number + this.type + this.spaceAfter;
    }
}
function getContext(node, doc) {
    let nodes = [];
    for (let cur = node; cur; cur = cur.parent) {
        if (cur.name == "ListItem" || cur.name == "Blockquote" || cur.name == "FencedCode")
            nodes.push(cur);
    }
    let context = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
        let node = nodes[i], match;
        let line = doc.lineAt(node.from), startPos = node.from - line.from;
        if (node.name == "FencedCode") {
            context.push(new Context(node, startPos, startPos, "", "", "", null));
        }
        else if (node.name == "Blockquote" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {
            context.push(new Context(node, startPos, startPos + match[0].length, "", match[1], ">", null));
        }
        else if (node.name == "ListItem" && node.parent.name == "OrderedList" &&
            (match = /^( *)\d+([.)])( *)/.exec(line.text.slice(startPos)))) {
            let after = match[3], len = match[0].length;
            if (after.length >= 4) {
                after = after.slice(0, after.length - 4);
                len -= 4;
            }
            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));
        }
        else if (node.name == "ListItem" && node.parent.name == "BulletList" &&
            (match = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(line.text.slice(startPos)))) {
            let after = match[4], len = match[0].length;
            if (after.length > 4) {
                after = after.slice(0, after.length - 4);
                len -= 4;
            }
            let type = match[2];
            if (match[3])
                type += match[3].replace(/[xX]/, ' ');
            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));
        }
    }
    return context;
}
function itemNumber(item, doc) {
    return /^(\s*)(\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));
}
function renumberList(after, doc, changes, offset = 0) {
    for (let prev = -1, node = after;;) {
        if (node.name == "ListItem") {
            let m = itemNumber(node, doc);
            let number = +m[2];
            if (prev >= 0) {
                if (number != prev + 1)
                    return;
                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });
            }
            prev = number;
        }
        let next = node.nextSibling;
        if (!next)
            break;
        node = next;
    }
}
function normalizeIndent(content, state) {
    let blank = /^[ \t]*/.exec(content)[0].length;
    if (!blank || state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentUnit) != "\t")
        return content;
    let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(content, 4, blank);
    let space = "";
    for (let i = col; i > 0;) {
        if (i >= 4) {
            space += "\t";
            i -= 4;
        }
        else {
            space += " ";
            i--;
        }
    }
    return space + content.slice(blank);
}
/**
This command, when invoked in Markdown context with cursor
selection(s), will create a new line with the markup for
blockquotes and lists that were active on the old line. If the
cursor was directly after the end of the markup for the old line,
trailing whitespace and list markers are removed from that line.

The command does nothing in non-Markdown context, so it should
not be used as the only binding for Enter (even in a Markdown
document, HTML and code regions might use a different language).
*/
const insertNewlineContinueMarkup = ({ state, dispatch }) => {
    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state), { doc } = state;
    let dont = null, changes = state.changeByRange(range => {
        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, 0))
            return dont = { range };
        let pos = range.from, line = doc.lineAt(pos);
        let context = getContext(tree.resolveInner(pos, -1), doc);
        while (context.length && context[context.length - 1].from > pos - line.from)
            context.pop();
        if (!context.length)
            return dont = { range };
        let inner = context[context.length - 1];
        if (inner.to - inner.spaceAfter.length > pos - line.from)
            return dont = { range };
        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\S/.test(line.text.slice(inner.to));
        // Empty line in list
        if (inner.item && emptyLine) {
            let first = inner.node.firstChild, second = inner.node.getChild("ListItem", "ListItem");
            // Not second item or blank line before: delete a level of markup
            if (first.to >= pos || second && second.to < pos ||
                line.from > 0 && !/[^\s>]/.test(doc.lineAt(line.from - 1).text)) {
                let next = context.length > 1 ? context[context.length - 2] : null;
                let delTo, insert = "";
                if (next && next.item) { // Re-add marker for the list at the next level
                    delTo = line.from + next.from;
                    insert = next.marker(doc, 1);
                }
                else {
                    delTo = line.from + (next ? next.to : 0);
                }
                let changes = [{ from: delTo, to: pos, insert }];
                if (inner.node.name == "OrderedList")
                    renumberList(inner.item, doc, changes, -2);
                if (next && next.node.name == "OrderedList")
                    renumberList(next.item, doc, changes);
                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(delTo + insert.length), changes };
            }
            else { // Move second item down, making tight two-item list non-tight
                let insert = blankLine(context, state, line);
                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos + insert.length + 1),
                    changes: { from: line.from, insert: insert + state.lineBreak } };
            }
        }
        if (inner.node.name == "Blockquote" && emptyLine && line.from) {
            let prevLine = doc.lineAt(line.from - 1), quoted = />\s*$/.exec(prevLine.text);
            // Two aligned empty quoted lines in a row
            if (quoted && quoted.index == inner.from) {
                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },
                    { from: line.from + inner.from, to: line.to }]);
                return { range: range.map(changes), changes };
            }
        }
        let changes = [];
        if (inner.node.name == "OrderedList")
            renumberList(inner.item, doc, changes);
        let continued = inner.item && inner.item.from < line.from;
        let insert = "";
        // If not dedented
        if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
            for (let i = 0, e = context.length - 1; i <= e; i++) {
                insert += i == e && !continued ? context[i].marker(doc, 1)
                    : context[i].blank(i < e ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(line.text, 4, context[i + 1].from) - insert.length : null);
            }
        }
        let from = pos;
        while (from > line.from && /\s/.test(line.text.charAt(from - line.from - 1)))
            from--;
        insert = normalizeIndent(insert, state);
        if (nonTightList(inner.node, state.doc))
            insert = blankLine(context, state, line) + state.lineBreak + insert;
        changes.push({ from, to: pos, insert: state.lineBreak + insert });
        return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(from + insert.length + 1), changes };
    });
    if (dont)
        return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
};
function isMark(node) {
    return node.name == "QuoteMark" || node.name == "ListMark";
}
function nonTightList(node, doc) {
    if (node.name != "OrderedList" && node.name != "BulletList")
        return false;
    let first = node.firstChild, second = node.getChild("ListItem", "ListItem");
    if (!second)
        return false;
    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);
    let empty = /^[\s>]*$/.test(line1.text);
    return line1.number + (empty ? 0 : 1) < line2.number;
}
function blankLine(context, state, line) {
    let insert = "";
    for (let i = 0, e = context.length - 2; i <= e; i++) {
        insert += context[i].blank(i < e ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(line.text, 4, context[i + 1].from) - insert.length : null, i < e);
    }
    return normalizeIndent(insert, state);
}
function contextNodeForDelete(tree, pos) {
    let node = tree.resolveInner(pos, -1), scan = pos;
    if (isMark(node)) {
        scan = node.from;
        node = node.parent;
    }
    for (let prev; prev = node.childBefore(scan);) {
        if (isMark(prev)) {
            scan = prev.from;
        }
        else if (prev.name == "OrderedList" || prev.name == "BulletList") {
            node = prev.lastChild;
            scan = node.to;
        }
        else {
            break;
        }
    }
    return node;
}
/**
This command will, when invoked in a Markdown context with the
cursor directly after list or blockquote markup, delete one level
of markup. When the markup is for a list, it will be replaced by
spaces on the first invocation (a further invocation will delete
the spaces), to make it easy to continue a list.

When not after Markdown block markup, this command will return
false, so it is intended to be bound alongside other deletion
commands, with a higher precedence than the more generic commands.
*/
const deleteMarkupBackward = ({ state, dispatch }) => {
    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state);
    let dont = null, changes = state.changeByRange(range => {
        let pos = range.from, { doc } = state;
        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {
            let line = doc.lineAt(pos);
            let context = getContext(contextNodeForDelete(tree, pos), doc);
            if (context.length) {
                let inner = context[context.length - 1];
                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
                // Delete extra trailing space after markup
                if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
                    return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(line.from + spaceEnd),
                        changes: { from: line.from + spaceEnd, to: pos } };
                if (pos - line.from == spaceEnd &&
                    // Only apply this if we're on the line that has the
                    // construct's syntax, or there's only indentation in the
                    // target range
                    (!inner.item || line.from <= inner.item.from || !/\S/.test(line.text.slice(0, inner.to)))) {
                    let start = line.from + inner.from;
                    // Replace a list item marker with blank space
                    if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to))) {
                        let insert = inner.blank((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(line.text, 4, inner.to) - (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(line.text, 4, inner.from));
                        if (start == line.from)
                            insert = normalizeIndent(insert, state);
                        return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(start + insert.length),
                            changes: { from: start, to: line.from + inner.to, insert } };
                    }
                    // Delete one level of indentation
                    if (start < pos)
                        return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(start), changes: { from: start, to: pos } };
                }
            }
        }
        return dont = { range };
    });
    if (dont)
        return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete" }));
    return true;
};

/**
A small keymap with Markdown-specific bindings. Binds Enter to
[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)
and Backspace to
[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).
*/
const markdownKeymap = [
    { key: "Enter", run: insertNewlineContinueMarkup },
    { key: "Backspace", run: deleteMarkupBackward }
];
const htmlNoMatch = /*@__PURE__*/(0,_codemirror_lang_html__WEBPACK_IMPORTED_MODULE_5__.html)({ matchClosingTags: false });
/**
Markdown language support.
*/
function markdown(config = {}) {
    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;
    if (!(parser instanceof _lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.MarkdownParser))
        throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
    let extensions = config.extensions ? [config.extensions] : [];
    let support = [htmlTagLanguage.support], defaultCode;
    if (defaultCodeLanguage instanceof _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport) {
        support.push(defaultCodeLanguage.support);
        defaultCode = defaultCodeLanguage.language;
    }
    else if (defaultCodeLanguage) {
        defaultCode = defaultCodeLanguage;
    }
    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;
    extensions.push((0,_lezer_markdown__WEBPACK_IMPORTED_MODULE_3__.parseCode)({ codeParser, htmlParser: htmlTagLanguage.language.parser }));
    if (addKeymap)
        support.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Prec.high(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.keymap.of(markdownKeymap)));
    let lang = mkLang(parser.configure(extensions));
    if (completeHTMLTags)
        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));
    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport(lang, support);
}
function htmlTagCompletion(context) {
    let { state, pos } = context, m = /<[:\-\.\w\u00b7-\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));
    if (!m)
        return null;
    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state).resolveInner(pos, -1);
    while (tree && !tree.type.isTop) {
        if (tree.name == "CodeBlock" || tree.name == "FencedCode" || tree.name == "ProcessingInstructionBlock" ||
            tree.name == "CommentBlock" || tree.name == "Link" || tree.name == "Image")
            return null;
        tree = tree.parent;
    }
    return {
        from: pos - m[0].length, to: pos,
        options: htmlTagCompletions(),
        validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
    };
}
let _tagCompletions = null;
function htmlTagCompletions() {
    if (_tagCompletions)
        return _tagCompletions;
    let result = (0,_codemirror_lang_html__WEBPACK_IMPORTED_MODULE_5__.htmlCompletionSource)(new _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_6__.CompletionContext(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({ extensions: htmlNoMatch }), 0, true));
    return _tagCompletions = result ? result.options : [];
}




/***/ }),

/***/ "./node_modules/@lezer/markdown/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@lezer/markdown/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Autolink: () => (/* binding */ Autolink),
/* harmony export */   BlockContext: () => (/* binding */ BlockContext),
/* harmony export */   Element: () => (/* binding */ Element),
/* harmony export */   Emoji: () => (/* binding */ Emoji),
/* harmony export */   GFM: () => (/* binding */ GFM),
/* harmony export */   InlineContext: () => (/* binding */ InlineContext),
/* harmony export */   LeafBlock: () => (/* binding */ LeafBlock),
/* harmony export */   Line: () => (/* binding */ Line),
/* harmony export */   MarkdownParser: () => (/* binding */ MarkdownParser),
/* harmony export */   Strikethrough: () => (/* binding */ Strikethrough),
/* harmony export */   Subscript: () => (/* binding */ Subscript),
/* harmony export */   Superscript: () => (/* binding */ Superscript),
/* harmony export */   Table: () => (/* binding */ Table),
/* harmony export */   TaskList: () => (/* binding */ TaskList),
/* harmony export */   parseCode: () => (/* binding */ parseCode),
/* harmony export */   parser: () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ "webpack/sharing/consume/default/@lezer/common/@lezer/common");
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lezer_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ "webpack/sharing/consume/default/@lezer/highlight/@lezer/highlight");
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__);



class CompositeBlock {
    static create(type, value, from, parentHash, end) {
        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;
        return new CompositeBlock(type, value, from, hash, end, [], []);
    }
    constructor(type, 
    // Used for indentation in list items, markup character in lists
    value, from, hash, end, children, positions) {
        this.type = type;
        this.value = value;
        this.from = from;
        this.hash = hash;
        this.end = end;
        this.children = children;
        this.positions = positions;
        this.hashProp = [[_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash, hash]];
    }
    addChild(child, pos) {
        if (child.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) != this.hash)
            child = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(child.type, child.children, child.positions, child.length, this.hashProp);
        this.children.push(child);
        this.positions.push(pos);
    }
    toTree(nodeSet, end = this.end) {
        let last = this.children.length - 1;
        if (last >= 0)
            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);
        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
            makeTree: (children, positions, length) => new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, children, positions, length, this.hashProp)
        });
    }
}
var Type;
(function (Type) {
    Type[Type["Document"] = 1] = "Document";
    Type[Type["CodeBlock"] = 2] = "CodeBlock";
    Type[Type["FencedCode"] = 3] = "FencedCode";
    Type[Type["Blockquote"] = 4] = "Blockquote";
    Type[Type["HorizontalRule"] = 5] = "HorizontalRule";
    Type[Type["BulletList"] = 6] = "BulletList";
    Type[Type["OrderedList"] = 7] = "OrderedList";
    Type[Type["ListItem"] = 8] = "ListItem";
    Type[Type["ATXHeading1"] = 9] = "ATXHeading1";
    Type[Type["ATXHeading2"] = 10] = "ATXHeading2";
    Type[Type["ATXHeading3"] = 11] = "ATXHeading3";
    Type[Type["ATXHeading4"] = 12] = "ATXHeading4";
    Type[Type["ATXHeading5"] = 13] = "ATXHeading5";
    Type[Type["ATXHeading6"] = 14] = "ATXHeading6";
    Type[Type["SetextHeading1"] = 15] = "SetextHeading1";
    Type[Type["SetextHeading2"] = 16] = "SetextHeading2";
    Type[Type["HTMLBlock"] = 17] = "HTMLBlock";
    Type[Type["LinkReference"] = 18] = "LinkReference";
    Type[Type["Paragraph"] = 19] = "Paragraph";
    Type[Type["CommentBlock"] = 20] = "CommentBlock";
    Type[Type["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
    // Inline
    Type[Type["Escape"] = 22] = "Escape";
    Type[Type["Entity"] = 23] = "Entity";
    Type[Type["HardBreak"] = 24] = "HardBreak";
    Type[Type["Emphasis"] = 25] = "Emphasis";
    Type[Type["StrongEmphasis"] = 26] = "StrongEmphasis";
    Type[Type["Link"] = 27] = "Link";
    Type[Type["Image"] = 28] = "Image";
    Type[Type["InlineCode"] = 29] = "InlineCode";
    Type[Type["HTMLTag"] = 30] = "HTMLTag";
    Type[Type["Comment"] = 31] = "Comment";
    Type[Type["ProcessingInstruction"] = 32] = "ProcessingInstruction";
    Type[Type["Autolink"] = 33] = "Autolink";
    // Smaller tokens
    Type[Type["HeaderMark"] = 34] = "HeaderMark";
    Type[Type["QuoteMark"] = 35] = "QuoteMark";
    Type[Type["ListMark"] = 36] = "ListMark";
    Type[Type["LinkMark"] = 37] = "LinkMark";
    Type[Type["EmphasisMark"] = 38] = "EmphasisMark";
    Type[Type["CodeMark"] = 39] = "CodeMark";
    Type[Type["CodeText"] = 40] = "CodeText";
    Type[Type["CodeInfo"] = 41] = "CodeInfo";
    Type[Type["LinkTitle"] = 42] = "LinkTitle";
    Type[Type["LinkLabel"] = 43] = "LinkLabel";
    Type[Type["URL"] = 44] = "URL";
})(Type || (Type = {}));
/// Data structure used to accumulate a block's content during [leaf
/// block parsing](#BlockParser.leaf).
class LeafBlock {
    /// @internal
    constructor(
    /// The start position of the block.
    start, 
    /// The block's text content.
    content) {
        this.start = start;
        this.content = content;
        /// @internal
        this.marks = [];
        /// The block parsers active for this block.
        this.parsers = [];
    }
}
/// Data structure used during block-level per-line parsing.
class Line {
    constructor() {
        /// The line's full text.
        this.text = "";
        /// The base indent provided by the composite contexts (that have
        /// been handled so far).
        this.baseIndent = 0;
        /// The string position corresponding to the base indent.
        this.basePos = 0;
        /// The number of contexts handled @internal
        this.depth = 0;
        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal
        this.markers = [];
        /// The position of the next non-whitespace character beyond any
        /// list, blockquote, or other composite block markers.
        this.pos = 0;
        /// The column of the next non-whitespace character.
        this.indent = 0;
        /// The character code of the character after `pos`.
        this.next = -1;
    }
    /// @internal
    forward() {
        if (this.basePos > this.pos)
            this.forwardInner();
    }
    /// @internal
    forwardInner() {
        let newPos = this.skipSpace(this.basePos);
        this.indent = this.countIndent(newPos, this.pos, this.indent);
        this.pos = newPos;
        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
    }
    /// Skip whitespace after the given position, return the position of
    /// the next non-space character or the end of the line if there's
    /// only space after `from`.
    skipSpace(from) { return skipSpace(this.text, from); }
    /// @internal
    reset(text) {
        this.text = text;
        this.baseIndent = this.basePos = this.pos = this.indent = 0;
        this.forwardInner();
        this.depth = 1;
        while (this.markers.length)
            this.markers.pop();
    }
    /// Move the line's base position forward to the given position.
    /// This should only be called by composite [block
    /// parsers](#BlockParser.parse) or [markup skipping
    /// functions](#NodeSpec.composite).
    moveBase(to) {
        this.basePos = to;
        this.baseIndent = this.countIndent(to, this.pos, this.indent);
    }
    /// Move the line's base position forward to the given _column_.
    moveBaseColumn(indent) {
        this.baseIndent = indent;
        this.basePos = this.findColumn(indent);
    }
    /// Store a composite-block-level marker. Should be called from
    /// [markup skipping functions](#NodeSpec.composite) when they
    /// consume any non-whitespace characters.
    addMarker(elt) {
        this.markers.push(elt);
    }
    /// Find the column position at `to`, optionally starting at a given
    /// position and column.
    countIndent(to, from = 0, indent = 0) {
        for (let i = from; i < to; i++)
            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
        return indent;
    }
    /// Find the position corresponding to the given column.
    findColumn(goal) {
        let i = 0;
        for (let indent = 0; i < this.text.length && indent < goal; i++)
            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
        return i;
    }
    /// @internal
    scrub() {
        if (!this.baseIndent)
            return this.text;
        let result = "";
        for (let i = 0; i < this.basePos; i++)
            result += " ";
        return result + this.text.slice(this.basePos);
    }
}
function skipForList(bl, cx, line) {
    if (line.pos == line.text.length ||
        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))
        return true;
    if (line.indent >= line.baseIndent + 4)
        return false;
    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
    return size > 0 &&
        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&
        line.text.charCodeAt(line.pos + size - 1) == bl.value;
}
const DefaultSkipMarkup = {
    [Type.Blockquote](bl, cx, line) {
        if (line.next != 62 /* '>' */)
            return false;
        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
        bl.end = cx.lineStart + line.text.length;
        return true;
    },
    [Type.ListItem](bl, _cx, line) {
        if (line.indent < line.baseIndent + bl.value && line.next > -1)
            return false;
        line.moveBaseColumn(line.baseIndent + bl.value);
        return true;
    },
    [Type.OrderedList]: skipForList,
    [Type.BulletList]: skipForList,
    [Type.Document]() { return true; }
};
function space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }
function skipSpace(line, i = 0) {
    while (i < line.length && space(line.charCodeAt(i)))
        i++;
    return i;
}
function skipSpaceBack(line, i, to) {
    while (i > to && space(line.charCodeAt(i - 1)))
        i--;
    return i;
}
function isFencedCode(line) {
    if (line.next != 96 && line.next != 126 /* '`~' */)
        return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
        pos++;
    if (pos < line.pos + 3)
        return -1;
    if (line.next == 96)
        for (let i = pos; i < line.text.length; i++)
            if (line.text.charCodeAt(i) == 96)
                return -1;
    return pos;
}
function isBlockquote(line) {
    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line, cx, breaking) {
    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)
        return -1;
    let count = 1;
    for (let pos = line.pos + 1; pos < line.text.length; pos++) {
        let ch = line.text.charCodeAt(pos);
        if (ch == line.next)
            count++;
        else if (!space(ch))
            return -1;
    }
    // Setext headers take precedence
    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)
        return -1;
    return count < 3 ? -1 : 1;
}
function inList(cx, type) {
    for (let i = cx.stack.length - 1; i >= 0; i--)
        if (cx.stack[i].type == type)
            return true;
    return false;
}
function isBulletList(line, cx, breaking) {
    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&
        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&
        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
}
function isOrderedList(line, cx, breaking) {
    let pos = line.pos, next = line.next;
    for (;;) {
        if (next >= 48 && next <= 57 /* '0-9' */)
            pos++;
        else
            break;
        if (pos == line.text.length)
            return -1;
        next = line.text.charCodeAt(pos);
    }
    if (pos == line.pos || pos > line.pos + 9 ||
        (next != 46 && next != 41 /* '.)' */) ||
        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||
        breaking && !inList(cx, Type.OrderedList) &&
            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))
        return -1;
    return pos + 1 - line.pos;
}
function isAtxHeading(line) {
    if (line.next != 35 /* '#' */)
        return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
        pos++;
    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
        return -1;
    let size = pos - line.pos;
    return size > 6 ? -1 : size;
}
function isSetextUnderline(line) {
    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)
        return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
        pos++;
    let end = pos;
    while (pos < line.text.length && space(line.text.charCodeAt(pos)))
        pos++;
    return pos == line.text.length ? end : -1;
}
const EmptyLine = /^[ \t]*$/, CommentEnd = /-->/, ProcessingEnd = /\?>/;
const HTMLBlockStyle = [
    [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
    [/^\s*<!--/, CommentEnd],
    [/^\s*<\?/, ProcessingEnd],
    [/^\s*<![A-Z]/, />/],
    [/^\s*<!\[CDATA\[/, /\]\]>/],
    [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
    [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
];
function isHTMLBlock(line, _cx, breaking) {
    if (line.next != 60 /* '<' */)
        return -1;
    let rest = line.text.slice(line.pos);
    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
        if (HTMLBlockStyle[i][0].test(rest))
            return i;
    return -1;
}
function getListIndent(line, pos) {
    let indentAfter = line.countIndent(pos, line.pos, line.indent);
    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks, from, to) {
    let last = marks.length - 1;
    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)
        marks[last].to = to;
    else
        marks.push(elt(Type.CodeText, from, to));
}
// Rules for parsing blocks. A return value of false means the rule
// doesn't apply here, true means it does. When true is returned and
// `p.line` has been updated, the rule is assumed to have consumed a
// leaf block. Otherwise, it is assumed to have opened a context.
const DefaultBlockParsers = {
    LinkReference: undefined,
    IndentedCode(cx, line) {
        let base = line.baseIndent + 4;
        if (line.indent < base)
            return false;
        let start = line.findColumn(base);
        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;
        let marks = [], pendingMarks = [];
        addCodeText(marks, from, to);
        while (cx.nextLine() && line.depth >= cx.stack.length) {
            if (line.pos == line.text.length) { // Empty
                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
                for (let m of line.markers)
                    pendingMarks.push(m);
            }
            else if (line.indent < base) {
                break;
            }
            else {
                if (pendingMarks.length) {
                    for (let m of pendingMarks) {
                        if (m.type == Type.CodeText)
                            addCodeText(marks, m.from, m.to);
                        else
                            marks.push(m);
                    }
                    pendingMarks = [];
                }
                addCodeText(marks, cx.lineStart - 1, cx.lineStart);
                for (let m of line.markers)
                    marks.push(m);
                to = cx.lineStart + line.text.length;
                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
                if (codeStart < to)
                    addCodeText(marks, codeStart, to);
            }
        }
        if (pendingMarks.length) {
            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);
            if (pendingMarks.length)
                line.markers = pendingMarks.concat(line.markers);
        }
        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);
        return true;
    },
    FencedCode(cx, line) {
        let fenceEnd = isFencedCode(line);
        if (fenceEnd < 0)
            return false;
        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
        let marks = [elt(Type.CodeMark, from, from + len)];
        if (infoFrom < infoTo)
            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
            let i = line.pos;
            if (line.indent - line.baseIndent < 4)
                while (i < line.text.length && line.text.charCodeAt(i) == ch)
                    i++;
            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
                for (let m of line.markers)
                    marks.push(m);
                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));
                cx.nextLine();
                break;
            }
            else {
                if (!first)
                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);
                for (let m of line.markers)
                    marks.push(m);
                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
                if (textStart < textEnd)
                    addCodeText(marks, textStart, textEnd);
            }
        }
        cx.addNode(cx.buffer.writeElements(marks, -from)
            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);
        return true;
    },
    Blockquote(cx, line) {
        let size = isBlockquote(line);
        if (size < 0)
            return false;
        cx.startContext(Type.Blockquote, line.pos);
        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
        line.moveBase(line.pos + size);
        return null;
    },
    HorizontalRule(cx, line) {
        if (isHorizontalRule(line, cx, false) < 0)
            return false;
        let from = cx.lineStart + line.pos;
        cx.nextLine();
        cx.addNode(Type.HorizontalRule, from);
        return true;
    },
    BulletList(cx, line) {
        let size = isBulletList(line, cx, false);
        if (size < 0)
            return false;
        if (cx.block.type != Type.BulletList)
            cx.startContext(Type.BulletList, line.basePos, line.next);
        let newBase = getListIndent(line, line.pos + 1);
        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
        line.moveBaseColumn(newBase);
        return null;
    },
    OrderedList(cx, line) {
        let size = isOrderedList(line, cx, false);
        if (size < 0)
            return false;
        if (cx.block.type != Type.OrderedList)
            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
        let newBase = getListIndent(line, line.pos + size);
        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
        line.moveBaseColumn(newBase);
        return null;
    },
    ATXHeading(cx, line) {
        let size = isAtxHeading(line);
        if (size < 0)
            return false;
        let off = line.pos, from = cx.lineStart + off;
        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
        while (after > off && line.text.charCodeAt(after - 1) == line.next)
            after--;
        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))
            after = line.text.length;
        let buf = cx.buffer
            .write(Type.HeaderMark, 0, size)
            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
        if (after < line.text.length)
            buf.write(Type.HeaderMark, after - off, endOfSpace - off);
        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
        cx.nextLine();
        cx.addNode(node, from);
        return true;
    },
    HTMLBlock(cx, line) {
        let type = isHTMLBlock(line, cx, false);
        if (type < 0)
            return false;
        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
        let marks = [], trailing = end != EmptyLine;
        while (!end.test(line.text) && cx.nextLine()) {
            if (line.depth < cx.stack.length) {
                trailing = false;
                break;
            }
            for (let m of line.markers)
                marks.push(m);
        }
        if (trailing)
            cx.nextLine();
        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
        let to = cx.prevLineEnd();
        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);
        return true;
    },
    SetextHeading: undefined // Specifies relative precedence for block-continue function
};
// This implements a state machine that incrementally parses link references. At each
// next line, it looks ahead to see if the line continues the reference or not. If it
// doesn't and a valid link is available ending before that line, it finishes that.
// Similarly, on `finish` (when the leaf is terminated by external circumstances), it
// creates a link reference if there's a valid reference up to the current point.
class LinkReferenceParser {
    constructor(leaf) {
        this.stage = 0 /* RefStage.Start */;
        this.elts = [];
        this.pos = 0;
        this.start = leaf.start;
        this.advance(leaf.content);
    }
    nextLine(cx, line, leaf) {
        if (this.stage == -1 /* RefStage.Failed */)
            return false;
        let content = leaf.content + "\n" + line.scrub();
        let finish = this.advance(content);
        if (finish > -1 && finish < content.length)
            return this.complete(cx, leaf, finish);
        return false;
    }
    finish(cx, leaf) {
        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)
            return this.complete(cx, leaf, leaf.content.length);
        return false;
    }
    complete(cx, leaf, len) {
        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
        return true;
    }
    nextStage(elt) {
        if (elt) {
            this.pos = elt.to - this.start;
            this.elts.push(elt);
            this.stage++;
            return true;
        }
        if (elt === false)
            this.stage = -1 /* RefStage.Failed */;
        return false;
    }
    advance(content) {
        for (;;) {
            if (this.stage == -1 /* RefStage.Failed */) {
                return -1;
            }
            else if (this.stage == 0 /* RefStage.Start */) {
                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))
                    return -1;
                if (content.charCodeAt(this.pos) != 58 /* ':' */)
                    return this.stage = -1 /* RefStage.Failed */;
                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
                this.pos++;
            }
            else if (this.stage == 1 /* RefStage.Label */) {
                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))
                    return -1;
            }
            else if (this.stage == 2 /* RefStage.Link */) {
                let skip = skipSpace(content, this.pos), end = 0;
                if (skip > this.pos) {
                    let title = parseLinkTitle(content, skip, this.start);
                    if (title) {
                        let titleEnd = lineEnd(content, title.to - this.start);
                        if (titleEnd > 0) {
                            this.nextStage(title);
                            end = titleEnd;
                        }
                    }
                }
                if (!end)
                    end = lineEnd(content, this.pos);
                return end > 0 && end < content.length ? end : -1;
            }
            else { // RefStage.Title
                return lineEnd(content, this.pos);
            }
        }
    }
}
function lineEnd(text, pos) {
    for (; pos < text.length; pos++) {
        let next = text.charCodeAt(pos);
        if (next == 10)
            break;
        if (!space(next))
            return -1;
    }
    return pos;
}
class SetextHeadingParser {
    nextLine(cx, line, leaf) {
        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
        let next = line.next;
        if (underline < 0)
            return false;
        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);
        cx.nextLine();
        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
            ...cx.parser.parseInline(leaf.content, leaf.start),
            underlineMark
        ]));
        return true;
    }
    finish() {
        return false;
    }
}
const DefaultLeafBlocks = {
    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },
    SetextHeading() { return new SetextHeadingParser; }
};
const DefaultEndLeaf = [
    (_, line) => isAtxHeading(line) >= 0,
    (_, line) => isFencedCode(line) >= 0,
    (_, line) => isBlockquote(line) >= 0,
    (p, line) => isBulletList(line, p, true) >= 0,
    (p, line) => isOrderedList(line, p, true) >= 0,
    (p, line) => isHorizontalRule(line, p, true) >= 0,
    (p, line) => isHTMLBlock(line, p, true) >= 0
];
const scanLineResult = { text: "", end: 0 };
/// Block-level parsing functions get access to this context object.
class BlockContext {
    /// @internal
    constructor(
    /// The parser configuration used.
    parser, 
    /// @internal
    input, fragments, 
    /// @internal
    ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.line = new Line();
        this.atEnd = false;
        /// For reused nodes on gaps, we can't directly put the original
        /// node into the tree, since that may be bitter than its parent.
        /// When this happens, we create a dummy tree that is replaced by
        /// the proper node in `injectGaps` @internal
        this.reusePlaceholders = new Map;
        this.stoppedAt = null;
        /// The range index that absoluteLineStart points into @internal
        this.rangeI = 0;
        this.to = ranges[ranges.length - 1].to;
        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
        this.stack = [this.block];
        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;
        this.readLine();
    }
    get parsedPos() {
        return this.absoluteLineStart;
    }
    advance() {
        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
            return this.finish();
        let { line } = this;
        for (;;) {
            for (let markI = 0;;) {
                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {
                    let mark = line.markers[markI++];
                    this.addNode(mark.type, mark.from, mark.to);
                }
                if (!next)
                    break;
                this.finishContext();
            }
            if (line.pos < line.text.length)
                break;
            // Empty line
            if (!this.nextLine())
                return this.finish();
        }
        if (this.fragments && this.reuseFragment(line.basePos))
            return null;
        start: for (;;) {
            for (let type of this.parser.blockParsers)
                if (type) {
                    let result = type(this, line);
                    if (result != false) {
                        if (result == true)
                            return null;
                        line.forward();
                        continue start;
                    }
                }
            break;
        }
        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
        for (let parse of this.parser.leafBlockParsers)
            if (parse) {
                let parser = parse(this, leaf);
                if (parser)
                    leaf.parsers.push(parser);
            }
        lines: while (this.nextLine()) {
            if (line.pos == line.text.length)
                break;
            if (line.indent < line.baseIndent + 4) {
                for (let stop of this.parser.endLeafBlock)
                    if (stop(this, line, leaf))
                        break lines;
            }
            for (let parser of leaf.parsers)
                if (parser.nextLine(this, line, leaf))
                    return null;
            leaf.content += "\n" + line.scrub();
            for (let m of line.markers)
                leaf.marks.push(m);
        }
        this.finishLeaf(leaf);
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    reuseFragment(start) {
        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||
            !this.fragments.matches(this.block.hash))
            return false;
        let taken = this.fragments.takeNodes(this);
        if (!taken)
            return false;
        this.absoluteLineStart += taken;
        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);
        this.moveRangeI();
        if (this.absoluteLineStart < this.to) {
            this.lineStart++;
            this.absoluteLineStart++;
            this.readLine();
        }
        else {
            this.atEnd = true;
            this.readLine();
        }
        return true;
    }
    /// The number of parent blocks surrounding the current block.
    get depth() {
        return this.stack.length;
    }
    /// Get the type of the parent block at the given depth. When no
    /// depth is passed, return the type of the innermost parent.
    parentType(depth = this.depth - 1) {
        return this.parser.nodeSet.types[this.stack[depth].type];
    }
    /// Move to the next input line. This should only be called by
    /// (non-composite) [block parsers](#BlockParser.parse) that consume
    /// the line directly, or leaf block parser
    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they
    /// consume the current line (and return true).
    nextLine() {
        this.lineStart += this.line.text.length;
        if (this.absoluteLineEnd >= this.to) {
            this.absoluteLineStart = this.absoluteLineEnd;
            this.atEnd = true;
            this.readLine();
            return false;
        }
        else {
            this.lineStart++;
            this.absoluteLineStart = this.absoluteLineEnd + 1;
            this.moveRangeI();
            this.readLine();
            return true;
        }
    }
    moveRangeI() {
        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
            this.rangeI++;
            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
        }
    }
    /// @internal
    scanLine(start) {
        let r = scanLineResult;
        r.end = start;
        if (start >= this.to) {
            r.text = "";
        }
        else {
            r.text = this.lineChunkAt(start);
            r.end += r.text.length;
            if (this.ranges.length > 1) {
                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
                while (this.ranges[rangeI].to < r.end) {
                    rangeI++;
                    let nextFrom = this.ranges[rangeI].from;
                    let after = this.lineChunkAt(nextFrom);
                    r.end = nextFrom + after.length;
                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
                    textOffset = r.end - r.text.length;
                }
            }
        }
        return r;
    }
    /// @internal
    readLine() {
        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);
        this.absoluteLineEnd = end;
        line.reset(text);
        for (; line.depth < this.stack.length; line.depth++) {
            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
            if (!handler)
                throw new Error("Unhandled block context " + Type[cx.type]);
            if (!handler(cx, this, line))
                break;
            line.forward();
        }
    }
    lineChunkAt(pos) {
        let next = this.input.chunk(pos), text;
        if (!this.input.lineChunks) {
            let eol = next.indexOf("\n");
            text = eol < 0 ? next : next.slice(0, eol);
        }
        else {
            text = next == "\n" ? "" : next;
        }
        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
    }
    /// The end position of the previous line.
    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }
    /// @internal
    startContext(type, start, value = 0) {
        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
        this.stack.push(this.block);
    }
    /// Start a composite block. Should only be called from [block
    /// parser functions](#BlockParser.parse) that return null.
    startComposite(type, start, value = 0) {
        this.startContext(this.parser.getNodeType(type), start, value);
    }
    /// @internal
    addNode(block, from, to) {
        if (typeof block == "number")
            block = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
        this.block.addChild(block, from - this.block.from);
    }
    /// Add a block element. Can be called by [block
    /// parsers](#BlockParser.parse).
    addElement(elt) {
        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);
    }
    /// Add a block element from a [leaf parser](#LeafBlockParser). This
    /// makes sure any extra composite block markup (such as blockquote
    /// markers) inside the block are also added to the syntax tree.
    addLeafElement(leaf, elt) {
        this.addNode(this.buffer
            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)
            .finish(elt.type, elt.to - elt.from), elt.from);
    }
    /// @internal
    finishContext() {
        let cx = this.stack.pop();
        let top = this.stack[this.stack.length - 1];
        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);
        this.block = top;
    }
    finish() {
        while (this.stack.length > 1)
            this.finishContext();
        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
    }
    addGaps(tree) {
        return this.ranges.length > 1 ?
            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;
    }
    /// @internal
    finishLeaf(leaf) {
        for (let parser of leaf.parsers)
            if (parser.finish(this, leaf))
                return;
        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
        this.addNode(this.buffer
            .writeElements(inline, -leaf.start)
            .finish(Type.Paragraph, leaf.content.length), leaf.start);
    }
    elt(type, from, to, children) {
        if (typeof type == "string")
            return elt(this.parser.getNodeType(type), from, to, children);
        return new TreeElement(type, from);
    }
    /// @internal
    get buffer() { return new Buffer(this.parser.nodeSet); }
}
function injectGaps(ranges, rangeI, tree, offset, dummies) {
    let rangeEnd = ranges[rangeI].to;
    let children = [], positions = [], start = tree.from + offset;
    function movePastNext(upto, inclusive) {
        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {
            let size = ranges[rangeI + 1].from - rangeEnd;
            offset += size;
            upto += size;
            rangeI++;
            rangeEnd = ranges[rangeI].to;
        }
    }
    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
        movePastNext(ch.from + offset, true);
        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);
        if (reuse) {
            node = reuse;
        }
        else if (ch.to + offset > rangeEnd) {
            node = injectGaps(ranges, rangeI, ch, offset, dummies);
            movePastNext(ch.to + offset, false);
        }
        else {
            node = ch.toTree();
        }
        children.push(node);
        positions.push(from - start);
    }
    movePastNext(tree.to + offset, false);
    return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);
}
/// A Markdown parser configuration.
class MarkdownParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(
    /// The parser's syntax [node
    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).
    nodeSet, 
    /// @internal
    blockParsers, 
    /// @internal
    leafBlockParsers, 
    /// @internal
    blockNames, 
    /// @internal
    endLeafBlock, 
    /// @internal
    skipContextMarkup, 
    /// @internal
    inlineParsers, 
    /// @internal
    inlineNames, 
    /// @internal
    wrappers) {
        super();
        this.nodeSet = nodeSet;
        this.blockParsers = blockParsers;
        this.leafBlockParsers = leafBlockParsers;
        this.blockNames = blockNames;
        this.endLeafBlock = endLeafBlock;
        this.skipContextMarkup = skipContextMarkup;
        this.inlineParsers = inlineParsers;
        this.inlineNames = inlineNames;
        this.wrappers = wrappers;
        /// @internal
        this.nodeTypes = Object.create(null);
        for (let t of nodeSet.types)
            this.nodeTypes[t.name] = t.id;
    }
    createParse(input, fragments, ranges) {
        let parse = new BlockContext(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Reconfigure the parser.
    configure(spec) {
        let config = resolveConfig(spec);
        if (!config)
            return this;
        let { nodeSet, skipContextMarkup } = this;
        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
        if (nonEmpty(config.defineNodes)) {
            skipContextMarkup = Object.assign({}, skipContextMarkup);
            let nodeTypes = nodeSet.types.slice(), styles;
            for (let s of config.defineNodes) {
                let { name, block, composite, style } = typeof s == "string" ? { name: s } : s;
                if (nodeTypes.some(t => t.name == name))
                    continue;
                if (composite)
                    skipContextMarkup[nodeTypes.length] =
                        (bl, cx, line) => composite(cx, line, bl.value);
                let id = nodeTypes.length;
                let group = composite ? ["Block", "BlockContext"] : !block ? undefined
                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
                nodeTypes.push(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
                    id,
                    name,
                    props: group && [[_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.group, group]]
                }));
                if (style) {
                    if (!styles)
                        styles = {};
                    if (Array.isArray(style) || style instanceof _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.Tag)
                        styles[name] = style;
                    else
                        Object.assign(styles, style);
                }
            }
            nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeTypes);
            if (styles)
                nodeSet = nodeSet.extend((0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)(styles));
        }
        if (nonEmpty(config.props))
            nodeSet = nodeSet.extend(...config.props);
        if (nonEmpty(config.remove)) {
            for (let rm of config.remove) {
                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);
                if (block > -1)
                    blockParsers[block] = leafBlockParsers[block] = undefined;
                if (inline > -1)
                    inlineParsers[inline] = undefined;
            }
        }
        if (nonEmpty(config.parseBlock)) {
            for (let spec of config.parseBlock) {
                let found = blockNames.indexOf(spec.name);
                if (found > -1) {
                    blockParsers[found] = spec.parse;
                    leafBlockParsers[found] = spec.leaf;
                }
                else {
                    let pos = spec.before ? findName(blockNames, spec.before)
                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;
                    blockParsers.splice(pos, 0, spec.parse);
                    leafBlockParsers.splice(pos, 0, spec.leaf);
                    blockNames.splice(pos, 0, spec.name);
                }
                if (spec.endLeaf)
                    endLeafBlock.push(spec.endLeaf);
            }
        }
        if (nonEmpty(config.parseInline)) {
            for (let spec of config.parseInline) {
                let found = inlineNames.indexOf(spec.name);
                if (found > -1) {
                    inlineParsers[found] = spec.parse;
                }
                else {
                    let pos = spec.before ? findName(inlineNames, spec.before)
                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;
                    inlineParsers.splice(pos, 0, spec.parse);
                    inlineNames.splice(pos, 0, spec.name);
                }
            }
        }
        if (config.wrap)
            wrappers = wrappers.concat(config.wrap);
        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
    }
    /// @internal
    getNodeType(name) {
        let found = this.nodeTypes[name];
        if (found == null)
            throw new RangeError(`Unknown node type '${name}'`);
        return found;
    }
    /// Parse the given piece of inline text at the given offset,
    /// returning an array of [`Element`](#Element) objects representing
    /// the inline content.
    parseInline(text, offset) {
        let cx = new InlineContext(this, text, offset);
        outer: for (let pos = offset; pos < cx.end;) {
            let next = cx.char(pos);
            for (let token of this.inlineParsers)
                if (token) {
                    let result = token(cx, next, pos);
                    if (result >= 0) {
                        pos = result;
                        continue outer;
                    }
                }
            pos++;
        }
        return cx.resolveMarkers(0);
    }
}
function nonEmpty(a) {
    return a != null && a.length > 0;
}
function resolveConfig(spec) {
    if (!Array.isArray(spec))
        return spec;
    if (spec.length == 0)
        return null;
    let conf = resolveConfig(spec[0]);
    if (spec.length == 1)
        return conf;
    let rest = resolveConfig(spec.slice(1));
    if (!rest || !conf)
        return conf || rest;
    let conc = (a, b) => (a || none).concat(b || none);
    let wrapA = conf.wrap, wrapB = rest.wrap;
    return {
        props: conc(conf.props, rest.props),
        defineNodes: conc(conf.defineNodes, rest.defineNodes),
        parseBlock: conc(conf.parseBlock, rest.parseBlock),
        parseInline: conc(conf.parseInline, rest.parseInline),
        remove: conc(conf.remove, rest.remove),
        wrap: !wrapA ? wrapB : !wrapB ? wrapA :
            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
    };
}
function findName(names, name) {
    let found = names.indexOf(name);
    if (found < 0)
        throw new RangeError(`Position specified relative to unknown parser ${name}`);
    return found;
}
let nodeTypes = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];
for (let i = 1, name; name = Type[i]; i++) {
    nodeTypes[i] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
        id: i,
        name,
        props: i >= Type.Escape ? [] : [[_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
        top: name == "Document"
    });
}
const none = [];
class Buffer {
    constructor(nodeSet) {
        this.nodeSet = nodeSet;
        this.content = [];
        this.nodes = [];
    }
    write(type, from, to, children = 0) {
        this.content.push(type, from, to, 4 + children * 4);
        return this;
    }
    writeElements(elts, offset = 0) {
        for (let e of elts)
            e.writeTo(this, offset);
        return this;
    }
    finish(type, length) {
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({
            buffer: this.content,
            nodeSet: this.nodeSet,
            reused: this.nodes,
            topID: type,
            length
        });
    }
}
/// Elements are used to compose syntax nodes during parsing.
class Element {
    /// @internal
    constructor(
    /// The node's
    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).
    type, 
    /// The start of the node, as an offset from the start of the document.
    from, 
    /// The end of the node.
    to, 
    /// The node's child nodes @internal
    children = none) {
        this.type = type;
        this.from = from;
        this.to = to;
        this.children = children;
    }
    /// @internal
    writeTo(buf, offset) {
        let startOff = buf.content.length;
        buf.writeElements(this.children, offset);
        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
    }
    /// @internal
    toTree(nodeSet) {
        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
    }
}
class TreeElement {
    constructor(tree, from) {
        this.tree = tree;
        this.from = from;
    }
    get to() { return this.from + this.tree.length; }
    get type() { return this.tree.type.id; }
    get children() { return none; }
    writeTo(buf, offset) {
        buf.nodes.push(this.tree);
        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
    }
    toTree() { return this.tree; }
}
function elt(type, from, to, children) {
    return new Element(type, from, to, children);
}
const EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
const EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
const LinkStart = {}, ImageStart = {};
class InlineDelimiter {
    constructor(type, from, to, side) {
        this.type = type;
        this.from = from;
        this.to = to;
        this.side = side;
    }
}
const Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
    Punctuation = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
}
catch (_) { }
const DefaultInline = {
    Escape(cx, next, start) {
        if (next != 92 /* '\\' */ || start == cx.end - 1)
            return -1;
        let escaped = cx.char(start + 1);
        for (let i = 0; i < Escapable.length; i++)
            if (Escapable.charCodeAt(i) == escaped)
                return cx.append(elt(Type.Escape, start, start + 2));
        return -1;
    },
    Entity(cx, next, start) {
        if (next != 38 /* '&' */)
            return -1;
        let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;
    },
    InlineCode(cx, next, start) {
        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)
            return -1;
        let pos = start + 1;
        while (pos < cx.end && cx.char(pos) == 96)
            pos++;
        let size = pos - start, curSize = 0;
        for (; pos < cx.end; pos++) {
            if (cx.char(pos) == 96) {
                curSize++;
                if (curSize == size && cx.char(pos + 1) != 96)
                    return cx.append(elt(Type.InlineCode, start, pos + 1, [
                        elt(Type.CodeMark, start, start + size),
                        elt(Type.CodeMark, pos + 1 - size, pos + 1)
                    ]));
            }
            else {
                curSize = 0;
            }
        }
        return -1;
    },
    HTMLTag(cx, next, start) {
        if (next != 60 /* '<' */ || start == cx.end - 1)
            return -1;
        let after = cx.slice(start + 1, cx.end);
        let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
        if (url) {
            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [
                elt(Type.LinkMark, start, start + 1),
                // url[0] includes the closing bracket, so exclude it from this slice
                elt(Type.URL, start + 1, start + url[0].length),
                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)
            ]));
        }
        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
        if (comment)
            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));
        let procInst = /^\?[^]*?\?>/.exec(after);
        if (procInst)
            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
        let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
        if (!m)
            return -1;
        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));
    },
    Emphasis(cx, next, start) {
        if (next != 95 && next != 42)
            return -1;
        let pos = start + 1;
        while (cx.char(pos) == next)
            pos++;
        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
        let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));
    },
    HardBreak(cx, next, start) {
        if (next == 92 /* '\\' */ && cx.char(start + 1) == 10 /* '\n' */)
            return cx.append(elt(Type.HardBreak, start, start + 2));
        if (next == 32) {
            let pos = start + 1;
            while (cx.char(pos) == 32)
                pos++;
            if (cx.char(pos) == 10 && pos >= start + 2)
                return cx.append(elt(Type.HardBreak, start, pos + 1));
        }
        return -1;
    },
    Link(cx, next, start) {
        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;
    },
    Image(cx, next, start) {
        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */
            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;
    },
    LinkEnd(cx, next, start) {
        if (next != 93 /* ']' */)
            return -1;
        // Scanning back to the next link/image start marker
        for (let i = cx.parts.length - 1; i >= 0; i--) {
            let part = cx.parts[i];
            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
                // If this one has been set invalid (because it would produce
                // a nested link) or there's no valid link here ignore both.
                if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
                    cx.parts[i] = null;
                    return -1;
                }
                // Finish the content and replace the entire range in
                // this.parts with the link/image node.
                let content = cx.takeContent(i);
                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
                // Set any open-link markers before this link to invalid.
                if (part.type == LinkStart)
                    for (let j = 0; j < i; j++) {
                        let p = cx.parts[j];
                        if (p instanceof InlineDelimiter && p.type == LinkStart)
                            p.side = 0 /* Mark.None */;
                    }
                return link.to;
            }
        }
        return -1;
    }
};
function finishLink(cx, content, type, start, startPos) {
    let { text } = cx, next = cx.char(startPos), endPos = startPos;
    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
    content.push(elt(Type.LinkMark, startPos - 1, startPos));
    if (next == 40 /* '(' */) {
        let pos = cx.skipSpace(startPos + 1);
        let dest = parseURL(text, pos - cx.offset, cx.offset), title;
        if (dest) {
            pos = cx.skipSpace(dest.to);
            // The destination and title must be separated by whitespace
            if (pos != dest.to) {
                title = parseLinkTitle(text, pos - cx.offset, cx.offset);
                if (title)
                    pos = cx.skipSpace(title.to);
            }
        }
        if (cx.char(pos) == 41 /* ')' */) {
            content.push(elt(Type.LinkMark, startPos, startPos + 1));
            endPos = pos + 1;
            if (dest)
                content.push(dest);
            if (title)
                content.push(title);
            content.push(elt(Type.LinkMark, pos, endPos));
        }
    }
    else if (next == 91 /* '[' */) {
        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
        if (label) {
            content.push(label);
            endPos = label.to;
        }
    }
    return elt(type, start, endPos, content);
}
// These return `null` when falling off the end of the input, `false`
// when parsing fails otherwise (for use in the incremental link
// reference parser).
function parseURL(text, start, offset) {
    let next = text.charCodeAt(start);
    if (next == 60 /* '<' */) {
        for (let pos = start + 1; pos < text.length; pos++) {
            let ch = text.charCodeAt(pos);
            if (ch == 62 /* '>' */)
                return elt(Type.URL, start + offset, pos + 1 + offset);
            if (ch == 60 || ch == 10 /* '<\n' */)
                return false;
        }
        return null;
    }
    else {
        let depth = 0, pos = start;
        for (let escaped = false; pos < text.length; pos++) {
            let ch = text.charCodeAt(pos);
            if (space(ch)) {
                break;
            }
            else if (escaped) {
                escaped = false;
            }
            else if (ch == 40 /* '(' */) {
                depth++;
            }
            else if (ch == 41 /* ')' */) {
                if (!depth)
                    break;
                depth--;
            }
            else if (ch == 92 /* '\\' */) {
                escaped = true;
            }
        }
        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;
    }
}
function parseLinkTitle(text, start, offset) {
    let next = text.charCodeAt(start);
    if (next != 39 && next != 34 && next != 40 /* '"\'(' */)
        return false;
    let end = next == 40 ? 41 : next;
    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {
        let ch = text.charCodeAt(pos);
        if (escaped)
            escaped = false;
        else if (ch == end)
            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
        else if (ch == 92 /* '\\' */)
            escaped = true;
    }
    return null;
}
function parseLinkLabel(text, start, offset, requireNonWS) {
    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {
        let ch = text.charCodeAt(pos);
        if (escaped)
            escaped = false;
        else if (ch == 93 /* ']' */)
            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
        else {
            if (requireNonWS && !space(ch))
                requireNonWS = false;
            if (ch == 91 /* '[' */)
                return false;
            else if (ch == 92 /* '\\' */)
                escaped = true;
        }
    }
    return null;
}
/// Inline parsing functions get access to this context, and use it to
/// read the content and emit syntax nodes.
class InlineContext {
    /// @internal
    constructor(
    /// The parser that is being used.
    parser, 
    /// The text of this inline section.
    text, 
    /// The starting offset of the section in the document.
    offset) {
        this.parser = parser;
        this.text = text;
        this.offset = offset;
        /// @internal
        this.parts = [];
    }
    /// Get the character code at the given (document-relative)
    /// position.
    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }
    /// The position of the end of this inline section.
    get end() { return this.offset + this.text.length; }
    /// Get a substring of this inline section. Again uses
    /// document-relative positions.
    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }
    /// @internal
    append(elt) {
        this.parts.push(elt);
        return elt.to;
    }
    /// Add a [delimiter](#DelimiterType) at this given position. `open`
    /// and `close` indicate whether this delimiter is opening, closing,
    /// or both. Returns the end of the delimiter, for convenient
    /// returning from [parse functions](#InlineParser.parse).
    addDelimiter(type, from, to, open, close) {
        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));
    }
    /// Returns true when there is an unmatched link or image opening
    /// token before the current position.
    get hasOpenLink() {
        for (let i = this.parts.length - 1; i >= 0; i--) {
            let part = this.parts[i];
            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
                return true;
        }
        return false;
    }
    /// Add an inline element. Returns the end of the element.
    addElement(elt) {
        return this.append(elt);
    }
    /// Resolve markers between this.parts.length and from, wrapping matched markers in the
    /// appropriate node and updating the content of this.parts. @internal
    resolveMarkers(from) {
        // Scan forward, looking for closing tokens
        for (let i = from; i < this.parts.length; i++) {
            let close = this.parts[i];
            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))
                continue;
            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
            let closeSize = close.to - close.from;
            let open, j = i - 1;
            // Continue scanning for a matching opening token
            for (; j >= from; j--) {
                let part = this.parts[j];
                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&
                    // Ignore emphasis delimiters where the character count doesn't match
                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&
                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
                    open = part;
                    break;
                }
            }
            if (!open)
                continue;
            let type = close.type.resolve, content = [];
            let start = open.from, end = close.to;
            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two
            // markers.
            if (emp) {
                let size = Math.min(2, open.to - open.from, closeSize);
                start = open.to - size;
                end = close.from + size;
                type = size == 1 ? "Emphasis" : "StrongEmphasis";
            }
            // Move the covered region into content, optionally adding marker nodes
            if (open.type.mark)
                content.push(this.elt(open.type.mark, start, open.to));
            for (let k = j + 1; k < i; k++) {
                if (this.parts[k] instanceof Element)
                    content.push(this.parts[k]);
                this.parts[k] = null;
            }
            if (close.type.mark)
                content.push(this.elt(close.type.mark, close.from, end));
            let element = this.elt(type, start, end, content);
            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.
            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
            // Insert the new element in this.parts
            if (keep)
                this.parts.splice(i, 0, element);
            else
                this.parts[i] = element;
        }
        // Collect the elements remaining in this.parts into an array.
        let result = [];
        for (let i = from; i < this.parts.length; i++) {
            let part = this.parts[i];
            if (part instanceof Element)
                result.push(part);
        }
        return result;
    }
    /// Find an opening delimiter of the given type. Returns `null` if
    /// no delimiter is found, or an index that can be passed to
    /// [`takeContent`](#InlineContext.takeContent) otherwise.
    findOpeningDelimiter(type) {
        for (let i = this.parts.length - 1; i >= 0; i--) {
            let part = this.parts[i];
            if (part instanceof InlineDelimiter && part.type == type)
                return i;
        }
        return null;
    }
    /// Remove all inline elements and delimiters starting from the
    /// given index (which you should get from
    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
    /// resolve delimiters inside of them, and return them as an array
    /// of elements.
    takeContent(startIndex) {
        let content = this.resolveMarkers(startIndex);
        this.parts.length = startIndex;
        return content;
    }
    /// Skip space after the given (document) position, returning either
    /// the position of the next non-space character or the end of the
    /// section.
    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }
    elt(type, from, to, children) {
        if (typeof type == "string")
            return elt(this.parser.getNodeType(type), from, to, children);
        return new TreeElement(type, from);
    }
}
function injectMarks(elements, marks) {
    if (!marks.length)
        return elements;
    if (!elements.length)
        return marks;
    let elts = elements.slice(), eI = 0;
    for (let mark of marks) {
        while (eI < elts.length && elts[eI].to < mark.to)
            eI++;
        if (eI < elts.length && elts[eI].from < mark.from) {
            let e = elts[eI];
            if (e instanceof Element)
                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));
        }
        else {
            elts.splice(eI++, 0, mark);
        }
    }
    return elts;
}
// These are blocks that can span blank lines, and should thus only be
// reused if their next sibling is also being reused.
const NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
class FragmentCursor {
    constructor(fragments, input) {
        this.fragments = fragments;
        this.input = input;
        // Index into fragment array
        this.i = 0;
        // Active fragment
        this.fragment = null;
        this.fragmentEnd = -1;
        // Cursor into the current fragment, if any. When `moveTo` returns
        // true, this points at the first block after `pos`.
        this.cursor = null;
        if (fragments.length)
            this.fragment = fragments[this.i++];
    }
    nextFragment() {
        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
        this.cursor = null;
        this.fragmentEnd = -1;
    }
    moveTo(pos, lineStart) {
        while (this.fragment && this.fragment.to <= pos)
            this.nextFragment();
        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
            return false;
        if (this.fragmentEnd < 0) {
            let end = this.fragment.to;
            while (end > 0 && this.input.read(end - 1, end) != "\n")
                end--;
            this.fragmentEnd = end ? end - 1 : 0;
        }
        let c = this.cursor;
        if (!c) {
            c = this.cursor = this.fragment.tree.cursor();
            c.firstChild();
        }
        let rPos = pos + this.fragment.offset;
        while (c.to <= rPos)
            if (!c.parent())
                return false;
        for (;;) {
            if (c.from >= rPos)
                return this.fragment.from <= lineStart;
            if (!c.childAfter(rPos))
                return false;
        }
    }
    matches(hash) {
        let tree = this.cursor.tree;
        return tree && tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) == hash;
    }
    takeNodes(cx) {
        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
        let prevEnd = end, prevI = blockI;
        for (;;) {
            if (cur.to - off > fragEnd) {
                if (cur.type.isAnonymous && cur.firstChild())
                    continue;
                break;
            }
            let pos = toRelative(cur.from - off, cx.ranges);
            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range
                cx.addNode(cur.tree, pos);
            }
            else {
                let dummy = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);
                cx.reusePlaceholders.set(dummy, cur.tree);
                cx.addNode(dummy, pos);
            }
            // Taken content must always end in a block, because incremental
            // parsing happens on block boundaries. Never stop directly
            // after an indented code block, since those can continue after
            // any number of blank lines.
            if (cur.type.is("Block")) {
                if (NotLast.indexOf(cur.type.id) < 0) {
                    end = cur.to - off;
                    blockI = cx.block.children.length;
                }
                else {
                    end = prevEnd;
                    blockI = prevI;
                    prevEnd = cur.to - off;
                    prevI = cx.block.children.length;
                }
            }
            if (!cur.nextSibling())
                break;
        }
        while (cx.block.children.length > blockI) {
            cx.block.children.pop();
            cx.block.positions.pop();
        }
        return end - start;
    }
}
// Convert an input-stream-relative position to a
// Markdown-doc-relative position by subtracting the size of all input
// gaps before `abs`.
function toRelative(abs, ranges) {
    let pos = abs;
    for (let i = 1; i < ranges.length; i++) {
        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;
        if (gapFrom < abs)
            pos -= gapTo - gapFrom;
    }
    return pos;
}
const markdownHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({
    "Blockquote/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.quote,
    HorizontalRule: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,
    "ATXHeading1/... SetextHeading1/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading1,
    "ATXHeading2/... SetextHeading2/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading2,
    "ATXHeading3/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading3,
    "ATXHeading4/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading4,
    "ATXHeading5/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading5,
    "ATXHeading6/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading6,
    "Comment CommentBlock": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,
    Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,
    Entity: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,
    "Emphasis/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,
    "StrongEmphasis/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,
    "Link/... Image/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,
    "OrderedList/... BulletList/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.list,
    "BlockQuote/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.quote,
    "InlineCode CodeText": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.monospace,
    "URL Autolink": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,
    "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,
    "CodeInfo LinkLabel": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,
    LinkTitle: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,
    Paragraph: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content
});
/// The default CommonMark parser.
const parser = new MarkdownParser(new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);

function leftOverSpace(node, from, to) {
    let ranges = [];
    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {
        let nextPos = n ? n.from : to;
        if (nextPos > pos)
            ranges.push({ from: pos, to: nextPos });
        if (!n)
            break;
        pos = n.to;
    }
    return ranges;
}
/// Create a Markdown extension to enable nested parsing on code
/// blocks and/or embedded HTML.
function parseCode(config) {
    let { codeParser, htmlParser } = config;
    let wrap = (0,_lezer_common__WEBPACK_IMPORTED_MODULE_0__.parseMixed)((node, input) => {
        let id = node.type.id;
        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {
            let info = "";
            if (id == Type.FencedCode) {
                let infoNode = node.node.getChild(Type.CodeInfo);
                if (infoNode)
                    info = input.read(infoNode.from, infoNode.to);
            }
            let parser = codeParser(info);
            if (parser)
                return { parser, overlay: node => node.type.id == Type.CodeText };
        }
        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {
            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };
        }
        return null;
    });
    return { wrap };
}

const StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
/// An extension that implements
/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)
/// Strikethrough syntax using `~~` delimiters.
const Strikethrough = {
    defineNodes: [{
            name: "Strikethrough",
            style: { "Strikethrough/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough }
        }, {
            name: "StrikethroughMark",
            style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction
        }],
    parseInline: [{
            name: "Strikethrough",
            parse(cx, next, pos) {
                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
                    return -1;
                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
                let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
            },
            after: "Emphasis"
        }]
};
function parseRow(cx, line, startI = 0, elts, offset = 0) {
    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
    let parseCell = () => {
        elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
    };
    for (let i = startI; i < line.length; i++) {
        let next = line.charCodeAt(i);
        if (next == 124 /* '|' */ && !esc) {
            if (!first || cellStart > -1)
                count++;
            first = false;
            if (elts) {
                if (cellStart > -1)
                    parseCell();
                elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
            }
            cellStart = cellEnd = -1;
        }
        else if (esc || next != 32 && next != 9) {
            if (cellStart < 0)
                cellStart = i;
            cellEnd = i + 1;
        }
        esc = !esc && next == 92;
    }
    if (cellStart > -1) {
        count++;
        if (elts)
            parseCell();
    }
    return count;
}
function hasPipe(str, start) {
    for (let i = start; i < str.length; i++) {
        let next = str.charCodeAt(i);
        if (next == 124 /* '|' */)
            return true;
        if (next == 92 /* '\\' */)
            i++;
    }
    return false;
}
const delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class TableParser {
    constructor() {
        // Null means we haven't seen the second line yet, false means this
        // isn't a table, and an array means this is a table and we've
        // parsed the given rows so far.
        this.rows = null;
    }
    nextLine(cx, line, leaf) {
        if (this.rows == null) { // Second line
            this.rows = false;
            let lineText;
            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&
                delimiterLine.test(lineText = line.text.slice(line.pos))) {
                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
                if (firstCount == parseRow(cx, lineText, line.pos))
                    this.rows = [cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
                        cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)];
            }
        }
        else if (this.rows) { // Line after the second
            let content = [];
            parseRow(cx, line.text, line.pos, content, cx.lineStart);
            this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));
        }
        return false;
    }
    finish(cx, leaf) {
        if (!this.rows)
            return false;
        cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
        return true;
    }
}
/// This extension provides
/// [GFM-style](https://github.github.com/gfm/#tables-extension-)
/// tables, using syntax like this:
///
/// ```
/// | head 1 | head 2 |
/// | ---    | ---    |
/// | cell 1 | cell 2 |
/// ```
const Table = {
    defineNodes: [
        { name: "Table", block: true },
        { name: "TableHeader", style: { "TableHeader/...": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading } },
        "TableRow",
        { name: "TableCell", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content },
        { name: "TableDelimiter", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction },
    ],
    parseBlock: [{
            name: "Table",
            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },
            endLeaf(cx, line, leaf) {
                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))
                    return false;
                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;
                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
            },
            before: "SetextHeading"
        }]
};
class TaskParser {
    nextLine() { return false; }
    finish(cx, leaf) {
        cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
            cx.elt("TaskMarker", leaf.start, leaf.start + 3),
            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
        ]));
        return true;
    }
}
/// Extension providing
/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)
/// task list items, where list items can be prefixed with `[ ]` or
/// `[x]` to add a checkbox.
const TaskList = {
    defineNodes: [
        { name: "Task", block: true, style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.list },
        { name: "TaskMarker", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom }
    ],
    parseBlock: [{
            name: "TaskList",
            leaf(cx, leaf) {
                return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser : null;
            },
            after: "SetextHeading"
        }]
};
const autolinkRE = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy;
const urlRE = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy;
const lastTwoDomainWords = /[\w-]+\.[\w-]+($|\/)/;
const emailRE = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy;
const xmppResourceRE = /\/[a-zA-Z\d@.]+/gy;
function count(str, from, to, ch) {
    let result = 0;
    for (let i = from; i < to; i++)
        if (str[i] == ch)
            result++;
    return result;
}
function autolinkURLEnd(text, from) {
    urlRE.lastIndex = from;
    let m = urlRE.exec(text);
    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf("_") > -1)
        return -1;
    let end = from + m[0].length;
    for (;;) {
        let last = text[end - 1], m;
        if (/[?!.,:*_~]/.test(last) ||
            last == ")" && count(text, from, end, ")") > count(text, from, end, "("))
            end--;
        else if (last == ";" && (m = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(text.slice(from, end))))
            end = from + m.index;
        else
            break;
    }
    return end;
}
function autolinkEmailEnd(text, from) {
    emailRE.lastIndex = from;
    let m = emailRE.exec(text);
    if (!m)
        return -1;
    let last = m[0][m[0].length - 1];
    return last == "_" || last == "-" ? -1 : from + m[0].length - (last == "." ? 1 : 0);
}
/// Extension that implements autolinking for
/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email
/// addresses.
const Autolink = {
    parseInline: [{
            name: "Autolink",
            parse(cx, next, absPos) {
                let pos = absPos - cx.offset;
                autolinkRE.lastIndex = pos;
                let m = autolinkRE.exec(cx.text), end = -1;
                if (!m)
                    return -1;
                if (m[1] || m[2]) { // www., http://
                    end = autolinkURLEnd(cx.text, pos + m[0].length);
                    if (end > -1 && cx.hasOpenLink) {
                        let noBracket = /([^\[\]]|\[[^\]]*\])*/.exec(cx.text.slice(pos, end));
                        end = pos + noBracket[0].length;
                    }
                }
                else if (m[3]) { // email address
                    end = autolinkEmailEnd(cx.text, pos);
                }
                else { // mailto:/xmpp:
                    end = autolinkEmailEnd(cx.text, pos + m[0].length);
                    if (end > -1 && m[0] == "xmpp:") {
                        xmppResourceRE.lastIndex = end;
                        m = xmppResourceRE.exec(cx.text);
                        if (m)
                            end = m.index + m[0].length;
                    }
                }
                if (end < 0)
                    return -1;
                cx.addElement(cx.elt("URL", absPos, end + cx.offset));
                return end + cx.offset;
            }
        }]
};
/// Extension bundle containing [`Table`](#Table),
/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and
/// [`Autolink`](#Autolink).
const GFM = [Table, TaskList, Strikethrough, Autolink];
function parseSubSuper(ch, node, mark) {
    return (cx, next, pos) => {
        if (next != ch || cx.char(pos + 1) == ch)
            return -1;
        let elts = [cx.elt(mark, pos, pos + 1)];
        for (let i = pos + 1; i < cx.end; i++) {
            let next = cx.char(i);
            if (next == ch)
                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
            if (next == 92 /* '\\' */)
                elts.push(cx.elt("Escape", i, i++ + 2));
            if (space(next))
                break;
        }
        return -1;
    };
}
/// Extension providing
/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)
/// superscript using `^` markers.
const Superscript = {
    defineNodes: [
        { name: "Superscript", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content) },
        { name: "SuperscriptMark", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction }
    ],
    parseInline: [{
            name: "Superscript",
            parse: parseSubSuper(94 /* '^' */, "Superscript", "SuperscriptMark")
        }]
};
/// Extension providing
/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)
/// subscript using `~` markers.
const Subscript = {
    defineNodes: [
        { name: "Subscript", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content) },
        { name: "SubscriptMark", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction }
    ],
    parseInline: [{
            name: "Subscript",
            parse: parseSubSuper(126 /* '~' */, "Subscript", "SubscriptMark")
        }]
};
/// Extension that parses two colons with only letters, underscores,
/// and numbers between them as `Emoji` nodes.
const Emoji = {
    defineNodes: [{ name: "Emoji", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character }],
    parseInline: [{
            name: "Emoji",
            parse(cx, next, pos) {
                let match;
                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
                    return -1;
                return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
            }
        }]
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sYW5nLW1hcmtkb3duX2Rpc3RfaW5kZXhfanMuMjA0Yzk2NWFmMTFkMzg5ZDk4MDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Y7QUFDMUM7QUFDb0s7QUFDako7QUFDMkM7QUFDckM7QUFDMUI7O0FBRXpDLDBCQUEwQix5RUFBbUIsR0FBRyxpQkFBaUIsU0FBUyxnQ0FBZ0M7QUFDMUcscUNBQXFDLG1EQUFRO0FBQzdDLGdDQUFnQyxtREFBTTtBQUN0QztBQUNBLHFCQUFxQiw4REFBWTtBQUNqQztBQUNBLHNDQUFzQyxtREFBbUQ7QUFDekYsU0FBUztBQUNUO0FBQ0EscUJBQXFCLGdFQUFjO0FBQ25DO0FBQ0EsU0FBUztBQUNULHFCQUFxQixrRUFBZ0I7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUFXO0FBQzdDLG9CQUFvQixnRUFBVSwrQkFBK0IsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZSwwREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdEQUFHLEVBQUUsc0RBQVMsRUFBRSx3REFBVyxFQUFFLGtEQUFLO0FBQ3RGO0FBQ0EseUJBQXlCLDhEQUFZO0FBQ3JDLDJDQUEyQyxtREFBbUQ7QUFDOUYsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUVBQW1CO0FBQzNDLGlDQUFpQyxx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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFRO0FBQ2xDO0FBQ0E7QUFDQSx1QkFBdUIsbURBQVE7QUFDL0Isd0JBQXdCLCtDQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFJO0FBQ3ZCLDJEQUEyRCwrQ0FBSSxDQUFDLG1EQUFRO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQWdEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkZBQTJGO0FBQ3hILHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sVUFBVSxZQUFZO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRWtMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctbWFya2Rvd24vZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGxlemVyL21hcmtkb3duL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uLCBjb3VudENvbHVtbiwgUHJlYywgRWRpdG9yU3RhdGUgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IGRlZmluZUxhbmd1YWdlRmFjZXQsIGZvbGROb2RlUHJvcCwgaW5kZW50Tm9kZVByb3AsIGxhbmd1YWdlRGF0YVByb3AsIGZvbGRTZXJ2aWNlLCBzeW50YXhUcmVlLCBMYW5ndWFnZSwgTGFuZ3VhZ2VEZXNjcmlwdGlvbiwgUGFyc2VDb250ZXh0LCBpbmRlbnRVbml0LCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBDb21wbGV0aW9uQ29udGV4dCB9IGZyb20gJ0Bjb2RlbWlycm9yL2F1dG9jb21wbGV0ZSc7XG5pbXBvcnQgeyBwYXJzZXIsIEdGTSwgU3Vic2NyaXB0LCBTdXBlcnNjcmlwdCwgRW1vamksIE1hcmtkb3duUGFyc2VyLCBwYXJzZUNvZGUgfSBmcm9tICdAbGV6ZXIvbWFya2Rvd24nO1xuaW1wb3J0IHsgaHRtbCwgaHRtbENvbXBsZXRpb25Tb3VyY2UgfSBmcm9tICdAY29kZW1pcnJvci9sYW5nLWh0bWwnO1xuaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuY29uc3QgZGF0YSA9IC8qQF9fUFVSRV9fKi9kZWZpbmVMYW5ndWFnZUZhY2V0KHsgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcIjwhLS1cIiwgY2xvc2U6IFwiLS0+XCIgfSB9IH0pO1xuY29uc3QgaGVhZGluZ1Byb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG5jb25zdCBjb21tb25tYXJrID0gLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgIHByb3BzOiBbXG4gICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHR5cGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICF0eXBlLmlzKFwiQmxvY2tcIikgfHwgdHlwZS5pcyhcIkRvY3VtZW50XCIpIHx8IGlzSGVhZGluZyh0eXBlKSAhPSBudWxsIHx8IGlzTGlzdCh0eXBlKSA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogKHRyZWUsIHN0YXRlKSA9PiAoeyBmcm9tOiBzdGF0ZS5kb2MubGluZUF0KHRyZWUuZnJvbSkudG8sIHRvOiB0cmVlLnRvIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgLypAX19QVVJFX18qL2hlYWRpbmdQcm9wLmFkZChpc0hlYWRpbmcpLFxuICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgIERvY3VtZW50OiAoKSA9PiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICAvKkBfX1BVUkVfXyovbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoe1xuICAgICAgICAgICAgRG9jdW1lbnQ6IGRhdGFcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbmZ1bmN0aW9uIGlzSGVhZGluZyh0eXBlKSB7XG4gICAgbGV0IG1hdGNoID0gL14oPzpBVFh8U2V0ZXh0KUhlYWRpbmcoXFxkKSQvLmV4ZWModHlwZS5uYW1lKTtcbiAgICByZXR1cm4gbWF0Y2ggPyArbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0xpc3QodHlwZSkge1xuICAgIHJldHVybiB0eXBlLm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiIHx8IHR5cGUubmFtZSA9PSBcIkJ1bGxldExpc3RcIjtcbn1cbmZ1bmN0aW9uIGZpbmRTZWN0aW9uRW5kKGhlYWRlck5vZGUsIGxldmVsKSB7XG4gICAgbGV0IGxhc3QgPSBoZWFkZXJOb2RlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBsYXN0Lm5leHRTaWJsaW5nLCBoZWFkaW5nO1xuICAgICAgICBpZiAoIW5leHQgfHwgKGhlYWRpbmcgPSBpc0hlYWRpbmcobmV4dC50eXBlKSkgIT0gbnVsbCAmJiBoZWFkaW5nIDw9IGxldmVsKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxhc3QgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbGFzdC50bztcbn1cbmNvbnN0IGhlYWRlckluZGVudCA9IC8qQF9fUFVSRV9fKi9mb2xkU2VydmljZS5vZigoc3RhdGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgICBmb3IgKGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGVuZCwgLTEpOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuZnJvbSA8IHN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBoZWFkaW5nID0gbm9kZS50eXBlLnByb3AoaGVhZGluZ1Byb3ApO1xuICAgICAgICBpZiAoaGVhZGluZyA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCB1cHRvID0gZmluZFNlY3Rpb25FbmQobm9kZSwgaGVhZGluZyk7XG4gICAgICAgIGlmICh1cHRvID4gZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZW5kLCB0bzogdXB0byB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0pO1xuZnVuY3Rpb24gbWtMYW5nKHBhcnNlcikge1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2UoZGF0YSwgcGFyc2VyLCBbaGVhZGVySW5kZW50XSwgXCJtYXJrZG93blwiKTtcbn1cbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3Igc3RyaWN0IENvbW1vbk1hcmsuXG4qL1xuY29uc3QgY29tbW9ubWFya0xhbmd1YWdlID0gLypAX19QVVJFX18qL21rTGFuZyhjb21tb25tYXJrKTtcbmNvbnN0IGV4dGVuZGVkID0gLypAX19QVVJFX18qL2NvbW1vbm1hcmsuY29uZmlndXJlKFtHRk0sIFN1YnNjcmlwdCwgU3VwZXJzY3JpcHQsIEVtb2ppLCB7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgVGFibGU6ICh0cmVlLCBzdGF0ZSkgPT4gKHsgZnJvbTogc3RhdGUuZG9jLmxpbmVBdCh0cmVlLmZyb20pLnRvLCB0bzogdHJlZS50byB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH1dKTtcbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3IgW0dGTV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vKSBwbHVzXG5zdWJzY3JpcHQsIHN1cGVyc2NyaXB0LCBhbmQgZW1vamkgc3ludGF4LlxuKi9cbmNvbnN0IG1hcmtkb3duTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovbWtMYW5nKGV4dGVuZGVkKTtcbmZ1bmN0aW9uIGdldENvZGVQYXJzZXIobGFuZ3VhZ2VzLCBkZWZhdWx0TGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gKGluZm8pID0+IHtcbiAgICAgICAgaWYgKGluZm8gJiYgbGFuZ3VhZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU3RyaXAgYW55dGhpbmcgYWZ0ZXIgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaW5mbyA9IC9cXFMqLy5leGVjKGluZm8pWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbGFuZ3VhZ2VzKGluZm8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvdW5kID0gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5tYXRjaExhbmd1YWdlTmFtZShsYW5ndWFnZXMsIGluZm8sIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kIGluc3RhbmNlb2YgTGFuZ3VhZ2VEZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuc3VwcG9ydCA/IGZvdW5kLnN1cHBvcnQubGFuZ3VhZ2UucGFyc2VyIDogUGFyc2VDb250ZXh0LmdldFNraXBwaW5nUGFyc2VyKGZvdW5kLmxvYWQoKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQucGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0TGFuZ3VhZ2UgPyBkZWZhdWx0TGFuZ3VhZ2UucGFyc2VyIDogbnVsbDtcbiAgICB9O1xufVxuXG5jbGFzcyBDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmcm9tLCB0bywgc3BhY2VCZWZvcmUsIHNwYWNlQWZ0ZXIsIHR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNwYWNlQmVmb3JlID0gc3BhY2VCZWZvcmU7XG4gICAgICAgIHRoaXMuc3BhY2VBZnRlciA9IHNwYWNlQWZ0ZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgfVxuICAgIGJsYW5rKG1heFdpZHRoLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BhY2VCZWZvcmUgKyAodGhpcy5ub2RlLm5hbWUgPT0gXCJCbG9ja3F1b3RlXCIgPyBcIj5cIiA6IFwiXCIpO1xuICAgICAgICBpZiAobWF4V2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBtYXhXaWR0aClcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudG8gLSB0aGlzLmZyb20gLSByZXN1bHQubGVuZ3RoIC0gdGhpcy5zcGFjZUFmdGVyLmxlbmd0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHRyYWlsaW5nID8gdGhpcy5zcGFjZUFmdGVyIDogXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFya2VyKGRvYywgYWRkKSB7XG4gICAgICAgIGxldCBudW1iZXIgPSB0aGlzLm5vZGUubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIgPyBTdHJpbmcoKCtpdGVtTnVtYmVyKHRoaXMuaXRlbSwgZG9jKVsyXSArIGFkZCkpIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2VCZWZvcmUgKyBudW1iZXIgKyB0aGlzLnR5cGUgKyB0aGlzLnNwYWNlQWZ0ZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChub2RlLCBkb2MpIHtcbiAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1ci5uYW1lID09IFwiTGlzdEl0ZW1cIiB8fCBjdXIubmFtZSA9PSBcIkJsb2NrcXVvdGVcIiB8fCBjdXIubmFtZSA9PSBcIkZlbmNlZENvZGVcIilcbiAgICAgICAgICAgIG5vZGVzLnB1c2goY3VyKTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSwgbWF0Y2g7XG4gICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChub2RlLmZyb20pLCBzdGFydFBvcyA9IG5vZGUuZnJvbSAtIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkZlbmNlZENvZGVcIikge1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKG5ldyBDb250ZXh0KG5vZGUsIHN0YXJ0UG9zLCBzdGFydFBvcywgXCJcIiwgXCJcIiwgXCJcIiwgbnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PSBcIkJsb2NrcXVvdGVcIiAmJiAobWF0Y2ggPSAvXiAqPiggPykvLmV4ZWMobGluZS50ZXh0LnNsaWNlKHN0YXJ0UG9zKSkpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnB1c2gobmV3IENvbnRleHQobm9kZSwgc3RhcnRQb3MsIHN0YXJ0UG9zICsgbWF0Y2hbMF0ubGVuZ3RoLCBcIlwiLCBtYXRjaFsxXSwgXCI+XCIsIG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT0gXCJMaXN0SXRlbVwiICYmIG5vZGUucGFyZW50Lm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiICYmXG4gICAgICAgICAgICAobWF0Y2ggPSAvXiggKilcXGQrKFsuKV0pKCAqKS8uZXhlYyhsaW5lLnRleHQuc2xpY2Uoc3RhcnRQb3MpKSkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG1hdGNoWzNdLCBsZW4gPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNsaWNlKDAsIGFmdGVyLmxlbmd0aCAtIDQpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5wdXNoKG5ldyBDb250ZXh0KG5vZGUucGFyZW50LCBzdGFydFBvcywgc3RhcnRQb3MgKyBsZW4sIG1hdGNoWzFdLCBhZnRlciwgbWF0Y2hbMl0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT0gXCJMaXN0SXRlbVwiICYmIG5vZGUucGFyZW50Lm5hbWUgPT0gXCJCdWxsZXRMaXN0XCIgJiZcbiAgICAgICAgICAgIChtYXRjaCA9IC9eKCAqKShbLSsqXSkoIHsxLDR9XFxbWyB4WF1cXF0pPyggKykvLmV4ZWMobGluZS50ZXh0LnNsaWNlKHN0YXJ0UG9zKSkpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaFs0XSwgbGVuID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFmdGVyLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNsaWNlKDAsIGFmdGVyLmxlbmd0aCAtIDQpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHR5cGUgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGlmIChtYXRjaFszXSlcbiAgICAgICAgICAgICAgICB0eXBlICs9IG1hdGNoWzNdLnJlcGxhY2UoL1t4WF0vLCAnICcpO1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKG5ldyBDb250ZXh0KG5vZGUucGFyZW50LCBzdGFydFBvcywgc3RhcnRQb3MgKyBsZW4sIG1hdGNoWzFdLCBhZnRlciwgdHlwZSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gaXRlbU51bWJlcihpdGVtLCBkb2MpIHtcbiAgICByZXR1cm4gL14oXFxzKikoXFxkKykoPz1bLildKS8uZXhlYyhkb2Muc2xpY2VTdHJpbmcoaXRlbS5mcm9tLCBpdGVtLmZyb20gKyAxMCkpO1xufVxuZnVuY3Rpb24gcmVudW1iZXJMaXN0KGFmdGVyLCBkb2MsIGNoYW5nZXMsIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBwcmV2ID0gLTEsIG5vZGUgPSBhZnRlcjs7KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJMaXN0SXRlbVwiKSB7XG4gICAgICAgICAgICBsZXQgbSA9IGl0ZW1OdW1iZXIobm9kZSwgZG9jKTtcbiAgICAgICAgICAgIGxldCBudW1iZXIgPSArbVsyXTtcbiAgICAgICAgICAgIGlmIChwcmV2ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyICE9IHByZXYgKyAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbm9kZS5mcm9tICsgbVsxXS5sZW5ndGgsIHRvOiBub2RlLmZyb20gKyBtWzBdLmxlbmd0aCwgaW5zZXJ0OiBTdHJpbmcocHJldiArIDIgKyBvZmZzZXQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmRlbnQoY29udGVudCwgc3RhdGUpIHtcbiAgICBsZXQgYmxhbmsgPSAvXlsgXFx0XSovLmV4ZWMoY29udGVudClbMF0ubGVuZ3RoO1xuICAgIGlmICghYmxhbmsgfHwgc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgIT0gXCJcXHRcIilcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKGNvbnRlbnQsIDQsIGJsYW5rKTtcbiAgICBsZXQgc3BhY2UgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSBjb2w7IGkgPiAwOykge1xuICAgICAgICBpZiAoaSA+PSA0KSB7XG4gICAgICAgICAgICBzcGFjZSArPSBcIlxcdFwiO1xuICAgICAgICAgICAgaSAtPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhY2UgKz0gXCIgXCI7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlICsgY29udGVudC5zbGljZShibGFuayk7XG59XG4vKipcblRoaXMgY29tbWFuZCwgd2hlbiBpbnZva2VkIGluIE1hcmtkb3duIGNvbnRleHQgd2l0aCBjdXJzb3JcbnNlbGVjdGlvbihzKSwgd2lsbCBjcmVhdGUgYSBuZXcgbGluZSB3aXRoIHRoZSBtYXJrdXAgZm9yXG5ibG9ja3F1b3RlcyBhbmQgbGlzdHMgdGhhdCB3ZXJlIGFjdGl2ZSBvbiB0aGUgb2xkIGxpbmUuIElmIHRoZVxuY3Vyc29yIHdhcyBkaXJlY3RseSBhZnRlciB0aGUgZW5kIG9mIHRoZSBtYXJrdXAgZm9yIHRoZSBvbGQgbGluZSxcbnRyYWlsaW5nIHdoaXRlc3BhY2UgYW5kIGxpc3QgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoYXQgbGluZS5cblxuVGhlIGNvbW1hbmQgZG9lcyBub3RoaW5nIGluIG5vbi1NYXJrZG93biBjb250ZXh0LCBzbyBpdCBzaG91bGRcbm5vdCBiZSB1c2VkIGFzIHRoZSBvbmx5IGJpbmRpbmcgZm9yIEVudGVyIChldmVuIGluIGEgTWFya2Rvd25cbmRvY3VtZW50LCBIVE1MIGFuZCBjb2RlIHJlZ2lvbnMgbWlnaHQgdXNlIGEgZGlmZmVyZW50IGxhbmd1YWdlKS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lQ29udGludWVNYXJrdXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIHsgZG9jIH0gPSBzdGF0ZTtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCAhbWFya2Rvd25MYW5ndWFnZS5pc0FjdGl2ZUF0KHN0YXRlLCByYW5nZS5mcm9tLCAwKSlcbiAgICAgICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBnZXRDb250ZXh0KHRyZWUucmVzb2x2ZUlubmVyKHBvcywgLTEpLCBkb2MpO1xuICAgICAgICB3aGlsZSAoY29udGV4dC5sZW5ndGggJiYgY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdLmZyb20gPiBwb3MgLSBsaW5lLmZyb20pXG4gICAgICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgICBpZiAoIWNvbnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGRvbnQgPSB7IHJhbmdlIH07XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGlubmVyLnRvIC0gaW5uZXIuc3BhY2VBZnRlci5sZW5ndGggPiBwb3MgLSBsaW5lLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IGVtcHR5TGluZSA9IHBvcyA+PSAoaW5uZXIudG8gLSBpbm5lci5zcGFjZUFmdGVyLmxlbmd0aCkgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKGlubmVyLnRvKSk7XG4gICAgICAgIC8vIEVtcHR5IGxpbmUgaW4gbGlzdFxuICAgICAgICBpZiAoaW5uZXIuaXRlbSAmJiBlbXB0eUxpbmUpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGlubmVyLm5vZGUuZmlyc3RDaGlsZCwgc2Vjb25kID0gaW5uZXIubm9kZS5nZXRDaGlsZChcIkxpc3RJdGVtXCIsIFwiTGlzdEl0ZW1cIik7XG4gICAgICAgICAgICAvLyBOb3Qgc2Vjb25kIGl0ZW0gb3IgYmxhbmsgbGluZSBiZWZvcmU6IGRlbGV0ZSBhIGxldmVsIG9mIG1hcmt1cFxuICAgICAgICAgICAgaWYgKGZpcnN0LnRvID49IHBvcyB8fCBzZWNvbmQgJiYgc2Vjb25kLnRvIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbGluZS5mcm9tID4gMCAmJiAhL1teXFxzPl0vLnRlc3QoZG9jLmxpbmVBdChsaW5lLmZyb20gLSAxKS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29udGV4dC5sZW5ndGggPiAxID8gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZGVsVG8sIGluc2VydCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5pdGVtKSB7IC8vIFJlLWFkZCBtYXJrZXIgZm9yIHRoZSBsaXN0IGF0IHRoZSBuZXh0IGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGRlbFRvID0gbGluZS5mcm9tICsgbmV4dC5mcm9tO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBuZXh0Lm1hcmtlcihkb2MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsVG8gPSBsaW5lLmZyb20gKyAobmV4dCA/IG5leHQudG8gOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBbeyBmcm9tOiBkZWxUbywgdG86IHBvcywgaW5zZXJ0IH1dO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5ub2RlLm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiKVxuICAgICAgICAgICAgICAgICAgICByZW51bWJlckxpc3QoaW5uZXIuaXRlbSwgZG9jLCBjaGFuZ2VzLCAtMik7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5ub2RlLm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiKVxuICAgICAgICAgICAgICAgICAgICByZW51bWJlckxpc3QobmV4dC5pdGVtLCBkb2MsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRlbFRvICsgaW5zZXJ0Lmxlbmd0aCksIGNoYW5nZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBNb3ZlIHNlY29uZCBpdGVtIGRvd24sIG1ha2luZyB0aWdodCB0d28taXRlbSBsaXN0IG5vbi10aWdodFxuICAgICAgICAgICAgICAgIGxldCBpbnNlcnQgPSBibGFua0xpbmUoY29udGV4dCwgc3RhdGUsIGxpbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIGluc2VydC5sZW5ndGggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogaW5zZXJ0ICsgc3RhdGUubGluZUJyZWFrIH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5uZXIubm9kZS5uYW1lID09IFwiQmxvY2txdW90ZVwiICYmIGVtcHR5TGluZSAmJiBsaW5lLmZyb20pIHtcbiAgICAgICAgICAgIGxldCBwcmV2TGluZSA9IGRvYy5saW5lQXQobGluZS5mcm9tIC0gMSksIHF1b3RlZCA9IC8+XFxzKiQvLmV4ZWMocHJldkxpbmUudGV4dCk7XG4gICAgICAgICAgICAvLyBUd28gYWxpZ25lZCBlbXB0eSBxdW90ZWQgbGluZXMgaW4gYSByb3dcbiAgICAgICAgICAgIGlmIChxdW90ZWQgJiYgcXVvdGVkLmluZGV4ID09IGlubmVyLmZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoW3sgZnJvbTogcHJldkxpbmUuZnJvbSArIHF1b3RlZC5pbmRleCwgdG86IHByZXZMaW5lLnRvIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgZnJvbTogbGluZS5mcm9tICsgaW5uZXIuZnJvbSwgdG86IGxpbmUudG8gfV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZS5tYXAoY2hhbmdlcyksIGNoYW5nZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBpZiAoaW5uZXIubm9kZS5uYW1lID09IFwiT3JkZXJlZExpc3RcIilcbiAgICAgICAgICAgIHJlbnVtYmVyTGlzdChpbm5lci5pdGVtLCBkb2MsIGNoYW5nZXMpO1xuICAgICAgICBsZXQgY29udGludWVkID0gaW5uZXIuaXRlbSAmJiBpbm5lci5pdGVtLmZyb20gPCBsaW5lLmZyb207XG4gICAgICAgIGxldCBpbnNlcnQgPSBcIlwiO1xuICAgICAgICAvLyBJZiBub3QgZGVkZW50ZWRcbiAgICAgICAgaWYgKCFjb250aW51ZWQgfHwgL15bXFxzXFxkLilcXC0rKj5dKi8uZXhlYyhsaW5lLnRleHQpWzBdLmxlbmd0aCA+PSBpbm5lci50bykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBjb250ZXh0Lmxlbmd0aCAtIDE7IGkgPD0gZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ICs9IGkgPT0gZSAmJiAhY29udGludWVkID8gY29udGV4dFtpXS5tYXJrZXIoZG9jLCAxKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRleHRbaV0uYmxhbmsoaSA8IGUgPyBjb3VudENvbHVtbihsaW5lLnRleHQsIDQsIGNvbnRleHRbaSArIDFdLmZyb20pIC0gaW5zZXJ0Lmxlbmd0aCA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tID0gcG9zO1xuICAgICAgICB3aGlsZSAoZnJvbSA+IGxpbmUuZnJvbSAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dC5jaGFyQXQoZnJvbSAtIGxpbmUuZnJvbSAtIDEpKSlcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgaW5zZXJ0ID0gbm9ybWFsaXplSW5kZW50KGluc2VydCwgc3RhdGUpO1xuICAgICAgICBpZiAobm9uVGlnaHRMaXN0KGlubmVyLm5vZGUsIHN0YXRlLmRvYykpXG4gICAgICAgICAgICBpbnNlcnQgPSBibGFua0xpbmUoY29udGV4dCwgc3RhdGUsIGxpbmUpICsgc3RhdGUubGluZUJyZWFrICsgaW5zZXJ0O1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tLCB0bzogcG9zLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIGluc2VydCB9KTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSArIGluc2VydC5sZW5ndGggKyAxKSwgY2hhbmdlcyB9O1xuICAgIH0pO1xuICAgIGlmIChkb250KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc01hcmsobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5hbWUgPT0gXCJRdW90ZU1hcmtcIiB8fCBub2RlLm5hbWUgPT0gXCJMaXN0TWFya1wiO1xufVxuZnVuY3Rpb24gbm9uVGlnaHRMaXN0KG5vZGUsIGRvYykge1xuICAgIGlmIChub2RlLm5hbWUgIT0gXCJPcmRlcmVkTGlzdFwiICYmIG5vZGUubmFtZSAhPSBcIkJ1bGxldExpc3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgc2Vjb25kID0gbm9kZS5nZXRDaGlsZChcIkxpc3RJdGVtXCIsIFwiTGlzdEl0ZW1cIik7XG4gICAgaWYgKCFzZWNvbmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbGluZTEgPSBkb2MubGluZUF0KGZpcnN0LnRvKSwgbGluZTIgPSBkb2MubGluZUF0KHNlY29uZC5mcm9tKTtcbiAgICBsZXQgZW1wdHkgPSAvXltcXHM+XSokLy50ZXN0KGxpbmUxLnRleHQpO1xuICAgIHJldHVybiBsaW5lMS5udW1iZXIgKyAoZW1wdHkgPyAwIDogMSkgPCBsaW5lMi5udW1iZXI7XG59XG5mdW5jdGlvbiBibGFua0xpbmUoY29udGV4dCwgc3RhdGUsIGxpbmUpIHtcbiAgICBsZXQgaW5zZXJ0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgZSA9IGNvbnRleHQubGVuZ3RoIC0gMjsgaSA8PSBlOyBpKyspIHtcbiAgICAgICAgaW5zZXJ0ICs9IGNvbnRleHRbaV0uYmxhbmsoaSA8IGUgPyBjb3VudENvbHVtbihsaW5lLnRleHQsIDQsIGNvbnRleHRbaSArIDFdLmZyb20pIC0gaW5zZXJ0Lmxlbmd0aCA6IG51bGwsIGkgPCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUluZGVudChpbnNlcnQsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNvbnRleHROb2RlRm9yRGVsZXRlKHRyZWUsIHBvcykge1xuICAgIGxldCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCAtMSksIHNjYW4gPSBwb3M7XG4gICAgaWYgKGlzTWFyayhub2RlKSkge1xuICAgICAgICBzY2FuID0gbm9kZS5mcm9tO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIGZvciAobGV0IHByZXY7IHByZXYgPSBub2RlLmNoaWxkQmVmb3JlKHNjYW4pOykge1xuICAgICAgICBpZiAoaXNNYXJrKHByZXYpKSB7XG4gICAgICAgICAgICBzY2FuID0gcHJldi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXYubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIgfHwgcHJldi5uYW1lID09IFwiQnVsbGV0TGlzdFwiKSB7XG4gICAgICAgICAgICBub2RlID0gcHJldi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBzY2FuID0gbm9kZS50bztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG5UaGlzIGNvbW1hbmQgd2lsbCwgd2hlbiBpbnZva2VkIGluIGEgTWFya2Rvd24gY29udGV4dCB3aXRoIHRoZVxuY3Vyc29yIGRpcmVjdGx5IGFmdGVyIGxpc3Qgb3IgYmxvY2txdW90ZSBtYXJrdXAsIGRlbGV0ZSBvbmUgbGV2ZWxcbm9mIG1hcmt1cC4gV2hlbiB0aGUgbWFya3VwIGlzIGZvciBhIGxpc3QsIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnlcbnNwYWNlcyBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiAoYSBmdXJ0aGVyIGludm9jYXRpb24gd2lsbCBkZWxldGVcbnRoZSBzcGFjZXMpLCB0byBtYWtlIGl0IGVhc3kgdG8gY29udGludWUgYSBsaXN0LlxuXG5XaGVuIG5vdCBhZnRlciBNYXJrZG93biBibG9jayBtYXJrdXAsIHRoaXMgY29tbWFuZCB3aWxsIHJldHVyblxuZmFsc2UsIHNvIGl0IGlzIGludGVuZGVkIHRvIGJlIGJvdW5kIGFsb25nc2lkZSBvdGhlciBkZWxldGlvblxuY29tbWFuZHMsIHdpdGggYSBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBtb3JlIGdlbmVyaWMgY29tbWFuZHMuXG4qL1xuY29uc3QgZGVsZXRlTWFya3VwQmFja3dhcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSk7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCB7IGRvYyB9ID0gc3RhdGU7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBtYXJrZG93bkxhbmd1YWdlLmlzQWN0aXZlQXQoc3RhdGUsIHJhbmdlLmZyb20pKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gZ2V0Q29udGV4dChjb250ZXh0Tm9kZUZvckRlbGV0ZSh0cmVlLCBwb3MpLCBkb2MpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGlubmVyLnRvIC0gaW5uZXIuc3BhY2VBZnRlci5sZW5ndGggKyAoaW5uZXIuc3BhY2VBZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgZXh0cmEgdHJhaWxpbmcgc3BhY2UgYWZ0ZXIgbWFya3VwXG4gICAgICAgICAgICAgICAgaWYgKHBvcyAtIGxpbmUuZnJvbSA+IHNwYWNlRW5kICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZShzcGFjZUVuZCwgcG9zIC0gbGluZS5mcm9tKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUuZnJvbSArIHNwYWNlRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogbGluZS5mcm9tICsgc3BhY2VFbmQsIHRvOiBwb3MgfSB9O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgLSBsaW5lLmZyb20gPT0gc3BhY2VFbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSB0aGlzIGlmIHdlJ3JlIG9uIHRoZSBsaW5lIHRoYXQgaGFzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3QncyBzeW50YXgsIG9yIHRoZXJlJ3Mgb25seSBpbmRlbnRhdGlvbiBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICghaW5uZXIuaXRlbSB8fCBsaW5lLmZyb20gPD0gaW5uZXIuaXRlbS5mcm9tIHx8ICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBpbm5lci50bykpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBsaW5lLmZyb20gKyBpbm5lci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGEgbGlzdCBpdGVtIG1hcmtlciB3aXRoIGJsYW5rIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5pdGVtICYmIGlubmVyLm5vZGUuZnJvbSA8IGlubmVyLml0ZW0uZnJvbSAmJiAvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZShpbm5lci5mcm9tLCBpbm5lci50bykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gaW5uZXIuYmxhbmsoY291bnRDb2x1bW4obGluZS50ZXh0LCA0LCBpbm5lci50bykgLSBjb3VudENvbHVtbihsaW5lLnRleHQsIDQsIGlubmVyLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gbm9ybWFsaXplSW5kZW50KGluc2VydCwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnQgKyBpbnNlcnQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHN0YXJ0LCB0bzogbGluZS5mcm9tICsgaW5uZXIudG8sIGluc2VydCB9IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG9uZSBsZXZlbCBvZiBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGFydCksIGNoYW5nZXM6IHsgZnJvbTogc3RhcnQsIHRvOiBwb3MgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoZG9udClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG5BIHNtYWxsIGtleW1hcCB3aXRoIE1hcmtkb3duLXNwZWNpZmljIGJpbmRpbmdzLiBCaW5kcyBFbnRlciB0b1xuW2BpbnNlcnROZXdsaW5lQ29udGludWVNYXJrdXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctbWFya2Rvd24uaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwKVxuYW5kIEJhY2tzcGFjZSB0b1xuW2BkZWxldGVNYXJrdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZy1tYXJrZG93bi5kZWxldGVNYXJrdXBCYWNrd2FyZCkuXG4qL1xuY29uc3QgbWFya2Rvd25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBpbnNlcnROZXdsaW5lQ29udGludWVNYXJrdXAgfSxcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVNYXJrdXBCYWNrd2FyZCB9XG5dO1xuY29uc3QgaHRtbE5vTWF0Y2ggPSAvKkBfX1BVUkVfXyovaHRtbCh7IG1hdGNoQ2xvc2luZ1RhZ3M6IGZhbHNlIH0pO1xuLyoqXG5NYXJrZG93biBsYW5ndWFnZSBzdXBwb3J0LlxuKi9cbmZ1bmN0aW9uIG1hcmtkb3duKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IHsgY29kZUxhbmd1YWdlcywgZGVmYXVsdENvZGVMYW5ndWFnZSwgYWRkS2V5bWFwID0gdHJ1ZSwgYmFzZTogeyBwYXJzZXIgfSA9IGNvbW1vbm1hcmtMYW5ndWFnZSwgY29tcGxldGVIVE1MVGFncyA9IHRydWUsIGh0bWxUYWdMYW5ndWFnZSA9IGh0bWxOb01hdGNoIH0gPSBjb25maWc7XG4gICAgaWYgKCEocGFyc2VyIGluc3RhbmNlb2YgTWFya2Rvd25QYXJzZXIpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJhc2UgcGFyc2VyIHByb3ZpZGVkIHRvIGBtYXJrZG93bmAgc2hvdWxkIGJlIGEgTWFya2Rvd24gcGFyc2VyXCIpO1xuICAgIGxldCBleHRlbnNpb25zID0gY29uZmlnLmV4dGVuc2lvbnMgPyBbY29uZmlnLmV4dGVuc2lvbnNdIDogW107XG4gICAgbGV0IHN1cHBvcnQgPSBbaHRtbFRhZ0xhbmd1YWdlLnN1cHBvcnRdLCBkZWZhdWx0Q29kZTtcbiAgICBpZiAoZGVmYXVsdENvZGVMYW5ndWFnZSBpbnN0YW5jZW9mIExhbmd1YWdlU3VwcG9ydCkge1xuICAgICAgICBzdXBwb3J0LnB1c2goZGVmYXVsdENvZGVMYW5ndWFnZS5zdXBwb3J0KTtcbiAgICAgICAgZGVmYXVsdENvZGUgPSBkZWZhdWx0Q29kZUxhbmd1YWdlLmxhbmd1YWdlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWZhdWx0Q29kZUxhbmd1YWdlKSB7XG4gICAgICAgIGRlZmF1bHRDb2RlID0gZGVmYXVsdENvZGVMYW5ndWFnZTtcbiAgICB9XG4gICAgbGV0IGNvZGVQYXJzZXIgPSBjb2RlTGFuZ3VhZ2VzIHx8IGRlZmF1bHRDb2RlID8gZ2V0Q29kZVBhcnNlcihjb2RlTGFuZ3VhZ2VzLCBkZWZhdWx0Q29kZSkgOiB1bmRlZmluZWQ7XG4gICAgZXh0ZW5zaW9ucy5wdXNoKHBhcnNlQ29kZSh7IGNvZGVQYXJzZXIsIGh0bWxQYXJzZXI6IGh0bWxUYWdMYW5ndWFnZS5sYW5ndWFnZS5wYXJzZXIgfSkpO1xuICAgIGlmIChhZGRLZXltYXApXG4gICAgICAgIHN1cHBvcnQucHVzaChQcmVjLmhpZ2goa2V5bWFwLm9mKG1hcmtkb3duS2V5bWFwKSkpO1xuICAgIGxldCBsYW5nID0gbWtMYW5nKHBhcnNlci5jb25maWd1cmUoZXh0ZW5zaW9ucykpO1xuICAgIGlmIChjb21wbGV0ZUhUTUxUYWdzKVxuICAgICAgICBzdXBwb3J0LnB1c2gobGFuZy5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBodG1sVGFnQ29tcGxldGlvbiB9KSk7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQobGFuZywgc3VwcG9ydCk7XG59XG5mdW5jdGlvbiBodG1sVGFnQ29tcGxldGlvbihjb250ZXh0KSB7XG4gICAgbGV0IHsgc3RhdGUsIHBvcyB9ID0gY29udGV4dCwgbSA9IC88WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvLmV4ZWMoc3RhdGUuc2xpY2VEb2MocG9zIC0gMjUsIHBvcykpO1xuICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XG4gICAgd2hpbGUgKHRyZWUgJiYgIXRyZWUudHlwZS5pc1RvcCkge1xuICAgICAgICBpZiAodHJlZS5uYW1lID09IFwiQ29kZUJsb2NrXCIgfHwgdHJlZS5uYW1lID09IFwiRmVuY2VkQ29kZVwiIHx8IHRyZWUubmFtZSA9PSBcIlByb2Nlc3NpbmdJbnN0cnVjdGlvbkJsb2NrXCIgfHxcbiAgICAgICAgICAgIHRyZWUubmFtZSA9PSBcIkNvbW1lbnRCbG9ja1wiIHx8IHRyZWUubmFtZSA9PSBcIkxpbmtcIiB8fCB0cmVlLm5hbWUgPT0gXCJJbWFnZVwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRyZWUgPSB0cmVlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogcG9zIC0gbVswXS5sZW5ndGgsIHRvOiBwb3MsXG4gICAgICAgIG9wdGlvbnM6IGh0bWxUYWdDb21wbGV0aW9ucygpLFxuICAgICAgICB2YWxpZEZvcjogL148WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvXG4gICAgfTtcbn1cbmxldCBfdGFnQ29tcGxldGlvbnMgPSBudWxsO1xuZnVuY3Rpb24gaHRtbFRhZ0NvbXBsZXRpb25zKCkge1xuICAgIGlmIChfdGFnQ29tcGxldGlvbnMpXG4gICAgICAgIHJldHVybiBfdGFnQ29tcGxldGlvbnM7XG4gICAgbGV0IHJlc3VsdCA9IGh0bWxDb21wbGV0aW9uU291cmNlKG5ldyBDb21wbGV0aW9uQ29udGV4dChFZGl0b3JTdGF0ZS5jcmVhdGUoeyBleHRlbnNpb25zOiBodG1sTm9NYXRjaCB9KSwgMCwgdHJ1ZSkpO1xuICAgIHJldHVybiBfdGFnQ29tcGxldGlvbnMgPSByZXN1bHQgPyByZXN1bHQub3B0aW9ucyA6IFtdO1xufVxuXG5leHBvcnQgeyBjb21tb25tYXJrTGFuZ3VhZ2UsIGRlbGV0ZU1hcmt1cEJhY2t3YXJkLCBpbnNlcnROZXdsaW5lQ29udGludWVNYXJrdXAsIG1hcmtkb3duLCBtYXJrZG93bktleW1hcCwgbWFya2Rvd25MYW5ndWFnZSB9O1xuIiwiaW1wb3J0IHsgTm9kZVR5cGUsIE5vZGVQcm9wLCBOb2RlU2V0LCBUcmVlLCBQYXJzZXIsIHBhcnNlTWl4ZWQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncywgVGFnIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbmNsYXNzIENvbXBvc2l0ZUJsb2NrIHtcbiAgICBzdGF0aWMgY3JlYXRlKHR5cGUsIHZhbHVlLCBmcm9tLCBwYXJlbnRIYXNoLCBlbmQpIHtcbiAgICAgICAgbGV0IGhhc2ggPSAocGFyZW50SGFzaCArIChwYXJlbnRIYXNoIDw8IDgpICsgdHlwZSArICh2YWx1ZSA8PCA0KSkgfCAwO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUJsb2NrKHR5cGUsIHZhbHVlLCBmcm9tLCBoYXNoLCBlbmQsIFtdLCBbXSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIFxuICAgIC8vIFVzZWQgZm9yIGluZGVudGF0aW9uIGluIGxpc3QgaXRlbXMsIG1hcmt1cCBjaGFyYWN0ZXIgaW4gbGlzdHNcbiAgICB2YWx1ZSwgZnJvbSwgaGFzaCwgZW5kLCBjaGlsZHJlbiwgcG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuaGFzaFByb3AgPSBbW05vZGVQcm9wLmNvbnRleHRIYXNoLCBoYXNoXV07XG4gICAgfVxuICAgIGFkZENoaWxkKGNoaWxkLCBwb3MpIHtcbiAgICAgICAgaWYgKGNoaWxkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpICE9IHRoaXMuaGFzaClcbiAgICAgICAgICAgIGNoaWxkID0gbmV3IFRyZWUoY2hpbGQudHlwZSwgY2hpbGQuY2hpbGRyZW4sIGNoaWxkLnBvc2l0aW9ucywgY2hpbGQubGVuZ3RoLCB0aGlzLmhhc2hQcm9wKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChwb3MpO1xuICAgIH1cbiAgICB0b1RyZWUobm9kZVNldCwgZW5kID0gdGhpcy5lbmQpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID49IDApXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1heChlbmQsIHRoaXMucG9zaXRpb25zW2xhc3RdICsgdGhpcy5jaGlsZHJlbltsYXN0XS5sZW5ndGggKyB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUobm9kZVNldC50eXBlc1t0aGlzLnR5cGVdLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgZW5kIC0gdGhpcy5mcm9tKS5iYWxhbmNlKHtcbiAgICAgICAgICAgIG1ha2VUcmVlOiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMuaGFzaFByb3ApXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiRG9jdW1lbnRcIl0gPSAxXSA9IFwiRG9jdW1lbnRcIjtcbiAgICBUeXBlW1R5cGVbXCJDb2RlQmxvY2tcIl0gPSAyXSA9IFwiQ29kZUJsb2NrXCI7XG4gICAgVHlwZVtUeXBlW1wiRmVuY2VkQ29kZVwiXSA9IDNdID0gXCJGZW5jZWRDb2RlXCI7XG4gICAgVHlwZVtUeXBlW1wiQmxvY2txdW90ZVwiXSA9IDRdID0gXCJCbG9ja3F1b3RlXCI7XG4gICAgVHlwZVtUeXBlW1wiSG9yaXpvbnRhbFJ1bGVcIl0gPSA1XSA9IFwiSG9yaXpvbnRhbFJ1bGVcIjtcbiAgICBUeXBlW1R5cGVbXCJCdWxsZXRMaXN0XCJdID0gNl0gPSBcIkJ1bGxldExpc3RcIjtcbiAgICBUeXBlW1R5cGVbXCJPcmRlcmVkTGlzdFwiXSA9IDddID0gXCJPcmRlcmVkTGlzdFwiO1xuICAgIFR5cGVbVHlwZVtcIkxpc3RJdGVtXCJdID0gOF0gPSBcIkxpc3RJdGVtXCI7XG4gICAgVHlwZVtUeXBlW1wiQVRYSGVhZGluZzFcIl0gPSA5XSA9IFwiQVRYSGVhZGluZzFcIjtcbiAgICBUeXBlW1R5cGVbXCJBVFhIZWFkaW5nMlwiXSA9IDEwXSA9IFwiQVRYSGVhZGluZzJcIjtcbiAgICBUeXBlW1R5cGVbXCJBVFhIZWFkaW5nM1wiXSA9IDExXSA9IFwiQVRYSGVhZGluZzNcIjtcbiAgICBUeXBlW1R5cGVbXCJBVFhIZWFkaW5nNFwiXSA9IDEyXSA9IFwiQVRYSGVhZGluZzRcIjtcbiAgICBUeXBlW1R5cGVbXCJBVFhIZWFkaW5nNVwiXSA9IDEzXSA9IFwiQVRYSGVhZGluZzVcIjtcbiAgICBUeXBlW1R5cGVbXCJBVFhIZWFkaW5nNlwiXSA9IDE0XSA9IFwiQVRYSGVhZGluZzZcIjtcbiAgICBUeXBlW1R5cGVbXCJTZXRleHRIZWFkaW5nMVwiXSA9IDE1XSA9IFwiU2V0ZXh0SGVhZGluZzFcIjtcbiAgICBUeXBlW1R5cGVbXCJTZXRleHRIZWFkaW5nMlwiXSA9IDE2XSA9IFwiU2V0ZXh0SGVhZGluZzJcIjtcbiAgICBUeXBlW1R5cGVbXCJIVE1MQmxvY2tcIl0gPSAxN10gPSBcIkhUTUxCbG9ja1wiO1xuICAgIFR5cGVbVHlwZVtcIkxpbmtSZWZlcmVuY2VcIl0gPSAxOF0gPSBcIkxpbmtSZWZlcmVuY2VcIjtcbiAgICBUeXBlW1R5cGVbXCJQYXJhZ3JhcGhcIl0gPSAxOV0gPSBcIlBhcmFncmFwaFwiO1xuICAgIFR5cGVbVHlwZVtcIkNvbW1lbnRCbG9ja1wiXSA9IDIwXSA9IFwiQ29tbWVudEJsb2NrXCI7XG4gICAgVHlwZVtUeXBlW1wiUHJvY2Vzc2luZ0luc3RydWN0aW9uQmxvY2tcIl0gPSAyMV0gPSBcIlByb2Nlc3NpbmdJbnN0cnVjdGlvbkJsb2NrXCI7XG4gICAgLy8gSW5saW5lXG4gICAgVHlwZVtUeXBlW1wiRXNjYXBlXCJdID0gMjJdID0gXCJFc2NhcGVcIjtcbiAgICBUeXBlW1R5cGVbXCJFbnRpdHlcIl0gPSAyM10gPSBcIkVudGl0eVwiO1xuICAgIFR5cGVbVHlwZVtcIkhhcmRCcmVha1wiXSA9IDI0XSA9IFwiSGFyZEJyZWFrXCI7XG4gICAgVHlwZVtUeXBlW1wiRW1waGFzaXNcIl0gPSAyNV0gPSBcIkVtcGhhc2lzXCI7XG4gICAgVHlwZVtUeXBlW1wiU3Ryb25nRW1waGFzaXNcIl0gPSAyNl0gPSBcIlN0cm9uZ0VtcGhhc2lzXCI7XG4gICAgVHlwZVtUeXBlW1wiTGlua1wiXSA9IDI3XSA9IFwiTGlua1wiO1xuICAgIFR5cGVbVHlwZVtcIkltYWdlXCJdID0gMjhdID0gXCJJbWFnZVwiO1xuICAgIFR5cGVbVHlwZVtcIklubGluZUNvZGVcIl0gPSAyOV0gPSBcIklubGluZUNvZGVcIjtcbiAgICBUeXBlW1R5cGVbXCJIVE1MVGFnXCJdID0gMzBdID0gXCJIVE1MVGFnXCI7XG4gICAgVHlwZVtUeXBlW1wiQ29tbWVudFwiXSA9IDMxXSA9IFwiQ29tbWVudFwiO1xuICAgIFR5cGVbVHlwZVtcIlByb2Nlc3NpbmdJbnN0cnVjdGlvblwiXSA9IDMyXSA9IFwiUHJvY2Vzc2luZ0luc3RydWN0aW9uXCI7XG4gICAgVHlwZVtUeXBlW1wiQXV0b2xpbmtcIl0gPSAzM10gPSBcIkF1dG9saW5rXCI7XG4gICAgLy8gU21hbGxlciB0b2tlbnNcbiAgICBUeXBlW1R5cGVbXCJIZWFkZXJNYXJrXCJdID0gMzRdID0gXCJIZWFkZXJNYXJrXCI7XG4gICAgVHlwZVtUeXBlW1wiUXVvdGVNYXJrXCJdID0gMzVdID0gXCJRdW90ZU1hcmtcIjtcbiAgICBUeXBlW1R5cGVbXCJMaXN0TWFya1wiXSA9IDM2XSA9IFwiTGlzdE1hcmtcIjtcbiAgICBUeXBlW1R5cGVbXCJMaW5rTWFya1wiXSA9IDM3XSA9IFwiTGlua01hcmtcIjtcbiAgICBUeXBlW1R5cGVbXCJFbXBoYXNpc01hcmtcIl0gPSAzOF0gPSBcIkVtcGhhc2lzTWFya1wiO1xuICAgIFR5cGVbVHlwZVtcIkNvZGVNYXJrXCJdID0gMzldID0gXCJDb2RlTWFya1wiO1xuICAgIFR5cGVbVHlwZVtcIkNvZGVUZXh0XCJdID0gNDBdID0gXCJDb2RlVGV4dFwiO1xuICAgIFR5cGVbVHlwZVtcIkNvZGVJbmZvXCJdID0gNDFdID0gXCJDb2RlSW5mb1wiO1xuICAgIFR5cGVbVHlwZVtcIkxpbmtUaXRsZVwiXSA9IDQyXSA9IFwiTGlua1RpdGxlXCI7XG4gICAgVHlwZVtUeXBlW1wiTGlua0xhYmVsXCJdID0gNDNdID0gXCJMaW5rTGFiZWxcIjtcbiAgICBUeXBlW1R5cGVbXCJVUkxcIl0gPSA0NF0gPSBcIlVSTFwiO1xufSkoVHlwZSB8fCAoVHlwZSA9IHt9KSk7XG4vLy8gRGF0YSBzdHJ1Y3R1cmUgdXNlZCB0byBhY2N1bXVsYXRlIGEgYmxvY2sncyBjb250ZW50IGR1cmluZyBbbGVhZlxuLy8vIGJsb2NrIHBhcnNpbmddKCNCbG9ja1BhcnNlci5sZWFmKS5cbmNsYXNzIExlYWZCbG9jayB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGJsb2NrLlxuICAgIHN0YXJ0LCBcbiAgICAvLy8gVGhlIGJsb2NrJ3MgdGV4dCBjb250ZW50LlxuICAgIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMubWFya3MgPSBbXTtcbiAgICAgICAgLy8vIFRoZSBibG9jayBwYXJzZXJzIGFjdGl2ZSBmb3IgdGhpcyBibG9jay5cbiAgICAgICAgdGhpcy5wYXJzZXJzID0gW107XG4gICAgfVxufVxuLy8vIERhdGEgc3RydWN0dXJlIHVzZWQgZHVyaW5nIGJsb2NrLWxldmVsIHBlci1saW5lIHBhcnNpbmcuXG5jbGFzcyBMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8vIFRoZSBsaW5lJ3MgZnVsbCB0ZXh0LlxuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAvLy8gVGhlIGJhc2UgaW5kZW50IHByb3ZpZGVkIGJ5IHRoZSBjb21wb3NpdGUgY29udGV4dHMgKHRoYXQgaGF2ZVxuICAgICAgICAvLy8gYmVlbiBoYW5kbGVkIHNvIGZhcikuXG4gICAgICAgIHRoaXMuYmFzZUluZGVudCA9IDA7XG4gICAgICAgIC8vLyBUaGUgc3RyaW5nIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGJhc2UgaW5kZW50LlxuICAgICAgICB0aGlzLmJhc2VQb3MgPSAwO1xuICAgICAgICAvLy8gVGhlIG51bWJlciBvZiBjb250ZXh0cyBoYW5kbGVkIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgLy8vIEFueSBtYXJrZXJzIChpLmUuIGJsb2NrIHF1b3RlIG1hcmtlcnMpIHBhcnNlZCBmb3IgdGhlIGNvbnRleHRzLiBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIC8vLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGJleW9uZCBhbnlcbiAgICAgICAgLy8vIGxpc3QsIGJsb2NrcXVvdGUsIG9yIG90aGVyIGNvbXBvc2l0ZSBibG9jayBtYXJrZXJzLlxuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8vLyBUaGUgY29sdW1uIG9mIHRoZSBuZXh0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAvLy8gVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgYHBvc2AuXG4gICAgICAgIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yd2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBvcyA+IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkSW5uZXIoKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcndhcmRJbm5lcigpIHtcbiAgICAgICAgbGV0IG5ld1BvcyA9IHRoaXMuc2tpcFNwYWNlKHRoaXMuYmFzZVBvcyk7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5jb3VudEluZGVudChuZXdQb3MsIHRoaXMucG9zLCB0aGlzLmluZGVudCk7XG4gICAgICAgIHRoaXMucG9zID0gbmV3UG9zO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXdQb3MgPT0gdGhpcy50ZXh0Lmxlbmd0aCA/IC0xIDogdGhpcy50ZXh0LmNoYXJDb2RlQXQobmV3UG9zKTtcbiAgICB9XG4gICAgLy8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciB0aGUgZ2l2ZW4gcG9zaXRpb24sIHJldHVybiB0aGUgcG9zaXRpb24gb2ZcbiAgICAvLy8gdGhlIG5leHQgbm9uLXNwYWNlIGNoYXJhY3RlciBvciB0aGUgZW5kIG9mIHRoZSBsaW5lIGlmIHRoZXJlJ3NcbiAgICAvLy8gb25seSBzcGFjZSBhZnRlciBgZnJvbWAuXG4gICAgc2tpcFNwYWNlKGZyb20pIHsgcmV0dXJuIHNraXBTcGFjZSh0aGlzLnRleHQsIGZyb20pOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc2V0KHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5iYXNlSW5kZW50ID0gdGhpcy5iYXNlUG9zID0gdGhpcy5wb3MgPSB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIHRoaXMuZm9yd2FyZElubmVyKCk7XG4gICAgICAgIHRoaXMuZGVwdGggPSAxO1xuICAgICAgICB3aGlsZSAodGhpcy5tYXJrZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWFya2Vycy5wb3AoKTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIGxpbmUncyBiYXNlIHBvc2l0aW9uIGZvcndhcmQgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSBjb21wb3NpdGUgW2Jsb2NrXG4gICAgLy8vIHBhcnNlcnNdKCNCbG9ja1BhcnNlci5wYXJzZSkgb3IgW21hcmt1cCBza2lwcGluZ1xuICAgIC8vLyBmdW5jdGlvbnNdKCNOb2RlU3BlYy5jb21wb3NpdGUpLlxuICAgIG1vdmVCYXNlKHRvKSB7XG4gICAgICAgIHRoaXMuYmFzZVBvcyA9IHRvO1xuICAgICAgICB0aGlzLmJhc2VJbmRlbnQgPSB0aGlzLmNvdW50SW5kZW50KHRvLCB0aGlzLnBvcywgdGhpcy5pbmRlbnQpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgbGluZSdzIGJhc2UgcG9zaXRpb24gZm9yd2FyZCB0byB0aGUgZ2l2ZW4gX2NvbHVtbl8uXG4gICAgbW92ZUJhc2VDb2x1bW4oaW5kZW50KSB7XG4gICAgICAgIHRoaXMuYmFzZUluZGVudCA9IGluZGVudDtcbiAgICAgICAgdGhpcy5iYXNlUG9zID0gdGhpcy5maW5kQ29sdW1uKGluZGVudCk7XG4gICAgfVxuICAgIC8vLyBTdG9yZSBhIGNvbXBvc2l0ZS1ibG9jay1sZXZlbCBtYXJrZXIuIFNob3VsZCBiZSBjYWxsZWQgZnJvbVxuICAgIC8vLyBbbWFya3VwIHNraXBwaW5nIGZ1bmN0aW9uc10oI05vZGVTcGVjLmNvbXBvc2l0ZSkgd2hlbiB0aGV5XG4gICAgLy8vIGNvbnN1bWUgYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgYWRkTWFya2VyKGVsdCkge1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChlbHQpO1xuICAgIH1cbiAgICAvLy8gRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IGB0b2AsIG9wdGlvbmFsbHkgc3RhcnRpbmcgYXQgYSBnaXZlblxuICAgIC8vLyBwb3NpdGlvbiBhbmQgY29sdW1uLlxuICAgIGNvdW50SW5kZW50KHRvLCBmcm9tID0gMCwgaW5kZW50ID0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgICAgICBpbmRlbnQgKz0gdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSkgPT0gOSA/IDQgLSBpbmRlbnQgJSA0IDogMTtcbiAgICAgICAgcmV0dXJuIGluZGVudDtcbiAgICB9XG4gICAgLy8vIEZpbmQgdGhlIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGNvbHVtbi5cbiAgICBmaW5kQ29sdW1uKGdvYWwpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRlbnQgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBnb2FsOyBpKyspXG4gICAgICAgICAgICBpbmRlbnQgKz0gdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSkgPT0gOSA/IDQgLSBpbmRlbnQgJSA0IDogMTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzY3J1YigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJhc2VJbmRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhc2VQb3M7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHRoaXMudGV4dC5zbGljZSh0aGlzLmJhc2VQb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBGb3JMaXN0KGJsLCBjeCwgbGluZSkge1xuICAgIGlmIChsaW5lLnBvcyA9PSBsaW5lLnRleHQubGVuZ3RoIHx8XG4gICAgICAgIChibCAhPSBjeC5ibG9jayAmJiBsaW5lLmluZGVudCA+PSBjeC5zdGFja1tsaW5lLmRlcHRoICsgMV0udmFsdWUgKyBsaW5lLmJhc2VJbmRlbnQpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGluZS5pbmRlbnQgPj0gbGluZS5iYXNlSW5kZW50ICsgNClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzaXplID0gKGJsLnR5cGUgPT0gVHlwZS5PcmRlcmVkTGlzdCA/IGlzT3JkZXJlZExpc3QgOiBpc0J1bGxldExpc3QpKGxpbmUsIGN4LCBmYWxzZSk7XG4gICAgcmV0dXJuIHNpemUgPiAwICYmXG4gICAgICAgIChibC50eXBlICE9IFR5cGUuQnVsbGV0TGlzdCB8fCBpc0hvcml6b250YWxSdWxlKGxpbmUsIGN4LCBmYWxzZSkgPCAwKSAmJlxuICAgICAgICBsaW5lLnRleHQuY2hhckNvZGVBdChsaW5lLnBvcyArIHNpemUgLSAxKSA9PSBibC52YWx1ZTtcbn1cbmNvbnN0IERlZmF1bHRTa2lwTWFya3VwID0ge1xuICAgIFtUeXBlLkJsb2NrcXVvdGVdKGJsLCBjeCwgbGluZSkge1xuICAgICAgICBpZiAobGluZS5uZXh0ICE9IDYyIC8qICc+JyAqLylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGluZS5tYXJrZXJzLnB1c2goZWx0KFR5cGUuUXVvdGVNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MgKyAxKSk7XG4gICAgICAgIGxpbmUubW92ZUJhc2UobGluZS5wb3MgKyAoc3BhY2UobGluZS50ZXh0LmNoYXJDb2RlQXQobGluZS5wb3MgKyAxKSkgPyAyIDogMSkpO1xuICAgICAgICBibC5lbmQgPSBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFtUeXBlLkxpc3RJdGVtXShibCwgX2N4LCBsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmluZGVudCA8IGxpbmUuYmFzZUluZGVudCArIGJsLnZhbHVlICYmIGxpbmUubmV4dCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsaW5lLm1vdmVCYXNlQ29sdW1uKGxpbmUuYmFzZUluZGVudCArIGJsLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBbVHlwZS5PcmRlcmVkTGlzdF06IHNraXBGb3JMaXN0LFxuICAgIFtUeXBlLkJ1bGxldExpc3RdOiBza2lwRm9yTGlzdCxcbiAgICBbVHlwZS5Eb2N1bWVudF0oKSB7IHJldHVybiB0cnVlOyB9XG59O1xuZnVuY3Rpb24gc3BhY2UoY2gpIHsgcmV0dXJuIGNoID09IDMyIHx8IGNoID09IDkgfHwgY2ggPT0gMTAgfHwgY2ggPT0gMTM7IH1cbmZ1bmN0aW9uIHNraXBTcGFjZShsaW5lLCBpID0gMCkge1xuICAgIHdoaWxlIChpIDwgbGluZS5sZW5ndGggJiYgc3BhY2UobGluZS5jaGFyQ29kZUF0KGkpKSlcbiAgICAgICAgaSsrO1xuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gc2tpcFNwYWNlQmFjayhsaW5lLCBpLCB0bykge1xuICAgIHdoaWxlIChpID4gdG8gJiYgc3BhY2UobGluZS5jaGFyQ29kZUF0KGkgLSAxKSkpXG4gICAgICAgIGktLTtcbiAgICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGlzRmVuY2VkQ29kZShsaW5lKSB7XG4gICAgaWYgKGxpbmUubmV4dCAhPSA5NiAmJiBsaW5lLm5leHQgIT0gMTI2IC8qICdgficgKi8pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MgKyAxO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgPT0gbGluZS5uZXh0KVxuICAgICAgICBwb3MrKztcbiAgICBpZiAocG9zIDwgbGluZS5wb3MgKyAzKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGxpbmUubmV4dCA9PSA5NilcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGxpbmUudGV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChsaW5lLnRleHQuY2hhckNvZGVBdChpKSA9PSA5NilcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIGlzQmxvY2txdW90ZShsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUubmV4dCAhPSA2MiAvKiAnPicgKi8gPyAtMSA6IGxpbmUudGV4dC5jaGFyQ29kZUF0KGxpbmUucG9zICsgMSkgPT0gMzIgPyAyIDogMTtcbn1cbmZ1bmN0aW9uIGlzSG9yaXpvbnRhbFJ1bGUobGluZSwgY3gsIGJyZWFraW5nKSB7XG4gICAgaWYgKGxpbmUubmV4dCAhPSA0MiAmJiBsaW5lLm5leHQgIT0gNDUgJiYgbGluZS5uZXh0ICE9IDk1IC8qICdfLSonICovKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICBmb3IgKGxldCBwb3MgPSBsaW5lLnBvcyArIDE7IHBvcyA8IGxpbmUudGV4dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIGxldCBjaCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjaCA9PSBsaW5lLm5leHQpXG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICBlbHNlIGlmICghc3BhY2UoY2gpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvLyBTZXRleHQgaGVhZGVycyB0YWtlIHByZWNlZGVuY2VcbiAgICBpZiAoYnJlYWtpbmcgJiYgbGluZS5uZXh0ID09IDQ1ICYmIGlzU2V0ZXh0VW5kZXJsaW5lKGxpbmUpID4gLTEgJiYgbGluZS5kZXB0aCA9PSBjeC5zdGFjay5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gY291bnQgPCAzID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gaW5MaXN0KGN4LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IGN4LnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoY3guc3RhY2tbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNCdWxsZXRMaXN0KGxpbmUsIGN4LCBicmVha2luZykge1xuICAgIHJldHVybiAobGluZS5uZXh0ID09IDQ1IHx8IGxpbmUubmV4dCA9PSA0MyB8fCBsaW5lLm5leHQgPT0gNDIgLyogJy0rKicgKi8pICYmXG4gICAgICAgIChsaW5lLnBvcyA9PSBsaW5lLnRleHQubGVuZ3RoIC0gMSB8fCBzcGFjZShsaW5lLnRleHQuY2hhckNvZGVBdChsaW5lLnBvcyArIDEpKSkgJiZcbiAgICAgICAgKCFicmVha2luZyB8fCBpbkxpc3QoY3gsIFR5cGUuQnVsbGV0TGlzdCkgfHwgbGluZS5za2lwU3BhY2UobGluZS5wb3MgKyAyKSA8IGxpbmUudGV4dC5sZW5ndGgpID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gaXNPcmRlcmVkTGlzdChsaW5lLCBjeCwgYnJlYWtpbmcpIHtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MsIG5leHQgPSBsaW5lLm5leHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3IC8qICcwLTknICovKVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocG9zID09IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIG5leHQgPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICBpZiAocG9zID09IGxpbmUucG9zIHx8IHBvcyA+IGxpbmUucG9zICsgOSB8fFxuICAgICAgICAobmV4dCAhPSA0NiAmJiBuZXh0ICE9IDQxIC8qICcuKScgKi8pIHx8XG4gICAgICAgIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoIC0gMSAmJiAhc3BhY2UobGluZS50ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkpKSB8fFxuICAgICAgICBicmVha2luZyAmJiAhaW5MaXN0KGN4LCBUeXBlLk9yZGVyZWRMaXN0KSAmJlxuICAgICAgICAgICAgKGxpbmUuc2tpcFNwYWNlKHBvcyArIDEpID09IGxpbmUudGV4dC5sZW5ndGggfHwgcG9zID4gbGluZS5wb3MgKyAxIHx8IGxpbmUubmV4dCAhPSA0OSAvKiAnMScgKi8pKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHBvcyArIDEgLSBsaW5lLnBvcztcbn1cbmZ1bmN0aW9uIGlzQXR4SGVhZGluZyhsaW5lKSB7XG4gICAgaWYgKGxpbmUubmV4dCAhPSAzNSAvKiAnIycgKi8pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MgKyAxO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgPT0gMzUpXG4gICAgICAgIHBvcysrO1xuICAgIGlmIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgIT0gMzIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgc2l6ZSA9IHBvcyAtIGxpbmUucG9zO1xuICAgIHJldHVybiBzaXplID4gNiA/IC0xIDogc2l6ZTtcbn1cbmZ1bmN0aW9uIGlzU2V0ZXh0VW5kZXJsaW5lKGxpbmUpIHtcbiAgICBpZiAobGluZS5uZXh0ICE9IDQ1ICYmIGxpbmUubmV4dCAhPSA2MSAvKiAnLT0nICovIHx8IGxpbmUuaW5kZW50ID49IGxpbmUuYmFzZUluZGVudCArIDQpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MgKyAxO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgPT0gbGluZS5uZXh0KVxuICAgICAgICBwb3MrKztcbiAgICBsZXQgZW5kID0gcG9zO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIHNwYWNlKGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykpKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zID09IGxpbmUudGV4dC5sZW5ndGggPyBlbmQgOiAtMTtcbn1cbmNvbnN0IEVtcHR5TGluZSA9IC9eWyBcXHRdKiQvLCBDb21tZW50RW5kID0gLy0tPi8sIFByb2Nlc3NpbmdFbmQgPSAvXFw/Pi87XG5jb25zdCBIVE1MQmxvY2tTdHlsZSA9IFtcbiAgICBbL148KD86c2NyaXB0fHByZXxzdHlsZSkoPzpcXHN8PnwkKS9pLCAvPFxcLyg/OnNjcmlwdHxwcmV8c3R5bGUpPi9pXSxcbiAgICBbL15cXHMqPCEtLS8sIENvbW1lbnRFbmRdLFxuICAgIFsvXlxccyo8XFw/LywgUHJvY2Vzc2luZ0VuZF0sXG4gICAgWy9eXFxzKjwhW0EtWl0vLCAvPi9dLFxuICAgIFsvXlxccyo8IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vXSxcbiAgICBbL15cXHMqPFxcLz8oPzphZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbnxjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aDF8aDJ8aDN8aDR8aDV8aDZ8aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb258cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyfHRyYWNrfHVsKSg/Olxcc3xcXC8/PnwkKS9pLCBFbXB0eUxpbmVdLFxuICAgIFsvXlxccyooPzo8XFwvW2Etel1bXFx3LV0qXFxzKj58PFthLXpdW1xcdy1dKihcXHMrW2EtejpfXVtcXHctLl0qKD86XFxzKj1cXHMqKD86W15cXHNcIic9PD5gXSt8J1teJ10qJ3xcIlteXCJdKlwiKSk/KSpcXHMqPilcXHMqJC9pLCBFbXB0eUxpbmVdXG5dO1xuZnVuY3Rpb24gaXNIVE1MQmxvY2sobGluZSwgX2N4LCBicmVha2luZykge1xuICAgIGlmIChsaW5lLm5leHQgIT0gNjAgLyogJzwnICovKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IHJlc3QgPSBsaW5lLnRleHQuc2xpY2UobGluZS5wb3MpO1xuICAgIGZvciAobGV0IGkgPSAwLCBlID0gSFRNTEJsb2NrU3R5bGUubGVuZ3RoIC0gKGJyZWFraW5nID8gMSA6IDApOyBpIDwgZTsgaSsrKVxuICAgICAgICBpZiAoSFRNTEJsb2NrU3R5bGVbaV1bMF0udGVzdChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJbmRlbnQobGluZSwgcG9zKSB7XG4gICAgbGV0IGluZGVudEFmdGVyID0gbGluZS5jb3VudEluZGVudChwb3MsIGxpbmUucG9zLCBsaW5lLmluZGVudCk7XG4gICAgbGV0IGluZGVudGVkID0gbGluZS5jb3VudEluZGVudChsaW5lLnNraXBTcGFjZShwb3MpLCBwb3MsIGluZGVudEFmdGVyKTtcbiAgICByZXR1cm4gaW5kZW50ZWQgPj0gaW5kZW50QWZ0ZXIgKyA1ID8gaW5kZW50QWZ0ZXIgKyAxIDogaW5kZW50ZWQ7XG59XG5mdW5jdGlvbiBhZGRDb2RlVGV4dChtYXJrcywgZnJvbSwgdG8pIHtcbiAgICBsZXQgbGFzdCA9IG1hcmtzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBtYXJrc1tsYXN0XS50byA9PSBmcm9tICYmIG1hcmtzW2xhc3RdLnR5cGUgPT0gVHlwZS5Db2RlVGV4dClcbiAgICAgICAgbWFya3NbbGFzdF0udG8gPSB0bztcbiAgICBlbHNlXG4gICAgICAgIG1hcmtzLnB1c2goZWx0KFR5cGUuQ29kZVRleHQsIGZyb20sIHRvKSk7XG59XG4vLyBSdWxlcyBmb3IgcGFyc2luZyBibG9ja3MuIEEgcmV0dXJuIHZhbHVlIG9mIGZhbHNlIG1lYW5zIHRoZSBydWxlXG4vLyBkb2Vzbid0IGFwcGx5IGhlcmUsIHRydWUgbWVhbnMgaXQgZG9lcy4gV2hlbiB0cnVlIGlzIHJldHVybmVkIGFuZFxuLy8gYHAubGluZWAgaGFzIGJlZW4gdXBkYXRlZCwgdGhlIHJ1bGUgaXMgYXNzdW1lZCB0byBoYXZlIGNvbnN1bWVkIGFcbi8vIGxlYWYgYmxvY2suIE90aGVyd2lzZSwgaXQgaXMgYXNzdW1lZCB0byBoYXZlIG9wZW5lZCBhIGNvbnRleHQuXG5jb25zdCBEZWZhdWx0QmxvY2tQYXJzZXJzID0ge1xuICAgIExpbmtSZWZlcmVuY2U6IHVuZGVmaW5lZCxcbiAgICBJbmRlbnRlZENvZGUoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBsaW5lLmJhc2VJbmRlbnQgKyA0O1xuICAgICAgICBpZiAobGluZS5pbmRlbnQgPCBiYXNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSBsaW5lLmZpbmRDb2x1bW4oYmFzZSk7XG4gICAgICAgIGxldCBmcm9tID0gY3gubGluZVN0YXJ0ICsgc3RhcnQsIHRvID0gY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IG1hcmtzID0gW10sIHBlbmRpbmdNYXJrcyA9IFtdO1xuICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgZnJvbSwgdG8pO1xuICAgICAgICB3aGlsZSAoY3gubmV4dExpbmUoKSAmJiBsaW5lLmRlcHRoID49IGN4LnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxpbmUucG9zID09IGxpbmUudGV4dC5sZW5ndGgpIHsgLy8gRW1wdHlcbiAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChwZW5kaW5nTWFya3MsIGN4LmxpbmVTdGFydCAtIDEsIGN4LmxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbSBvZiBsaW5lLm1hcmtlcnMpXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdNYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5pbmRlbnQgPCBiYXNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ01hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBtIG9mIHBlbmRpbmdNYXJrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0udHlwZSA9PSBUeXBlLkNvZGVUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBtLmZyb20sIG0udG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gobSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01hcmtzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBjeC5saW5lU3RhcnQgLSAxLCBjeC5saW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIHRvID0gY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZVN0YXJ0ID0gY3gubGluZVN0YXJ0ICsgbGluZS5maW5kQ29sdW1uKGxpbmUuYmFzZUluZGVudCArIDQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlU3RhcnQgPCB0bylcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29kZVRleHQobWFya3MsIGNvZGVTdGFydCwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwZW5kaW5nTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBwZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3MuZmlsdGVyKG0gPT4gbS50eXBlICE9IFR5cGUuQ29kZVRleHQpO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdNYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGluZS5tYXJrZXJzID0gcGVuZGluZ01hcmtzLmNvbmNhdChsaW5lLm1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGN4LmFkZE5vZGUoY3guYnVmZmVyLndyaXRlRWxlbWVudHMobWFya3MsIC1mcm9tKS5maW5pc2goVHlwZS5Db2RlQmxvY2ssIHRvIC0gZnJvbSksIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIEZlbmNlZENvZGUoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IGZlbmNlRW5kID0gaXNGZW5jZWRDb2RlKGxpbmUpO1xuICAgICAgICBpZiAoZmVuY2VFbmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZnJvbSA9IGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjaCA9IGxpbmUubmV4dCwgbGVuID0gZmVuY2VFbmQgLSBsaW5lLnBvcztcbiAgICAgICAgbGV0IGluZm9Gcm9tID0gbGluZS5za2lwU3BhY2UoZmVuY2VFbmQpLCBpbmZvVG8gPSBza2lwU3BhY2VCYWNrKGxpbmUudGV4dCwgbGluZS50ZXh0Lmxlbmd0aCwgaW5mb0Zyb20pO1xuICAgICAgICBsZXQgbWFya3MgPSBbZWx0KFR5cGUuQ29kZU1hcmssIGZyb20sIGZyb20gKyBsZW4pXTtcbiAgICAgICAgaWYgKGluZm9Gcm9tIDwgaW5mb1RvKVxuICAgICAgICAgICAgbWFya3MucHVzaChlbHQoVHlwZS5Db2RlSW5mbywgY3gubGluZVN0YXJ0ICsgaW5mb0Zyb20sIGN4LmxpbmVTdGFydCArIGluZm9UbykpO1xuICAgICAgICBmb3IgKGxldCBmaXJzdCA9IHRydWU7IGN4Lm5leHRMaW5lKCkgJiYgbGluZS5kZXB0aCA+PSBjeC5zdGFjay5sZW5ndGg7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxldCBpID0gbGluZS5wb3M7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRlbnQgLSBsaW5lLmJhc2VJbmRlbnQgPCA0KVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBsaW5lLnRleHQuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgLSBsaW5lLnBvcyA+PSBsZW4gJiYgbGluZS5za2lwU3BhY2UoaSkgPT0gbGluZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goZWx0KFR5cGUuQ29kZU1hcmssIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBpKSk7XG4gICAgICAgICAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBjeC5saW5lU3RhcnQgLSAxLCBjeC5saW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0U3RhcnQgPSBjeC5saW5lU3RhcnQgKyBsaW5lLmJhc2VQb3MsIHRleHRFbmQgPSBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPCB0ZXh0RW5kKVxuICAgICAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgdGV4dFN0YXJ0LCB0ZXh0RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjeC5hZGROb2RlKGN4LmJ1ZmZlci53cml0ZUVsZW1lbnRzKG1hcmtzLCAtZnJvbSlcbiAgICAgICAgICAgIC5maW5pc2goVHlwZS5GZW5jZWRDb2RlLCBjeC5wcmV2TGluZUVuZCgpIC0gZnJvbSksIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIEJsb2NrcXVvdGUoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHNpemUgPSBpc0Jsb2NrcXVvdGUobGluZSk7XG4gICAgICAgIGlmIChzaXplIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuQmxvY2txdW90ZSwgbGluZS5wb3MpO1xuICAgICAgICBjeC5hZGROb2RlKFR5cGUuUXVvdGVNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MgKyAxKTtcbiAgICAgICAgbGluZS5tb3ZlQmFzZShsaW5lLnBvcyArIHNpemUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIEhvcml6b250YWxSdWxlKGN4LCBsaW5lKSB7XG4gICAgICAgIGlmIChpc0hvcml6b250YWxSdWxlKGxpbmUsIGN4LCBmYWxzZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZnJvbSA9IGN4LmxpbmVTdGFydCArIGxpbmUucG9zO1xuICAgICAgICBjeC5uZXh0TGluZSgpO1xuICAgICAgICBjeC5hZGROb2RlKFR5cGUuSG9yaXpvbnRhbFJ1bGUsIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIEJ1bGxldExpc3QoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHNpemUgPSBpc0J1bGxldExpc3QobGluZSwgY3gsIGZhbHNlKTtcbiAgICAgICAgaWYgKHNpemUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3guYmxvY2sudHlwZSAhPSBUeXBlLkJ1bGxldExpc3QpXG4gICAgICAgICAgICBjeC5zdGFydENvbnRleHQoVHlwZS5CdWxsZXRMaXN0LCBsaW5lLmJhc2VQb3MsIGxpbmUubmV4dCk7XG4gICAgICAgIGxldCBuZXdCYXNlID0gZ2V0TGlzdEluZGVudChsaW5lLCBsaW5lLnBvcyArIDEpO1xuICAgICAgICBjeC5zdGFydENvbnRleHQoVHlwZS5MaXN0SXRlbSwgbGluZS5iYXNlUG9zLCBuZXdCYXNlIC0gbGluZS5iYXNlSW5kZW50KTtcbiAgICAgICAgY3guYWRkTm9kZShUeXBlLkxpc3RNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MgKyBzaXplKTtcbiAgICAgICAgbGluZS5tb3ZlQmFzZUNvbHVtbihuZXdCYXNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBPcmRlcmVkTGlzdChjeCwgbGluZSkge1xuICAgICAgICBsZXQgc2l6ZSA9IGlzT3JkZXJlZExpc3QobGluZSwgY3gsIGZhbHNlKTtcbiAgICAgICAgaWYgKHNpemUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3guYmxvY2sudHlwZSAhPSBUeXBlLk9yZGVyZWRMaXN0KVxuICAgICAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuT3JkZXJlZExpc3QsIGxpbmUuYmFzZVBvcywgbGluZS50ZXh0LmNoYXJDb2RlQXQobGluZS5wb3MgKyBzaXplIC0gMSkpO1xuICAgICAgICBsZXQgbmV3QmFzZSA9IGdldExpc3RJbmRlbnQobGluZSwgbGluZS5wb3MgKyBzaXplKTtcbiAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuTGlzdEl0ZW0sIGxpbmUuYmFzZVBvcywgbmV3QmFzZSAtIGxpbmUuYmFzZUluZGVudCk7XG4gICAgICAgIGN4LmFkZE5vZGUoVHlwZS5MaXN0TWFyaywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zICsgc2l6ZSk7XG4gICAgICAgIGxpbmUubW92ZUJhc2VDb2x1bW4obmV3QmFzZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgQVRYSGVhZGluZyhjeCwgbGluZSkge1xuICAgICAgICBsZXQgc2l6ZSA9IGlzQXR4SGVhZGluZyhsaW5lKTtcbiAgICAgICAgaWYgKHNpemUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb2ZmID0gbGluZS5wb3MsIGZyb20gPSBjeC5saW5lU3RhcnQgKyBvZmY7XG4gICAgICAgIGxldCBlbmRPZlNwYWNlID0gc2tpcFNwYWNlQmFjayhsaW5lLnRleHQsIGxpbmUudGV4dC5sZW5ndGgsIG9mZiksIGFmdGVyID0gZW5kT2ZTcGFjZTtcbiAgICAgICAgd2hpbGUgKGFmdGVyID4gb2ZmICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KGFmdGVyIC0gMSkgPT0gbGluZS5uZXh0KVxuICAgICAgICAgICAgYWZ0ZXItLTtcbiAgICAgICAgaWYgKGFmdGVyID09IGVuZE9mU3BhY2UgfHwgYWZ0ZXIgPT0gb2ZmIHx8ICFzcGFjZShsaW5lLnRleHQuY2hhckNvZGVBdChhZnRlciAtIDEpKSlcbiAgICAgICAgICAgIGFmdGVyID0gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1ZiA9IGN4LmJ1ZmZlclxuICAgICAgICAgICAgLndyaXRlKFR5cGUuSGVhZGVyTWFyaywgMCwgc2l6ZSlcbiAgICAgICAgICAgIC53cml0ZUVsZW1lbnRzKGN4LnBhcnNlci5wYXJzZUlubGluZShsaW5lLnRleHQuc2xpY2Uob2ZmICsgc2l6ZSArIDEsIGFmdGVyKSwgZnJvbSArIHNpemUgKyAxKSwgLWZyb20pO1xuICAgICAgICBpZiAoYWZ0ZXIgPCBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgYnVmLndyaXRlKFR5cGUuSGVhZGVyTWFyaywgYWZ0ZXIgLSBvZmYsIGVuZE9mU3BhY2UgLSBvZmYpO1xuICAgICAgICBsZXQgbm9kZSA9IGJ1Zi5maW5pc2goVHlwZS5BVFhIZWFkaW5nMSAtIDEgKyBzaXplLCBsaW5lLnRleHQubGVuZ3RoIC0gb2ZmKTtcbiAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgY3guYWRkTm9kZShub2RlLCBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBIVE1MQmxvY2soY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBpc0hUTUxCbG9jayhsaW5lLCBjeCwgZmFsc2UpO1xuICAgICAgICBpZiAodHlwZSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBmcm9tID0gY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGVuZCA9IEhUTUxCbG9ja1N0eWxlW3R5cGVdWzFdO1xuICAgICAgICBsZXQgbWFya3MgPSBbXSwgdHJhaWxpbmcgPSBlbmQgIT0gRW1wdHlMaW5lO1xuICAgICAgICB3aGlsZSAoIWVuZC50ZXN0KGxpbmUudGV4dCkgJiYgY3gubmV4dExpbmUoKSkge1xuICAgICAgICAgICAgaWYgKGxpbmUuZGVwdGggPCBjeC5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgbSBvZiBsaW5lLm1hcmtlcnMpXG4gICAgICAgICAgICAgICAgbWFya3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhaWxpbmcpXG4gICAgICAgICAgICBjeC5uZXh0TGluZSgpO1xuICAgICAgICBsZXQgbm9kZVR5cGUgPSBlbmQgPT0gQ29tbWVudEVuZCA/IFR5cGUuQ29tbWVudEJsb2NrIDogZW5kID09IFByb2Nlc3NpbmdFbmQgPyBUeXBlLlByb2Nlc3NpbmdJbnN0cnVjdGlvbkJsb2NrIDogVHlwZS5IVE1MQmxvY2s7XG4gICAgICAgIGxldCB0byA9IGN4LnByZXZMaW5lRW5kKCk7XG4gICAgICAgIGN4LmFkZE5vZGUoY3guYnVmZmVyLndyaXRlRWxlbWVudHMobWFya3MsIC1mcm9tKS5maW5pc2gobm9kZVR5cGUsIHRvIC0gZnJvbSksIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFNldGV4dEhlYWRpbmc6IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgcmVsYXRpdmUgcHJlY2VkZW5jZSBmb3IgYmxvY2stY29udGludWUgZnVuY3Rpb25cbn07XG4vLyBUaGlzIGltcGxlbWVudHMgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaW5jcmVtZW50YWxseSBwYXJzZXMgbGluayByZWZlcmVuY2VzLiBBdCBlYWNoXG4vLyBuZXh0IGxpbmUsIGl0IGxvb2tzIGFoZWFkIHRvIHNlZSBpZiB0aGUgbGluZSBjb250aW51ZXMgdGhlIHJlZmVyZW5jZSBvciBub3QuIElmIGl0XG4vLyBkb2Vzbid0IGFuZCBhIHZhbGlkIGxpbmsgaXMgYXZhaWxhYmxlIGVuZGluZyBiZWZvcmUgdGhhdCBsaW5lLCBpdCBmaW5pc2hlcyB0aGF0LlxuLy8gU2ltaWxhcmx5LCBvbiBgZmluaXNoYCAod2hlbiB0aGUgbGVhZiBpcyB0ZXJtaW5hdGVkIGJ5IGV4dGVybmFsIGNpcmN1bXN0YW5jZXMpLCBpdFxuLy8gY3JlYXRlcyBhIGxpbmsgcmVmZXJlbmNlIGlmIHRoZXJlJ3MgYSB2YWxpZCByZWZlcmVuY2UgdXAgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG5jbGFzcyBMaW5rUmVmZXJlbmNlUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihsZWFmKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSAwIC8qIFJlZlN0YWdlLlN0YXJ0ICovO1xuICAgICAgICB0aGlzLmVsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbGVhZi5zdGFydDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKGxlYWYuY29udGVudCk7XG4gICAgfVxuICAgIG5leHRMaW5lKGN4LCBsaW5lLCBsZWFmKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWdlID09IC0xIC8qIFJlZlN0YWdlLkZhaWxlZCAqLylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBsZWFmLmNvbnRlbnQgKyBcIlxcblwiICsgbGluZS5zY3J1YigpO1xuICAgICAgICBsZXQgZmluaXNoID0gdGhpcy5hZHZhbmNlKGNvbnRlbnQpO1xuICAgICAgICBpZiAoZmluaXNoID4gLTEgJiYgZmluaXNoIDwgY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShjeCwgbGVhZiwgZmluaXNoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmaW5pc2goY3gsIGxlYWYpIHtcbiAgICAgICAgaWYgKCh0aGlzLnN0YWdlID09IDIgLyogUmVmU3RhZ2UuTGluayAqLyB8fCB0aGlzLnN0YWdlID09IDMgLyogUmVmU3RhZ2UuVGl0bGUgKi8pICYmIHNraXBTcGFjZShsZWFmLmNvbnRlbnQsIHRoaXMucG9zKSA9PSBsZWFmLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUoY3gsIGxlYWYsIGxlYWYuY29udGVudC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbXBsZXRlKGN4LCBsZWFmLCBsZW4pIHtcbiAgICAgICAgY3guYWRkTGVhZkVsZW1lbnQobGVhZiwgZWx0KFR5cGUuTGlua1JlZmVyZW5jZSwgdGhpcy5zdGFydCwgdGhpcy5zdGFydCArIGxlbiwgdGhpcy5lbHRzKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBuZXh0U3RhZ2UoZWx0KSB7XG4gICAgICAgIGlmIChlbHQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZWx0LnRvIC0gdGhpcy5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuZWx0cy5wdXNoKGVsdCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlKys7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UgPSAtMSAvKiBSZWZTdGFnZS5GYWlsZWQgKi87XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWR2YW5jZShjb250ZW50KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWdlID09IC0xIC8qIFJlZlN0YWdlLkZhaWxlZCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhZ2UgPT0gMCAvKiBSZWZTdGFnZS5TdGFydCAqLykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZXh0U3RhZ2UocGFyc2VMaW5rTGFiZWwoY29udGVudCwgdGhpcy5wb3MsIHRoaXMuc3RhcnQsIHRydWUpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmNoYXJDb2RlQXQodGhpcy5wb3MpICE9IDU4IC8qICc6JyAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UgPSAtMSAvKiBSZWZTdGFnZS5GYWlsZWQgKi87XG4gICAgICAgICAgICAgICAgdGhpcy5lbHRzLnB1c2goZWx0KFR5cGUuTGlua01hcmssIHRoaXMucG9zICsgdGhpcy5zdGFydCwgdGhpcy5wb3MgKyB0aGlzLnN0YXJ0ICsgMSkpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YWdlID09IDEgLyogUmVmU3RhZ2UuTGFiZWwgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmV4dFN0YWdlKHBhcnNlVVJMKGNvbnRlbnQsIHNraXBTcGFjZShjb250ZW50LCB0aGlzLnBvcyksIHRoaXMuc3RhcnQpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFnZSA9PSAyIC8qIFJlZlN0YWdlLkxpbmsgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc2tpcCA9IHNraXBTcGFjZShjb250ZW50LCB0aGlzLnBvcyksIGVuZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiB0aGlzLnBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBwYXJzZUxpbmtUaXRsZShjb250ZW50LCBza2lwLCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGVFbmQgPSBsaW5lRW5kKGNvbnRlbnQsIHRpdGxlLnRvIC0gdGhpcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGl0bGVFbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhZ2UodGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRpdGxlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW5kKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBsaW5lRW5kKGNvbnRlbnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kID4gMCAmJiBlbmQgPCBjb250ZW50Lmxlbmd0aCA/IGVuZCA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIFJlZlN0YWdlLlRpdGxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVFbmQoY29udGVudCwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbGluZUVuZCh0ZXh0LCBwb3MpIHtcbiAgICBmb3IgKDsgcG9zIDwgdGV4dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChuZXh0ID09IDEwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICghc3BhY2UobmV4dCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5jbGFzcyBTZXRleHRIZWFkaW5nUGFyc2VyIHtcbiAgICBuZXh0TGluZShjeCwgbGluZSwgbGVhZikge1xuICAgICAgICBsZXQgdW5kZXJsaW5lID0gbGluZS5kZXB0aCA8IGN4LnN0YWNrLmxlbmd0aCA/IC0xIDogaXNTZXRleHRVbmRlcmxpbmUobGluZSk7XG4gICAgICAgIGxldCBuZXh0ID0gbGluZS5uZXh0O1xuICAgICAgICBpZiAodW5kZXJsaW5lIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHVuZGVybGluZU1hcmsgPSBlbHQoVHlwZS5IZWFkZXJNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgdW5kZXJsaW5lKTtcbiAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgY3guYWRkTGVhZkVsZW1lbnQobGVhZiwgZWx0KG5leHQgPT0gNjEgPyBUeXBlLlNldGV4dEhlYWRpbmcxIDogVHlwZS5TZXRleHRIZWFkaW5nMiwgbGVhZi5zdGFydCwgY3gucHJldkxpbmVFbmQoKSwgW1xuICAgICAgICAgICAgLi4uY3gucGFyc2VyLnBhcnNlSW5saW5lKGxlYWYuY29udGVudCwgbGVhZi5zdGFydCksXG4gICAgICAgICAgICB1bmRlcmxpbmVNYXJrXG4gICAgICAgIF0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IERlZmF1bHRMZWFmQmxvY2tzID0ge1xuICAgIExpbmtSZWZlcmVuY2UoXywgbGVhZikgeyByZXR1cm4gbGVhZi5jb250ZW50LmNoYXJDb2RlQXQoMCkgPT0gOTEgLyogJ1snICovID8gbmV3IExpbmtSZWZlcmVuY2VQYXJzZXIobGVhZikgOiBudWxsOyB9LFxuICAgIFNldGV4dEhlYWRpbmcoKSB7IHJldHVybiBuZXcgU2V0ZXh0SGVhZGluZ1BhcnNlcjsgfVxufTtcbmNvbnN0IERlZmF1bHRFbmRMZWFmID0gW1xuICAgIChfLCBsaW5lKSA9PiBpc0F0eEhlYWRpbmcobGluZSkgPj0gMCxcbiAgICAoXywgbGluZSkgPT4gaXNGZW5jZWRDb2RlKGxpbmUpID49IDAsXG4gICAgKF8sIGxpbmUpID0+IGlzQmxvY2txdW90ZShsaW5lKSA+PSAwLFxuICAgIChwLCBsaW5lKSA9PiBpc0J1bGxldExpc3QobGluZSwgcCwgdHJ1ZSkgPj0gMCxcbiAgICAocCwgbGluZSkgPT4gaXNPcmRlcmVkTGlzdChsaW5lLCBwLCB0cnVlKSA+PSAwLFxuICAgIChwLCBsaW5lKSA9PiBpc0hvcml6b250YWxSdWxlKGxpbmUsIHAsIHRydWUpID49IDAsXG4gICAgKHAsIGxpbmUpID0+IGlzSFRNTEJsb2NrKGxpbmUsIHAsIHRydWUpID49IDBcbl07XG5jb25zdCBzY2FuTGluZVJlc3VsdCA9IHsgdGV4dDogXCJcIiwgZW5kOiAwIH07XG4vLy8gQmxvY2stbGV2ZWwgcGFyc2luZyBmdW5jdGlvbnMgZ2V0IGFjY2VzcyB0byB0aGlzIGNvbnRleHQgb2JqZWN0LlxuY2xhc3MgQmxvY2tDb250ZXh0IHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBwYXJzZXIgY29uZmlndXJhdGlvbiB1c2VkLlxuICAgIHBhcnNlciwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGlucHV0LCBmcmFnbWVudHMsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICAgIHRoaXMuYXRFbmQgPSBmYWxzZTtcbiAgICAgICAgLy8vIEZvciByZXVzZWQgbm9kZXMgb24gZ2Fwcywgd2UgY2FuJ3QgZGlyZWN0bHkgcHV0IHRoZSBvcmlnaW5hbFxuICAgICAgICAvLy8gbm9kZSBpbnRvIHRoZSB0cmVlLCBzaW5jZSB0aGF0IG1heSBiZSBiaXR0ZXIgdGhhbiBpdHMgcGFyZW50LlxuICAgICAgICAvLy8gV2hlbiB0aGlzIGhhcHBlbnMsIHdlIGNyZWF0ZSBhIGR1bW15IHRyZWUgdGhhdCBpcyByZXBsYWNlZCBieVxuICAgICAgICAvLy8gdGhlIHByb3BlciBub2RlIGluIGBpbmplY3RHYXBzYCBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5yZXVzZVBsYWNlaG9sZGVycyA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgLy8vIFRoZSByYW5nZSBpbmRleCB0aGF0IGFic29sdXRlTGluZVN0YXJ0IHBvaW50cyBpbnRvIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnJhbmdlSSA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPSB0aGlzLmFic29sdXRlTGluZUVuZCA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICB0aGlzLmJsb2NrID0gQ29tcG9zaXRlQmxvY2suY3JlYXRlKFR5cGUuRG9jdW1lbnQsIDAsIHRoaXMubGluZVN0YXJ0LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFt0aGlzLmJsb2NrXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cywgaW5wdXQpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkTGluZSgpO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZUxpbmVTdGFydDtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA+IHRoaXMuc3RvcHBlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGxldCB7IGxpbmUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtJID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBsaW5lLmRlcHRoIDwgdGhpcy5zdGFjay5sZW5ndGggPyB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtYXJrSSA8IGxpbmUubWFya2Vycy5sZW5ndGggJiYgKCFuZXh0IHx8IGxpbmUubWFya2Vyc1ttYXJrSV0uZnJvbSA8IG5leHQuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGxpbmUubWFya2Vyc1ttYXJrSSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGROb2RlKG1hcmsudHlwZSwgbWFyay5mcm9tLCBtYXJrLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaENvbnRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lLnBvcyA8IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBFbXB0eSBsaW5lXG4gICAgICAgICAgICBpZiAoIXRoaXMubmV4dExpbmUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMgJiYgdGhpcy5yZXVzZUZyYWdtZW50KGxpbmUuYmFzZVBvcykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc3RhcnQ6IGZvciAoOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy5wYXJzZXIuYmxvY2tQYXJzZXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0eXBlKHRoaXMsIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLmZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlYWYgPSBuZXcgTGVhZkJsb2NrKHRoaXMubGluZVN0YXJ0ICsgbGluZS5wb3MsIGxpbmUudGV4dC5zbGljZShsaW5lLnBvcykpO1xuICAgICAgICBmb3IgKGxldCBwYXJzZSBvZiB0aGlzLnBhcnNlci5sZWFmQmxvY2tQYXJzZXJzKVxuICAgICAgICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHBhcnNlKHRoaXMsIGxlYWYpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIpXG4gICAgICAgICAgICAgICAgICAgIGxlYWYucGFyc2Vycy5wdXNoKHBhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxpbmVzOiB3aGlsZSAodGhpcy5uZXh0TGluZSgpKSB7XG4gICAgICAgICAgICBpZiAobGluZS5wb3MgPT0gbGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGVudCA8IGxpbmUuYmFzZUluZGVudCArIDQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdG9wIG9mIHRoaXMucGFyc2VyLmVuZExlYWZCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AodGhpcywgbGluZSwgbGVhZikpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsaW5lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnNlciBvZiBsZWFmLnBhcnNlcnMpXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5uZXh0TGluZSh0aGlzLCBsaW5lLCBsZWFmKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZWFmLmNvbnRlbnQgKz0gXCJcXG5cIiArIGxpbmUuc2NydWIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgIGxlYWYubWFya3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaExlYWYobGVhZik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgcmV1c2VGcmFnbWVudChzdGFydCkge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnRzLm1vdmVUbyh0aGlzLmFic29sdXRlTGluZVN0YXJ0ICsgc3RhcnQsIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQpIHx8XG4gICAgICAgICAgICAhdGhpcy5mcmFnbWVudHMubWF0Y2hlcyh0aGlzLmJsb2NrLmhhc2gpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdGFrZW4gPSB0aGlzLmZyYWdtZW50cy50YWtlTm9kZXModGhpcyk7XG4gICAgICAgIGlmICghdGFrZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgKz0gdGFrZW47XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdG9SZWxhdGl2ZSh0aGlzLmFic29sdXRlTGluZVN0YXJ0LCB0aGlzLnJhbmdlcyk7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSSgpO1xuICAgICAgICBpZiAodGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVhZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIFRoZSBudW1iZXIgb2YgcGFyZW50IGJsb2NrcyBzdXJyb3VuZGluZyB0aGUgY3VycmVudCBibG9jay5cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdHlwZSBvZiB0aGUgcGFyZW50IGJsb2NrIGF0IHRoZSBnaXZlbiBkZXB0aC4gV2hlbiBub1xuICAgIC8vLyBkZXB0aCBpcyBwYXNzZWQsIHJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5uZXJtb3N0IHBhcmVudC5cbiAgICBwYXJlbnRUeXBlKGRlcHRoID0gdGhpcy5kZXB0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbdGhpcy5zdGFja1tkZXB0aF0udHlwZV07XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IGlucHV0IGxpbmUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5XG4gICAgLy8vIChub24tY29tcG9zaXRlKSBbYmxvY2sgcGFyc2Vyc10oI0Jsb2NrUGFyc2VyLnBhcnNlKSB0aGF0IGNvbnN1bWVcbiAgICAvLy8gdGhlIGxpbmUgZGlyZWN0bHksIG9yIGxlYWYgYmxvY2sgcGFyc2VyXG4gICAgLy8vIFtgbmV4dExpbmVgXSgjTGVhZkJsb2NrUGFyc2VyLm5leHRMaW5lKSBtZXRob2RzIHdoZW4gdGhleVxuICAgIC8vLyBjb25zdW1lIHRoZSBjdXJyZW50IGxpbmUgKGFuZCByZXR1cm4gdHJ1ZSkuXG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ICs9IHRoaXMubGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuYWJzb2x1dGVMaW5lRW5kID49IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPSB0aGlzLmFic29sdXRlTGluZUVuZDtcbiAgICAgICAgICAgIHRoaXMuYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWFkTGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQrKztcbiAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPSB0aGlzLmFic29sdXRlTGluZUVuZCArIDE7XG4gICAgICAgICAgICB0aGlzLm1vdmVSYW5nZUkoKTtcbiAgICAgICAgICAgIHRoaXMucmVhZExpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVSYW5nZUkoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlSSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEgJiYgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA+PSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSV0udG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJKys7XG4gICAgICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0ID0gTWF0aC5tYXgodGhpcy5hYnNvbHV0ZUxpbmVTdGFydCwgdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUldLmZyb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzY2FuTGluZShzdGFydCkge1xuICAgICAgICBsZXQgciA9IHNjYW5MaW5lUmVzdWx0O1xuICAgICAgICByLmVuZCA9IHN0YXJ0O1xuICAgICAgICBpZiAoc3RhcnQgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgci50ZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIudGV4dCA9IHRoaXMubGluZUNodW5rQXQoc3RhcnQpO1xuICAgICAgICAgICAgci5lbmQgKz0gci50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRPZmZzZXQgPSB0aGlzLmFic29sdXRlTGluZVN0YXJ0LCByYW5nZUkgPSB0aGlzLnJhbmdlSTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbcmFuZ2VJXS50byA8IHIuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlSSsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dEZyb20gPSB0aGlzLnJhbmdlc1tyYW5nZUldLmZyb207XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUNodW5rQXQobmV4dEZyb20pO1xuICAgICAgICAgICAgICAgICAgICByLmVuZCA9IG5leHRGcm9tICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByLnRleHQgPSByLnRleHQuc2xpY2UoMCwgdGhpcy5yYW5nZXNbcmFuZ2VJIC0gMV0udG8gLSB0ZXh0T2Zmc2V0KSArIGFmdGVyO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gci5lbmQgLSByLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlYWRMaW5lKCkge1xuICAgICAgICBsZXQgeyBsaW5lIH0gPSB0aGlzLCB7IHRleHQsIGVuZCB9ID0gdGhpcy5zY2FuTGluZSh0aGlzLmFic29sdXRlTGluZVN0YXJ0KTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZUxpbmVFbmQgPSBlbmQ7XG4gICAgICAgIGxpbmUucmVzZXQodGV4dCk7XG4gICAgICAgIGZvciAoOyBsaW5lLmRlcHRoIDwgdGhpcy5zdGFjay5sZW5ndGg7IGxpbmUuZGVwdGgrKykge1xuICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5zdGFja1tsaW5lLmRlcHRoXSwgaGFuZGxlciA9IHRoaXMucGFyc2VyLnNraXBDb250ZXh0TWFya3VwW2N4LnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBibG9jayBjb250ZXh0IFwiICsgVHlwZVtjeC50eXBlXSk7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIoY3gsIHRoaXMsIGxpbmUpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZS5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluZUNodW5rQXQocG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpLCB0ZXh0O1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IG5leHQuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIHRleHQgPSBlb2wgPCAwID8gbmV4dCA6IG5leHQuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBuZXh0ID09IFwiXFxuXCIgPyBcIlwiIDogbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgdGV4dC5sZW5ndGggPiB0aGlzLnRvID8gdGV4dC5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKSA6IHRleHQ7XG4gICAgfVxuICAgIC8vLyBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBsaW5lLlxuICAgIHByZXZMaW5lRW5kKCkgeyByZXR1cm4gdGhpcy5hdEVuZCA/IHRoaXMubGluZVN0YXJ0IDogdGhpcy5saW5lU3RhcnQgLSAxOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXJ0Q29udGV4dCh0eXBlLCBzdGFydCwgdmFsdWUgPSAwKSB7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBDb21wb3NpdGVCbG9jay5jcmVhdGUodHlwZSwgdmFsdWUsIHRoaXMubGluZVN0YXJ0ICsgc3RhcnQsIHRoaXMuYmxvY2suaGFzaCwgdGhpcy5saW5lU3RhcnQgKyB0aGlzLmxpbmUudGV4dC5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5ibG9jayk7XG4gICAgfVxuICAgIC8vLyBTdGFydCBhIGNvbXBvc2l0ZSBibG9jay4gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gW2Jsb2NrXG4gICAgLy8vIHBhcnNlciBmdW5jdGlvbnNdKCNCbG9ja1BhcnNlci5wYXJzZSkgdGhhdCByZXR1cm4gbnVsbC5cbiAgICBzdGFydENvbXBvc2l0ZSh0eXBlLCBzdGFydCwgdmFsdWUgPSAwKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDb250ZXh0KHRoaXMucGFyc2VyLmdldE5vZGVUeXBlKHR5cGUpLCBzdGFydCwgdmFsdWUpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgYWRkTm9kZShibG9jaywgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgYmxvY2sgPSBuZXcgVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2Jsb2NrXSwgbm9uZSwgbm9uZSwgKHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IHRoaXMucHJldkxpbmVFbmQoKSkgLSBmcm9tKTtcbiAgICAgICAgdGhpcy5ibG9jay5hZGRDaGlsZChibG9jaywgZnJvbSAtIHRoaXMuYmxvY2suZnJvbSk7XG4gICAgfVxuICAgIC8vLyBBZGQgYSBibG9jayBlbGVtZW50LiBDYW4gYmUgY2FsbGVkIGJ5IFtibG9ja1xuICAgIC8vLyBwYXJzZXJzXSgjQmxvY2tQYXJzZXIucGFyc2UpLlxuICAgIGFkZEVsZW1lbnQoZWx0KSB7XG4gICAgICAgIHRoaXMuYmxvY2suYWRkQ2hpbGQoZWx0LnRvVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0KSwgZWx0LmZyb20gLSB0aGlzLmJsb2NrLmZyb20pO1xuICAgIH1cbiAgICAvLy8gQWRkIGEgYmxvY2sgZWxlbWVudCBmcm9tIGEgW2xlYWYgcGFyc2VyXSgjTGVhZkJsb2NrUGFyc2VyKS4gVGhpc1xuICAgIC8vLyBtYWtlcyBzdXJlIGFueSBleHRyYSBjb21wb3NpdGUgYmxvY2sgbWFya3VwIChzdWNoIGFzIGJsb2NrcXVvdGVcbiAgICAvLy8gbWFya2VycykgaW5zaWRlIHRoZSBibG9jayBhcmUgYWxzbyBhZGRlZCB0byB0aGUgc3ludGF4IHRyZWUuXG4gICAgYWRkTGVhZkVsZW1lbnQobGVhZiwgZWx0KSB7XG4gICAgICAgIHRoaXMuYWRkTm9kZSh0aGlzLmJ1ZmZlclxuICAgICAgICAgICAgLndyaXRlRWxlbWVudHMoaW5qZWN0TWFya3MoZWx0LmNoaWxkcmVuLCBsZWFmLm1hcmtzKSwgLWVsdC5mcm9tKVxuICAgICAgICAgICAgLmZpbmlzaChlbHQudHlwZSwgZWx0LnRvIC0gZWx0LmZyb20pLCBlbHQuZnJvbSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5pc2hDb250ZXh0KCkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB0b3AuYWRkQ2hpbGQoY3gudG9UcmVlKHRoaXMucGFyc2VyLm5vZGVTZXQpLCBjeC5mcm9tIC0gdG9wLmZyb20pO1xuICAgICAgICB0aGlzLmJsb2NrID0gdG9wO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkR2Fwcyh0aGlzLmJsb2NrLnRvVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0LCB0aGlzLmxpbmVTdGFydCkpO1xuICAgIH1cbiAgICBhZGRHYXBzKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgaW5qZWN0R2Fwcyh0aGlzLnJhbmdlcywgMCwgdHJlZS50b3BOb2RlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCB0aGlzLnJldXNlUGxhY2Vob2xkZXJzKSA6IHRyZWU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5pc2hMZWFmKGxlYWYpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyc2VyIG9mIGxlYWYucGFyc2VycylcbiAgICAgICAgICAgIGlmIChwYXJzZXIuZmluaXNoKHRoaXMsIGxlYWYpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGlubGluZSA9IGluamVjdE1hcmtzKHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKGxlYWYuY29udGVudCwgbGVhZi5zdGFydCksIGxlYWYubWFya3MpO1xuICAgICAgICB0aGlzLmFkZE5vZGUodGhpcy5idWZmZXJcbiAgICAgICAgICAgIC53cml0ZUVsZW1lbnRzKGlubGluZSwgLWxlYWYuc3RhcnQpXG4gICAgICAgICAgICAuZmluaXNoKFR5cGUuUGFyYWdyYXBoLCBsZWFmLmNvbnRlbnQubGVuZ3RoKSwgbGVhZi5zdGFydCk7XG4gICAgfVxuICAgIGVsdCh0eXBlLCBmcm9tLCB0bywgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gZWx0KHRoaXMucGFyc2VyLmdldE5vZGVUeXBlKHR5cGUpLCBmcm9tLCB0bywgY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFbGVtZW50KHR5cGUsIGZyb20pO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IGJ1ZmZlcigpIHsgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJzZXIubm9kZVNldCk7IH1cbn1cbmZ1bmN0aW9uIGluamVjdEdhcHMocmFuZ2VzLCByYW5nZUksIHRyZWUsIG9mZnNldCwgZHVtbWllcykge1xuICAgIGxldCByYW5nZUVuZCA9IHJhbmdlc1tyYW5nZUldLnRvO1xuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgc3RhcnQgPSB0cmVlLmZyb20gKyBvZmZzZXQ7XG4gICAgZnVuY3Rpb24gbW92ZVBhc3ROZXh0KHVwdG8sIGluY2x1c2l2ZSkge1xuICAgICAgICB3aGlsZSAoaW5jbHVzaXZlID8gdXB0byA+PSByYW5nZUVuZCA6IHVwdG8gPiByYW5nZUVuZCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSByYW5nZXNbcmFuZ2VJICsgMV0uZnJvbSAtIHJhbmdlRW5kO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICB1cHRvICs9IHNpemU7XG4gICAgICAgICAgICByYW5nZUkrKztcbiAgICAgICAgICAgIHJhbmdlRW5kID0gcmFuZ2VzW3JhbmdlSV0udG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgY2ggPSB0cmVlLmZpcnN0Q2hpbGQ7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIG1vdmVQYXN0TmV4dChjaC5mcm9tICsgb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgbGV0IGZyb20gPSBjaC5mcm9tICsgb2Zmc2V0LCBub2RlLCByZXVzZSA9IGR1bW1pZXMuZ2V0KGNoLnRyZWUpO1xuICAgICAgICBpZiAocmV1c2UpIHtcbiAgICAgICAgICAgIG5vZGUgPSByZXVzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaC50byArIG9mZnNldCA+IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBub2RlID0gaW5qZWN0R2FwcyhyYW5nZXMsIHJhbmdlSSwgY2gsIG9mZnNldCwgZHVtbWllcyk7XG4gICAgICAgICAgICBtb3ZlUGFzdE5leHQoY2gudG8gKyBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBjaC50b1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gc3RhcnQpO1xuICAgIH1cbiAgICBtb3ZlUGFzdE5leHQodHJlZS50byArIG9mZnNldCwgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgVHJlZSh0cmVlLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRyZWUudG8gKyBvZmZzZXQgLSBzdGFydCwgdHJlZS50cmVlID8gdHJlZS50cmVlLnByb3BWYWx1ZXMgOiB1bmRlZmluZWQpO1xufVxuLy8vIEEgTWFya2Rvd24gcGFyc2VyIGNvbmZpZ3VyYXRpb24uXG5jbGFzcyBNYXJrZG93blBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgcGFyc2VyJ3Mgc3ludGF4IFtub2RlXG4gICAgLy8vIHR5cGVzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVNldCkuXG4gICAgbm9kZVNldCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJsb2NrUGFyc2VycywgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGxlYWZCbG9ja1BhcnNlcnMsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBibG9ja05hbWVzLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZW5kTGVhZkJsb2NrLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2tpcENvbnRleHRNYXJrdXAsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBpbmxpbmVQYXJzZXJzLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgaW5saW5lTmFtZXMsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB3cmFwcGVycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmJsb2NrUGFyc2VycyA9IGJsb2NrUGFyc2VycztcbiAgICAgICAgdGhpcy5sZWFmQmxvY2tQYXJzZXJzID0gbGVhZkJsb2NrUGFyc2VycztcbiAgICAgICAgdGhpcy5ibG9ja05hbWVzID0gYmxvY2tOYW1lcztcbiAgICAgICAgdGhpcy5lbmRMZWFmQmxvY2sgPSBlbmRMZWFmQmxvY2s7XG4gICAgICAgIHRoaXMuc2tpcENvbnRleHRNYXJrdXAgPSBza2lwQ29udGV4dE1hcmt1cDtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXJzID0gaW5saW5lUGFyc2VycztcbiAgICAgICAgdGhpcy5pbmxpbmVOYW1lcyA9IGlubGluZU5hbWVzO1xuICAgICAgICB0aGlzLndyYXBwZXJzID0gd3JhcHBlcnM7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCB0IG9mIG5vZGVTZXQudHlwZXMpXG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlc1t0Lm5hbWVdID0gdC5pZDtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBCbG9ja0NvbnRleHQodGhpcywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgICAgICAgcGFyc2UgPSB3KHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIC8vLyBSZWNvbmZpZ3VyZSB0aGUgcGFyc2VyLlxuICAgIGNvbmZpZ3VyZShzcGVjKSB7XG4gICAgICAgIGxldCBjb25maWcgPSByZXNvbHZlQ29uZmlnKHNwZWMpO1xuICAgICAgICBpZiAoIWNvbmZpZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgeyBub2RlU2V0LCBza2lwQ29udGV4dE1hcmt1cCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJsb2NrUGFyc2VycyA9IHRoaXMuYmxvY2tQYXJzZXJzLnNsaWNlKCksIGxlYWZCbG9ja1BhcnNlcnMgPSB0aGlzLmxlYWZCbG9ja1BhcnNlcnMuc2xpY2UoKSwgYmxvY2tOYW1lcyA9IHRoaXMuYmxvY2tOYW1lcy5zbGljZSgpLCBpbmxpbmVQYXJzZXJzID0gdGhpcy5pbmxpbmVQYXJzZXJzLnNsaWNlKCksIGlubGluZU5hbWVzID0gdGhpcy5pbmxpbmVOYW1lcy5zbGljZSgpLCBlbmRMZWFmQmxvY2sgPSB0aGlzLmVuZExlYWZCbG9jay5zbGljZSgpLCB3cmFwcGVycyA9IHRoaXMud3JhcHBlcnM7XG4gICAgICAgIGlmIChub25FbXB0eShjb25maWcuZGVmaW5lTm9kZXMpKSB7XG4gICAgICAgICAgICBza2lwQ29udGV4dE1hcmt1cCA9IE9iamVjdC5hc3NpZ24oe30sIHNraXBDb250ZXh0TWFya3VwKTtcbiAgICAgICAgICAgIGxldCBub2RlVHlwZXMgPSBub2RlU2V0LnR5cGVzLnNsaWNlKCksIHN0eWxlcztcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgY29uZmlnLmRlZmluZU5vZGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbmFtZSwgYmxvY2ssIGNvbXBvc2l0ZSwgc3R5bGUgfSA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyB7IG5hbWU6IHMgfSA6IHM7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlcy5zb21lKHQgPT4gdC5uYW1lID09IG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlKVxuICAgICAgICAgICAgICAgICAgICBza2lwQ29udGV4dE1hcmt1cFtub2RlVHlwZXMubGVuZ3RoXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoYmwsIGN4LCBsaW5lKSA9PiBjb21wb3NpdGUoY3gsIGxpbmUsIGJsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBub2RlVHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBncm91cCA9IGNvbXBvc2l0ZSA/IFtcIkJsb2NrXCIsIFwiQmxvY2tDb250ZXh0XCJdIDogIWJsb2NrID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogaWQgPj0gVHlwZS5BVFhIZWFkaW5nMSAmJiBpZCA8PSBUeXBlLlNldGV4dEhlYWRpbmcyID8gW1wiQmxvY2tcIiwgXCJMZWFmQmxvY2tcIiwgXCJIZWFkaW5nXCJdIDogW1wiQmxvY2tcIiwgXCJMZWFmQmxvY2tcIl07XG4gICAgICAgICAgICAgICAgbm9kZVR5cGVzLnB1c2goTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBncm91cCAmJiBbW05vZGVQcm9wLmdyb3VwLCBncm91cF1dXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkgfHwgc3R5bGUgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbbmFtZV0gPSBzdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZVR5cGVzKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMpXG4gICAgICAgICAgICAgICAgbm9kZVNldCA9IG5vZGVTZXQuZXh0ZW5kKHN0eWxlVGFncyhzdHlsZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnByb3BzKSlcbiAgICAgICAgICAgIG5vZGVTZXQgPSBub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnJlbW92ZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJtIG9mIGNvbmZpZy5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLmJsb2NrTmFtZXMuaW5kZXhPZihybSksIGlubGluZSA9IHRoaXMuaW5saW5lTmFtZXMuaW5kZXhPZihybSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUGFyc2Vyc1tibG9ja10gPSBsZWFmQmxvY2tQYXJzZXJzW2Jsb2NrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaW5saW5lID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVBhcnNlcnNbaW5saW5lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnBhcnNlQmxvY2spKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIGNvbmZpZy5wYXJzZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gYmxvY2tOYW1lcy5pbmRleE9mKHNwZWMubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tQYXJzZXJzW2ZvdW5kXSA9IHNwZWMucGFyc2U7XG4gICAgICAgICAgICAgICAgICAgIGxlYWZCbG9ja1BhcnNlcnNbZm91bmRdID0gc3BlYy5sZWFmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IHNwZWMuYmVmb3JlID8gZmluZE5hbWUoYmxvY2tOYW1lcywgc3BlYy5iZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNwZWMuYWZ0ZXIgPyBmaW5kTmFtZShibG9ja05hbWVzLCBzcGVjLmFmdGVyKSArIDEgOiBibG9ja05hbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUGFyc2Vycy5zcGxpY2UocG9zLCAwLCBzcGVjLnBhcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZkJsb2NrUGFyc2Vycy5zcGxpY2UocG9zLCAwLCBzcGVjLmxlYWYpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja05hbWVzLnNwbGljZShwb3MsIDAsIHNwZWMubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGVjLmVuZExlYWYpXG4gICAgICAgICAgICAgICAgICAgIGVuZExlYWZCbG9jay5wdXNoKHNwZWMuZW5kTGVhZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbkVtcHR5KGNvbmZpZy5wYXJzZUlubGluZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2YgY29uZmlnLnBhcnNlSW5saW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gaW5saW5lTmFtZXMuaW5kZXhPZihzcGVjLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZVBhcnNlcnNbZm91bmRdID0gc3BlYy5wYXJzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBzcGVjLmJlZm9yZSA/IGZpbmROYW1lKGlubGluZU5hbWVzLCBzcGVjLmJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3BlYy5hZnRlciA/IGZpbmROYW1lKGlubGluZU5hbWVzLCBzcGVjLmFmdGVyKSArIDEgOiBpbmxpbmVOYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpbmxpbmVQYXJzZXJzLnNwbGljZShwb3MsIDAsIHNwZWMucGFyc2UpO1xuICAgICAgICAgICAgICAgICAgICBpbmxpbmVOYW1lcy5zcGxpY2UocG9zLCAwLCBzcGVjLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICB3cmFwcGVycyA9IHdyYXBwZXJzLmNvbmNhdChjb25maWcud3JhcCk7XG4gICAgICAgIHJldHVybiBuZXcgTWFya2Rvd25QYXJzZXIobm9kZVNldCwgYmxvY2tQYXJzZXJzLCBsZWFmQmxvY2tQYXJzZXJzLCBibG9ja05hbWVzLCBlbmRMZWFmQmxvY2ssIHNraXBDb250ZXh0TWFya3VwLCBpbmxpbmVQYXJzZXJzLCBpbmxpbmVOYW1lcywgd3JhcHBlcnMpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0Tm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVUeXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKGZvdW5kID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBub2RlIHR5cGUgJyR7bmFtZX0nYCk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLy8vIFBhcnNlIHRoZSBnaXZlbiBwaWVjZSBvZiBpbmxpbmUgdGV4dCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LFxuICAgIC8vLyByZXR1cm5pbmcgYW4gYXJyYXkgb2YgW2BFbGVtZW50YF0oI0VsZW1lbnQpIG9iamVjdHMgcmVwcmVzZW50aW5nXG4gICAgLy8vIHRoZSBpbmxpbmUgY29udGVudC5cbiAgICBwYXJzZUlubGluZSh0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGN4ID0gbmV3IElubGluZUNvbnRleHQodGhpcywgdGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgb3V0ZXI6IGZvciAobGV0IHBvcyA9IG9mZnNldDsgcG9zIDwgY3guZW5kOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjeC5jaGFyKHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0aGlzLmlubGluZVBhcnNlcnMpXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihjeCwgbmV4dCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjeC5yZXNvbHZlTWFya2VycygwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub25FbXB0eShhKSB7XG4gICAgcmV0dXJuIGEgIT0gbnVsbCAmJiBhLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZXNvbHZlQ29uZmlnKHNwZWMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3BlYykpXG4gICAgICAgIHJldHVybiBzcGVjO1xuICAgIGlmIChzcGVjLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29uZiA9IHJlc29sdmVDb25maWcoc3BlY1swXSk7XG4gICAgaWYgKHNwZWMubGVuZ3RoID09IDEpXG4gICAgICAgIHJldHVybiBjb25mO1xuICAgIGxldCByZXN0ID0gcmVzb2x2ZUNvbmZpZyhzcGVjLnNsaWNlKDEpKTtcbiAgICBpZiAoIXJlc3QgfHwgIWNvbmYpXG4gICAgICAgIHJldHVybiBjb25mIHx8IHJlc3Q7XG4gICAgbGV0IGNvbmMgPSAoYSwgYikgPT4gKGEgfHwgbm9uZSkuY29uY2F0KGIgfHwgbm9uZSk7XG4gICAgbGV0IHdyYXBBID0gY29uZi53cmFwLCB3cmFwQiA9IHJlc3Qud3JhcDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogY29uYyhjb25mLnByb3BzLCByZXN0LnByb3BzKSxcbiAgICAgICAgZGVmaW5lTm9kZXM6IGNvbmMoY29uZi5kZWZpbmVOb2RlcywgcmVzdC5kZWZpbmVOb2RlcyksXG4gICAgICAgIHBhcnNlQmxvY2s6IGNvbmMoY29uZi5wYXJzZUJsb2NrLCByZXN0LnBhcnNlQmxvY2spLFxuICAgICAgICBwYXJzZUlubGluZTogY29uYyhjb25mLnBhcnNlSW5saW5lLCByZXN0LnBhcnNlSW5saW5lKSxcbiAgICAgICAgcmVtb3ZlOiBjb25jKGNvbmYucmVtb3ZlLCByZXN0LnJlbW92ZSksXG4gICAgICAgIHdyYXA6ICF3cmFwQSA/IHdyYXBCIDogIXdyYXBCID8gd3JhcEEgOlxuICAgICAgICAgICAgKGlubmVyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IHdyYXBBKHdyYXBCKGlubmVyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmROYW1lKG5hbWVzLCBuYW1lKSB7XG4gICAgbGV0IGZvdW5kID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gc3BlY2lmaWVkIHJlbGF0aXZlIHRvIHVua25vd24gcGFyc2VyICR7bmFtZX1gKTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5sZXQgbm9kZVR5cGVzID0gW05vZGVUeXBlLm5vbmVdO1xuZm9yIChsZXQgaSA9IDEsIG5hbWU7IG5hbWUgPSBUeXBlW2ldOyBpKyspIHtcbiAgICBub2RlVHlwZXNbaV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogaSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IGkgPj0gVHlwZS5Fc2NhcGUgPyBbXSA6IFtbTm9kZVByb3AuZ3JvdXAsIGkgaW4gRGVmYXVsdFNraXBNYXJrdXAgPyBbXCJCbG9ja1wiLCBcIkJsb2NrQ29udGV4dFwiXSA6IFtcIkJsb2NrXCIsIFwiTGVhZkJsb2NrXCJdXV0sXG4gICAgICAgIHRvcDogbmFtZSA9PSBcIkRvY3VtZW50XCJcbiAgICB9KTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNsYXNzIEJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3Iobm9kZVNldCkge1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cbiAgICB3cml0ZSh0eXBlLCBmcm9tLCB0bywgY2hpbGRyZW4gPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHR5cGUsIGZyb20sIHRvLCA0ICsgY2hpbGRyZW4gKiA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdyaXRlRWxlbWVudHMoZWx0cywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBmb3IgKGxldCBlIG9mIGVsdHMpXG4gICAgICAgICAgICBlLndyaXRlVG8odGhpcywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCh0eXBlLCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLm5vZGVTZXQsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMubm9kZXMsXG4gICAgICAgICAgICB0b3BJRDogdHlwZSxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLy8gRWxlbWVudHMgYXJlIHVzZWQgdG8gY29tcG9zZSBzeW50YXggbm9kZXMgZHVyaW5nIHBhcnNpbmcuXG5jbGFzcyBFbGVtZW50IHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBub2RlJ3NcbiAgICAvLy8gW2lkXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVR5cGUuaWQpLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIG5vZGUsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gICAgdG8sIFxuICAgIC8vLyBUaGUgbm9kZSdzIGNoaWxkIG5vZGVzIEBpbnRlcm5hbFxuICAgIGNoaWxkcmVuID0gbm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHdyaXRlVG8oYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gYnVmLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICBidWYud3JpdGVFbGVtZW50cyh0aGlzLmNoaWxkcmVuLCBvZmZzZXQpO1xuICAgICAgICBidWYuY29udGVudC5wdXNoKHRoaXMudHlwZSwgdGhpcy5mcm9tICsgb2Zmc2V0LCB0aGlzLnRvICsgb2Zmc2V0LCBidWYuY29udGVudC5sZW5ndGggKyA0IC0gc3RhcnRPZmYpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9UcmVlKG5vZGVTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIobm9kZVNldCkud3JpdGVFbGVtZW50cyh0aGlzLmNoaWxkcmVuLCAtdGhpcy5mcm9tKS5maW5pc2godGhpcy50eXBlLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG59XG5jbGFzcyBUcmVlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodHJlZSwgZnJvbSkge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRyZWUubGVuZ3RoOyB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLnRyZWUudHlwZS5pZDsgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG5vbmU7IH1cbiAgICB3cml0ZVRvKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgIGJ1Zi5ub2Rlcy5wdXNoKHRoaXMudHJlZSk7XG4gICAgICAgIGJ1Zi5jb250ZW50LnB1c2goYnVmLm5vZGVzLmxlbmd0aCAtIDEsIHRoaXMuZnJvbSArIG9mZnNldCwgdGhpcy50byArIG9mZnNldCwgLTEpO1xuICAgIH1cbiAgICB0b1RyZWUoKSB7IHJldHVybiB0aGlzLnRyZWU7IH1cbn1cbmZ1bmN0aW9uIGVsdCh0eXBlLCBmcm9tLCB0bywgY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQodHlwZSwgZnJvbSwgdG8sIGNoaWxkcmVuKTtcbn1cbmNvbnN0IEVtcGhhc2lzVW5kZXJzY29yZSA9IHsgcmVzb2x2ZTogXCJFbXBoYXNpc1wiLCBtYXJrOiBcIkVtcGhhc2lzTWFya1wiIH07XG5jb25zdCBFbXBoYXNpc0FzdGVyaXNrID0geyByZXNvbHZlOiBcIkVtcGhhc2lzXCIsIG1hcms6IFwiRW1waGFzaXNNYXJrXCIgfTtcbmNvbnN0IExpbmtTdGFydCA9IHt9LCBJbWFnZVN0YXJ0ID0ge307XG5jbGFzcyBJbmxpbmVEZWxpbWl0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGZyb20sIHRvLCBzaWRlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG59XG5jb25zdCBFc2NhcGFibGUgPSBcIiFcXFwiIyQlJicoKSorLC0uLzo7PD0+P0BbXFxcXF1eX2B7fH1+XCI7XG5sZXQgUHVuY3R1YXRpb24gPSAvWyFcIiMkJSYnKCkqKyxcXC0uXFwvOjs8PT4/QFxcW1xcXFxcXF1eX2B7fH1+XFx4QTFcXHUyMDEwLVxcdTIwMjddLztcbnRyeSB7XG4gICAgUHVuY3R1YXRpb24gPSBuZXcgUmVnRXhwKFwiW1xcXFxwe1BjfXxcXFxccHtQZH18XFxcXHB7UGV9fFxcXFxwe1BmfXxcXFxccHtQaX18XFxcXHB7UG99fFxcXFxwe1BzfV1cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuY29uc3QgRGVmYXVsdElubGluZSA9IHtcbiAgICBFc2NhcGUoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDkyIC8qICdcXFxcJyAqLyB8fCBzdGFydCA9PSBjeC5lbmQgLSAxKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGN4LmNoYXIoc3RhcnQgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFc2NhcGFibGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoRXNjYXBhYmxlLmNoYXJDb2RlQXQoaSkgPT0gZXNjYXBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkVzY2FwZSwgc3RhcnQsIHN0YXJ0ICsgMikpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBFbnRpdHkoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDM4IC8qICcmJyAqLylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IG0gPSAvXig/OiNcXGQrfCN4W2EtZlxcZF0rfFxcdyspOy9pLmV4ZWMoY3guc2xpY2Uoc3RhcnQgKyAxLCBzdGFydCArIDMxKSk7XG4gICAgICAgIHJldHVybiBtID8gY3guYXBwZW5kKGVsdChUeXBlLkVudGl0eSwgc3RhcnQsIHN0YXJ0ICsgMSArIG1bMF0ubGVuZ3RoKSkgOiAtMTtcbiAgICB9LFxuICAgIElubGluZUNvZGUoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDk2IC8qICdgJyAqLyB8fCBzdGFydCAmJiBjeC5jaGFyKHN0YXJ0IC0gMSkgPT0gOTYpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydCArIDE7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjeC5lbmQgJiYgY3guY2hhcihwb3MpID09IDk2KVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIGxldCBzaXplID0gcG9zIC0gc3RhcnQsIGN1clNpemUgPSAwO1xuICAgICAgICBmb3IgKDsgcG9zIDwgY3guZW5kOyBwb3MrKykge1xuICAgICAgICAgICAgaWYgKGN4LmNoYXIocG9zKSA9PSA5Nikge1xuICAgICAgICAgICAgICAgIGN1clNpemUrKztcbiAgICAgICAgICAgICAgICBpZiAoY3VyU2l6ZSA9PSBzaXplICYmIGN4LmNoYXIocG9zICsgMSkgIT0gOTYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuSW5saW5lQ29kZSwgc3RhcnQsIHBvcyArIDEsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdChUeXBlLkNvZGVNYXJrLCBzdGFydCwgc3RhcnQgKyBzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdChUeXBlLkNvZGVNYXJrLCBwb3MgKyAxIC0gc2l6ZSwgcG9zICsgMSlcbiAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyU2l6ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgSFRNTFRhZyhjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgaWYgKG5leHQgIT0gNjAgLyogJzwnICovIHx8IHN0YXJ0ID09IGN4LmVuZCAtIDEpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBhZnRlciA9IGN4LnNsaWNlKHN0YXJ0ICsgMSwgY3guZW5kKTtcbiAgICAgICAgbGV0IHVybCA9IC9eKD86W2Etel1bLVxcdysuXSs6W15cXHM+XSt8W2EtelxcZC4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtelxcZF0oPzpbYS16XFxkLV17MCw2MX1bYS16XFxkXSk/KD86XFwuW2EtelxcZF0oPzpbYS16XFxkLV17MCw2MX1bYS16XFxkXSk/KSopPi9pLmV4ZWMoYWZ0ZXIpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkF1dG9saW5rLCBzdGFydCwgc3RhcnQgKyAxICsgdXJsWzBdLmxlbmd0aCwgW1xuICAgICAgICAgICAgICAgIGVsdChUeXBlLkxpbmtNYXJrLCBzdGFydCwgc3RhcnQgKyAxKSxcbiAgICAgICAgICAgICAgICAvLyB1cmxbMF0gaW5jbHVkZXMgdGhlIGNsb3NpbmcgYnJhY2tldCwgc28gZXhjbHVkZSBpdCBmcm9tIHRoaXMgc2xpY2VcbiAgICAgICAgICAgICAgICBlbHQoVHlwZS5VUkwsIHN0YXJ0ICsgMSwgc3RhcnQgKyB1cmxbMF0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnQgKyB1cmxbMF0ubGVuZ3RoLCBzdGFydCArIDEgKyB1cmxbMF0ubGVuZ3RoKVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21tZW50ID0gL14hLS1bXj5dKD86LVteLV18W14tXSkqPy0tPi9pLmV4ZWMoYWZ0ZXIpO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuQ29tbWVudCwgc3RhcnQsIHN0YXJ0ICsgMSArIGNvbW1lbnRbMF0ubGVuZ3RoKSk7XG4gICAgICAgIGxldCBwcm9jSW5zdCA9IC9eXFw/W15dKj9cXD8+Ly5leGVjKGFmdGVyKTtcbiAgICAgICAgaWYgKHByb2NJbnN0KVxuICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIHN0YXJ0LCBzdGFydCArIDEgKyBwcm9jSW5zdFswXS5sZW5ndGgpKTtcbiAgICAgICAgbGV0IG0gPSAvXig/OiFbQS1aXVteXSo/PnwhXFxbQ0RBVEFcXFtbXl0qP1xcXVxcXT58XFwvXFxzKlthLXpBLVpdW1xcdy1dKlxccyo+fFxccypbYS16QS1aXVtcXHctXSooXFxzK1thLXpBLVo6X11bXFx3LS46XSooPzpcXHMqPVxccyooPzpbXlxcc1wiJz08PmBdK3wnW14nXSonfFwiW15cIl0qXCIpKT8pKlxccyooXFwvXFxzKik/PikvLmV4ZWMoYWZ0ZXIpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuSFRNTFRhZywgc3RhcnQsIHN0YXJ0ICsgMSArIG1bMF0ubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBFbXBoYXNpcyhjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgaWYgKG5leHQgIT0gOTUgJiYgbmV4dCAhPSA0MilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0ICsgMTtcbiAgICAgICAgd2hpbGUgKGN4LmNoYXIocG9zKSA9PSBuZXh0KVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIGxldCBiZWZvcmUgPSBjeC5zbGljZShzdGFydCAtIDEsIHN0YXJ0KSwgYWZ0ZXIgPSBjeC5zbGljZShwb3MsIHBvcyArIDEpO1xuICAgICAgICBsZXQgcEJlZm9yZSA9IFB1bmN0dWF0aW9uLnRlc3QoYmVmb3JlKSwgcEFmdGVyID0gUHVuY3R1YXRpb24udGVzdChhZnRlcik7XG4gICAgICAgIGxldCBzQmVmb3JlID0gL1xcc3xeJC8udGVzdChiZWZvcmUpLCBzQWZ0ZXIgPSAvXFxzfF4kLy50ZXN0KGFmdGVyKTtcbiAgICAgICAgbGV0IGxlZnRGbGFua2luZyA9ICFzQWZ0ZXIgJiYgKCFwQWZ0ZXIgfHwgc0JlZm9yZSB8fCBwQmVmb3JlKTtcbiAgICAgICAgbGV0IHJpZ2h0RmxhbmtpbmcgPSAhc0JlZm9yZSAmJiAoIXBCZWZvcmUgfHwgc0FmdGVyIHx8IHBBZnRlcik7XG4gICAgICAgIGxldCBjYW5PcGVuID0gbGVmdEZsYW5raW5nICYmIChuZXh0ID09IDQyIHx8ICFyaWdodEZsYW5raW5nIHx8IHBCZWZvcmUpO1xuICAgICAgICBsZXQgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nICYmIChuZXh0ID09IDQyIHx8ICFsZWZ0RmxhbmtpbmcgfHwgcEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChuZXcgSW5saW5lRGVsaW1pdGVyKG5leHQgPT0gOTUgPyBFbXBoYXNpc1VuZGVyc2NvcmUgOiBFbXBoYXNpc0FzdGVyaXNrLCBzdGFydCwgcG9zLCAoY2FuT3BlbiA/IDEgLyogTWFyay5PcGVuICovIDogMCAvKiBNYXJrLk5vbmUgKi8pIHwgKGNhbkNsb3NlID8gMiAvKiBNYXJrLkNsb3NlICovIDogMCAvKiBNYXJrLk5vbmUgKi8pKSk7XG4gICAgfSxcbiAgICBIYXJkQnJlYWsoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ID09IDkyIC8qICdcXFxcJyAqLyAmJiBjeC5jaGFyKHN0YXJ0ICsgMSkgPT0gMTAgLyogJ1xcbicgKi8pXG4gICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkhhcmRCcmVhaywgc3RhcnQsIHN0YXJ0ICsgMikpO1xuICAgICAgICBpZiAobmV4dCA9PSAzMikge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChjeC5jaGFyKHBvcykgPT0gMzIpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAoY3guY2hhcihwb3MpID09IDEwICYmIHBvcyA+PSBzdGFydCArIDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5IYXJkQnJlYWssIHN0YXJ0LCBwb3MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgTGluayhjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQgPT0gOTEgLyogJ1snICovID8gY3guYXBwZW5kKG5ldyBJbmxpbmVEZWxpbWl0ZXIoTGlua1N0YXJ0LCBzdGFydCwgc3RhcnQgKyAxLCAxIC8qIE1hcmsuT3BlbiAqLykpIDogLTE7XG4gICAgfSxcbiAgICBJbWFnZShjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQgPT0gMzMgLyogJyEnICovICYmIGN4LmNoYXIoc3RhcnQgKyAxKSA9PSA5MSAvKiAnWycgKi9cbiAgICAgICAgICAgID8gY3guYXBwZW5kKG5ldyBJbmxpbmVEZWxpbWl0ZXIoSW1hZ2VTdGFydCwgc3RhcnQsIHN0YXJ0ICsgMiwgMSAvKiBNYXJrLk9wZW4gKi8pKSA6IC0xO1xuICAgIH0sXG4gICAgTGlua0VuZChjeCwgbmV4dCwgc3RhcnQpIHtcbiAgICAgICAgaWYgKG5leHQgIT0gOTMgLyogJ10nICovKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyBTY2FubmluZyBiYWNrIHRvIHRoZSBuZXh0IGxpbmsvaW1hZ2Ugc3RhcnQgbWFya2VyXG4gICAgICAgIGZvciAobGV0IGkgPSBjeC5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBjeC5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIChwYXJ0LnR5cGUgPT0gTGlua1N0YXJ0IHx8IHBhcnQudHlwZSA9PSBJbWFnZVN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgb25lIGhhcyBiZWVuIHNldCBpbnZhbGlkIChiZWNhdXNlIGl0IHdvdWxkIHByb2R1Y2VcbiAgICAgICAgICAgICAgICAvLyBhIG5lc3RlZCBsaW5rKSBvciB0aGVyZSdzIG5vIHZhbGlkIGxpbmsgaGVyZSBpZ25vcmUgYm90aC5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQuc2lkZSB8fCBjeC5za2lwU3BhY2UocGFydC50bykgPT0gc3RhcnQgJiYgIS9bKFxcW10vLnRlc3QoY3guc2xpY2Uoc3RhcnQgKyAxLCBzdGFydCArIDIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjeC5wYXJ0c1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIHRoZSBjb250ZW50IGFuZCByZXBsYWNlIHRoZSBlbnRpcmUgcmFuZ2UgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBhcnRzIHdpdGggdGhlIGxpbmsvaW1hZ2Ugbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IGN4LnRha2VDb250ZW50KGkpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gY3gucGFydHNbaV0gPSBmaW5pc2hMaW5rKGN4LCBjb250ZW50LCBwYXJ0LnR5cGUgPT0gTGlua1N0YXJ0ID8gVHlwZS5MaW5rIDogVHlwZS5JbWFnZSwgcGFydC5mcm9tLCBzdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIFNldCBhbnkgb3Blbi1saW5rIG1hcmtlcnMgYmVmb3JlIHRoaXMgbGluayB0byBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT0gTGlua1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSBjeC5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIHAudHlwZSA9PSBMaW5rU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zaWRlID0gMCAvKiBNYXJrLk5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGluay50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGZpbmlzaExpbmsoY3gsIGNvbnRlbnQsIHR5cGUsIHN0YXJ0LCBzdGFydFBvcykge1xuICAgIGxldCB7IHRleHQgfSA9IGN4LCBuZXh0ID0gY3guY2hhcihzdGFydFBvcyksIGVuZFBvcyA9IHN0YXJ0UG9zO1xuICAgIGNvbnRlbnQudW5zaGlmdChlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnQsIHN0YXJ0ICsgKHR5cGUgPT0gVHlwZS5JbWFnZSA/IDIgOiAxKSkpO1xuICAgIGNvbnRlbnQucHVzaChlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnRQb3MgLSAxLCBzdGFydFBvcykpO1xuICAgIGlmIChuZXh0ID09IDQwIC8qICcoJyAqLykge1xuICAgICAgICBsZXQgcG9zID0gY3guc2tpcFNwYWNlKHN0YXJ0UG9zICsgMSk7XG4gICAgICAgIGxldCBkZXN0ID0gcGFyc2VVUkwodGV4dCwgcG9zIC0gY3gub2Zmc2V0LCBjeC5vZmZzZXQpLCB0aXRsZTtcbiAgICAgICAgaWYgKGRlc3QpIHtcbiAgICAgICAgICAgIHBvcyA9IGN4LnNraXBTcGFjZShkZXN0LnRvKTtcbiAgICAgICAgICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBhbmQgdGl0bGUgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKHBvcyAhPSBkZXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBwYXJzZUxpbmtUaXRsZSh0ZXh0LCBwb3MgLSBjeC5vZmZzZXQsIGN4Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlKVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeC5za2lwU3BhY2UodGl0bGUudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjeC5jaGFyKHBvcykgPT0gNDEgLyogJyknICovKSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goZWx0KFR5cGUuTGlua01hcmssIHN0YXJ0UG9zLCBzdGFydFBvcyArIDEpKTtcbiAgICAgICAgICAgIGVuZFBvcyA9IHBvcyArIDE7XG4gICAgICAgICAgICBpZiAoZGVzdClcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goZGVzdCk7XG4gICAgICAgICAgICBpZiAodGl0bGUpXG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHRpdGxlKTtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChlbHQoVHlwZS5MaW5rTWFyaywgcG9zLCBlbmRQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0ID09IDkxIC8qICdbJyAqLykge1xuICAgICAgICBsZXQgbGFiZWwgPSBwYXJzZUxpbmtMYWJlbCh0ZXh0LCBzdGFydFBvcyAtIGN4Lm9mZnNldCwgY3gub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIGVuZFBvcyA9IGxhYmVsLnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHQodHlwZSwgc3RhcnQsIGVuZFBvcywgY29udGVudCk7XG59XG4vLyBUaGVzZSByZXR1cm4gYG51bGxgIHdoZW4gZmFsbGluZyBvZmYgdGhlIGVuZCBvZiB0aGUgaW5wdXQsIGBmYWxzZWBcbi8vIHdoZW4gcGFyc2luZyBmYWlscyBvdGhlcndpc2UgKGZvciB1c2UgaW4gdGhlIGluY3JlbWVudGFsIGxpbmtcbi8vIHJlZmVyZW5jZSBwYXJzZXIpLlxuZnVuY3Rpb24gcGFyc2VVUkwodGV4dCwgc3RhcnQsIG9mZnNldCkge1xuICAgIGxldCBuZXh0ID0gdGV4dC5jaGFyQ29kZUF0KHN0YXJ0KTtcbiAgICBpZiAobmV4dCA9PSA2MCAvKiAnPCcgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3RhcnQgKyAxOyBwb3MgPCB0ZXh0Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09IDYyIC8qICc+JyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gZWx0KFR5cGUuVVJMLCBzdGFydCArIG9mZnNldCwgcG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gNjAgfHwgY2ggPT0gMTAgLyogJzxcXG4nICovKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBkZXB0aCA9IDAsIHBvcyA9IHN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBlc2NhcGVkID0gZmFsc2U7IHBvcyA8IHRleHQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgICAgbGV0IGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoc3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gNDAgLyogJygnICovKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IDQxIC8qICcpJyAqLykge1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSA5MiAvKiAnXFxcXCcgKi8pIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zID4gc3RhcnQgPyBlbHQoVHlwZS5VUkwsIHN0YXJ0ICsgb2Zmc2V0LCBwb3MgKyBvZmZzZXQpIDogcG9zID09IHRleHQubGVuZ3RoID8gbnVsbCA6IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHRleHQsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICBsZXQgbmV4dCA9IHRleHQuY2hhckNvZGVBdChzdGFydCk7XG4gICAgaWYgKG5leHQgIT0gMzkgJiYgbmV4dCAhPSAzNCAmJiBuZXh0ICE9IDQwIC8qICdcIlxcJygnICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVuZCA9IG5leHQgPT0gNDAgPyA0MSA6IG5leHQ7XG4gICAgZm9yIChsZXQgcG9zID0gc3RhcnQgKyAxLCBlc2NhcGVkID0gZmFsc2U7IHBvcyA8IHRleHQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBsZXQgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGVzY2FwZWQpXG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKGNoID09IGVuZClcbiAgICAgICAgICAgIHJldHVybiBlbHQoVHlwZS5MaW5rVGl0bGUsIHN0YXJ0ICsgb2Zmc2V0LCBwb3MgKyAxICsgb2Zmc2V0KTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gOTIgLyogJ1xcXFwnICovKVxuICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwodGV4dCwgc3RhcnQsIG9mZnNldCwgcmVxdWlyZU5vbldTKSB7XG4gICAgZm9yIChsZXQgZXNjYXBlZCA9IGZhbHNlLCBwb3MgPSBzdGFydCArIDEsIGVuZCA9IE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyA5OTkpOyBwb3MgPCBlbmQ7IHBvcysrKSB7XG4gICAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoZXNjYXBlZClcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gOTMgLyogJ10nICovKVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVOb25XUyA/IGZhbHNlIDogZWx0KFR5cGUuTGlua0xhYmVsLCBzdGFydCArIG9mZnNldCwgcG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVOb25XUyAmJiAhc3BhY2UoY2gpKVxuICAgICAgICAgICAgICAgIHJlcXVpcmVOb25XUyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNoID09IDkxIC8qICdbJyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSA5MiAvKiAnXFxcXCcgKi8pXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLy8gSW5saW5lIHBhcnNpbmcgZnVuY3Rpb25zIGdldCBhY2Nlc3MgdG8gdGhpcyBjb250ZXh0LCBhbmQgdXNlIGl0IHRvXG4vLy8gcmVhZCB0aGUgY29udGVudCBhbmQgZW1pdCBzeW50YXggbm9kZXMuXG5jbGFzcyBJbmxpbmVDb250ZXh0IHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBwYXJzZXIgdGhhdCBpcyBiZWluZyB1c2VkLlxuICAgIHBhcnNlciwgXG4gICAgLy8vIFRoZSB0ZXh0IG9mIHRoaXMgaW5saW5lIHNlY3Rpb24uXG4gICAgdGV4dCwgXG4gICAgLy8vIFRoZSBzdGFydGluZyBvZmZzZXQgb2YgdGhlIHNlY3Rpb24gaW4gdGhlIGRvY3VtZW50LlxuICAgIG9mZnNldCkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBjaGFyYWN0ZXIgY29kZSBhdCB0aGUgZ2l2ZW4gKGRvY3VtZW50LXJlbGF0aXZlKVxuICAgIC8vLyBwb3NpdGlvbi5cbiAgICBjaGFyKHBvcykgeyByZXR1cm4gcG9zID49IHRoaXMuZW5kID8gLTEgOiB0aGlzLnRleHQuY2hhckNvZGVBdChwb3MgLSB0aGlzLm9mZnNldCk7IH1cbiAgICAvLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhpcyBpbmxpbmUgc2VjdGlvbi5cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgLy8vIEdldCBhIHN1YnN0cmluZyBvZiB0aGlzIGlubGluZSBzZWN0aW9uLiBBZ2FpbiB1c2VzXG4gICAgLy8vIGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9ucy5cbiAgICBzbGljZShmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20gLSB0aGlzLm9mZnNldCwgdG8gLSB0aGlzLm9mZnNldCk7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgYXBwZW5kKGVsdCkge1xuICAgICAgICB0aGlzLnBhcnRzLnB1c2goZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdC50bztcbiAgICB9XG4gICAgLy8vIEFkZCBhIFtkZWxpbWl0ZXJdKCNEZWxpbWl0ZXJUeXBlKSBhdCB0aGlzIGdpdmVuIHBvc2l0aW9uLiBgb3BlbmBcbiAgICAvLy8gYW5kIGBjbG9zZWAgaW5kaWNhdGUgd2hldGhlciB0aGlzIGRlbGltaXRlciBpcyBvcGVuaW5nLCBjbG9zaW5nLFxuICAgIC8vLyBvciBib3RoLiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGRlbGltaXRlciwgZm9yIGNvbnZlbmllbnRcbiAgICAvLy8gcmV0dXJuaW5nIGZyb20gW3BhcnNlIGZ1bmN0aW9uc10oI0lubGluZVBhcnNlci5wYXJzZSkuXG4gICAgYWRkRGVsaW1pdGVyKHR5cGUsIGZyb20sIHRvLCBvcGVuLCBjbG9zZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmQobmV3IElubGluZURlbGltaXRlcih0eXBlLCBmcm9tLCB0bywgKG9wZW4gPyAxIC8qIE1hcmsuT3BlbiAqLyA6IDAgLyogTWFyay5Ob25lICovKSB8IChjbG9zZSA/IDIgLyogTWFyay5DbG9zZSAqLyA6IDAgLyogTWFyay5Ob25lICovKSkpO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhlcmUgaXMgYW4gdW5tYXRjaGVkIGxpbmsgb3IgaW1hZ2Ugb3BlbmluZ1xuICAgIC8vLyB0b2tlbiBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgZ2V0IGhhc09wZW5MaW5rKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBJbmxpbmVEZWxpbWl0ZXIgJiYgKHBhcnQudHlwZSA9PSBMaW5rU3RhcnQgfHwgcGFydC50eXBlID09IEltYWdlU3RhcnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIEFkZCBhbiBpbmxpbmUgZWxlbWVudC4gUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBlbGVtZW50LlxuICAgIGFkZEVsZW1lbnQoZWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZChlbHQpO1xuICAgIH1cbiAgICAvLy8gUmVzb2x2ZSBtYXJrZXJzIGJldHdlZW4gdGhpcy5wYXJ0cy5sZW5ndGggYW5kIGZyb20sIHdyYXBwaW5nIG1hdGNoZWQgbWFya2VycyBpbiB0aGVcbiAgICAvLy8gYXBwcm9wcmlhdGUgbm9kZSBhbmQgdXBkYXRpbmcgdGhlIGNvbnRlbnQgb2YgdGhpcy5wYXJ0cy4gQGludGVybmFsXG4gICAgcmVzb2x2ZU1hcmtlcnMoZnJvbSkge1xuICAgICAgICAvLyBTY2FuIGZvcndhcmQsIGxvb2tpbmcgZm9yIGNsb3NpbmcgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNsb3NlID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKGNsb3NlIGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIGNsb3NlLnR5cGUucmVzb2x2ZSAmJiAoY2xvc2Uuc2lkZSAmIDIgLyogTWFyay5DbG9zZSAqLykpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGVtcCA9IGNsb3NlLnR5cGUgPT0gRW1waGFzaXNVbmRlcnNjb3JlIHx8IGNsb3NlLnR5cGUgPT0gRW1waGFzaXNBc3RlcmlzaztcbiAgICAgICAgICAgIGxldCBjbG9zZVNpemUgPSBjbG9zZS50byAtIGNsb3NlLmZyb207XG4gICAgICAgICAgICBsZXQgb3BlbiwgaiA9IGkgLSAxO1xuICAgICAgICAgICAgLy8gQ29udGludWUgc2Nhbm5pbmcgZm9yIGEgbWF0Y2hpbmcgb3BlbmluZyB0b2tlblxuICAgICAgICAgICAgZm9yICg7IGogPj0gZnJvbTsgai0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgSW5saW5lRGVsaW1pdGVyICYmIChwYXJ0LnNpZGUgJiAxIC8qIE1hcmsuT3BlbiAqLykgJiYgcGFydC50eXBlID09IGNsb3NlLnR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcGhhc2lzIGRlbGltaXRlcnMgd2hlcmUgdGhlIGNoYXJhY3RlciBjb3VudCBkb2Vzbid0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICEoZW1wICYmICgoY2xvc2Uuc2lkZSAmIDEgLyogTWFyay5PcGVuICovKSB8fCAocGFydC5zaWRlICYgMiAvKiBNYXJrLkNsb3NlICovKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJ0LnRvIC0gcGFydC5mcm9tICsgY2xvc2VTaXplKSAlIDMgPT0gMCAmJiAoKHBhcnQudG8gLSBwYXJ0LmZyb20pICUgMyB8fCBjbG9zZVNpemUgJSAzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3BlbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gY2xvc2UudHlwZS5yZXNvbHZlLCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBvcGVuLmZyb20sIGVuZCA9IGNsb3NlLnRvO1xuICAgICAgICAgICAgLy8gRW1waGFzaXMgbWFya2VyIGVmZmVjdCBkZXBlbmRzIG9uIHRoZSBjaGFyYWN0ZXIgY291bnQuIFNpemUgY29uc3VtZWQgaXMgbWluaW11bSBvZiB0aGUgdHdvXG4gICAgICAgICAgICAvLyBtYXJrZXJzLlxuICAgICAgICAgICAgaWYgKGVtcCkge1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gTWF0aC5taW4oMiwgb3Blbi50byAtIG9wZW4uZnJvbSwgY2xvc2VTaXplKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG9wZW4udG8gLSBzaXplO1xuICAgICAgICAgICAgICAgIGVuZCA9IGNsb3NlLmZyb20gKyBzaXplO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBzaXplID09IDEgPyBcIkVtcGhhc2lzXCIgOiBcIlN0cm9uZ0VtcGhhc2lzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBjb3ZlcmVkIHJlZ2lvbiBpbnRvIGNvbnRlbnQsIG9wdGlvbmFsbHkgYWRkaW5nIG1hcmtlciBub2Rlc1xuICAgICAgICAgICAgaWYgKG9wZW4udHlwZS5tYXJrKVxuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh0aGlzLmVsdChvcGVuLnR5cGUubWFyaywgc3RhcnQsIG9wZW4udG8pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IGk7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcnRzW2tdIGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHRoaXMucGFydHNba10pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydHNba10gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsb3NlLnR5cGUubWFyaylcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2godGhpcy5lbHQoY2xvc2UudHlwZS5tYXJrLCBjbG9zZS5mcm9tLCBlbmQpKTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5lbHQodHlwZSwgc3RhcnQsIGVuZCwgY29udGVudCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbGVmdG92ZXIgZW1waGFzaXMgbWFya2VyIGNoYXJhY3RlcnMsIHNocmluayB0aGUgY2xvc2Uvb3BlbiBtYXJrZXJzLiBPdGhlcndpc2UsIGNsZWFyIHRoZW0uXG4gICAgICAgICAgICB0aGlzLnBhcnRzW2pdID0gZW1wICYmIG9wZW4uZnJvbSAhPSBzdGFydCA/IG5ldyBJbmxpbmVEZWxpbWl0ZXIob3Blbi50eXBlLCBvcGVuLmZyb20sIHN0YXJ0LCBvcGVuLnNpZGUpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBrZWVwID0gdGhpcy5wYXJ0c1tpXSA9IGVtcCAmJiBjbG9zZS50byAhPSBlbmQgPyBuZXcgSW5saW5lRGVsaW1pdGVyKGNsb3NlLnR5cGUsIGVuZCwgY2xvc2UudG8sIGNsb3NlLnNpZGUpIDogbnVsbDtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IGVsZW1lbnQgaW4gdGhpcy5wYXJ0c1xuICAgICAgICAgICAgaWYgKGtlZXApXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5zcGxpY2UoaSwgMCwgZWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29sbGVjdCB0aGUgZWxlbWVudHMgcmVtYWluaW5nIGluIHRoaXMucGFydHMgaW50byBhbiBhcnJheS5cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gRmluZCBhbiBvcGVuaW5nIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gdHlwZS4gUmV0dXJucyBgbnVsbGAgaWZcbiAgICAvLy8gbm8gZGVsaW1pdGVyIGlzIGZvdW5kLCBvciBhbiBpbmRleCB0aGF0IGNhbiBiZSBwYXNzZWQgdG9cbiAgICAvLy8gW2B0YWtlQ29udGVudGBdKCNJbmxpbmVDb250ZXh0LnRha2VDb250ZW50KSBvdGhlcndpc2UuXG4gICAgZmluZE9wZW5pbmdEZWxpbWl0ZXIodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBJbmxpbmVEZWxpbWl0ZXIgJiYgcGFydC50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vLyBSZW1vdmUgYWxsIGlubGluZSBlbGVtZW50cyBhbmQgZGVsaW1pdGVycyBzdGFydGluZyBmcm9tIHRoZVxuICAgIC8vLyBnaXZlbiBpbmRleCAod2hpY2ggeW91IHNob3VsZCBnZXQgZnJvbVxuICAgIC8vLyBbYGZpbmRPcGVuaW5nRGVsaW1pdGVyYF0oI0lubGluZUNvbnRleHQuZmluZE9wZW5pbmdEZWxpbWl0ZXIpLFxuICAgIC8vLyByZXNvbHZlIGRlbGltaXRlcnMgaW5zaWRlIG9mIHRoZW0sIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBhcnJheVxuICAgIC8vLyBvZiBlbGVtZW50cy5cbiAgICB0YWtlQ29udGVudChzdGFydEluZGV4KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5yZXNvbHZlTWFya2VycyhzdGFydEluZGV4KTtcbiAgICAgICAgdGhpcy5wYXJ0cy5sZW5ndGggPSBzdGFydEluZGV4O1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgLy8vIFNraXAgc3BhY2UgYWZ0ZXIgdGhlIGdpdmVuIChkb2N1bWVudCkgcG9zaXRpb24sIHJldHVybmluZyBlaXRoZXJcbiAgICAvLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IG5vbi1zcGFjZSBjaGFyYWN0ZXIgb3IgdGhlIGVuZCBvZiB0aGVcbiAgICAvLy8gc2VjdGlvbi5cbiAgICBza2lwU3BhY2UoZnJvbSkgeyByZXR1cm4gc2tpcFNwYWNlKHRoaXMudGV4dCwgZnJvbSAtIHRoaXMub2Zmc2V0KSArIHRoaXMub2Zmc2V0OyB9XG4gICAgZWx0KHR5cGUsIGZyb20sIHRvLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBlbHQodGhpcy5wYXJzZXIuZ2V0Tm9kZVR5cGUodHlwZSksIGZyb20sIHRvLCBjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUVsZW1lbnQodHlwZSwgZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5qZWN0TWFya3MoZWxlbWVudHMsIG1hcmtzKSB7XG4gICAgaWYgKCFtYXJrcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIGxldCBlbHRzID0gZWxlbWVudHMuc2xpY2UoKSwgZUkgPSAwO1xuICAgIGZvciAobGV0IG1hcmsgb2YgbWFya3MpIHtcbiAgICAgICAgd2hpbGUgKGVJIDwgZWx0cy5sZW5ndGggJiYgZWx0c1tlSV0udG8gPCBtYXJrLnRvKVxuICAgICAgICAgICAgZUkrKztcbiAgICAgICAgaWYgKGVJIDwgZWx0cy5sZW5ndGggJiYgZWx0c1tlSV0uZnJvbSA8IG1hcmsuZnJvbSkge1xuICAgICAgICAgICAgbGV0IGUgPSBlbHRzW2VJXTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRWxlbWVudClcbiAgICAgICAgICAgICAgICBlbHRzW2VJXSA9IG5ldyBFbGVtZW50KGUudHlwZSwgZS5mcm9tLCBlLnRvLCBpbmplY3RNYXJrcyhlLmNoaWxkcmVuLCBbbWFya10pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsdHMuc3BsaWNlKGVJKyssIDAsIG1hcmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzO1xufVxuLy8gVGhlc2UgYXJlIGJsb2NrcyB0aGF0IGNhbiBzcGFuIGJsYW5rIGxpbmVzLCBhbmQgc2hvdWxkIHRodXMgb25seSBiZVxuLy8gcmV1c2VkIGlmIHRoZWlyIG5leHQgc2libGluZyBpcyBhbHNvIGJlaW5nIHJldXNlZC5cbmNvbnN0IE5vdExhc3QgPSBbVHlwZS5Db2RlQmxvY2ssIFR5cGUuTGlzdEl0ZW0sIFR5cGUuT3JkZXJlZExpc3QsIFR5cGUuQnVsbGV0TGlzdF07XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBpbnB1dCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGZyYWdtZW50IGFycmF5XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIC8vIEFjdGl2ZSBmcmFnbWVudFxuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnbWVudEVuZCA9IC0xO1xuICAgICAgICAvLyBDdXJzb3IgaW50byB0aGUgY3VycmVudCBmcmFnbWVudCwgaWYgYW55LiBXaGVuIGBtb3ZlVG9gIHJldHVybnNcbiAgICAgICAgLy8gdHJ1ZSwgdGhpcyBwb2ludHMgYXQgdGhlIGZpcnN0IGJsb2NrIGFmdGVyIGBwb3NgLlxuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXSA6IG51bGw7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnbWVudEVuZCA9IC0xO1xuICAgIH1cbiAgICBtb3ZlVG8ocG9zLCBsaW5lU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5mcmFnbWVudC50byA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQgfHwgdGhpcy5mcmFnbWVudC5mcm9tID4gKHBvcyA/IHBvcyAtIDEgOiAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRFbmQgPCAwKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5mcmFnbWVudC50bztcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPiAwICYmIHRoaXMuaW5wdXQucmVhZChlbmQgLSAxLCBlbmQpICE9IFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgZW5kLS07XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50RW5kID0gZW5kID8gZW5kIC0gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGMgPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICBjID0gdGhpcy5jdXJzb3IgPSB0aGlzLmZyYWdtZW50LnRyZWUuY3Vyc29yKCk7XG4gICAgICAgICAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgclBvcyA9IHBvcyArIHRoaXMuZnJhZ21lbnQub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoYy50byA8PSByUG9zKVxuICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA+PSByUG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZyb20gPD0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgaWYgKCFjLmNoaWxkQWZ0ZXIoclBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoZXMoaGFzaCkge1xuICAgICAgICBsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7XG4gICAgICAgIHJldHVybiB0cmVlICYmIHRyZWUucHJvcChOb2RlUHJvcC5jb250ZXh0SGFzaCkgPT0gaGFzaDtcbiAgICB9XG4gICAgdGFrZU5vZGVzKGN4KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzLmN1cnNvciwgb2ZmID0gdGhpcy5mcmFnbWVudC5vZmZzZXQsIGZyYWdFbmQgPSB0aGlzLmZyYWdtZW50RW5kIC0gKHRoaXMuZnJhZ21lbnQub3BlbkVuZCA/IDEgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gY3guYWJzb2x1dGVMaW5lU3RhcnQsIGVuZCA9IHN0YXJ0LCBibG9ja0kgPSBjeC5ibG9jay5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBwcmV2RW5kID0gZW5kLCBwcmV2SSA9IGJsb2NrSTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGN1ci50byAtIG9mZiA+IGZyYWdFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnR5cGUuaXNBbm9ueW1vdXMgJiYgY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9zID0gdG9SZWxhdGl2ZShjdXIuZnJvbSAtIG9mZiwgY3gucmFuZ2VzKTtcbiAgICAgICAgICAgIGlmIChjdXIudG8gLSBvZmYgPD0gY3gucmFuZ2VzW2N4LnJhbmdlSV0udG8pIHsgLy8gRml0cyBpbiBjdXJyZW50IHJhbmdlXG4gICAgICAgICAgICAgICAgY3guYWRkTm9kZShjdXIudHJlZSwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkdW1teSA9IG5ldyBUcmVlKGN4LnBhcnNlci5ub2RlU2V0LnR5cGVzW1R5cGUuUGFyYWdyYXBoXSwgW10sIFtdLCAwLCBjeC5ibG9jay5oYXNoUHJvcCk7XG4gICAgICAgICAgICAgICAgY3gucmV1c2VQbGFjZWhvbGRlcnMuc2V0KGR1bW15LCBjdXIudHJlZSk7XG4gICAgICAgICAgICAgICAgY3guYWRkTm9kZShkdW1teSwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRha2VuIGNvbnRlbnQgbXVzdCBhbHdheXMgZW5kIGluIGEgYmxvY2ssIGJlY2F1c2UgaW5jcmVtZW50YWxcbiAgICAgICAgICAgIC8vIHBhcnNpbmcgaGFwcGVucyBvbiBibG9jayBib3VuZGFyaWVzLiBOZXZlciBzdG9wIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBhZnRlciBhbiBpbmRlbnRlZCBjb2RlIGJsb2NrLCBzaW5jZSB0aG9zZSBjYW4gY29udGludWUgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGFueSBudW1iZXIgb2YgYmxhbmsgbGluZXMuXG4gICAgICAgICAgICBpZiAoY3VyLnR5cGUuaXMoXCJCbG9ja1wiKSkge1xuICAgICAgICAgICAgICAgIGlmIChOb3RMYXN0LmluZGV4T2YoY3VyLnR5cGUuaWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBjdXIudG8gLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSSA9IGN4LmJsb2NrLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSSA9IHByZXZJO1xuICAgICAgICAgICAgICAgICAgICBwcmV2RW5kID0gY3VyLnRvIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICBwcmV2SSA9IGN4LmJsb2NrLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjeC5ibG9jay5jaGlsZHJlbi5sZW5ndGggPiBibG9ja0kpIHtcbiAgICAgICAgICAgIGN4LmJsb2NrLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICAgICAgY3guYmxvY2sucG9zaXRpb25zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgICB9XG59XG4vLyBDb252ZXJ0IGFuIGlucHV0LXN0cmVhbS1yZWxhdGl2ZSBwb3NpdGlvbiB0byBhXG4vLyBNYXJrZG93bi1kb2MtcmVsYXRpdmUgcG9zaXRpb24gYnkgc3VidHJhY3RpbmcgdGhlIHNpemUgb2YgYWxsIGlucHV0XG4vLyBnYXBzIGJlZm9yZSBgYWJzYC5cbmZ1bmN0aW9uIHRvUmVsYXRpdmUoYWJzLCByYW5nZXMpIHtcbiAgICBsZXQgcG9zID0gYWJzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gcmFuZ2VzW2kgLSAxXS50bywgZ2FwVG8gPSByYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgaWYgKGdhcEZyb20gPCBhYnMpXG4gICAgICAgICAgICBwb3MgLT0gZ2FwVG8gLSBnYXBGcm9tO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgbWFya2Rvd25IaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICAgIFwiQmxvY2txdW90ZS8uLi5cIjogdGFncy5xdW90ZSxcbiAgICBIb3Jpem9udGFsUnVsZTogdGFncy5jb250ZW50U2VwYXJhdG9yLFxuICAgIFwiQVRYSGVhZGluZzEvLi4uIFNldGV4dEhlYWRpbmcxLy4uLlwiOiB0YWdzLmhlYWRpbmcxLFxuICAgIFwiQVRYSGVhZGluZzIvLi4uIFNldGV4dEhlYWRpbmcyLy4uLlwiOiB0YWdzLmhlYWRpbmcyLFxuICAgIFwiQVRYSGVhZGluZzMvLi4uXCI6IHRhZ3MuaGVhZGluZzMsXG4gICAgXCJBVFhIZWFkaW5nNC8uLi5cIjogdGFncy5oZWFkaW5nNCxcbiAgICBcIkFUWEhlYWRpbmc1Ly4uLlwiOiB0YWdzLmhlYWRpbmc1LFxuICAgIFwiQVRYSGVhZGluZzYvLi4uXCI6IHRhZ3MuaGVhZGluZzYsXG4gICAgXCJDb21tZW50IENvbW1lbnRCbG9ja1wiOiB0YWdzLmNvbW1lbnQsXG4gICAgRXNjYXBlOiB0YWdzLmVzY2FwZSxcbiAgICBFbnRpdHk6IHRhZ3MuY2hhcmFjdGVyLFxuICAgIFwiRW1waGFzaXMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4gICAgXCJTdHJvbmdFbXBoYXNpcy8uLi5cIjogdGFncy5zdHJvbmcsXG4gICAgXCJMaW5rLy4uLiBJbWFnZS8uLi5cIjogdGFncy5saW5rLFxuICAgIFwiT3JkZXJlZExpc3QvLi4uIEJ1bGxldExpc3QvLi4uXCI6IHRhZ3MubGlzdCxcbiAgICBcIkJsb2NrUXVvdGUvLi4uXCI6IHRhZ3MucXVvdGUsXG4gICAgXCJJbmxpbmVDb2RlIENvZGVUZXh0XCI6IHRhZ3MubW9ub3NwYWNlLFxuICAgIFwiVVJMIEF1dG9saW5rXCI6IHRhZ3MudXJsLFxuICAgIFwiSGVhZGVyTWFyayBIYXJkQnJlYWsgUXVvdGVNYXJrIExpc3RNYXJrIExpbmtNYXJrIEVtcGhhc2lzTWFyayBDb2RlTWFya1wiOiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbixcbiAgICBcIkNvZGVJbmZvIExpbmtMYWJlbFwiOiB0YWdzLmxhYmVsTmFtZSxcbiAgICBMaW5rVGl0bGU6IHRhZ3Muc3RyaW5nLFxuICAgIFBhcmFncmFwaDogdGFncy5jb250ZW50XG59KTtcbi8vLyBUaGUgZGVmYXVsdCBDb21tb25NYXJrIHBhcnNlci5cbmNvbnN0IHBhcnNlciA9IG5ldyBNYXJrZG93blBhcnNlcihuZXcgTm9kZVNldChub2RlVHlwZXMpLmV4dGVuZChtYXJrZG93bkhpZ2hsaWdodGluZyksIE9iamVjdC5rZXlzKERlZmF1bHRCbG9ja1BhcnNlcnMpLm1hcChuID0+IERlZmF1bHRCbG9ja1BhcnNlcnNbbl0pLCBPYmplY3Qua2V5cyhEZWZhdWx0QmxvY2tQYXJzZXJzKS5tYXAobiA9PiBEZWZhdWx0TGVhZkJsb2Nrc1tuXSksIE9iamVjdC5rZXlzKERlZmF1bHRCbG9ja1BhcnNlcnMpLCBEZWZhdWx0RW5kTGVhZiwgRGVmYXVsdFNraXBNYXJrdXAsIE9iamVjdC5rZXlzKERlZmF1bHRJbmxpbmUpLm1hcChuID0+IERlZmF1bHRJbmxpbmVbbl0pLCBPYmplY3Qua2V5cyhEZWZhdWx0SW5saW5lKSwgW10pO1xuXG5mdW5jdGlvbiBsZWZ0T3ZlclNwYWNlKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSBub2RlLmZpcnN0Q2hpbGQsIHBvcyA9IGZyb207OyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgbmV4dFBvcyA9IG4gPyBuLmZyb20gOiB0bztcbiAgICAgICAgaWYgKG5leHRQb3MgPiBwb3MpXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IG5leHRQb3MgfSk7XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBuLnRvO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8vIENyZWF0ZSBhIE1hcmtkb3duIGV4dGVuc2lvbiB0byBlbmFibGUgbmVzdGVkIHBhcnNpbmcgb24gY29kZVxuLy8vIGJsb2NrcyBhbmQvb3IgZW1iZWRkZWQgSFRNTC5cbmZ1bmN0aW9uIHBhcnNlQ29kZShjb25maWcpIHtcbiAgICBsZXQgeyBjb2RlUGFyc2VyLCBodG1sUGFyc2VyIH0gPSBjb25maWc7XG4gICAgbGV0IHdyYXAgPSBwYXJzZU1peGVkKChub2RlLCBpbnB1dCkgPT4ge1xuICAgICAgICBsZXQgaWQgPSBub2RlLnR5cGUuaWQ7XG4gICAgICAgIGlmIChjb2RlUGFyc2VyICYmIChpZCA9PSBUeXBlLkNvZGVCbG9jayB8fCBpZCA9PSBUeXBlLkZlbmNlZENvZGUpKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoaWQgPT0gVHlwZS5GZW5jZWRDb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZm9Ob2RlID0gbm9kZS5ub2RlLmdldENoaWxkKFR5cGUuQ29kZUluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgaW5mbyA9IGlucHV0LnJlYWQoaW5mb05vZGUuZnJvbSwgaW5mb05vZGUudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlciA9IGNvZGVQYXJzZXIoaW5mbyk7XG4gICAgICAgICAgICBpZiAocGFyc2VyKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcnNlciwgb3ZlcmxheTogbm9kZSA9PiBub2RlLnR5cGUuaWQgPT0gVHlwZS5Db2RlVGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGh0bWxQYXJzZXIgJiYgKGlkID09IFR5cGUuSFRNTEJsb2NrIHx8IGlkID09IFR5cGUuSFRNTFRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHBhcnNlcjogaHRtbFBhcnNlciwgb3ZlcmxheTogbGVmdE92ZXJTcGFjZShub2RlLm5vZGUsIG5vZGUuZnJvbSwgbm9kZS50bykgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICByZXR1cm4geyB3cmFwIH07XG59XG5cbmNvbnN0IFN0cmlrZXRocm91Z2hEZWxpbSA9IHsgcmVzb2x2ZTogXCJTdHJpa2V0aHJvdWdoXCIsIG1hcms6IFwiU3RyaWtldGhyb3VnaE1hcmtcIiB9O1xuLy8vIEFuIGV4dGVuc2lvbiB0aGF0IGltcGxlbWVudHNcbi8vLyBbR0ZNLXN0eWxlXShodHRwczovL2dpdGh1Yi5naXRodWIuY29tL2dmbS8jc3RyaWtldGhyb3VnaC1leHRlbnNpb24tKVxuLy8vIFN0cmlrZXRocm91Z2ggc3ludGF4IHVzaW5nIGB+fmAgZGVsaW1pdGVycy5cbmNvbnN0IFN0cmlrZXRocm91Z2ggPSB7XG4gICAgZGVmaW5lTm9kZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmlrZXRocm91Z2hcIixcbiAgICAgICAgICAgIHN0eWxlOiB7IFwiU3RyaWtldGhyb3VnaC8uLi5cIjogdGFncy5zdHJpa2V0aHJvdWdoIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpa2V0aHJvdWdoTWFya1wiLFxuICAgICAgICAgICAgc3R5bGU6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uXG4gICAgICAgIH1dLFxuICAgIHBhcnNlSW5saW5lOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJTdHJpa2V0aHJvdWdoXCIsXG4gICAgICAgICAgICBwYXJzZShjeCwgbmV4dCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gMTI2IC8qICd+JyAqLyB8fCBjeC5jaGFyKHBvcyArIDEpICE9IDEyNiB8fCBjeC5jaGFyKHBvcyArIDIpID09IDEyNilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBjeC5zbGljZShwb3MgLSAxLCBwb3MpLCBhZnRlciA9IGN4LnNsaWNlKHBvcyArIDIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICAgIGxldCBzQmVmb3JlID0gL1xcc3xeJC8udGVzdChiZWZvcmUpLCBzQWZ0ZXIgPSAvXFxzfF4kLy50ZXN0KGFmdGVyKTtcbiAgICAgICAgICAgICAgICBsZXQgcEJlZm9yZSA9IFB1bmN0dWF0aW9uLnRlc3QoYmVmb3JlKSwgcEFmdGVyID0gUHVuY3R1YXRpb24udGVzdChhZnRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN4LmFkZERlbGltaXRlcihTdHJpa2V0aHJvdWdoRGVsaW0sIHBvcywgcG9zICsgMiwgIXNBZnRlciAmJiAoIXBBZnRlciB8fCBzQmVmb3JlIHx8IHBCZWZvcmUpLCAhc0JlZm9yZSAmJiAoIXBCZWZvcmUgfHwgc0FmdGVyIHx8IHBBZnRlcikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyOiBcIkVtcGhhc2lzXCJcbiAgICAgICAgfV1cbn07XG5mdW5jdGlvbiBwYXJzZVJvdyhjeCwgbGluZSwgc3RhcnRJID0gMCwgZWx0cywgb2Zmc2V0ID0gMCkge1xuICAgIGxldCBjb3VudCA9IDAsIGZpcnN0ID0gdHJ1ZSwgY2VsbFN0YXJ0ID0gLTEsIGNlbGxFbmQgPSAtMSwgZXNjID0gZmFsc2U7XG4gICAgbGV0IHBhcnNlQ2VsbCA9ICgpID0+IHtcbiAgICAgICAgZWx0cy5wdXNoKGN4LmVsdChcIlRhYmxlQ2VsbFwiLCBvZmZzZXQgKyBjZWxsU3RhcnQsIG9mZnNldCArIGNlbGxFbmQsIGN4LnBhcnNlci5wYXJzZUlubGluZShsaW5lLnNsaWNlKGNlbGxTdGFydCwgY2VsbEVuZCksIG9mZnNldCArIGNlbGxTdGFydCkpKTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbGluZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAobmV4dCA9PSAxMjQgLyogJ3wnICovICYmICFlc2MpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QgfHwgY2VsbFN0YXJ0ID4gLTEpXG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsU3RhcnQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgZWx0cy5wdXNoKGN4LmVsdChcIlRhYmxlRGVsaW1pdGVyXCIsIGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQgKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsU3RhcnQgPSBjZWxsRW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXNjIHx8IG5leHQgIT0gMzIgJiYgbmV4dCAhPSA5KSB7XG4gICAgICAgICAgICBpZiAoY2VsbFN0YXJ0IDwgMClcbiAgICAgICAgICAgICAgICBjZWxsU3RhcnQgPSBpO1xuICAgICAgICAgICAgY2VsbEVuZCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVzYyA9ICFlc2MgJiYgbmV4dCA9PSA5MjtcbiAgICB9XG4gICAgaWYgKGNlbGxTdGFydCA+IC0xKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChlbHRzKVxuICAgICAgICAgICAgcGFyc2VDZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGhhc1BpcGUoc3RyLCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmV4dCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAobmV4dCA9PSAxMjQgLyogJ3wnICovKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChuZXh0ID09IDkyIC8qICdcXFxcJyAqLylcbiAgICAgICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgZGVsaW1pdGVyTGluZSA9IC9eXFx8PyhcXHMqOj8tKzo/XFxzKlxcfCkrKFxccyo6Py0rOj9cXHMqKT8kLztcbmNsYXNzIFRhYmxlUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gTnVsbCBtZWFucyB3ZSBoYXZlbid0IHNlZW4gdGhlIHNlY29uZCBsaW5lIHlldCwgZmFsc2UgbWVhbnMgdGhpc1xuICAgICAgICAvLyBpc24ndCBhIHRhYmxlLCBhbmQgYW4gYXJyYXkgbWVhbnMgdGhpcyBpcyBhIHRhYmxlIGFuZCB3ZSd2ZVxuICAgICAgICAvLyBwYXJzZWQgdGhlIGdpdmVuIHJvd3Mgc28gZmFyLlxuICAgICAgICB0aGlzLnJvd3MgPSBudWxsO1xuICAgIH1cbiAgICBuZXh0TGluZShjeCwgbGluZSwgbGVhZikge1xuICAgICAgICBpZiAodGhpcy5yb3dzID09IG51bGwpIHsgLy8gU2Vjb25kIGxpbmVcbiAgICAgICAgICAgIHRoaXMucm93cyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGxpbmVUZXh0O1xuICAgICAgICAgICAgaWYgKChsaW5lLm5leHQgPT0gNDUgfHwgbGluZS5uZXh0ID09IDU4IHx8IGxpbmUubmV4dCA9PSAxMjQgLyogJy06fCcgKi8pICYmXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyTGluZS50ZXN0KGxpbmVUZXh0ID0gbGluZS50ZXh0LnNsaWNlKGxpbmUucG9zKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RSb3cgPSBbXSwgZmlyc3RDb3VudCA9IHBhcnNlUm93KGN4LCBsZWFmLmNvbnRlbnQsIDAsIGZpcnN0Um93LCBsZWFmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb3VudCA9PSBwYXJzZVJvdyhjeCwgbGluZVRleHQsIGxpbmUucG9zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gW2N4LmVsdChcIlRhYmxlSGVhZGVyXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyBsZWFmLmNvbnRlbnQubGVuZ3RoLCBmaXJzdFJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjeC5lbHQoXCJUYWJsZURlbGltaXRlclwiLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucm93cykgeyAvLyBMaW5lIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBwYXJzZVJvdyhjeCwgbGluZS50ZXh0LCBsaW5lLnBvcywgY29udGVudCwgY3gubGluZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKGN4LmVsdChcIlRhYmxlUm93XCIsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoLCBjb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmaW5pc2goY3gsIGxlYWYpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvd3MpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN4LmFkZExlYWZFbGVtZW50KGxlYWYsIGN4LmVsdChcIlRhYmxlXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyBsZWFmLmNvbnRlbnQubGVuZ3RoLCB0aGlzLnJvd3MpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8vIFRoaXMgZXh0ZW5zaW9uIHByb3ZpZGVzXG4vLy8gW0dGTS1zdHlsZV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3RhYmxlcy1leHRlbnNpb24tKVxuLy8vIHRhYmxlcywgdXNpbmcgc3ludGF4IGxpa2UgdGhpczpcbi8vL1xuLy8vIGBgYFxuLy8vIHwgaGVhZCAxIHwgaGVhZCAyIHxcbi8vLyB8IC0tLSAgICB8IC0tLSAgICB8XG4vLy8gfCBjZWxsIDEgfCBjZWxsIDIgfFxuLy8vIGBgYFxuY29uc3QgVGFibGUgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlRhYmxlXCIsIGJsb2NrOiB0cnVlIH0sXG4gICAgICAgIHsgbmFtZTogXCJUYWJsZUhlYWRlclwiLCBzdHlsZTogeyBcIlRhYmxlSGVhZGVyLy4uLlwiOiB0YWdzLmhlYWRpbmcgfSB9LFxuICAgICAgICBcIlRhYmxlUm93XCIsXG4gICAgICAgIHsgbmFtZTogXCJUYWJsZUNlbGxcIiwgc3R5bGU6IHRhZ3MuY29udGVudCB9LFxuICAgICAgICB7IG5hbWU6IFwiVGFibGVEZWxpbWl0ZXJcIiwgc3R5bGU6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uIH0sXG4gICAgXSxcbiAgICBwYXJzZUJsb2NrOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJUYWJsZVwiLFxuICAgICAgICAgICAgbGVhZihfLCBsZWFmKSB7IHJldHVybiBoYXNQaXBlKGxlYWYuY29udGVudCwgMCkgPyBuZXcgVGFibGVQYXJzZXIgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW5kTGVhZihjeCwgbGluZSwgbGVhZikge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmLnBhcnNlcnMuc29tZShwID0+IHAgaW5zdGFuY2VvZiBUYWJsZVBhcnNlcikgfHwgIWhhc1BpcGUobGluZS50ZXh0LCBsaW5lLmJhc2VQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjeC5zY2FuTGluZShjeC5hYnNvbHV0ZUxpbmVFbmQgKyAxKS50ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWxpbWl0ZXJMaW5lLnRlc3QobmV4dCkgJiYgcGFyc2VSb3coY3gsIGxpbmUudGV4dCwgbGluZS5iYXNlUG9zKSA9PSBwYXJzZVJvdyhjeCwgbmV4dCwgbGluZS5iYXNlUG9zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmU6IFwiU2V0ZXh0SGVhZGluZ1wiXG4gICAgICAgIH1dXG59O1xuY2xhc3MgVGFza1BhcnNlciB7XG4gICAgbmV4dExpbmUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZpbmlzaChjeCwgbGVhZikge1xuICAgICAgICBjeC5hZGRMZWFmRWxlbWVudChsZWFmLCBjeC5lbHQoXCJUYXNrXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyBsZWFmLmNvbnRlbnQubGVuZ3RoLCBbXG4gICAgICAgICAgICBjeC5lbHQoXCJUYXNrTWFya2VyXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyAzKSxcbiAgICAgICAgICAgIC4uLmN4LnBhcnNlci5wYXJzZUlubGluZShsZWFmLmNvbnRlbnQuc2xpY2UoMyksIGxlYWYuc3RhcnQgKyAzKVxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vLyBFeHRlbnNpb24gcHJvdmlkaW5nXG4vLy8gW0dGTS1zdHlsZV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3Rhc2stbGlzdC1pdGVtcy1leHRlbnNpb24tKVxuLy8vIHRhc2sgbGlzdCBpdGVtcywgd2hlcmUgbGlzdCBpdGVtcyBjYW4gYmUgcHJlZml4ZWQgd2l0aCBgWyBdYCBvclxuLy8vIGBbeF1gIHRvIGFkZCBhIGNoZWNrYm94LlxuY29uc3QgVGFza0xpc3QgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlRhc2tcIiwgYmxvY2s6IHRydWUsIHN0eWxlOiB0YWdzLmxpc3QgfSxcbiAgICAgICAgeyBuYW1lOiBcIlRhc2tNYXJrZXJcIiwgc3R5bGU6IHRhZ3MuYXRvbSB9XG4gICAgXSxcbiAgICBwYXJzZUJsb2NrOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJUYXNrTGlzdFwiLFxuICAgICAgICAgICAgbGVhZihjeCwgbGVhZikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXlxcW1sgeFhdXFxdWyBcXHRdLy50ZXN0KGxlYWYuY29udGVudCkgJiYgY3gucGFyZW50VHlwZSgpLm5hbWUgPT0gXCJMaXN0SXRlbVwiID8gbmV3IFRhc2tQYXJzZXIgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyOiBcIlNldGV4dEhlYWRpbmdcIlxuICAgICAgICB9XVxufTtcbmNvbnN0IGF1dG9saW5rUkUgPSAvKHd3d1xcLil8KGh0dHBzPzpcXC9cXC8pfChbXFx3ListXStAKXwobWFpbHRvOnx4bXBwOikvZ3k7XG5jb25zdCB1cmxSRSA9IC9bXFx3LV0rKFxcLltcXHctXSspKyhcXC9bXlxcczxdKik/L2d5O1xuY29uc3QgbGFzdFR3b0RvbWFpbldvcmRzID0gL1tcXHctXStcXC5bXFx3LV0rKCR8XFwvKS87XG5jb25zdCBlbWFpbFJFID0gL1tcXHcuKy1dK0BbXFx3LV0rKFxcLltcXHcuLV0rKSsvZ3k7XG5jb25zdCB4bXBwUmVzb3VyY2VSRSA9IC9cXC9bYS16QS1aXFxkQC5dKy9neTtcbmZ1bmN0aW9uIGNvdW50KHN0ciwgZnJvbSwgdG8sIGNoKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICBpZiAoc3RyW2ldID09IGNoKVxuICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGF1dG9saW5rVVJMRW5kKHRleHQsIGZyb20pIHtcbiAgICB1cmxSRS5sYXN0SW5kZXggPSBmcm9tO1xuICAgIGxldCBtID0gdXJsUkUuZXhlYyh0ZXh0KTtcbiAgICBpZiAoIW0gfHwgbGFzdFR3b0RvbWFpbldvcmRzLmV4ZWMobVswXSlbMF0uaW5kZXhPZihcIl9cIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBlbmQgPSBmcm9tICsgbVswXS5sZW5ndGg7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbGFzdCA9IHRleHRbZW5kIC0gMV0sIG07XG4gICAgICAgIGlmICgvWz8hLiw6Kl9+XS8udGVzdChsYXN0KSB8fFxuICAgICAgICAgICAgbGFzdCA9PSBcIilcIiAmJiBjb3VudCh0ZXh0LCBmcm9tLCBlbmQsIFwiKVwiKSA+IGNvdW50KHRleHQsIGZyb20sIGVuZCwgXCIoXCIpKVxuICAgICAgICAgICAgZW5kLS07XG4gICAgICAgIGVsc2UgaWYgKGxhc3QgPT0gXCI7XCIgJiYgKG0gPSAvJig/OiNcXGQrfCN4W2EtZlxcZF0rfFxcdyspOyQvLmV4ZWModGV4dC5zbGljZShmcm9tLCBlbmQpKSkpXG4gICAgICAgICAgICBlbmQgPSBmcm9tICsgbS5pbmRleDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBhdXRvbGlua0VtYWlsRW5kKHRleHQsIGZyb20pIHtcbiAgICBlbWFpbFJFLmxhc3RJbmRleCA9IGZyb207XG4gICAgbGV0IG0gPSBlbWFpbFJFLmV4ZWModGV4dCk7XG4gICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGxhc3QgPSBtWzBdW21bMF0ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3QgPT0gXCJfXCIgfHwgbGFzdCA9PSBcIi1cIiA/IC0xIDogZnJvbSArIG1bMF0ubGVuZ3RoIC0gKGxhc3QgPT0gXCIuXCIgPyAxIDogMCk7XG59XG4vLy8gRXh0ZW5zaW9uIHRoYXQgaW1wbGVtZW50cyBhdXRvbGlua2luZyBmb3Jcbi8vLyBgd3d3LmAvYGh0dHA6Ly9gL2BodHRwczovL2AvYG1haWx0bzpgL2B4bXBwOmAgVVJMcyBhbmQgZW1haWxcbi8vLyBhZGRyZXNzZXMuXG5jb25zdCBBdXRvbGluayA9IHtcbiAgICBwYXJzZUlubGluZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiQXV0b2xpbmtcIixcbiAgICAgICAgICAgIHBhcnNlKGN4LCBuZXh0LCBhYnNQb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gYWJzUG9zIC0gY3gub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF1dG9saW5rUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICAgICAgICAgIGxldCBtID0gYXV0b2xpbmtSRS5leGVjKGN4LnRleHQpLCBlbmQgPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobVsxXSB8fCBtWzJdKSB7IC8vIHd3dy4sIGh0dHA6Ly9cbiAgICAgICAgICAgICAgICAgICAgZW5kID0gYXV0b2xpbmtVUkxFbmQoY3gudGV4dCwgcG9zICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gLTEgJiYgY3guaGFzT3BlbkxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub0JyYWNrZXQgPSAvKFteXFxbXFxdXXxcXFtbXlxcXV0qXFxdKSovLmV4ZWMoY3gudGV4dC5zbGljZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gcG9zICsgbm9CcmFja2V0WzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtWzNdKSB7IC8vIGVtYWlsIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gYXV0b2xpbmtFbWFpbEVuZChjeC50ZXh0LCBwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gbWFpbHRvOi94bXBwOlxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhdXRvbGlua0VtYWlsRW5kKGN4LnRleHQsIHBvcyArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IC0xICYmIG1bMF0gPT0gXCJ4bXBwOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bXBwUmVzb3VyY2VSRS5sYXN0SW5kZXggPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0geG1wcFJlc291cmNlUkUuZXhlYyhjeC50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGN4LmFkZEVsZW1lbnQoY3guZWx0KFwiVVJMXCIsIGFic1BvcywgZW5kICsgY3gub2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZCArIGN4Lm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbn07XG4vLy8gRXh0ZW5zaW9uIGJ1bmRsZSBjb250YWluaW5nIFtgVGFibGVgXSgjVGFibGUpLFxuLy8vIFtgVGFza0xpc3RgXSgjVGFza0xpc3QpLCBbYFN0cmlrZXRocm91Z2hgXSgjU3RyaWtldGhyb3VnaCksIGFuZFxuLy8vIFtgQXV0b2xpbmtgXSgjQXV0b2xpbmspLlxuY29uc3QgR0ZNID0gW1RhYmxlLCBUYXNrTGlzdCwgU3RyaWtldGhyb3VnaCwgQXV0b2xpbmtdO1xuZnVuY3Rpb24gcGFyc2VTdWJTdXBlcihjaCwgbm9kZSwgbWFyaykge1xuICAgIHJldHVybiAoY3gsIG5leHQsIHBvcykgPT4ge1xuICAgICAgICBpZiAobmV4dCAhPSBjaCB8fCBjeC5jaGFyKHBvcyArIDEpID09IGNoKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgZWx0cyA9IFtjeC5lbHQobWFyaywgcG9zLCBwb3MgKyAxKV07XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3MgKyAxOyBpIDwgY3guZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3guY2hhcihpKTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGNoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjeC5hZGRFbGVtZW50KGN4LmVsdChub2RlLCBwb3MsIGkgKyAxLCBlbHRzLmNvbmNhdChjeC5lbHQobWFyaywgaSwgaSArIDEpKSkpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gOTIgLyogJ1xcXFwnICovKVxuICAgICAgICAgICAgICAgIGVsdHMucHVzaChjeC5lbHQoXCJFc2NhcGVcIiwgaSwgaSsrICsgMikpO1xuICAgICAgICAgICAgaWYgKHNwYWNlKG5leHQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuLy8vIEV4dGVuc2lvbiBwcm92aWRpbmdcbi8vLyBbUGFuZG9jLXN0eWxlXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjc3VwZXJzY3JpcHRzLWFuZC1zdWJzY3JpcHRzKVxuLy8vIHN1cGVyc2NyaXB0IHVzaW5nIGBeYCBtYXJrZXJzLlxuY29uc3QgU3VwZXJzY3JpcHQgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlN1cGVyc2NyaXB0XCIsIHN0eWxlOiB0YWdzLnNwZWNpYWwodGFncy5jb250ZW50KSB9LFxuICAgICAgICB7IG5hbWU6IFwiU3VwZXJzY3JpcHRNYXJrXCIsIHN0eWxlOiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiB9XG4gICAgXSxcbiAgICBwYXJzZUlubGluZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiU3VwZXJzY3JpcHRcIixcbiAgICAgICAgICAgIHBhcnNlOiBwYXJzZVN1YlN1cGVyKDk0IC8qICdeJyAqLywgXCJTdXBlcnNjcmlwdFwiLCBcIlN1cGVyc2NyaXB0TWFya1wiKVxuICAgICAgICB9XVxufTtcbi8vLyBFeHRlbnNpb24gcHJvdmlkaW5nXG4vLy8gW1BhbmRvYy1zdHlsZV0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI3N1cGVyc2NyaXB0cy1hbmQtc3Vic2NyaXB0cylcbi8vLyBzdWJzY3JpcHQgdXNpbmcgYH5gIG1hcmtlcnMuXG5jb25zdCBTdWJzY3JpcHQgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlN1YnNjcmlwdFwiLCBzdHlsZTogdGFncy5zcGVjaWFsKHRhZ3MuY29udGVudCkgfSxcbiAgICAgICAgeyBuYW1lOiBcIlN1YnNjcmlwdE1hcmtcIiwgc3R5bGU6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uIH1cbiAgICBdLFxuICAgIHBhcnNlSW5saW5lOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJTdWJzY3JpcHRcIixcbiAgICAgICAgICAgIHBhcnNlOiBwYXJzZVN1YlN1cGVyKDEyNiAvKiAnficgKi8sIFwiU3Vic2NyaXB0XCIsIFwiU3Vic2NyaXB0TWFya1wiKVxuICAgICAgICB9XVxufTtcbi8vLyBFeHRlbnNpb24gdGhhdCBwYXJzZXMgdHdvIGNvbG9ucyB3aXRoIG9ubHkgbGV0dGVycywgdW5kZXJzY29yZXMsXG4vLy8gYW5kIG51bWJlcnMgYmV0d2VlbiB0aGVtIGFzIGBFbW9qaWAgbm9kZXMuXG5jb25zdCBFbW9qaSA9IHtcbiAgICBkZWZpbmVOb2RlczogW3sgbmFtZTogXCJFbW9qaVwiLCBzdHlsZTogdGFncy5jaGFyYWN0ZXIgfV0sXG4gICAgcGFyc2VJbmxpbmU6IFt7XG4gICAgICAgICAgICBuYW1lOiBcIkVtb2ppXCIsXG4gICAgICAgICAgICBwYXJzZShjeCwgbmV4dCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IDU4IC8qICc6JyAqLyB8fCAhKG1hdGNoID0gL15bYS16QS1aXzAtOV0rOi8uZXhlYyhjeC5zbGljZShwb3MgKyAxLCBjeC5lbmQpKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3guYWRkRWxlbWVudChjeC5lbHQoXCJFbW9qaVwiLCBwb3MsIHBvcyArIDEgKyBtYXRjaFswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbn07XG5cbmV4cG9ydCB7IEF1dG9saW5rLCBCbG9ja0NvbnRleHQsIEVsZW1lbnQsIEVtb2ppLCBHRk0sIElubGluZUNvbnRleHQsIExlYWZCbG9jaywgTGluZSwgTWFya2Rvd25QYXJzZXIsIFN0cmlrZXRocm91Z2gsIFN1YnNjcmlwdCwgU3VwZXJzY3JpcHQsIFRhYmxlLCBUYXNrTGlzdCwgcGFyc2VDb2RlLCBwYXJzZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==