(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter_ydoc_lib_index_js-node_modules_process_browser_js"],{

/***/ "./node_modules/@jupyter/ydoc/lib/api.js":
/*!***********************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/api.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/awareness.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/awareness.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

//# sourceMappingURL=awareness.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YBaseCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YBaseCell),
/* harmony export */   YCodeCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YCodeCell),
/* harmony export */   YDocument: () => (/* reexport safe */ _ydocument_js__WEBPACK_IMPORTED_MODULE_4__.YDocument),
/* harmony export */   YFile: () => (/* reexport safe */ _yfile_js__WEBPACK_IMPORTED_MODULE_5__.YFile),
/* harmony export */   YMarkdownCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YMarkdownCell),
/* harmony export */   YNotebook: () => (/* reexport safe */ _ynotebook_js__WEBPACK_IMPORTED_MODULE_6__.YNotebook),
/* harmony export */   YRawCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YRawCell),
/* harmony export */   convertYMapEventToMapChange: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.convertYMapEventToMapChange),
/* harmony export */   createMutex: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.createMutex),
/* harmony export */   createStandaloneCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.createStandaloneCell)
/* harmony export */ });
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ "./node_modules/@jupyter/ydoc/lib/api.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@jupyter/ydoc/lib/utils.js");
/* harmony import */ var _awareness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./awareness.js */ "./node_modules/@jupyter/ydoc/lib/awareness.js");
/* harmony import */ var _ytext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ytext.js */ "./node_modules/@jupyter/ydoc/lib/ytext.js");
/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ydocument.js */ "./node_modules/@jupyter/ydoc/lib/ydocument.js");
/* harmony import */ var _yfile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./yfile.js */ "./node_modules/@jupyter/ydoc/lib/yfile.js");
/* harmony import */ var _ynotebook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ynotebook.js */ "./node_modules/@jupyter/ydoc/lib/ynotebook.js");
/* harmony import */ var _ycell_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ycell.js */ "./node_modules/@jupyter/ydoc/lib/ycell.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module ydoc
 */








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertYMapEventToMapChange: () => (/* binding */ convertYMapEventToMapChange),
/* harmony export */   createMutex: () => (/* binding */ createMutex)
/* harmony export */ });
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
function convertYMapEventToMapChange(event) {
    let changes = new Map();
    event.changes.keys.forEach((event, key) => {
        changes.set(key, {
            action: event.action,
            oldValue: event.oldValue,
            newValue: this.ymeta.get(key)
        });
    });
    return changes;
}
/**
 * Creates a mutual exclude function with the following property:
 *
 * ```js
 * const mutex = createMutex()
 * mutex(() => {
 *   // This function is immediately executed
 *   mutex(() => {
 *     // This function is not executed, as the mutex is already active.
 *   })
 * })
 * ```
 */
const createMutex = () => {
    let token = true;
    return (f) => {
        if (token) {
            token = false;
            try {
                f();
            }
            finally {
                token = true;
            }
        }
    };
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/ycell.js":
/*!*************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/ycell.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YBaseCell: () => (/* binding */ YBaseCell),
/* harmony export */   YCodeCell: () => (/* binding */ YCodeCell),
/* harmony export */   YMarkdownCell: () => (/* binding */ YMarkdownCell),
/* harmony export */   YRawCell: () => (/* binding */ YRawCell),
/* harmony export */   createCell: () => (/* binding */ createCell),
/* harmony export */   createCellModelFromSharedType: () => (/* binding */ createCellModelFromSharedType),
/* harmony export */   createStandaloneCell: () => (/* binding */ createStandaloneCell)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness */ "./node_modules/y-protocols/awareness.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_3__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * Create a new shared cell model given the YJS shared type.
 */
const createCellModelFromSharedType = (type, options = {}) => {
    switch (type.get('cell_type')) {
        case 'code':
            return new YCodeCell(type, type.get('source'), type.get('outputs'), options);
        case 'markdown':
            return new YMarkdownCell(type, type.get('source'), options);
        case 'raw':
            return new YRawCell(type, type.get('source'), options);
        default:
            throw new Error('Found unknown cell type');
    }
};
/**
 * Create a new cell that can be inserted in an existing shared model.
 *
 * If no notebook is specified the cell will be standalone.
 *
 * @param cell Cell JSON representation
 * @param notebook Notebook to which the cell will be added
 */
const createCell = (cell, notebook) => {
    var _a, _b;
    const ymodel = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map();
    const ysource = new yjs__WEBPACK_IMPORTED_MODULE_3__.Text();
    const ymetadata = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map();
    ymodel.set('source', ysource);
    ymodel.set('metadata', ymetadata);
    ymodel.set('cell_type', cell.cell_type);
    ymodel.set('id', (_a = cell.id) !== null && _a !== void 0 ? _a : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4());
    let ycell;
    switch (cell.cell_type) {
        case 'markdown': {
            ycell = new YMarkdownCell(ymodel, ysource, { notebook }, ymetadata);
            if (cell.attachments != null) {
                ycell.setAttachments(cell.attachments);
            }
            break;
        }
        case 'code': {
            const youtputs = new yjs__WEBPACK_IMPORTED_MODULE_3__.Array();
            ymodel.set('outputs', youtputs);
            ycell = new YCodeCell(ymodel, ysource, youtputs, {
                notebook
            }, ymetadata);
            const cCell = cell;
            ycell.execution_count = (_b = cCell.execution_count) !== null && _b !== void 0 ? _b : null;
            if (cCell.outputs) {
                ycell.setOutputs(cCell.outputs);
            }
            break;
        }
        default: {
            // raw
            ycell = new YRawCell(ymodel, ysource, { notebook }, ymetadata);
            if (cell.attachments) {
                ycell.setAttachments(cell.attachments);
            }
            break;
        }
    }
    if (cell.metadata != null) {
        ycell.setMetadata(cell.metadata);
    }
    if (cell.source != null) {
        ycell.setSource(typeof cell.source === 'string' ? cell.source : cell.source.join(''));
    }
    return ycell;
};
/**
 * Create a new cell that cannot be inserted in an existing shared model.
 *
 * @param cell Cell JSON representation
 */
const createStandaloneCell = (cell) => createCell(cell);
class YBaseCell {
    /**
     * Create a new YCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return createCell({ id, cell_type: this.prototype.cell_type });
    }
    /**
     * Base cell constructor
     *
     * ### Notes
     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
     *
     * The ``ysource`` is needed because ``ymodel.get('source')`` will
     * not return the real source if the model is not yet attached to
     * a document. Requesting it explicitly allows to introspect a non-empty
     * source before the cell is attached to the document.
     *
     * @param ymodel Cell map
     * @param ysource Cell source
     * @param options \{ notebook?: The notebook the cell is attached to \}
     * @param ymetadata Cell metadata
     */
    constructor(ymodel, ysource, options = {}, ymetadata) {
        /**
         * Handle a change to the ymodel.
         */
        this._modelObserver = (events, transaction) => {
            if (transaction.origin !== 'silent-change') {
                this._changed.emit(this.getChanges(events));
            }
        };
        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        /**
         * The notebook that this cell belongs to.
         */
        this._notebook = null;
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._isDisposed = false;
        this._undoManager = null;
        this.ymodel = ymodel;
        this._ysource = ysource;
        this._ymetadata = ymetadata !== null && ymetadata !== void 0 ? ymetadata : this.ymodel.get('metadata');
        this._prevSourceLength = ysource ? ysource.length : 0;
        this._notebook = null;
        this._awareness = null;
        this._undoManager = null;
        if (options.notebook) {
            this._notebook = options.notebook;
            // We cannot create a undo manager with the cell not yet attached in the notebook
            // so we defer that to the notebook insertCell method
        }
        else {
            // Standalone cell
            const doc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();
            doc.getArray().insert(0, [this.ymodel]);
            this._awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__.Awareness(doc);
            this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([this.ymodel], {
                trackedOrigins: new Set([this])
            });
        }
        this.ymodel.observeDeep(this._modelObserver);
    }
    /**
     * Cell notebook awareness or null if the cell is standalone.
     */
    get awareness() {
        var _a, _b, _c;
        return (_c = (_a = this._awareness) !== null && _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null && _c !== void 0 ? _c : null;
    }
    /**
     * The type of the cell.
     */
    get cell_type() {
        throw new Error('A YBaseCell must not be constructed');
    }
    /**
     * The changed signal.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Signal emitted when the cell is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Cell id
     */
    get id() {
        return this.getId();
    }
    /**
     * Whether the model has been disposed or not.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Whether the cell is standalone or not.
     *
     * If the cell is standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    get isStandalone() {
        return this._notebook !== null;
    }
    /**
     * Cell metadata.
     *
     * #### Notes
     * You should prefer to access and modify the specific key of interest.
     */
    get metadata() {
        return this.getMetadata();
    }
    set metadata(v) {
        this.setMetadata(v);
    }
    /**
     * Signal triggered when the cell metadata changes.
     */
    get metadataChanged() {
        return this._metadataChanged;
    }
    /**
     * The notebook that this cell belongs to.
     */
    get notebook() {
        return this._notebook;
    }
    /**
     * Cell input content.
     */
    get source() {
        return this.getSource();
    }
    set source(v) {
        this.setSource(v);
    }
    /**
     * The cell undo manager.
     */
    get undoManager() {
        var _a;
        if (!this.notebook) {
            return this._undoManager;
        }
        return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo)
            ? this._undoManager
            : this.notebook.undoManager;
    }
    /**
     * Defer setting the undo manager as it requires the
     * cell to be attached to the notebook Y document.
     */
    setUndoManager() {
        if (this._undoManager) {
            throw new Error('The cell undo manager is already set.');
        }
        if (this._notebook && this._notebook.disableDocumentWideUndoRedo) {
            this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([this.ymodel], {
                trackedOrigins: new Set([this])
            });
        }
    }
    get ysource() {
        return this._ysource;
    }
    /**
     * Whether the object can undo changes.
     */
    canUndo() {
        return !!this.undoManager && this.undoManager.undoStack.length > 0;
    }
    /**
     * Whether the object can redo changes.
     */
    canRedo() {
        return !!this.undoManager && this.undoManager.redoStack.length > 0;
    }
    /**
     * Clear the change stack.
     */
    clearUndoHistory() {
        var _a;
        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();
    }
    /**
     * Undo an operation.
     */
    undo() {
        var _a;
        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();
    }
    /**
     * Redo an operation.
     */
    redo() {
        var _a;
        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        var _a;
        if (this._isDisposed)
            return;
        this._isDisposed = true;
        this.ymodel.unobserveDeep(this._modelObserver);
        if (this._awareness) {
            // A new document is created for standalone cell.
            const doc = this._awareness.doc;
            this._awareness.destroy();
            doc.destroy();
        }
        if (this._undoManager) {
            // Be sure to not destroy the document undo manager.
            if (this._undoManager === ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.undoManager)) {
                this._undoManager = null;
            }
            else {
                this._undoManager.destroy();
            }
        }
        this._disposed.emit();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);
    }
    /**
     * Get cell id.
     *
     * @returns Cell id
     */
    getId() {
        return this.ymodel.get('id');
    }
    /**
     * Gets cell's source.
     *
     * @returns Cell's source.
     */
    getSource() {
        return this.ysource.toString();
    }
    /**
     * Sets cell's source.
     *
     * @param value: New source.
     */
    setSource(value) {
        this.transact(() => {
            this.ysource.delete(0, this.ysource.length);
            this.ysource.insert(0, value);
        });
        // @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.
        // this.ymodel.set('source', new Y.Text(value));
    }
    /**
     * Replace content from `start' to `end` with `value`.
     *
     * @param start: The start index of the range to replace (inclusive).
     *
     * @param end: The end index of the range to replace (exclusive).
     *
     * @param value: New source (optional).
     */
    updateSource(start, end, value = '') {
        this.transact(() => {
            const ysource = this.ysource;
            // insert and then delete.
            // This ensures that the cursor position is adjusted after the replaced content.
            ysource.insert(start, value);
            ysource.delete(start + value.length, end - start);
        });
    }
    /**
     * Delete a metadata cell.
     *
     * @param key The key to delete
     */
    deleteMetadata(key) {
        if (typeof this.getMetadata(key) === 'undefined') {
            return;
        }
        this.transact(() => {
            this._ymetadata.delete(key);
            const jupyter = this.getMetadata('jupyter');
            if (key === 'collapsed' && jupyter) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { outputs_hidden, ...others } = jupyter;
                if (Object.keys(others).length === 0) {
                    this._ymetadata.delete('jupyter');
                }
                else {
                    this._ymetadata.set('jupyter', others);
                }
            }
            else if (key === 'jupyter') {
                this._ymetadata.delete('collapsed');
            }
        }, false);
    }
    getMetadata(key) {
        const metadata = this._ymetadata;
        // Transiently the metadata can be missing - like during destruction
        if (metadata === undefined) {
            return undefined;
        }
        if (typeof key === 'string') {
            const value = metadata.get(key);
            return typeof value === 'undefined'
                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`
                : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata.get(key));
        }
        else {
            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata.toJSON());
        }
    }
    setMetadata(metadata, value) {
        var _a, _b;
        if (typeof metadata === 'string') {
            if (typeof value === 'undefined') {
                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);
            }
            const key = metadata;
            // Only set metadata if we change something to avoid infinite
            // loop of signal changes.
            if (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual((_a = this.getMetadata(key)) !== null && _a !== void 0 ? _a : null, value)) {
                return;
            }
            this.transact(() => {
                var _a;
                this._ymetadata.set(key, value);
                if (key === 'collapsed') {
                    const jupyter = ((_a = this.getMetadata('jupyter')) !== null && _a !== void 0 ? _a : {});
                    if (jupyter.outputs_hidden !== value) {
                        this.setMetadata('jupyter', {
                            ...jupyter,
                            outputs_hidden: value
                        });
                    }
                }
                else if (key === 'jupyter') {
                    const isHidden = value['outputs_hidden'];
                    if (typeof isHidden !== 'undefined') {
                        if (this.getMetadata('collapsed') !== isHidden) {
                            this.setMetadata('collapsed', isHidden);
                        }
                    }
                    else {
                        this.deleteMetadata('collapsed');
                    }
                }
            }, false);
        }
        else {
            const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata);
            if (clone.collapsed != null) {
                clone.jupyter = clone.jupyter || {};
                clone.jupyter.outputs_hidden = clone.collapsed;
            }
            else if (((_b = clone === null || clone === void 0 ? void 0 : clone.jupyter) === null || _b === void 0 ? void 0 : _b.outputs_hidden) != null) {
                clone.collapsed = clone.jupyter.outputs_hidden;
            }
            if (!_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(clone, this.getMetadata())) {
                this.transact(() => {
                    for (const [key, value] of Object.entries(clone)) {
                        this._ymetadata.set(key, value);
                    }
                }, false);
            }
        }
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            id: this.getId(),
            cell_type: this.cell_type,
            source: this.getSource(),
            metadata: this.getMetadata()
        };
    }
    /**
     * Perform a transaction. While the function f is called, all changes to the shared
     * document are bundled into a single event.
     *
     * @param f Transaction to execute
     * @param undoable Whether to track the change in the action history or not (default `true`)
     */
    transact(f, undoable = true, origin = null) {
        !this.notebook || this.notebook.disableDocumentWideUndoRedo
            ? this.ymodel.doc == null
                ? f()
                : this.ymodel.doc.transact(f, undoable ? this : origin)
            : this.notebook.transact(f, undoable);
    }
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    getChanges(events) {
        const changes = {};
        const sourceEvent = events.find(event => event.target === this.ymodel.get('source'));
        if (sourceEvent) {
            changes.sourceChange = sourceEvent.changes.delta;
        }
        const metadataEvents = events.find(event => event.target === this._ymetadata);
        if (metadataEvents) {
            changes.metadataChange = metadataEvents.changes.keys;
            metadataEvents.changes.keys.forEach((change, key) => {
                switch (change.action) {
                    case 'add':
                        this._metadataChanged.emit({
                            key,
                            newValue: this._ymetadata.get(key),
                            type: 'add'
                        });
                        break;
                    case 'delete':
                        this._metadataChanged.emit({
                            key,
                            oldValue: change.oldValue,
                            type: 'remove'
                        });
                        break;
                    case 'update':
                        {
                            const newValue = this._ymetadata.get(key);
                            const oldValue = change.oldValue;
                            let equal = true;
                            if (typeof oldValue == 'object' && typeof newValue == 'object') {
                                equal = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(oldValue, newValue);
                            }
                            else {
                                equal = oldValue === newValue;
                            }
                            if (!equal) {
                                this._metadataChanged.emit({
                                    key,
                                    type: 'change',
                                    oldValue,
                                    newValue
                                });
                            }
                        }
                        break;
                }
            });
        }
        const modelEvent = events.find(event => event.target === this.ymodel);
        // The model allows us to replace the complete source with a new string. We express this in the Delta format
        // as a replace of the complete string.
        const ysource = this.ymodel.get('source');
        if (modelEvent && modelEvent.keysChanged.has('source')) {
            changes.sourceChange = [
                { delete: this._prevSourceLength },
                { insert: ysource.toString() }
            ];
        }
        this._prevSourceLength = ysource.length;
        return changes;
    }
}
/**
 * Shareable code cell.
 */
class YCodeCell extends YBaseCell {
    /**
     * Create a new YCodeCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return super.create(id);
    }
    /**
     * Code cell constructor
     *
     * ### Notes
     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
     *
     * The ``ysource`` is needed because ``ymodel.get('source')`` will
     * not return the real source if the model is not yet attached to
     * a document. Requesting it explicitly allows to introspect a non-empty
     * source before the cell is attached to the document.
     *
     * @param ymodel Cell map
     * @param ysource Cell source
     * @param youtputs Code cell outputs
     * @param options \{ notebook?: The notebook the cell is attached to \}
     * @param ymetadata Cell metadata
     */
    constructor(ymodel, ysource, youtputs, options = {}, ymetadata) {
        super(ymodel, ysource, options, ymetadata);
        this._youtputs = youtputs;
    }
    /**
     * The type of the cell.
     */
    get cell_type() {
        return 'code';
    }
    /**
     * The code cell's prompt number. Will be null if the cell has not been run.
     */
    get execution_count() {
        return this.ymodel.get('execution_count') || null;
    }
    set execution_count(count) {
        // Do not use `this.execution_count`. When initializing the
        // cell, we need to set execution_count to `null` if we compare
        // using `this.execution_count` it will return `null` and we will
        // never initialize it
        if (this.ymodel.get('execution_count') !== count) {
            this.transact(() => {
                this.ymodel.set('execution_count', count);
            }, false);
        }
    }
    /**
     * The code cell's execution state.
     */
    get executionState() {
        var _a;
        return (_a = this.ymodel.get('execution_state')) !== null && _a !== void 0 ? _a : 'idle';
    }
    set executionState(state) {
        if (this.ymodel.get('execution_state') !== state) {
            this.transact(() => {
                this.ymodel.set('execution_state', state);
            }, false);
        }
    }
    /**
     * Cell outputs.
     */
    get outputs() {
        return this.getOutputs();
    }
    set outputs(v) {
        this.setOutputs(v);
    }
    get youtputs() {
        return this._youtputs;
    }
    /**
     * Execution, display, or stream outputs.
     */
    getOutputs() {
        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this._youtputs.toJSON());
    }
    createOutputs(outputs) {
        const newOutputs = [];
        for (const output of _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(outputs)) {
            let _newOutput1;
            if (output.output_type === 'stream') {
                // Set the text field as a Y.Text
                const { text, ...outputWithoutText } = output;
                _newOutput1 = outputWithoutText;
                const newText = new yjs__WEBPACK_IMPORTED_MODULE_3__.Text();
                let _text = text instanceof Array ? text.join() : text;
                newText.insert(0, _text);
                _newOutput1['text'] = newText;
            }
            else {
                _newOutput1 = output;
            }
            const _newOutput2 = [];
            for (const [key, value] of Object.entries(_newOutput1)) {
                _newOutput2.push([key, value]);
            }
            const newOutput = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map(_newOutput2);
            newOutputs.push(newOutput);
        }
        return newOutputs;
    }
    /**
     * Replace all outputs.
     */
    setOutputs(outputs) {
        this.transact(() => {
            this._youtputs.delete(0, this._youtputs.length);
            const newOutputs = this.createOutputs(outputs);
            this._youtputs.insert(0, newOutputs);
        }, false);
    }
    /**
     * Remove text from a stream output.
     */
    removeStreamOutput(index, start, origin = null) {
        this.transact(() => {
            const output = this._youtputs.get(index);
            const prevText = output.get('text');
            const length = prevText.length - start;
            prevText.delete(start, length);
        }, false, origin);
    }
    /**
     * Append text to a stream output.
     */
    appendStreamOutput(index, text, origin = null) {
        this.transact(() => {
            const output = this._youtputs.get(index);
            const prevText = output.get('text');
            prevText.insert(prevText.length, text);
        }, false, origin);
    }
    /**
     * Replace content from `start' to `end` with `outputs`.
     *
     * @param start: The start index of the range to replace (inclusive).
     *
     * @param end: The end index of the range to replace (exclusive).
     *
     * @param outputs: New outputs (optional).
     */
    updateOutputs(start, end, outputs = [], origin = null) {
        const fin = end < this._youtputs.length ? end - start : this._youtputs.length - start;
        this.transact(() => {
            this._youtputs.delete(start, fin);
            const newOutputs = this.createOutputs(outputs);
            this._youtputs.insert(start, newOutputs);
        }, false, origin);
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            ...super.toJSON(),
            outputs: this.getOutputs(),
            execution_count: this.execution_count
        };
    }
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    getChanges(events) {
        const changes = super.getChanges(events);
        const streamOutputEvent = events.find(
        // Changes to the 'text' of a cell's stream output can be accessed like so:
        // ycell['outputs'][output_idx]['text']
        // This translates to an event path of: ['outputs', output_idx, 'text]
        event => event.path.length === 3 &&
            event.path[0] === 'outputs' &&
            event.path[2] === 'text');
        if (streamOutputEvent) {
            changes.streamOutputChange = streamOutputEvent.changes.delta;
        }
        const outputEvent = events.find(event => event.target === this.ymodel.get('outputs'));
        if (outputEvent) {
            changes.outputsChange = outputEvent.changes.delta;
        }
        const modelEvent = events.find(event => event.target === this.ymodel);
        if (modelEvent && modelEvent.keysChanged.has('execution_count')) {
            const change = modelEvent.changes.keys.get('execution_count');
            changes.executionCountChange = {
                oldValue: change.oldValue,
                newValue: this.ymodel.get('execution_count')
            };
        }
        if (modelEvent && modelEvent.keysChanged.has('execution_state')) {
            const change = modelEvent.changes.keys.get('execution_state');
            changes.executionStateChange = {
                oldValue: change.oldValue,
                newValue: this.ymodel.get('execution_state')
            };
        }
        return changes;
    }
}
class YAttachmentCell extends YBaseCell {
    /**
     * Cell attachments
     */
    get attachments() {
        return this.getAttachments();
    }
    set attachments(v) {
        this.setAttachments(v);
    }
    /**
     * Gets the cell attachments.
     *
     * @returns The cell attachments.
     */
    getAttachments() {
        return this.ymodel.get('attachments');
    }
    /**
     * Sets the cell attachments
     *
     * @param attachments: The cell attachments.
     */
    setAttachments(attachments) {
        this.transact(() => {
            if (attachments == null) {
                this.ymodel.delete('attachments');
            }
            else {
                this.ymodel.set('attachments', attachments);
            }
        }, false);
    }
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    getChanges(events) {
        const changes = super.getChanges(events);
        const modelEvent = events.find(event => event.target === this.ymodel);
        if (modelEvent && modelEvent.keysChanged.has('attachments')) {
            const change = modelEvent.changes.keys.get('attachments');
            changes.attachmentsChange = {
                oldValue: change.oldValue,
                newValue: this.ymodel.get('attachments')
            };
        }
        return changes;
    }
}
/**
 * Shareable raw cell.
 */
class YRawCell extends YAttachmentCell {
    /**
     * Create a new YRawCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return super.create(id);
    }
    /**
     * String identifying the type of cell.
     */
    get cell_type() {
        return 'raw';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            id: this.getId(),
            cell_type: 'raw',
            source: this.getSource(),
            metadata: this.getMetadata(),
            attachments: this.getAttachments()
        };
    }
}
/**
 * Shareable markdown cell.
 */
class YMarkdownCell extends YAttachmentCell {
    /**
     * Create a new YMarkdownCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return super.create(id);
    }
    /**
     * String identifying the type of cell.
     */
    get cell_type() {
        return 'markdown';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            id: this.getId(),
            cell_type: 'markdown',
            source: this.getSource(),
            metadata: this.getMetadata(),
            attachments: this.getAttachments()
        };
    }
}
//# sourceMappingURL=ycell.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/ydocument.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/ydocument.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YDocument: () => (/* binding */ YDocument)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness */ "./node_modules/y-protocols/awareness.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_3__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * Generic shareable document.
 */
class YDocument {
    constructor(options) {
        var _a;
        /**
         * Handle a change to the ystate.
         */
        this.onStateChanged = (event) => {
            const stateChange = new Array();
            event.keysChanged.forEach(key => {
                const change = event.changes.keys.get(key);
                if (change) {
                    stateChange.push({
                        name: key,
                        oldValue: change.oldValue,
                        newValue: this.ystate.get(key)
                    });
                }
            });
            this._changed.emit({ stateChange });
        };
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._isDisposed = false;
        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._ydoc = (_a = options === null || options === void 0 ? void 0 : options.ydoc) !== null && _a !== void 0 ? _a : new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();
        this._ystate = this._ydoc.getMap('state');
        this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([], {
            trackedOrigins: new Set([this]),
            doc: this._ydoc
        });
        this._awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__.Awareness(this._ydoc);
        this._ystate.observe(this.onStateChanged);
    }
    /**
     * YJS document.
     */
    get ydoc() {
        return this._ydoc;
    }
    /**
     * Shared state
     */
    get ystate() {
        return this._ystate;
    }
    /**
     * YJS document undo manager
     */
    get undoManager() {
        return this._undoManager;
    }
    /**
     * Shared awareness
     */
    get awareness() {
        return this._awareness;
    }
    /**
     * The changed signal.
     */
    get changed() {
        return this._changed;
    }
    /**
     * A signal emitted when the document is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Whether the document is disposed or not.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Document state
     */
    get state() {
        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this.ystate.toJSON());
    }
    /**
     * Whether the object can undo changes.
     */
    canUndo() {
        return this.undoManager.undoStack.length > 0;
    }
    /**
     * Whether the object can redo changes.
     */
    canRedo() {
        return this.undoManager.redoStack.length > 0;
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.ystate.unobserve(this.onStateChanged);
        this.awareness.destroy();
        this.undoManager.destroy();
        this.ydoc.destroy();
        this._disposed.emit();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);
    }
    /**
     * Get the value for a state attribute
     *
     * @param key Key to get
     */
    getState(key) {
        const value = this.ystate.get(key);
        return typeof value === 'undefined'
            ? value
            : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);
    }
    /**
     * Set the value of a state attribute
     *
     * @param key Key to set
     * @param value New attribute value
     */
    setState(key, value) {
        if (!_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(this.ystate.get(key), value)) {
            this.ystate.set(key, value);
        }
    }
    /**
     * Get the document source
     *
     * @returns The source
     */
    get source() {
        return this.getSource();
    }
    /**
     * Set the document source
     *
     * @param value The source to set
     */
    set source(value) {
        this.setSource(value);
    }
    /**
     * Undo an operation.
     */
    undo() {
        this.undoManager.undo();
    }
    /**
     * Redo an operation.
     */
    redo() {
        this.undoManager.redo();
    }
    /**
     * Clear the change stack.
     */
    clearUndoHistory() {
        this.undoManager.clear();
    }
    /**
     * Perform a transaction. While the function f is called, all changes to the shared
     * document are bundled into a single event.
     */
    transact(f, undoable = true, origin = null) {
        this.ydoc.transact(f, undoable ? this : origin);
    }
}
//# sourceMappingURL=ydocument.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/yfile.js":
/*!*************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/yfile.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YFile: () => (/* binding */ YFile)
/* harmony export */ });
/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ydocument.js */ "./node_modules/@jupyter/ydoc/lib/ydocument.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Shareable text file.
 */
class YFile extends _ydocument_js__WEBPACK_IMPORTED_MODULE_0__.YDocument {
    /**
     * Create a new file
     *
     * #### Notes
     * The document is empty and must be populated
     */
    constructor() {
        super();
        /**
         * Document version
         */
        this.version = '1.0.0';
        /**
         * YJS file text.
         */
        this.ysource = this.ydoc.getText('source');
        /**
         * Handle a change to the ymodel.
         */
        this._modelObserver = (event) => {
            this._changed.emit({ sourceChange: event.changes.delta });
        };
        this.undoManager.addToScope(this.ysource);
        this.ysource.observe(this._modelObserver);
    }
    /**
     * Creates a standalone YFile
     */
    static create() {
        return new YFile();
    }
    /**
     * File text
     */
    get source() {
        return this.getSource();
    }
    set source(v) {
        this.setSource(v);
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.ysource.unobserve(this._modelObserver);
        super.dispose();
    }
    /**
     * Get the file text.
     *
     * @returns File text.
     */
    getSource() {
        return this.ysource.toString();
    }
    /**
     * Set the file text.
     *
     * @param value New text
     */
    setSource(value) {
        this.transact(() => {
            const ytext = this.ysource;
            ytext.delete(0, ytext.length);
            ytext.insert(0, value);
        });
    }
    /**
     * Replace content from `start' to `end` with `value`.
     *
     * @param start: The start index of the range to replace (inclusive).
     * @param end: The end index of the range to replace (exclusive).
     * @param value: New source (optional).
     */
    updateSource(start, end, value = '') {
        this.transact(() => {
            const ysource = this.ysource;
            // insert and then delete.
            // This ensures that the cursor position is adjusted after the replaced content.
            ysource.insert(start, value);
            ysource.delete(start + value.length, end - start);
        });
    }
}
//# sourceMappingURL=yfile.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/ynotebook.js":
/*!*****************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/ynotebook.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YNotebook: () => (/* binding */ YNotebook)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ydocument.js */ "./node_modules/@jupyter/ydoc/lib/ydocument.js");
/* harmony import */ var _ycell_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ycell.js */ "./node_modules/@jupyter/ydoc/lib/ycell.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/





/**
 * Shared implementation of the Shared Document types.
 *
 * Shared cells can be inserted into a SharedNotebook.
 * Shared cells only start emitting events when they are connected to a SharedNotebook.
 *
 * "Standalone" cells must not be inserted into a (Shared)Notebook.
 * Standalone cells emit events immediately after they have been created, but they must not
 * be included into a (Shared)Notebook.
 */
class YNotebook extends _ydocument_js__WEBPACK_IMPORTED_MODULE_3__.YDocument {
    /**
     * Create a new notebook
     *
     * #### Notes
     * The document is empty and must be populated
     *
     * @param options
     */
    constructor(options = {}) {
        var _a;
        super();
        /**
         * Document version
         */
        this.version = '2.0.0';
        /**
         * YJS map for the notebook metadata
         */
        this.ymeta = this.ydoc.getMap('meta');
        /**
         * Handle a change to the ystate.
         */
        this._onMetaChanged = (events) => {
            const metadataEvents = events.find(event => event.target === this.ymeta.get('metadata'));
            if (metadataEvents) {
                const metadataChange = metadataEvents.changes.keys;
                const ymetadata = this.ymeta.get('metadata');
                metadataEvents.changes.keys.forEach((change, key) => {
                    switch (change.action) {
                        case 'add':
                            this._metadataChanged.emit({
                                key,
                                type: 'add',
                                newValue: ymetadata.get(key)
                            });
                            break;
                        case 'delete':
                            this._metadataChanged.emit({
                                key,
                                type: 'remove',
                                oldValue: change.oldValue
                            });
                            break;
                        case 'update':
                            {
                                const newValue = ymetadata.get(key);
                                const oldValue = change.oldValue;
                                let equal = true;
                                if (typeof oldValue == 'object' && typeof newValue == 'object') {
                                    equal = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(oldValue, newValue);
                                }
                                else {
                                    equal = oldValue === newValue;
                                }
                                if (!equal) {
                                    this._metadataChanged.emit({
                                        key,
                                        type: 'change',
                                        oldValue,
                                        newValue
                                    });
                                }
                            }
                            break;
                    }
                });
                this._changed.emit({ metadataChange });
            }
            const metaEvent = events.find(event => event.target === this.ymeta);
            if (!metaEvent) {
                return;
            }
            if (metaEvent.keysChanged.has('metadata')) {
                // Handle metadata change when adding/removing the YMap
                const change = metaEvent.changes.keys.get('metadata');
                if ((change === null || change === void 0 ? void 0 : change.action) === 'add' && !change.oldValue) {
                    const metadataChange = new Map();
                    for (const key of Object.keys(this.metadata)) {
                        metadataChange.set(key, {
                            action: 'add',
                            oldValue: undefined
                        });
                        this._metadataChanged.emit({
                            key,
                            type: 'add',
                            newValue: this.getMetadata(key)
                        });
                    }
                    this._changed.emit({ metadataChange });
                }
            }
            if (metaEvent.keysChanged.has('nbformat')) {
                const change = metaEvent.changes.keys.get('nbformat');
                const nbformatChanged = {
                    key: 'nbformat',
                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,
                    newValue: this.nbformat
                };
                this._changed.emit({ nbformatChanged });
            }
            if (metaEvent.keysChanged.has('nbformat_minor')) {
                const change = metaEvent.changes.keys.get('nbformat_minor');
                const nbformatChanged = {
                    key: 'nbformat_minor',
                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,
                    newValue: this.nbformat_minor
                };
                this._changed.emit({ nbformatChanged });
            }
        };
        /**
         * Handle a change to the list of cells.
         */
        this._onYCellsChanged = (event) => {
            // update the type cell mapping by iterating through the added/removed types
            event.changes.added.forEach(item => {
                const type = item.content.type;
                if (!this._ycellMapping.has(type)) {
                    const c = (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCellModelFromSharedType)(type, { notebook: this });
                    c.setUndoManager();
                    this._ycellMapping.set(type, c);
                }
            });
            event.changes.deleted.forEach(item => {
                const type = item.content.type;
                const model = this._ycellMapping.get(type);
                if (model) {
                    model.dispose();
                    this._ycellMapping.delete(type);
                }
            });
            let index = 0;
            // this reflects the event.changes.delta, but replaces the content of delta.insert with ycells
            const cellsChange = [];
            event.changes.delta.forEach((d) => {
                if (d.insert != null) {
                    const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));
                    cellsChange.push({ insert: insertedCells });
                    this.cells.splice(index, 0, ...insertedCells);
                    index += d.insert.length;
                }
                else if (d.delete != null) {
                    cellsChange.push(d);
                    this.cells.splice(index, d.delete);
                }
                else if (d.retain != null) {
                    cellsChange.push(d);
                    index += d.retain;
                }
            });
            this._changed.emit({
                cellsChange: cellsChange
            });
        };
        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        /**
         * Internal Yjs cells list
         */
        this._ycells = this.ydoc.getArray('cells');
        this._ycellMapping = new WeakMap();
        this._disableDocumentWideUndoRedo =
            (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false;
        this.cells = this._ycells.toArray().map(ycell => {
            if (!this._ycellMapping.has(ycell)) {
                this._ycellMapping.set(ycell, (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCellModelFromSharedType)(ycell, { notebook: this }));
            }
            return this._ycellMapping.get(ycell);
        });
        this.undoManager.addToScope(this._ycells);
        this._ycells.observe(this._onYCellsChanged);
        this.ymeta.observeDeep(this._onMetaChanged);
    }
    /**
     * Creates a standalone YNotebook
     *
     * Note: This method is useful when we need to initialize
     * the YNotebook from the JavaScript side.
     */
    static create(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const ynotebook = new YNotebook({
            disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false
        });
        const data = {
            cells: (_c = (_b = options.data) === null || _b === void 0 ? void 0 : _b.cells) !== null && _c !== void 0 ? _c : [],
            nbformat: (_e = (_d = options.data) === null || _d === void 0 ? void 0 : _d.nbformat) !== null && _e !== void 0 ? _e : 4,
            nbformat_minor: (_g = (_f = options.data) === null || _f === void 0 ? void 0 : _f.nbformat_minor) !== null && _g !== void 0 ? _g : 5,
            metadata: (_j = (_h = options.data) === null || _h === void 0 ? void 0 : _h.metadata) !== null && _j !== void 0 ? _j : {}
        };
        ynotebook.fromJSON(data);
        return ynotebook;
    }
    /**
     * Wether the undo/redo logic should be
     * considered on the full document across all cells.
     *
     * Default: false
     */
    get disableDocumentWideUndoRedo() {
        return this._disableDocumentWideUndoRedo;
    }
    /**
     * Notebook metadata
     */
    get metadata() {
        return this.getMetadata();
    }
    set metadata(v) {
        this.setMetadata(v);
    }
    /**
     * Signal triggered when a metadata changes.
     */
    get metadataChanged() {
        return this._metadataChanged;
    }
    /**
     * nbformat major version
     */
    get nbformat() {
        return this.ymeta.get('nbformat');
    }
    set nbformat(value) {
        this.transact(() => {
            this.ymeta.set('nbformat', value);
        }, false);
    }
    /**
     * nbformat minor version
     */
    get nbformat_minor() {
        return this.ymeta.get('nbformat_minor');
    }
    set nbformat_minor(value) {
        this.transact(() => {
            this.ymeta.set('nbformat_minor', value);
        }, false);
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._ycells.unobserve(this._onYCellsChanged);
        this.ymeta.unobserveDeep(this._onMetaChanged);
        super.dispose();
    }
    /**
     * Get a shared cell by index.
     *
     * @param index: Cell's position.
     *
     * @returns The requested shared cell.
     */
    getCell(index) {
        return this.cells[index];
    }
    /**
     * Add a shared cell at the notebook bottom.
     *
     * @param cell Cell to add.
     *
     * @returns The added cell.
     */
    addCell(cell) {
        return this.insertCell(this._ycells.length, cell);
    }
    /**
     * Insert a shared cell into a specific position.
     *
     * @param index: Cell's position.
     * @param cell: Cell to insert.
     *
     * @returns The inserted cell.
     */
    insertCell(index, cell) {
        return this.insertCells(index, [cell])[0];
    }
    /**
     * Insert a list of shared cells into a specific position.
     *
     * @param index: Position to insert the cells.
     * @param cells: Array of shared cells to insert.
     *
     * @returns The inserted cells.
     */
    insertCells(index, cells) {
        const yCells = cells.map(c => {
            const cell = (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCell)(c, this);
            this._ycellMapping.set(cell.ymodel, cell);
            return cell;
        });
        this.transact(() => {
            this._ycells.insert(index, yCells.map(cell => cell.ymodel));
        });
        yCells.forEach(c => {
            c.setUndoManager();
        });
        return yCells;
    }
    /**
     * Move a cell.
     *
     * @param fromIndex: Index of the cell to move.
     * @param toIndex: New position of the cell.
     */
    moveCell(fromIndex, toIndex) {
        this.moveCells(fromIndex, toIndex);
    }
    /**
     * Move cells.
     *
     * @param fromIndex: Index of the first cells to move.
     * @param toIndex: New position of the first cell (in the current array).
     * @param n: Number of cells to move (default 1)
     */
    moveCells(fromIndex, toIndex, n = 1) {
        // FIXME we need to use yjs move feature to preserve undo history
        const clones = new Array(n)
            .fill(true)
            .map((_, idx) => this.getCell(fromIndex + idx).toJSON());
        this.transact(() => {
            this._ycells.delete(fromIndex, n);
            this._ycells.insert(fromIndex > toIndex ? toIndex : toIndex - n + 1, clones.map(clone => (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCell)(clone, this).ymodel));
        });
    }
    /**
     * Remove a cell.
     *
     * @param index: Index of the cell to remove.
     */
    deleteCell(index) {
        this.deleteCellRange(index, index + 1);
    }
    /**
     * Remove a range of cells.
     *
     * @param from: The start index of the range to remove (inclusive).
     * @param to: The end index of the range to remove (exclusive).
     */
    deleteCellRange(from, to) {
        // Cells will be removed from the mapping in the model event listener.
        this.transact(() => {
            this._ycells.delete(from, to - from);
        });
    }
    /**
     * Delete a metadata notebook.
     *
     * @param key The key to delete
     */
    deleteMetadata(key) {
        if (typeof this.getMetadata(key) === 'undefined') {
            return;
        }
        const allMetadata = this.metadata;
        delete allMetadata[key];
        this.setMetadata(allMetadata);
    }
    getMetadata(key) {
        const ymetadata = this.ymeta.get('metadata');
        // Transiently the metadata can be missing - like during destruction
        if (ymetadata === undefined) {
            return undefined;
        }
        if (typeof key === 'string') {
            const value = ymetadata.get(key);
            return typeof value === 'undefined'
                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`
                : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);
        }
        else {
            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(ymetadata.toJSON());
        }
    }
    setMetadata(metadata, value) {
        var _a;
        if (typeof metadata === 'string') {
            if (typeof value === 'undefined') {
                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);
            }
            if (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual((_a = this.getMetadata(metadata)) !== null && _a !== void 0 ? _a : null, value)) {
                return;
            }
            const update = {};
            update[metadata] = value;
            this.updateMetadata(update);
        }
        else {
            if (!this.metadata || !_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(this.metadata, metadata)) {
                const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata);
                const ymetadata = this.ymeta.get('metadata');
                // Transiently the metadata can be missing - like during destruction
                if (ymetadata === undefined) {
                    return undefined;
                }
                this.transact(() => {
                    ymetadata.clear();
                    for (const [key, value] of Object.entries(clone)) {
                        ymetadata.set(key, value);
                    }
                });
            }
        }
    }
    /**
     * Updates the metadata associated with the notebook.
     *
     * @param value: Metadata's attribute to update.
     */
    updateMetadata(value) {
        // TODO: Maybe modify only attributes instead of replacing the whole metadata?
        const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);
        const ymetadata = this.ymeta.get('metadata');
        // Transiently the metadata can be missing - like during destruction
        if (ymetadata === undefined) {
            return undefined;
        }
        this.transact(() => {
            for (const [key, value] of Object.entries(clone)) {
                ymetadata.set(key, value);
            }
        });
    }
    /**
     * Get the notebook source
     *
     * @returns The notebook
     */
    getSource() {
        return this.toJSON();
    }
    /**
     * Set the notebook source
     *
     * @param value The notebook
     */
    setSource(value) {
        this.fromJSON(value);
    }
    /**
     * Override the notebook with a JSON-serialized document.
     *
     * @param value The notebook
     */
    fromJSON(value) {
        this.transact(() => {
            this.nbformat = value.nbformat;
            this.nbformat_minor = value.nbformat_minor;
            const metadata = value.metadata;
            if (metadata['orig_nbformat'] !== undefined) {
                delete metadata['orig_nbformat'];
            }
            if (!this.metadata) {
                const ymetadata = new yjs__WEBPACK_IMPORTED_MODULE_2__.Map();
                for (const [key, value] of Object.entries(metadata)) {
                    ymetadata.set(key, value);
                }
                this.ymeta.set('metadata', ymetadata);
            }
            else {
                this.metadata = metadata;
            }
            const useId = value.nbformat === 4 && value.nbformat_minor >= 5;
            const ycells = value.cells.map(cell => {
                if (!useId) {
                    delete cell.id;
                }
                return cell;
            });
            this.insertCells(this.cells.length, ycells);
            this.deleteCellRange(0, this.cells.length);
        });
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        // strip cell ids if we have notebook format 4.0-4.4
        const pruneCellId = this.nbformat === 4 && this.nbformat_minor <= 4;
        return {
            metadata: this.metadata,
            nbformat_minor: this.nbformat_minor,
            nbformat: this.nbformat,
            cells: this.cells.map(c => {
                const raw = c.toJSON();
                if (pruneCellId) {
                    delete raw.id;
                }
                return raw;
            })
        };
    }
}
//# sourceMappingURL=ynotebook.js.map

/***/ }),

/***/ "./node_modules/@jupyter/ydoc/lib/ytext.js":
/*!*************************************************!*\
  !*** ./node_modules/@jupyter/ydoc/lib/ytext.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

//# sourceMappingURL=ytext.js.map

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/y-protocols/awareness.js":
/*!***********************************************!*\
  !*** ./node_modules/y-protocols/awareness.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Awareness: () => (/* binding */ Awareness),
/* harmony export */   applyAwarenessUpdate: () => (/* binding */ applyAwarenessUpdate),
/* harmony export */   encodeAwarenessUpdate: () => (/* binding */ encodeAwarenessUpdate),
/* harmony export */   modifyAwarenessUpdate: () => (/* binding */ modifyAwarenessUpdate),
/* harmony export */   outdatedTimeout: () => (/* binding */ outdatedTimeout),
/* harmony export */   removeAwarenessStates: () => (/* binding */ removeAwarenessStates)
/* harmony export */ });
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/encoding */ "./node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/decoding */ "./node_modules/lib0/decoding.js");
/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/time */ "./node_modules/lib0/time.js");
/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/math */ "./node_modules/lib0/math.js");
/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/observable */ "./node_modules/lib0/observable.js");
/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/function */ "./node_modules/lib0/function.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @module awareness-protocol
 */







 // eslint-disable-line

const outdatedTimeout = 30000

/**
 * @typedef {Object} MetaClientState
 * @property {number} MetaClientState.clock
 * @property {number} MetaClientState.lastUpdated unix timestamp
 */

/**
 * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information
 * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of
 * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.
 *
 * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override
 * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is
 * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that
 * a remote client is offline, it may propagate a message with
 * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a
 * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.
 *
 * Before a client disconnects, it should propagate a `null` state with an updated clock.
 *
 * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.
 *
 * @extends {Observable<string>}
 */
class Awareness extends lib0_observable__WEBPACK_IMPORTED_MODULE_1__.Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor (doc) {
    super()
    this.doc = doc
    /**
     * @type {number}
     */
    this.clientID = doc.clientID
    /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */
    this.states = new Map()
    /**
     * @type {Map<number, MetaClientState>}
     */
    this.meta = new Map()
    this._checkInterval = /** @type {any} */ (setInterval(() => {
      const now = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {
        // renew local clock
        this.setLocalState(this.getLocalState())
      }
      /**
       * @type {Array<number>}
       */
      const remove = []
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid)
        }
      })
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, 'timeout')
      }
    }, lib0_math__WEBPACK_IMPORTED_MODULE_3__.floor(outdatedTimeout / 10)))
    doc.on('destroy', () => {
      this.destroy()
    })
    this.setLocalState({})
  }

  destroy () {
    this.emit('destroy', [this])
    this.setLocalState(null)
    super.destroy()
    clearInterval(this._checkInterval)
  }

  /**
   * @return {Object<string,any>|null}
   */
  getLocalState () {
    return this.states.get(this.clientID) || null
  }

  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState (state) {
    const clientID = this.clientID
    const currLocalMeta = this.meta.get(clientID)
    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1
    const prevState = this.states.get(clientID)
    if (state === null) {
      this.states.delete(clientID)
    } else {
      this.states.set(clientID, state)
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
    })
    const added = []
    const updated = []
    const filteredUpdated = []
    const removed = []
    if (state === null) {
      removed.push(clientID)
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID)
      }
    } else {
      updated.push(clientID)
      if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID)
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])
    }
    this.emit('update', [{ added, updated, removed }, 'local'])
  }

  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField (field, value) {
    const state = this.getLocalState()
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      })
    }
  }

  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates () {
    return this.states
  }
}

/**
 * Mark (remote) clients as inactive and remove them from the list of active peers.
 * This change will be propagated to remote clients.
 *
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @param {any} origin
 */
const removeAwarenessStates = (awareness, clients, origin) => {
  const removed = []
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i]
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID)
      if (clientID === awareness.clientID) {
        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
        })
      }
      removed.push(clientID)
    }
  }
  if (removed.length > 0) {
    awareness.emit('change', [{ added: [], updated: [], removed }, origin])
    awareness.emit('update', [{ added: [], updated: [], removed }, origin])
  }
}

/**
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @return {Uint8Array}
 */
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = clients[i]
    const state = states.get(clientID) || null
    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(state))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * Modify the content of an awareness update before re-encoding it to an awareness update.
 *
 * This might be useful when you have a central server that wants to ensure that clients
 * cant hijack somebody elses identity.
 *
 * @param {Uint8Array} update
 * @param {function(any):any} modify
 * @return {Uint8Array}
 */
const modifyAwarenessUpdate = (update, modify) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const modifiedState = modify(state)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(modifiedState))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * @param {Awareness} awareness
 * @param {Uint8Array} update
 * @param {any} origin This will be added to the emitted change event
 */
const applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const timestamp = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
  const added = []
  const updated = []
  const filteredUpdated = []
  const removed = []
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const clientMeta = awareness.meta.get(clientID)
    const prevState = awareness.states.get(clientID)
    const currClock = clientMeta === undefined ? 0 : clientMeta.clock
    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {
      if (state === null) {
        // never let a remote client remove this local state
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          // remote client removed the local state. Do not remote state. Broadcast a message indicating
          // that this client still exists by increasing the clock
          clock++
        } else {
          awareness.states.delete(clientID)
        }
      } else {
        awareness.states.set(clientID, state)
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      })
      if (clientMeta === undefined && state !== null) {
        added.push(clientID)
      } else if (clientMeta !== undefined && state === null) {
        removed.push(clientID)
      } else if (state !== null) {
        if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID)
        }
        updated.push(clientID)
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit('change', [{
      added, updated: filteredUpdated, removed
    }, origin])
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit('update', [{
      added, updated, removed
    }, origin])
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlcl95ZG9jX2xpYl9pbmRleF9qcy1ub2RlX21vZHVsZXNfcHJvY2Vzc19icm93c2VyX2pzLjFiZThlOTljOWNhODE0NWUzOTNkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNVO0FBQ1Y7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDVTtBQUNWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUI7QUFDRTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDa0U7QUFDakc7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRDtBQUNQO0FBQ087QUFDekI7QUFDekI7QUFDQTtBQUNBO0FBQ08seURBQXlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixvQ0FBSztBQUM1Qix3QkFBd0IscUNBQU07QUFDOUIsMEJBQTBCLG9DQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxtREFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBeUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscURBQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQU07QUFDbEMsNkJBQTZCLHFEQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9DQUFLO0FBQ2pDO0FBQ0Esa0NBQWtDLDREQUFTO0FBQzNDLG9DQUFvQyw0Q0FBYTtBQUNqRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRDQUFhO0FBQ2pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3AzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDRDtBQUNPO0FBQ3pCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixpQ0FBaUMsYUFBYTtBQUM5QztBQUNBLDRCQUE0QixxREFBTTtBQUNsQztBQUNBLDZCQUE2QixxREFBTTtBQUNuQyxnSUFBZ0ksb0NBQUs7QUFDckk7QUFDQSxnQ0FBZ0MsNENBQWE7QUFDN0M7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEIsNERBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzREFBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUMzQztBQUNBO0FBQ0E7QUFDTyxvQkFBb0Isb0RBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLHNCQUFzQixzREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDVTtBQUNWOzs7Ozs7Ozs7O0FDTEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixhQUFhLHVEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVyL3lkb2MvbGliL2FwaS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIvYXdhcmVuZXNzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AanVweXRlci95ZG9jL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVyL3lkb2MvbGliL3ljZWxsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AanVweXRlci95ZG9jL2xpYi95ZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVyL3lkb2MvbGliL3lmaWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AanVweXRlci95ZG9jL2xpYi95bm90ZWJvb2suanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVyL3lkb2MvbGliL3l0ZXh0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5leHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd2FyZW5lc3MuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSB5ZG9jXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vYXBpLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hd2FyZW5lc3MuanMnO1xuZXhwb3J0ICogZnJvbSAnLi95dGV4dC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3lkb2N1bWVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3lmaWxlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4veW5vdGVib29rLmpzJztcbmV4cG9ydCB7IFlCYXNlQ2VsbCwgWVJhd0NlbGwsIFlNYXJrZG93bkNlbGwsIFlDb2RlQ2VsbCwgY3JlYXRlU3RhbmRhbG9uZUNlbGwgfSBmcm9tICcuL3ljZWxsLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRZTWFwRXZlbnRUb01hcENoYW5nZShldmVudCkge1xuICAgIGxldCBjaGFuZ2VzID0gbmV3IE1hcCgpO1xuICAgIGV2ZW50LmNoYW5nZXMua2V5cy5mb3JFYWNoKChldmVudCwga2V5KSA9PiB7XG4gICAgICAgIGNoYW5nZXMuc2V0KGtleSwge1xuICAgICAgICAgICAgYWN0aW9uOiBldmVudC5hY3Rpb24sXG4gICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQub2xkVmFsdWUsXG4gICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy55bWV0YS5nZXQoa2V5KVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXV0ZXggPSBjcmVhdGVNdXRleCgpXG4gKiBtdXRleCgoKSA9PiB7XG4gKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAqICAgbXV0ZXgoKCkgPT4ge1xuICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhcyB0aGUgbXV0ZXggaXMgYWxyZWFkeSBhY3RpdmUuXG4gKiAgIH0pXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNdXRleCA9ICgpID0+IHtcbiAgICBsZXQgdG9rZW4gPSB0cnVlO1xuICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBKU09ORXh0LCBVVUlEIH0gZnJvbSAnQGx1bWluby9jb3JldXRpbHMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuaW1wb3J0IHsgQXdhcmVuZXNzIH0gZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzJztcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNoYXJlZCBjZWxsIG1vZGVsIGdpdmVuIHRoZSBZSlMgc2hhcmVkIHR5cGUuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDZWxsTW9kZWxGcm9tU2hhcmVkVHlwZSA9ICh0eXBlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUuZ2V0KCdjZWxsX3R5cGUnKSkge1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWUNvZGVDZWxsKHR5cGUsIHR5cGUuZ2V0KCdzb3VyY2UnKSwgdHlwZS5nZXQoJ291dHB1dHMnKSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgJ21hcmtkb3duJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWU1hcmtkb3duQ2VsbCh0eXBlLCB0eXBlLmdldCgnc291cmNlJyksIG9wdGlvbnMpO1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBZUmF3Q2VsbCh0eXBlLCB0eXBlLmdldCgnc291cmNlJyksIG9wdGlvbnMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1bmtub3duIGNlbGwgdHlwZScpO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjZWxsIHRoYXQgY2FuIGJlIGluc2VydGVkIGluIGFuIGV4aXN0aW5nIHNoYXJlZCBtb2RlbC5cbiAqXG4gKiBJZiBubyBub3RlYm9vayBpcyBzcGVjaWZpZWQgdGhlIGNlbGwgd2lsbCBiZSBzdGFuZGFsb25lLlxuICpcbiAqIEBwYXJhbSBjZWxsIENlbGwgSlNPTiByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIG5vdGVib29rIE5vdGVib29rIHRvIHdoaWNoIHRoZSBjZWxsIHdpbGwgYmUgYWRkZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNlbGwgPSAoY2VsbCwgbm90ZWJvb2spID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHltb2RlbCA9IG5ldyBZLk1hcCgpO1xuICAgIGNvbnN0IHlzb3VyY2UgPSBuZXcgWS5UZXh0KCk7XG4gICAgY29uc3QgeW1ldGFkYXRhID0gbmV3IFkuTWFwKCk7XG4gICAgeW1vZGVsLnNldCgnc291cmNlJywgeXNvdXJjZSk7XG4gICAgeW1vZGVsLnNldCgnbWV0YWRhdGEnLCB5bWV0YWRhdGEpO1xuICAgIHltb2RlbC5zZXQoJ2NlbGxfdHlwZScsIGNlbGwuY2VsbF90eXBlKTtcbiAgICB5bW9kZWwuc2V0KCdpZCcsIChfYSA9IGNlbGwuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUQudXVpZDQoKSk7XG4gICAgbGV0IHljZWxsO1xuICAgIHN3aXRjaCAoY2VsbC5jZWxsX3R5cGUpIHtcbiAgICAgICAgY2FzZSAnbWFya2Rvd24nOiB7XG4gICAgICAgICAgICB5Y2VsbCA9IG5ldyBZTWFya2Rvd25DZWxsKHltb2RlbCwgeXNvdXJjZSwgeyBub3RlYm9vayB9LCB5bWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKGNlbGwuYXR0YWNobWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHljZWxsLnNldEF0dGFjaG1lbnRzKGNlbGwuYXR0YWNobWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHlvdXRwdXRzID0gbmV3IFkuQXJyYXkoKTtcbiAgICAgICAgICAgIHltb2RlbC5zZXQoJ291dHB1dHMnLCB5b3V0cHV0cyk7XG4gICAgICAgICAgICB5Y2VsbCA9IG5ldyBZQ29kZUNlbGwoeW1vZGVsLCB5c291cmNlLCB5b3V0cHV0cywge1xuICAgICAgICAgICAgICAgIG5vdGVib29rXG4gICAgICAgICAgICB9LCB5bWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY0NlbGwgPSBjZWxsO1xuICAgICAgICAgICAgeWNlbGwuZXhlY3V0aW9uX2NvdW50ID0gKF9iID0gY0NlbGwuZXhlY3V0aW9uX2NvdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGNDZWxsLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB5Y2VsbC5zZXRPdXRwdXRzKGNDZWxsLm91dHB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gcmF3XG4gICAgICAgICAgICB5Y2VsbCA9IG5ldyBZUmF3Q2VsbCh5bW9kZWwsIHlzb3VyY2UsIHsgbm90ZWJvb2sgfSwgeW1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChjZWxsLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgeWNlbGwuc2V0QXR0YWNobWVudHMoY2VsbC5hdHRhY2htZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2VsbC5tZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHljZWxsLnNldE1ldGFkYXRhKGNlbGwubWV0YWRhdGEpO1xuICAgIH1cbiAgICBpZiAoY2VsbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICB5Y2VsbC5zZXRTb3VyY2UodHlwZW9mIGNlbGwuc291cmNlID09PSAnc3RyaW5nJyA/IGNlbGwuc291cmNlIDogY2VsbC5zb3VyY2Uuam9pbignJykpO1xuICAgIH1cbiAgICByZXR1cm4geWNlbGw7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2VsbCB0aGF0IGNhbm5vdCBiZSBpbnNlcnRlZCBpbiBhbiBleGlzdGluZyBzaGFyZWQgbW9kZWwuXG4gKlxuICogQHBhcmFtIGNlbGwgQ2VsbCBKU09OIHJlcHJlc2VudGF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTdGFuZGFsb25lQ2VsbCA9IChjZWxsKSA9PiBjcmVhdGVDZWxsKGNlbGwpO1xuZXhwb3J0IGNsYXNzIFlCYXNlQ2VsbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFlDZWxsIHRoYXQgd29ya3Mgc3RhbmRhbG9uZS4gSXQgY2Fubm90IGJlXG4gICAgICogaW5zZXJ0ZWQgaW50byBhIFlOb3RlYm9vayBiZWNhdXNlIHRoZSBZanMgbW9kZWwgaXMgYWxyZWFkeVxuICAgICAqIGF0dGFjaGVkIHRvIGFuIGFub255bW91cyBZLkRvYyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGlkKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDZWxsKHsgaWQsIGNlbGxfdHlwZTogdGhpcy5wcm90b3R5cGUuY2VsbF90eXBlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlIGNlbGwgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqICMjIyBOb3Rlc1xuICAgICAqIERvbid0IHVzZSB0aGUgY29uc3RydWN0b3IgZGlyZWN0bHkgLSBwcmVmZXIgdXNpbmcgYGBZTm90ZWJvb2suaW5zZXJ0Q2VsbGBgXG4gICAgICpcbiAgICAgKiBUaGUgYGB5c291cmNlYGAgaXMgbmVlZGVkIGJlY2F1c2UgYGB5bW9kZWwuZ2V0KCdzb3VyY2UnKWBgIHdpbGxcbiAgICAgKiBub3QgcmV0dXJuIHRoZSByZWFsIHNvdXJjZSBpZiB0aGUgbW9kZWwgaXMgbm90IHlldCBhdHRhY2hlZCB0b1xuICAgICAqIGEgZG9jdW1lbnQuIFJlcXVlc3RpbmcgaXQgZXhwbGljaXRseSBhbGxvd3MgdG8gaW50cm9zcGVjdCBhIG5vbi1lbXB0eVxuICAgICAqIHNvdXJjZSBiZWZvcmUgdGhlIGNlbGwgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHltb2RlbCBDZWxsIG1hcFxuICAgICAqIEBwYXJhbSB5c291cmNlIENlbGwgc291cmNlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgXFx7IG5vdGVib29rPzogVGhlIG5vdGVib29rIHRoZSBjZWxsIGlzIGF0dGFjaGVkIHRvIFxcfVxuICAgICAqIEBwYXJhbSB5bWV0YWRhdGEgQ2VsbCBtZXRhZGF0YVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHltb2RlbCwgeXNvdXJjZSwgb3B0aW9ucyA9IHt9LCB5bWV0YWRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSBhIGNoYW5nZSB0byB0aGUgeW1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbW9kZWxPYnNlcnZlciA9IChldmVudHMsIHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ub3JpZ2luICE9PSAnc2lsZW50LWNoYW5nZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodGhpcy5nZXRDaGFuZ2VzKGV2ZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9tZXRhZGF0YUNoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5vdGVib29rIHRoYXQgdGhpcyBjZWxsIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ub3RlYm9vayA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdW5kb01hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnltb2RlbCA9IHltb2RlbDtcbiAgICAgICAgdGhpcy5feXNvdXJjZSA9IHlzb3VyY2U7XG4gICAgICAgIHRoaXMuX3ltZXRhZGF0YSA9IHltZXRhZGF0YSAhPT0gbnVsbCAmJiB5bWV0YWRhdGEgIT09IHZvaWQgMCA/IHltZXRhZGF0YSA6IHRoaXMueW1vZGVsLmdldCgnbWV0YWRhdGEnKTtcbiAgICAgICAgdGhpcy5fcHJldlNvdXJjZUxlbmd0aCA9IHlzb3VyY2UgPyB5c291cmNlLmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuX25vdGVib29rID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXdhcmVuZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5kb01hbmFnZXIgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5ub3RlYm9vaykge1xuICAgICAgICAgICAgdGhpcy5fbm90ZWJvb2sgPSBvcHRpb25zLm5vdGVib29rO1xuICAgICAgICAgICAgLy8gV2UgY2Fubm90IGNyZWF0ZSBhIHVuZG8gbWFuYWdlciB3aXRoIHRoZSBjZWxsIG5vdCB5ZXQgYXR0YWNoZWQgaW4gdGhlIG5vdGVib29rXG4gICAgICAgICAgICAvLyBzbyB3ZSBkZWZlciB0aGF0IHRvIHRoZSBub3RlYm9vayBpbnNlcnRDZWxsIG1ldGhvZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RhbmRhbG9uZSBjZWxsXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgWS5Eb2MoKTtcbiAgICAgICAgICAgIGRvYy5nZXRBcnJheSgpLmluc2VydCgwLCBbdGhpcy55bW9kZWxdKTtcbiAgICAgICAgICAgIHRoaXMuX2F3YXJlbmVzcyA9IG5ldyBBd2FyZW5lc3MoZG9jKTtcbiAgICAgICAgICAgIHRoaXMuX3VuZG9NYW5hZ2VyID0gbmV3IFkuVW5kb01hbmFnZXIoW3RoaXMueW1vZGVsXSwge1xuICAgICAgICAgICAgICAgIHRyYWNrZWRPcmlnaW5zOiBuZXcgU2V0KFt0aGlzXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueW1vZGVsLm9ic2VydmVEZWVwKHRoaXMuX21vZGVsT2JzZXJ2ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZWxsIG5vdGVib29rIGF3YXJlbmVzcyBvciBudWxsIGlmIHRoZSBjZWxsIGlzIHN0YW5kYWxvbmUuXG4gICAgICovXG4gICAgZ2V0IGF3YXJlbmVzcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoX2MgPSAoX2EgPSB0aGlzLl9hd2FyZW5lc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRoaXMubm90ZWJvb2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hd2FyZW5lc3MpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIGdldCBjZWxsX3R5cGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBZQmFzZUNlbGwgbXVzdCBub3QgYmUgY29uc3RydWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNoYW5nZWQgc2lnbmFsLlxuICAgICAqL1xuICAgIGdldCBjaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY2VsbCBpcyBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2VsbCBpZFxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbW9kZWwgaGFzIGJlZW4gZGlzcG9zZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGdldCBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2VsbCBpcyBzdGFuZGFsb25lIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjZWxsIGlzIHN0YW5kYWxvbmUuIEl0IGNhbm5vdCBiZVxuICAgICAqIGluc2VydGVkIGludG8gYSBZTm90ZWJvb2sgYmVjYXVzZSB0aGUgWWpzIG1vZGVsIGlzIGFscmVhZHlcbiAgICAgKiBhdHRhY2hlZCB0byBhbiBhbm9ueW1vdXMgWS5Eb2MgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0IGlzU3RhbmRhbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdGVib29rICE9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZWxsIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFlvdSBzaG91bGQgcHJlZmVyIHRvIGFjY2VzcyBhbmQgbW9kaWZ5IHRoZSBzcGVjaWZpYyBrZXkgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSgpO1xuICAgIH1cbiAgICBzZXQgbWV0YWRhdGEodikge1xuICAgICAgICB0aGlzLnNldE1ldGFkYXRhKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgdHJpZ2dlcmVkIHdoZW4gdGhlIGNlbGwgbWV0YWRhdGEgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGFDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbm90ZWJvb2sgdGhhdCB0aGlzIGNlbGwgYmVsb25ncyB0by5cbiAgICAgKi9cbiAgICBnZXQgbm90ZWJvb2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3RlYm9vaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2VsbCBpbnB1dCBjb250ZW50LlxuICAgICAqL1xuICAgIGdldCBzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpO1xuICAgIH1cbiAgICBzZXQgc291cmNlKHYpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIHVuZG8gbWFuYWdlci5cbiAgICAgKi9cbiAgICBnZXQgdW5kb01hbmFnZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm5vdGVib29rKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5kb01hbmFnZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLm5vdGVib29rKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvKVxuICAgICAgICAgICAgPyB0aGlzLl91bmRvTWFuYWdlclxuICAgICAgICAgICAgOiB0aGlzLm5vdGVib29rLnVuZG9NYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZlciBzZXR0aW5nIHRoZSB1bmRvIG1hbmFnZXIgYXMgaXQgcmVxdWlyZXMgdGhlXG4gICAgICogY2VsbCB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm90ZWJvb2sgWSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBzZXRVbmRvTWFuYWdlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VuZG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjZWxsIHVuZG8gbWFuYWdlciBpcyBhbHJlYWR5IHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbm90ZWJvb2sgJiYgdGhpcy5fbm90ZWJvb2suZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvKSB7XG4gICAgICAgICAgICB0aGlzLl91bmRvTWFuYWdlciA9IG5ldyBZLlVuZG9NYW5hZ2VyKFt0aGlzLnltb2RlbF0sIHtcbiAgICAgICAgICAgICAgICB0cmFja2VkT3JpZ2luczogbmV3IFNldChbdGhpc10pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgeXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3lzb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG9iamVjdCBjYW4gdW5kbyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNhblVuZG8oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudW5kb01hbmFnZXIgJiYgdGhpcy51bmRvTWFuYWdlci51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgb2JqZWN0IGNhbiByZWRvIGNoYW5nZXMuXG4gICAgICovXG4gICAgY2FuUmVkbygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy51bmRvTWFuYWdlciAmJiB0aGlzLnVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY2hhbmdlIHN0YWNrLlxuICAgICAqL1xuICAgIGNsZWFyVW5kb0hpc3RvcnkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy51bmRvTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuZG8gYW4gb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHVuZG8oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy51bmRvTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuZG8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkbyBhbiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgcmVkbygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnVuZG9NYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkbygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMueW1vZGVsLnVub2JzZXJ2ZURlZXAodGhpcy5fbW9kZWxPYnNlcnZlcik7XG4gICAgICAgIGlmICh0aGlzLl9hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIC8vIEEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWQgZm9yIHN0YW5kYWxvbmUgY2VsbC5cbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX2F3YXJlbmVzcy5kb2M7XG4gICAgICAgICAgICB0aGlzLl9hd2FyZW5lc3MuZGVzdHJveSgpO1xuICAgICAgICAgICAgZG9jLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5kb01hbmFnZXIpIHtcbiAgICAgICAgICAgIC8vIEJlIHN1cmUgdG8gbm90IGRlc3Ryb3kgdGhlIGRvY3VtZW50IHVuZG8gbWFuYWdlci5cbiAgICAgICAgICAgIGlmICh0aGlzLl91bmRvTWFuYWdlciA9PT0gKChfYSA9IHRoaXMubm90ZWJvb2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bmRvTWFuYWdlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmRvTWFuYWdlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmRvTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQuZW1pdCgpO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY2VsbCBpZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIENlbGwgaWRcbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueW1vZGVsLmdldCgnaWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjZWxsJ3Mgc291cmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQ2VsbCdzIHNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXRTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnlzb3VyY2UudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBjZWxsJ3Mgc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlOiBOZXcgc291cmNlLlxuICAgICAqL1xuICAgIHNldFNvdXJjZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMueXNvdXJjZS5kZWxldGUoMCwgdGhpcy55c291cmNlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnlzb3VyY2UuaW5zZXJ0KDAsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0b2RvIERvIHdlIG5lZWQgcHJvcGVyIHJlcGxhY2Ugc2VtYW50aWM/IFRoaXMgbGVhZHMgdG8gaXNzdWVzIGluIGVkaXRvciBiaW5kaW5ncyBiZWNhdXNlIHRoZXkgZG9uJ3Qgc3dpdGNoIHNvdXJjZS5cbiAgICAgICAgLy8gdGhpcy55bW9kZWwuc2V0KCdzb3VyY2UnLCBuZXcgWS5UZXh0KHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgY29udGVudCBmcm9tIGBzdGFydCcgdG8gYGVuZGAgd2l0aCBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0OiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlcGxhY2UgKGluY2x1c2l2ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5kOiBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZSB0byByZXBsYWNlIChleGNsdXNpdmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlOiBOZXcgc291cmNlIChvcHRpb25hbCkuXG4gICAgICovXG4gICAgdXBkYXRlU291cmNlKHN0YXJ0LCBlbmQsIHZhbHVlID0gJycpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5c291cmNlID0gdGhpcy55c291cmNlO1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuZCB0aGVuIGRlbGV0ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjdXJzb3IgcG9zaXRpb24gaXMgYWRqdXN0ZWQgYWZ0ZXIgdGhlIHJlcGxhY2VkIGNvbnRlbnQuXG4gICAgICAgICAgICB5c291cmNlLmluc2VydChzdGFydCwgdmFsdWUpO1xuICAgICAgICAgICAgeXNvdXJjZS5kZWxldGUoc3RhcnQgKyB2YWx1ZS5sZW5ndGgsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIG1ldGFkYXRhIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gZGVsZXRlXG4gICAgICovXG4gICAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXRNZXRhZGF0YShrZXkpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5feW1ldGFkYXRhLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgY29uc3QganVweXRlciA9IHRoaXMuZ2V0TWV0YWRhdGEoJ2p1cHl0ZXInKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjb2xsYXBzZWQnICYmIGp1cHl0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBvdXRwdXRzX2hpZGRlbiwgLi4ub3RoZXJzIH0gPSBqdXB5dGVyO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvdGhlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95bWV0YWRhdGEuZGVsZXRlKCdqdXB5dGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95bWV0YWRhdGEuc2V0KCdqdXB5dGVyJywgb3RoZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdqdXB5dGVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ltZXRhZGF0YS5kZWxldGUoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKGtleSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuX3ltZXRhZGF0YTtcbiAgICAgICAgLy8gVHJhbnNpZW50bHkgdGhlIG1ldGFkYXRhIGNhbiBiZSBtaXNzaW5nIC0gbGlrZSBkdXJpbmcgZGVzdHJ1Y3Rpb25cbiAgICAgICAgaWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1ldGFkYXRhLmdldChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZCAvLyB1bmRlZmluZWQgaXMgY29udmVydGVkIHRvIGB7fWAgYnkgYEpTT05FeHQuZGVlcENvcHlgXG4gICAgICAgICAgICAgICAgOiBKU09ORXh0LmRlZXBDb3B5KG1ldGFkYXRhLmdldChrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09ORXh0LmRlZXBDb3B5KG1ldGFkYXRhLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRNZXRhZGF0YShtZXRhZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWV0YWRhdGEgdmFsdWUgZm9yICR7bWV0YWRhdGF9IGNhbm5vdCBiZSAndW5kZWZpbmVkJzsgdXNlIGRlbGV0ZU1ldGFkYXRhLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbWV0YWRhdGE7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCBtZXRhZGF0YSBpZiB3ZSBjaGFuZ2Ugc29tZXRoaW5nIHRvIGF2b2lkIGluZmluaXRlXG4gICAgICAgICAgICAvLyBsb29wIG9mIHNpZ25hbCBjaGFuZ2VzLlxuICAgICAgICAgICAgaWYgKEpTT05FeHQuZGVlcEVxdWFsKChfYSA9IHRoaXMuZ2V0TWV0YWRhdGEoa2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ltZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NvbGxhcHNlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganVweXRlciA9ICgoX2EgPSB0aGlzLmdldE1ldGFkYXRhKCdqdXB5dGVyJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGp1cHl0ZXIub3V0cHV0c19oaWRkZW4gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE1ldGFkYXRhKCdqdXB5dGVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmp1cHl0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0c19oaWRkZW46IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdqdXB5dGVyJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0hpZGRlbiA9IHZhbHVlWydvdXRwdXRzX2hpZGRlbiddO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzSGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0TWV0YWRhdGEoJ2NvbGxhcHNlZCcpICE9PSBpc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWV0YWRhdGEoJ2NvbGxhcHNlZCcsIGlzSGlkZGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlTWV0YWRhdGEoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBKU09ORXh0LmRlZXBDb3B5KG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChjbG9uZS5jb2xsYXBzZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsb25lLmp1cHl0ZXIgPSBjbG9uZS5qdXB5dGVyIHx8IHt9O1xuICAgICAgICAgICAgICAgIGNsb25lLmp1cHl0ZXIub3V0cHV0c19oaWRkZW4gPSBjbG9uZS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoKF9iID0gY2xvbmUgPT09IG51bGwgfHwgY2xvbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb25lLmp1cHl0ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vdXRwdXRzX2hpZGRlbikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsb25lLmNvbGxhcHNlZCA9IGNsb25lLmp1cHl0ZXIub3V0cHV0c19oaWRkZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUpTT05FeHQuZGVlcEVxdWFsKGNsb25lLCB0aGlzLmdldE1ldGFkYXRhKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNsb25lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feW1ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1vZGVsIHRvIEpTT04uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIGNlbGxfdHlwZTogdGhpcy5jZWxsX3R5cGUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5nZXRNZXRhZGF0YSgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSB0cmFuc2FjdGlvbi4gV2hpbGUgdGhlIGZ1bmN0aW9uIGYgaXMgY2FsbGVkLCBhbGwgY2hhbmdlcyB0byB0aGUgc2hhcmVkXG4gICAgICogZG9jdW1lbnQgYXJlIGJ1bmRsZWQgaW50byBhIHNpbmdsZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmIFRyYW5zYWN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0gdW5kb2FibGUgV2hldGhlciB0byB0cmFjayB0aGUgY2hhbmdlIGluIHRoZSBhY3Rpb24gaGlzdG9yeSBvciBub3QgKGRlZmF1bHQgYHRydWVgKVxuICAgICAqL1xuICAgIHRyYW5zYWN0KGYsIHVuZG9hYmxlID0gdHJ1ZSwgb3JpZ2luID0gbnVsbCkge1xuICAgICAgICAhdGhpcy5ub3RlYm9vayB8fCB0aGlzLm5vdGVib29rLmRpc2FibGVEb2N1bWVudFdpZGVVbmRvUmVkb1xuICAgICAgICAgICAgPyB0aGlzLnltb2RlbC5kb2MgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZigpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnltb2RlbC5kb2MudHJhbnNhY3QoZiwgdW5kb2FibGUgPyB0aGlzIDogb3JpZ2luKVxuICAgICAgICAgICAgOiB0aGlzLm5vdGVib29rLnRyYW5zYWN0KGYsIHVuZG9hYmxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBjaGFuZ2VzIGZyb20gWUpTIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50cyBZSlMgZXZlbnRzXG4gICAgICogQHJldHVybnMgQ2VsbCBjaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlcyhldmVudHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHt9O1xuICAgICAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50cy5maW5kKGV2ZW50ID0+IGV2ZW50LnRhcmdldCA9PT0gdGhpcy55bW9kZWwuZ2V0KCdzb3VyY2UnKSk7XG4gICAgICAgIGlmIChzb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgY2hhbmdlcy5zb3VyY2VDaGFuZ2UgPSBzb3VyY2VFdmVudC5jaGFuZ2VzLmRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhRXZlbnRzID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLl95bWV0YWRhdGEpO1xuICAgICAgICBpZiAobWV0YWRhdGFFdmVudHMpIHtcbiAgICAgICAgICAgIGNoYW5nZXMubWV0YWRhdGFDaGFuZ2UgPSBtZXRhZGF0YUV2ZW50cy5jaGFuZ2VzLmtleXM7XG4gICAgICAgICAgICBtZXRhZGF0YUV2ZW50cy5jaGFuZ2VzLmtleXMuZm9yRWFjaCgoY2hhbmdlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMuX3ltZXRhZGF0YS5nZXQoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuX3ltZXRhZGF0YS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGNoYW5nZS5vbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG5ld1ZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gSlNPTkV4dC5kZWVwRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gb2xkVmFsdWUgPT09IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbCk7XG4gICAgICAgIC8vIFRoZSBtb2RlbCBhbGxvd3MgdXMgdG8gcmVwbGFjZSB0aGUgY29tcGxldGUgc291cmNlIHdpdGggYSBuZXcgc3RyaW5nLiBXZSBleHByZXNzIHRoaXMgaW4gdGhlIERlbHRhIGZvcm1hdFxuICAgICAgICAvLyBhcyBhIHJlcGxhY2Ugb2YgdGhlIGNvbXBsZXRlIHN0cmluZy5cbiAgICAgICAgY29uc3QgeXNvdXJjZSA9IHRoaXMueW1vZGVsLmdldCgnc291cmNlJyk7XG4gICAgICAgIGlmIChtb2RlbEV2ZW50ICYmIG1vZGVsRXZlbnQua2V5c0NoYW5nZWQuaGFzKCdzb3VyY2UnKSkge1xuICAgICAgICAgICAgY2hhbmdlcy5zb3VyY2VDaGFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgeyBkZWxldGU6IHRoaXMuX3ByZXZTb3VyY2VMZW5ndGggfSxcbiAgICAgICAgICAgICAgICB7IGluc2VydDogeXNvdXJjZS50b1N0cmluZygpIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldlNvdXJjZUxlbmd0aCA9IHlzb3VyY2UubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG59XG4vKipcbiAqIFNoYXJlYWJsZSBjb2RlIGNlbGwuXG4gKi9cbmV4cG9ydCBjbGFzcyBZQ29kZUNlbGwgZXh0ZW5kcyBZQmFzZUNlbGwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBZQ29kZUNlbGwgdGhhdCB3b3JrcyBzdGFuZGFsb25lLiBJdCBjYW5ub3QgYmVcbiAgICAgKiBpbnNlcnRlZCBpbnRvIGEgWU5vdGVib29rIGJlY2F1c2UgdGhlIFlqcyBtb2RlbCBpcyBhbHJlYWR5XG4gICAgICogYXR0YWNoZWQgdG8gYW4gYW5vbnltb3VzIFkuRG9jIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoaWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvZGUgY2VsbCBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogIyMjIE5vdGVzXG4gICAgICogRG9uJ3QgdXNlIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseSAtIHByZWZlciB1c2luZyBgYFlOb3RlYm9vay5pbnNlcnRDZWxsYGBcbiAgICAgKlxuICAgICAqIFRoZSBgYHlzb3VyY2VgYCBpcyBuZWVkZWQgYmVjYXVzZSBgYHltb2RlbC5nZXQoJ3NvdXJjZScpYGAgd2lsbFxuICAgICAqIG5vdCByZXR1cm4gdGhlIHJlYWwgc291cmNlIGlmIHRoZSBtb2RlbCBpcyBub3QgeWV0IGF0dGFjaGVkIHRvXG4gICAgICogYSBkb2N1bWVudC4gUmVxdWVzdGluZyBpdCBleHBsaWNpdGx5IGFsbG93cyB0byBpbnRyb3NwZWN0IGEgbm9uLWVtcHR5XG4gICAgICogc291cmNlIGJlZm9yZSB0aGUgY2VsbCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geW1vZGVsIENlbGwgbWFwXG4gICAgICogQHBhcmFtIHlzb3VyY2UgQ2VsbCBzb3VyY2VcbiAgICAgKiBAcGFyYW0geW91dHB1dHMgQ29kZSBjZWxsIG91dHB1dHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBcXHsgbm90ZWJvb2s/OiBUaGUgbm90ZWJvb2sgdGhlIGNlbGwgaXMgYXR0YWNoZWQgdG8gXFx9XG4gICAgICogQHBhcmFtIHltZXRhZGF0YSBDZWxsIG1ldGFkYXRhXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeW1vZGVsLCB5c291cmNlLCB5b3V0cHV0cywgb3B0aW9ucyA9IHt9LCB5bWV0YWRhdGEpIHtcbiAgICAgICAgc3VwZXIoeW1vZGVsLCB5c291cmNlLCBvcHRpb25zLCB5bWV0YWRhdGEpO1xuICAgICAgICB0aGlzLl95b3V0cHV0cyA9IHlvdXRwdXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBnZXQgY2VsbF90eXBlKCkge1xuICAgICAgICByZXR1cm4gJ2NvZGUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBjZWxsJ3MgcHJvbXB0IG51bWJlci4gV2lsbCBiZSBudWxsIGlmIHRoZSBjZWxsIGhhcyBub3QgYmVlbiBydW4uXG4gICAgICovXG4gICAgZ2V0IGV4ZWN1dGlvbl9jb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueW1vZGVsLmdldCgnZXhlY3V0aW9uX2NvdW50JykgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IGV4ZWN1dGlvbl9jb3VudChjb3VudCkge1xuICAgICAgICAvLyBEbyBub3QgdXNlIGB0aGlzLmV4ZWN1dGlvbl9jb3VudGAuIFdoZW4gaW5pdGlhbGl6aW5nIHRoZVxuICAgICAgICAvLyBjZWxsLCB3ZSBuZWVkIHRvIHNldCBleGVjdXRpb25fY291bnQgdG8gYG51bGxgIGlmIHdlIGNvbXBhcmVcbiAgICAgICAgLy8gdXNpbmcgYHRoaXMuZXhlY3V0aW9uX2NvdW50YCBpdCB3aWxsIHJldHVybiBgbnVsbGAgYW5kIHdlIHdpbGxcbiAgICAgICAgLy8gbmV2ZXIgaW5pdGlhbGl6ZSBpdFxuICAgICAgICBpZiAodGhpcy55bW9kZWwuZ2V0KCdleGVjdXRpb25fY291bnQnKSAhPT0gY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMueW1vZGVsLnNldCgnZXhlY3V0aW9uX2NvdW50JywgY291bnQpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2RlIGNlbGwncyBleGVjdXRpb24gc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGV4ZWN1dGlvblN0YXRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnltb2RlbC5nZXQoJ2V4ZWN1dGlvbl9zdGF0ZScpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnaWRsZSc7XG4gICAgfVxuICAgIHNldCBleGVjdXRpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy55bW9kZWwuZ2V0KCdleGVjdXRpb25fc3RhdGUnKSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMueW1vZGVsLnNldCgnZXhlY3V0aW9uX3N0YXRlJywgc3RhdGUpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENlbGwgb3V0cHV0cy5cbiAgICAgKi9cbiAgICBnZXQgb3V0cHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0cygpO1xuICAgIH1cbiAgICBzZXQgb3V0cHV0cyh2KSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0cyh2KTtcbiAgICB9XG4gICAgZ2V0IHlvdXRwdXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feW91dHB1dHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGlvbiwgZGlzcGxheSwgb3Igc3RyZWFtIG91dHB1dHMuXG4gICAgICovXG4gICAgZ2V0T3V0cHV0cygpIHtcbiAgICAgICAgcmV0dXJuIEpTT05FeHQuZGVlcENvcHkodGhpcy5feW91dHB1dHMudG9KU09OKCkpO1xuICAgIH1cbiAgICBjcmVhdGVPdXRwdXRzKG91dHB1dHMpIHtcbiAgICAgICAgY29uc3QgbmV3T3V0cHV0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBKU09ORXh0LmRlZXBDb3B5KG91dHB1dHMpKSB7XG4gICAgICAgICAgICBsZXQgX25ld091dHB1dDE7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm91dHB1dF90eXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdGV4dCBmaWVsZCBhcyBhIFkuVGV4dFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGV4dCwgLi4ub3V0cHV0V2l0aG91dFRleHQgfSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICBfbmV3T3V0cHV0MSA9IG91dHB1dFdpdGhvdXRUZXh0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBuZXcgWS5UZXh0KCk7XG4gICAgICAgICAgICAgICAgbGV0IF90ZXh0ID0gdGV4dCBpbnN0YW5jZW9mIEFycmF5ID8gdGV4dC5qb2luKCkgOiB0ZXh0O1xuICAgICAgICAgICAgICAgIG5ld1RleHQuaW5zZXJ0KDAsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBfbmV3T3V0cHV0MVsndGV4dCddID0gbmV3VGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9uZXdPdXRwdXQxID0gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX25ld091dHB1dDIgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKF9uZXdPdXRwdXQxKSkge1xuICAgICAgICAgICAgICAgIF9uZXdPdXRwdXQyLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld091dHB1dCA9IG5ldyBZLk1hcChfbmV3T3V0cHV0Mik7XG4gICAgICAgICAgICBuZXdPdXRwdXRzLnB1c2gobmV3T3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3V0cHV0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbGwgb3V0cHV0cy5cbiAgICAgKi9cbiAgICBzZXRPdXRwdXRzKG91dHB1dHMpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl95b3V0cHV0cy5kZWxldGUoMCwgdGhpcy5feW91dHB1dHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld091dHB1dHMgPSB0aGlzLmNyZWF0ZU91dHB1dHMob3V0cHV0cyk7XG4gICAgICAgICAgICB0aGlzLl95b3V0cHV0cy5pbnNlcnQoMCwgbmV3T3V0cHV0cyk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRleHQgZnJvbSBhIHN0cmVhbSBvdXRwdXQuXG4gICAgICovXG4gICAgcmVtb3ZlU3RyZWFtT3V0cHV0KGluZGV4LCBzdGFydCwgb3JpZ2luID0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuX3lvdXRwdXRzLmdldChpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2VGV4dCA9IG91dHB1dC5nZXQoJ3RleHQnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHByZXZUZXh0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICAgICAgcHJldlRleHQuZGVsZXRlKHN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICB9LCBmYWxzZSwgb3JpZ2luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kIHRleHQgdG8gYSBzdHJlYW0gb3V0cHV0LlxuICAgICAqL1xuICAgIGFwcGVuZFN0cmVhbU91dHB1dChpbmRleCwgdGV4dCwgb3JpZ2luID0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuX3lvdXRwdXRzLmdldChpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2VGV4dCA9IG91dHB1dC5nZXQoJ3RleHQnKTtcbiAgICAgICAgICAgIHByZXZUZXh0Lmluc2VydChwcmV2VGV4dC5sZW5ndGgsIHRleHQpO1xuICAgICAgICB9LCBmYWxzZSwgb3JpZ2luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBjb250ZW50IGZyb20gYHN0YXJ0JyB0byBgZW5kYCB3aXRoIGBvdXRwdXRzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydDogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSB0byByZXBsYWNlIChpbmNsdXNpdmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZDogVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgdG8gcmVwbGFjZSAoZXhjbHVzaXZlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdXRwdXRzOiBOZXcgb3V0cHV0cyAob3B0aW9uYWwpLlxuICAgICAqL1xuICAgIHVwZGF0ZU91dHB1dHMoc3RhcnQsIGVuZCwgb3V0cHV0cyA9IFtdLCBvcmlnaW4gPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZpbiA9IGVuZCA8IHRoaXMuX3lvdXRwdXRzLmxlbmd0aCA/IGVuZCAtIHN0YXJ0IDogdGhpcy5feW91dHB1dHMubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5feW91dHB1dHMuZGVsZXRlKHN0YXJ0LCBmaW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3T3V0cHV0cyA9IHRoaXMuY3JlYXRlT3V0cHV0cyhvdXRwdXRzKTtcbiAgICAgICAgICAgIHRoaXMuX3lvdXRwdXRzLmluc2VydChzdGFydCwgbmV3T3V0cHV0cyk7XG4gICAgICAgIH0sIGZhbHNlLCBvcmlnaW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1vZGVsIHRvIEpTT04uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBvdXRwdXRzOiB0aGlzLmdldE91dHB1dHMoKSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9jb3VudDogdGhpcy5leGVjdXRpb25fY291bnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBjaGFuZ2VzIGZyb20gWUpTIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50cyBZSlMgZXZlbnRzXG4gICAgICogQHJldHVybnMgQ2VsbCBjaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlcyhldmVudHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHN1cGVyLmdldENoYW5nZXMoZXZlbnRzKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtT3V0cHV0RXZlbnQgPSBldmVudHMuZmluZChcbiAgICAgICAgLy8gQ2hhbmdlcyB0byB0aGUgJ3RleHQnIG9mIGEgY2VsbCdzIHN0cmVhbSBvdXRwdXQgY2FuIGJlIGFjY2Vzc2VkIGxpa2Ugc286XG4gICAgICAgIC8vIHljZWxsWydvdXRwdXRzJ11bb3V0cHV0X2lkeF1bJ3RleHQnXVxuICAgICAgICAvLyBUaGlzIHRyYW5zbGF0ZXMgdG8gYW4gZXZlbnQgcGF0aCBvZjogWydvdXRwdXRzJywgb3V0cHV0X2lkeCwgJ3RleHRdXG4gICAgICAgIGV2ZW50ID0+IGV2ZW50LnBhdGgubGVuZ3RoID09PSAzICYmXG4gICAgICAgICAgICBldmVudC5wYXRoWzBdID09PSAnb3V0cHV0cycgJiZcbiAgICAgICAgICAgIGV2ZW50LnBhdGhbMl0gPT09ICd0ZXh0Jyk7XG4gICAgICAgIGlmIChzdHJlYW1PdXRwdXRFdmVudCkge1xuICAgICAgICAgICAgY2hhbmdlcy5zdHJlYW1PdXRwdXRDaGFuZ2UgPSBzdHJlYW1PdXRwdXRFdmVudC5jaGFuZ2VzLmRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbC5nZXQoJ291dHB1dHMnKSk7XG4gICAgICAgIGlmIChvdXRwdXRFdmVudCkge1xuICAgICAgICAgICAgY2hhbmdlcy5vdXRwdXRzQ2hhbmdlID0gb3V0cHV0RXZlbnQuY2hhbmdlcy5kZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbCk7XG4gICAgICAgIGlmIChtb2RlbEV2ZW50ICYmIG1vZGVsRXZlbnQua2V5c0NoYW5nZWQuaGFzKCdleGVjdXRpb25fY291bnQnKSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gbW9kZWxFdmVudC5jaGFuZ2VzLmtleXMuZ2V0KCdleGVjdXRpb25fY291bnQnKTtcbiAgICAgICAgICAgIGNoYW5nZXMuZXhlY3V0aW9uQ291bnRDaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy55bW9kZWwuZ2V0KCdleGVjdXRpb25fY291bnQnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZWxFdmVudCAmJiBtb2RlbEV2ZW50LmtleXNDaGFuZ2VkLmhhcygnZXhlY3V0aW9uX3N0YXRlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IG1vZGVsRXZlbnQuY2hhbmdlcy5rZXlzLmdldCgnZXhlY3V0aW9uX3N0YXRlJyk7XG4gICAgICAgICAgICBjaGFuZ2VzLmV4ZWN1dGlvblN0YXRlQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMueW1vZGVsLmdldCgnZXhlY3V0aW9uX3N0YXRlJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgWUF0dGFjaG1lbnRDZWxsIGV4dGVuZHMgWUJhc2VDZWxsIHtcbiAgICAvKipcbiAgICAgKiBDZWxsIGF0dGFjaG1lbnRzXG4gICAgICovXG4gICAgZ2V0IGF0dGFjaG1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRhY2htZW50cygpO1xuICAgIH1cbiAgICBzZXQgYXR0YWNobWVudHModikge1xuICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnRzKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZWxsIGF0dGFjaG1lbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNlbGwgYXR0YWNobWVudHMuXG4gICAgICovXG4gICAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnltb2RlbC5nZXQoJ2F0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNlbGwgYXR0YWNobWVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50czogVGhlIGNlbGwgYXR0YWNobWVudHMuXG4gICAgICovXG4gICAgc2V0QXR0YWNobWVudHMoYXR0YWNobWVudHMpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0YWNobWVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueW1vZGVsLmRlbGV0ZSgnYXR0YWNobWVudHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueW1vZGVsLnNldCgnYXR0YWNobWVudHMnLCBhdHRhY2htZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBjaGFuZ2VzIGZyb20gWUpTIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50cyBZSlMgZXZlbnRzXG4gICAgICogQHJldHVybnMgQ2VsbCBjaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlcyhldmVudHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHN1cGVyLmdldENoYW5nZXMoZXZlbnRzKTtcbiAgICAgICAgY29uc3QgbW9kZWxFdmVudCA9IGV2ZW50cy5maW5kKGV2ZW50ID0+IGV2ZW50LnRhcmdldCA9PT0gdGhpcy55bW9kZWwpO1xuICAgICAgICBpZiAobW9kZWxFdmVudCAmJiBtb2RlbEV2ZW50LmtleXNDaGFuZ2VkLmhhcygnYXR0YWNobWVudHMnKSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gbW9kZWxFdmVudC5jaGFuZ2VzLmtleXMuZ2V0KCdhdHRhY2htZW50cycpO1xuICAgICAgICAgICAgY2hhbmdlcy5hdHRhY2htZW50c0NoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogY2hhbmdlLm9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiB0aGlzLnltb2RlbC5nZXQoJ2F0dGFjaG1lbnRzJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxufVxuLyoqXG4gKiBTaGFyZWFibGUgcmF3IGNlbGwuXG4gKi9cbmV4cG9ydCBjbGFzcyBZUmF3Q2VsbCBleHRlbmRzIFlBdHRhY2htZW50Q2VsbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFlSYXdDZWxsIHRoYXQgd29ya3Mgc3RhbmRhbG9uZS4gSXQgY2Fubm90IGJlXG4gICAgICogaW5zZXJ0ZWQgaW50byBhIFlOb3RlYm9vayBiZWNhdXNlIHRoZSBZanMgbW9kZWwgaXMgYWxyZWFkeVxuICAgICAqIGF0dGFjaGVkIHRvIGFuIGFub255bW91cyBZLkRvYyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGlkKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHR5cGUgb2YgY2VsbC5cbiAgICAgKi9cbiAgICBnZXQgY2VsbF90eXBlKCkge1xuICAgICAgICByZXR1cm4gJ3Jhdyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbW9kZWwgdG8gSlNPTi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5nZXRJZCgpLFxuICAgICAgICAgICAgY2VsbF90eXBlOiAncmF3JyxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLmdldE1ldGFkYXRhKCksXG4gICAgICAgICAgICBhdHRhY2htZW50czogdGhpcy5nZXRBdHRhY2htZW50cygpXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBTaGFyZWFibGUgbWFya2Rvd24gY2VsbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFlNYXJrZG93bkNlbGwgZXh0ZW5kcyBZQXR0YWNobWVudENlbGwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBZTWFya2Rvd25DZWxsIHRoYXQgd29ya3Mgc3RhbmRhbG9uZS4gSXQgY2Fubm90IGJlXG4gICAgICogaW5zZXJ0ZWQgaW50byBhIFlOb3RlYm9vayBiZWNhdXNlIHRoZSBZanMgbW9kZWwgaXMgYWxyZWFkeVxuICAgICAqIGF0dGFjaGVkIHRvIGFuIGFub255bW91cyBZLkRvYyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGlkKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHR5cGUgb2YgY2VsbC5cbiAgICAgKi9cbiAgICBnZXQgY2VsbF90eXBlKCkge1xuICAgICAgICByZXR1cm4gJ21hcmtkb3duJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtb2RlbCB0byBKU09OLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldElkKCksXG4gICAgICAgICAgICBjZWxsX3R5cGU6ICdtYXJrZG93bicsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5nZXRNZXRhZGF0YSgpLFxuICAgICAgICAgICAgYXR0YWNobWVudHM6IHRoaXMuZ2V0QXR0YWNobWVudHMoKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXljZWxsLmpzLm1hcCIsIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgSlNPTkV4dCB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbmltcG9ydCB7IEF3YXJlbmVzcyB9IGZyb20gJ3ktcHJvdG9jb2xzL2F3YXJlbmVzcyc7XG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcyc7XG4vKipcbiAqIEdlbmVyaWMgc2hhcmVhYmxlIGRvY3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgWURvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSBhIGNoYW5nZSB0byB0aGUgeXN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDaGFuZ2UgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGV2ZW50LmtleXNDaGFuZ2VkLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBldmVudC5jaGFuZ2VzLmtleXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy55c3RhdGUuZ2V0KGtleSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQoeyBzdGF0ZUNoYW5nZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl95ZG9jID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnlkb2MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBZLkRvYygpO1xuICAgICAgICB0aGlzLl95c3RhdGUgPSB0aGlzLl95ZG9jLmdldE1hcCgnc3RhdGUnKTtcbiAgICAgICAgdGhpcy5fdW5kb01hbmFnZXIgPSBuZXcgWS5VbmRvTWFuYWdlcihbXSwge1xuICAgICAgICAgICAgdHJhY2tlZE9yaWdpbnM6IG5ldyBTZXQoW3RoaXNdKSxcbiAgICAgICAgICAgIGRvYzogdGhpcy5feWRvY1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXdhcmVuZXNzID0gbmV3IEF3YXJlbmVzcyh0aGlzLl95ZG9jKTtcbiAgICAgICAgdGhpcy5feXN0YXRlLm9ic2VydmUodGhpcy5vblN0YXRlQ2hhbmdlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFlKUyBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBnZXQgeWRvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3lkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNoYXJlZCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCB5c3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95c3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFlKUyBkb2N1bWVudCB1bmRvIG1hbmFnZXJcbiAgICAgKi9cbiAgICBnZXQgdW5kb01hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bmRvTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hhcmVkIGF3YXJlbmVzc1xuICAgICAqL1xuICAgIGdldCBhd2FyZW5lc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hd2FyZW5lc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFuZ2VkIHNpZ25hbC5cbiAgICAgKi9cbiAgICBnZXQgY2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgZG9jdW1lbnQgaXMgZGlzcG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIGRpc3Bvc2VkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvY3VtZW50IHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gSlNPTkV4dC5kZWVwQ29weSh0aGlzLnlzdGF0ZS50b0pTT04oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG9iamVjdCBjYW4gdW5kbyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNhblVuZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBvYmplY3QgY2FuIHJlZG8gY2hhbmdlcy5cbiAgICAgKi9cbiAgICBjYW5SZWRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMueXN0YXRlLnVub2JzZXJ2ZSh0aGlzLm9uU3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5hd2FyZW5lc3MuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnVuZG9NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy55ZG9jLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQuZW1pdCgpO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGZvciBhIHN0YXRlIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBLZXkgdG8gZ2V0XG4gICAgICovXG4gICAgZ2V0U3RhdGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy55c3RhdGUuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IEpTT05FeHQuZGVlcENvcHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IEtleSB0byBzZXRcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFN0YXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFKU09ORXh0LmRlZXBFcXVhbCh0aGlzLnlzdGF0ZS5nZXQoa2V5KSwgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnlzdGF0ZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb2N1bWVudCBzb3VyY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzb3VyY2VcbiAgICAgKi9cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkb2N1bWVudCBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc291cmNlIHRvIHNldFxuICAgICAqL1xuICAgIHNldCBzb3VyY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2UodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmRvIGFuIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICB1bmRvKCkge1xuICAgICAgICB0aGlzLnVuZG9NYW5hZ2VyLnVuZG8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkbyBhbiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgcmVkbygpIHtcbiAgICAgICAgdGhpcy51bmRvTWFuYWdlci5yZWRvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjaGFuZ2Ugc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJVbmRvSGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy51bmRvTWFuYWdlci5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgdHJhbnNhY3Rpb24uIFdoaWxlIHRoZSBmdW5jdGlvbiBmIGlzIGNhbGxlZCwgYWxsIGNoYW5nZXMgdG8gdGhlIHNoYXJlZFxuICAgICAqIGRvY3VtZW50IGFyZSBidW5kbGVkIGludG8gYSBzaW5nbGUgZXZlbnQuXG4gICAgICovXG4gICAgdHJhbnNhY3QoZiwgdW5kb2FibGUgPSB0cnVlLCBvcmlnaW4gPSBudWxsKSB7XG4gICAgICAgIHRoaXMueWRvYy50cmFuc2FjdChmLCB1bmRvYWJsZSA/IHRoaXMgOiBvcmlnaW4pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXlkb2N1bWVudC5qcy5tYXAiLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFlEb2N1bWVudCB9IGZyb20gJy4veWRvY3VtZW50LmpzJztcbi8qKlxuICogU2hhcmVhYmxlIHRleHQgZmlsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFlGaWxlIGV4dGVuZHMgWURvY3VtZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZmlsZVxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkb2N1bWVudCBpcyBlbXB0eSBhbmQgbXVzdCBiZSBwb3B1bGF0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvY3VtZW50IHZlcnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVyc2lvbiA9ICcxLjAuMCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZSlMgZmlsZSB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55c291cmNlID0gdGhpcy55ZG9jLmdldFRleHQoJ3NvdXJjZScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGEgY2hhbmdlIHRvIHRoZSB5bW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tb2RlbE9ic2VydmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQoeyBzb3VyY2VDaGFuZ2U6IGV2ZW50LmNoYW5nZXMuZGVsdGEgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5kb01hbmFnZXIuYWRkVG9TY29wZSh0aGlzLnlzb3VyY2UpO1xuICAgICAgICB0aGlzLnlzb3VyY2Uub2JzZXJ2ZSh0aGlzLl9tb2RlbE9ic2VydmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YW5kYWxvbmUgWUZpbGVcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFlGaWxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbGUgdGV4dFxuICAgICAqL1xuICAgIGdldCBzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpO1xuICAgIH1cbiAgICBzZXQgc291cmNlKHYpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55c291cmNlLnVub2JzZXJ2ZSh0aGlzLl9tb2RlbE9ic2VydmVyKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbGUgdGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEZpbGUgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnlzb3VyY2UudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWxlIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHRleHRcbiAgICAgKi9cbiAgICBzZXRTb3VyY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5dGV4dCA9IHRoaXMueXNvdXJjZTtcbiAgICAgICAgICAgIHl0ZXh0LmRlbGV0ZSgwLCB5dGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgeXRleHQuaW5zZXJ0KDAsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgY29udGVudCBmcm9tIGBzdGFydCcgdG8gYGVuZGAgd2l0aCBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0OiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlcGxhY2UgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGVuZDogVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgdG8gcmVwbGFjZSAoZXhjbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0gdmFsdWU6IE5ldyBzb3VyY2UgKG9wdGlvbmFsKS5cbiAgICAgKi9cbiAgICB1cGRhdGVTb3VyY2Uoc3RhcnQsIGVuZCwgdmFsdWUgPSAnJykge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHlzb3VyY2UgPSB0aGlzLnlzb3VyY2U7XG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5kIHRoZW4gZGVsZXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBwb3NpdGlvbiBpcyBhZGp1c3RlZCBhZnRlciB0aGUgcmVwbGFjZWQgY29udGVudC5cbiAgICAgICAgICAgIHlzb3VyY2UuaW5zZXJ0KHN0YXJ0LCB2YWx1ZSk7XG4gICAgICAgICAgICB5c291cmNlLmRlbGV0ZShzdGFydCArIHZhbHVlLmxlbmd0aCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD15ZmlsZS5qcy5tYXAiLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEpTT05FeHQgfSBmcm9tICdAbHVtaW5vL2NvcmV1dGlscyc7XG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcyc7XG5pbXBvcnQgeyBZRG9jdW1lbnQgfSBmcm9tICcuL3lkb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDZWxsLCBjcmVhdGVDZWxsTW9kZWxGcm9tU2hhcmVkVHlwZSB9IGZyb20gJy4veWNlbGwuanMnO1xuLyoqXG4gKiBTaGFyZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYXJlZCBEb2N1bWVudCB0eXBlcy5cbiAqXG4gKiBTaGFyZWQgY2VsbHMgY2FuIGJlIGluc2VydGVkIGludG8gYSBTaGFyZWROb3RlYm9vay5cbiAqIFNoYXJlZCBjZWxscyBvbmx5IHN0YXJ0IGVtaXR0aW5nIGV2ZW50cyB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZCB0byBhIFNoYXJlZE5vdGVib29rLlxuICpcbiAqIFwiU3RhbmRhbG9uZVwiIGNlbGxzIG11c3Qgbm90IGJlIGluc2VydGVkIGludG8gYSAoU2hhcmVkKU5vdGVib29rLlxuICogU3RhbmRhbG9uZSBjZWxscyBlbWl0IGV2ZW50cyBpbW1lZGlhdGVseSBhZnRlciB0aGV5IGhhdmUgYmVlbiBjcmVhdGVkLCBidXQgdGhleSBtdXN0IG5vdFxuICogYmUgaW5jbHVkZWQgaW50byBhIChTaGFyZWQpTm90ZWJvb2suXG4gKi9cbmV4cG9ydCBjbGFzcyBZTm90ZWJvb2sgZXh0ZW5kcyBZRG9jdW1lbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub3RlYm9va1xuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkb2N1bWVudCBpcyBlbXB0eSBhbmQgbXVzdCBiZSBwb3B1bGF0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvY3VtZW50IHZlcnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVyc2lvbiA9ICcyLjAuMCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZSlMgbWFwIGZvciB0aGUgbm90ZWJvb2sgbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueW1ldGEgPSB0aGlzLnlkb2MuZ2V0TWFwKCdtZXRhJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgYSBjaGFuZ2UgdG8gdGhlIHlzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uTWV0YUNoYW5nZWQgPSAoZXZlbnRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YUV2ZW50cyA9IGV2ZW50cy5maW5kKGV2ZW50ID0+IGV2ZW50LnRhcmdldCA9PT0gdGhpcy55bWV0YS5nZXQoJ21ldGFkYXRhJykpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFDaGFuZ2UgPSBtZXRhZGF0YUV2ZW50cy5jaGFuZ2VzLmtleXM7XG4gICAgICAgICAgICAgICAgY29uc3QgeW1ldGFkYXRhID0gdGhpcy55bWV0YS5nZXQoJ21ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFFdmVudHMuY2hhbmdlcy5rZXlzLmZvckVhY2goKGNoYW5nZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YUNoYW5nZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiB5bWV0YWRhdGEuZ2V0KGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGFDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogY2hhbmdlLm9sZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB5bWV0YWRhdGEuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gY2hhbmdlLm9sZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiBuZXdWYWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWwgPSBKU09ORXh0LmRlZXBFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWwgPSBvbGRWYWx1ZSA9PT0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGFDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQoeyBtZXRhZGF0YUNoYW5nZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1ldGFFdmVudCA9IGV2ZW50cy5maW5kKGV2ZW50ID0+IGV2ZW50LnRhcmdldCA9PT0gdGhpcy55bWV0YSk7XG4gICAgICAgICAgICBpZiAoIW1ldGFFdmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhRXZlbnQua2V5c0NoYW5nZWQuaGFzKCdtZXRhZGF0YScpKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1ldGFkYXRhIGNoYW5nZSB3aGVuIGFkZGluZy9yZW1vdmluZyB0aGUgWU1hcFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IG1ldGFFdmVudC5jaGFuZ2VzLmtleXMuZ2V0KCdtZXRhZGF0YScpO1xuICAgICAgICAgICAgICAgIGlmICgoY2hhbmdlID09PSBudWxsIHx8IGNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbmdlLmFjdGlvbikgPT09ICdhZGQnICYmICFjaGFuZ2Uub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFDaGFuZ2UgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUNoYW5nZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnYWRkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMuZ2V0TWV0YWRhdGEoa2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHsgbWV0YWRhdGFDaGFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFFdmVudC5rZXlzQ2hhbmdlZC5oYXMoJ25iZm9ybWF0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBtZXRhRXZlbnQuY2hhbmdlcy5rZXlzLmdldCgnbmJmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYmZvcm1hdENoYW5nZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ25iZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IChjaGFuZ2UgPT09IG51bGwgfHwgY2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFuZ2Uub2xkVmFsdWUpID8gY2hhbmdlLm9sZFZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy5uYmZvcm1hdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHsgbmJmb3JtYXRDaGFuZ2VkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFFdmVudC5rZXlzQ2hhbmdlZC5oYXMoJ25iZm9ybWF0X21pbm9yJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBtZXRhRXZlbnQuY2hhbmdlcy5rZXlzLmdldCgnbmJmb3JtYXRfbWlub3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYmZvcm1hdENoYW5nZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ25iZm9ybWF0X21pbm9yJyxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IChjaGFuZ2UgPT09IG51bGwgfHwgY2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFuZ2Uub2xkVmFsdWUpID8gY2hhbmdlLm9sZFZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy5uYmZvcm1hdF9taW5vclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHsgbmJmb3JtYXRDaGFuZ2VkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGEgY2hhbmdlIHRvIHRoZSBsaXN0IG9mIGNlbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25ZQ2VsbHNDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHR5cGUgY2VsbCBtYXBwaW5nIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBhZGRlZC9yZW1vdmVkIHR5cGVzXG4gICAgICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGl0ZW0uY29udGVudC50eXBlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5feWNlbGxNYXBwaW5nLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gY3JlYXRlQ2VsbE1vZGVsRnJvbVNoYXJlZFR5cGUodHlwZSwgeyBub3RlYm9vazogdGhpcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRVbmRvTWFuYWdlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95Y2VsbE1hcHBpbmcuc2V0KHR5cGUsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnQuY2hhbmdlcy5kZWxldGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGl0ZW0uY29udGVudC50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5feWNlbGxNYXBwaW5nLmdldCh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95Y2VsbE1hcHBpbmcuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIHRoaXMgcmVmbGVjdHMgdGhlIGV2ZW50LmNoYW5nZXMuZGVsdGEsIGJ1dCByZXBsYWNlcyB0aGUgY29udGVudCBvZiBkZWx0YS5pbnNlcnQgd2l0aCB5Y2VsbHNcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzQ2hhbmdlID0gW107XG4gICAgICAgICAgICBldmVudC5jaGFuZ2VzLmRlbHRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRlZENlbGxzID0gZC5pbnNlcnQubWFwKCh5Y2VsbCkgPT4gdGhpcy5feWNlbGxNYXBwaW5nLmdldCh5Y2VsbCkpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsc0NoYW5nZS5wdXNoKHsgaW5zZXJ0OiBpbnNlcnRlZENlbGxzIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzLnNwbGljZShpbmRleCwgMCwgLi4uaW5zZXJ0ZWRDZWxscyk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGQuaW5zZXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZC5kZWxldGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsc0NoYW5nZS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzLnNwbGljZShpbmRleCwgZC5kZWxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkLnJldGFpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzQ2hhbmdlLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGQucmV0YWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjZWxsc0NoYW5nZTogY2VsbHNDaGFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9tZXRhZGF0YUNoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgWWpzIGNlbGxzIGxpc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ljZWxscyA9IHRoaXMueWRvYy5nZXRBcnJheSgnY2VsbHMnKTtcbiAgICAgICAgdGhpcy5feWNlbGxNYXBwaW5nID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvID1cbiAgICAgICAgICAgIChfYSA9IG9wdGlvbnMuZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuX3ljZWxscy50b0FycmF5KCkubWFwKHljZWxsID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5feWNlbGxNYXBwaW5nLmhhcyh5Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl95Y2VsbE1hcHBpbmcuc2V0KHljZWxsLCBjcmVhdGVDZWxsTW9kZWxGcm9tU2hhcmVkVHlwZSh5Y2VsbCwgeyBub3RlYm9vazogdGhpcyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feWNlbGxNYXBwaW5nLmdldCh5Y2VsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuZG9NYW5hZ2VyLmFkZFRvU2NvcGUodGhpcy5feWNlbGxzKTtcbiAgICAgICAgdGhpcy5feWNlbGxzLm9ic2VydmUodGhpcy5fb25ZQ2VsbHNDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy55bWV0YS5vYnNlcnZlRGVlcCh0aGlzLl9vbk1ldGFDaGFuZ2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YW5kYWxvbmUgWU5vdGVib29rXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiB3ZSBuZWVkIHRvIGluaXRpYWxpemVcbiAgICAgKiB0aGUgWU5vdGVib29rIGZyb20gdGhlIEphdmFTY3JpcHQgc2lkZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgY29uc3QgeW5vdGVib29rID0gbmV3IFlOb3RlYm9vayh7XG4gICAgICAgICAgICBkaXNhYmxlRG9jdW1lbnRXaWRlVW5kb1JlZG86IChfYSA9IG9wdGlvbnMuZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGNlbGxzOiAoX2MgPSAoX2IgPSBvcHRpb25zLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jZWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10sXG4gICAgICAgICAgICBuYmZvcm1hdDogKF9lID0gKF9kID0gb3B0aW9ucy5kYXRhKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubmJmb3JtYXQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDQsXG4gICAgICAgICAgICBuYmZvcm1hdF9taW5vcjogKF9nID0gKF9mID0gb3B0aW9ucy5kYXRhKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubmJmb3JtYXRfbWlub3IpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDUsXG4gICAgICAgICAgICBtZXRhZGF0YTogKF9qID0gKF9oID0gb3B0aW9ucy5kYXRhKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gubWV0YWRhdGEpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHlub3RlYm9vay5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgcmV0dXJuIHlub3RlYm9vaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2V0aGVyIHRoZSB1bmRvL3JlZG8gbG9naWMgc2hvdWxkIGJlXG4gICAgICogY29uc2lkZXJlZCBvbiB0aGUgZnVsbCBkb2N1bWVudCBhY3Jvc3MgYWxsIGNlbGxzLlxuICAgICAqXG4gICAgICogRGVmYXVsdDogZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RlYm9vayBtZXRhZGF0YVxuICAgICAqL1xuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWV0YWRhdGEoKTtcbiAgICB9XG4gICAgc2V0IG1ldGFkYXRhKHYpIHtcbiAgICAgICAgdGhpcy5zZXRNZXRhZGF0YSh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIHRyaWdnZXJlZCB3aGVuIGEgbWV0YWRhdGEgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGFDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBuYmZvcm1hdCBtYWpvciB2ZXJzaW9uXG4gICAgICovXG4gICAgZ2V0IG5iZm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy55bWV0YS5nZXQoJ25iZm9ybWF0Jyk7XG4gICAgfVxuICAgIHNldCBuYmZvcm1hdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMueW1ldGEuc2V0KCduYmZvcm1hdCcsIHZhbHVlKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBuYmZvcm1hdCBtaW5vciB2ZXJzaW9uXG4gICAgICovXG4gICAgZ2V0IG5iZm9ybWF0X21pbm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55bWV0YS5nZXQoJ25iZm9ybWF0X21pbm9yJyk7XG4gICAgfVxuICAgIHNldCBuYmZvcm1hdF9taW5vcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMueW1ldGEuc2V0KCduYmZvcm1hdF9taW5vcicsIHZhbHVlKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ljZWxscy51bm9ic2VydmUodGhpcy5fb25ZQ2VsbHNDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy55bWV0YS51bm9ic2VydmVEZWVwKHRoaXMuX29uTWV0YUNoYW5nZWQpO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNoYXJlZCBjZWxsIGJ5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4OiBDZWxsJ3MgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVxdWVzdGVkIHNoYXJlZCBjZWxsLlxuICAgICAqL1xuICAgIGdldENlbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHNbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzaGFyZWQgY2VsbCBhdCB0aGUgbm90ZWJvb2sgYm90dG9tLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlbGwgQ2VsbCB0byBhZGQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkZWQgY2VsbC5cbiAgICAgKi9cbiAgICBhZGRDZWxsKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2VsbCh0aGlzLl95Y2VsbHMubGVuZ3RoLCBjZWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgc2hhcmVkIGNlbGwgaW50byBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4OiBDZWxsJ3MgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIGNlbGw6IENlbGwgdG8gaW5zZXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluc2VydGVkIGNlbGwuXG4gICAgICovXG4gICAgaW5zZXJ0Q2VsbChpbmRleCwgY2VsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRDZWxscyhpbmRleCwgW2NlbGxdKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbGlzdCBvZiBzaGFyZWQgY2VsbHMgaW50byBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4OiBQb3NpdGlvbiB0byBpbnNlcnQgdGhlIGNlbGxzLlxuICAgICAqIEBwYXJhbSBjZWxsczogQXJyYXkgb2Ygc2hhcmVkIGNlbGxzIHRvIGluc2VydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnNlcnRlZCBjZWxscy5cbiAgICAgKi9cbiAgICBpbnNlcnRDZWxscyhpbmRleCwgY2VsbHMpIHtcbiAgICAgICAgY29uc3QgeUNlbGxzID0gY2VsbHMubWFwKGMgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNyZWF0ZUNlbGwoYywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl95Y2VsbE1hcHBpbmcuc2V0KGNlbGwueW1vZGVsLCBjZWxsKTtcbiAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl95Y2VsbHMuaW5zZXJ0KGluZGV4LCB5Q2VsbHMubWFwKGNlbGwgPT4gY2VsbC55bW9kZWwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlDZWxscy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgYy5zZXRVbmRvTWFuYWdlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHlDZWxscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZSBhIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUluZGV4OiBJbmRleCBvZiB0aGUgY2VsbCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB0b0luZGV4OiBOZXcgcG9zaXRpb24gb2YgdGhlIGNlbGwuXG4gICAgICovXG4gICAgbW92ZUNlbGwoZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIHRoaXMubW92ZUNlbGxzKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmUgY2VsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUluZGV4OiBJbmRleCBvZiB0aGUgZmlyc3QgY2VsbHMgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0gdG9JbmRleDogTmV3IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBjZWxsIChpbiB0aGUgY3VycmVudCBhcnJheSkuXG4gICAgICogQHBhcmFtIG46IE51bWJlciBvZiBjZWxscyB0byBtb3ZlIChkZWZhdWx0IDEpXG4gICAgICovXG4gICAgbW92ZUNlbGxzKGZyb21JbmRleCwgdG9JbmRleCwgbiA9IDEpIHtcbiAgICAgICAgLy8gRklYTUUgd2UgbmVlZCB0byB1c2UgeWpzIG1vdmUgZmVhdHVyZSB0byBwcmVzZXJ2ZSB1bmRvIGhpc3RvcnlcbiAgICAgICAgY29uc3QgY2xvbmVzID0gbmV3IEFycmF5KG4pXG4gICAgICAgICAgICAuZmlsbCh0cnVlKVxuICAgICAgICAgICAgLm1hcCgoXywgaWR4KSA9PiB0aGlzLmdldENlbGwoZnJvbUluZGV4ICsgaWR4KS50b0pTT04oKSk7XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5feWNlbGxzLmRlbGV0ZShmcm9tSW5kZXgsIG4pO1xuICAgICAgICAgICAgdGhpcy5feWNlbGxzLmluc2VydChmcm9tSW5kZXggPiB0b0luZGV4ID8gdG9JbmRleCA6IHRvSW5kZXggLSBuICsgMSwgY2xvbmVzLm1hcChjbG9uZSA9PiBjcmVhdGVDZWxsKGNsb25lLCB0aGlzKS55bW9kZWwpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXg6IEluZGV4IG9mIHRoZSBjZWxsIHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICBkZWxldGVDZWxsKGluZGV4KSB7XG4gICAgICAgIHRoaXMuZGVsZXRlQ2VsbFJhbmdlKGluZGV4LCBpbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSByYW5nZSBvZiBjZWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tOiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlbW92ZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0gdG86IFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlbW92ZSAoZXhjbHVzaXZlKS5cbiAgICAgKi9cbiAgICBkZWxldGVDZWxsUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgLy8gQ2VsbHMgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIG1hcHBpbmcgaW4gdGhlIG1vZGVsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ljZWxscy5kZWxldGUoZnJvbSwgdG8gLSBmcm9tKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIG1ldGFkYXRhIG5vdGVib29rLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGRlbGV0ZVxuICAgICAqL1xuICAgIGRlbGV0ZU1ldGFkYXRhKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2V0TWV0YWRhdGEoa2V5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIGRlbGV0ZSBhbGxNZXRhZGF0YVtrZXldO1xuICAgICAgICB0aGlzLnNldE1ldGFkYXRhKGFsbE1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgICAgIGNvbnN0IHltZXRhZGF0YSA9IHRoaXMueW1ldGEuZ2V0KCdtZXRhZGF0YScpO1xuICAgICAgICAvLyBUcmFuc2llbnRseSB0aGUgbWV0YWRhdGEgY2FuIGJlIG1pc3NpbmcgLSBsaWtlIGR1cmluZyBkZXN0cnVjdGlvblxuICAgICAgICBpZiAoeW1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHltZXRhZGF0YS5nZXQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWQgLy8gdW5kZWZpbmVkIGlzIGNvbnZlcnRlZCB0byBge31gIGJ5IGBKU09ORXh0LmRlZXBDb3B5YFxuICAgICAgICAgICAgICAgIDogSlNPTkV4dC5kZWVwQ29weSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTkV4dC5kZWVwQ29weSh5bWV0YWRhdGEudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE1ldGFkYXRhKG1ldGFkYXRhLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1ldGFkYXRhIHZhbHVlIGZvciAke21ldGFkYXRhfSBjYW5ub3QgYmUgJ3VuZGVmaW5lZCc7IHVzZSBkZWxldGVNZXRhZGF0YS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChKU09ORXh0LmRlZXBFcXVhbCgoX2EgPSB0aGlzLmdldE1ldGFkYXRhKG1ldGFkYXRhKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgICAgICAgICB1cGRhdGVbbWV0YWRhdGFdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEgfHwgIUpTT05FeHQuZGVlcEVxdWFsKHRoaXMubWV0YWRhdGEsIG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gSlNPTkV4dC5kZWVwQ29weShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeW1ldGFkYXRhID0gdGhpcy55bWV0YS5nZXQoJ21ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgLy8gVHJhbnNpZW50bHkgdGhlIG1ldGFkYXRhIGNhbiBiZSBtaXNzaW5nIC0gbGlrZSBkdXJpbmcgZGVzdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoeW1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHltZXRhZGF0YS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjbG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHltZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIG5vdGVib29rLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlOiBNZXRhZGF0YSdzIGF0dHJpYnV0ZSB0byB1cGRhdGUuXG4gICAgICovXG4gICAgdXBkYXRlTWV0YWRhdGEodmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETzogTWF5YmUgbW9kaWZ5IG9ubHkgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGUgd2hvbGUgbWV0YWRhdGE/XG4gICAgICAgIGNvbnN0IGNsb25lID0gSlNPTkV4dC5kZWVwQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHltZXRhZGF0YSA9IHRoaXMueW1ldGEuZ2V0KCdtZXRhZGF0YScpO1xuICAgICAgICAvLyBUcmFuc2llbnRseSB0aGUgbWV0YWRhdGEgY2FuIGJlIG1pc3NpbmcgLSBsaWtlIGR1cmluZyBkZXN0cnVjdGlvblxuICAgICAgICBpZiAoeW1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjbG9uZSkpIHtcbiAgICAgICAgICAgICAgICB5bWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBub3RlYm9vayBzb3VyY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBub3RlYm9va1xuICAgICAqL1xuICAgIGdldFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90ZWJvb2sgc291cmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5vdGVib29rXG4gICAgICovXG4gICAgc2V0U291cmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnJvbUpTT04odmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgbm90ZWJvb2sgd2l0aCBhIEpTT04tc2VyaWFsaXplZCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmJmb3JtYXQgPSB2YWx1ZS5uYmZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMubmJmb3JtYXRfbWlub3IgPSB2YWx1ZS5uYmZvcm1hdF9taW5vcjtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdmFsdWUubWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGFbJ29yaWdfbmJmb3JtYXQnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1ldGFkYXRhWydvcmlnX25iZm9ybWF0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5bWV0YWRhdGEgPSBuZXcgWS5NYXAoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeW1ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy55bWV0YS5zZXQoJ21ldGFkYXRhJywgeW1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVzZUlkID0gdmFsdWUubmJmb3JtYXQgPT09IDQgJiYgdmFsdWUubmJmb3JtYXRfbWlub3IgPj0gNTtcbiAgICAgICAgICAgIGNvbnN0IHljZWxscyA9IHZhbHVlLmNlbGxzLm1hcChjZWxsID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRDZWxscyh0aGlzLmNlbGxzLmxlbmd0aCwgeWNlbGxzKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlQ2VsbFJhbmdlKDAsIHRoaXMuY2VsbHMubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbW9kZWwgdG8gSlNPTi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIC8vIHN0cmlwIGNlbGwgaWRzIGlmIHdlIGhhdmUgbm90ZWJvb2sgZm9ybWF0IDQuMC00LjRcbiAgICAgICAgY29uc3QgcHJ1bmVDZWxsSWQgPSB0aGlzLm5iZm9ybWF0ID09PSA0ICYmIHRoaXMubmJmb3JtYXRfbWlub3IgPD0gNDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgbmJmb3JtYXRfbWlub3I6IHRoaXMubmJmb3JtYXRfbWlub3IsXG4gICAgICAgICAgICBuYmZvcm1hdDogdGhpcy5uYmZvcm1hdCxcbiAgICAgICAgICAgIGNlbGxzOiB0aGlzLmNlbGxzLm1hcChjID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBjLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIGlmIChwcnVuZUNlbGxJZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmF3LmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD15bm90ZWJvb2suanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD15dGV4dC5qcy5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBAbW9kdWxlIGF3YXJlbmVzcy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBmIGZyb20gJ2xpYjAvZnVuY3Rpb24nXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5leHBvcnQgY29uc3Qgb3V0ZGF0ZWRUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhQ2xpZW50U3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUuY2xvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUubGFzdFVwZGF0ZWQgdW5peCB0aW1lc3RhbXBcbiAqL1xuXG4vKipcbiAqIFRoZSBBd2FyZW5lc3MgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsZSBzaGFyZWQgc3RhdGUgcHJvdG9jb2wgdGhhdCBjYW4gYmUgdXNlZCBmb3Igbm9uLXBlcnNpc3RlbnQgZGF0YSBsaWtlIGF3YXJlbmVzcyBpbmZvcm1hdGlvblxuICogKGN1cnNvciwgdXNlcm5hbWUsIHN0YXR1cywgLi4pLiBFYWNoIGNsaWVudCBjYW4gdXBkYXRlIGl0cyBvd24gbG9jYWwgc3RhdGUgYW5kIGxpc3RlbiB0byBzdGF0ZSBjaGFuZ2VzIG9mXG4gKiByZW1vdGUgY2xpZW50cy4gRXZlcnkgY2xpZW50IG1heSBzZXQgYSBzdGF0ZSBvZiBhIHJlbW90ZSBwZWVyIHRvIGBudWxsYCB0byBtYXJrIHRoZSBjbGllbnQgYXMgb2ZmbGluZS5cbiAqXG4gKiBFYWNoIGNsaWVudCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGNsaWVudCBpZCAoc29tZXRoaW5nIHdlIGJvcnJvdyBmcm9tIGBkb2MuY2xpZW50SURgKS4gQSBjbGllbnQgY2FuIG92ZXJyaWRlXG4gKiBpdHMgb3duIHN0YXRlIGJ5IHByb3BhZ2F0aW5nIGEgbWVzc2FnZSB3aXRoIGFuIGluY3JlYXNpbmcgdGltZXN0YW1wIChgY2xvY2tgKS4gSWYgc3VjaCBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGl0IGlzXG4gKiBhcHBsaWVkIGlmIHRoZSBrbm93biBzdGF0ZSBvZiB0aGF0IGNsaWVudCBpcyBvbGRlciB0aGFuIHRoZSBuZXcgc3RhdGUgKGBjbG9jayA8IG5ld0Nsb2NrYCkuIElmIGEgY2xpZW50IHRoaW5rcyB0aGF0XG4gKiBhIHJlbW90ZSBjbGllbnQgaXMgb2ZmbGluZSwgaXQgbWF5IHByb3BhZ2F0ZSBhIG1lc3NhZ2Ugd2l0aFxuICogYHsgY2xvY2s6IGN1cnJlbnRDbGllbnRDbG9jaywgc3RhdGU6IG51bGwsIGNsaWVudDogcmVtb3RlQ2xpZW50IH1gLiBJZiBzdWNoIGFcbiAqIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGFuZCB0aGUga25vd24gY2xvY2sgb2YgdGhhdCBjbGllbnQgZXF1YWxzIHRoZSByZWNlaXZlZCBjbG9jaywgaXQgd2lsbCBvdmVycmlkZSB0aGUgc3RhdGUgd2l0aCBgbnVsbGAuXG4gKlxuICogQmVmb3JlIGEgY2xpZW50IGRpc2Nvbm5lY3RzLCBpdCBzaG91bGQgcHJvcGFnYXRlIGEgYG51bGxgIHN0YXRlIHdpdGggYW4gdXBkYXRlZCBjbG9jay5cbiAqXG4gKiBBd2FyZW5lc3Mgc3RhdGVzIG11c3QgYmUgdXBkYXRlZCBldmVyeSAzMCBzZWNvbmRzLiBPdGhlcndpc2UgdGhlIEF3YXJlbmVzcyBpbnN0YW5jZSB3aWxsIGRlbGV0ZSB0aGUgY2xpZW50IHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmV4cG9ydCBjbGFzcyBBd2FyZW5lc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRFxuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnQgaWQgdG8gY2xpZW50IHN0YXRlXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE1ldGFDbGllbnRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBpZiAodGhpcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwgJiYgKG91dGRhdGVkVGltZW91dCAvIDIgPD0gbm93IC0gLyoqIEB0eXBlIHt7bGFzdFVwZGF0ZWQ6bnVtYmVyfX0gKi8gKHRoaXMubWV0YS5nZXQodGhpcy5jbGllbnRJRCkpLmxhc3RVcGRhdGVkKSkge1xuICAgICAgICAvLyByZW5ldyBsb2NhbCBjbG9ja1xuICAgICAgICB0aGlzLnNldExvY2FsU3RhdGUodGhpcy5nZXRMb2NhbFN0YXRlKCkpXG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAgICovXG4gICAgICBjb25zdCByZW1vdmUgPSBbXVxuICAgICAgdGhpcy5tZXRhLmZvckVhY2goKG1ldGEsIGNsaWVudGlkKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnRpZCAhPT0gdGhpcy5jbGllbnRJRCAmJiBvdXRkYXRlZFRpbWVvdXQgPD0gbm93IC0gbWV0YS5sYXN0VXBkYXRlZCAmJiB0aGlzLnN0YXRlcy5oYXMoY2xpZW50aWQpKSB7XG4gICAgICAgICAgcmVtb3ZlLnB1c2goY2xpZW50aWQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAocmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMsIHJlbW92ZSwgJ3RpbWVvdXQnKVxuICAgICAgfVxuICAgIH0sIG1hdGguZmxvb3Iob3V0ZGF0ZWRUaW1lb3V0IC8gMTApKSlcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH0pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKHt9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKVxuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShudWxsKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH1cbiAgICovXG4gIGdldExvY2FsU3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5nZXQodGhpcy5jbGllbnRJRCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9IHN0YXRlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlIChzdGF0ZSkge1xuICAgIGNvbnN0IGNsaWVudElEID0gdGhpcy5jbGllbnRJRFxuICAgIGNvbnN0IGN1cnJMb2NhbE1ldGEgPSB0aGlzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGNsb2NrID0gY3VyckxvY2FsTWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGN1cnJMb2NhbE1ldGEuY2xvY2sgKyAxXG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgIH1cbiAgICB0aGlzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxhc3RVcGRhdGVkOiB0aW1lLmdldFVuaXhUaW1lKClcbiAgICB9KVxuICAgIGNvbnN0IGFkZGVkID0gW11cbiAgICBjb25zdCB1cGRhdGVkID0gW11cbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IHJlbW92ZWQgPSBbXVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIGlmICghZi5lcXVhbGl0eURlZXAocHJldlN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIHNldExvY2FsU3RhdGVGaWVsZCAoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldExvY2FsU3RhdGUoKVxuICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFtmaWVsZF06IHZhbHVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLE9iamVjdDxzdHJpbmcsYW55Pj59XG4gICAqL1xuICBnZXRTdGF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1xuICB9XG59XG5cbi8qKlxuICogTWFyayAocmVtb3RlKSBjbGllbnRzIGFzIGluYWN0aXZlIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwZWVycy5cbiAqIFRoaXMgY2hhbmdlIHdpbGwgYmUgcHJvcGFnYXRlZCB0byByZW1vdGUgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUF3YXJlbmVzc1N0YXRlcyA9IChhd2FyZW5lc3MsIGNsaWVudHMsIG9yaWdpbikgPT4ge1xuICBjb25zdCByZW1vdmVkID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldXG4gICAgaWYgKGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkge1xuICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCkge1xuICAgICAgICBjb25zdCBjdXJNZXRhID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKVxuICAgICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgICBjbG9jazogY3VyTWV0YS5jbG9jayArIDEsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSlcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgY2xpZW50cywgc3RhdGVzID0gYXdhcmVuZXNzLnN0YXRlcykgPT4ge1xuICBjb25zdCBsZW4gPSBjbGllbnRzLmxlbmd0aFxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY2xpZW50SUQpIHx8IG51bGxcbiAgICBjb25zdCBjbG9jayA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSkuY2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSlcbiAgfVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb250ZW50IG9mIGFuIGF3YXJlbmVzcyB1cGRhdGUgYmVmb3JlIHJlLWVuY29kaW5nIGl0IHRvIGFuIGF3YXJlbmVzcyB1cGRhdGUuXG4gKlxuICogVGhpcyBtaWdodCBiZSB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhIGNlbnRyYWwgc2VydmVyIHRoYXQgd2FudHMgdG8gZW5zdXJlIHRoYXQgY2xpZW50c1xuICogY2FudCBoaWphY2sgc29tZWJvZHkgZWxzZXMgaWRlbnRpdHkuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IG1vZGlmeVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IG1vZGlmeUF3YXJlbmVzc1VwZGF0ZSA9ICh1cGRhdGUsIG1vZGlmeSkgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgbW9kaWZpZWRTdGF0ZSA9IG1vZGlmeShzdGF0ZSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KG1vZGlmaWVkU3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IG9yaWdpbiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVtaXR0ZWQgY2hhbmdlIGV2ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgdGltZXN0YW1wID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGFkZGVkID0gW11cbiAgY29uc3QgdXBkYXRlZCA9IFtdXG4gIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgY2xpZW50TWV0YSA9IGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRClcbiAgICBjb25zdCBwcmV2U3RhdGUgPSBhd2FyZW5lc3Muc3RhdGVzLmdldChjbGllbnRJRClcbiAgICBjb25zdCBjdXJyQ2xvY2sgPSBjbGllbnRNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY2xpZW50TWV0YS5jbG9ja1xuICAgIGlmIChjdXJyQ2xvY2sgPCBjbG9jayB8fCAoY3VyckNsb2NrID09PSBjbG9jayAmJiBzdGF0ZSA9PT0gbnVsbCAmJiBhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbmV2ZXIgbGV0IGEgcmVtb3RlIGNsaWVudCByZW1vdmUgdGhpcyBsb2NhbCBzdGF0ZVxuICAgICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCAmJiBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9IG51bGwpIHtcbiAgICAgICAgICAvLyByZW1vdGUgY2xpZW50IHJlbW92ZWQgdGhlIGxvY2FsIHN0YXRlLiBEbyBub3QgcmVtb3RlIHN0YXRlLiBCcm9hZGNhc3QgYSBtZXNzYWdlIGluZGljYXRpbmdcbiAgICAgICAgICAvLyB0aGF0IHRoaXMgY2xpZW50IHN0aWxsIGV4aXN0cyBieSBpbmNyZWFzaW5nIHRoZSBjbG9ja1xuICAgICAgICAgIGNsb2NrKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgIGNsb2NrLFxuICAgICAgICBsYXN0VXBkYXRlZDogdGltZXN0YW1wXG4gICAgICB9KVxuICAgICAgaWYgKGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRNZXRhICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWYuZXF1YWxpdHlEZWVwKHN0YXRlLCBwcmV2U3RhdGUpKSB7XG4gICAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IHVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9