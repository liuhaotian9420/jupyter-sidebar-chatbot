"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_input_tex_AllPackages_js"],{

/***/ "./node_modules/mathjax-full/js/input/tex/AllPackages.js":
/*!***************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/AllPackages.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllPackages = void 0;
__webpack_require__(/*! ./base/BaseConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseConfiguration.js");
__webpack_require__(/*! ./action/ActionConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/action/ActionConfiguration.js");
__webpack_require__(/*! ./ams/AmsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsConfiguration.js");
__webpack_require__(/*! ./amscd/AmsCdConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/amscd/AmsCdConfiguration.js");
__webpack_require__(/*! ./bbox/BboxConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/bbox/BboxConfiguration.js");
__webpack_require__(/*! ./boldsymbol/BoldsymbolConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/boldsymbol/BoldsymbolConfiguration.js");
__webpack_require__(/*! ./braket/BraketConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/braket/BraketConfiguration.js");
__webpack_require__(/*! ./bussproofs/BussproofsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsConfiguration.js");
__webpack_require__(/*! ./cancel/CancelConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/cancel/CancelConfiguration.js");
__webpack_require__(/*! ./cases/CasesConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/cases/CasesConfiguration.js");
__webpack_require__(/*! ./centernot/CenternotConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/centernot/CenternotConfiguration.js");
__webpack_require__(/*! ./color/ColorConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/color/ColorConfiguration.js");
__webpack_require__(/*! ./colorv2/ColorV2Configuration.js */ "./node_modules/mathjax-full/js/input/tex/colorv2/ColorV2Configuration.js");
__webpack_require__(/*! ./colortbl/ColortblConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/colortbl/ColortblConfiguration.js");
__webpack_require__(/*! ./configmacros/ConfigMacrosConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/configmacros/ConfigMacrosConfiguration.js");
__webpack_require__(/*! ./empheq/EmpheqConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/empheq/EmpheqConfiguration.js");
__webpack_require__(/*! ./enclose/EncloseConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/enclose/EncloseConfiguration.js");
__webpack_require__(/*! ./extpfeil/ExtpfeilConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/extpfeil/ExtpfeilConfiguration.js");
__webpack_require__(/*! ./gensymb/GensymbConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/gensymb/GensymbConfiguration.js");
__webpack_require__(/*! ./html/HtmlConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/html/HtmlConfiguration.js");
__webpack_require__(/*! ./mathtools/MathtoolsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsConfiguration.js");
__webpack_require__(/*! ./mhchem/MhchemConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/mhchem/MhchemConfiguration.js");
__webpack_require__(/*! ./newcommand/NewcommandConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandConfiguration.js");
__webpack_require__(/*! ./noerrors/NoErrorsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/noerrors/NoErrorsConfiguration.js");
__webpack_require__(/*! ./noundefined/NoUndefinedConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/noundefined/NoUndefinedConfiguration.js");
__webpack_require__(/*! ./physics/PhysicsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsConfiguration.js");
__webpack_require__(/*! ./setoptions/SetOptionsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/setoptions/SetOptionsConfiguration.js");
__webpack_require__(/*! ./tagformat/TagFormatConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/tagformat/TagFormatConfiguration.js");
__webpack_require__(/*! ./textcomp/TextcompConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/textcomp/TextcompConfiguration.js");
__webpack_require__(/*! ./textmacros/TextMacrosConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosConfiguration.js");
__webpack_require__(/*! ./upgreek/UpgreekConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/upgreek/UpgreekConfiguration.js");
__webpack_require__(/*! ./unicode/UnicodeConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/unicode/UnicodeConfiguration.js");
__webpack_require__(/*! ./verb/VerbConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/verb/VerbConfiguration.js");
if (typeof MathJax !== 'undefined' && MathJax.loader) {
    MathJax.loader.preLoad('[tex]/action', '[tex]/ams', '[tex]/amscd', '[tex]/bbox', '[tex]/boldsymbol', '[tex]/braket', '[tex]/bussproofs', '[tex]/cancel', '[tex]/cases', '[tex]/centernot', '[tex]/color', '[tex]/colorv2', '[tex]/colortbl', '[tex]/empheq', '[tex]/enclose', '[tex]/extpfeil', '[tex]/gensymb', '[tex]/html', '[tex]/mathtools', '[tex]/mhchem', '[tex]/newcommand', '[tex]/noerrors', '[tex]/noundefined', '[tex]/physics', '[tex]/upgreek', '[tex]/unicode', '[tex]/verb', '[tex]/configmacros', '[tex]/tagformat', '[tex]/textcomp', '[tex]/textmacros', '[tex]/setoptions');
}
exports.AllPackages = [
    'base',
    'action',
    'ams',
    'amscd',
    'bbox',
    'boldsymbol',
    'braket',
    'bussproofs',
    'cancel',
    'cases',
    'centernot',
    'color',
    'colortbl',
    'empheq',
    'enclose',
    'extpfeil',
    'gensymb',
    'html',
    'mathtools',
    'mhchem',
    'newcommand',
    'noerrors',
    'noundefined',
    'upgreek',
    'unicode',
    'verb',
    'configmacros',
    'tagformat',
    'textcomp',
    'textmacros'
];
//# sourceMappingURL=AllPackages.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/action/ActionConfiguration.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/action/ActionConfiguration.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionConfiguration = exports.ActionMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
exports.ActionMethods = {};
exports.ActionMethods.Macro = BaseMethods_js_1.default.Macro;
exports.ActionMethods.Toggle = function (parser, name) {
    var children = [];
    var arg;
    while ((arg = parser.GetArgument(name)) !== '\\endtoggle') {
        children.push(new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml());
    }
    parser.Push(parser.create('node', 'maction', children, { actiontype: 'toggle' }));
};
exports.ActionMethods.Mathtip = function (parser, name) {
    var arg = parser.ParseArg(name);
    var tip = parser.ParseArg(name);
    parser.Push(parser.create('node', 'maction', [arg, tip], { actiontype: 'tooltip' }));
};
new SymbolMap_js_1.CommandMap('action-macros', {
    toggle: 'Toggle',
    mathtip: 'Mathtip',
    texttip: ['Macro', '\\mathtip{#1}{\\text{#2}}', 2]
}, exports.ActionMethods);
exports.ActionConfiguration = Configuration_js_1.Configuration.create('action', { handler: { macro: ['action-macros'] } });
//# sourceMappingURL=ActionConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/ams/AmsConfiguration.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/ams/AmsConfiguration.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmsConfiguration = exports.AmsTags = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var AmsItems_js_1 = __webpack_require__(/*! ./AmsItems.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsItems.js");
var Tags_js_1 = __webpack_require__(/*! ../Tags.js */ "./node_modules/mathjax-full/js/input/tex/Tags.js");
var AmsMethods_js_1 = __webpack_require__(/*! ./AmsMethods.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js");
__webpack_require__(/*! ./AmsMappings.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsMappings.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var AmsTags = (function (_super) {
    __extends(AmsTags, _super);
    function AmsTags() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AmsTags;
}(Tags_js_1.AbstractTags));
exports.AmsTags = AmsTags;
var init = function (config) {
    new SymbolMap_js_1.CommandMap(AmsMethods_js_1.NEW_OPS, {}, {});
    config.append(Configuration_js_1.Configuration.local({ handler: { macro: [AmsMethods_js_1.NEW_OPS] },
        priority: -1 }));
};
exports.AmsConfiguration = Configuration_js_1.Configuration.create('ams', {
    handler: {
        character: ['AMSmath-operatorLetter'],
        delimiter: ['AMSsymbols-delimiter', 'AMSmath-delimiter'],
        macro: ['AMSsymbols-mathchar0mi', 'AMSsymbols-mathchar0mo',
            'AMSsymbols-delimiter', 'AMSsymbols-macros',
            'AMSmath-mathchar0mo', 'AMSmath-macros', 'AMSmath-delimiter'],
        environment: ['AMSmath-environment']
    },
    items: (_a = {},
        _a[AmsItems_js_1.MultlineItem.prototype.kind] = AmsItems_js_1.MultlineItem,
        _a[AmsItems_js_1.FlalignItem.prototype.kind] = AmsItems_js_1.FlalignItem,
        _a),
    tags: { 'ams': AmsTags },
    init: init,
    config: function (_config, jax) {
        if (jax.parseOptions.options.multlineWidth) {
            jax.parseOptions.options.ams.multlineWidth = jax.parseOptions.options.multlineWidth;
        }
        delete jax.parseOptions.options.multlineWidth;
    },
    options: {
        multlineWidth: '',
        ams: {
            multlineWidth: '100%',
            multlineIndent: '1em',
        }
    }
});
//# sourceMappingURL=AmsConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/ams/AmsItems.js":
/*!****************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/ams/AmsItems.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlalignItem = exports.MultlineItem = void 0;
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var MultlineItem = (function (_super) {
    __extends(MultlineItem, _super);
    function MultlineItem(factory) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, factory) || this;
        _this.factory.configuration.tags.start('multline', true, args[0]);
        return _this;
    }
    Object.defineProperty(MultlineItem.prototype, "kind", {
        get: function () {
            return 'multline';
        },
        enumerable: false,
        configurable: true
    });
    MultlineItem.prototype.EndEntry = function () {
        if (this.table.length) {
            ParseUtil_js_1.default.fixInitialMO(this.factory.configuration, this.nodes);
        }
        var shove = this.getProperty('shove');
        var mtd = this.create('node', 'mtd', this.nodes, shove ? { columnalign: shove } : {});
        this.setProperty('shove', null);
        this.row.push(mtd);
        this.Clear();
    };
    MultlineItem.prototype.EndRow = function () {
        if (this.row.length !== 1) {
            throw new TexError_js_1.default('MultlineRowsOneCol', 'The rows within the %1 environment must have exactly one column', 'multline');
        }
        var row = this.create('node', 'mtr', this.row);
        this.table.push(row);
        this.row = [];
    };
    MultlineItem.prototype.EndTable = function () {
        _super.prototype.EndTable.call(this);
        if (this.table.length) {
            var m = this.table.length - 1, label = -1;
            if (!NodeUtil_js_1.default.getAttribute(NodeUtil_js_1.default.getChildren(this.table[0])[0], 'columnalign')) {
                NodeUtil_js_1.default.setAttribute(NodeUtil_js_1.default.getChildren(this.table[0])[0], 'columnalign', TexConstants_js_1.TexConstant.Align.LEFT);
            }
            if (!NodeUtil_js_1.default.getAttribute(NodeUtil_js_1.default.getChildren(this.table[m])[0], 'columnalign')) {
                NodeUtil_js_1.default.setAttribute(NodeUtil_js_1.default.getChildren(this.table[m])[0], 'columnalign', TexConstants_js_1.TexConstant.Align.RIGHT);
            }
            var tag = this.factory.configuration.tags.getTag();
            if (tag) {
                label = (this.arraydef.side === TexConstants_js_1.TexConstant.Align.LEFT ? 0 : this.table.length - 1);
                var mtr = this.table[label];
                var mlabel = this.create('node', 'mlabeledtr', [tag].concat(NodeUtil_js_1.default.getChildren(mtr)));
                NodeUtil_js_1.default.copyAttributes(mtr, mlabel);
                this.table[label] = mlabel;
            }
        }
        this.factory.configuration.tags.end();
    };
    return MultlineItem;
}(BaseItems_js_1.ArrayItem));
exports.MultlineItem = MultlineItem;
var FlalignItem = (function (_super) {
    __extends(FlalignItem, _super);
    function FlalignItem(factory, name, numbered, padded, center) {
        var _this = _super.call(this, factory) || this;
        _this.name = name;
        _this.numbered = numbered;
        _this.padded = padded;
        _this.center = center;
        _this.factory.configuration.tags.start(name, numbered, numbered);
        return _this;
    }
    Object.defineProperty(FlalignItem.prototype, "kind", {
        get: function () {
            return 'flalign';
        },
        enumerable: false,
        configurable: true
    });
    FlalignItem.prototype.EndEntry = function () {
        _super.prototype.EndEntry.call(this);
        var n = this.getProperty('xalignat');
        if (!n)
            return;
        if (this.row.length > n) {
            throw new TexError_js_1.default('XalignOverflow', 'Extra %1 in row of %2', '&', this.name);
        }
    };
    FlalignItem.prototype.EndRow = function () {
        var cell;
        var row = this.row;
        var n = this.getProperty('xalignat');
        while (row.length < n) {
            row.push(this.create('node', 'mtd'));
        }
        this.row = [];
        if (this.padded) {
            this.row.push(this.create('node', 'mtd'));
        }
        while ((cell = row.shift())) {
            this.row.push(cell);
            cell = row.shift();
            if (cell)
                this.row.push(cell);
            if (row.length || this.padded) {
                this.row.push(this.create('node', 'mtd'));
            }
        }
        if (this.row.length > this.maxrow) {
            this.maxrow = this.row.length;
        }
        _super.prototype.EndRow.call(this);
        var mtr = this.table[this.table.length - 1];
        if (this.getProperty('zeroWidthLabel') && mtr.isKind('mlabeledtr')) {
            var mtd = NodeUtil_js_1.default.getChildren(mtr)[0];
            var side = this.factory.configuration.options['tagSide'];
            var def = __assign({ width: 0 }, (side === 'right' ? { lspace: '-1width' } : {}));
            var mpadded = this.create('node', 'mpadded', NodeUtil_js_1.default.getChildren(mtd), def);
            mtd.setChildren([mpadded]);
        }
    };
    FlalignItem.prototype.EndTable = function () {
        _super.prototype.EndTable.call(this);
        if (this.center) {
            if (this.maxrow <= 2) {
                var def = this.arraydef;
                delete def.width;
                delete this.global.indentalign;
            }
        }
    };
    return FlalignItem;
}(BaseItems_js_1.EqnArrayItem));
exports.FlalignItem = FlalignItem;
//# sourceMappingURL=AmsItems.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/ams/AmsMappings.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/ams/AmsMappings.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AmsMethods_js_1 = __webpack_require__(/*! ./AmsMethods.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js");
var sm = __importStar(__webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js"));
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var lengths_js_1 = __webpack_require__(/*! ../../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
new sm.CharacterMap('AMSmath-mathchar0mo', ParseMethods_js_1.default.mathchar0mo, {
    iiiint: ['\u2A0C', { texClass: MmlNode_js_1.TEXCLASS.OP }]
});
new sm.RegExpMap('AMSmath-operatorLetter', AmsMethods_js_1.AmsMethods.operatorLetter, /[-*]/i);
new sm.CommandMap('AMSmath-macros', {
    mathring: ['Accent', '02DA'],
    nobreakspace: 'Tilde',
    negmedspace: ['Spacer', lengths_js_1.MATHSPACE.negativemediummathspace],
    negthickspace: ['Spacer', lengths_js_1.MATHSPACE.negativethickmathspace],
    idotsint: ['MultiIntegral', '\\int\\cdots\\int'],
    dddot: ['Accent', '20DB'],
    ddddot: ['Accent', '20DC'],
    sideset: 'SideSet',
    boxed: ['Macro', '\\fbox{$\\displaystyle{#1}$}', 1],
    tag: 'HandleTag',
    notag: 'HandleNoTag',
    eqref: ['HandleRef', true],
    substack: ['Macro', '\\begin{subarray}{c}#1\\end{subarray}', 1],
    injlim: ['NamedOp', 'inj&thinsp;lim'],
    projlim: ['NamedOp', 'proj&thinsp;lim'],
    varliminf: ['Macro', '\\mathop{\\underline{\\mmlToken{mi}{lim}}}'],
    varlimsup: ['Macro', '\\mathop{\\overline{\\mmlToken{mi}{lim}}}'],
    varinjlim: ['Macro', '\\mathop{\\underrightarrow{\\mmlToken{mi}{lim}}}'],
    varprojlim: ['Macro', '\\mathop{\\underleftarrow{\\mmlToken{mi}{lim}}}'],
    DeclareMathOperator: 'HandleDeclareOp',
    operatorname: 'HandleOperatorName',
    genfrac: 'Genfrac',
    frac: ['Genfrac', '', '', '', ''],
    tfrac: ['Genfrac', '', '', '', '1'],
    dfrac: ['Genfrac', '', '', '', '0'],
    binom: ['Genfrac', '(', ')', '0', ''],
    tbinom: ['Genfrac', '(', ')', '0', '1'],
    dbinom: ['Genfrac', '(', ')', '0', '0'],
    cfrac: 'CFrac',
    shoveleft: ['HandleShove', TexConstants_js_1.TexConstant.Align.LEFT],
    shoveright: ['HandleShove', TexConstants_js_1.TexConstant.Align.RIGHT],
    xrightarrow: ['xArrow', 0x2192, 5, 10],
    xleftarrow: ['xArrow', 0x2190, 10, 5]
}, AmsMethods_js_1.AmsMethods);
new sm.EnvironmentMap('AMSmath-environment', ParseMethods_js_1.default.environment, {
    'equation*': ['Equation', null, false],
    'eqnarray*': ['EqnArray', null, false, true, 'rcl',
        ParseUtil_js_1.default.cols(0, lengths_js_1.MATHSPACE.thickmathspace), '.5em'],
    align: ['EqnArray', null, true, true, 'rl', ParseUtil_js_1.default.cols(0, 2)],
    'align*': ['EqnArray', null, false, true, 'rl', ParseUtil_js_1.default.cols(0, 2)],
    multline: ['Multline', null, true],
    'multline*': ['Multline', null, false],
    split: ['EqnArray', null, false, false, 'rl', ParseUtil_js_1.default.cols(0)],
    gather: ['EqnArray', null, true, true, 'c'],
    'gather*': ['EqnArray', null, false, true, 'c'],
    alignat: ['AlignAt', null, true, true],
    'alignat*': ['AlignAt', null, false, true],
    alignedat: ['AlignAt', null, false, false],
    aligned: ['AmsEqnArray', null, null, null, 'rl', ParseUtil_js_1.default.cols(0, 2), '.5em', 'D'],
    gathered: ['AmsEqnArray', null, null, null, 'c', null, '.5em', 'D'],
    xalignat: ['XalignAt', null, true, true],
    'xalignat*': ['XalignAt', null, false, true],
    xxalignat: ['XalignAt', null, false, false],
    flalign: ['FlalignArray', null, true, false, true, 'rlc', 'auto auto fit'],
    'flalign*': ['FlalignArray', null, false, false, true, 'rlc', 'auto auto fit'],
    subarray: ['Array', null, null, null, null, ParseUtil_js_1.default.cols(0), '0.1em', 'S', 1],
    smallmatrix: ['Array', null, null, null, 'c', ParseUtil_js_1.default.cols(1 / 3),
        '.2em', 'S', 1],
    matrix: ['Array', null, null, null, 'c'],
    pmatrix: ['Array', null, '(', ')', 'c'],
    bmatrix: ['Array', null, '[', ']', 'c'],
    Bmatrix: ['Array', null, '\\{', '\\}', 'c'],
    vmatrix: ['Array', null, '\\vert', '\\vert', 'c'],
    Vmatrix: ['Array', null, '\\Vert', '\\Vert', 'c'],
    cases: ['Array', null, '\\{', '.', 'll', null, '.2em', 'T']
}, AmsMethods_js_1.AmsMethods);
new sm.DelimiterMap('AMSmath-delimiter', ParseMethods_js_1.default.delimiter, {
    '\\lvert': ['\u007C', { texClass: MmlNode_js_1.TEXCLASS.OPEN }],
    '\\rvert': ['\u007C', { texClass: MmlNode_js_1.TEXCLASS.CLOSE }],
    '\\lVert': ['\u2016', { texClass: MmlNode_js_1.TEXCLASS.OPEN }],
    '\\rVert': ['\u2016', { texClass: MmlNode_js_1.TEXCLASS.CLOSE }]
});
new sm.CharacterMap('AMSsymbols-mathchar0mi', ParseMethods_js_1.default.mathchar0mi, {
    digamma: '\u03DD',
    varkappa: '\u03F0',
    varGamma: ['\u0393', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varDelta: ['\u0394', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varTheta: ['\u0398', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varLambda: ['\u039B', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varXi: ['\u039E', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varPi: ['\u03A0', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varSigma: ['\u03A3', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varUpsilon: ['\u03A5', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varPhi: ['\u03A6', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varPsi: ['\u03A8', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    varOmega: ['\u03A9', { mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC }],
    beth: '\u2136',
    gimel: '\u2137',
    daleth: '\u2138',
    backprime: ['\u2035', { variantForm: true }],
    hslash: '\u210F',
    varnothing: ['\u2205', { variantForm: true }],
    blacktriangle: '\u25B4',
    triangledown: ['\u25BD', { variantForm: true }],
    blacktriangledown: '\u25BE',
    square: '\u25FB',
    Box: '\u25FB',
    blacksquare: '\u25FC',
    lozenge: '\u25CA',
    Diamond: '\u25CA',
    blacklozenge: '\u29EB',
    circledS: ['\u24C8', { mathvariant: TexConstants_js_1.TexConstant.Variant.NORMAL }],
    bigstar: '\u2605',
    sphericalangle: '\u2222',
    measuredangle: '\u2221',
    nexists: '\u2204',
    complement: '\u2201',
    mho: '\u2127',
    eth: ['\u00F0', { mathvariant: TexConstants_js_1.TexConstant.Variant.NORMAL }],
    Finv: '\u2132',
    diagup: '\u2571',
    Game: '\u2141',
    diagdown: '\u2572',
    Bbbk: ['\u006B',
        { mathvariant: TexConstants_js_1.TexConstant.Variant.DOUBLESTRUCK }],
    yen: '\u00A5',
    circledR: '\u00AE',
    checkmark: '\u2713',
    maltese: '\u2720'
});
new sm.CharacterMap('AMSsymbols-mathchar0mo', ParseMethods_js_1.default.mathchar0mo, {
    dotplus: '\u2214',
    ltimes: '\u22C9',
    smallsetminus: ['\u2216', { variantForm: true }],
    rtimes: '\u22CA',
    Cap: '\u22D2',
    doublecap: '\u22D2',
    leftthreetimes: '\u22CB',
    Cup: '\u22D3',
    doublecup: '\u22D3',
    rightthreetimes: '\u22CC',
    barwedge: '\u22BC',
    curlywedge: '\u22CF',
    veebar: '\u22BB',
    curlyvee: '\u22CE',
    doublebarwedge: '\u2A5E',
    boxminus: '\u229F',
    circleddash: '\u229D',
    boxtimes: '\u22A0',
    circledast: '\u229B',
    boxdot: '\u22A1',
    circledcirc: '\u229A',
    boxplus: '\u229E',
    centerdot: ['\u22C5', { variantForm: true }],
    divideontimes: '\u22C7',
    intercal: '\u22BA',
    leqq: '\u2266',
    geqq: '\u2267',
    leqslant: '\u2A7D',
    geqslant: '\u2A7E',
    eqslantless: '\u2A95',
    eqslantgtr: '\u2A96',
    lesssim: '\u2272',
    gtrsim: '\u2273',
    lessapprox: '\u2A85',
    gtrapprox: '\u2A86',
    approxeq: '\u224A',
    lessdot: '\u22D6',
    gtrdot: '\u22D7',
    lll: '\u22D8',
    llless: '\u22D8',
    ggg: '\u22D9',
    gggtr: '\u22D9',
    lessgtr: '\u2276',
    gtrless: '\u2277',
    lesseqgtr: '\u22DA',
    gtreqless: '\u22DB',
    lesseqqgtr: '\u2A8B',
    gtreqqless: '\u2A8C',
    doteqdot: '\u2251',
    Doteq: '\u2251',
    eqcirc: '\u2256',
    risingdotseq: '\u2253',
    circeq: '\u2257',
    fallingdotseq: '\u2252',
    triangleq: '\u225C',
    backsim: '\u223D',
    thicksim: ['\u223C', { variantForm: true }],
    backsimeq: '\u22CD',
    thickapprox: ['\u2248', { variantForm: true }],
    subseteqq: '\u2AC5',
    supseteqq: '\u2AC6',
    Subset: '\u22D0',
    Supset: '\u22D1',
    sqsubset: '\u228F',
    sqsupset: '\u2290',
    preccurlyeq: '\u227C',
    succcurlyeq: '\u227D',
    curlyeqprec: '\u22DE',
    curlyeqsucc: '\u22DF',
    precsim: '\u227E',
    succsim: '\u227F',
    precapprox: '\u2AB7',
    succapprox: '\u2AB8',
    vartriangleleft: '\u22B2',
    lhd: '\u22B2',
    vartriangleright: '\u22B3',
    rhd: '\u22B3',
    trianglelefteq: '\u22B4',
    unlhd: '\u22B4',
    trianglerighteq: '\u22B5',
    unrhd: '\u22B5',
    vDash: ['\u22A8', { variantForm: true }],
    Vdash: '\u22A9',
    Vvdash: '\u22AA',
    smallsmile: ['\u2323', { variantForm: true }],
    shortmid: ['\u2223', { variantForm: true }],
    smallfrown: ['\u2322', { variantForm: true }],
    shortparallel: ['\u2225', { variantForm: true }],
    bumpeq: '\u224F',
    between: '\u226C',
    Bumpeq: '\u224E',
    pitchfork: '\u22D4',
    varpropto: ['\u221D', { variantForm: true }],
    backepsilon: '\u220D',
    blacktriangleleft: '\u25C2',
    blacktriangleright: '\u25B8',
    therefore: '\u2234',
    because: '\u2235',
    eqsim: '\u2242',
    vartriangle: ['\u25B3', { variantForm: true }],
    Join: '\u22C8',
    nless: '\u226E',
    ngtr: '\u226F',
    nleq: '\u2270',
    ngeq: '\u2271',
    nleqslant: ['\u2A87', { variantForm: true }],
    ngeqslant: ['\u2A88', { variantForm: true }],
    nleqq: ['\u2270', { variantForm: true }],
    ngeqq: ['\u2271', { variantForm: true }],
    lneq: '\u2A87',
    gneq: '\u2A88',
    lneqq: '\u2268',
    gneqq: '\u2269',
    lvertneqq: ['\u2268', { variantForm: true }],
    gvertneqq: ['\u2269', { variantForm: true }],
    lnsim: '\u22E6',
    gnsim: '\u22E7',
    lnapprox: '\u2A89',
    gnapprox: '\u2A8A',
    nprec: '\u2280',
    nsucc: '\u2281',
    npreceq: ['\u22E0', { variantForm: true }],
    nsucceq: ['\u22E1', { variantForm: true }],
    precneqq: '\u2AB5',
    succneqq: '\u2AB6',
    precnsim: '\u22E8',
    succnsim: '\u22E9',
    precnapprox: '\u2AB9',
    succnapprox: '\u2ABA',
    nsim: '\u2241',
    ncong: '\u2247',
    nshortmid: ['\u2224', { variantForm: true }],
    nshortparallel: ['\u2226', { variantForm: true }],
    nmid: '\u2224',
    nparallel: '\u2226',
    nvdash: '\u22AC',
    nvDash: '\u22AD',
    nVdash: '\u22AE',
    nVDash: '\u22AF',
    ntriangleleft: '\u22EA',
    ntriangleright: '\u22EB',
    ntrianglelefteq: '\u22EC',
    ntrianglerighteq: '\u22ED',
    nsubseteq: '\u2288',
    nsupseteq: '\u2289',
    nsubseteqq: ['\u2288', { variantForm: true }],
    nsupseteqq: ['\u2289', { variantForm: true }],
    subsetneq: '\u228A',
    supsetneq: '\u228B',
    varsubsetneq: ['\u228A', { variantForm: true }],
    varsupsetneq: ['\u228B', { variantForm: true }],
    subsetneqq: '\u2ACB',
    supsetneqq: '\u2ACC',
    varsubsetneqq: ['\u2ACB', { variantForm: true }],
    varsupsetneqq: ['\u2ACC', { variantForm: true }],
    leftleftarrows: '\u21C7',
    rightrightarrows: '\u21C9',
    leftrightarrows: '\u21C6',
    rightleftarrows: '\u21C4',
    Lleftarrow: '\u21DA',
    Rrightarrow: '\u21DB',
    twoheadleftarrow: '\u219E',
    twoheadrightarrow: '\u21A0',
    leftarrowtail: '\u21A2',
    rightarrowtail: '\u21A3',
    looparrowleft: '\u21AB',
    looparrowright: '\u21AC',
    leftrightharpoons: '\u21CB',
    rightleftharpoons: ['\u21CC', { variantForm: true }],
    curvearrowleft: '\u21B6',
    curvearrowright: '\u21B7',
    circlearrowleft: '\u21BA',
    circlearrowright: '\u21BB',
    Lsh: '\u21B0',
    Rsh: '\u21B1',
    upuparrows: '\u21C8',
    downdownarrows: '\u21CA',
    upharpoonleft: '\u21BF',
    upharpoonright: '\u21BE',
    downharpoonleft: '\u21C3',
    restriction: '\u21BE',
    multimap: '\u22B8',
    downharpoonright: '\u21C2',
    leftrightsquigarrow: '\u21AD',
    rightsquigarrow: '\u21DD',
    leadsto: '\u21DD',
    dashrightarrow: '\u21E2',
    dashleftarrow: '\u21E0',
    nleftarrow: '\u219A',
    nrightarrow: '\u219B',
    nLeftarrow: '\u21CD',
    nRightarrow: '\u21CF',
    nleftrightarrow: '\u21AE',
    nLeftrightarrow: '\u21CE'
});
new sm.DelimiterMap('AMSsymbols-delimiter', ParseMethods_js_1.default.delimiter, {
    '\\ulcorner': '\u231C',
    '\\urcorner': '\u231D',
    '\\llcorner': '\u231E',
    '\\lrcorner': '\u231F'
});
new sm.CommandMap('AMSsymbols-macros', {
    implies: ['Macro', '\\;\\Longrightarrow\\;'],
    impliedby: ['Macro', '\\;\\Longleftarrow\\;']
}, AmsMethods_js_1.AmsMethods);
//# sourceMappingURL=AmsMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js":
/*!******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NEW_OPS = exports.AmsMethods = void 0;
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var Symbol_js_1 = __webpack_require__(/*! ../Symbol.js */ "./node_modules/mathjax-full/js/input/tex/Symbol.js");
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
exports.AmsMethods = {};
exports.AmsMethods.AmsEqnArray = function (parser, begin, numbered, taggable, align, spacing, style) {
    var args = parser.GetBrackets('\\begin{' + begin.getName() + '}');
    var array = BaseMethods_js_1.default.EqnArray(parser, begin, numbered, taggable, align, spacing, style);
    return ParseUtil_js_1.default.setArrayAlign(array, args);
};
exports.AmsMethods.AlignAt = function (parser, begin, numbered, taggable) {
    var name = begin.getName();
    var n, valign, align = '', spacing = [];
    if (!taggable) {
        valign = parser.GetBrackets('\\begin{' + name + '}');
    }
    n = parser.GetArgument('\\begin{' + name + '}');
    if (n.match(/[^0-9]/)) {
        throw new TexError_js_1.default('PositiveIntegerArg', 'Argument to %1 must me a positive integer', '\\begin{' + name + '}');
    }
    var count = parseInt(n, 10);
    while (count > 0) {
        align += 'rl';
        spacing.push('0em 0em');
        count--;
    }
    var spaceStr = spacing.join(' ');
    if (taggable) {
        return exports.AmsMethods.EqnArray(parser, begin, numbered, taggable, align, spaceStr);
    }
    var array = exports.AmsMethods.EqnArray(parser, begin, numbered, taggable, align, spaceStr);
    return ParseUtil_js_1.default.setArrayAlign(array, valign);
};
exports.AmsMethods.Multline = function (parser, begin, numbered) {
    parser.Push(begin);
    ParseUtil_js_1.default.checkEqnEnv(parser);
    var item = parser.itemFactory.create('multline', numbered, parser.stack);
    item.arraydef = {
        displaystyle: true,
        rowspacing: '.5em',
        columnspacing: '100%',
        width: parser.options.ams['multlineWidth'],
        side: parser.options['tagSide'],
        minlabelspacing: parser.options['tagIndent'],
        framespacing: parser.options.ams['multlineIndent'] + ' 0',
        frame: '',
        'data-width-includes-label': true
    };
    return item;
};
exports.AmsMethods.XalignAt = function (parser, begin, numbered, padded) {
    var n = parser.GetArgument('\\begin{' + begin.getName() + '}');
    if (n.match(/[^0-9]/)) {
        throw new TexError_js_1.default('PositiveIntegerArg', 'Argument to %1 must me a positive integer', '\\begin{' + begin.getName() + '}');
    }
    var align = (padded ? 'crl' : 'rlc');
    var width = (padded ? 'fit auto auto' : 'auto auto fit');
    var item = exports.AmsMethods.FlalignArray(parser, begin, numbered, padded, false, align, width, true);
    item.setProperty('xalignat', 2 * parseInt(n));
    return item;
};
exports.AmsMethods.FlalignArray = function (parser, begin, numbered, padded, center, align, width, zeroWidthLabel) {
    if (zeroWidthLabel === void 0) { zeroWidthLabel = false; }
    parser.Push(begin);
    ParseUtil_js_1.default.checkEqnEnv(parser);
    align = align
        .split('')
        .join(' ')
        .replace(/r/g, 'right')
        .replace(/l/g, 'left')
        .replace(/c/g, 'center');
    var item = parser.itemFactory.create('flalign', begin.getName(), numbered, padded, center, parser.stack);
    item.arraydef = {
        width: '100%',
        displaystyle: true,
        columnalign: align,
        columnspacing: '0em',
        columnwidth: width,
        rowspacing: '3pt',
        side: parser.options['tagSide'],
        minlabelspacing: (zeroWidthLabel ? '0' : parser.options['tagIndent']),
        'data-width-includes-label': true,
    };
    item.setProperty('zeroWidthLabel', zeroWidthLabel);
    return item;
};
exports.NEW_OPS = 'ams-declare-ops';
exports.AmsMethods.HandleDeclareOp = function (parser, name) {
    var star = (parser.GetStar() ? '*' : '');
    var cs = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
    if (cs.charAt(0) === '\\') {
        cs = cs.substr(1);
    }
    var op = parser.GetArgument(name);
    parser.configuration.handlers.retrieve(exports.NEW_OPS).
        add(cs, new Symbol_js_1.Macro(cs, exports.AmsMethods.Macro, ["\\operatorname".concat(star, "{").concat(op, "}")]));
};
exports.AmsMethods.HandleOperatorName = function (parser, name) {
    var star = parser.GetStar();
    var op = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
    var mml = new TexParser_js_1.default(op, __assign(__assign({}, parser.stack.env), { font: TexConstants_js_1.TexConstant.Variant.NORMAL, multiLetterIdentifiers: /^[-*a-z]+/i, operatorLetters: true }), parser.configuration).mml();
    if (!mml.isKind('mi')) {
        mml = parser.create('node', 'TeXAtom', [mml]);
    }
    NodeUtil_js_1.default.setProperties(mml, { movesupsub: star, movablelimits: true, texClass: MmlNode_js_1.TEXCLASS.OP });
    if (!star) {
        var c = parser.GetNext(), i = parser.i;
        if (c === '\\' && ++parser.i && parser.GetCS() !== 'limits') {
            parser.i = i;
        }
    }
    parser.Push(mml);
};
exports.AmsMethods.SideSet = function (parser, name) {
    var _a = __read(splitSideSet(parser.ParseArg(name)), 2), preScripts = _a[0], preRest = _a[1];
    var _b = __read(splitSideSet(parser.ParseArg(name)), 2), postScripts = _b[0], postRest = _b[1];
    var base = parser.ParseArg(name);
    var mml = base;
    if (preScripts) {
        if (preRest) {
            preScripts.replaceChild(parser.create('node', 'mphantom', [
                parser.create('node', 'mpadded', [ParseUtil_js_1.default.copyNode(base, parser)], { width: 0 })
            ]), NodeUtil_js_1.default.getChildAt(preScripts, 0));
        }
        else {
            mml = parser.create('node', 'mmultiscripts', [base]);
            if (postScripts) {
                NodeUtil_js_1.default.appendChildren(mml, [
                    NodeUtil_js_1.default.getChildAt(postScripts, 1) || parser.create('node', 'none'),
                    NodeUtil_js_1.default.getChildAt(postScripts, 2) || parser.create('node', 'none')
                ]);
            }
            NodeUtil_js_1.default.setProperty(mml, 'scriptalign', 'left');
            NodeUtil_js_1.default.appendChildren(mml, [
                parser.create('node', 'mprescripts'),
                NodeUtil_js_1.default.getChildAt(preScripts, 1) || parser.create('node', 'none'),
                NodeUtil_js_1.default.getChildAt(preScripts, 2) || parser.create('node', 'none')
            ]);
        }
    }
    if (postScripts && mml === base) {
        postScripts.replaceChild(base, NodeUtil_js_1.default.getChildAt(postScripts, 0));
        mml = postScripts;
    }
    var mrow = parser.create('node', 'TeXAtom', [], { texClass: MmlNode_js_1.TEXCLASS.OP, movesupsub: true, movablelimits: true });
    if (preRest) {
        preScripts && mrow.appendChild(preScripts);
        mrow.appendChild(preRest);
    }
    mrow.appendChild(mml);
    postRest && mrow.appendChild(postRest);
    parser.Push(mrow);
};
function splitSideSet(mml) {
    if (!mml || (mml.isInferred && mml.childNodes.length === 0))
        return [null, null];
    if (mml.isKind('msubsup') && checkSideSetBase(mml))
        return [mml, null];
    var child = NodeUtil_js_1.default.getChildAt(mml, 0);
    if (!(mml.isInferred && child && checkSideSetBase(child)))
        return [null, mml];
    mml.childNodes.splice(0, 1);
    return [child, mml];
}
function checkSideSetBase(mml) {
    var base = mml.childNodes[0];
    return base && base.isKind('mi') && base.getText() === '';
}
exports.AmsMethods.operatorLetter = function (parser, c) {
    return parser.stack.env.operatorLetters ? ParseMethods_js_1.default.variable(parser, c) : false;
};
exports.AmsMethods.MultiIntegral = function (parser, name, integral) {
    var next = parser.GetNext();
    if (next === '\\') {
        var i = parser.i;
        next = parser.GetArgument(name);
        parser.i = i;
        if (next === '\\limits') {
            if (name === '\\idotsint') {
                integral = '\\!\\!\\mathop{\\,\\,' + integral + '}';
            }
            else {
                integral = '\\!\\!\\!\\mathop{\\,\\,\\,' + integral + '}';
            }
        }
    }
    parser.string = integral + ' ' + parser.string.slice(parser.i);
    parser.i = 0;
};
exports.AmsMethods.xArrow = function (parser, name, chr, l, r) {
    var def = { width: '+' + ParseUtil_js_1.default.Em((l + r) / 18), lspace: ParseUtil_js_1.default.Em(l / 18) };
    var bot = parser.GetBrackets(name);
    var first = parser.ParseArg(name);
    var dstrut = parser.create('node', 'mspace', [], { depth: '.25em' });
    var arrow = parser.create('token', 'mo', { stretchy: true, texClass: MmlNode_js_1.TEXCLASS.REL }, String.fromCodePoint(chr));
    arrow = parser.create('node', 'mstyle', [arrow], { scriptlevel: 0 });
    var mml = parser.create('node', 'munderover', [arrow]);
    var mpadded = parser.create('node', 'mpadded', [first, dstrut], def);
    NodeUtil_js_1.default.setAttribute(mpadded, 'voffset', '-.2em');
    NodeUtil_js_1.default.setAttribute(mpadded, 'height', '-.2em');
    NodeUtil_js_1.default.setChild(mml, mml.over, mpadded);
    if (bot) {
        var bottom = new TexParser_js_1.default(bot, parser.stack.env, parser.configuration).mml();
        var bstrut = parser.create('node', 'mspace', [], { height: '.75em' });
        mpadded = parser.create('node', 'mpadded', [bottom, bstrut], def);
        NodeUtil_js_1.default.setAttribute(mpadded, 'voffset', '.15em');
        NodeUtil_js_1.default.setAttribute(mpadded, 'depth', '-.15em');
        NodeUtil_js_1.default.setChild(mml, mml.under, mpadded);
    }
    NodeUtil_js_1.default.setProperty(mml, 'subsupOK', true);
    parser.Push(mml);
};
exports.AmsMethods.HandleShove = function (parser, _name, shove) {
    var top = parser.stack.Top();
    if (top.kind !== 'multline') {
        throw new TexError_js_1.default('CommandOnlyAllowedInEnv', '%1 only allowed in %2 environment', parser.currentCS, 'multline');
    }
    if (top.Size()) {
        throw new TexError_js_1.default('CommandAtTheBeginingOfLine', '%1 must come at the beginning of the line', parser.currentCS);
    }
    top.setProperty('shove', shove);
};
exports.AmsMethods.CFrac = function (parser, name) {
    var lr = ParseUtil_js_1.default.trimSpaces(parser.GetBrackets(name, ''));
    var num = parser.GetArgument(name);
    var den = parser.GetArgument(name);
    var lrMap = {
        l: TexConstants_js_1.TexConstant.Align.LEFT, r: TexConstants_js_1.TexConstant.Align.RIGHT, '': ''
    };
    var numNode = new TexParser_js_1.default('\\strut\\textstyle{' + num + '}', parser.stack.env, parser.configuration).mml();
    var denNode = new TexParser_js_1.default('\\strut\\textstyle{' + den + '}', parser.stack.env, parser.configuration).mml();
    var frac = parser.create('node', 'mfrac', [numNode, denNode]);
    lr = lrMap[lr];
    if (lr == null) {
        throw new TexError_js_1.default('IllegalAlign', 'Illegal alignment specified in %1', parser.currentCS);
    }
    if (lr) {
        NodeUtil_js_1.default.setProperties(frac, { numalign: lr, denomalign: lr });
    }
    parser.Push(frac);
};
exports.AmsMethods.Genfrac = function (parser, name, left, right, thick, style) {
    if (left == null) {
        left = parser.GetDelimiterArg(name);
    }
    if (right == null) {
        right = parser.GetDelimiterArg(name);
    }
    if (thick == null) {
        thick = parser.GetArgument(name);
    }
    if (style == null) {
        style = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
    }
    var num = parser.ParseArg(name);
    var den = parser.ParseArg(name);
    var frac = parser.create('node', 'mfrac', [num, den]);
    if (thick !== '') {
        NodeUtil_js_1.default.setAttribute(frac, 'linethickness', thick);
    }
    if (left || right) {
        NodeUtil_js_1.default.setProperty(frac, 'withDelims', true);
        frac = ParseUtil_js_1.default.fixedFence(parser.configuration, left, frac, right);
    }
    if (style !== '') {
        var styleDigit = parseInt(style, 10);
        var styleAlpha = ['D', 'T', 'S', 'SS'][styleDigit];
        if (styleAlpha == null) {
            throw new TexError_js_1.default('BadMathStyleFor', 'Bad math style for %1', parser.currentCS);
        }
        frac = parser.create('node', 'mstyle', [frac]);
        if (styleAlpha === 'D') {
            NodeUtil_js_1.default.setProperties(frac, { displaystyle: true, scriptlevel: 0 });
        }
        else {
            NodeUtil_js_1.default.setProperties(frac, { displaystyle: false,
                scriptlevel: styleDigit - 1 });
        }
    }
    parser.Push(frac);
};
exports.AmsMethods.HandleTag = function (parser, name) {
    if (!parser.tags.currentTag.taggable && parser.tags.env) {
        throw new TexError_js_1.default('CommandNotAllowedInEnv', '%1 not allowed in %2 environment', parser.currentCS, parser.tags.env);
    }
    if (parser.tags.currentTag.tag) {
        throw new TexError_js_1.default('MultipleCommand', 'Multiple %1', parser.currentCS);
    }
    var star = parser.GetStar();
    var tagId = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
    parser.tags.tag(tagId, star);
};
exports.AmsMethods.HandleNoTag = BaseMethods_js_1.default.HandleNoTag;
exports.AmsMethods.HandleRef = BaseMethods_js_1.default.HandleRef;
exports.AmsMethods.Macro = BaseMethods_js_1.default.Macro;
exports.AmsMethods.Accent = BaseMethods_js_1.default.Accent;
exports.AmsMethods.Tilde = BaseMethods_js_1.default.Tilde;
exports.AmsMethods.Array = BaseMethods_js_1.default.Array;
exports.AmsMethods.Spacer = BaseMethods_js_1.default.Spacer;
exports.AmsMethods.NamedOp = BaseMethods_js_1.default.NamedOp;
exports.AmsMethods.EqnArray = BaseMethods_js_1.default.EqnArray;
exports.AmsMethods.Equation = BaseMethods_js_1.default.Equation;
//# sourceMappingURL=AmsMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/amscd/AmsCdConfiguration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/amscd/AmsCdConfiguration.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmsCdConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
__webpack_require__(/*! ./AmsCdMappings.js */ "./node_modules/mathjax-full/js/input/tex/amscd/AmsCdMappings.js");
exports.AmsCdConfiguration = Configuration_js_1.Configuration.create('amscd', {
    handler: {
        character: ['amscd_special'],
        macro: ['amscd_macros'],
        environment: ['amscd_environment']
    },
    options: {
        amscd: {
            colspace: '5pt',
            rowspace: '5pt',
            harrowsize: '2.75em',
            varrowsize: '1.75em',
            hideHorizontalLabels: false
        }
    }
});
//# sourceMappingURL=AmsCdConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/amscd/AmsCdMappings.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/amscd/AmsCdMappings.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var sm = __importStar(__webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js"));
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var AmsCdMethods_js_1 = __importDefault(__webpack_require__(/*! ./AmsCdMethods.js */ "./node_modules/mathjax-full/js/input/tex/amscd/AmsCdMethods.js"));
new sm.EnvironmentMap('amscd_environment', ParseMethods_js_1.default.environment, { CD: 'CD' }, AmsCdMethods_js_1.default);
new sm.CommandMap('amscd_macros', {
    minCDarrowwidth: 'minCDarrowwidth',
    minCDarrowheight: 'minCDarrowheight',
}, AmsCdMethods_js_1.default);
new sm.MacroMap('amscd_special', { '@': 'arrow' }, AmsCdMethods_js_1.default);
//# sourceMappingURL=AmsCdMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/amscd/AmsCdMethods.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/amscd/AmsCdMethods.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var BaseConfiguration_js_1 = __webpack_require__(/*! ../base/BaseConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseConfiguration.js");
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var AmsCdMethods = {};
AmsCdMethods.CD = function (parser, begin) {
    parser.Push(begin);
    var item = parser.itemFactory.create('array');
    var options = parser.configuration.options.amscd;
    item.setProperties({
        minw: parser.stack.env.CD_minw || options.harrowsize,
        minh: parser.stack.env.CD_minh || options.varrowsize
    });
    item.arraydef = {
        columnalign: 'center',
        columnspacing: options.colspace,
        rowspacing: options.rowspace,
        displaystyle: true
    };
    return item;
};
AmsCdMethods.arrow = function (parser, name) {
    var c = parser.string.charAt(parser.i);
    if (!c.match(/[><VA.|=]/)) {
        return (0, BaseConfiguration_js_1.Other)(parser, name);
    }
    else {
        parser.i++;
    }
    var first = parser.stack.Top();
    if (!first.isKind('array') || first.Size()) {
        AmsCdMethods.cell(parser, name);
        first = parser.stack.Top();
    }
    var top = first;
    var arrowRow = ((top.table.length % 2) === 1);
    var n = (top.row.length + (arrowRow ? 0 : 1)) % 2;
    while (n) {
        AmsCdMethods.cell(parser, name);
        n--;
    }
    var mml;
    var hdef = { minsize: top.getProperty('minw'), stretchy: true }, vdef = { minsize: top.getProperty('minh'),
        stretchy: true, symmetric: true, lspace: 0, rspace: 0 };
    if (c === '.') {
    }
    else if (c === '|') {
        mml = parser.create('token', 'mo', vdef, '\u2225');
    }
    else if (c === '=') {
        mml = parser.create('token', 'mo', hdef, '=');
    }
    else {
        var arrow = {
            '>': '\u2192', '<': '\u2190', 'V': '\u2193', 'A': '\u2191'
        }[c];
        var a = parser.GetUpTo(name + c, c);
        var b = parser.GetUpTo(name + c, c);
        if (c === '>' || c === '<') {
            mml = parser.create('token', 'mo', hdef, arrow);
            if (!a) {
                a = '\\kern ' + top.getProperty('minw');
            }
            if (a || b) {
                var pad = { width: '+.67em', lspace: '.33em' };
                mml = parser.create('node', 'munderover', [mml]);
                if (a) {
                    var nodeA = new TexParser_js_1.default(a, parser.stack.env, parser.configuration).mml();
                    var mpadded = parser.create('node', 'mpadded', [nodeA], pad);
                    NodeUtil_js_1.default.setAttribute(mpadded, 'voffset', '.1em');
                    NodeUtil_js_1.default.setChild(mml, mml.over, mpadded);
                }
                if (b) {
                    var nodeB = new TexParser_js_1.default(b, parser.stack.env, parser.configuration).mml();
                    NodeUtil_js_1.default.setChild(mml, mml.under, parser.create('node', 'mpadded', [nodeB], pad));
                }
                if (parser.configuration.options.amscd.hideHorizontalLabels) {
                    mml = parser.create('node', 'mpadded', mml, { depth: 0, height: '.67em' });
                }
            }
        }
        else {
            var arrowNode = parser.create('token', 'mo', vdef, arrow);
            mml = arrowNode;
            if (a || b) {
                mml = parser.create('node', 'mrow');
                if (a) {
                    NodeUtil_js_1.default.appendChildren(mml, [new TexParser_js_1.default('\\scriptstyle\\llap{' + a + '}', parser.stack.env, parser.configuration).mml()]);
                }
                arrowNode.texClass = MmlNode_js_1.TEXCLASS.ORD;
                NodeUtil_js_1.default.appendChildren(mml, [arrowNode]);
                if (b) {
                    NodeUtil_js_1.default.appendChildren(mml, [new TexParser_js_1.default('\\scriptstyle\\rlap{' + b + '}', parser.stack.env, parser.configuration).mml()]);
                }
            }
        }
    }
    if (mml) {
        parser.Push(mml);
    }
    AmsCdMethods.cell(parser, name);
};
AmsCdMethods.cell = function (parser, name) {
    var top = parser.stack.Top();
    if ((top.table || []).length % 2 === 0 && (top.row || []).length === 0) {
        parser.Push(parser.create('node', 'mpadded', [], { height: '8.5pt', depth: '2pt' }));
    }
    parser.Push(parser.itemFactory.create('cell').setProperties({ isEntry: true, name: name }));
};
AmsCdMethods.minCDarrowwidth = function (parser, name) {
    parser.stack.env.CD_minw = parser.GetDimen(name);
};
AmsCdMethods.minCDarrowheight = function (parser, name) {
    parser.stack.env.CD_minh = parser.GetDimen(name);
};
exports["default"] = AmsCdMethods;
//# sourceMappingURL=AmsCdMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/bbox/BboxConfiguration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/bbox/BboxConfiguration.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BboxConfiguration = exports.BboxMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
exports.BboxMethods = {};
exports.BboxMethods.BBox = function (parser, name) {
    var bbox = parser.GetBrackets(name, '');
    var math = parser.ParseArg(name);
    var parts = bbox.split(/,/);
    var def, background, style;
    for (var i = 0, m = parts.length; i < m; i++) {
        var part = parts[i].trim();
        var match = part.match(/^(\.\d+|\d+(\.\d*)?)(pt|em|ex|mu|px|in|cm|mm)$/);
        if (match) {
            if (def) {
                throw new TexError_js_1.default('MultipleBBoxProperty', '%1 specified twice in %2', 'Padding', name);
            }
            var pad = BBoxPadding(match[1] + match[3]);
            if (pad) {
                def = {
                    height: '+' + pad,
                    depth: '+' + pad,
                    lspace: pad,
                    width: '+' + (2 * parseInt(match[1], 10)) + match[3]
                };
            }
        }
        else if (part.match(/^([a-z0-9]+|\#[0-9a-f]{6}|\#[0-9a-f]{3})$/i)) {
            if (background) {
                throw new TexError_js_1.default('MultipleBBoxProperty', '%1 specified twice in %2', 'Background', name);
            }
            background = part;
        }
        else if (part.match(/^[-a-z]+:/i)) {
            if (style) {
                throw new TexError_js_1.default('MultipleBBoxProperty', '%1 specified twice in %2', 'Style', name);
            }
            style = BBoxStyle(part);
        }
        else if (part !== '') {
            throw new TexError_js_1.default('InvalidBBoxProperty', '"%1" doesn\'t look like a color, a padding dimension, or a style', part);
        }
    }
    if (def) {
        math = parser.create('node', 'mpadded', [math], def);
    }
    if (background || style) {
        def = {};
        if (background) {
            Object.assign(def, { mathbackground: background });
        }
        if (style) {
            Object.assign(def, { style: style });
        }
        math = parser.create('node', 'mstyle', [math], def);
    }
    parser.Push(math);
};
var BBoxStyle = function (styles) {
    return styles;
};
var BBoxPadding = function (pad) {
    return pad;
};
new SymbolMap_js_1.CommandMap('bbox', { bbox: 'BBox' }, exports.BboxMethods);
exports.BboxConfiguration = Configuration_js_1.Configuration.create('bbox', { handler: { macro: ['bbox'] } });
//# sourceMappingURL=BboxConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/boldsymbol/BoldsymbolConfiguration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/boldsymbol/BoldsymbolConfiguration.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BoldsymbolConfiguration = exports.rewriteBoldTokens = exports.createBoldToken = exports.BoldsymbolMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var NodeFactory_js_1 = __webpack_require__(/*! ../NodeFactory.js */ "./node_modules/mathjax-full/js/input/tex/NodeFactory.js");
var BOLDVARIANT = {};
BOLDVARIANT[TexConstants_js_1.TexConstant.Variant.NORMAL] = TexConstants_js_1.TexConstant.Variant.BOLD;
BOLDVARIANT[TexConstants_js_1.TexConstant.Variant.ITALIC] = TexConstants_js_1.TexConstant.Variant.BOLDITALIC;
BOLDVARIANT[TexConstants_js_1.TexConstant.Variant.FRAKTUR] = TexConstants_js_1.TexConstant.Variant.BOLDFRAKTUR;
BOLDVARIANT[TexConstants_js_1.TexConstant.Variant.SCRIPT] = TexConstants_js_1.TexConstant.Variant.BOLDSCRIPT;
BOLDVARIANT[TexConstants_js_1.TexConstant.Variant.SANSSERIF] = TexConstants_js_1.TexConstant.Variant.BOLDSANSSERIF;
BOLDVARIANT['-tex-calligraphic'] = '-tex-bold-calligraphic';
BOLDVARIANT['-tex-oldstyle'] = '-tex-bold-oldstyle';
BOLDVARIANT['-tex-mathit'] = TexConstants_js_1.TexConstant.Variant.BOLDITALIC;
exports.BoldsymbolMethods = {};
exports.BoldsymbolMethods.Boldsymbol = function (parser, name) {
    var boldsymbol = parser.stack.env['boldsymbol'];
    parser.stack.env['boldsymbol'] = true;
    var mml = parser.ParseArg(name);
    parser.stack.env['boldsymbol'] = boldsymbol;
    parser.Push(mml);
};
new SymbolMap_js_1.CommandMap('boldsymbol', { boldsymbol: 'Boldsymbol' }, exports.BoldsymbolMethods);
function createBoldToken(factory, kind, def, text) {
    var token = NodeFactory_js_1.NodeFactory.createToken(factory, kind, def, text);
    if (kind !== 'mtext' &&
        factory.configuration.parser.stack.env['boldsymbol']) {
        NodeUtil_js_1.default.setProperty(token, 'fixBold', true);
        factory.configuration.addNode('fixBold', token);
    }
    return token;
}
exports.createBoldToken = createBoldToken;
function rewriteBoldTokens(arg) {
    var e_1, _a;
    try {
        for (var _b = __values(arg.data.getList('fixBold')), _c = _b.next(); !_c.done; _c = _b.next()) {
            var node = _c.value;
            if (NodeUtil_js_1.default.getProperty(node, 'fixBold')) {
                var variant = NodeUtil_js_1.default.getAttribute(node, 'mathvariant');
                if (variant == null) {
                    NodeUtil_js_1.default.setAttribute(node, 'mathvariant', TexConstants_js_1.TexConstant.Variant.BOLD);
                }
                else {
                    NodeUtil_js_1.default.setAttribute(node, 'mathvariant', BOLDVARIANT[variant] || variant);
                }
                NodeUtil_js_1.default.removeProperties(node, 'fixBold');
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.rewriteBoldTokens = rewriteBoldTokens;
exports.BoldsymbolConfiguration = Configuration_js_1.Configuration.create('boldsymbol', {
    handler: { macro: ['boldsymbol'] },
    nodes: { 'token': createBoldToken },
    postprocessors: [rewriteBoldTokens]
});
//# sourceMappingURL=BoldsymbolConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/braket/BraketConfiguration.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/braket/BraketConfiguration.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BraketConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var BraketItems_js_1 = __webpack_require__(/*! ./BraketItems.js */ "./node_modules/mathjax-full/js/input/tex/braket/BraketItems.js");
__webpack_require__(/*! ./BraketMappings.js */ "./node_modules/mathjax-full/js/input/tex/braket/BraketMappings.js");
exports.BraketConfiguration = Configuration_js_1.Configuration.create('braket', {
    handler: {
        character: ['Braket-characters'],
        macro: ['Braket-macros']
    },
    items: (_a = {},
        _a[BraketItems_js_1.BraketItem.prototype.kind] = BraketItems_js_1.BraketItem,
        _a)
});
//# sourceMappingURL=BraketConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/braket/BraketItems.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/braket/BraketItems.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BraketItem = void 0;
var StackItem_js_1 = __webpack_require__(/*! ../StackItem.js */ "./node_modules/mathjax-full/js/input/tex/StackItem.js");
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var BraketItem = (function (_super) {
    __extends(BraketItem, _super);
    function BraketItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BraketItem.prototype, "kind", {
        get: function () {
            return 'braket';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BraketItem.prototype, "isOpen", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    BraketItem.prototype.checkItem = function (item) {
        if (item.isKind('close')) {
            return [[this.factory.create('mml', this.toMml())], true];
        }
        if (item.isKind('mml')) {
            this.Push(item.toMml());
            if (this.getProperty('single')) {
                return [[this.toMml()], true];
            }
            return StackItem_js_1.BaseItem.fail;
        }
        return _super.prototype.checkItem.call(this, item);
    };
    BraketItem.prototype.toMml = function () {
        var inner = _super.prototype.toMml.call(this);
        var open = this.getProperty('open');
        var close = this.getProperty('close');
        if (this.getProperty('stretchy')) {
            return ParseUtil_js_1.default.fenced(this.factory.configuration, open, inner, close);
        }
        var attrs = { fence: true, stretchy: false, symmetric: true, texClass: MmlNode_js_1.TEXCLASS.OPEN };
        var openNode = this.create('token', 'mo', attrs, open);
        attrs.texClass = MmlNode_js_1.TEXCLASS.CLOSE;
        var closeNode = this.create('token', 'mo', attrs, close);
        var mrow = this.create('node', 'mrow', [openNode, inner, closeNode], { open: open, close: close, texClass: MmlNode_js_1.TEXCLASS.INNER });
        return mrow;
    };
    return BraketItem;
}(StackItem_js_1.BaseItem));
exports.BraketItem = BraketItem;
//# sourceMappingURL=BraketItems.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/braket/BraketMappings.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/braket/BraketMappings.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var BraketMethods_js_1 = __importDefault(__webpack_require__(/*! ./BraketMethods.js */ "./node_modules/mathjax-full/js/input/tex/braket/BraketMethods.js"));
new SymbolMap_js_1.CommandMap('Braket-macros', {
    bra: ['Macro', '{\\langle {#1} \\vert}', 1],
    ket: ['Macro', '{\\vert {#1} \\rangle}', 1],
    braket: ['Braket', '\u27E8', '\u27E9', false, Infinity],
    'set': ['Braket', '{', '}', false, 1],
    Bra: ['Macro', '{\\left\\langle {#1} \\right\\vert}', 1],
    Ket: ['Macro', '{\\left\\vert {#1} \\right\\rangle}', 1],
    Braket: ['Braket', '\u27E8', '\u27E9', true, Infinity],
    Set: ['Braket', '{', '}', true, 1],
    ketbra: ['Macro', '{\\vert {#1} \\rangle\\langle {#2} \\vert}', 2],
    Ketbra: ['Macro', '{\\left\\vert {#1} \\right\\rangle\\left\\langle {#2} \\right\\vert}', 2],
    '|': 'Bar'
}, BraketMethods_js_1.default);
new SymbolMap_js_1.MacroMap('Braket-characters', {
    '|': 'Bar'
}, BraketMethods_js_1.default);
//# sourceMappingURL=BraketMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/braket/BraketMethods.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/braket/BraketMethods.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var BraketMethods = {};
BraketMethods.Macro = BaseMethods_js_1.default.Macro;
BraketMethods.Braket = function (parser, _name, open, close, stretchy, barmax) {
    var next = parser.GetNext();
    if (next === '') {
        throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);
    }
    var single = true;
    if (next === '{') {
        parser.i++;
        single = false;
    }
    parser.Push(parser.itemFactory.create('braket')
        .setProperties({ barmax: barmax, barcount: 0, open: open,
        close: close, stretchy: stretchy, single: single }));
};
BraketMethods.Bar = function (parser, name) {
    var c = name === '|' ? '|' : '\u2225';
    var top = parser.stack.Top();
    if (top.kind !== 'braket' ||
        top.getProperty('barcount') >= top.getProperty('barmax')) {
        var mml = parser.create('token', 'mo', { texClass: MmlNode_js_1.TEXCLASS.ORD, stretchy: false }, c);
        parser.Push(mml);
        return;
    }
    if (c === '|' && parser.GetNext() === '|') {
        parser.i++;
        c = '\u2225';
    }
    var stretchy = top.getProperty('stretchy');
    if (!stretchy) {
        var node_1 = parser.create('token', 'mo', { stretchy: false, braketbar: true }, c);
        parser.Push(node_1);
        return;
    }
    var node = parser.create('node', 'TeXAtom', [], { texClass: MmlNode_js_1.TEXCLASS.CLOSE });
    parser.Push(node);
    top.setProperty('barcount', top.getProperty('barcount') + 1);
    node = parser.create('token', 'mo', { stretchy: true, braketbar: true }, c);
    parser.Push(node);
    node = parser.create('node', 'TeXAtom', [], { texClass: MmlNode_js_1.TEXCLASS.OPEN });
    parser.Push(node);
};
exports["default"] = BraketMethods;
//# sourceMappingURL=BraketMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsConfiguration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsConfiguration.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BussproofsConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var BussproofsItems_js_1 = __webpack_require__(/*! ./BussproofsItems.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsItems.js");
var BussproofsUtil_js_1 = __webpack_require__(/*! ./BussproofsUtil.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsUtil.js");
__webpack_require__(/*! ./BussproofsMappings.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsMappings.js");
exports.BussproofsConfiguration = Configuration_js_1.Configuration.create('bussproofs', {
    handler: {
        macro: ['Bussproofs-macros'],
        environment: ['Bussproofs-environments']
    },
    items: (_a = {},
        _a[BussproofsItems_js_1.ProofTreeItem.prototype.kind] = BussproofsItems_js_1.ProofTreeItem,
        _a),
    preprocessors: [
        [BussproofsUtil_js_1.saveDocument, 1]
    ],
    postprocessors: [
        [BussproofsUtil_js_1.clearDocument, 3],
        [BussproofsUtil_js_1.makeBsprAttributes, 2],
        [BussproofsUtil_js_1.balanceRules, 1]
    ]
});
//# sourceMappingURL=BussproofsConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsItems.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsItems.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProofTreeItem = void 0;
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var StackItem_js_1 = __webpack_require__(/*! ../StackItem.js */ "./node_modules/mathjax-full/js/input/tex/StackItem.js");
var Stack_js_1 = __importDefault(__webpack_require__(/*! ../Stack.js */ "./node_modules/mathjax-full/js/input/tex/Stack.js"));
var BussproofsUtil = __importStar(__webpack_require__(/*! ./BussproofsUtil.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsUtil.js"));
var ProofTreeItem = (function (_super) {
    __extends(ProofTreeItem, _super);
    function ProofTreeItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.leftLabel = null;
        _this.rigthLabel = null;
        _this.innerStack = new Stack_js_1.default(_this.factory, {}, true);
        return _this;
    }
    Object.defineProperty(ProofTreeItem.prototype, "kind", {
        get: function () {
            return 'proofTree';
        },
        enumerable: false,
        configurable: true
    });
    ProofTreeItem.prototype.checkItem = function (item) {
        if (item.isKind('end') && item.getName() === 'prooftree') {
            var node = this.toMml();
            BussproofsUtil.setProperty(node, 'proof', true);
            return [[this.factory.create('mml', node), item], true];
        }
        if (item.isKind('stop')) {
            throw new TexError_js_1.default('EnvMissingEnd', 'Missing \\end{%1}', this.getName());
        }
        this.innerStack.Push(item);
        return StackItem_js_1.BaseItem.fail;
    };
    ProofTreeItem.prototype.toMml = function () {
        var tree = _super.prototype.toMml.call(this);
        var start = this.innerStack.Top();
        if (start.isKind('start') && !start.Size()) {
            return tree;
        }
        this.innerStack.Push(this.factory.create('stop'));
        var prefix = this.innerStack.Top().toMml();
        return this.create('node', 'mrow', [prefix, tree], {});
    };
    return ProofTreeItem;
}(StackItem_js_1.BaseItem));
exports.ProofTreeItem = ProofTreeItem;
//# sourceMappingURL=BussproofsItems.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsMappings.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsMappings.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BussproofsMethods_js_1 = __importDefault(__webpack_require__(/*! ./BussproofsMethods.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsMethods.js"));
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
new SymbolMap_js_1.CommandMap('Bussproofs-macros', {
    AxiomC: 'Axiom',
    UnaryInfC: ['Inference', 1],
    BinaryInfC: ['Inference', 2],
    TrinaryInfC: ['Inference', 3],
    QuaternaryInfC: ['Inference', 4],
    QuinaryInfC: ['Inference', 5],
    RightLabel: ['Label', 'right'],
    LeftLabel: ['Label', 'left'],
    AXC: 'Axiom',
    UIC: ['Inference', 1],
    BIC: ['Inference', 2],
    TIC: ['Inference', 3],
    RL: ['Label', 'right'],
    LL: ['Label', 'left'],
    noLine: ['SetLine', 'none', false],
    singleLine: ['SetLine', 'solid', false],
    solidLine: ['SetLine', 'solid', false],
    dashedLine: ['SetLine', 'dashed', false],
    alwaysNoLine: ['SetLine', 'none', true],
    alwaysSingleLine: ['SetLine', 'solid', true],
    alwaysSolidLine: ['SetLine', 'solid', true],
    alwaysDashedLine: ['SetLine', 'dashed', true],
    rootAtTop: ['RootAtTop', true],
    alwaysRootAtTop: ['RootAtTop', true],
    rootAtBottom: ['RootAtTop', false],
    alwaysRootAtBottom: ['RootAtTop', false],
    fCenter: 'FCenter',
    Axiom: 'AxiomF',
    UnaryInf: ['InferenceF', 1],
    BinaryInf: ['InferenceF', 2],
    TrinaryInf: ['InferenceF', 3],
    QuaternaryInf: ['InferenceF', 4],
    QuinaryInf: ['InferenceF', 5]
}, BussproofsMethods_js_1.default);
new SymbolMap_js_1.EnvironmentMap('Bussproofs-environments', ParseMethods_js_1.default.environment, {
    prooftree: ['Prooftree', null, false]
}, BussproofsMethods_js_1.default);
//# sourceMappingURL=BussproofsMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsMethods.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsMethods.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var BussproofsUtil = __importStar(__webpack_require__(/*! ./BussproofsUtil.js */ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsUtil.js"));
var BussproofsMethods = {};
BussproofsMethods.Prooftree = function (parser, begin) {
    parser.Push(begin);
    var newItem = parser.itemFactory.create('proofTree').
        setProperties({ name: begin.getName(),
        line: 'solid', currentLine: 'solid', rootAtTop: false });
    return newItem;
};
BussproofsMethods.Axiom = function (parser, name) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    var content = paddedContent(parser, parser.GetArgument(name));
    BussproofsUtil.setProperty(content, 'axiom', true);
    top.Push(content);
};
var paddedContent = function (parser, content) {
    var nodes = ParseUtil_js_1.default.internalMath(parser, ParseUtil_js_1.default.trimSpaces(content), 0);
    if (!nodes[0].childNodes[0].childNodes.length) {
        return parser.create('node', 'mrow', []);
    }
    var lpad = parser.create('node', 'mspace', [], { width: '.5ex' });
    var rpad = parser.create('node', 'mspace', [], { width: '.5ex' });
    return parser.create('node', 'mrow', __spreadArray(__spreadArray([lpad], __read(nodes), false), [rpad], false));
};
BussproofsMethods.Inference = function (parser, name, n) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    if (top.Size() < n) {
        throw new TexError_js_1.default('BadProofTree', 'Proof tree badly specified.');
    }
    var rootAtTop = top.getProperty('rootAtTop');
    var childCount = (n === 1 && !top.Peek()[0].childNodes.length) ? 0 : n;
    var children = [];
    do {
        if (children.length) {
            children.unshift(parser.create('node', 'mtd', [], {}));
        }
        children.unshift(parser.create('node', 'mtd', [top.Pop()], { 'rowalign': (rootAtTop ? 'top' : 'bottom') }));
        n--;
    } while (n > 0);
    var row = parser.create('node', 'mtr', children, {});
    var table = parser.create('node', 'mtable', [row], { framespacing: '0 0' });
    var conclusion = paddedContent(parser, parser.GetArgument(name));
    var style = top.getProperty('currentLine');
    if (style !== top.getProperty('line')) {
        top.setProperty('currentLine', top.getProperty('line'));
    }
    var rule = createRule(parser, table, [conclusion], top.getProperty('left'), top.getProperty('right'), style, rootAtTop);
    top.setProperty('left', null);
    top.setProperty('right', null);
    BussproofsUtil.setProperty(rule, 'inference', childCount);
    parser.configuration.addNode('inference', rule);
    top.Push(rule);
};
function createRule(parser, premise, conclusions, left, right, style, rootAtTop) {
    var upper = parser.create('node', 'mtr', [parser.create('node', 'mtd', [premise], {})], {});
    var lower = parser.create('node', 'mtr', [parser.create('node', 'mtd', conclusions, {})], {});
    var rule = parser.create('node', 'mtable', rootAtTop ? [lower, upper] : [upper, lower], { align: 'top 2', rowlines: style, framespacing: '0 0' });
    BussproofsUtil.setProperty(rule, 'inferenceRule', rootAtTop ? 'up' : 'down');
    var leftLabel, rightLabel;
    if (left) {
        leftLabel = parser.create('node', 'mpadded', [left], { height: '+.5em', width: '+.5em', voffset: '-.15em' });
        BussproofsUtil.setProperty(leftLabel, 'prooflabel', 'left');
    }
    if (right) {
        rightLabel = parser.create('node', 'mpadded', [right], { height: '+.5em', width: '+.5em', voffset: '-.15em' });
        BussproofsUtil.setProperty(rightLabel, 'prooflabel', 'right');
    }
    var children, label;
    if (left && right) {
        children = [leftLabel, rule, rightLabel];
        label = 'both';
    }
    else if (left) {
        children = [leftLabel, rule];
        label = 'left';
    }
    else if (right) {
        children = [rule, rightLabel];
        label = 'right';
    }
    else {
        return rule;
    }
    rule = parser.create('node', 'mrow', children);
    BussproofsUtil.setProperty(rule, 'labelledRule', label);
    return rule;
}
BussproofsMethods.Label = function (parser, name, side) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    var content = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), 0);
    var label = (content.length > 1) ?
        parser.create('node', 'mrow', content, {}) : content[0];
    top.setProperty(side, label);
};
BussproofsMethods.SetLine = function (parser, _name, style, always) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    top.setProperty('currentLine', style);
    if (always) {
        top.setProperty('line', style);
    }
};
BussproofsMethods.RootAtTop = function (parser, _name, where) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    top.setProperty('rootAtTop', where);
};
BussproofsMethods.AxiomF = function (parser, name) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    var line = parseFCenterLine(parser, name);
    BussproofsUtil.setProperty(line, 'axiom', true);
    top.Push(line);
};
function parseFCenterLine(parser, name) {
    var dollar = parser.GetNext();
    if (dollar !== '$') {
        throw new TexError_js_1.default('IllegalUseOfCommand', 'Use of %1 does not match it\'s definition.', name);
    }
    parser.i++;
    var axiom = parser.GetUpTo(name, '$');
    if (axiom.indexOf('\\fCenter') === -1) {
        throw new TexError_js_1.default('IllegalUseOfCommand', 'Missing \\fCenter in %1.', name);
    }
    var _a = __read(axiom.split('\\fCenter'), 2), prem = _a[0], conc = _a[1];
    var premise = (new TexParser_js_1.default(prem, parser.stack.env, parser.configuration)).mml();
    var conclusion = (new TexParser_js_1.default(conc, parser.stack.env, parser.configuration)).mml();
    var fcenter = (new TexParser_js_1.default('\\fCenter', parser.stack.env, parser.configuration)).mml();
    var left = parser.create('node', 'mtd', [premise], {});
    var middle = parser.create('node', 'mtd', [fcenter], {});
    var right = parser.create('node', 'mtd', [conclusion], {});
    var row = parser.create('node', 'mtr', [left, middle, right], {});
    var table = parser.create('node', 'mtable', [row], { columnspacing: '.5ex', columnalign: 'center 2' });
    BussproofsUtil.setProperty(table, 'sequent', true);
    parser.configuration.addNode('sequent', row);
    return table;
}
BussproofsMethods.FCenter = function (_parser, _name) { };
BussproofsMethods.InferenceF = function (parser, name, n) {
    var top = parser.stack.Top();
    if (top.kind !== 'proofTree') {
        throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');
    }
    if (top.Size() < n) {
        throw new TexError_js_1.default('BadProofTree', 'Proof tree badly specified.');
    }
    var rootAtTop = top.getProperty('rootAtTop');
    var childCount = (n === 1 && !top.Peek()[0].childNodes.length) ? 0 : n;
    var children = [];
    do {
        if (children.length) {
            children.unshift(parser.create('node', 'mtd', [], {}));
        }
        children.unshift(parser.create('node', 'mtd', [top.Pop()], { 'rowalign': (rootAtTop ? 'top' : 'bottom') }));
        n--;
    } while (n > 0);
    var row = parser.create('node', 'mtr', children, {});
    var table = parser.create('node', 'mtable', [row], { framespacing: '0 0' });
    var conclusion = parseFCenterLine(parser, name);
    var style = top.getProperty('currentLine');
    if (style !== top.getProperty('line')) {
        top.setProperty('currentLine', top.getProperty('line'));
    }
    var rule = createRule(parser, table, [conclusion], top.getProperty('left'), top.getProperty('right'), style, rootAtTop);
    top.setProperty('left', null);
    top.setProperty('right', null);
    BussproofsUtil.setProperty(rule, 'inference', childCount);
    parser.configuration.addNode('inference', rule);
    top.Push(rule);
};
exports["default"] = BussproofsMethods;
//# sourceMappingURL=BussproofsMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsUtil.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/bussproofs/BussproofsUtil.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearDocument = exports.saveDocument = exports.makeBsprAttributes = exports.removeProperty = exports.getProperty = exports.setProperty = exports.balanceRules = void 0;
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var doc = null;
var item = null;
var getBBox = function (node) {
    item.root = node;
    var width = doc.outputJax.getBBox(item, doc).w;
    return width;
};
var getRule = function (node) {
    var i = 0;
    while (node && !NodeUtil_js_1.default.isType(node, 'mtable')) {
        if (NodeUtil_js_1.default.isType(node, 'text')) {
            return null;
        }
        if (NodeUtil_js_1.default.isType(node, 'mrow')) {
            node = node.childNodes[0];
            i = 0;
            continue;
        }
        node = node.parent.childNodes[i];
        i++;
    }
    return node;
};
var getPremises = function (rule, direction) {
    return rule.childNodes[direction === 'up' ? 1 : 0].childNodes[0].
        childNodes[0].childNodes[0].childNodes[0];
};
var getPremise = function (premises, n) {
    return premises.childNodes[n].childNodes[0].childNodes[0];
};
var firstPremise = function (premises) {
    return getPremise(premises, 0);
};
var lastPremise = function (premises) {
    return getPremise(premises, premises.childNodes.length - 1);
};
var getConclusion = function (rule, direction) {
    return rule.childNodes[direction === 'up' ? 0 : 1].childNodes[0].childNodes[0].childNodes[0];
};
var getColumn = function (inf) {
    while (inf && !NodeUtil_js_1.default.isType(inf, 'mtd')) {
        inf = inf.parent;
    }
    return inf;
};
var nextSibling = function (inf) {
    return inf.parent.childNodes[inf.parent.childNodes.indexOf(inf) + 1];
};
var previousSibling = function (inf) {
    return inf.parent.childNodes[inf.parent.childNodes.indexOf(inf) - 1];
};
var getParentInf = function (inf) {
    while (inf && (0, exports.getProperty)(inf, 'inference') == null) {
        inf = inf.parent;
    }
    return inf;
};
var getSpaces = function (inf, rule, right) {
    if (right === void 0) { right = false; }
    var result = 0;
    if (inf === rule) {
        return result;
    }
    if (inf !== rule.parent) {
        var children_1 = inf.childNodes;
        var index_1 = right ? children_1.length - 1 : 0;
        if (NodeUtil_js_1.default.isType(children_1[index_1], 'mspace')) {
            result += getBBox(children_1[index_1]);
        }
        inf = rule.parent;
    }
    if (inf === rule) {
        return result;
    }
    var children = inf.childNodes;
    var index = right ? children.length - 1 : 0;
    if (children[index] !== rule) {
        result += getBBox(children[index]);
    }
    return result;
};
var adjustValue = function (inf, right) {
    if (right === void 0) { right = false; }
    var rule = getRule(inf);
    var conc = getConclusion(rule, (0, exports.getProperty)(rule, 'inferenceRule'));
    var w = getSpaces(inf, rule, right);
    var x = getBBox(rule);
    var y = getBBox(conc);
    return w + ((x - y) / 2);
};
var addSpace = function (config, inf, space, right) {
    if (right === void 0) { right = false; }
    if ((0, exports.getProperty)(inf, 'inferenceRule') ||
        (0, exports.getProperty)(inf, 'labelledRule')) {
        var mrow = config.nodeFactory.create('node', 'mrow');
        inf.parent.replaceChild(mrow, inf);
        mrow.setChildren([inf]);
        moveProperties(inf, mrow);
        inf = mrow;
    }
    var index = right ? inf.childNodes.length - 1 : 0;
    var mspace = inf.childNodes[index];
    if (NodeUtil_js_1.default.isType(mspace, 'mspace')) {
        NodeUtil_js_1.default.setAttribute(mspace, 'width', ParseUtil_js_1.default.Em(ParseUtil_js_1.default.dimen2em(NodeUtil_js_1.default.getAttribute(mspace, 'width')) + space));
        return;
    }
    mspace = config.nodeFactory.create('node', 'mspace', [], { width: ParseUtil_js_1.default.Em(space) });
    if (right) {
        inf.appendChild(mspace);
        return;
    }
    mspace.parent = inf;
    inf.childNodes.unshift(mspace);
};
var moveProperties = function (src, dest) {
    var props = ['inference', 'proof', 'maxAdjust', 'labelledRule'];
    props.forEach(function (x) {
        var value = (0, exports.getProperty)(src, x);
        if (value != null) {
            (0, exports.setProperty)(dest, x, value);
            (0, exports.removeProperty)(src, x);
        }
    });
};
var adjustSequents = function (config) {
    var sequents = config.nodeLists['sequent'];
    if (!sequents) {
        return;
    }
    for (var i = sequents.length - 1, seq = void 0; seq = sequents[i]; i--) {
        if ((0, exports.getProperty)(seq, 'sequentProcessed')) {
            (0, exports.removeProperty)(seq, 'sequentProcessed');
            continue;
        }
        var collect = [];
        var inf = getParentInf(seq);
        if ((0, exports.getProperty)(inf, 'inference') !== 1) {
            continue;
        }
        collect.push(seq);
        while ((0, exports.getProperty)(inf, 'inference') === 1) {
            inf = getRule(inf);
            var premise = firstPremise(getPremises(inf, (0, exports.getProperty)(inf, 'inferenceRule')));
            var sequent = ((0, exports.getProperty)(premise, 'inferenceRule')) ?
                getConclusion(premise, (0, exports.getProperty)(premise, 'inferenceRule')) :
                premise;
            if ((0, exports.getProperty)(sequent, 'sequent')) {
                seq = sequent.childNodes[0];
                collect.push(seq);
                (0, exports.setProperty)(seq, 'sequentProcessed', true);
            }
            inf = premise;
        }
        adjustSequentPairwise(config, collect);
    }
};
var addSequentSpace = function (config, sequent, position, direction, width) {
    var mspace = config.nodeFactory.create('node', 'mspace', [], { width: ParseUtil_js_1.default.Em(width) });
    if (direction === 'left') {
        var row = sequent.childNodes[position].childNodes[0];
        mspace.parent = row;
        row.childNodes.unshift(mspace);
    }
    else {
        sequent.childNodes[position].appendChild(mspace);
    }
    (0, exports.setProperty)(sequent.parent, 'sequentAdjust_' + direction, width);
};
var adjustSequentPairwise = function (config, sequents) {
    var top = sequents.pop();
    while (sequents.length) {
        var bottom = sequents.pop();
        var _a = __read(compareSequents(top, bottom), 2), left = _a[0], right = _a[1];
        if ((0, exports.getProperty)(top.parent, 'axiom')) {
            addSequentSpace(config, left < 0 ? top : bottom, 0, 'left', Math.abs(left));
            addSequentSpace(config, right < 0 ? top : bottom, 2, 'right', Math.abs(right));
        }
        top = bottom;
    }
};
var compareSequents = function (top, bottom) {
    var tr = getBBox(top.childNodes[2]);
    var br = getBBox(bottom.childNodes[2]);
    var tl = getBBox(top.childNodes[0]);
    var bl = getBBox(bottom.childNodes[0]);
    var dl = tl - bl;
    var dr = tr - br;
    return [dl, dr];
};
var balanceRules = function (arg) {
    var e_1, _a;
    item = new arg.document.options.MathItem('', null, arg.math.display);
    var config = arg.data;
    adjustSequents(config);
    var inferences = config.nodeLists['inference'] || [];
    try {
        for (var inferences_1 = __values(inferences), inferences_1_1 = inferences_1.next(); !inferences_1_1.done; inferences_1_1 = inferences_1.next()) {
            var inf = inferences_1_1.value;
            var isProof = (0, exports.getProperty)(inf, 'proof');
            var rule = getRule(inf);
            var premises = getPremises(rule, (0, exports.getProperty)(rule, 'inferenceRule'));
            var premiseF = firstPremise(premises);
            if ((0, exports.getProperty)(premiseF, 'inference')) {
                var adjust_1 = adjustValue(premiseF);
                if (adjust_1) {
                    addSpace(config, premiseF, -adjust_1);
                    var w_1 = getSpaces(inf, rule, false);
                    addSpace(config, inf, adjust_1 - w_1);
                }
            }
            var premiseL = lastPremise(premises);
            if ((0, exports.getProperty)(premiseL, 'inference') == null) {
                continue;
            }
            var adjust = adjustValue(premiseL, true);
            addSpace(config, premiseL, -adjust, true);
            var w = getSpaces(inf, rule, true);
            var maxAdjust = (0, exports.getProperty)(inf, 'maxAdjust');
            if (maxAdjust != null) {
                adjust = Math.max(adjust, maxAdjust);
            }
            var column = void 0;
            if (isProof || !(column = getColumn(inf))) {
                addSpace(config, (0, exports.getProperty)(inf, 'proof') ? inf : inf.parent, adjust - w, true);
                continue;
            }
            var sibling = nextSibling(column);
            if (sibling) {
                var pos = config.nodeFactory.create('node', 'mspace', [], { width: adjust - w + 'em' });
                sibling.appendChild(pos);
                inf.removeProperty('maxAdjust');
                continue;
            }
            var parentRule = getParentInf(column);
            if (!parentRule) {
                continue;
            }
            adjust = (0, exports.getProperty)(parentRule, 'maxAdjust') ?
                Math.max((0, exports.getProperty)(parentRule, 'maxAdjust'), adjust) : adjust;
            (0, exports.setProperty)(parentRule, 'maxAdjust', adjust);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (inferences_1_1 && !inferences_1_1.done && (_a = inferences_1.return)) _a.call(inferences_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
exports.balanceRules = balanceRules;
var property_prefix = 'bspr_';
var blacklistedProperties = (_a = {},
    _a[property_prefix + 'maxAdjust'] = true,
    _a);
var setProperty = function (node, property, value) {
    NodeUtil_js_1.default.setProperty(node, property_prefix + property, value);
};
exports.setProperty = setProperty;
var getProperty = function (node, property) {
    return NodeUtil_js_1.default.getProperty(node, property_prefix + property);
};
exports.getProperty = getProperty;
var removeProperty = function (node, property) {
    node.removeProperty(property_prefix + property);
};
exports.removeProperty = removeProperty;
var makeBsprAttributes = function (arg) {
    arg.data.root.walkTree(function (mml, _data) {
        var attr = [];
        mml.getPropertyNames().forEach(function (x) {
            if (!blacklistedProperties[x] && x.match(RegExp('^' + property_prefix))) {
                attr.push(x + ':' + mml.getProperty(x));
            }
        });
        if (attr.length) {
            NodeUtil_js_1.default.setAttribute(mml, 'semantics', attr.join(';'));
        }
    });
};
exports.makeBsprAttributes = makeBsprAttributes;
var saveDocument = function (arg) {
    doc = arg.document;
    if (!('getBBox' in doc.outputJax)) {
        throw Error('The bussproofs extension requires an output jax with a getBBox() method');
    }
};
exports.saveDocument = saveDocument;
var clearDocument = function (_arg) {
    doc = null;
};
exports.clearDocument = clearDocument;
//# sourceMappingURL=BussproofsUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/cancel/CancelConfiguration.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/cancel/CancelConfiguration.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancelConfiguration = exports.CancelMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var EncloseConfiguration_js_1 = __webpack_require__(/*! ../enclose/EncloseConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/enclose/EncloseConfiguration.js");
exports.CancelMethods = {};
exports.CancelMethods.Cancel = function (parser, name, notation) {
    var attr = parser.GetBrackets(name, '');
    var math = parser.ParseArg(name);
    var def = ParseUtil_js_1.default.keyvalOptions(attr, EncloseConfiguration_js_1.ENCLOSE_OPTIONS);
    def['notation'] = notation;
    parser.Push(parser.create('node', 'menclose', [math], def));
};
exports.CancelMethods.CancelTo = function (parser, name) {
    var attr = parser.GetBrackets(name, '');
    var value = parser.ParseArg(name);
    var math = parser.ParseArg(name);
    var def = ParseUtil_js_1.default.keyvalOptions(attr, EncloseConfiguration_js_1.ENCLOSE_OPTIONS);
    def['notation'] = [TexConstants_js_1.TexConstant.Notation.UPDIAGONALSTRIKE,
        TexConstants_js_1.TexConstant.Notation.UPDIAGONALARROW,
        TexConstants_js_1.TexConstant.Notation.NORTHEASTARROW].join(' ');
    value = parser.create('node', 'mpadded', [value], { depth: '-.1em', height: '+.1em', voffset: '.1em' });
    parser.Push(parser.create('node', 'msup', [parser.create('node', 'menclose', [math], def), value]));
};
new SymbolMap_js_1.CommandMap('cancel', {
    cancel: ['Cancel', TexConstants_js_1.TexConstant.Notation.UPDIAGONALSTRIKE],
    bcancel: ['Cancel', TexConstants_js_1.TexConstant.Notation.DOWNDIAGONALSTRIKE],
    xcancel: ['Cancel', TexConstants_js_1.TexConstant.Notation.UPDIAGONALSTRIKE + ' ' +
            TexConstants_js_1.TexConstant.Notation.DOWNDIAGONALSTRIKE],
    cancelto: 'CancelTo'
}, exports.CancelMethods);
exports.CancelConfiguration = Configuration_js_1.Configuration.create('cancel', { handler: { macro: ['cancel'] } });
//# sourceMappingURL=CancelConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/cases/CasesConfiguration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/cases/CasesConfiguration.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CasesConfiguration = exports.CasesMethods = exports.CasesTags = exports.CasesBeginItem = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var AmsConfiguration_js_1 = __webpack_require__(/*! ../ams/AmsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsConfiguration.js");
var EmpheqUtil_js_1 = __webpack_require__(/*! ../empheq/EmpheqUtil.js */ "./node_modules/mathjax-full/js/input/tex/empheq/EmpheqUtil.js");
var CasesBeginItem = (function (_super) {
    __extends(CasesBeginItem, _super);
    function CasesBeginItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CasesBeginItem.prototype, "kind", {
        get: function () {
            return 'cases-begin';
        },
        enumerable: false,
        configurable: true
    });
    CasesBeginItem.prototype.checkItem = function (item) {
        if (item.isKind('end') && item.getName() === this.getName()) {
            if (this.getProperty('end')) {
                this.setProperty('end', false);
                return [[], true];
            }
        }
        return _super.prototype.checkItem.call(this, item);
    };
    return CasesBeginItem;
}(BaseItems_js_1.BeginItem));
exports.CasesBeginItem = CasesBeginItem;
var CasesTags = (function (_super) {
    __extends(CasesTags, _super);
    function CasesTags() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.subcounter = 0;
        return _this;
    }
    CasesTags.prototype.start = function (env, taggable, defaultTags) {
        this.subcounter = 0;
        _super.prototype.start.call(this, env, taggable, defaultTags);
    };
    CasesTags.prototype.autoTag = function () {
        if (this.currentTag.tag != null)
            return;
        if (this.currentTag.env === 'subnumcases') {
            if (this.subcounter === 0)
                this.counter++;
            this.subcounter++;
            this.tag(this.formatNumber(this.counter, this.subcounter), false);
        }
        else {
            if (this.subcounter === 0 || this.currentTag.env !== 'numcases-left')
                this.counter++;
            this.tag(this.formatNumber(this.counter), false);
        }
    };
    CasesTags.prototype.formatNumber = function (n, m) {
        if (m === void 0) { m = null; }
        return n.toString() + (m === null ? '' : String.fromCharCode(0x60 + m));
    };
    return CasesTags;
}(AmsConfiguration_js_1.AmsTags));
exports.CasesTags = CasesTags;
exports.CasesMethods = {
    NumCases: function (parser, begin) {
        if (parser.stack.env.closing === begin.getName()) {
            delete parser.stack.env.closing;
            parser.Push(parser.itemFactory.create('end').setProperty('name', begin.getName()));
            var cases = parser.stack.Top();
            var table = cases.Last;
            var original = ParseUtil_js_1.default.copyNode(table, parser);
            var left = cases.getProperty('left');
            EmpheqUtil_js_1.EmpheqUtil.left(table, original, left + '\\empheqlbrace\\,', parser, 'numcases-left');
            parser.Push(parser.itemFactory.create('end').setProperty('name', begin.getName()));
            return null;
        }
        else {
            var left = parser.GetArgument('\\begin{' + begin.getName() + '}');
            begin.setProperty('left', left);
            var array = BaseMethods_js_1.default.EqnArray(parser, begin, true, true, 'll');
            array.arraydef.displaystyle = false;
            array.arraydef.rowspacing = '.2em';
            array.setProperty('numCases', true);
            parser.Push(begin);
            return array;
        }
    },
    Entry: function (parser, name) {
        if (!parser.stack.Top().getProperty('numCases')) {
            return BaseMethods_js_1.default.Entry(parser, name);
        }
        parser.Push(parser.itemFactory.create('cell').setProperties({ isEntry: true, name: name }));
        var tex = parser.string;
        var braces = 0, i = parser.i, m = tex.length;
        while (i < m) {
            var c = tex.charAt(i);
            if (c === '{') {
                braces++;
                i++;
            }
            else if (c === '}') {
                if (braces === 0) {
                    break;
                }
                else {
                    braces--;
                    i++;
                }
            }
            else if (c === '&' && braces === 0) {
                throw new TexError_js_1.default('ExtraCasesAlignTab', 'Extra alignment tab in text for numcase environment');
            }
            else if (c === '\\' && braces === 0) {
                var cs = (tex.slice(i + 1).match(/^[a-z]+|./i) || [])[0];
                if (cs === '\\' || cs === 'cr' || cs === 'end' || cs === 'label') {
                    break;
                }
                else {
                    i += cs.length;
                }
            }
            else {
                i++;
            }
        }
        var text = tex.substr(parser.i, i - parser.i).replace(/^\s*/, '');
        parser.PushAll(ParseUtil_js_1.default.internalMath(parser, text, 0));
        parser.i = i;
    }
};
new SymbolMap_js_1.EnvironmentMap('cases-env', EmpheqUtil_js_1.EmpheqUtil.environment, {
    numcases: ['NumCases', 'cases'],
    subnumcases: ['NumCases', 'cases']
}, exports.CasesMethods);
new SymbolMap_js_1.MacroMap('cases-macros', {
    '&': 'Entry'
}, exports.CasesMethods);
exports.CasesConfiguration = Configuration_js_1.Configuration.create('cases', {
    handler: {
        environment: ['cases-env'],
        character: ['cases-macros']
    },
    items: (_a = {},
        _a[CasesBeginItem.prototype.kind] = CasesBeginItem,
        _a),
    tags: { 'cases': CasesTags }
});
//# sourceMappingURL=CasesConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/centernot/CenternotConfiguration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/centernot/CenternotConfiguration.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CenternotConfiguration = exports.filterCenterOver = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
new SymbolMap_js_1.CommandMap('centernot', {
    centerOver: 'CenterOver',
    centernot: ['Macro', '\\centerOver{#1}{{\u29F8}}', 1]
}, {
    CenterOver: function (parser, name) {
        var arg = '{' + parser.GetArgument(name) + '}';
        var over = parser.ParseArg(name);
        var base = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();
        var mml = parser.create('node', 'TeXAtom', [
            new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml(),
            parser.create('node', 'mpadded', [
                parser.create('node', 'mpadded', [over], { width: 0, lspace: '-.5width' }),
                parser.create('node', 'mphantom', [base])
            ], { width: 0, lspace: '-.5width' })
        ]);
        parser.configuration.addNode('centerOver', base);
        parser.Push(mml);
    },
    Macro: BaseMethods_js_1.default.Macro
});
function filterCenterOver(_a) {
    var e_1, _b;
    var data = _a.data;
    try {
        for (var _c = __values(data.getList('centerOver')), _d = _c.next(); !_d.done; _d = _c.next()) {
            var base = _d.value;
            var texClass = NodeUtil_js_1.default.getTexClass(base.childNodes[0].childNodes[0]);
            if (texClass !== null) {
                NodeUtil_js_1.default.setProperties(base.parent.parent.parent.parent.parent.parent, { texClass: texClass });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.filterCenterOver = filterCenterOver;
exports.CenternotConfiguration = Configuration_js_1.Configuration.create('centernot', {
    handler: { macro: ['centernot'] },
    postprocessors: [filterCenterOver]
});
//# sourceMappingURL=CenternotConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/color/ColorConfiguration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/color/ColorConfiguration.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorConfiguration = void 0;
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var ColorMethods_js_1 = __webpack_require__(/*! ./ColorMethods.js */ "./node_modules/mathjax-full/js/input/tex/color/ColorMethods.js");
var ColorUtil_js_1 = __webpack_require__(/*! ./ColorUtil.js */ "./node_modules/mathjax-full/js/input/tex/color/ColorUtil.js");
new SymbolMap_js_1.CommandMap('color', {
    color: 'Color',
    textcolor: 'TextColor',
    definecolor: 'DefineColor',
    colorbox: 'ColorBox',
    fcolorbox: 'FColorBox'
}, ColorMethods_js_1.ColorMethods);
var config = function (_config, jax) {
    jax.parseOptions.packageData.set('color', { model: new ColorUtil_js_1.ColorModel() });
};
exports.ColorConfiguration = Configuration_js_1.Configuration.create('color', {
    handler: {
        macro: ['color'],
    },
    options: {
        color: {
            padding: '5px',
            borderWidth: '2px'
        }
    },
    config: config
});
//# sourceMappingURL=ColorConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/color/ColorConstants.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/color/ColorConstants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.COLORS = void 0;
exports.COLORS = new Map([
    ['Apricot', '#FBB982'],
    ['Aquamarine', '#00B5BE'],
    ['Bittersweet', '#C04F17'],
    ['Black', '#221E1F'],
    ['Blue', '#2D2F92'],
    ['BlueGreen', '#00B3B8'],
    ['BlueViolet', '#473992'],
    ['BrickRed', '#B6321C'],
    ['Brown', '#792500'],
    ['BurntOrange', '#F7921D'],
    ['CadetBlue', '#74729A'],
    ['CarnationPink', '#F282B4'],
    ['Cerulean', '#00A2E3'],
    ['CornflowerBlue', '#41B0E4'],
    ['Cyan', '#00AEEF'],
    ['Dandelion', '#FDBC42'],
    ['DarkOrchid', '#A4538A'],
    ['Emerald', '#00A99D'],
    ['ForestGreen', '#009B55'],
    ['Fuchsia', '#8C368C'],
    ['Goldenrod', '#FFDF42'],
    ['Gray', '#949698'],
    ['Green', '#00A64F'],
    ['GreenYellow', '#DFE674'],
    ['JungleGreen', '#00A99A'],
    ['Lavender', '#F49EC4'],
    ['LimeGreen', '#8DC73E'],
    ['Magenta', '#EC008C'],
    ['Mahogany', '#A9341F'],
    ['Maroon', '#AF3235'],
    ['Melon', '#F89E7B'],
    ['MidnightBlue', '#006795'],
    ['Mulberry', '#A93C93'],
    ['NavyBlue', '#006EB8'],
    ['OliveGreen', '#3C8031'],
    ['Orange', '#F58137'],
    ['OrangeRed', '#ED135A'],
    ['Orchid', '#AF72B0'],
    ['Peach', '#F7965A'],
    ['Periwinkle', '#7977B8'],
    ['PineGreen', '#008B72'],
    ['Plum', '#92268F'],
    ['ProcessBlue', '#00B0F0'],
    ['Purple', '#99479B'],
    ['RawSienna', '#974006'],
    ['Red', '#ED1B23'],
    ['RedOrange', '#F26035'],
    ['RedViolet', '#A1246B'],
    ['Rhodamine', '#EF559F'],
    ['RoyalBlue', '#0071BC'],
    ['RoyalPurple', '#613F99'],
    ['RubineRed', '#ED017D'],
    ['Salmon', '#F69289'],
    ['SeaGreen', '#3FBC9D'],
    ['Sepia', '#671800'],
    ['SkyBlue', '#46C5DD'],
    ['SpringGreen', '#C6DC67'],
    ['Tan', '#DA9D76'],
    ['TealBlue', '#00AEB3'],
    ['Thistle', '#D883B7'],
    ['Turquoise', '#00B4CE'],
    ['Violet', '#58429B'],
    ['VioletRed', '#EF58A0'],
    ['White', '#FFFFFF'],
    ['WildStrawberry', '#EE2967'],
    ['Yellow', '#FFF200'],
    ['YellowGreen', '#98CC70'],
    ['YellowOrange', '#FAA21A'],
]);
//# sourceMappingURL=ColorConstants.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/color/ColorMethods.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/color/ColorMethods.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorMethods = void 0;
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
function padding(colorPadding) {
    var pad = "+".concat(colorPadding);
    var unit = colorPadding.replace(/^.*?([a-z]*)$/, '$1');
    var pad2 = 2 * parseFloat(pad);
    return {
        width: "+".concat(pad2).concat(unit),
        height: pad,
        depth: pad,
        lspace: colorPadding,
    };
}
exports.ColorMethods = {};
exports.ColorMethods.Color = function (parser, name) {
    var model = parser.GetBrackets(name, '');
    var colorDef = parser.GetArgument(name);
    var colorModel = parser.configuration.packageData.get('color').model;
    var color = colorModel.getColor(model, colorDef);
    var style = parser.itemFactory.create('style')
        .setProperties({ styles: { mathcolor: color } });
    parser.stack.env['color'] = color;
    parser.Push(style);
};
exports.ColorMethods.TextColor = function (parser, name) {
    var model = parser.GetBrackets(name, '');
    var colorDef = parser.GetArgument(name);
    var colorModel = parser.configuration.packageData.get('color').model;
    var color = colorModel.getColor(model, colorDef);
    var old = parser.stack.env['color'];
    parser.stack.env['color'] = color;
    var math = parser.ParseArg(name);
    if (old) {
        parser.stack.env['color'] = old;
    }
    else {
        delete parser.stack.env['color'];
    }
    var node = parser.create('node', 'mstyle', [math], { mathcolor: color });
    parser.Push(node);
};
exports.ColorMethods.DefineColor = function (parser, name) {
    var cname = parser.GetArgument(name);
    var model = parser.GetArgument(name);
    var def = parser.GetArgument(name);
    var colorModel = parser.configuration.packageData.get('color').model;
    colorModel.defineColor(model, cname, def);
};
exports.ColorMethods.ColorBox = function (parser, name) {
    var cname = parser.GetArgument(name);
    var math = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));
    var colorModel = parser.configuration.packageData.get('color').model;
    var node = parser.create('node', 'mpadded', math, {
        mathbackground: colorModel.getColor('named', cname)
    });
    NodeUtil_js_1.default.setProperties(node, padding(parser.options.color.padding));
    parser.Push(node);
};
exports.ColorMethods.FColorBox = function (parser, name) {
    var fname = parser.GetArgument(name);
    var cname = parser.GetArgument(name);
    var math = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));
    var options = parser.options.color;
    var colorModel = parser.configuration.packageData.get('color').model;
    var node = parser.create('node', 'mpadded', math, {
        mathbackground: colorModel.getColor('named', cname),
        style: "border: ".concat(options.borderWidth, " solid ").concat(colorModel.getColor('named', fname))
    });
    NodeUtil_js_1.default.setProperties(node, padding(options.padding));
    parser.Push(node);
};
//# sourceMappingURL=ColorMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/color/ColorUtil.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/color/ColorUtil.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorModel = void 0;
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var ColorConstants_js_1 = __webpack_require__(/*! ./ColorConstants.js */ "./node_modules/mathjax-full/js/input/tex/color/ColorConstants.js");
var ColorModelProcessors = new Map();
var ColorModel = (function () {
    function ColorModel() {
        this.userColors = new Map();
    }
    ColorModel.prototype.normalizeColor = function (model, def) {
        if (!model || model === 'named') {
            return def;
        }
        if (ColorModelProcessors.has(model)) {
            var modelProcessor = ColorModelProcessors.get(model);
            return modelProcessor(def);
        }
        throw new TexError_js_1.default('UndefinedColorModel', 'Color model \'%1\' not defined', model);
    };
    ColorModel.prototype.getColor = function (model, def) {
        if (!model || model === 'named') {
            return this.getColorByName(def);
        }
        return this.normalizeColor(model, def);
    };
    ColorModel.prototype.getColorByName = function (name) {
        if (this.userColors.has(name)) {
            return this.userColors.get(name);
        }
        if (ColorConstants_js_1.COLORS.has(name)) {
            return ColorConstants_js_1.COLORS.get(name);
        }
        return name;
    };
    ColorModel.prototype.defineColor = function (model, name, def) {
        var normalized = this.normalizeColor(model, def);
        this.userColors.set(name, normalized);
    };
    return ColorModel;
}());
exports.ColorModel = ColorModel;
ColorModelProcessors.set('rgb', function (rgb) {
    var e_1, _a;
    var rgbParts = rgb.trim().split(/\s*,\s*/);
    var RGB = '#';
    if (rgbParts.length !== 3) {
        throw new TexError_js_1.default('ModelArg1', 'Color values for the %1 model require 3 numbers', 'rgb');
    }
    try {
        for (var rgbParts_1 = __values(rgbParts), rgbParts_1_1 = rgbParts_1.next(); !rgbParts_1_1.done; rgbParts_1_1 = rgbParts_1.next()) {
            var rgbPart = rgbParts_1_1.value;
            if (!rgbPart.match(/^(\d+(\.\d*)?|\.\d+)$/)) {
                throw new TexError_js_1.default('InvalidDecimalNumber', 'Invalid decimal number');
            }
            var n = parseFloat(rgbPart);
            if (n < 0 || n > 1) {
                throw new TexError_js_1.default('ModelArg2', 'Color values for the %1 model must be between %2 and %3', 'rgb', '0', '1');
            }
            var pn = Math.floor(n * 255).toString(16);
            if (pn.length < 2) {
                pn = '0' + pn;
            }
            RGB += pn;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (rgbParts_1_1 && !rgbParts_1_1.done && (_a = rgbParts_1.return)) _a.call(rgbParts_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return RGB;
});
ColorModelProcessors.set('RGB', function (rgb) {
    var e_2, _a;
    var rgbParts = rgb.trim().split(/\s*,\s*/);
    var RGB = '#';
    if (rgbParts.length !== 3) {
        throw new TexError_js_1.default('ModelArg1', 'Color values for the %1 model require 3 numbers', 'RGB');
    }
    try {
        for (var rgbParts_2 = __values(rgbParts), rgbParts_2_1 = rgbParts_2.next(); !rgbParts_2_1.done; rgbParts_2_1 = rgbParts_2.next()) {
            var rgbPart = rgbParts_2_1.value;
            if (!rgbPart.match(/^\d+$/)) {
                throw new TexError_js_1.default('InvalidNumber', 'Invalid number');
            }
            var n = parseInt(rgbPart);
            if (n > 255) {
                throw new TexError_js_1.default('ModelArg2', 'Color values for the %1 model must be between %2 and %3', 'RGB', '0', '255');
            }
            var pn = n.toString(16);
            if (pn.length < 2) {
                pn = '0' + pn;
            }
            RGB += pn;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (rgbParts_2_1 && !rgbParts_2_1.done && (_a = rgbParts_2.return)) _a.call(rgbParts_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return RGB;
});
ColorModelProcessors.set('gray', function (gray) {
    if (!gray.match(/^\s*(\d+(\.\d*)?|\.\d+)\s*$/)) {
        throw new TexError_js_1.default('InvalidDecimalNumber', 'Invalid decimal number');
    }
    var n = parseFloat(gray);
    if (n < 0 || n > 1) {
        throw new TexError_js_1.default('ModelArg2', 'Color values for the %1 model must be between %2 and %3', 'gray', '0', '1');
    }
    var pn = Math.floor(n * 255).toString(16);
    if (pn.length < 2) {
        pn = '0' + pn;
    }
    return "#".concat(pn).concat(pn).concat(pn);
});
//# sourceMappingURL=ColorUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/colortbl/ColortblConfiguration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/colortbl/ColortblConfiguration.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColortblConfiguration = exports.ColorArrayItem = void 0;
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var ColorArrayItem = (function (_super) {
    __extends(ColorArrayItem, _super);
    function ColorArrayItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.color = {
            cell: '',
            row: '',
            col: []
        };
        _this.hasColor = false;
        return _this;
    }
    ColorArrayItem.prototype.EndEntry = function () {
        _super.prototype.EndEntry.call(this);
        var cell = this.row[this.row.length - 1];
        var color = this.color.cell || this.color.row || this.color.col[this.row.length - 1];
        if (color) {
            cell.attributes.set('mathbackground', color);
            this.color.cell = '';
            this.hasColor = true;
        }
    };
    ColorArrayItem.prototype.EndRow = function () {
        _super.prototype.EndRow.call(this);
        this.color.row = '';
    };
    ColorArrayItem.prototype.createMml = function () {
        var mml = _super.prototype.createMml.call(this);
        var table = (mml.isKind('mrow') ? mml.childNodes[1] : mml);
        if (table.isKind('menclose')) {
            table = table.childNodes[0].childNodes[0];
        }
        if (this.hasColor && table.attributes.get('frame') === 'none') {
            table.attributes.set('frame', '');
        }
        return mml;
    };
    return ColorArrayItem;
}(BaseItems_js_1.ArrayItem));
exports.ColorArrayItem = ColorArrayItem;
new SymbolMap_js_1.CommandMap('colortbl', {
    cellcolor: ['TableColor', 'cell'],
    rowcolor: ['TableColor', 'row'],
    columncolor: ['TableColor', 'col']
}, {
    TableColor: function (parser, name, type) {
        var lookup = parser.configuration.packageData.get('color').model;
        var model = parser.GetBrackets(name, '');
        var color = lookup.getColor(model, parser.GetArgument(name));
        var top = parser.stack.Top();
        if (!(top instanceof ColorArrayItem)) {
            throw new TexError_js_1.default('UnsupportedTableColor', 'Unsupported use of %1', parser.currentCS);
        }
        if (type === 'col') {
            if (top.table.length) {
                throw new TexError_js_1.default('ColumnColorNotTop', '%1 must be in the top row', name);
            }
            top.color.col[top.row.length] = color;
            if (parser.GetBrackets(name, '')) {
                parser.GetBrackets(name, '');
            }
        }
        else {
            top.color[type] = color;
            if (type === 'row' && (top.Size() || top.row.length)) {
                throw new TexError_js_1.default('RowColorNotFirst', '%1 must be at the beginning of a row', name);
            }
        }
    }
});
var config = function (config, jax) {
    if (!jax.parseOptions.packageData.has('color')) {
        Configuration_js_1.ConfigurationHandler.get('color').config(config, jax);
    }
};
exports.ColortblConfiguration = Configuration_js_1.Configuration.create('colortbl', {
    handler: { macro: ['colortbl'] },
    items: { 'array': ColorArrayItem },
    priority: 10,
    config: [config, 10]
});
//# sourceMappingURL=ColortblConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/colorv2/ColorV2Configuration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/colorv2/ColorV2Configuration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorConfiguration = exports.ColorV2Methods = void 0;
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
exports.ColorV2Methods = {
    Color: function (parser, name) {
        var color = parser.GetArgument(name);
        var old = parser.stack.env['color'];
        parser.stack.env['color'] = color;
        var math = parser.ParseArg(name);
        if (old) {
            parser.stack.env['color'] = old;
        }
        else {
            delete parser.stack.env['color'];
        }
        var node = parser.create('node', 'mstyle', [math], { mathcolor: color });
        parser.Push(node);
    }
};
new SymbolMap_js_1.CommandMap('colorv2', { color: 'Color' }, exports.ColorV2Methods);
exports.ColorConfiguration = Configuration_js_1.Configuration.create('colorv2', { handler: { macro: ['colorv2'] } });
//# sourceMappingURL=ColorV2Configuration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/configmacros/ConfigMacrosConfiguration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/configmacros/ConfigMacrosConfiguration.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigMacrosConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var Symbol_js_1 = __webpack_require__(/*! ../Symbol.js */ "./node_modules/mathjax-full/js/input/tex/Symbol.js");
var NewcommandMethods_js_1 = __importDefault(__webpack_require__(/*! ../newcommand/NewcommandMethods.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMethods.js"));
var NewcommandItems_js_1 = __webpack_require__(/*! ../newcommand/NewcommandItems.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandItems.js");
var MACROSMAP = 'configmacros-map';
var ENVIRONMENTMAP = 'configmacros-env-map';
function configmacrosInit(config) {
    new SymbolMap_js_1.CommandMap(MACROSMAP, {}, {});
    new SymbolMap_js_1.EnvironmentMap(ENVIRONMENTMAP, ParseMethods_js_1.default.environment, {}, {});
    config.append(Configuration_js_1.Configuration.local({
        handler: {
            macro: [MACROSMAP],
            environment: [ENVIRONMENTMAP]
        },
        priority: 3
    }));
}
function configmacrosConfig(_config, jax) {
    configMacros(jax);
    configEnvironments(jax);
}
function configMacros(jax) {
    var e_1, _a;
    var handler = jax.parseOptions.handlers.retrieve(MACROSMAP);
    var macros = jax.parseOptions.options.macros;
    try {
        for (var _b = __values(Object.keys(macros)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var cs = _c.value;
            var def = (typeof macros[cs] === 'string' ? [macros[cs]] : macros[cs]);
            var macro = Array.isArray(def[2]) ?
                new Symbol_js_1.Macro(cs, NewcommandMethods_js_1.default.MacroWithTemplate, def.slice(0, 2).concat(def[2])) :
                new Symbol_js_1.Macro(cs, NewcommandMethods_js_1.default.Macro, def);
            handler.add(cs, macro);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function configEnvironments(jax) {
    var e_2, _a;
    var handler = jax.parseOptions.handlers.retrieve(ENVIRONMENTMAP);
    var environments = jax.parseOptions.options.environments;
    try {
        for (var _b = __values(Object.keys(environments)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var env = _c.value;
            handler.add(env, new Symbol_js_1.Macro(env, NewcommandMethods_js_1.default.BeginEnv, [true].concat(environments[env])));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
exports.ConfigMacrosConfiguration = Configuration_js_1.Configuration.create('configmacros', {
    init: configmacrosInit,
    config: configmacrosConfig,
    items: (_a = {},
        _a[NewcommandItems_js_1.BeginEnvItem.prototype.kind] = NewcommandItems_js_1.BeginEnvItem,
        _a),
    options: {
        macros: (0, Options_js_1.expandable)({}),
        environments: (0, Options_js_1.expandable)({})
    }
});
//# sourceMappingURL=ConfigMacrosConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/empheq/EmpheqConfiguration.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/empheq/EmpheqConfiguration.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmpheqConfiguration = exports.EmpheqMethods = exports.EmpheqBeginItem = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var EmpheqUtil_js_1 = __webpack_require__(/*! ./EmpheqUtil.js */ "./node_modules/mathjax-full/js/input/tex/empheq/EmpheqUtil.js");
var EmpheqBeginItem = (function (_super) {
    __extends(EmpheqBeginItem, _super);
    function EmpheqBeginItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(EmpheqBeginItem.prototype, "kind", {
        get: function () {
            return 'empheq-begin';
        },
        enumerable: false,
        configurable: true
    });
    EmpheqBeginItem.prototype.checkItem = function (item) {
        if (item.isKind('end') && item.getName() === this.getName()) {
            this.setProperty('end', false);
        }
        return _super.prototype.checkItem.call(this, item);
    };
    return EmpheqBeginItem;
}(BaseItems_js_1.BeginItem));
exports.EmpheqBeginItem = EmpheqBeginItem;
exports.EmpheqMethods = {
    Empheq: function (parser, begin) {
        if (parser.stack.env.closing === begin.getName()) {
            delete parser.stack.env.closing;
            parser.Push(parser.itemFactory.create('end').setProperty('name', parser.stack.global.empheq));
            parser.stack.global.empheq = '';
            var empheq = parser.stack.Top();
            EmpheqUtil_js_1.EmpheqUtil.adjustTable(empheq, parser);
            parser.Push(parser.itemFactory.create('end').setProperty('name', 'empheq'));
        }
        else {
            ParseUtil_js_1.default.checkEqnEnv(parser);
            delete parser.stack.global.eqnenv;
            var opts = parser.GetBrackets('\\begin{' + begin.getName() + '}') || '';
            var _a = __read((parser.GetArgument('\\begin{' + begin.getName() + '}') || '').split(/=/), 2), env = _a[0], n = _a[1];
            if (!EmpheqUtil_js_1.EmpheqUtil.checkEnv(env)) {
                throw new TexError_js_1.default('UnknownEnv', 'Unknown environment "%1"', env);
            }
            if (opts) {
                begin.setProperties(EmpheqUtil_js_1.EmpheqUtil.splitOptions(opts, { left: 1, right: 1 }));
            }
            parser.stack.global.empheq = env;
            parser.string = '\\begin{' + env + '}' + (n ? '{' + n + '}' : '') + parser.string.slice(parser.i);
            parser.i = 0;
            parser.Push(begin);
        }
    },
    EmpheqMO: function (parser, _name, c) {
        parser.Push(parser.create('token', 'mo', {}, c));
    },
    EmpheqDelim: function (parser, name) {
        var c = parser.GetDelimiter(name);
        parser.Push(parser.create('token', 'mo', { stretchy: true, symmetric: true }, c));
    }
};
new SymbolMap_js_1.EnvironmentMap('empheq-env', EmpheqUtil_js_1.EmpheqUtil.environment, {
    empheq: ['Empheq', 'empheq'],
}, exports.EmpheqMethods);
new SymbolMap_js_1.CommandMap('empheq-macros', {
    empheqlbrace: ['EmpheqMO', '{'],
    empheqrbrace: ['EmpheqMO', '}'],
    empheqlbrack: ['EmpheqMO', '['],
    empheqrbrack: ['EmpheqMO', ']'],
    empheqlangle: ['EmpheqMO', '\u27E8'],
    empheqrangle: ['EmpheqMO', '\u27E9'],
    empheqlparen: ['EmpheqMO', '('],
    empheqrparen: ['EmpheqMO', ')'],
    empheqlvert: ['EmpheqMO', '|'],
    empheqrvert: ['EmpheqMO', '|'],
    empheqlVert: ['EmpheqMO', '\u2016'],
    empheqrVert: ['EmpheqMO', '\u2016'],
    empheqlfloor: ['EmpheqMO', '\u230A'],
    empheqrfloor: ['EmpheqMO', '\u230B'],
    empheqlceil: ['EmpheqMO', '\u2308'],
    empheqrceil: ['EmpheqMO', '\u2309'],
    empheqbiglbrace: ['EmpheqMO', '{'],
    empheqbigrbrace: ['EmpheqMO', '}'],
    empheqbiglbrack: ['EmpheqMO', '['],
    empheqbigrbrack: ['EmpheqMO', ']'],
    empheqbiglangle: ['EmpheqMO', '\u27E8'],
    empheqbigrangle: ['EmpheqMO', '\u27E9'],
    empheqbiglparen: ['EmpheqMO', '('],
    empheqbigrparen: ['EmpheqMO', ')'],
    empheqbiglvert: ['EmpheqMO', '|'],
    empheqbigrvert: ['EmpheqMO', '|'],
    empheqbiglVert: ['EmpheqMO', '\u2016'],
    empheqbigrVert: ['EmpheqMO', '\u2016'],
    empheqbiglfloor: ['EmpheqMO', '\u230A'],
    empheqbigrfloor: ['EmpheqMO', '\u230B'],
    empheqbiglceil: ['EmpheqMO', '\u2308'],
    empheqbigrceil: ['EmpheqMO', '\u2309'],
    empheql: 'EmpheqDelim',
    empheqr: 'EmpheqDelim',
    empheqbigl: 'EmpheqDelim',
    empheqbigr: 'EmpheqDelim'
}, exports.EmpheqMethods);
exports.EmpheqConfiguration = Configuration_js_1.Configuration.create('empheq', {
    handler: {
        macro: ['empheq-macros'],
        environment: ['empheq-env'],
    },
    items: (_a = {},
        _a[EmpheqBeginItem.prototype.kind] = EmpheqBeginItem,
        _a)
});
//# sourceMappingURL=EmpheqConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/empheq/EmpheqUtil.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/empheq/EmpheqUtil.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmpheqUtil = void 0;
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
exports.EmpheqUtil = {
    environment: function (parser, env, func, args) {
        var name = args[0];
        var item = parser.itemFactory.create(name + '-begin').setProperties({ name: env, end: name });
        parser.Push(func.apply(void 0, __spreadArray([parser, item], __read(args.slice(1)), false)));
    },
    splitOptions: function (text, allowed) {
        if (allowed === void 0) { allowed = null; }
        return ParseUtil_js_1.default.keyvalOptions(text, allowed, true);
    },
    columnCount: function (table) {
        var e_1, _a;
        var m = 0;
        try {
            for (var _b = __values(table.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                var n = row.childNodes.length - (row.isKind('mlabeledtr') ? 1 : 0);
                if (n > m)
                    m = n;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return m;
    },
    cellBlock: function (tex, table, parser, env) {
        var e_2, _a;
        var mpadded = parser.create('node', 'mpadded', [], { height: 0, depth: 0, voffset: '-1height' });
        var result = new TexParser_js_1.default(tex, parser.stack.env, parser.configuration);
        var mml = result.mml();
        if (env && result.configuration.tags.label) {
            result.configuration.tags.currentTag.env = env;
            result.configuration.tags.getTag(true);
        }
        try {
            for (var _b = __values((mml.isInferred ? mml.childNodes : [mml])), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                mpadded.appendChild(child);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        mpadded.appendChild(parser.create('node', 'mphantom', [
            parser.create('node', 'mpadded', [table], { width: 0 })
        ]));
        return mpadded;
    },
    topRowTable: function (original, parser) {
        var table = ParseUtil_js_1.default.copyNode(original, parser);
        table.setChildren(table.childNodes.slice(0, 1));
        table.attributes.set('align', 'baseline 1');
        return original.factory.create('mphantom', {}, [parser.create('node', 'mpadded', [table], { width: 0 })]);
    },
    rowspanCell: function (mtd, tex, table, parser, env) {
        mtd.appendChild(parser.create('node', 'mpadded', [
            this.cellBlock(tex, ParseUtil_js_1.default.copyNode(table, parser), parser, env),
            this.topRowTable(table, parser)
        ], { height: 0, depth: 0, voffset: 'height' }));
    },
    left: function (table, original, left, parser, env) {
        var e_3, _a;
        if (env === void 0) { env = ''; }
        table.attributes.set('columnalign', 'right ' + (table.attributes.get('columnalign') || ''));
        table.attributes.set('columnspacing', '0em ' + (table.attributes.get('columnspacing') || ''));
        var mtd;
        try {
            for (var _b = __values(table.childNodes.slice(0).reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                mtd = parser.create('node', 'mtd');
                row.childNodes.unshift(mtd);
                mtd.parent = row;
                if (row.isKind('mlabeledtr')) {
                    row.childNodes[0] = row.childNodes[1];
                    row.childNodes[1] = mtd;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        this.rowspanCell(mtd, left, original, parser, env);
    },
    right: function (table, original, right, parser, env) {
        if (env === void 0) { env = ''; }
        if (table.childNodes.length === 0) {
            table.appendChild(parser.create('node', 'mtr'));
        }
        var m = exports.EmpheqUtil.columnCount(table);
        var row = table.childNodes[0];
        while (row.childNodes.length < m)
            row.appendChild(parser.create('node', 'mtd'));
        var mtd = row.appendChild(parser.create('node', 'mtd'));
        exports.EmpheqUtil.rowspanCell(mtd, right, original, parser, env);
        table.attributes.set('columnalign', (table.attributes.get('columnalign') || '').split(/ /).slice(0, m).join(' ') + ' left');
        table.attributes.set('columnspacing', (table.attributes.get('columnspacing') || '').split(/ /).slice(0, m - 1).join(' ') + ' 0em');
    },
    adjustTable: function (empheq, parser) {
        var left = empheq.getProperty('left');
        var right = empheq.getProperty('right');
        if (left || right) {
            var table = empheq.Last;
            var original = ParseUtil_js_1.default.copyNode(table, parser);
            if (left)
                this.left(table, original, left, parser);
            if (right)
                this.right(table, original, right, parser);
        }
    },
    allowEnv: {
        equation: true,
        align: true,
        gather: true,
        flalign: true,
        alignat: true,
        multline: true
    },
    checkEnv: function (env) {
        return this.allowEnv.hasOwnProperty(env.replace(/\*$/, '')) || false;
    }
};
//# sourceMappingURL=EmpheqUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/enclose/EncloseConfiguration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/enclose/EncloseConfiguration.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EncloseConfiguration = exports.EncloseMethods = exports.ENCLOSE_OPTIONS = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
exports.ENCLOSE_OPTIONS = {
    'data-arrowhead': 1,
    color: 1,
    mathcolor: 1,
    background: 1,
    mathbackground: 1,
    'data-padding': 1,
    'data-thickness': 1
};
exports.EncloseMethods = {};
exports.EncloseMethods.Enclose = function (parser, name) {
    var notation = parser.GetArgument(name).replace(/,/g, ' ');
    var attr = parser.GetBrackets(name, '');
    var math = parser.ParseArg(name);
    var def = ParseUtil_js_1.default.keyvalOptions(attr, exports.ENCLOSE_OPTIONS);
    def.notation = notation;
    parser.Push(parser.create('node', 'menclose', [math], def));
};
new SymbolMap_js_1.CommandMap('enclose', { enclose: 'Enclose' }, exports.EncloseMethods);
exports.EncloseConfiguration = Configuration_js_1.Configuration.create('enclose', { handler: { macro: ['enclose'] } });
//# sourceMappingURL=EncloseConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/extpfeil/ExtpfeilConfiguration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/extpfeil/ExtpfeilConfiguration.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtpfeilConfiguration = exports.ExtpfeilMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var AmsMethods_js_1 = __webpack_require__(/*! ../ams/AmsMethods.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js");
var NewcommandUtil_js_1 = __importDefault(__webpack_require__(/*! ../newcommand/NewcommandUtil.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandUtil.js"));
var NewcommandConfiguration_js_1 = __webpack_require__(/*! ../newcommand/NewcommandConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandConfiguration.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
exports.ExtpfeilMethods = {};
exports.ExtpfeilMethods.xArrow = AmsMethods_js_1.AmsMethods.xArrow;
exports.ExtpfeilMethods.NewExtArrow = function (parser, name) {
    var cs = parser.GetArgument(name);
    var space = parser.GetArgument(name);
    var chr = parser.GetArgument(name);
    if (!cs.match(/^\\([a-z]+|.)$/i)) {
        throw new TexError_js_1.default('NewextarrowArg1', 'First argument to %1 must be a control sequence name', name);
    }
    if (!space.match(/^(\d+),(\d+)$/)) {
        throw new TexError_js_1.default('NewextarrowArg2', 'Second argument to %1 must be two integers separated by a comma', name);
    }
    if (!chr.match(/^(\d+|0x[0-9A-F]+)$/i)) {
        throw new TexError_js_1.default('NewextarrowArg3', 'Third argument to %1 must be a unicode character number', name);
    }
    cs = cs.substr(1);
    var spaces = space.split(',');
    NewcommandUtil_js_1.default.addMacro(parser, cs, exports.ExtpfeilMethods.xArrow, [parseInt(chr), parseInt(spaces[0]), parseInt(spaces[1])]);
};
new SymbolMap_js_1.CommandMap('extpfeil', {
    xtwoheadrightarrow: ['xArrow', 0x21A0, 12, 16],
    xtwoheadleftarrow: ['xArrow', 0x219E, 17, 13],
    xmapsto: ['xArrow', 0x21A6, 6, 7],
    xlongequal: ['xArrow', 0x003D, 7, 7],
    xtofrom: ['xArrow', 0x21C4, 12, 12],
    Newextarrow: 'NewExtArrow'
}, exports.ExtpfeilMethods);
var init = function (config) {
    NewcommandConfiguration_js_1.NewcommandConfiguration.init(config);
};
exports.ExtpfeilConfiguration = Configuration_js_1.Configuration.create('extpfeil', {
    handler: { macro: ['extpfeil'] },
    init: init
});
//# sourceMappingURL=ExtpfeilConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/gensymb/GensymbConfiguration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/gensymb/GensymbConfiguration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GensymbConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
function mathcharUnit(parser, mchar) {
    var def = mchar.attributes || {};
    def.mathvariant = TexConstants_js_1.TexConstant.Variant.NORMAL;
    def.class = 'MathML-Unit';
    var node = parser.create('token', 'mi', def, mchar.char);
    parser.Push(node);
}
new SymbolMap_js_1.CharacterMap('gensymb-symbols', mathcharUnit, {
    ohm: '\u2126',
    degree: '\u00B0',
    celsius: '\u2103',
    perthousand: '\u2030',
    micro: '\u00B5'
});
exports.GensymbConfiguration = Configuration_js_1.Configuration.create('gensymb', {
    handler: { macro: ['gensymb-symbols'] },
});
//# sourceMappingURL=GensymbConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/html/HtmlConfiguration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/html/HtmlConfiguration.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HtmlConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var HtmlMethods_js_1 = __importDefault(__webpack_require__(/*! ./HtmlMethods.js */ "./node_modules/mathjax-full/js/input/tex/html/HtmlMethods.js"));
new SymbolMap_js_1.CommandMap('html_macros', {
    href: 'Href',
    'class': 'Class',
    style: 'Style',
    cssId: 'Id'
}, HtmlMethods_js_1.default);
exports.HtmlConfiguration = Configuration_js_1.Configuration.create('html', { handler: { macro: ['html_macros'] } });
//# sourceMappingURL=HtmlConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/html/HtmlMethods.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/html/HtmlMethods.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var HtmlMethods = {};
HtmlMethods.Href = function (parser, name) {
    var url = parser.GetArgument(name);
    var arg = GetArgumentMML(parser, name);
    NodeUtil_js_1.default.setAttribute(arg, 'href', url);
    parser.Push(arg);
};
HtmlMethods.Class = function (parser, name) {
    var CLASS = parser.GetArgument(name);
    var arg = GetArgumentMML(parser, name);
    var oldClass = NodeUtil_js_1.default.getAttribute(arg, 'class');
    if (oldClass) {
        CLASS = oldClass + ' ' + CLASS;
    }
    NodeUtil_js_1.default.setAttribute(arg, 'class', CLASS);
    parser.Push(arg);
};
HtmlMethods.Style = function (parser, name) {
    var style = parser.GetArgument(name);
    var arg = GetArgumentMML(parser, name);
    var oldStyle = NodeUtil_js_1.default.getAttribute(arg, 'style');
    if (oldStyle) {
        if (style.charAt(style.length - 1) !== ';') {
            style += ';';
        }
        style = oldStyle + ' ' + style;
    }
    NodeUtil_js_1.default.setAttribute(arg, 'style', style);
    parser.Push(arg);
};
HtmlMethods.Id = function (parser, name) {
    var ID = parser.GetArgument(name);
    var arg = GetArgumentMML(parser, name);
    NodeUtil_js_1.default.setAttribute(arg, 'id', ID);
    parser.Push(arg);
};
var GetArgumentMML = function (parser, name) {
    var arg = parser.ParseArg(name);
    if (!NodeUtil_js_1.default.isInferred(arg)) {
        return arg;
    }
    var children = NodeUtil_js_1.default.getChildren(arg);
    if (children.length === 1) {
        return children[0];
    }
    var mrow = parser.create('node', 'mrow');
    NodeUtil_js_1.default.copyChildren(arg, mrow);
    NodeUtil_js_1.default.copyAttributes(arg, mrow);
    return mrow;
};
exports["default"] = HtmlMethods;
//# sourceMappingURL=HtmlMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsConfiguration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsConfiguration.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathtoolsConfiguration = exports.fixPrescripts = exports.PAIREDDELIMS = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
__webpack_require__(/*! ./MathtoolsMappings.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMappings.js");
var MathtoolsUtil_js_1 = __webpack_require__(/*! ./MathtoolsUtil.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsUtil.js");
var MathtoolsTags_js_1 = __webpack_require__(/*! ./MathtoolsTags.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsTags.js");
var MathtoolsItems_js_1 = __webpack_require__(/*! ./MathtoolsItems.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsItems.js");
exports.PAIREDDELIMS = 'mathtools-paired-delims';
function initMathtools(config) {
    new SymbolMap_js_1.CommandMap(exports.PAIREDDELIMS, {}, {});
    config.append(Configuration_js_1.Configuration.local({ handler: { macro: [exports.PAIREDDELIMS] }, priority: -5 }));
}
function configMathtools(config, jax) {
    var e_1, _a;
    var parser = jax.parseOptions;
    var pairedDelims = parser.options.mathtools.pairedDelimiters;
    try {
        for (var _b = __values(Object.keys(pairedDelims)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var cs = _c.value;
            MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser, cs, pairedDelims[cs]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    (0, MathtoolsTags_js_1.MathtoolsTagFormat)(config, jax);
}
function fixPrescripts(_a) {
    var e_2, _b, e_3, _c, e_4, _d;
    var data = _a.data;
    try {
        for (var _e = __values(data.getList('mmultiscripts')), _f = _e.next(); !_f.done; _f = _e.next()) {
            var node = _f.value;
            if (!node.getProperty('fixPrescript'))
                continue;
            var childNodes = NodeUtil_js_1.default.getChildren(node);
            var n = 0;
            try {
                for (var _g = (e_3 = void 0, __values([1, 2])), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var i = _h.value;
                    if (!childNodes[i]) {
                        NodeUtil_js_1.default.setChild(node, i, data.nodeFactory.create('node', 'none'));
                        n++;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                }
                finally { if (e_3) throw e_3.error; }
            }
            try {
                for (var _j = (e_4 = void 0, __values([4, 5])), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var i = _k.value;
                    if (NodeUtil_js_1.default.isType(childNodes[i], 'mrow') && NodeUtil_js_1.default.getChildren(childNodes[i]).length === 0) {
                        NodeUtil_js_1.default.setChild(node, i, data.nodeFactory.create('node', 'none'));
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_d = _j.return)) _d.call(_j);
                }
                finally { if (e_4) throw e_4.error; }
            }
            if (n === 2) {
                childNodes.splice(1, 2);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
exports.fixPrescripts = fixPrescripts;
exports.MathtoolsConfiguration = Configuration_js_1.Configuration.create('mathtools', {
    handler: {
        macro: ['mathtools-macros', 'mathtools-delimiters'],
        environment: ['mathtools-environments'],
        delimiter: ['mathtools-delimiters'],
        character: ['mathtools-characters']
    },
    items: (_a = {},
        _a[MathtoolsItems_js_1.MultlinedItem.prototype.kind] = MathtoolsItems_js_1.MultlinedItem,
        _a),
    init: initMathtools,
    config: configMathtools,
    postprocessors: [[fixPrescripts, -6]],
    options: {
        mathtools: {
            'multlinegap': '1em',
            'multlined-pos': 'c',
            'firstline-afterskip': '',
            'lastline-preskip': '',
            'smallmatrix-align': 'c',
            'shortvdotsadjustabove': '.2em',
            'shortvdotsadjustbelow': '.2em',
            'centercolon': false,
            'centercolon-offset': '.04em',
            'thincolon-dx': '-.04em',
            'thincolon-dw': '-.08em',
            'use-unicode': false,
            'prescript-sub-format': '',
            'prescript-sup-format': '',
            'prescript-arg-format': '',
            'allow-mathtoolsset': true,
            pairedDelimiters: (0, Options_js_1.expandable)({}),
            tagforms: (0, Options_js_1.expandable)({}),
        }
    }
});
//# sourceMappingURL=MathtoolsConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsItems.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsItems.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultlinedItem = void 0;
var AmsItems_js_1 = __webpack_require__(/*! ../ams/AmsItems.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsItems.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var MultlinedItem = (function (_super) {
    __extends(MultlinedItem, _super);
    function MultlinedItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MultlinedItem.prototype, "kind", {
        get: function () {
            return 'multlined';
        },
        enumerable: false,
        configurable: true
    });
    MultlinedItem.prototype.EndTable = function () {
        if (this.Size() || this.row.length) {
            this.EndEntry();
            this.EndRow();
        }
        if (this.table.length > 1) {
            var options = this.factory.configuration.options.mathtools;
            var gap = options.multlinegap;
            var firstskip = options['firstline-afterskip'] || gap;
            var lastskip = options['lastline-preskip'] || gap;
            var first = NodeUtil_js_1.default.getChildren(this.table[0])[0];
            if (NodeUtil_js_1.default.getAttribute(first, 'columnalign') !== TexConstants_js_1.TexConstant.Align.RIGHT) {
                first.appendChild(this.create('node', 'mspace', [], { width: firstskip }));
            }
            var last = NodeUtil_js_1.default.getChildren(this.table[this.table.length - 1])[0];
            if (NodeUtil_js_1.default.getAttribute(last, 'columnalign') !== TexConstants_js_1.TexConstant.Align.LEFT) {
                var top_1 = NodeUtil_js_1.default.getChildren(last)[0];
                top_1.childNodes.unshift(null);
                var space = this.create('node', 'mspace', [], { width: lastskip });
                NodeUtil_js_1.default.setChild(top_1, 0, space);
            }
        }
        _super.prototype.EndTable.call(this);
    };
    return MultlinedItem;
}(AmsItems_js_1.MultlineItem));
exports.MultlinedItem = MultlinedItem;
//# sourceMappingURL=MathtoolsItems.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMappings.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMappings.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var MathtoolsMethods_js_1 = __webpack_require__(/*! ./MathtoolsMethods.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMethods.js");
new SymbolMap_js_1.CommandMap('mathtools-macros', {
    shoveleft: ['HandleShove', TexConstants_js_1.TexConstant.Align.LEFT],
    shoveright: ['HandleShove', TexConstants_js_1.TexConstant.Align.RIGHT],
    xleftrightarrow: ['xArrow', 0x2194, 10, 10],
    xLeftarrow: ['xArrow', 0x21D0, 12, 7],
    xRightarrow: ['xArrow', 0x21D2, 7, 12],
    xLeftrightarrow: ['xArrow', 0x21D4, 12, 12],
    xhookleftarrow: ['xArrow', 0x21A9, 10, 5],
    xhookrightarrow: ['xArrow', 0x21AA, 5, 10],
    xmapsto: ['xArrow', 0x21A6, 10, 10],
    xrightharpoondown: ['xArrow', 0x21C1, 5, 10],
    xleftharpoondown: ['xArrow', 0x21BD, 10, 5],
    xrightleftharpoons: ['xArrow', 0x21CC, 10, 10],
    xrightharpoonup: ['xArrow', 0x21C0, 5, 10],
    xleftharpoonup: ['xArrow', 0x21BC, 10, 5],
    xleftrightharpoons: ['xArrow', 0x21CB, 10, 10],
    mathllap: ['MathLap', 'l', false],
    mathrlap: ['MathLap', 'r', false],
    mathclap: ['MathLap', 'c', false],
    clap: ['MtLap', 'c'],
    textllap: ['MtLap', 'l'],
    textrlap: ['MtLap', 'r'],
    textclap: ['MtLap', 'c'],
    cramped: 'Cramped',
    crampedllap: ['MathLap', 'l', true],
    crampedrlap: ['MathLap', 'r', true],
    crampedclap: ['MathLap', 'c', true],
    crampedsubstack: ['Macro', '\\begin{crampedsubarray}{c}#1\\end{crampedsubarray}', 1],
    mathmbox: 'MathMBox',
    mathmakebox: 'MathMakeBox',
    overbracket: 'UnderOverBracket',
    underbracket: 'UnderOverBracket',
    refeq: 'HandleRef',
    MoveEqLeft: ['Macro', '\\hspace{#1em}&\\hspace{-#1em}', 1, '2'],
    Aboxed: 'Aboxed',
    ArrowBetweenLines: 'ArrowBetweenLines',
    vdotswithin: 'VDotsWithin',
    shortvdotswithin: 'ShortVDotsWithin',
    MTFlushSpaceAbove: 'FlushSpaceAbove',
    MTFlushSpaceBelow: 'FlushSpaceBelow',
    DeclarePairedDelimiter: 'DeclarePairedDelimiter',
    DeclarePairedDelimiterX: 'DeclarePairedDelimiterX',
    DeclarePairedDelimiterXPP: 'DeclarePairedDelimiterXPP',
    DeclarePairedDelimiters: 'DeclarePairedDelimiter',
    DeclarePairedDelimitersX: 'DeclarePairedDelimiterX',
    DeclarePairedDelimitersXPP: 'DeclarePairedDelimiterXPP',
    centercolon: ['CenterColon', true, true],
    ordinarycolon: ['CenterColon', false],
    MTThinColon: ['CenterColon', true, true, true],
    coloneqq: ['Relation', ':=', '\u2254'],
    Coloneqq: ['Relation', '::=', '\u2A74'],
    coloneq: ['Relation', ':-'],
    Coloneq: ['Relation', '::-'],
    eqqcolon: ['Relation', '=:', '\u2255'],
    Eqqcolon: ['Relation', '=::'],
    eqcolon: ['Relation', '-:', '\u2239'],
    Eqcolon: ['Relation', '-::'],
    colonapprox: ['Relation', ':\\approx'],
    Colonapprox: ['Relation', '::\\approx'],
    colonsim: ['Relation', ':\\sim'],
    Colonsim: ['Relation', '::\\sim'],
    dblcolon: ['Relation', '::', '\u2237'],
    nuparrow: ['NArrow', '\u2191', '.06em'],
    ndownarrow: ['NArrow', '\u2193', '.25em'],
    bigtimes: ['Macro', '\\mathop{\\Large\\kern-.1em\\boldsymbol{\\times}\\kern-.1em}'],
    splitfrac: ['SplitFrac', false],
    splitdfrac: ['SplitFrac', true],
    xmathstrut: 'XMathStrut',
    prescript: 'Prescript',
    newtagform: ['NewTagForm', false],
    renewtagform: ['NewTagForm', true],
    usetagform: 'UseTagForm',
    adjustlimits: [
        'MacroWithTemplate',
        '\\mathop{{#1}\\vphantom{{#3}}}_{{#2}\\vphantom{{#4}}}\\mathop{{#3}\\vphantom{{#1}}}_{{#4}\\vphantom{{#2}}}',
        4, , '_', , '_'
    ],
    mathtoolsset: 'SetOptions'
}, MathtoolsMethods_js_1.MathtoolsMethods);
new SymbolMap_js_1.EnvironmentMap('mathtools-environments', ParseMethods_js_1.default.environment, {
    dcases: ['Array', null, '\\{', '', 'll', null, '.2em', 'D'],
    rcases: ['Array', null, '', '\\}', 'll', null, '.2em'],
    drcases: ['Array', null, '', '\\}', 'll', null, '.2em', 'D'],
    'dcases*': ['Cases', null, '{', '', 'D'],
    'rcases*': ['Cases', null, '', '}'],
    'drcases*': ['Cases', null, '', '}', 'D'],
    'cases*': ['Cases', null, '{', ''],
    'matrix*': ['MtMatrix', null, null, null],
    'pmatrix*': ['MtMatrix', null, '(', ')'],
    'bmatrix*': ['MtMatrix', null, '[', ']'],
    'Bmatrix*': ['MtMatrix', null, '\\{', '\\}'],
    'vmatrix*': ['MtMatrix', null, '\\vert', '\\vert'],
    'Vmatrix*': ['MtMatrix', null, '\\Vert', '\\Vert'],
    'smallmatrix*': ['MtSmallMatrix', null, null, null],
    psmallmatrix: ['MtSmallMatrix', null, '(', ')', 'c'],
    'psmallmatrix*': ['MtSmallMatrix', null, '(', ')'],
    bsmallmatrix: ['MtSmallMatrix', null, '[', ']', 'c'],
    'bsmallmatrix*': ['MtSmallMatrix', null, '[', ']'],
    Bsmallmatrix: ['MtSmallMatrix', null, '\\{', '\\}', 'c'],
    'Bsmallmatrix*': ['MtSmallMatrix', null, '\\{', '\\}'],
    vsmallmatrix: ['MtSmallMatrix', null, '\\vert', '\\vert', 'c'],
    'vsmallmatrix*': ['MtSmallMatrix', null, '\\vert', '\\vert'],
    Vsmallmatrix: ['MtSmallMatrix', null, '\\Vert', '\\Vert', 'c'],
    'Vsmallmatrix*': ['MtSmallMatrix', null, '\\Vert', '\\Vert'],
    crampedsubarray: ['Array', null, null, null, null, '0em', '0.1em', 'S\'', 1],
    multlined: 'MtMultlined',
    spreadlines: ['SpreadLines', true],
    lgathered: ['AmsEqnArray', null, null, null, 'l', null, '.5em', 'D'],
    rgathered: ['AmsEqnArray', null, null, null, 'r', null, '.5em', 'D'],
}, MathtoolsMethods_js_1.MathtoolsMethods);
new SymbolMap_js_1.DelimiterMap('mathtools-delimiters', ParseMethods_js_1.default.delimiter, {
    '\\lparen': '(',
    '\\rparen': ')'
});
new SymbolMap_js_1.CommandMap('mathtools-characters', {
    ':': ['CenterColon', true]
}, MathtoolsMethods_js_1.MathtoolsMethods);
//# sourceMappingURL=MathtoolsMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMethods.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMethods.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathtoolsMethods = void 0;
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var AmsMethods_js_1 = __webpack_require__(/*! ../ams/AmsMethods.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js");
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var lengths_js_1 = __webpack_require__(/*! ../../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var NewcommandUtil_js_1 = __importDefault(__webpack_require__(/*! ../newcommand/NewcommandUtil.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandUtil.js"));
var NewcommandMethods_js_1 = __importDefault(__webpack_require__(/*! ../newcommand/NewcommandMethods.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMethods.js"));
var MathtoolsUtil_js_1 = __webpack_require__(/*! ./MathtoolsUtil.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsUtil.js");
exports.MathtoolsMethods = {
    MtMatrix: function (parser, begin, open, close) {
        var align = parser.GetBrackets("\\begin{".concat(begin.getName(), "}"), 'c');
        return exports.MathtoolsMethods.Array(parser, begin, open, close, align);
    },
    MtSmallMatrix: function (parser, begin, open, close, align) {
        if (!align) {
            align = parser.GetBrackets("\\begin{".concat(begin.getName(), "}"), parser.options.mathtools['smallmatrix-align']);
        }
        return exports.MathtoolsMethods.Array(parser, begin, open, close, align, ParseUtil_js_1.default.Em(1 / 3), '.2em', 'S', 1);
    },
    MtMultlined: function (parser, begin) {
        var _a;
        var name = "\\begin{".concat(begin.getName(), "}");
        var pos = parser.GetBrackets(name, parser.options.mathtools['multlined-pos'] || 'c');
        var width = pos ? parser.GetBrackets(name, '') : '';
        if (pos && !pos.match(/^[cbt]$/)) {
            _a = __read([pos, width], 2), width = _a[0], pos = _a[1];
        }
        parser.Push(begin);
        var item = parser.itemFactory.create('multlined', parser, begin);
        item.arraydef = {
            displaystyle: true,
            rowspacing: '.5em',
            width: width || 'auto',
            columnwidth: '100%',
        };
        return ParseUtil_js_1.default.setArrayAlign(item, pos || 'c');
    },
    HandleShove: function (parser, name, shove) {
        var top = parser.stack.Top();
        if (top.kind !== 'multline' && top.kind !== 'multlined') {
            throw new TexError_js_1.default('CommandInMultlined', '%1 can only appear within the multline or multlined environments', name);
        }
        if (top.Size()) {
            throw new TexError_js_1.default('CommandAtTheBeginingOfLine', '%1 must come at the beginning of the line', name);
        }
        top.setProperty('shove', shove);
        var shift = parser.GetBrackets(name);
        var mml = parser.ParseArg(name);
        if (shift) {
            var mrow = parser.create('node', 'mrow', []);
            var mspace = parser.create('node', 'mspace', [], { width: shift });
            if (shove === 'left') {
                mrow.appendChild(mspace);
                mrow.appendChild(mml);
            }
            else {
                mrow.appendChild(mml);
                mrow.appendChild(mspace);
            }
            mml = mrow;
        }
        parser.Push(mml);
    },
    SpreadLines: function (parser, begin) {
        var e_1, _a;
        if (parser.stack.env.closing === begin.getName()) {
            delete parser.stack.env.closing;
            var top_1 = parser.stack.Pop();
            var mml = top_1.toMml();
            var spread = top_1.getProperty('spread');
            if (mml.isInferred) {
                try {
                    for (var _b = __values(NodeUtil_js_1.default.getChildren(mml)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        MathtoolsUtil_js_1.MathtoolsUtil.spreadLines(child, spread);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                MathtoolsUtil_js_1.MathtoolsUtil.spreadLines(mml, spread);
            }
            parser.Push(mml);
        }
        else {
            var spread = parser.GetDimen("\\begin{".concat(begin.getName(), "}"));
            begin.setProperty('spread', spread);
            parser.Push(begin);
        }
    },
    Cases: function (parser, begin, open, close, style) {
        var array = parser.itemFactory.create('array').setProperty('casesEnv', begin.getName());
        array.arraydef = {
            rowspacing: '.2em',
            columnspacing: '1em',
            columnalign: 'left'
        };
        if (style === 'D') {
            array.arraydef.displaystyle = true;
        }
        array.setProperties({ open: open, close: close });
        parser.Push(begin);
        return array;
    },
    MathLap: function (parser, name, pos, cramped) {
        var style = parser.GetBrackets(name, '').trim();
        var mml = parser.create('node', 'mstyle', [
            parser.create('node', 'mpadded', [parser.ParseArg(name)], __assign({ width: 0 }, (pos === 'r' ? {} : { lspace: (pos === 'l' ? '-1width' : '-.5width') })))
        ], { 'data-cramped': cramped });
        MathtoolsUtil_js_1.MathtoolsUtil.setDisplayLevel(mml, style);
        parser.Push(parser.create('node', 'TeXAtom', [mml]));
    },
    Cramped: function (parser, name) {
        var style = parser.GetBrackets(name, '').trim();
        var arg = parser.ParseArg(name);
        var mml = parser.create('node', 'mstyle', [arg], { 'data-cramped': true });
        MathtoolsUtil_js_1.MathtoolsUtil.setDisplayLevel(mml, style);
        parser.Push(mml);
    },
    MtLap: function (parser, name, pos) {
        var content = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), 0);
        var mml = parser.create('node', 'mpadded', content, { width: 0 });
        if (pos !== 'r') {
            NodeUtil_js_1.default.setAttribute(mml, 'lspace', pos === 'l' ? '-1width' : '-.5width');
        }
        parser.Push(mml);
    },
    MathMakeBox: function (parser, name) {
        var width = parser.GetBrackets(name);
        var pos = parser.GetBrackets(name, 'c');
        var mml = parser.create('node', 'mpadded', [parser.ParseArg(name)]);
        if (width) {
            NodeUtil_js_1.default.setAttribute(mml, 'width', width);
        }
        var align = (0, Options_js_1.lookup)(pos, { c: 'center', r: 'right' }, '');
        if (align) {
            NodeUtil_js_1.default.setAttribute(mml, 'data-align', align);
        }
        parser.Push(mml);
    },
    MathMBox: function (parser, name) {
        parser.Push(parser.create('node', 'mrow', [parser.ParseArg(name)]));
    },
    UnderOverBracket: function (parser, name) {
        var thickness = (0, lengths_js_1.length2em)(parser.GetBrackets(name, '.1em'), .1);
        var height = parser.GetBrackets(name, '.2em');
        var arg = parser.GetArgument(name);
        var _a = __read((name.charAt(1) === 'o' ?
            ['over', 'accent', 'bottom'] :
            ['under', 'accentunder', 'top']), 3), pos = _a[0], accent = _a[1], border = _a[2];
        var t = (0, lengths_js_1.em)(thickness);
        var base = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();
        var copy = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();
        var script = parser.create('node', 'mpadded', [
            parser.create('node', 'mphantom', [copy])
        ], {
            style: "border: ".concat(t, " solid; border-").concat(border, ": none"),
            height: height,
            depth: 0
        });
        var node = ParseUtil_js_1.default.underOver(parser, base, script, pos, true);
        var munderover = NodeUtil_js_1.default.getChildAt(NodeUtil_js_1.default.getChildAt(node, 0), 0);
        NodeUtil_js_1.default.setAttribute(munderover, accent, true);
        parser.Push(node);
    },
    Aboxed: function (parser, name) {
        var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);
        if (top.row.length % 2 === 1) {
            top.row.push(parser.create('node', 'mtd', []));
        }
        var arg = parser.GetArgument(name);
        var rest = parser.string.substr(parser.i);
        parser.string = arg + '&&\\endAboxed';
        parser.i = 0;
        var left = parser.GetUpTo(name, '&');
        var right = parser.GetUpTo(name, '&');
        parser.GetUpTo(name, '\\endAboxed');
        var tex = ParseUtil_js_1.default.substituteArgs(parser, [left, right], '\\rlap{\\boxed{#1{}#2}}\\kern.267em\\phantom{#1}&\\phantom{{}#2}\\kern.267em');
        parser.string = tex + rest;
        parser.i = 0;
    },
    ArrowBetweenLines: function (parser, name) {
        var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);
        if (top.Size() || top.row.length) {
            throw new TexError_js_1.default('BetweenLines', '%1 must be on a row by itself', name);
        }
        var star = parser.GetStar();
        var symbol = parser.GetBrackets(name, '\\Updownarrow');
        if (star) {
            top.EndEntry();
            top.EndEntry();
        }
        var tex = (star ? '\\quad' + symbol : symbol + '\\quad');
        var mml = new TexParser_js_1.default(tex, parser.stack.env, parser.configuration).mml();
        parser.Push(mml);
        top.EndEntry();
        top.EndRow();
    },
    VDotsWithin: function (parser, name) {
        var top = parser.stack.Top();
        var isFlush = (top.getProperty('flushspaceabove') === top.table.length);
        var arg = '\\mmlToken{mi}{}' + parser.GetArgument(name) + '\\mmlToken{mi}{}';
        var base = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();
        var mml = parser.create('node', 'mpadded', [
            parser.create('node', 'mpadded', [
                parser.create('node', 'mo', [
                    parser.create('text', '\u22EE')
                ])
            ], __assign({ width: 0, lspace: '-.5width' }, (isFlush ? { height: '-.6em', voffset: '-.18em' } : {}))),
            parser.create('node', 'mphantom', [base])
        ], {
            lspace: '.5width'
        });
        parser.Push(mml);
    },
    ShortVDotsWithin: function (parser, _name) {
        var top = parser.stack.Top();
        var star = parser.GetStar();
        exports.MathtoolsMethods.FlushSpaceAbove(parser, '\\MTFlushSpaceAbove');
        !star && top.EndEntry();
        exports.MathtoolsMethods.VDotsWithin(parser, '\\vdotswithin');
        star && top.EndEntry();
        exports.MathtoolsMethods.FlushSpaceBelow(parser, '\\MTFlushSpaceBelow');
    },
    FlushSpaceAbove: function (parser, name) {
        var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);
        top.setProperty('flushspaceabove', top.table.length);
        top.addRowSpacing('-' + parser.options.mathtools['shortvdotsadjustabove']);
    },
    FlushSpaceBelow: function (parser, name) {
        var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);
        top.Size() && top.EndEntry();
        top.EndRow();
        top.addRowSpacing('-' + parser.options.mathtools['shortvdotsadjustbelow']);
    },
    PairedDelimiters: function (parser, name, open, close, body, n, pre, post) {
        if (body === void 0) { body = '#1'; }
        if (n === void 0) { n = 1; }
        if (pre === void 0) { pre = ''; }
        if (post === void 0) { post = ''; }
        var star = parser.GetStar();
        var size = (star ? '' : parser.GetBrackets(name));
        var _a = __read((star ? ['\\left', '\\right'] : size ? [size + 'l', size + 'r'] : ['', '']), 2), left = _a[0], right = _a[1];
        var delim = (star ? '\\middle' : size || '');
        if (n) {
            var args = [];
            for (var i = args.length; i < n; i++) {
                args.push(parser.GetArgument(name));
            }
            pre = ParseUtil_js_1.default.substituteArgs(parser, args, pre);
            body = ParseUtil_js_1.default.substituteArgs(parser, args, body);
            post = ParseUtil_js_1.default.substituteArgs(parser, args, post);
        }
        body = body.replace(/\\delimsize/g, delim);
        parser.string = [pre, left, open, body, right, close, post, parser.string.substr(parser.i)]
            .reduce(function (s, part) { return ParseUtil_js_1.default.addArgs(parser, s, part); }, '');
        parser.i = 0;
        ParseUtil_js_1.default.checkMaxMacros(parser);
    },
    DeclarePairedDelimiter: function (parser, name) {
        var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);
        var open = parser.GetArgument(name);
        var close = parser.GetArgument(name);
        MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close]);
    },
    DeclarePairedDelimiterX: function (parser, name) {
        var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);
        var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);
        var open = parser.GetArgument(name);
        var close = parser.GetArgument(name);
        var body = parser.GetArgument(name);
        MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close, body, n]);
    },
    DeclarePairedDelimiterXPP: function (parser, name) {
        var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);
        var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);
        var pre = parser.GetArgument(name);
        var open = parser.GetArgument(name);
        var close = parser.GetArgument(name);
        var post = parser.GetArgument(name);
        var body = parser.GetArgument(name);
        MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close, body, n, pre, post]);
    },
    CenterColon: function (parser, _name, center, force, thin) {
        if (force === void 0) { force = false; }
        if (thin === void 0) { thin = false; }
        var options = parser.options.mathtools;
        var mml = parser.create('token', 'mo', {}, ':');
        if (center && (options['centercolon'] || force)) {
            var dy = options['centercolon-offset'];
            mml = parser.create('node', 'mpadded', [mml], __assign({ voffset: dy, height: "+".concat(dy), depth: "-".concat(dy) }, (thin ? { width: options['thincolon-dw'], lspace: options['thincolon-dx'] } : {})));
        }
        parser.Push(mml);
    },
    Relation: function (parser, _name, tex, unicode) {
        var options = parser.options.mathtools;
        if (options['use-unicode'] && unicode) {
            parser.Push(parser.create('token', 'mo', { texClass: MmlNode_js_1.TEXCLASS.REL }, unicode));
        }
        else {
            tex = '\\mathrel{' + tex.replace(/:/g, '\\MTThinColon').replace(/-/g, '\\mathrel{-}') + '}';
            parser.string = ParseUtil_js_1.default.addArgs(parser, tex, parser.string.substr(parser.i));
            parser.i = 0;
        }
    },
    NArrow: function (parser, _name, c, dy) {
        parser.Push(parser.create('node', 'TeXAtom', [
            parser.create('token', 'mtext', {}, c),
            parser.create('node', 'mpadded', [
                parser.create('node', 'mpadded', [
                    parser.create('node', 'menclose', [
                        parser.create('node', 'mspace', [], { height: '.2em', depth: 0, width: '.4em' })
                    ], { notation: 'updiagonalstrike', 'data-thickness': '.05em', 'data-padding': 0 })
                ], { width: 0, lspace: '-.5width', voffset: dy }),
                parser.create('node', 'mphantom', [
                    parser.create('token', 'mtext', {}, c)
                ])
            ], { width: 0, lspace: '-.5width' })
        ], { texClass: MmlNode_js_1.TEXCLASS.REL }));
    },
    SplitFrac: function (parser, name, display) {
        var num = parser.ParseArg(name);
        var den = parser.ParseArg(name);
        parser.Push(parser.create('node', 'mstyle', [
            parser.create('node', 'mfrac', [
                parser.create('node', 'mstyle', [
                    num,
                    parser.create('token', 'mi'),
                    parser.create('token', 'mspace', { width: '1em' })
                ], { scriptlevel: 0 }),
                parser.create('node', 'mstyle', [
                    parser.create('token', 'mspace', { width: '1em' }),
                    parser.create('token', 'mi'),
                    den
                ], { scriptlevel: 0 })
            ], { linethickness: 0, numalign: 'left', denomalign: 'right' })
        ], { displaystyle: display, scriptlevel: 0 }));
    },
    XMathStrut: function (parser, name) {
        var dd = parser.GetBrackets(name);
        var dh = parser.GetArgument(name);
        dh = MathtoolsUtil_js_1.MathtoolsUtil.plusOrMinus(name, dh);
        dd = MathtoolsUtil_js_1.MathtoolsUtil.plusOrMinus(name, dd || dh);
        parser.Push(parser.create('node', 'TeXAtom', [
            parser.create('node', 'mpadded', [
                parser.create('node', 'mphantom', [
                    parser.create('token', 'mo', { stretchy: false }, '(')
                ])
            ], { width: 0, height: dh + 'height', depth: dd + 'depth' })
        ], { texClass: MmlNode_js_1.TEXCLASS.ORD }));
    },
    Prescript: function (parser, name) {
        var sup = MathtoolsUtil_js_1.MathtoolsUtil.getScript(parser, name, 'sup');
        var sub = MathtoolsUtil_js_1.MathtoolsUtil.getScript(parser, name, 'sub');
        var base = MathtoolsUtil_js_1.MathtoolsUtil.getScript(parser, name, 'arg');
        if (NodeUtil_js_1.default.isType(sup, 'none') && NodeUtil_js_1.default.isType(sub, 'none')) {
            parser.Push(base);
            return;
        }
        var mml = parser.create('node', 'mmultiscripts', [base]);
        NodeUtil_js_1.default.getChildren(mml).push(null, null);
        NodeUtil_js_1.default.appendChildren(mml, [parser.create('node', 'mprescripts'), sub, sup]);
        mml.setProperty('fixPrescript', true);
        parser.Push(mml);
    },
    NewTagForm: function (parser, name, renew) {
        if (renew === void 0) { renew = false; }
        var tags = parser.tags;
        if (!('mtFormats' in tags)) {
            throw new TexError_js_1.default('TagsNotMT', '%1 can only be used with ams or mathtools tags', name);
        }
        var id = parser.GetArgument(name).trim();
        if (!id) {
            throw new TexError_js_1.default('InvalidTagFormID', 'Tag form name can\'t be empty');
        }
        var format = parser.GetBrackets(name, '');
        var left = parser.GetArgument(name);
        var right = parser.GetArgument(name);
        if (!renew && tags.mtFormats.has(id)) {
            throw new TexError_js_1.default('DuplicateTagForm', 'Duplicate tag form: %1', id);
        }
        tags.mtFormats.set(id, [left, right, format]);
    },
    UseTagForm: function (parser, name) {
        var tags = parser.tags;
        if (!('mtFormats' in tags)) {
            throw new TexError_js_1.default('TagsNotMT', '%1 can only be used with ams or mathtools tags', name);
        }
        var id = parser.GetArgument(name).trim();
        if (!id) {
            tags.mtCurrent = null;
            return;
        }
        if (!tags.mtFormats.has(id)) {
            throw new TexError_js_1.default('UndefinedTagForm', 'Undefined tag form: %1', id);
        }
        tags.mtCurrent = tags.mtFormats.get(id);
    },
    SetOptions: function (parser, name) {
        var e_2, _a;
        var options = parser.options.mathtools;
        if (!options['allow-mathtoolsset']) {
            throw new TexError_js_1.default('ForbiddenMathtoolsSet', '%1 is disabled', name);
        }
        var allowed = {};
        Object.keys(options).forEach(function (id) {
            if (id !== 'pariedDelimiters' && id !== 'tagforms' && id !== 'allow-mathtoolsset') {
                allowed[id] = 1;
            }
        });
        var args = parser.GetArgument(name);
        var keys = ParseUtil_js_1.default.keyvalOptions(args, allowed, true);
        try {
            for (var _b = __values(Object.keys(keys)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var id = _c.value;
                options[id] = keys[id];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    },
    Array: BaseMethods_js_1.default.Array,
    Macro: BaseMethods_js_1.default.Macro,
    xArrow: AmsMethods_js_1.AmsMethods.xArrow,
    HandleRef: AmsMethods_js_1.AmsMethods.HandleRef,
    AmsEqnArray: AmsMethods_js_1.AmsMethods.AmsEqnArray,
    MacroWithTemplate: NewcommandMethods_js_1.default.MacroWithTemplate,
};
//# sourceMappingURL=MathtoolsMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsTags.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsTags.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathtoolsTagFormat = void 0;
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var Tags_js_1 = __webpack_require__(/*! ../Tags.js */ "./node_modules/mathjax-full/js/input/tex/Tags.js");
var tagID = 0;
function MathtoolsTagFormat(config, jax) {
    var tags = jax.parseOptions.options.tags;
    if (tags !== 'base' && config.tags.hasOwnProperty(tags)) {
        Tags_js_1.TagsFactory.add(tags, config.tags[tags]);
    }
    var TagClass = Tags_js_1.TagsFactory.create(jax.parseOptions.options.tags).constructor;
    var TagFormat = (function (_super) {
        __extends(TagFormat, _super);
        function TagFormat() {
            var e_1, _a;
            var _this = _super.call(this) || this;
            _this.mtFormats = new Map();
            _this.mtCurrent = null;
            var forms = jax.parseOptions.options.mathtools.tagforms;
            try {
                for (var _b = __values(Object.keys(forms)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var form = _c.value;
                    if (!Array.isArray(forms[form]) || forms[form].length !== 3) {
                        throw new TexError_js_1.default('InvalidTagFormDef', 'The tag form definition for "%1" should be an array fo three strings', form);
                    }
                    _this.mtFormats.set(form, forms[form]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return _this;
        }
        TagFormat.prototype.formatTag = function (tag) {
            if (this.mtCurrent) {
                var _a = __read(this.mtCurrent, 3), left = _a[0], right = _a[1], format = _a[2];
                return (format ? "".concat(left).concat(format, "{").concat(tag, "}").concat(right) : "".concat(left).concat(tag).concat(right));
            }
            return _super.prototype.formatTag.call(this, tag);
        };
        return TagFormat;
    }(TagClass));
    tagID++;
    var tagName = 'MathtoolsTags-' + tagID;
    Tags_js_1.TagsFactory.add(tagName, TagFormat);
    jax.parseOptions.options.tags = tagName;
}
exports.MathtoolsTagFormat = MathtoolsTagFormat;
//# sourceMappingURL=MathtoolsTags.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsUtil.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsUtil.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathtoolsUtil = void 0;
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var Symbol_js_1 = __webpack_require__(/*! ../Symbol.js */ "./node_modules/mathjax-full/js/input/tex/Symbol.js");
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var MathtoolsMethods_js_1 = __webpack_require__(/*! ./MathtoolsMethods.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsMethods.js");
var MathtoolsConfiguration_js_1 = __webpack_require__(/*! ./MathtoolsConfiguration.js */ "./node_modules/mathjax-full/js/input/tex/mathtools/MathtoolsConfiguration.js");
exports.MathtoolsUtil = {
    setDisplayLevel: function (mml, style) {
        if (!style)
            return;
        var _a = __read((0, Options_js_1.lookup)(style, {
            '\\displaystyle': [true, 0],
            '\\textstyle': [false, 0],
            '\\scriptstyle': [false, 1],
            '\\scriptscriptstyle': [false, 2]
        }, [null, null]), 2), display = _a[0], script = _a[1];
        if (display !== null) {
            mml.attributes.set('displaystyle', display);
            mml.attributes.set('scriptlevel', script);
        }
    },
    checkAlignment: function (parser, name) {
        var top = parser.stack.Top();
        if (top.kind !== BaseItems_js_1.EqnArrayItem.prototype.kind) {
            throw new TexError_js_1.default('NotInAlignment', '%1 can only be used in aligment environments', name);
        }
        return top;
    },
    addPairedDelims: function (config, cs, args) {
        var delims = config.handlers.retrieve(MathtoolsConfiguration_js_1.PAIREDDELIMS);
        delims.add(cs, new Symbol_js_1.Macro(cs, MathtoolsMethods_js_1.MathtoolsMethods.PairedDelimiters, args));
    },
    spreadLines: function (mtable, spread) {
        if (!mtable.isKind('mtable'))
            return;
        var rowspacing = mtable.attributes.get('rowspacing');
        if (rowspacing) {
            var add_1 = ParseUtil_js_1.default.dimen2em(spread);
            rowspacing = rowspacing
                .split(/ /)
                .map(function (s) { return ParseUtil_js_1.default.Em(Math.max(0, ParseUtil_js_1.default.dimen2em(s) + add_1)); })
                .join(' ');
        }
        else {
            rowspacing = spread;
        }
        mtable.attributes.set('rowspacing', rowspacing);
    },
    plusOrMinus: function (name, n) {
        n = n.trim();
        if (!n.match(/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)$/)) {
            throw new TexError_js_1.default('NotANumber', 'Argument to %1 is not a number', name);
        }
        return (n.match(/^[-+]/) ? n : '+' + n);
    },
    getScript: function (parser, name, pos) {
        var arg = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
        if (arg === '') {
            return parser.create('node', 'none');
        }
        var format = parser.options.mathtools["prescript-".concat(pos, "-format")];
        format && (arg = "".concat(format, "{").concat(arg, "}"));
        return new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();
    }
};
//# sourceMappingURL=MathtoolsUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/mhchem/MhchemConfiguration.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/mhchem/MhchemConfiguration.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MhchemConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var AmsMethods_js_1 = __webpack_require__(/*! ../ams/AmsMethods.js */ "./node_modules/mathjax-full/js/input/tex/ams/AmsMethods.js");
var mhchemParser_js_1 = __webpack_require__(/*! mhchemparser/dist/mhchemParser.js */ "./node_modules/mhchemparser/dist/mhchemParser.js");
var MhchemMethods = {};
MhchemMethods.Macro = BaseMethods_js_1.default.Macro;
MhchemMethods.xArrow = AmsMethods_js_1.AmsMethods.xArrow;
MhchemMethods.Machine = function (parser, name, machine) {
    var arg = parser.GetArgument(name);
    var tex;
    try {
        tex = mhchemParser_js_1.mhchemParser.toTex(arg, machine);
    }
    catch (err) {
        throw new TexError_js_1.default(err[0], err[1]);
    }
    parser.string = tex + parser.string.substr(parser.i);
    parser.i = 0;
};
new SymbolMap_js_1.CommandMap('mhchem', {
    ce: ['Machine', 'ce'],
    pu: ['Machine', 'pu'],
    longrightleftharpoons: [
        'Macro',
        '\\stackrel{\\textstyle{-}\\!\\!{\\rightharpoonup}}{\\smash{{\\leftharpoondown}\\!\\!{-}}}'
    ],
    longRightleftharpoons: [
        'Macro',
        '\\stackrel{\\textstyle{-}\\!\\!{\\rightharpoonup}}{\\smash{\\leftharpoondown}}'
    ],
    longLeftrightharpoons: [
        'Macro',
        '\\stackrel{\\textstyle\\vphantom{{-}}{\\rightharpoonup}}{\\smash{{\\leftharpoondown}\\!\\!{-}}}'
    ],
    longleftrightarrows: [
        'Macro',
        '\\stackrel{\\longrightarrow}{\\smash{\\longleftarrow}\\Rule{0px}{.25em}{0px}}'
    ],
    tripledash: [
        'Macro',
        '\\vphantom{-}\\raise2mu{\\kern2mu\\tiny\\text{-}\\kern1mu\\text{-}\\kern1mu\\text{-}\\kern2mu}'
    ],
    xleftrightarrow: ['xArrow', 0x2194, 6, 6],
    xrightleftharpoons: ['xArrow', 0x21CC, 5, 7],
    xRightleftharpoons: ['xArrow', 0x21CC, 5, 7],
    xLeftrightharpoons: ['xArrow', 0x21CC, 5, 7]
}, MhchemMethods);
exports.MhchemConfiguration = Configuration_js_1.Configuration.create('mhchem', { handler: { macro: ['mhchem'] } });
//# sourceMappingURL=MhchemConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandConfiguration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandConfiguration.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewcommandConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var NewcommandItems_js_1 = __webpack_require__(/*! ./NewcommandItems.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandItems.js");
var NewcommandUtil_js_1 = __importDefault(__webpack_require__(/*! ./NewcommandUtil.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandUtil.js"));
__webpack_require__(/*! ./NewcommandMappings.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMappings.js");
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var sm = __importStar(__webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js"));
var init = function (config) {
    new sm.DelimiterMap(NewcommandUtil_js_1.default.NEW_DELIMITER, ParseMethods_js_1.default.delimiter, {});
    new sm.CommandMap(NewcommandUtil_js_1.default.NEW_COMMAND, {}, {});
    new sm.EnvironmentMap(NewcommandUtil_js_1.default.NEW_ENVIRONMENT, ParseMethods_js_1.default.environment, {}, {});
    config.append(Configuration_js_1.Configuration.local({ handler: { character: [],
            delimiter: [NewcommandUtil_js_1.default.NEW_DELIMITER],
            macro: [NewcommandUtil_js_1.default.NEW_DELIMITER,
                NewcommandUtil_js_1.default.NEW_COMMAND],
            environment: [NewcommandUtil_js_1.default.NEW_ENVIRONMENT]
        },
        priority: -1 }));
};
exports.NewcommandConfiguration = Configuration_js_1.Configuration.create('newcommand', {
    handler: {
        macro: ['Newcommand-macros']
    },
    items: (_a = {},
        _a[NewcommandItems_js_1.BeginEnvItem.prototype.kind] = NewcommandItems_js_1.BeginEnvItem,
        _a),
    options: { maxMacros: 1000 },
    init: init
});
//# sourceMappingURL=NewcommandConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandItems.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandItems.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeginEnvItem = void 0;
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var StackItem_js_1 = __webpack_require__(/*! ../StackItem.js */ "./node_modules/mathjax-full/js/input/tex/StackItem.js");
var BeginEnvItem = (function (_super) {
    __extends(BeginEnvItem, _super);
    function BeginEnvItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BeginEnvItem.prototype, "kind", {
        get: function () {
            return 'beginEnv';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BeginEnvItem.prototype, "isOpen", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    BeginEnvItem.prototype.checkItem = function (item) {
        if (item.isKind('end')) {
            if (item.getName() !== this.getName()) {
                throw new TexError_js_1.default('EnvBadEnd', '\\begin{%1} ended with \\end{%2}', this.getName(), item.getName());
            }
            return [[this.factory.create('mml', this.toMml())], true];
        }
        if (item.isKind('stop')) {
            throw new TexError_js_1.default('EnvMissingEnd', 'Missing \\end{%1}', this.getName());
        }
        return _super.prototype.checkItem.call(this, item);
    };
    return BeginEnvItem;
}(StackItem_js_1.BaseItem));
exports.BeginEnvItem = BeginEnvItem;
//# sourceMappingURL=NewcommandItems.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMappings.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMappings.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var NewcommandMethods_js_1 = __importDefault(__webpack_require__(/*! ./NewcommandMethods.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMethods.js"));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
new SymbolMap_js_1.CommandMap('Newcommand-macros', {
    newcommand: 'NewCommand',
    renewcommand: 'NewCommand',
    newenvironment: 'NewEnvironment',
    renewenvironment: 'NewEnvironment',
    def: 'MacroDef',
    'let': 'Let'
}, NewcommandMethods_js_1.default);
//# sourceMappingURL=NewcommandMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMethods.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandMethods.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var sm = __importStar(__webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js"));
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var NewcommandUtil_js_1 = __importDefault(__webpack_require__(/*! ./NewcommandUtil.js */ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandUtil.js"));
var NewcommandMethods = {};
NewcommandMethods.NewCommand = function (parser, name) {
    var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);
    var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);
    var opt = parser.GetBrackets(name);
    var def = parser.GetArgument(name);
    NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.Macro, [def, n, opt]);
};
NewcommandMethods.NewEnvironment = function (parser, name) {
    var env = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
    var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);
    var opt = parser.GetBrackets(name);
    var bdef = parser.GetArgument(name);
    var edef = parser.GetArgument(name);
    NewcommandUtil_js_1.default.addEnvironment(parser, env, NewcommandMethods.BeginEnv, [true, bdef, edef, n, opt]);
};
NewcommandMethods.MacroDef = function (parser, name) {
    var cs = NewcommandUtil_js_1.default.GetCSname(parser, name);
    var params = NewcommandUtil_js_1.default.GetTemplate(parser, name, '\\' + cs);
    var def = parser.GetArgument(name);
    !(params instanceof Array) ?
        NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.Macro, [def, params]) :
        NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.MacroWithTemplate, [def].concat(params));
};
NewcommandMethods.Let = function (parser, name) {
    var cs = NewcommandUtil_js_1.default.GetCSname(parser, name);
    var c = parser.GetNext();
    if (c === '=') {
        parser.i++;
        c = parser.GetNext();
    }
    var handlers = parser.configuration.handlers;
    if (c === '\\') {
        name = NewcommandUtil_js_1.default.GetCSname(parser, name);
        var macro_1 = handlers.get('delimiter').lookup('\\' + name);
        if (macro_1) {
            NewcommandUtil_js_1.default.addDelimiter(parser, '\\' + cs, macro_1.char, macro_1.attributes);
            return;
        }
        var map_1 = handlers.get('macro').applicable(name);
        if (!map_1) {
            return;
        }
        if (map_1 instanceof sm.MacroMap) {
            var macro_2 = map_1.lookup(name);
            NewcommandUtil_js_1.default.addMacro(parser, cs, macro_2.func, macro_2.args, macro_2.symbol);
            return;
        }
        macro_1 = map_1.lookup(name);
        var newArgs = NewcommandUtil_js_1.default.disassembleSymbol(cs, macro_1);
        var method = function (p, _cs) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            var symb = NewcommandUtil_js_1.default.assembleSymbol(rest);
            return map_1.parser(p, symb);
        };
        NewcommandUtil_js_1.default.addMacro(parser, cs, method, newArgs);
        return;
    }
    parser.i++;
    var macro = handlers.get('delimiter').lookup(c);
    if (macro) {
        NewcommandUtil_js_1.default.addDelimiter(parser, '\\' + cs, macro.char, macro.attributes);
        return;
    }
    NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.Macro, [c]);
};
NewcommandMethods.MacroWithTemplate = function (parser, name, text, n) {
    var params = [];
    for (var _i = 4; _i < arguments.length; _i++) {
        params[_i - 4] = arguments[_i];
    }
    var argCount = parseInt(n, 10);
    if (argCount) {
        var args = [];
        parser.GetNext();
        if (params[0] && !NewcommandUtil_js_1.default.MatchParam(parser, params[0])) {
            throw new TexError_js_1.default('MismatchUseDef', 'Use of %1 doesn\'t match its definition', name);
        }
        for (var i = 0; i < argCount; i++) {
            args.push(NewcommandUtil_js_1.default.GetParameter(parser, name, params[i + 1]));
        }
        text = ParseUtil_js_1.default.substituteArgs(parser, args, text);
    }
    parser.string = ParseUtil_js_1.default.addArgs(parser, text, parser.string.slice(parser.i));
    parser.i = 0;
    ParseUtil_js_1.default.checkMaxMacros(parser);
};
NewcommandMethods.BeginEnv = function (parser, begin, bdef, edef, n, def) {
    if (begin.getProperty('end') && parser.stack.env['closing'] === begin.getName()) {
        delete parser.stack.env['closing'];
        var rest = parser.string.slice(parser.i);
        parser.string = edef;
        parser.i = 0;
        parser.Parse();
        parser.string = rest;
        parser.i = 0;
        return parser.itemFactory.create('end').setProperty('name', begin.getName());
    }
    if (n) {
        var args = [];
        if (def != null) {
            var optional = parser.GetBrackets('\\begin{' + begin.getName() + '}');
            args.push(optional == null ? def : optional);
        }
        for (var i = args.length; i < n; i++) {
            args.push(parser.GetArgument('\\begin{' + begin.getName() + '}'));
        }
        bdef = ParseUtil_js_1.default.substituteArgs(parser, args, bdef);
        edef = ParseUtil_js_1.default.substituteArgs(parser, [], edef);
    }
    parser.string = ParseUtil_js_1.default.addArgs(parser, bdef, parser.string.slice(parser.i));
    parser.i = 0;
    return parser.itemFactory.create('beginEnv').setProperty('name', begin.getName());
};
NewcommandMethods.Macro = BaseMethods_js_1.default.Macro;
exports["default"] = NewcommandMethods;
//# sourceMappingURL=NewcommandMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandUtil.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/newcommand/NewcommandUtil.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var Symbol_js_1 = __webpack_require__(/*! ../Symbol.js */ "./node_modules/mathjax-full/js/input/tex/Symbol.js");
var NewcommandUtil;
(function (NewcommandUtil) {
    function disassembleSymbol(name, symbol) {
        var newArgs = [name, symbol.char];
        if (symbol.attributes) {
            for (var key in symbol.attributes) {
                newArgs.push(key);
                newArgs.push(symbol.attributes[key]);
            }
        }
        return newArgs;
    }
    NewcommandUtil.disassembleSymbol = disassembleSymbol;
    function assembleSymbol(args) {
        var name = args[0];
        var char = args[1];
        var attrs = {};
        for (var i = 2; i < args.length; i = i + 2) {
            attrs[args[i]] = args[i + 1];
        }
        return new Symbol_js_1.Symbol(name, char, attrs);
    }
    NewcommandUtil.assembleSymbol = assembleSymbol;
    function GetCSname(parser, cmd) {
        var c = parser.GetNext();
        if (c !== '\\') {
            throw new TexError_js_1.default('MissingCS', '%1 must be followed by a control sequence', cmd);
        }
        var cs = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(cmd));
        return cs.substr(1);
    }
    NewcommandUtil.GetCSname = GetCSname;
    function GetCsNameArgument(parser, name) {
        var cs = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));
        if (cs.charAt(0) === '\\') {
            cs = cs.substr(1);
        }
        if (!cs.match(/^(.|[a-z]+)$/i)) {
            throw new TexError_js_1.default('IllegalControlSequenceName', 'Illegal control sequence name for %1', name);
        }
        return cs;
    }
    NewcommandUtil.GetCsNameArgument = GetCsNameArgument;
    function GetArgCount(parser, name) {
        var n = parser.GetBrackets(name);
        if (n) {
            n = ParseUtil_js_1.default.trimSpaces(n);
            if (!n.match(/^[0-9]+$/)) {
                throw new TexError_js_1.default('IllegalParamNumber', 'Illegal number of parameters specified in %1', name);
            }
        }
        return n;
    }
    NewcommandUtil.GetArgCount = GetArgCount;
    function GetTemplate(parser, cmd, cs) {
        var c = parser.GetNext();
        var params = [];
        var n = 0;
        var i = parser.i;
        while (parser.i < parser.string.length) {
            c = parser.GetNext();
            if (c === '#') {
                if (i !== parser.i) {
                    params[n] = parser.string.substr(i, parser.i - i);
                }
                c = parser.string.charAt(++parser.i);
                if (!c.match(/^[1-9]$/)) {
                    throw new TexError_js_1.default('CantUseHash2', 'Illegal use of # in template for %1', cs);
                }
                if (parseInt(c) !== ++n) {
                    throw new TexError_js_1.default('SequentialParam', 'Parameters for %1 must be numbered sequentially', cs);
                }
                i = parser.i + 1;
            }
            else if (c === '{') {
                if (i !== parser.i) {
                    params[n] = parser.string.substr(i, parser.i - i);
                }
                if (params.length > 0) {
                    return [n.toString()].concat(params);
                }
                else {
                    return n;
                }
            }
            parser.i++;
        }
        throw new TexError_js_1.default('MissingReplacementString', 'Missing replacement string for definition of %1', cmd);
    }
    NewcommandUtil.GetTemplate = GetTemplate;
    function GetParameter(parser, name, param) {
        if (param == null) {
            return parser.GetArgument(name);
        }
        var i = parser.i;
        var j = 0;
        var hasBraces = 0;
        while (parser.i < parser.string.length) {
            var c = parser.string.charAt(parser.i);
            if (c === '{') {
                if (parser.i === i) {
                    hasBraces = 1;
                }
                parser.GetArgument(name);
                j = parser.i - i;
            }
            else if (MatchParam(parser, param)) {
                if (hasBraces) {
                    i++;
                    j -= 2;
                }
                return parser.string.substr(i, j);
            }
            else if (c === '\\') {
                parser.i++;
                j++;
                hasBraces = 0;
                var match = parser.string.substr(parser.i).match(/[a-z]+|./i);
                if (match) {
                    parser.i += match[0].length;
                    j = parser.i - i;
                }
            }
            else {
                parser.i++;
                j++;
                hasBraces = 0;
            }
        }
        throw new TexError_js_1.default('RunawayArgument', 'Runaway argument for %1?', name);
    }
    NewcommandUtil.GetParameter = GetParameter;
    function MatchParam(parser, param) {
        if (parser.string.substr(parser.i, param.length) !== param) {
            return 0;
        }
        if (param.match(/\\[a-z]+$/i) &&
            parser.string.charAt(parser.i + param.length).match(/[a-z]/i)) {
            return 0;
        }
        parser.i += param.length;
        return 1;
    }
    NewcommandUtil.MatchParam = MatchParam;
    function addDelimiter(parser, cs, char, attr) {
        var handlers = parser.configuration.handlers;
        var handler = handlers.retrieve(NewcommandUtil.NEW_DELIMITER);
        handler.add(cs, new Symbol_js_1.Symbol(cs, char, attr));
    }
    NewcommandUtil.addDelimiter = addDelimiter;
    function addMacro(parser, cs, func, attr, symbol) {
        if (symbol === void 0) { symbol = ''; }
        var handlers = parser.configuration.handlers;
        var handler = handlers.retrieve(NewcommandUtil.NEW_COMMAND);
        handler.add(cs, new Symbol_js_1.Macro(symbol ? symbol : cs, func, attr));
    }
    NewcommandUtil.addMacro = addMacro;
    function addEnvironment(parser, env, func, attr) {
        var handlers = parser.configuration.handlers;
        var handler = handlers.retrieve(NewcommandUtil.NEW_ENVIRONMENT);
        handler.add(env, new Symbol_js_1.Macro(env, func, attr));
    }
    NewcommandUtil.addEnvironment = addEnvironment;
    NewcommandUtil.NEW_DELIMITER = 'new-Delimiter';
    NewcommandUtil.NEW_COMMAND = 'new-Command';
    NewcommandUtil.NEW_ENVIRONMENT = 'new-Environment';
})(NewcommandUtil || (NewcommandUtil = {}));
exports["default"] = NewcommandUtil;
//# sourceMappingURL=NewcommandUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/noerrors/NoErrorsConfiguration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/noerrors/NoErrorsConfiguration.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoErrorsConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
function noErrors(factory, message, _id, expr) {
    var mtext = factory.create('token', 'mtext', {}, expr.replace(/\n/g, ' '));
    var error = factory.create('node', 'merror', [mtext], { 'data-mjx-error': message, title: message });
    return error;
}
exports.NoErrorsConfiguration = Configuration_js_1.Configuration.create('noerrors', { nodes: { 'error': noErrors } });
//# sourceMappingURL=NoErrorsConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/noundefined/NoUndefinedConfiguration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/noundefined/NoUndefinedConfiguration.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoUndefinedConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
function noUndefined(parser, name) {
    var e_1, _a;
    var textNode = parser.create('text', '\\' + name);
    var options = parser.options.noundefined || {};
    var def = {};
    try {
        for (var _b = __values(['color', 'background', 'size']), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            if (options[id]) {
                def['math' + id] = options[id];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    parser.Push(parser.create('node', 'mtext', [], def, textNode));
}
exports.NoUndefinedConfiguration = Configuration_js_1.Configuration.create('noundefined', {
    fallback: { macro: noUndefined },
    options: {
        noundefined: {
            color: 'red',
            background: '',
            size: ''
        }
    },
    priority: 3
});
//# sourceMappingURL=NoUndefinedConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsConfiguration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/physics/PhysicsConfiguration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PhysicsConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var PhysicsItems_js_1 = __webpack_require__(/*! ./PhysicsItems.js */ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsItems.js");
__webpack_require__(/*! ./PhysicsMappings.js */ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsMappings.js");
exports.PhysicsConfiguration = Configuration_js_1.Configuration.create('physics', {
    handler: {
        macro: [
            'Physics-automatic-bracing-macros',
            'Physics-vector-macros',
            'Physics-vector-mo',
            'Physics-vector-mi',
            'Physics-derivative-macros',
            'Physics-expressions-macros',
            'Physics-quick-quad-macros',
            'Physics-bra-ket-macros',
            'Physics-matrix-macros'
        ],
        character: ['Physics-characters'],
        environment: ['Physics-aux-envs']
    },
    items: (_a = {},
        _a[PhysicsItems_js_1.AutoOpen.prototype.kind] = PhysicsItems_js_1.AutoOpen,
        _a),
    options: {
        physics: {
            italicdiff: false,
            arrowdel: false
        }
    }
});
//# sourceMappingURL=PhysicsConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsItems.js":
/*!************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/physics/PhysicsItems.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoOpen = void 0;
var StackItem_js_1 = __webpack_require__(/*! ../StackItem.js */ "./node_modules/mathjax-full/js/input/tex/StackItem.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var AutoOpen = (function (_super) {
    __extends(AutoOpen, _super);
    function AutoOpen() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.openCount = 0;
        return _this;
    }
    Object.defineProperty(AutoOpen.prototype, "kind", {
        get: function () {
            return 'auto open';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AutoOpen.prototype, "isOpen", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    AutoOpen.prototype.toMml = function () {
        var parser = this.factory.configuration.parser;
        var right = this.getProperty('right');
        if (this.getProperty('smash')) {
            var mml_1 = _super.prototype.toMml.call(this);
            var smash = parser.create('node', 'mpadded', [mml_1], { height: 0, depth: 0 });
            this.Clear();
            this.Push(parser.create('node', 'TeXAtom', [smash]));
        }
        if (right) {
            this.Push(new TexParser_js_1.default(right, parser.stack.env, parser.configuration).mml());
        }
        var mml = ParseUtil_js_1.default.fenced(this.factory.configuration, this.getProperty('open'), _super.prototype.toMml.call(this), this.getProperty('close'), this.getProperty('big'));
        NodeUtil_js_1.default.removeProperties(mml, 'open', 'close', 'texClass');
        return mml;
    };
    AutoOpen.prototype.checkItem = function (item) {
        if (item.isKind('mml') && item.Size() === 1) {
            var mml = item.toMml();
            if (mml.isKind('mo') && mml.getText() === this.getProperty('open')) {
                this.openCount++;
            }
        }
        var close = item.getProperty('autoclose');
        if (close && close === this.getProperty('close') && !this.openCount--) {
            if (this.getProperty('ignore')) {
                this.Clear();
                return [[], true];
            }
            return [[this.toMml()], true];
        }
        return _super.prototype.checkItem.call(this, item);
    };
    AutoOpen.errors = Object.assign(Object.create(StackItem_js_1.BaseItem.errors), {
        'stop': ['ExtraOrMissingDelims', 'Extra open or missing close delimiter']
    });
    return AutoOpen;
}(StackItem_js_1.BaseItem));
exports.AutoOpen = AutoOpen;
//# sourceMappingURL=PhysicsItems.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsMappings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/physics/PhysicsMappings.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var PhysicsMethods_js_1 = __importDefault(__webpack_require__(/*! ./PhysicsMethods.js */ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsMethods.js"));
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var ParseMethods_js_1 = __importDefault(__webpack_require__(/*! ../ParseMethods.js */ "./node_modules/mathjax-full/js/input/tex/ParseMethods.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
new SymbolMap_js_1.CommandMap('Physics-automatic-bracing-macros', {
    'quantity': 'Quantity',
    'qty': 'Quantity',
    'pqty': ['Quantity', '(', ')', true],
    'bqty': ['Quantity', '[', ']', true],
    'vqty': ['Quantity', '|', '|', true],
    'Bqty': ['Quantity', '\\{', '\\}', true],
    'absolutevalue': ['Quantity', '|', '|', true],
    'abs': ['Quantity', '|', '|', true],
    'norm': ['Quantity', '\\|', '\\|', true],
    'evaluated': 'Eval',
    'eval': 'Eval',
    'order': ['Quantity', '(', ')', true, 'O',
        TexConstants_js_1.TexConstant.Variant.CALLIGRAPHIC],
    'commutator': 'Commutator',
    'comm': 'Commutator',
    'anticommutator': ['Commutator', '\\{', '\\}'],
    'acomm': ['Commutator', '\\{', '\\}'],
    'poissonbracket': ['Commutator', '\\{', '\\}'],
    'pb': ['Commutator', '\\{', '\\}']
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.CharacterMap('Physics-vector-mo', ParseMethods_js_1.default.mathchar0mo, {
    dotproduct: ['\u22C5', { mathvariant: TexConstants_js_1.TexConstant.Variant.BOLD }],
    vdot: ['\u22C5', { mathvariant: TexConstants_js_1.TexConstant.Variant.BOLD }],
    crossproduct: '\u00D7',
    cross: '\u00D7',
    cp: '\u00D7',
    gradientnabla: ['\u2207', { mathvariant: TexConstants_js_1.TexConstant.Variant.BOLD }]
});
new SymbolMap_js_1.CharacterMap('Physics-vector-mi', ParseMethods_js_1.default.mathchar0mi, {
    real: ['\u211C', { mathvariant: TexConstants_js_1.TexConstant.Variant.NORMAL }],
    imaginary: ['\u2111', { mathvariant: TexConstants_js_1.TexConstant.Variant.NORMAL }]
});
new SymbolMap_js_1.CommandMap('Physics-vector-macros', {
    'vnabla': 'Vnabla',
    'vectorbold': 'VectorBold',
    'vb': 'VectorBold',
    'vectorarrow': ['StarMacro', 1, '\\vec{\\vb', '{#1}}'],
    'va': ['StarMacro', 1, '\\vec{\\vb', '{#1}}'],
    'vectorunit': ['StarMacro', 1, '\\hat{\\vb', '{#1}}'],
    'vu': ['StarMacro', 1, '\\hat{\\vb', '{#1}}'],
    'gradient': ['OperatorApplication', '\\vnabla', '(', '['],
    'grad': ['OperatorApplication', '\\vnabla', '(', '['],
    'divergence': ['VectorOperator', '\\vnabla\\vdot', '(', '['],
    'div': ['VectorOperator', '\\vnabla\\vdot', '(', '['],
    'curl': ['VectorOperator', '\\vnabla\\crossproduct', '(', '['],
    'laplacian': ['OperatorApplication', '\\nabla^2', '(', '['],
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.CommandMap('Physics-expressions-macros', {
    'sin': 'Expression',
    'sinh': 'Expression',
    'arcsin': 'Expression',
    'asin': 'Expression',
    'cos': 'Expression',
    'cosh': 'Expression',
    'arccos': 'Expression',
    'acos': 'Expression',
    'tan': 'Expression',
    'tanh': 'Expression',
    'arctan': 'Expression',
    'atan': 'Expression',
    'csc': 'Expression',
    'csch': 'Expression',
    'arccsc': 'Expression',
    'acsc': 'Expression',
    'sec': 'Expression',
    'sech': 'Expression',
    'arcsec': 'Expression',
    'asec': 'Expression',
    'cot': 'Expression',
    'coth': 'Expression',
    'arccot': 'Expression',
    'acot': 'Expression',
    'exp': ['Expression', false],
    'log': 'Expression',
    'ln': 'Expression',
    'det': ['Expression', false],
    'Pr': ['Expression', false],
    'tr': ['Expression', false],
    'trace': ['Expression', false, 'tr'],
    'Tr': ['Expression', false],
    'Trace': ['Expression', false, 'Tr'],
    'rank': 'NamedFn',
    'erf': ['Expression', false],
    'Residue': ['Macro', '\\mathrm{Res}'],
    'Res': ['OperatorApplication', '\\Residue', '(', '[', '{'],
    'principalvalue': ['OperatorApplication', '{\\cal P}'],
    'pv': ['OperatorApplication', '{\\cal P}'],
    'PV': ['OperatorApplication', '{\\rm P.V.}'],
    'Re': ['OperatorApplication', '\\mathrm{Re}', '{'],
    'Im': ['OperatorApplication', '\\mathrm{Im}', '{'],
    'sine': ['NamedFn', 'sin'],
    'hypsine': ['NamedFn', 'sinh'],
    'arcsine': ['NamedFn', 'arcsin'],
    'asine': ['NamedFn', 'asin'],
    'cosine': ['NamedFn', 'cos'],
    'hypcosine': ['NamedFn', 'cosh'],
    'arccosine': ['NamedFn', 'arccos'],
    'acosine': ['NamedFn', 'acos'],
    'tangent': ['NamedFn', 'tan'],
    'hyptangent': ['NamedFn', 'tanh'],
    'arctangent': ['NamedFn', 'arctan'],
    'atangent': ['NamedFn', 'atan'],
    'cosecant': ['NamedFn', 'csc'],
    'hypcosecant': ['NamedFn', 'csch'],
    'arccosecant': ['NamedFn', 'arccsc'],
    'acosecant': ['NamedFn', 'acsc'],
    'secant': ['NamedFn', 'sec'],
    'hypsecant': ['NamedFn', 'sech'],
    'arcsecant': ['NamedFn', 'arcsec'],
    'asecant': ['NamedFn', 'asec'],
    'cotangent': ['NamedFn', 'cot'],
    'hypcotangent': ['NamedFn', 'coth'],
    'arccotangent': ['NamedFn', 'arccot'],
    'acotangent': ['NamedFn', 'acot'],
    'exponential': ['NamedFn', 'exp'],
    'logarithm': ['NamedFn', 'log'],
    'naturallogarithm': ['NamedFn', 'ln'],
    'determinant': ['NamedFn', 'det'],
    'Probability': ['NamedFn', 'Pr'],
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.CommandMap('Physics-quick-quad-macros', {
    'qqtext': 'Qqtext',
    'qq': 'Qqtext',
    'qcomma': ['Macro', '\\qqtext*{,}'],
    'qc': ['Macro', '\\qqtext*{,}'],
    'qcc': ['Qqtext', 'c.c.'],
    'qif': ['Qqtext', 'if'],
    'qthen': ['Qqtext', 'then'],
    'qelse': ['Qqtext', 'else'],
    'qotherwise': ['Qqtext', 'otherwise'],
    'qunless': ['Qqtext', 'unless'],
    'qgiven': ['Qqtext', 'given'],
    'qusing': ['Qqtext', 'using'],
    'qassume': ['Qqtext', 'assume'],
    'qsince': ['Qqtext', 'since'],
    'qlet': ['Qqtext', 'let'],
    'qfor': ['Qqtext', 'for'],
    'qall': ['Qqtext', 'all'],
    'qeven': ['Qqtext', 'even'],
    'qodd': ['Qqtext', 'odd'],
    'qinteger': ['Qqtext', 'integer'],
    'qand': ['Qqtext', 'and'],
    'qor': ['Qqtext', 'or'],
    'qas': ['Qqtext', 'as'],
    'qin': ['Qqtext', 'in'],
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.CommandMap('Physics-derivative-macros', {
    'diffd': 'DiffD',
    'flatfrac': ['Macro', '\\left.#1\\middle/#2\\right.', 2],
    'differential': ['Differential', '\\diffd'],
    'dd': ['Differential', '\\diffd'],
    'variation': ['Differential', '\\delta'],
    'var': ['Differential', '\\delta'],
    'derivative': ['Derivative', 2, '\\diffd'],
    'dv': ['Derivative', 2, '\\diffd'],
    'partialderivative': ['Derivative', 3, '\\partial'],
    'pderivative': ['Derivative', 3, '\\partial'],
    'pdv': ['Derivative', 3, '\\partial'],
    'functionalderivative': ['Derivative', 2, '\\delta'],
    'fderivative': ['Derivative', 2, '\\delta'],
    'fdv': ['Derivative', 2, '\\delta'],
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.CommandMap('Physics-bra-ket-macros', {
    'bra': 'Bra',
    'ket': 'Ket',
    'innerproduct': 'BraKet',
    'ip': 'BraKet',
    'braket': 'BraKet',
    'outerproduct': 'KetBra',
    'dyad': 'KetBra',
    'ketbra': 'KetBra',
    'op': 'KetBra',
    'expectationvalue': 'Expectation',
    'expval': 'Expectation',
    'ev': 'Expectation',
    'matrixelement': 'MatrixElement',
    'matrixel': 'MatrixElement',
    'mel': 'MatrixElement',
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.CommandMap('Physics-matrix-macros', {
    'matrixquantity': 'MatrixQuantity',
    'mqty': 'MatrixQuantity',
    'pmqty': ['Macro', '\\mqty(#1)', 1],
    'Pmqty': ['Macro', '\\mqty*(#1)', 1],
    'bmqty': ['Macro', '\\mqty[#1]', 1],
    'vmqty': ['Macro', '\\mqty|#1|', 1],
    'smallmatrixquantity': ['MatrixQuantity', true],
    'smqty': ['MatrixQuantity', true],
    'spmqty': ['Macro', '\\smqty(#1)', 1],
    'sPmqty': ['Macro', '\\smqty*(#1)', 1],
    'sbmqty': ['Macro', '\\smqty[#1]', 1],
    'svmqty': ['Macro', '\\smqty|#1|', 1],
    'matrixdeterminant': ['Macro', '\\vmqty{#1}', 1],
    'mdet': ['Macro', '\\vmqty{#1}', 1],
    'smdet': ['Macro', '\\svmqty{#1}', 1],
    'identitymatrix': 'IdentityMatrix',
    'imat': 'IdentityMatrix',
    'xmatrix': 'XMatrix',
    'xmat': 'XMatrix',
    'zeromatrix': ['Macro', '\\xmat{0}{#1}{#2}', 2],
    'zmat': ['Macro', '\\xmat{0}{#1}{#2}', 2],
    'paulimatrix': 'PauliMatrix',
    'pmat': 'PauliMatrix',
    'diagonalmatrix': 'DiagonalMatrix',
    'dmat': 'DiagonalMatrix',
    'antidiagonalmatrix': ['DiagonalMatrix', true],
    'admat': ['DiagonalMatrix', true]
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.EnvironmentMap('Physics-aux-envs', ParseMethods_js_1.default.environment, {
    smallmatrix: ['Array', null, null, null, 'c', '0.333em', '.2em', 'S', 1]
}, PhysicsMethods_js_1.default);
new SymbolMap_js_1.MacroMap('Physics-characters', {
    '|': ['AutoClose', MmlNode_js_1.TEXCLASS.ORD],
    ')': 'AutoClose',
    ']': 'AutoClose'
}, PhysicsMethods_js_1.default);
//# sourceMappingURL=PhysicsMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/physics/PhysicsMethods.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/physics/PhysicsMethods.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var NodeFactory_js_1 = __webpack_require__(/*! ../NodeFactory.js */ "./node_modules/mathjax-full/js/input/tex/NodeFactory.js");
var PhysicsMethods = {};
var pairs = {
    '(': ')',
    '[': ']',
    '{': '}',
    '|': '|',
};
var biggs = /^(b|B)i(g{1,2})$/;
PhysicsMethods.Quantity = function (parser, name, open, close, arg, named, variant) {
    if (open === void 0) { open = '('; }
    if (close === void 0) { close = ')'; }
    if (arg === void 0) { arg = false; }
    if (named === void 0) { named = ''; }
    if (variant === void 0) { variant = ''; }
    var star = arg ? parser.GetStar() : false;
    var next = parser.GetNext();
    var position = parser.i;
    var big = null;
    if (next === '\\') {
        parser.i++;
        big = parser.GetCS();
        if (!big.match(biggs)) {
            var empty = parser.create('node', 'mrow');
            parser.Push(ParseUtil_js_1.default.fenced(parser.configuration, open, empty, close));
            parser.i = position;
            return;
        }
        next = parser.GetNext();
    }
    var right = pairs[next];
    if (arg && next !== '{') {
        throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);
    }
    if (!right) {
        var empty = parser.create('node', 'mrow');
        parser.Push(ParseUtil_js_1.default.fenced(parser.configuration, open, empty, close));
        parser.i = position;
        return;
    }
    if (named) {
        var mml = parser.create('token', 'mi', { texClass: MmlNode_js_1.TEXCLASS.OP }, named);
        if (variant) {
            NodeUtil_js_1.default.setAttribute(mml, 'mathvariant', variant);
        }
        parser.Push(parser.itemFactory.create('fn', mml));
    }
    if (next === '{') {
        var argument = parser.GetArgument(name);
        next = arg ? open : '\\{';
        right = arg ? close : '\\}';
        argument = star ? next + ' ' + argument + ' ' + right :
            (big ?
                '\\' + big + 'l' + next + ' ' + argument + ' ' + '\\' + big + 'r' + right :
                '\\left' + next + ' ' + argument + ' ' + '\\right' + right);
        parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());
        return;
    }
    if (arg) {
        next = open;
        right = close;
    }
    parser.i++;
    parser.Push(parser.itemFactory.create('auto open')
        .setProperties({ open: next, close: right, big: big }));
};
PhysicsMethods.Eval = function (parser, name) {
    var star = parser.GetStar();
    var next = parser.GetNext();
    if (next === '{') {
        var arg = parser.GetArgument(name);
        var replace = '\\left. ' +
            (star ? '\\smash{' + arg + '}' : arg) +
            ' ' + '\\vphantom{\\int}\\right|';
        parser.string = parser.string.slice(0, parser.i) + replace +
            parser.string.slice(parser.i);
        return;
    }
    if (next === '(' || next === '[') {
        parser.i++;
        parser.Push(parser.itemFactory.create('auto open')
            .setProperties({ open: next, close: '|',
            smash: star, right: '\\vphantom{\\int}' }));
        return;
    }
    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);
};
PhysicsMethods.Commutator = function (parser, name, open, close) {
    if (open === void 0) { open = '['; }
    if (close === void 0) { close = ']'; }
    var star = parser.GetStar();
    var next = parser.GetNext();
    var big = null;
    if (next === '\\') {
        parser.i++;
        big = parser.GetCS();
        if (!big.match(biggs)) {
            throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);
        }
        next = parser.GetNext();
    }
    if (next !== '{') {
        throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);
    }
    var arg1 = parser.GetArgument(name);
    var arg2 = parser.GetArgument(name);
    var argument = arg1 + ',' + arg2;
    argument = star ? open + ' ' + argument + ' ' + close :
        (big ?
            '\\' + big + 'l' + open + ' ' + argument + ' ' + '\\' + big + 'r' + close :
            '\\left' + open + ' ' + argument + ' ' + '\\right' + close);
    parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());
};
var latinCap = [0x41, 0x5A];
var latinSmall = [0x61, 0x7A];
var greekCap = [0x391, 0x3A9];
var greekSmall = [0x3B1, 0x3C9];
var digits = [0x30, 0x39];
function inRange(value, range) {
    return (value >= range[0] && value <= range[1]);
}
function createVectorToken(factory, kind, def, text) {
    var parser = factory.configuration.parser;
    var token = NodeFactory_js_1.NodeFactory.createToken(factory, kind, def, text);
    var code = text.codePointAt(0);
    if (text.length === 1 && !parser.stack.env.font &&
        parser.stack.env.vectorFont &&
        (inRange(code, latinCap) || inRange(code, latinSmall) ||
            inRange(code, greekCap) || inRange(code, digits) ||
            (inRange(code, greekSmall) && parser.stack.env.vectorStar) ||
            NodeUtil_js_1.default.getAttribute(token, 'accent'))) {
        NodeUtil_js_1.default.setAttribute(token, 'mathvariant', parser.stack.env.vectorFont);
    }
    return token;
}
PhysicsMethods.VectorBold = function (parser, name) {
    var star = parser.GetStar();
    var arg = parser.GetArgument(name);
    var oldToken = parser.configuration.nodeFactory.get('token');
    var oldFont = parser.stack.env.font;
    delete parser.stack.env.font;
    parser.configuration.nodeFactory.set('token', createVectorToken);
    parser.stack.env.vectorFont = star ? 'bold-italic' : 'bold';
    parser.stack.env.vectorStar = star;
    var node = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();
    if (oldFont) {
        parser.stack.env.font = oldFont;
    }
    delete parser.stack.env.vectorFont;
    delete parser.stack.env.vectorStar;
    parser.configuration.nodeFactory.set('token', oldToken);
    parser.Push(node);
};
PhysicsMethods.StarMacro = function (parser, name, argcount) {
    var parts = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        parts[_i - 3] = arguments[_i];
    }
    var star = parser.GetStar();
    var args = [];
    if (argcount) {
        for (var i = args.length; i < argcount; i++) {
            args.push(parser.GetArgument(name));
        }
    }
    var macro = parts.join(star ? '*' : '');
    macro = ParseUtil_js_1.default.substituteArgs(parser, args, macro);
    parser.string = ParseUtil_js_1.default.addArgs(parser, macro, parser.string.slice(parser.i));
    parser.i = 0;
    ParseUtil_js_1.default.checkMaxMacros(parser);
};
var vectorApplication = function (parser, kind, name, operator, fences) {
    var op = new TexParser_js_1.default(operator, parser.stack.env, parser.configuration).mml();
    parser.Push(parser.itemFactory.create(kind, op));
    var left = parser.GetNext();
    var right = pairs[left];
    if (!right) {
        return;
    }
    var lfence = '', rfence = '', arg = '';
    var enlarge = fences.indexOf(left) !== -1;
    if (left === '{') {
        arg = parser.GetArgument(name);
        lfence = enlarge ? '\\left\\{' : '';
        rfence = enlarge ? '\\right\\}' : '';
        var macro = lfence + ' ' + arg + ' ' + rfence;
        parser.string = macro + parser.string.slice(parser.i);
        parser.i = 0;
        return;
    }
    if (!enlarge) {
        return;
    }
    parser.i++;
    parser.Push(parser.itemFactory.create('auto open')
        .setProperties({ open: left, close: right }));
};
PhysicsMethods.OperatorApplication = function (parser, name, operator) {
    var fences = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        fences[_i - 3] = arguments[_i];
    }
    vectorApplication(parser, 'fn', name, operator, fences);
};
PhysicsMethods.VectorOperator = function (parser, name, operator) {
    var fences = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        fences[_i - 3] = arguments[_i];
    }
    vectorApplication(parser, 'mml', name, operator, fences);
};
PhysicsMethods.Expression = function (parser, name, opt, id) {
    if (opt === void 0) { opt = true; }
    if (id === void 0) { id = ''; }
    id = id || name.slice(1);
    var exp = opt ? parser.GetBrackets(name) : null;
    var mml = parser.create('token', 'mi', { texClass: MmlNode_js_1.TEXCLASS.OP }, id);
    if (exp) {
        var sup = new TexParser_js_1.default(exp, parser.stack.env, parser.configuration).mml();
        mml = parser.create('node', 'msup', [mml, sup]);
    }
    parser.Push(parser.itemFactory.create('fn', mml));
    if (parser.GetNext() !== '(') {
        return;
    }
    parser.i++;
    parser.Push(parser.itemFactory.create('auto open')
        .setProperties({ open: '(', close: ')' }));
};
PhysicsMethods.Qqtext = function (parser, name, text) {
    var star = parser.GetStar();
    var arg = text ? text : parser.GetArgument(name);
    var replace = (star ? '' : '\\quad') + '\\text{' + arg + '}\\quad ';
    parser.string = parser.string.slice(0, parser.i) + replace +
        parser.string.slice(parser.i);
};
PhysicsMethods.Differential = function (parser, name, op) {
    var optArg = parser.GetBrackets(name);
    var power = optArg != null ? '^{' + optArg + '}' : ' ';
    var parens = parser.GetNext() === '(';
    var braces = parser.GetNext() === '{';
    var macro = op + power;
    if (!(parens || braces)) {
        macro += parser.GetArgument(name, true) || '';
        var mml = new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml();
        parser.Push(mml);
        return;
    }
    if (braces) {
        macro += parser.GetArgument(name);
        var mml = new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml();
        parser.Push(parser.create('node', 'TeXAtom', [mml], { texClass: MmlNode_js_1.TEXCLASS.OP }));
        return;
    }
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
    parser.i++;
    parser.Push(parser.itemFactory.create('auto open')
        .setProperties({ open: '(', close: ')' }));
};
PhysicsMethods.Derivative = function (parser, name, argMax, op) {
    var star = parser.GetStar();
    var optArg = parser.GetBrackets(name);
    var argCounter = 1;
    var args = [];
    args.push(parser.GetArgument(name));
    while (parser.GetNext() === '{' && argCounter < argMax) {
        args.push(parser.GetArgument(name));
        argCounter++;
    }
    var ignore = false;
    var power1 = ' ';
    var power2 = ' ';
    if (argMax > 2 && args.length > 2) {
        power1 = '^{' + (args.length - 1) + '}';
        ignore = true;
    }
    else if (optArg != null) {
        if (argMax > 2 && args.length > 1) {
            ignore = true;
        }
        power1 = '^{' + optArg + '}';
        power2 = power1;
    }
    var frac = star ? '\\flatfrac' : '\\frac';
    var first = args.length > 1 ? args[0] : '';
    var second = args.length > 1 ? args[1] : args[0];
    var rest = '';
    for (var i = 2, arg = void 0; arg = args[i]; i++) {
        rest += op + ' ' + arg;
    }
    var macro = frac + '{' + op + power1 + first + '}' +
        '{' + op + ' ' + second + power2 + ' ' + rest + '}';
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
    if (parser.GetNext() === '(') {
        parser.i++;
        parser.Push(parser.itemFactory.create('auto open')
            .setProperties({ open: '(', close: ')', ignore: ignore }));
    }
};
PhysicsMethods.Bra = function (parser, name) {
    var starBra = parser.GetStar();
    var bra = parser.GetArgument(name);
    var ket = '';
    var hasKet = false;
    var starKet = false;
    if (parser.GetNext() === '\\') {
        var saveI = parser.i;
        parser.i++;
        var cs = parser.GetCS();
        var symbol = parser.lookup('macro', cs);
        if (symbol && symbol.symbol === 'ket') {
            hasKet = true;
            saveI = parser.i;
            starKet = parser.GetStar();
            if (parser.GetNext() === '{') {
                ket = parser.GetArgument(cs, true);
            }
            else {
                parser.i = saveI;
                starKet = false;
            }
        }
        else {
            parser.i = saveI;
        }
    }
    var macro = '';
    if (hasKet) {
        macro = (starBra || starKet) ?
            "\\langle{".concat(bra, "}\\vert{").concat(ket, "}\\rangle") :
            "\\left\\langle{".concat(bra, "}\\middle\\vert{").concat(ket, "}\\right\\rangle");
    }
    else {
        macro = (starBra || starKet) ?
            "\\langle{".concat(bra, "}\\vert") : "\\left\\langle{".concat(bra, "}\\right\\vert{").concat(ket, "}");
    }
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.Ket = function (parser, name) {
    var star = parser.GetStar();
    var ket = parser.GetArgument(name);
    var macro = star ? "\\vert{".concat(ket, "}\\rangle") :
        "\\left\\vert{".concat(ket, "}\\right\\rangle");
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.BraKet = function (parser, name) {
    var star = parser.GetStar();
    var bra = parser.GetArgument(name);
    var ket = null;
    if (parser.GetNext() === '{') {
        ket = parser.GetArgument(name, true);
    }
    var macro = '';
    if (ket == null) {
        macro = star ?
            "\\langle{".concat(bra, "}\\vert{").concat(bra, "}\\rangle") :
            "\\left\\langle{".concat(bra, "}\\middle\\vert{").concat(bra, "}\\right\\rangle");
    }
    else {
        macro = star ?
            "\\langle{".concat(bra, "}\\vert{").concat(ket, "}\\rangle") :
            "\\left\\langle{".concat(bra, "}\\middle\\vert{").concat(ket, "}\\right\\rangle");
    }
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.KetBra = function (parser, name) {
    var star = parser.GetStar();
    var ket = parser.GetArgument(name);
    var bra = null;
    if (parser.GetNext() === '{') {
        bra = parser.GetArgument(name, true);
    }
    var macro = '';
    if (bra == null) {
        macro = star ?
            "\\vert{".concat(ket, "}\\rangle\\!\\langle{").concat(ket, "}\\vert") :
            "\\left\\vert{".concat(ket, "}\\middle\\rangle\\!\\middle\\langle{").concat(ket, "}\\right\\vert");
    }
    else {
        macro = star ?
            "\\vert{".concat(ket, "}\\rangle\\!\\langle{").concat(bra, "}\\vert") :
            "\\left\\vert{".concat(ket, "}\\middle\\rangle\\!\\middle\\langle{").concat(bra, "}\\right\\vert");
    }
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
function outputBraket(_a, star1, star2) {
    var _b = __read(_a, 3), arg1 = _b[0], arg2 = _b[1], arg3 = _b[2];
    return (star1 && star2) ?
        "\\left\\langle{".concat(arg1, "}\\middle\\vert{").concat(arg2, "}\\middle\\vert{").concat(arg3, "}\\right\\rangle") :
        (star1 ? "\\langle{".concat(arg1, "}\\vert{").concat(arg2, "}\\vert{").concat(arg3, "}\\rangle") :
            "\\left\\langle{".concat(arg1, "}\\right\\vert{").concat(arg2, "}\\left\\vert{").concat(arg3, "}\\right\\rangle"));
}
PhysicsMethods.Expectation = function (parser, name) {
    var star1 = parser.GetStar();
    var star2 = star1 && parser.GetStar();
    var arg1 = parser.GetArgument(name);
    var arg2 = null;
    if (parser.GetNext() === '{') {
        arg2 = parser.GetArgument(name, true);
    }
    var macro = (arg1 && arg2) ?
        outputBraket([arg2, arg1, arg2], star1, star2) :
        (star1 ? "\\langle {".concat(arg1, "} \\rangle") :
            "\\left\\langle {".concat(arg1, "} \\right\\rangle"));
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.MatrixElement = function (parser, name) {
    var star1 = parser.GetStar();
    var star2 = star1 && parser.GetStar();
    var arg1 = parser.GetArgument(name);
    var arg2 = parser.GetArgument(name);
    var arg3 = parser.GetArgument(name);
    var macro = outputBraket([arg1, arg2, arg3], star1, star2);
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.MatrixQuantity = function (parser, name, small) {
    var star = parser.GetStar();
    var next = parser.GetNext();
    var array = small ? 'smallmatrix' : 'array';
    var arg = '';
    var open = '';
    var close = '';
    switch (next) {
        case '{':
            arg = parser.GetArgument(name);
            break;
        case '(':
            parser.i++;
            open = star ? '\\lgroup' : '(';
            close = star ? '\\rgroup' : ')';
            arg = parser.GetUpTo(name, ')');
            break;
        case '[':
            parser.i++;
            open = '[';
            close = ']';
            arg = parser.GetUpTo(name, ']');
            break;
        case '|':
            parser.i++;
            open = '|';
            close = '|';
            arg = parser.GetUpTo(name, '|');
            break;
        default:
            open = '(';
            close = ')';
            break;
    }
    var macro = (open ? '\\left' : '') + open +
        '\\begin{' + array + '}{} ' + arg + '\\end{' + array + '}' +
        (open ? '\\right' : '') + close;
    parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.IdentityMatrix = function (parser, name) {
    var arg = parser.GetArgument(name);
    var size = parseInt(arg, 10);
    if (isNaN(size)) {
        throw new TexError_js_1.default('InvalidNumber', 'Invalid number');
    }
    if (size <= 1) {
        parser.string = '1' + parser.string.slice(parser.i);
        parser.i = 0;
        return;
    }
    var zeros = Array(size).fill('0');
    var columns = [];
    for (var i = 0; i < size; i++) {
        var row = zeros.slice();
        row[i] = '1';
        columns.push(row.join(' & '));
    }
    parser.string = columns.join('\\\\ ') + parser.string.slice(parser.i);
    parser.i = 0;
};
PhysicsMethods.XMatrix = function (parser, name) {
    var star = parser.GetStar();
    var arg1 = parser.GetArgument(name);
    var arg2 = parser.GetArgument(name);
    var arg3 = parser.GetArgument(name);
    var n = parseInt(arg2, 10);
    var m = parseInt(arg3, 10);
    if (isNaN(n) || isNaN(m) || m.toString() !== arg3 || n.toString() !== arg2) {
        throw new TexError_js_1.default('InvalidNumber', 'Invalid number');
    }
    n = n < 1 ? 1 : n;
    m = m < 1 ? 1 : m;
    if (!star) {
        var row = Array(m).fill(arg1).join(' & ');
        var matrix_1 = Array(n).fill(row).join('\\\\ ');
        parser.string = matrix_1 + parser.string.slice(parser.i);
        parser.i = 0;
        return;
    }
    var matrix = '';
    if (n === 1 && m === 1) {
        matrix = arg1;
    }
    else if (n === 1) {
        var row = [];
        for (var i = 1; i <= m; i++) {
            row.push("".concat(arg1, "_{").concat(i, "}"));
        }
        matrix = row.join(' & ');
    }
    else if (m === 1) {
        var row = [];
        for (var i = 1; i <= n; i++) {
            row.push("".concat(arg1, "_{").concat(i, "}"));
        }
        matrix = row.join('\\\\ ');
    }
    else {
        var rows = [];
        for (var i = 1; i <= n; i++) {
            var row = [];
            for (var j = 1; j <= m; j++) {
                row.push("".concat(arg1, "_{{").concat(i, "}{").concat(j, "}}"));
            }
            rows.push(row.join(' & '));
        }
        matrix = rows.join('\\\\ ');
    }
    parser.string = matrix + parser.string.slice(parser.i);
    parser.i = 0;
    return;
};
PhysicsMethods.PauliMatrix = function (parser, name) {
    var arg = parser.GetArgument(name);
    var matrix = arg.slice(1);
    switch (arg[0]) {
        case '0':
            matrix += ' 1 & 0\\\\ 0 & 1';
            break;
        case '1':
        case 'x':
            matrix += ' 0 & 1\\\\ 1 & 0';
            break;
        case '2':
        case 'y':
            matrix += ' 0 & -i\\\\ i & 0';
            break;
        case '3':
        case 'z':
            matrix += ' 1 & 0\\\\ 0 & -1';
            break;
        default:
    }
    parser.string = matrix + parser.string.slice(parser.i);
    parser.i = 0;
};
PhysicsMethods.DiagonalMatrix = function (parser, name, anti) {
    if (parser.GetNext() !== '{') {
        return;
    }
    var startI = parser.i;
    parser.GetArgument(name);
    var endI = parser.i;
    parser.i = startI + 1;
    var elements = [];
    var element = '';
    var currentI = parser.i;
    while (currentI < endI) {
        try {
            element = parser.GetUpTo(name, ',');
        }
        catch (e) {
            parser.i = endI;
            elements.push(parser.string.slice(currentI, endI - 1));
            break;
        }
        if (parser.i >= endI) {
            elements.push(parser.string.slice(currentI, endI));
            break;
        }
        currentI = parser.i;
        elements.push(element);
    }
    parser.string = makeDiagMatrix(elements, anti) + parser.string.slice(endI);
    parser.i = 0;
};
function makeDiagMatrix(elements, anti) {
    var length = elements.length;
    var matrix = [];
    for (var i = 0; i < length; i++) {
        matrix.push(Array(anti ? length - i : i + 1).join('&') +
            '\\mqty{' + elements[i] + '}');
    }
    return matrix.join('\\\\ ');
}
PhysicsMethods.AutoClose = function (parser, fence, _texclass) {
    var mo = parser.create('token', 'mo', { stretchy: false }, fence);
    var item = parser.itemFactory.create('mml', mo).
        setProperties({ autoclose: fence });
    parser.Push(item);
};
PhysicsMethods.Vnabla = function (parser, _name) {
    var argument = parser.options.physics.arrowdel ?
        '\\vec{\\gradientnabla}' : '{\\gradientnabla}';
    return parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.DiffD = function (parser, _name) {
    var argument = parser.options.physics.italicdiff ? 'd' : '{\\rm d}';
    return parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());
};
PhysicsMethods.Macro = BaseMethods_js_1.default.Macro;
PhysicsMethods.NamedFn = BaseMethods_js_1.default.NamedFn;
PhysicsMethods.Array = BaseMethods_js_1.default.Array;
exports["default"] = PhysicsMethods;
//# sourceMappingURL=PhysicsMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/setoptions/SetOptionsConfiguration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/setoptions/SetOptionsConfiguration.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetOptionsConfiguration = exports.SetOptionsUtil = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var Symbol_js_1 = __webpack_require__(/*! ../Symbol.js */ "./node_modules/mathjax-full/js/input/tex/Symbol.js");
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
exports.SetOptionsUtil = {
    filterPackage: function (parser, extension) {
        if (extension !== 'tex' && !Configuration_js_1.ConfigurationHandler.get(extension)) {
            throw new TexError_js_1.default('NotAPackage', 'Not a defined package: %1', extension);
        }
        var config = parser.options.setoptions;
        var options = config.allowOptions[extension];
        if ((options === undefined && !config.allowPackageDefault) || options === false) {
            throw new TexError_js_1.default('PackageNotSettable', 'Options can\'t be set for package "%1"', extension);
        }
        return true;
    },
    filterOption: function (parser, extension, option) {
        var _a;
        var config = parser.options.setoptions;
        var options = config.allowOptions[extension] || {};
        var allow = (options.hasOwnProperty(option) && !(0, Options_js_1.isObject)(options[option]) ? options[option] : null);
        if (allow === false || (allow === null && !config.allowOptionsDefault)) {
            throw new TexError_js_1.default('OptionNotSettable', 'Option "%1" is not allowed to be set', option);
        }
        if (!((_a = (extension === 'tex' ? parser.options : parser.options[extension])) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(option))) {
            if (extension === 'tex') {
                throw new TexError_js_1.default('InvalidTexOption', 'Invalid TeX option "%1"', option);
            }
            else {
                throw new TexError_js_1.default('InvalidOptionKey', 'Invalid option "%1" for package "%2"', option, extension);
            }
        }
        return true;
    },
    filterValue: function (_parser, _extension, _option, value) {
        return value;
    }
};
var setOptionsMap = new SymbolMap_js_1.CommandMap('setoptions', {
    setOptions: 'SetOptions'
}, {
    SetOptions: function (parser, name) {
        var e_1, _a;
        var extension = parser.GetBrackets(name) || 'tex';
        var options = ParseUtil_js_1.default.keyvalOptions(parser.GetArgument(name));
        var config = parser.options.setoptions;
        if (!config.filterPackage(parser, extension))
            return;
        try {
            for (var _b = __values(Object.keys(options)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (config.filterOption(parser, extension, key)) {
                    (extension === 'tex' ? parser.options : parser.options[extension])[key] =
                        config.filterValue(parser, extension, key, options[key]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
});
function setoptionsConfig(_config, jax) {
    var require = jax.parseOptions.handlers.get('macro').lookup('require');
    if (require) {
        setOptionsMap.add('Require', new Symbol_js_1.Macro('Require', require._func));
        setOptionsMap.add('require', new Symbol_js_1.Macro('require', BaseMethods_js_1.default.Macro, ['\\Require{#2}\\setOptions[#2]{#1}', 2, '']));
    }
}
exports.SetOptionsConfiguration = Configuration_js_1.Configuration.create('setoptions', {
    handler: { macro: ['setoptions'] },
    config: setoptionsConfig,
    priority: 3,
    options: {
        setoptions: {
            filterPackage: exports.SetOptionsUtil.filterPackage,
            filterOption: exports.SetOptionsUtil.filterOption,
            filterValue: exports.SetOptionsUtil.filterValue,
            allowPackageDefault: true,
            allowOptionsDefault: true,
            allowOptions: (0, Options_js_1.expandable)({
                tex: {
                    FindTeX: false,
                    formatError: false,
                    package: false,
                    baseURL: false,
                    tags: false,
                    maxBuffer: false,
                    maxMaxros: false,
                    macros: false,
                    environments: false
                },
                setoptions: false,
                autoload: false,
                require: false,
                configmacros: false,
                tagformat: false
            })
        }
    }
});
//# sourceMappingURL=SetOptionsConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/tagformat/TagFormatConfiguration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/tagformat/TagFormatConfiguration.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagFormatConfiguration = exports.tagformatConfig = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var Tags_js_1 = __webpack_require__(/*! ../Tags.js */ "./node_modules/mathjax-full/js/input/tex/Tags.js");
var tagID = 0;
function tagformatConfig(config, jax) {
    var tags = jax.parseOptions.options.tags;
    if (tags !== 'base' && config.tags.hasOwnProperty(tags)) {
        Tags_js_1.TagsFactory.add(tags, config.tags[tags]);
    }
    var TagClass = Tags_js_1.TagsFactory.create(jax.parseOptions.options.tags).constructor;
    var TagFormat = (function (_super) {
        __extends(TagFormat, _super);
        function TagFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TagFormat.prototype.formatNumber = function (n) {
            return jax.parseOptions.options.tagformat.number(n);
        };
        TagFormat.prototype.formatTag = function (tag) {
            return jax.parseOptions.options.tagformat.tag(tag);
        };
        TagFormat.prototype.formatId = function (id) {
            return jax.parseOptions.options.tagformat.id(id);
        };
        TagFormat.prototype.formatUrl = function (id, base) {
            return jax.parseOptions.options.tagformat.url(id, base);
        };
        return TagFormat;
    }(TagClass));
    tagID++;
    var tagName = 'configTags-' + tagID;
    Tags_js_1.TagsFactory.add(tagName, TagFormat);
    jax.parseOptions.options.tags = tagName;
}
exports.tagformatConfig = tagformatConfig;
exports.TagFormatConfiguration = Configuration_js_1.Configuration.create('tagformat', {
    config: [tagformatConfig, 10],
    options: {
        tagformat: {
            number: function (n) { return n.toString(); },
            tag: function (tag) { return '(' + tag + ')'; },
            id: function (id) { return 'mjx-eqn:' + id.replace(/\s/g, '_'); },
            url: function (id, base) { return base + '#' + encodeURIComponent(id); },
        }
    }
});
//# sourceMappingURL=TagFormatConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/textcomp/TextcompConfiguration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/textcomp/TextcompConfiguration.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextcompConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
__webpack_require__(/*! ./TextcompMappings.js */ "./node_modules/mathjax-full/js/input/tex/textcomp/TextcompMappings.js");
exports.TextcompConfiguration = Configuration_js_1.Configuration.create('textcomp', {
    handler: { macro: ['textcomp-macros'] }
});
//# sourceMappingURL=TextcompConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/textcomp/TextcompMappings.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/textcomp/TextcompMappings.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var TextMacrosMethods_js_1 = __webpack_require__(/*! ../textmacros/TextMacrosMethods.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMethods.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var TextParser_js_1 = __webpack_require__(/*! ../textmacros/TextParser.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextParser.js");
new SymbolMap_js_1.CommandMap('textcomp-macros', {
    'textasciicircum': ['Insert', '\u005E'],
    'textasciitilde': ['Insert', '\u007E'],
    'textasteriskcentered': ['Insert', '\u002A'],
    'textbackslash': ['Insert', '\u005C'],
    'textbar': ['Insert', '\u007C'],
    'textbraceleft': ['Insert', '\u007B'],
    'textbraceright': ['Insert', '\u007D'],
    'textbullet': ['Insert', '\u2022'],
    'textdagger': ['Insert', '\u2020'],
    'textdaggerdbl': ['Insert', '\u2021'],
    'textellipsis': ['Insert', '\u2026'],
    'textemdash': ['Insert', '\u2014'],
    'textendash': ['Insert', '\u2013'],
    'textexclamdown': ['Insert', '\u00A1'],
    'textgreater': ['Insert', '\u003E'],
    'textless': ['Insert', '\u003C'],
    'textordfeminine': ['Insert', '\u00AA'],
    'textordmasculine': ['Insert', '\u00BA'],
    'textparagraph': ['Insert', '\u00B6'],
    'textperiodcentered': ['Insert', '\u00B7'],
    'textquestiondown': ['Insert', '\u00BF'],
    'textquotedblleft': ['Insert', '\u201C'],
    'textquotedblright': ['Insert', '\u201D'],
    'textquoteleft': ['Insert', '\u2018'],
    'textquoteright': ['Insert', '\u2019'],
    'textsection': ['Insert', '\u00A7'],
    'textunderscore': ['Insert', '\u005F'],
    'textvisiblespace': ['Insert', '\u2423'],
    'textacutedbl': ['Insert', '\u02DD'],
    'textasciiacute': ['Insert', '\u00B4'],
    'textasciibreve': ['Insert', '\u02D8'],
    'textasciicaron': ['Insert', '\u02C7'],
    'textasciidieresis': ['Insert', '\u00A8'],
    'textasciimacron': ['Insert', '\u00AF'],
    'textgravedbl': ['Insert', '\u02F5'],
    'texttildelow': ['Insert', '\u02F7'],
    'textbaht': ['Insert', '\u0E3F'],
    'textcent': ['Insert', '\u00A2'],
    'textcolonmonetary': ['Insert', '\u20A1'],
    'textcurrency': ['Insert', '\u00A4'],
    'textdollar': ['Insert', '\u0024'],
    'textdong': ['Insert', '\u20AB'],
    'texteuro': ['Insert', '\u20AC'],
    'textflorin': ['Insert', '\u0192'],
    'textguarani': ['Insert', '\u20B2'],
    'textlira': ['Insert', '\u20A4'],
    'textnaira': ['Insert', '\u20A6'],
    'textpeso': ['Insert', '\u20B1'],
    'textsterling': ['Insert', '\u00A3'],
    'textwon': ['Insert', '\u20A9'],
    'textyen': ['Insert', '\u00A5'],
    'textcircledP': ['Insert', '\u2117'],
    'textcompwordmark': ['Insert', '\u200C'],
    'textcopyleft': ['Insert', "\uD83C\uDD2F"],
    'textcopyright': ['Insert', '\u00A9'],
    'textregistered': ['Insert', '\u00AE'],
    'textservicemark': ['Insert', '\u2120'],
    'texttrademark': ['Insert', '\u2122'],
    'textbardbl': ['Insert', '\u2016'],
    'textbigcircle': ['Insert', '\u25EF'],
    'textblank': ['Insert', '\u2422'],
    'textbrokenbar': ['Insert', '\u00A6'],
    'textdiscount': ['Insert', '\u2052'],
    'textestimated': ['Insert', '\u212E'],
    'textinterrobang': ['Insert', '\u203D'],
    'textinterrobangdown': ['Insert', '\u2E18'],
    'textmusicalnote': ['Insert', '\u266A'],
    'textnumero': ['Insert', '\u2116'],
    'textopenbullet': ['Insert', '\u25E6'],
    'textpertenthousand': ['Insert', '\u2031'],
    'textperthousand': ['Insert', '\u2030'],
    'textrecipe': ['Insert', '\u211E'],
    'textreferencemark': ['Insert', '\u203B'],
    'textlangle': ['Insert', '\u2329'],
    'textrangle': ['Insert', '\u232A'],
    'textlbrackdbl': ['Insert', '\u27E6'],
    'textrbrackdbl': ['Insert', '\u27E7'],
    'textlquill': ['Insert', '\u2045'],
    'textrquill': ['Insert', '\u2046'],
    'textcelsius': ['Insert', '\u2103'],
    'textdegree': ['Insert', '\u00B0'],
    'textdiv': ['Insert', '\u00F7'],
    'textdownarrow': ['Insert', '\u2193'],
    'textfractionsolidus': ['Insert', '\u2044'],
    'textleftarrow': ['Insert', '\u2190'],
    'textlnot': ['Insert', '\u00AC'],
    'textmho': ['Insert', '\u2127'],
    'textminus': ['Insert', '\u2212'],
    'textmu': ['Insert', '\u00B5'],
    'textohm': ['Insert', '\u2126'],
    'textonehalf': ['Insert', '\u00BD'],
    'textonequarter': ['Insert', '\u00BC'],
    'textonesuperior': ['Insert', '\u00B9'],
    'textpm': ['Insert', '\u00B1'],
    'textrightarrow': ['Insert', '\u2192'],
    'textsurd': ['Insert', '\u221A'],
    'textthreequarters': ['Insert', '\u00BE'],
    'textthreesuperior': ['Insert', '\u00B3'],
    'texttimes': ['Insert', '\u00D7'],
    'texttwosuperior': ['Insert', '\u00B2'],
    'textuparrow': ['Insert', '\u2191'],
    'textborn': ['Insert', '\u002A'],
    'textdied': ['Insert', '\u2020'],
    'textdivorced': ['Insert', '\u26AE'],
    'textmarried': ['Insert', '\u26AD'],
    'textcentoldstyle': ['Insert', '\u00A2', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textdollaroldstyle': ['Insert', '\u0024', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textzerooldstyle': ['Insert', '0', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textoneoldstyle': ['Insert', '1', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'texttwooldstyle': ['Insert', '2', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textthreeoldstyle': ['Insert', '3', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textfouroldstyle': ['Insert', '4', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textfiveoldstyle': ['Insert', '5', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textsixoldstyle': ['Insert', '6', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textsevenoldstyle': ['Insert', '7', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'texteightoldstyle': ['Insert', '8', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    'textnineoldstyle': ['Insert', '9', TexConstants_js_1.TexConstant.Variant.OLDSTYLE]
}, {
    Insert: function (parser, name, c, font) {
        if (parser instanceof TextParser_js_1.TextParser) {
            if (!font) {
                TextMacrosMethods_js_1.TextMacrosMethods.Insert(parser, name, c);
                return;
            }
            parser.saveText();
        }
        parser.Push(ParseUtil_js_1.default.internalText(parser, c, font ? { mathvariant: font } : {}));
    }
});
//# sourceMappingURL=TextcompMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosConfiguration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosConfiguration.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextMacrosConfiguration = exports.TextBaseConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var ParseOptions_js_1 = __importDefault(__webpack_require__(/*! ../ParseOptions.js */ "./node_modules/mathjax-full/js/input/tex/ParseOptions.js"));
var Tags_js_1 = __webpack_require__(/*! ../Tags.js */ "./node_modules/mathjax-full/js/input/tex/Tags.js");
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var TextParser_js_1 = __webpack_require__(/*! ./TextParser.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextParser.js");
var TextMacrosMethods_js_1 = __webpack_require__(/*! ./TextMacrosMethods.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMethods.js");
__webpack_require__(/*! ./TextMacrosMappings.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMappings.js");
exports.TextBaseConfiguration = Configuration_js_1.Configuration.create('text-base', {
    parser: 'text',
    handler: {
        character: ['command', 'text-special'],
        macro: ['text-macros']
    },
    fallback: {
        character: function (parser, c) {
            parser.text += c;
        },
        macro: function (parser, name) {
            var texParser = parser.texParser;
            var macro = texParser.lookup('macro', name);
            if (macro && macro._func !== TextMacrosMethods_js_1.TextMacrosMethods.Macro) {
                parser.Error('MathMacro', '%1 is only supported in math mode', '\\' + name);
            }
            texParser.parse('macro', [parser, name]);
        }
    },
    items: (_a = {},
        _a[BaseItems_js_1.StartItem.prototype.kind] = BaseItems_js_1.StartItem,
        _a[BaseItems_js_1.StopItem.prototype.kind] = BaseItems_js_1.StopItem,
        _a[BaseItems_js_1.MmlItem.prototype.kind] = BaseItems_js_1.MmlItem,
        _a[BaseItems_js_1.StyleItem.prototype.kind] = BaseItems_js_1.StyleItem,
        _a)
});
function internalMath(parser, text, level, mathvariant) {
    var config = parser.configuration.packageData.get('textmacros');
    if (!(parser instanceof TextParser_js_1.TextParser)) {
        config.texParser = parser;
    }
    return [(new TextParser_js_1.TextParser(text, mathvariant ? { mathvariant: mathvariant } : {}, config.parseOptions, level)).mml()];
}
exports.TextMacrosConfiguration = Configuration_js_1.Configuration.create('textmacros', {
    config: function (_config, jax) {
        var textConf = new Configuration_js_1.ParserConfiguration(jax.parseOptions.options.textmacros.packages, ['tex', 'text']);
        textConf.init();
        var parseOptions = new ParseOptions_js_1.default(textConf, []);
        parseOptions.options = jax.parseOptions.options;
        textConf.config(jax);
        Tags_js_1.TagsFactory.addTags(textConf.tags);
        parseOptions.tags = Tags_js_1.TagsFactory.getDefault();
        parseOptions.tags.configuration = parseOptions;
        parseOptions.packageData = jax.parseOptions.packageData;
        parseOptions.packageData.set('textmacros', { parseOptions: parseOptions, jax: jax, texParser: null });
        parseOptions.options.internalMath = internalMath;
    },
    preprocessors: [function (data) {
            var config = data.data.packageData.get('textmacros');
            config.parseOptions.nodeFactory.setMmlFactory(config.jax.mmlFactory);
        }],
    options: {
        textmacros: {
            packages: ['text-base']
        }
    }
});
//# sourceMappingURL=TextMacrosConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMappings.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMappings.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var TextMacrosMethods_js_1 = __webpack_require__(/*! ./TextMacrosMethods.js */ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMethods.js");
var lengths_js_1 = __webpack_require__(/*! ../../../util/lengths.js */ "./node_modules/mathjax-full/js/util/lengths.js");
new SymbolMap_js_1.MacroMap('text-special', {
    '$': 'Math',
    '%': 'Comment',
    '^': 'MathModeOnly',
    '_': 'MathModeOnly',
    '&': 'Misplaced',
    '#': 'Misplaced',
    '~': 'Tilde',
    ' ': 'Space',
    '\t': 'Space',
    '\r': 'Space',
    '\n': 'Space',
    '\u00A0': 'Tilde',
    '{': 'OpenBrace',
    '}': 'CloseBrace',
    '`': 'OpenQuote',
    '\'': 'CloseQuote'
}, TextMacrosMethods_js_1.TextMacrosMethods);
new SymbolMap_js_1.CommandMap('text-macros', {
    '(': 'Math',
    '$': 'SelfQuote',
    '_': 'SelfQuote',
    '%': 'SelfQuote',
    '{': 'SelfQuote',
    '}': 'SelfQuote',
    ' ': 'SelfQuote',
    '&': 'SelfQuote',
    '#': 'SelfQuote',
    '\\': 'SelfQuote',
    '\'': ['Accent', '\u00B4'],
    '\u2019': ['Accent', '\u00B4'],
    '`': ['Accent', '\u0060'],
    '\u2018': ['Accent', '\u0060'],
    '^': ['Accent', '^'],
    '\"': ['Accent', '\u00A8'],
    '~': ['Accent', '~'],
    '=': ['Accent', '\u00AF'],
    '.': ['Accent', '\u02D9'],
    'u': ['Accent', '\u02D8'],
    'v': ['Accent', '\u02C7'],
    emph: 'Emph',
    rm: ['SetFont', TexConstants_js_1.TexConstant.Variant.NORMAL],
    mit: ['SetFont', TexConstants_js_1.TexConstant.Variant.ITALIC],
    oldstyle: ['SetFont', TexConstants_js_1.TexConstant.Variant.OLDSTYLE],
    cal: ['SetFont', TexConstants_js_1.TexConstant.Variant.CALLIGRAPHIC],
    it: ['SetFont', '-tex-mathit'],
    bf: ['SetFont', TexConstants_js_1.TexConstant.Variant.BOLD],
    bbFont: ['SetFont', TexConstants_js_1.TexConstant.Variant.DOUBLESTRUCK],
    scr: ['SetFont', TexConstants_js_1.TexConstant.Variant.SCRIPT],
    frak: ['SetFont', TexConstants_js_1.TexConstant.Variant.FRAKTUR],
    sf: ['SetFont', TexConstants_js_1.TexConstant.Variant.SANSSERIF],
    tt: ['SetFont', TexConstants_js_1.TexConstant.Variant.MONOSPACE],
    tiny: ['SetSize', 0.5],
    Tiny: ['SetSize', 0.6],
    scriptsize: ['SetSize', 0.7],
    small: ['SetSize', 0.85],
    normalsize: ['SetSize', 1.0],
    large: ['SetSize', 1.2],
    Large: ['SetSize', 1.44],
    LARGE: ['SetSize', 1.73],
    huge: ['SetSize', 2.07],
    Huge: ['SetSize', 2.49],
    Bbb: ['Macro', '{\\bbFont #1}', 1],
    textnormal: ['Macro', '{\\rm #1}', 1],
    textup: ['Macro', '{\\rm #1}', 1],
    textrm: ['Macro', '{\\rm #1}', 1],
    textit: ['Macro', '{\\it #1}', 1],
    textbf: ['Macro', '{\\bf #1}', 1],
    textsf: ['Macro', '{\\sf #1}', 1],
    texttt: ['Macro', '{\\tt #1}', 1],
    dagger: ['Insert', '\u2020'],
    ddagger: ['Insert', '\u2021'],
    S: ['Insert', '\u00A7'],
    ',': ['Spacer', lengths_js_1.MATHSPACE.thinmathspace],
    ':': ['Spacer', lengths_js_1.MATHSPACE.mediummathspace],
    '>': ['Spacer', lengths_js_1.MATHSPACE.mediummathspace],
    ';': ['Spacer', lengths_js_1.MATHSPACE.thickmathspace],
    '!': ['Spacer', lengths_js_1.MATHSPACE.negativethinmathspace],
    enspace: ['Spacer', .5],
    quad: ['Spacer', 1],
    qquad: ['Spacer', 2],
    thinspace: ['Spacer', lengths_js_1.MATHSPACE.thinmathspace],
    negthinspace: ['Spacer', lengths_js_1.MATHSPACE.negativethinmathspace],
    hskip: 'Hskip',
    hspace: 'Hskip',
    kern: 'Hskip',
    mskip: 'Hskip',
    mspace: 'Hskip',
    mkern: 'Hskip',
    rule: 'rule',
    Rule: ['Rule'],
    Space: ['Rule', 'blank'],
    color: 'CheckAutoload',
    textcolor: 'CheckAutoload',
    colorbox: 'CheckAutoload',
    fcolorbox: 'CheckAutoload',
    href: 'CheckAutoload',
    style: 'CheckAutoload',
    class: 'CheckAutoload',
    cssId: 'CheckAutoload',
    unicode: 'CheckAutoload',
    ref: ['HandleRef', false],
    eqref: ['HandleRef', true],
}, TextMacrosMethods_js_1.TextMacrosMethods);
//# sourceMappingURL=TextMacrosMappings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMethods.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/textmacros/TextMacrosMethods.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextMacrosMethods = void 0;
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var Retries_js_1 = __webpack_require__(/*! ../../../util/Retries.js */ "./node_modules/mathjax-full/js/util/Retries.js");
var BaseMethods_js_1 = __importDefault(__webpack_require__(/*! ../base/BaseMethods.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseMethods.js"));
exports.TextMacrosMethods = {
    Comment: function (parser, _c) {
        while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\n') {
            parser.i++;
        }
        parser.i++;
    },
    Math: function (parser, open) {
        parser.saveText();
        var i = parser.i;
        var j, c;
        var braces = 0;
        while ((c = parser.GetNext())) {
            j = parser.i++;
            switch (c) {
                case '\\':
                    var cs = parser.GetCS();
                    if (cs === ')')
                        c = '\\(';
                case '$':
                    if (braces === 0 && open === c) {
                        var config = parser.texParser.configuration;
                        var mml = (new TexParser_js_1.default(parser.string.substr(i, j - i), parser.stack.env, config)).mml();
                        parser.PushMath(mml);
                        return;
                    }
                    break;
                case '{':
                    braces++;
                    break;
                case '}':
                    if (braces === 0) {
                        parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
                    }
                    braces--;
                    break;
            }
        }
        parser.Error('MathNotTerminated', 'Math-mode is not properly terminated');
    },
    MathModeOnly: function (parser, c) {
        parser.Error('MathModeOnly', '\'%1\' allowed only in math mode', c);
    },
    Misplaced: function (parser, c) {
        parser.Error('Misplaced', '\'%1\' can not be used here', c);
    },
    OpenBrace: function (parser, _c) {
        var env = parser.stack.env;
        parser.envStack.push(env);
        parser.stack.env = Object.assign({}, env);
    },
    CloseBrace: function (parser, _c) {
        if (parser.envStack.length) {
            parser.saveText();
            parser.stack.env = parser.envStack.pop();
        }
        else {
            parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
        }
    },
    OpenQuote: function (parser, c) {
        if (parser.string.charAt(parser.i) === c) {
            parser.text += '\u201C';
            parser.i++;
        }
        else {
            parser.text += '\u2018';
        }
    },
    CloseQuote: function (parser, c) {
        if (parser.string.charAt(parser.i) === c) {
            parser.text += '\u201D';
            parser.i++;
        }
        else {
            parser.text += '\u2019';
        }
    },
    Tilde: function (parser, _c) {
        parser.text += '\u00A0';
    },
    Space: function (parser, _c) {
        parser.text += ' ';
        while (parser.GetNext().match(/\s/))
            parser.i++;
    },
    SelfQuote: function (parser, name) {
        parser.text += name.substr(1);
    },
    Insert: function (parser, _name, c) {
        parser.text += c;
    },
    Accent: function (parser, name, c) {
        var base = parser.ParseArg(name);
        var accent = parser.create('token', 'mo', {}, c);
        parser.addAttributes(accent);
        parser.Push(parser.create('node', 'mover', [base, accent]));
    },
    Emph: function (parser, name) {
        var variant = (parser.stack.env.mathvariant === '-tex-mathit' ? 'normal' : '-tex-mathit');
        parser.Push(parser.ParseTextArg(name, { mathvariant: variant }));
    },
    SetFont: function (parser, _name, variant) {
        parser.saveText();
        parser.stack.env.mathvariant = variant;
    },
    SetSize: function (parser, _name, size) {
        parser.saveText();
        parser.stack.env.mathsize = size;
    },
    CheckAutoload: function (parser, name) {
        var autoload = parser.configuration.packageData.get('autoload');
        var texParser = parser.texParser;
        name = name.slice(1);
        var macro = texParser.lookup('macro', name);
        if (!macro || (autoload && macro._func === autoload.Autoload)) {
            texParser.parse('macro', [texParser, name]);
            if (!macro)
                return;
            (0, Retries_js_1.retryAfter)(Promise.resolve());
        }
        texParser.parse('macro', [parser, name]);
    },
    Macro: BaseMethods_js_1.default.Macro,
    Spacer: BaseMethods_js_1.default.Spacer,
    Hskip: BaseMethods_js_1.default.Hskip,
    rule: BaseMethods_js_1.default.rule,
    Rule: BaseMethods_js_1.default.Rule,
    HandleRef: BaseMethods_js_1.default.HandleRef
};
//# sourceMappingURL=TextMacrosMethods.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/textmacros/TextParser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/textmacros/TextParser.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextParser = void 0;
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ../TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var BaseItems_js_1 = __webpack_require__(/*! ../base/BaseItems.js */ "./node_modules/mathjax-full/js/input/tex/base/BaseItems.js");
var TextParser = (function (_super) {
    __extends(TextParser, _super);
    function TextParser(text, env, configuration, level) {
        var _this = _super.call(this, text, env, configuration) || this;
        _this.level = level;
        return _this;
    }
    Object.defineProperty(TextParser.prototype, "texParser", {
        get: function () {
            return this.configuration.packageData.get('textmacros').texParser;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextParser.prototype, "tags", {
        get: function () {
            return this.texParser.tags;
        },
        enumerable: false,
        configurable: true
    });
    TextParser.prototype.mml = function () {
        return (this.level != null ?
            this.create('node', 'mstyle', this.nodes, { displaystyle: false, scriptlevel: this.level }) :
            this.nodes.length === 1 ? this.nodes[0] : this.create('node', 'mrow', this.nodes));
    };
    TextParser.prototype.Parse = function () {
        this.text = '';
        this.nodes = [];
        this.envStack = [];
        _super.prototype.Parse.call(this);
    };
    TextParser.prototype.saveText = function () {
        if (this.text) {
            var mathvariant = this.stack.env.mathvariant;
            var text = ParseUtil_js_1.default.internalText(this, this.text, mathvariant ? { mathvariant: mathvariant } : {});
            this.text = '';
            this.Push(text);
        }
    };
    TextParser.prototype.Push = function (mml) {
        if (this.text) {
            this.saveText();
        }
        if (mml instanceof BaseItems_js_1.StopItem) {
            return _super.prototype.Push.call(this, mml);
        }
        if (mml instanceof BaseItems_js_1.StyleItem) {
            this.stack.env.mathcolor = this.stack.env.color;
            return;
        }
        if (mml instanceof MmlNode_js_1.AbstractMmlNode) {
            this.addAttributes(mml);
            this.nodes.push(mml);
        }
    };
    TextParser.prototype.PushMath = function (mml) {
        var e_1, _a;
        var env = this.stack.env;
        if (!mml.isKind('TeXAtom')) {
            mml = this.create('node', 'TeXAtom', [mml]);
        }
        try {
            for (var _b = __values(['mathsize', 'mathcolor']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_1 = _c.value;
                if (env[name_1] && !mml.attributes.getExplicit(name_1)) {
                    if (!mml.isToken && !mml.isKind('mstyle')) {
                        mml = this.create('node', 'mstyle', [mml]);
                    }
                    NodeUtil_js_1.default.setAttribute(mml, name_1, env[name_1]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (mml.isInferred) {
            mml = this.create('node', 'mrow', mml.childNodes);
        }
        this.nodes.push(mml);
    };
    TextParser.prototype.addAttributes = function (mml) {
        var e_2, _a;
        var env = this.stack.env;
        if (!mml.isToken)
            return;
        try {
            for (var _b = __values(['mathsize', 'mathcolor', 'mathvariant']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_2 = _c.value;
                if (env[name_2] && !mml.attributes.getExplicit(name_2)) {
                    NodeUtil_js_1.default.setAttribute(mml, name_2, env[name_2]);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    TextParser.prototype.ParseTextArg = function (name, env) {
        var text = this.GetArgument(name);
        env = Object.assign(Object.assign({}, this.stack.env), env);
        return (new TextParser(text, env, this.configuration)).mml();
    };
    TextParser.prototype.ParseArg = function (name) {
        return (new TextParser(this.GetArgument(name), this.stack.env, this.configuration)).mml();
    };
    TextParser.prototype.Error = function (id, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        throw new (TexError_js_1.default.bind.apply(TexError_js_1.default, __spreadArray([void 0, id, message], __read(args), false)))();
    };
    return TextParser;
}(TexParser_js_1.default));
exports.TextParser = TextParser;
//# sourceMappingURL=TextParser.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/unicode/UnicodeConfiguration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/unicode/UnicodeConfiguration.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnicodeConfiguration = exports.UnicodeMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ../ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ../NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var Entities_js_1 = __webpack_require__(/*! ../../../util/Entities.js */ "./node_modules/mathjax-full/js/util/Entities.js");
exports.UnicodeMethods = {};
var UnicodeCache = {};
exports.UnicodeMethods.Unicode = function (parser, name) {
    var HD = parser.GetBrackets(name);
    var HDsplit = null;
    var font = null;
    if (HD) {
        if (HD.replace(/ /g, '').
            match(/^(\d+(\.\d*)?|\.\d+),(\d+(\.\d*)?|\.\d+)$/)) {
            HDsplit = HD.replace(/ /g, '').split(/,/);
            font = parser.GetBrackets(name);
        }
        else {
            font = HD;
        }
    }
    var n = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name)).replace(/^0x/, 'x');
    if (!n.match(/^(x[0-9A-Fa-f]+|[0-9]+)$/)) {
        throw new TexError_js_1.default('BadUnicode', 'Argument to \\unicode must be a number');
    }
    var N = parseInt(n.match(/^x/) ? '0' + n : n);
    if (!UnicodeCache[N]) {
        UnicodeCache[N] = [800, 200, font, N];
    }
    else if (!font) {
        font = UnicodeCache[N][2];
    }
    if (HDsplit) {
        UnicodeCache[N][0] = Math.floor(parseFloat(HDsplit[0]) * 1000);
        UnicodeCache[N][1] = Math.floor(parseFloat(HDsplit[1]) * 1000);
    }
    var variant = parser.stack.env.font;
    var def = {};
    if (font) {
        UnicodeCache[N][2] = def.fontfamily = font.replace(/'/g, '\'');
        if (variant) {
            if (variant.match(/bold/)) {
                def.fontweight = 'bold';
            }
            if (variant.match(/italic|-mathit/)) {
                def.fontstyle = 'italic';
            }
        }
    }
    else if (variant) {
        def.mathvariant = variant;
    }
    var node = parser.create('token', 'mtext', def, (0, Entities_js_1.numeric)(n));
    NodeUtil_js_1.default.setProperty(node, 'unicode', true);
    parser.Push(node);
};
new SymbolMap_js_1.CommandMap('unicode', { unicode: 'Unicode' }, exports.UnicodeMethods);
exports.UnicodeConfiguration = Configuration_js_1.Configuration.create('unicode', { handler: { macro: ['unicode'] } });
//# sourceMappingURL=UnicodeConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/upgreek/UpgreekConfiguration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/upgreek/UpgreekConfiguration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpgreekConfiguration = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
function mathchar0miNormal(parser, mchar) {
    var def = mchar.attributes || {};
    def.mathvariant = TexConstants_js_1.TexConstant.Variant.NORMAL;
    var node = parser.create('token', 'mi', def, mchar.char);
    parser.Push(node);
}
new SymbolMap_js_1.CharacterMap('upgreek', mathchar0miNormal, {
    upalpha: '\u03B1',
    upbeta: '\u03B2',
    upgamma: '\u03B3',
    updelta: '\u03B4',
    upepsilon: '\u03F5',
    upzeta: '\u03B6',
    upeta: '\u03B7',
    uptheta: '\u03B8',
    upiota: '\u03B9',
    upkappa: '\u03BA',
    uplambda: '\u03BB',
    upmu: '\u03BC',
    upnu: '\u03BD',
    upxi: '\u03BE',
    upomicron: '\u03BF',
    uppi: '\u03C0',
    uprho: '\u03C1',
    upsigma: '\u03C3',
    uptau: '\u03C4',
    upupsilon: '\u03C5',
    upphi: '\u03D5',
    upchi: '\u03C7',
    uppsi: '\u03C8',
    upomega: '\u03C9',
    upvarepsilon: '\u03B5',
    upvartheta: '\u03D1',
    upvarpi: '\u03D6',
    upvarrho: '\u03F1',
    upvarsigma: '\u03C2',
    upvarphi: '\u03C6',
    Upgamma: '\u0393',
    Updelta: '\u0394',
    Uptheta: '\u0398',
    Uplambda: '\u039B',
    Upxi: '\u039E',
    Uppi: '\u03A0',
    Upsigma: '\u03A3',
    Upupsilon: '\u03A5',
    Upphi: '\u03A6',
    Uppsi: '\u03A8',
    Upomega: '\u03A9'
});
exports.UpgreekConfiguration = Configuration_js_1.Configuration.create('upgreek', {
    handler: { macro: ['upgreek'] },
});
//# sourceMappingURL=UpgreekConfiguration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/verb/VerbConfiguration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/verb/VerbConfiguration.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VerbConfiguration = exports.VerbMethods = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var TexConstants_js_1 = __webpack_require__(/*! ../TexConstants.js */ "./node_modules/mathjax-full/js/input/tex/TexConstants.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
exports.VerbMethods = {};
exports.VerbMethods.Verb = function (parser, name) {
    var c = parser.GetNext();
    var start = ++parser.i;
    if (c === '') {
        throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', name);
    }
    while (parser.i < parser.string.length &&
        parser.string.charAt(parser.i) !== c) {
        parser.i++;
    }
    if (parser.i === parser.string.length) {
        throw new TexError_js_1.default('NoClosingDelim', 'Can\'t find closing delimiter for %1', parser.currentCS);
    }
    var text = parser.string.slice(start, parser.i).replace(/ /g, '\u00A0');
    parser.i++;
    parser.Push(parser.create('token', 'mtext', { mathvariant: TexConstants_js_1.TexConstant.Variant.MONOSPACE }, text));
};
new SymbolMap_js_1.CommandMap('verb', { verb: 'Verb' }, exports.VerbMethods);
exports.VerbConfiguration = Configuration_js_1.Configuration.create('verb', { handler: { macro: ['verb'] } });
//# sourceMappingURL=VerbConfiguration.js.map

/***/ }),

/***/ "./node_modules/mhchemparser/dist/mhchemParser.js":
/*!********************************************************!*\
  !*** ./node_modules/mhchemparser/dist/mhchemParser.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {


/*!
 *************************************************************************
 *
 *  mhchemParser.ts
 *  4.1.1
 *
 *  Parser for the \ce command and \pu command for MathJax and Co.
 *
 *  mhchem's \ce is a tool for writing beautiful chemical equations easily.
 *  mhchem's \pu is a tool for writing physical units easily.
 *
 *  ----------------------------------------------------------------------
 *
 *  Copyright (c) 2015-2021 Martin Hensel
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  ----------------------------------------------------------------------
 *
 *  https://github.com/mhchem/mhchemParser
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mhchemParser = void 0;
var mhchemParser = (function () {
    function mhchemParser() {
    }
    mhchemParser.toTex = function (input, type) {
        return _mhchemTexify.go(_mhchemParser.go(input, type), type !== "tex");
    };
    return mhchemParser;
}());
exports.mhchemParser = mhchemParser;
function _mhchemCreateTransitions(o) {
    var pattern, state;
    var transitions = {};
    for (pattern in o) {
        for (state in o[pattern]) {
            var stateArray = state.split("|");
            o[pattern][state].stateArray = stateArray;
            for (var i = 0; i < stateArray.length; i++) {
                transitions[stateArray[i]] = [];
            }
        }
    }
    for (pattern in o) {
        for (state in o[pattern]) {
            var stateArray = o[pattern][state].stateArray || [];
            for (var i = 0; i < stateArray.length; i++) {
                var p = o[pattern][state];
                p.action_ = [].concat(p.action_);
                for (var k = 0; k < p.action_.length; k++) {
                    if (typeof p.action_[k] === "string") {
                        p.action_[k] = { type_: p.action_[k] };
                    }
                }
                var patternArray = pattern.split("|");
                for (var j = 0; j < patternArray.length; j++) {
                    if (stateArray[i] === '*') {
                        var t = void 0;
                        for (t in transitions) {
                            transitions[t].push({ pattern: patternArray[j], task: p });
                        }
                    }
                    else {
                        transitions[stateArray[i]].push({ pattern: patternArray[j], task: p });
                    }
                }
            }
        }
    }
    return transitions;
}
;
var _mhchemParser = {
    go: function (input, stateMachine) {
        if (!input) {
            return [];
        }
        if (stateMachine === undefined) {
            stateMachine = 'ce';
        }
        var state = '0';
        var buffer = {};
        buffer['parenthesisLevel'] = 0;
        input = input.replace(/\n/g, " ");
        input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
        input = input.replace(/[\u2026]/g, "...");
        var lastInput;
        var watchdog = 10;
        var output = [];
        while (true) {
            if (lastInput !== input) {
                watchdog = 10;
                lastInput = input;
            }
            else {
                watchdog--;
            }
            var machine = _mhchemParser.stateMachines[stateMachine];
            var t = machine.transitions[state] || machine.transitions['*'];
            iterateTransitions: for (var i = 0; i < t.length; i++) {
                var matches = _mhchemParser.patterns.match_(t[i].pattern, input);
                if (matches) {
                    var task = t[i].task;
                    for (var iA = 0; iA < task.action_.length; iA++) {
                        var o = void 0;
                        if (machine.actions[task.action_[iA].type_]) {
                            o = machine.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
                        }
                        else if (_mhchemParser.actions[task.action_[iA].type_]) {
                            o = _mhchemParser.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
                        }
                        else {
                            throw ["MhchemBugA", "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"];
                        }
                        _mhchemParser.concatArray(output, o);
                    }
                    state = task.nextState || state;
                    if (input.length > 0) {
                        if (!task.revisit) {
                            input = matches.remainder;
                        }
                        if (!task.toContinue) {
                            break iterateTransitions;
                        }
                    }
                    else {
                        return output;
                    }
                }
            }
            if (watchdog <= 0) {
                throw ["MhchemBugU", "mhchem bug U. Please report."];
            }
        }
    },
    concatArray: function (a, b) {
        if (b) {
            if (Array.isArray(b)) {
                for (var iB = 0; iB < b.length; iB++) {
                    a.push(b[iB]);
                }
            }
            else {
                a.push(b);
            }
        }
    },
    patterns: {
        patterns: {
            'empty': /^$/,
            'else': /^./,
            'else2': /^./,
            'space': /^\s/,
            'space A': /^\s(?=[A-Z\\$])/,
            'space$': /^\s$/,
            'a-z': /^[a-z]/,
            'x': /^x/,
            'x$': /^x$/,
            'i$': /^i$/,
            'letters': /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
            '\\greek': /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
            'one lowercase latin letter $': /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
            '$one lowercase latin letter$ $': /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
            'one lowercase greek letter $': /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
            'digits': /^[0-9]+/,
            '-9.,9': /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
            '-9.,9 no missing 0': /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
            '(-)(9.,9)(e)(99)': function (input) {
                var match = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:(?:([eE])|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
                if (match && match[0]) {
                    return { match_: match.slice(1), remainder: input.substr(match[0].length) };
                }
                return null;
            },
            '(-)(9)^(-9)': /^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/,
            'state of aggregation $': function (input) {
                var a = _mhchemParser.patterns.findObserveGroups(input, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
                if (a && a.remainder.match(/^($|[\s,;\)\]\}])/)) {
                    return a;
                }
                var match = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
                if (match) {
                    return { match_: match[0], remainder: input.substr(match[0].length) };
                }
                return null;
            },
            '_{(state of aggregation)}$': /^_\{(\([a-z]{1,3}\))\}/,
            '{[(': /^(?:\\\{|\[|\()/,
            ')]}': /^(?:\)|\]|\\\})/,
            ', ': /^[,;]\s*/,
            ',': /^[,;]/,
            '.': /^[.]/,
            '. __* ': /^([.\u22C5\u00B7\u2022]|[*])\s*/,
            '...': /^\.\.\.(?=$|[^.])/,
            '^{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "^{", "", "", "}"); },
            '^($...$)': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "^", "$", "$", ""); },
            '^a': /^\^([0-9]+|[^\\_])/,
            '^\\x{}{}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
            '^\\x{}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", ""); },
            '^\\x': /^\^(\\[a-zA-Z]+)\s*/,
            '^(-1)': /^\^(-?\d+)/,
            '\'': /^'/,
            '_{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "_{", "", "", "}"); },
            '_($...$)': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "_", "$", "$", ""); },
            '_9': /^_([+\-]?[0-9]+|[^\\])/,
            '_\\x{}{}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
            '_\\x{}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", ""); },
            '_\\x': /^_(\\[a-zA-Z]+)\s*/,
            '^_': /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
            '{}^': /^\{\}(?=\^)/,
            '{}': /^\{\}/,
            '{...}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "", "{", "}", ""); },
            '{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}"); },
            '$...$': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "", "$", "$", ""); },
            '${(...)}$__$(...)$': function (input) {
                return _mhchemParser.patterns.findObserveGroups(input, "${", "", "", "}$") || _mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$");
            },
            '=<>': /^[=<>]/,
            '#': /^[#\u2261]/,
            '+': /^\+/,
            '-$': /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
            '-9': /^-(?=[0-9])/,
            '- orbital overlap': /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
            '-': /^-/,
            'pm-operator': /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
            'operator': /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
            'arrowUpDown': /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
            '\\bond{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\bond{", "", "", "}"); },
            '->': /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
            'CMT': /^[CMT](?=\[)/,
            '[(...)]': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]"); },
            '1st-level escape': /^(&|\\\\|\\hline)\s*/,
            '\\,': /^(?:\\[,\ ;:])/,
            '\\x{}{}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
            '\\x{}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", ""); },
            '\\ca': /^\\ca(?:\s+|(?![a-zA-Z]))/,
            '\\x': /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
            'orbital': /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
            'others': /^[\/~|]/,
            '\\frac{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\frac{", "", "", "}", "{", "", "", "}"); },
            '\\overset{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\overset{", "", "", "}", "{", "", "", "}"); },
            '\\underset{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\underset{", "", "", "}", "{", "", "", "}"); },
            '\\underbrace{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\underbrace{", "", "", "}_", "{", "", "", "}"); },
            '\\color{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}"); },
            '\\color{(...)}{(...)}': function (input) {
                return _mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}", "{", "", "", "}") ||
                    _mhchemParser.patterns.findObserveGroups(input, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}");
            },
            '\\ce{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\ce{", "", "", "}"); },
            '\\pu{(...)}': function (input) { return _mhchemParser.patterns.findObserveGroups(input, "\\pu{", "", "", "}"); },
            'oxidation$': /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
            'd-oxidation$': /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
            'roman numeral': /^[IVX]+/,
            '1/2$': /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
            'amount': function (input) {
                var match;
                match = input.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);
                if (match) {
                    return { match_: match[0], remainder: input.substr(match[0].length) };
                }
                var a = _mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
                if (a) {
                    match = a.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);
                    if (match) {
                        return { match_: match[0], remainder: input.substr(match[0].length) };
                    }
                }
                return null;
            },
            'amount2': function (input) { return this['amount'](input); },
            '(KV letters),': /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
            'formula$': function (input) {
                if (input.match(/^\([a-z]+\)$/)) {
                    return null;
                }
                var match = input.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
                if (match) {
                    return { match_: match[0], remainder: input.substr(match[0].length) };
                }
                return null;
            },
            'uprightEntities': /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
            '/': /^\s*(\/)\s*/,
            '//': /^\s*(\/\/)\s*/,
            '*': /^\s*[*.]\s*/
        },
        findObserveGroups: function (input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
            var _match = function (input, pattern) {
                if (typeof pattern === "string") {
                    if (input.indexOf(pattern) !== 0) {
                        return null;
                    }
                    return pattern;
                }
                else {
                    var match_1 = input.match(pattern);
                    if (!match_1) {
                        return null;
                    }
                    return match_1[0];
                }
            };
            var _findObserveGroups = function (input, i, endChars) {
                var braces = 0;
                while (i < input.length) {
                    var a = input.charAt(i);
                    var match_2 = _match(input.substr(i), endChars);
                    if (match_2 !== null && braces === 0) {
                        return { endMatchBegin: i, endMatchEnd: i + match_2.length };
                    }
                    else if (a === "{") {
                        braces++;
                    }
                    else if (a === "}") {
                        if (braces === 0) {
                            throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
                        }
                        else {
                            braces--;
                        }
                    }
                    i++;
                }
                if (braces > 0) {
                    return null;
                }
                return null;
            };
            var match = _match(input, begExcl);
            if (match === null) {
                return null;
            }
            input = input.substr(match.length);
            match = _match(input, begIncl);
            if (match === null) {
                return null;
            }
            var e = _findObserveGroups(input, match.length, endIncl || endExcl);
            if (e === null) {
                return null;
            }
            var match1 = input.substring(0, (endIncl ? e.endMatchEnd : e.endMatchBegin));
            if (!(beg2Excl || beg2Incl)) {
                return {
                    match_: match1,
                    remainder: input.substr(e.endMatchEnd)
                };
            }
            else {
                var group2 = this.findObserveGroups(input.substr(e.endMatchEnd), beg2Excl, beg2Incl, end2Incl, end2Excl);
                if (group2 === null) {
                    return null;
                }
                var matchRet = [match1, group2.match_];
                return {
                    match_: (combine ? matchRet.join("") : matchRet),
                    remainder: group2.remainder
                };
            }
        },
        match_: function (m, input) {
            var pattern = _mhchemParser.patterns.patterns[m];
            if (pattern === undefined) {
                throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];
            }
            else if (typeof pattern === "function") {
                return _mhchemParser.patterns.patterns[m](input);
            }
            else {
                var match = input.match(pattern);
                if (match) {
                    if (match.length > 2) {
                        return { match_: match.slice(1), remainder: input.substr(match[0].length) };
                    }
                    else {
                        return { match_: match[1] || match[0], remainder: input.substr(match[0].length) };
                    }
                }
                return null;
            }
        }
    },
    actions: {
        'a=': function (buffer, m) { buffer.a = (buffer.a || "") + m; return undefined; },
        'b=': function (buffer, m) { buffer.b = (buffer.b || "") + m; return undefined; },
        'p=': function (buffer, m) { buffer.p = (buffer.p || "") + m; return undefined; },
        'o=': function (buffer, m) { buffer.o = (buffer.o || "") + m; return undefined; },
        'q=': function (buffer, m) { buffer.q = (buffer.q || "") + m; return undefined; },
        'd=': function (buffer, m) { buffer.d = (buffer.d || "") + m; return undefined; },
        'rm=': function (buffer, m) { buffer.rm = (buffer.rm || "") + m; return undefined; },
        'text=': function (buffer, m) { buffer.text_ = (buffer.text_ || "") + m; return undefined; },
        'insert': function (_buffer, _m, a) { return { type_: a }; },
        'insert+p1': function (_buffer, m, a) { return { type_: a, p1: m }; },
        'insert+p1+p2': function (_buffer, m, a) { return { type_: a, p1: m[0], p2: m[1] }; },
        'copy': function (_buffer, m) { return m; },
        'write': function (_buffer, _m, a) { return a; },
        'rm': function (_buffer, m) { return { type_: 'rm', p1: m }; },
        'text': function (_buffer, m) { return _mhchemParser.go(m, 'text'); },
        'tex-math': function (_buffer, m) { return _mhchemParser.go(m, 'tex-math'); },
        'tex-math tight': function (_buffer, m) { return _mhchemParser.go(m, 'tex-math tight'); },
        'bond': function (_buffer, m, k) { return { type_: 'bond', kind_: k || m }; },
        'color0-output': function (_buffer, m) { return { type_: 'color0', color: m }; },
        'ce': function (_buffer, m) { return _mhchemParser.go(m, 'ce'); },
        'pu': function (_buffer, m) { return _mhchemParser.go(m, 'pu'); },
        '1/2': function (_buffer, m) {
            var ret = [];
            if (m.match(/^[+\-]/)) {
                ret.push(m.substr(0, 1));
                m = m.substr(1);
            }
            var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
            n[1] = n[1].replace(/\$/g, "");
            ret.push({ type_: 'frac', p1: n[1], p2: n[2] });
            if (n[3]) {
                n[3] = n[3].replace(/\$/g, "");
                ret.push({ type_: 'tex-math', p1: n[3] });
            }
            return ret;
        },
        '9,9': function (_buffer, m) { return _mhchemParser.go(m, '9,9'); }
    },
    stateMachines: {
        'tex': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '0': { action_: 'copy' }
                },
                '\\ce{(...)}': {
                    '0': { action_: [{ type_: 'write', option: "{" }, 'ce', { type_: 'write', option: "}" }] }
                },
                '\\pu{(...)}': {
                    '0': { action_: [{ type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                'else': {
                    '0': { action_: 'copy' }
                },
            }),
            actions: {}
        },
        'ce': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: 'output' }
                },
                'else': {
                    '0|1|2': { action_: 'beginsWithBond=false', revisit: true, toContinue: true }
                },
                'oxidation$': {
                    '0': { action_: 'oxidation-output' }
                },
                'CMT': {
                    'r': { action_: 'rdt=', nextState: 'rt' },
                    'rd': { action_: 'rqt=', nextState: 'rdt' }
                },
                'arrowUpDown': {
                    '0|1|2|as': { action_: ['sb=false', 'output', 'operator'], nextState: '1' }
                },
                'uprightEntities': {
                    '0|1|2': { action_: ['o=', 'output'], nextState: '1' }
                },
                'orbital': {
                    '0|1|2|3': { action_: 'o=', nextState: 'o' }
                },
                '->': {
                    '0|1|2|3': { action_: 'r=', nextState: 'r' },
                    'a|as': { action_: ['output', 'r='], nextState: 'r' },
                    '*': { action_: ['output', 'r='], nextState: 'r' }
                },
                '+': {
                    'o': { action_: 'd= kv', nextState: 'd' },
                    'd|D': { action_: 'd=', nextState: 'd' },
                    'q': { action_: 'd=', nextState: 'qd' },
                    'qd|qD': { action_: 'd=', nextState: 'qd' },
                    'dq': { action_: ['output', 'd='], nextState: 'd' },
                    '3': { action_: ['sb=false', 'output', 'operator'], nextState: '0' }
                },
                'amount': {
                    '0|2': { action_: 'a=', nextState: 'a' }
                },
                'pm-operator': {
                    '0|1|2|a|as': { action_: ['sb=false', 'output', { type_: 'operator', option: '\\pm' }], nextState: '0' }
                },
                'operator': {
                    '0|1|2|a|as': { action_: ['sb=false', 'output', 'operator'], nextState: '0' }
                },
                '-$': {
                    'o|q': { action_: ['charge or bond', 'output'], nextState: 'qd' },
                    'd': { action_: 'd=', nextState: 'd' },
                    'D': { action_: ['output', { type_: 'bond', option: "-" }], nextState: '3' },
                    'q': { action_: 'd=', nextState: 'qd' },
                    'qd': { action_: 'd=', nextState: 'qd' },
                    'qD|dq': { action_: ['output', { type_: 'bond', option: "-" }], nextState: '3' }
                },
                '-9': {
                    '3|o': { action_: ['output', { type_: 'insert', option: 'hyphen' }], nextState: '3' }
                },
                '- orbital overlap': {
                    'o': { action_: ['output', { type_: 'insert', option: 'hyphen' }], nextState: '2' },
                    'd': { action_: ['output', { type_: 'insert', option: 'hyphen' }], nextState: '2' }
                },
                '-': {
                    '0|1|2': { action_: [{ type_: 'output', option: 1 }, 'beginsWithBond=true', { type_: 'bond', option: "-" }], nextState: '3' },
                    '3': { action_: { type_: 'bond', option: "-" } },
                    'a': { action_: ['output', { type_: 'insert', option: 'hyphen' }], nextState: '2' },
                    'as': { action_: [{ type_: 'output', option: 2 }, { type_: 'bond', option: "-" }], nextState: '3' },
                    'b': { action_: 'b=' },
                    'o': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
                    'q': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
                    'd|qd|dq': { action_: { type_: '- after o/d', option: true }, nextState: '2' },
                    'D|qD|p': { action_: ['output', { type_: 'bond', option: "-" }], nextState: '3' }
                },
                'amount2': {
                    '1|3': { action_: 'a=', nextState: 'a' }
                },
                'letters': {
                    '0|1|2|3|a|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },
                    'q|dq': { action_: ['output', 'o='], nextState: 'o' },
                    'd|D|qd|qD': { action_: 'o after d', nextState: 'o' }
                },
                'digits': {
                    'o': { action_: 'q=', nextState: 'q' },
                    'd|D': { action_: 'q=', nextState: 'dq' },
                    'q': { action_: ['output', 'o='], nextState: 'o' },
                    'a': { action_: 'o=', nextState: 'o' }
                },
                'space A': {
                    'b|p|bp': { action_: [] }
                },
                'space': {
                    'a': { action_: [], nextState: 'as' },
                    '0': { action_: 'sb=false' },
                    '1|2': { action_: 'sb=true' },
                    'r|rt|rd|rdt|rdq': { action_: 'output', nextState: '0' },
                    '*': { action_: ['output', 'sb=true'], nextState: '1' }
                },
                '1st-level escape': {
                    '1|2': { action_: ['output', { type_: 'insert+p1', option: '1st-level escape' }] },
                    '*': { action_: ['output', { type_: 'insert+p1', option: '1st-level escape' }], nextState: '0' }
                },
                '[(...)]': {
                    'r|rt': { action_: 'rd=', nextState: 'rd' },
                    'rd|rdt': { action_: 'rq=', nextState: 'rdq' }
                },
                '...': {
                    'o|d|D|dq|qd|qD': { action_: ['output', { type_: 'bond', option: "..." }], nextState: '3' },
                    '*': { action_: [{ type_: 'output', option: 1 }, { type_: 'insert', option: 'ellipsis' }], nextState: '1' }
                },
                '. __* ': {
                    '*': { action_: ['output', { type_: 'insert', option: 'addition compound' }], nextState: '1' }
                },
                'state of aggregation $': {
                    '*': { action_: ['output', 'state of aggregation'], nextState: '1' }
                },
                '{[(': {
                    'a|as|o': { action_: ['o=', 'output', 'parenthesisLevel++'], nextState: '2' },
                    '0|1|2|3': { action_: ['o=', 'output', 'parenthesisLevel++'], nextState: '2' },
                    '*': { action_: ['output', 'o=', 'output', 'parenthesisLevel++'], nextState: '2' }
                },
                ')]}': {
                    '0|1|2|3|b|p|bp|o': { action_: ['o=', 'parenthesisLevel--'], nextState: 'o' },
                    'a|as|d|D|q|qd|qD|dq': { action_: ['output', 'o=', 'parenthesisLevel--'], nextState: 'o' }
                },
                ', ': {
                    '*': { action_: ['output', 'comma'], nextState: '0' }
                },
                '^_': {
                    '*': { action_: [] }
                },
                '^{(...)}|^($...$)': {
                    '0|1|2|as': { action_: 'b=', nextState: 'b' },
                    'p': { action_: 'b=', nextState: 'bp' },
                    '3|o': { action_: 'd= kv', nextState: 'D' },
                    'q': { action_: 'd=', nextState: 'qD' },
                    'd|D|qd|qD|dq': { action_: ['output', 'd='], nextState: 'D' }
                },
                '^a|^\\x{}{}|^\\x{}|^\\x|\'': {
                    '0|1|2|as': { action_: 'b=', nextState: 'b' },
                    'p': { action_: 'b=', nextState: 'bp' },
                    '3|o': { action_: 'd= kv', nextState: 'd' },
                    'q': { action_: 'd=', nextState: 'qd' },
                    'd|qd|D|qD': { action_: 'd=' },
                    'dq': { action_: ['output', 'd='], nextState: 'd' }
                },
                '_{(state of aggregation)}$': {
                    'd|D|q|qd|qD|dq': { action_: ['output', 'q='], nextState: 'q' }
                },
                '_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x': {
                    '0|1|2|as': { action_: 'p=', nextState: 'p' },
                    'b': { action_: 'p=', nextState: 'bp' },
                    '3|o': { action_: 'q=', nextState: 'q' },
                    'd|D': { action_: 'q=', nextState: 'dq' },
                    'q|qd|qD|dq': { action_: ['output', 'q='], nextState: 'q' }
                },
                '=<>': {
                    '0|1|2|3|a|as|o|q|d|D|qd|qD|dq': { action_: [{ type_: 'output', option: 2 }, 'bond'], nextState: '3' }
                },
                '#': {
                    '0|1|2|3|a|as|o': { action_: [{ type_: 'output', option: 2 }, { type_: 'bond', option: "#" }], nextState: '3' }
                },
                '{}^': {
                    '*': { action_: [{ type_: 'output', option: 1 }, { type_: 'insert', option: 'tinySkip' }], nextState: '1' }
                },
                '{}': {
                    '*': { action_: { type_: 'output', option: 1 }, nextState: '1' }
                },
                '{...}': {
                    '0|1|2|3|a|as|b|p|bp': { action_: 'o=', nextState: 'o' },
                    'o|d|D|q|qd|qD|dq': { action_: ['output', 'o='], nextState: 'o' }
                },
                '$...$': {
                    'a': { action_: 'a=' },
                    '0|1|2|3|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },
                    'as|o': { action_: 'o=' },
                    'q|d|D|qd|qD|dq': { action_: ['output', 'o='], nextState: 'o' }
                },
                '\\bond{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'bond'], nextState: "3" }
                },
                '\\frac{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 1 }, 'frac-output'], nextState: '3' }
                },
                '\\overset{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'overset-output'], nextState: '3' }
                },
                '\\underset{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'underset-output'], nextState: '3' }
                },
                '\\underbrace{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'underbrace-output'], nextState: '3' }
                },
                '\\color{(...)}{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'color-output'], nextState: '3' }
                },
                '\\color{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'color0-output'] }
                },
                '\\ce{(...)}': {
                    '*': { action_: [{ type_: 'output', option: 2 }, 'ce'], nextState: '3' }
                },
                '\\,': {
                    '*': { action_: [{ type_: 'output', option: 1 }, 'copy'], nextState: '1' }
                },
                '\\pu{(...)}': {
                    '*': { action_: ['output', { type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }], nextState: '3' }
                },
                '\\x{}{}|\\x{}|\\x': {
                    '0|1|2|3|a|as|b|p|bp|o|c0': { action_: ['o=', 'output'], nextState: '3' },
                    '*': { action_: ['output', 'o=', 'output'], nextState: '3' }
                },
                'others': {
                    '*': { action_: [{ type_: 'output', option: 1 }, 'copy'], nextState: '3' }
                },
                'else2': {
                    'a': { action_: 'a to o', nextState: 'o', revisit: true },
                    'as': { action_: ['output', 'sb=true'], nextState: '1', revisit: true },
                    'r|rt|rd|rdt|rdq': { action_: ['output'], nextState: '0', revisit: true },
                    '*': { action_: ['output', 'copy'], nextState: '3' }
                }
            }),
            actions: {
                'o after d': function (buffer, m) {
                    var ret;
                    if ((buffer.d || "").match(/^[1-9][0-9]*$/)) {
                        var tmp = buffer.d;
                        buffer.d = undefined;
                        ret = this['output'](buffer);
                        ret.push({ type_: 'tinySkip' });
                        buffer.b = tmp;
                    }
                    else {
                        ret = this['output'](buffer);
                    }
                    _mhchemParser.actions['o='](buffer, m);
                    return ret;
                },
                'd= kv': function (buffer, m) {
                    buffer.d = m;
                    buffer.dType = 'kv';
                    return undefined;
                },
                'charge or bond': function (buffer, m) {
                    if (buffer['beginsWithBond']) {
                        var ret = [];
                        _mhchemParser.concatArray(ret, this['output'](buffer));
                        _mhchemParser.concatArray(ret, _mhchemParser.actions['bond'](buffer, m, "-"));
                        return ret;
                    }
                    else {
                        buffer.d = m;
                        return undefined;
                    }
                },
                '- after o/d': function (buffer, m, isAfterD) {
                    var c1 = _mhchemParser.patterns.match_('orbital', buffer.o || "");
                    var c2 = _mhchemParser.patterns.match_('one lowercase greek letter $', buffer.o || "");
                    var c3 = _mhchemParser.patterns.match_('one lowercase latin letter $', buffer.o || "");
                    var c4 = _mhchemParser.patterns.match_('$one lowercase latin letter$ $', buffer.o || "");
                    var hyphenFollows = m === "-" && (c1 && c1.remainder === "" || c2 || c3 || c4);
                    if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
                        buffer.o = '$' + buffer.o + '$';
                    }
                    var ret = [];
                    if (hyphenFollows) {
                        _mhchemParser.concatArray(ret, this['output'](buffer));
                        ret.push({ type_: 'hyphen' });
                    }
                    else {
                        c1 = _mhchemParser.patterns.match_('digits', buffer.d || "");
                        if (isAfterD && c1 && c1.remainder === '') {
                            _mhchemParser.concatArray(ret, _mhchemParser.actions['d='](buffer, m));
                            _mhchemParser.concatArray(ret, this['output'](buffer));
                        }
                        else {
                            _mhchemParser.concatArray(ret, this['output'](buffer));
                            _mhchemParser.concatArray(ret, _mhchemParser.actions['bond'](buffer, m, "-"));
                        }
                    }
                    return ret;
                },
                'a to o': function (buffer) {
                    buffer.o = buffer.a;
                    buffer.a = undefined;
                    return undefined;
                },
                'sb=true': function (buffer) { buffer.sb = true; return undefined; },
                'sb=false': function (buffer) { buffer.sb = false; return undefined; },
                'beginsWithBond=true': function (buffer) { buffer['beginsWithBond'] = true; return undefined; },
                'beginsWithBond=false': function (buffer) { buffer['beginsWithBond'] = false; return undefined; },
                'parenthesisLevel++': function (buffer) { buffer['parenthesisLevel']++; return undefined; },
                'parenthesisLevel--': function (buffer) { buffer['parenthesisLevel']--; return undefined; },
                'state of aggregation': function (_buffer, m) {
                    return { type_: 'state of aggregation', p1: _mhchemParser.go(m, 'o') };
                },
                'comma': function (buffer, m) {
                    var a = m.replace(/\s*$/, '');
                    var withSpace = (a !== m);
                    if (withSpace && buffer['parenthesisLevel'] === 0) {
                        return { type_: 'comma enumeration L', p1: a };
                    }
                    else {
                        return { type_: 'comma enumeration M', p1: a };
                    }
                },
                'output': function (buffer, _m, entityFollows) {
                    var ret;
                    if (!buffer.r) {
                        ret = [];
                        if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
                        }
                        else {
                            if (buffer.sb) {
                                ret.push({ type_: 'entitySkip' });
                            }
                            if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows !== 2) {
                                buffer.o = buffer.a;
                                buffer.a = undefined;
                            }
                            else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
                                buffer.o = buffer.a;
                                buffer.d = buffer.b;
                                buffer.q = buffer.p;
                                buffer.a = buffer.b = buffer.p = undefined;
                            }
                            else {
                                if (buffer.o && buffer.dType === 'kv' && _mhchemParser.patterns.match_('d-oxidation$', buffer.d || "")) {
                                    buffer.dType = 'oxidation';
                                }
                                else if (buffer.o && buffer.dType === 'kv' && !buffer.q) {
                                    buffer.dType = undefined;
                                }
                            }
                            ret.push({
                                type_: 'chemfive',
                                a: _mhchemParser.go(buffer.a, 'a'),
                                b: _mhchemParser.go(buffer.b, 'bd'),
                                p: _mhchemParser.go(buffer.p, 'pq'),
                                o: _mhchemParser.go(buffer.o, 'o'),
                                q: _mhchemParser.go(buffer.q, 'pq'),
                                d: _mhchemParser.go(buffer.d, (buffer.dType === 'oxidation' ? 'oxidation' : 'bd')),
                                dType: buffer.dType
                            });
                        }
                    }
                    else {
                        var rd = void 0;
                        if (buffer.rdt === 'M') {
                            rd = _mhchemParser.go(buffer.rd, 'tex-math');
                        }
                        else if (buffer.rdt === 'T') {
                            rd = [{ type_: 'text', p1: buffer.rd || "" }];
                        }
                        else {
                            rd = _mhchemParser.go(buffer.rd, 'ce');
                        }
                        var rq = void 0;
                        if (buffer.rqt === 'M') {
                            rq = _mhchemParser.go(buffer.rq, 'tex-math');
                        }
                        else if (buffer.rqt === 'T') {
                            rq = [{ type_: 'text', p1: buffer.rq || "" }];
                        }
                        else {
                            rq = _mhchemParser.go(buffer.rq, 'ce');
                        }
                        ret = {
                            type_: 'arrow',
                            r: buffer.r,
                            rd: rd,
                            rq: rq
                        };
                    }
                    for (var p in buffer) {
                        if (p !== 'parenthesisLevel' && p !== 'beginsWithBond') {
                            delete buffer[p];
                        }
                    }
                    return ret;
                },
                'oxidation-output': function (_buffer, m) {
                    var ret = ["{"];
                    _mhchemParser.concatArray(ret, _mhchemParser.go(m, 'oxidation'));
                    ret.push("}");
                    return ret;
                },
                'frac-output': function (_buffer, m) {
                    return { type_: 'frac-ce', p1: _mhchemParser.go(m[0], 'ce'), p2: _mhchemParser.go(m[1], 'ce') };
                },
                'overset-output': function (_buffer, m) {
                    return { type_: 'overset', p1: _mhchemParser.go(m[0], 'ce'), p2: _mhchemParser.go(m[1], 'ce') };
                },
                'underset-output': function (_buffer, m) {
                    return { type_: 'underset', p1: _mhchemParser.go(m[0], 'ce'), p2: _mhchemParser.go(m[1], 'ce') };
                },
                'underbrace-output': function (_buffer, m) {
                    return { type_: 'underbrace', p1: _mhchemParser.go(m[0], 'ce'), p2: _mhchemParser.go(m[1], 'ce') };
                },
                'color-output': function (_buffer, m) {
                    return { type_: 'color', color1: m[0], color2: _mhchemParser.go(m[1], 'ce') };
                },
                'r=': function (buffer, m) { buffer.r = m; return undefined; },
                'rdt=': function (buffer, m) { buffer.rdt = m; return undefined; },
                'rd=': function (buffer, m) { buffer.rd = m; return undefined; },
                'rqt=': function (buffer, m) { buffer.rqt = m; return undefined; },
                'rq=': function (buffer, m) { buffer.rq = m; return undefined; },
                'operator': function (_buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; }
            }
        },
        'a': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: [] }
                },
                '1/2$': {
                    '0': { action_: '1/2' }
                },
                'else': {
                    '0': { action_: [], nextState: '1', revisit: true }
                },
                '${(...)}$__$(...)$': {
                    '*': { action_: 'tex-math tight', nextState: '1' }
                },
                ',': {
                    '*': { action_: { type_: 'insert', option: 'commaDecimal' } }
                },
                'else2': {
                    '*': { action_: 'copy' }
                }
            }),
            actions: {}
        },
        'o': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: [] }
                },
                '1/2$': {
                    '0': { action_: '1/2' }
                },
                'else': {
                    '0': { action_: [], nextState: '1', revisit: true }
                },
                'letters': {
                    '*': { action_: 'rm' }
                },
                '\\ca': {
                    '*': { action_: { type_: 'insert', option: 'circa' } }
                },
                '\\pu{(...)}': {
                    '*': { action_: [{ type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                '\\x{}{}|\\x{}|\\x': {
                    '*': { action_: 'copy' }
                },
                '${(...)}$__$(...)$': {
                    '*': { action_: 'tex-math' }
                },
                '{(...)}': {
                    '*': { action_: [{ type_: 'write', option: "{" }, 'text', { type_: 'write', option: "}" }] }
                },
                'else2': {
                    '*': { action_: 'copy' }
                }
            }),
            actions: {}
        },
        'text': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: 'output' }
                },
                '{...}': {
                    '*': { action_: 'text=' }
                },
                '${(...)}$__$(...)$': {
                    '*': { action_: 'tex-math' }
                },
                '\\greek': {
                    '*': { action_: ['output', 'rm'] }
                },
                '\\pu{(...)}': {
                    '*': { action_: ['output', { type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                '\\,|\\x{}{}|\\x{}|\\x': {
                    '*': { action_: ['output', 'copy'] }
                },
                'else': {
                    '*': { action_: 'text=' }
                }
            }),
            actions: {
                'output': function (buffer) {
                    if (buffer.text_) {
                        var ret = { type_: 'text', p1: buffer.text_ };
                        for (var p in buffer) {
                            delete buffer[p];
                        }
                        return ret;
                    }
                    return undefined;
                }
            }
        },
        'pq': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: [] }
                },
                'state of aggregation $': {
                    '*': { action_: 'state of aggregation' }
                },
                'i$': {
                    '0': { action_: [], nextState: '!f', revisit: true }
                },
                '(KV letters),': {
                    '0': { action_: 'rm', nextState: '0' }
                },
                'formula$': {
                    '0': { action_: [], nextState: 'f', revisit: true }
                },
                '1/2$': {
                    '0': { action_: '1/2' }
                },
                'else': {
                    '0': { action_: [], nextState: '!f', revisit: true }
                },
                '${(...)}$__$(...)$': {
                    '*': { action_: 'tex-math' }
                },
                '{(...)}': {
                    '*': { action_: 'text' }
                },
                'a-z': {
                    'f': { action_: 'tex-math' }
                },
                'letters': {
                    '*': { action_: 'rm' }
                },
                '-9.,9': {
                    '*': { action_: '9,9' }
                },
                ',': {
                    '*': { action_: { type_: 'insert+p1', option: 'comma enumeration S' } }
                },
                '\\color{(...)}{(...)}': {
                    '*': { action_: 'color-output' }
                },
                '\\color{(...)}': {
                    '*': { action_: 'color0-output' }
                },
                '\\ce{(...)}': {
                    '*': { action_: 'ce' }
                },
                '\\pu{(...)}': {
                    '*': { action_: [{ type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                '\\,|\\x{}{}|\\x{}|\\x': {
                    '*': { action_: 'copy' }
                },
                'else2': {
                    '*': { action_: 'copy' }
                }
            }),
            actions: {
                'state of aggregation': function (_buffer, m) {
                    return { type_: 'state of aggregation subscript', p1: _mhchemParser.go(m, 'o') };
                },
                'color-output': function (_buffer, m) {
                    return { type_: 'color', color1: m[0], color2: _mhchemParser.go(m[1], 'pq') };
                }
            }
        },
        'bd': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: [] }
                },
                'x$': {
                    '0': { action_: [], nextState: '!f', revisit: true }
                },
                'formula$': {
                    '0': { action_: [], nextState: 'f', revisit: true }
                },
                'else': {
                    '0': { action_: [], nextState: '!f', revisit: true }
                },
                '-9.,9 no missing 0': {
                    '*': { action_: '9,9' }
                },
                '.': {
                    '*': { action_: { type_: 'insert', option: 'electron dot' } }
                },
                'a-z': {
                    'f': { action_: 'tex-math' }
                },
                'x': {
                    '*': { action_: { type_: 'insert', option: 'KV x' } }
                },
                'letters': {
                    '*': { action_: 'rm' }
                },
                '\'': {
                    '*': { action_: { type_: 'insert', option: 'prime' } }
                },
                '${(...)}$__$(...)$': {
                    '*': { action_: 'tex-math' }
                },
                '{(...)}': {
                    '*': { action_: 'text' }
                },
                '\\color{(...)}{(...)}': {
                    '*': { action_: 'color-output' }
                },
                '\\color{(...)}': {
                    '*': { action_: 'color0-output' }
                },
                '\\ce{(...)}': {
                    '*': { action_: 'ce' }
                },
                '\\pu{(...)}': {
                    '*': { action_: [{ type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                '\\,|\\x{}{}|\\x{}|\\x': {
                    '*': { action_: 'copy' }
                },
                'else2': {
                    '*': { action_: 'copy' }
                }
            }),
            actions: {
                'color-output': function (_buffer, m) {
                    return { type_: 'color', color1: m[0], color2: _mhchemParser.go(m[1], 'bd') };
                }
            }
        },
        'oxidation': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: [] }
                },
                'roman numeral': {
                    '*': { action_: 'roman-numeral' }
                },
                '${(...)}$__$(...)$': {
                    '*': { action_: 'tex-math' }
                },
                'else': {
                    '*': { action_: 'copy' }
                }
            }),
            actions: {
                'roman-numeral': function (_buffer, m) { return { type_: 'roman numeral', p1: m }; }
            }
        },
        'tex-math': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: 'output' }
                },
                '\\ce{(...)}': {
                    '*': { action_: ['output', 'ce'] }
                },
                '\\pu{(...)}': {
                    '*': { action_: ['output', { type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                '{...}|\\,|\\x{}{}|\\x{}|\\x': {
                    '*': { action_: 'o=' }
                },
                'else': {
                    '*': { action_: 'o=' }
                }
            }),
            actions: {
                'output': function (buffer) {
                    if (buffer.o) {
                        var ret = { type_: 'tex-math', p1: buffer.o };
                        for (var p in buffer) {
                            delete buffer[p];
                        }
                        return ret;
                    }
                    return undefined;
                }
            }
        },
        'tex-math tight': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: 'output' }
                },
                '\\ce{(...)}': {
                    '*': { action_: ['output', 'ce'] }
                },
                '\\pu{(...)}': {
                    '*': { action_: ['output', { type_: 'write', option: "{" }, 'pu', { type_: 'write', option: "}" }] }
                },
                '{...}|\\,|\\x{}{}|\\x{}|\\x': {
                    '*': { action_: 'o=' }
                },
                '-|+': {
                    '*': { action_: 'tight operator' }
                },
                'else': {
                    '*': { action_: 'o=' }
                }
            }),
            actions: {
                'tight operator': function (buffer, m) { buffer.o = (buffer.o || "") + "{" + m + "}"; return undefined; },
                'output': function (buffer) {
                    if (buffer.o) {
                        var ret = { type_: 'tex-math', p1: buffer.o };
                        for (var p in buffer) {
                            delete buffer[p];
                        }
                        return ret;
                    }
                    return undefined;
                }
            }
        },
        '9,9': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: [] }
                },
                ',': {
                    '*': { action_: 'comma' }
                },
                'else': {
                    '*': { action_: 'copy' }
                }
            }),
            actions: {
                'comma': function () { return { type_: 'commaDecimal' }; }
            }
        },
        'pu': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: 'output' }
                },
                'space$': {
                    '*': { action_: ['output', 'space'] }
                },
                '{[(|)]}': {
                    '0|a': { action_: 'copy' }
                },
                '(-)(9)^(-9)': {
                    '0': { action_: 'number^', nextState: 'a' }
                },
                '(-)(9.,9)(e)(99)': {
                    '0': { action_: 'enumber', nextState: 'a' }
                },
                'space': {
                    '0|a': { action_: [] }
                },
                'pm-operator': {
                    '0|a': { action_: { type_: 'operator', option: '\\pm' }, nextState: '0' }
                },
                'operator': {
                    '0|a': { action_: 'copy', nextState: '0' }
                },
                '//': {
                    'd': { action_: 'o=', nextState: '/' }
                },
                '/': {
                    'd': { action_: 'o=', nextState: '/' }
                },
                '{...}|else': {
                    '0|d': { action_: 'd=', nextState: 'd' },
                    'a': { action_: ['space', 'd='], nextState: 'd' },
                    '/|q': { action_: 'q=', nextState: 'q' }
                }
            }),
            actions: {
                'enumber': function (_buffer, m) {
                    var ret = [];
                    if (m[0] === "+-" || m[0] === "+/-") {
                        ret.push("\\pm ");
                    }
                    else if (m[0]) {
                        ret.push(m[0]);
                    }
                    if (m[1]) {
                        _mhchemParser.concatArray(ret, _mhchemParser.go(m[1], 'pu-9,9'));
                        if (m[2]) {
                            if (m[2].match(/[,.]/)) {
                                _mhchemParser.concatArray(ret, _mhchemParser.go(m[2], 'pu-9,9'));
                            }
                            else {
                                ret.push(m[2]);
                            }
                        }
                        if (m[3] || m[4]) {
                            if (m[3] === "e" || m[4] === "*") {
                                ret.push({ type_: 'cdot' });
                            }
                            else {
                                ret.push({ type_: 'times' });
                            }
                        }
                    }
                    if (m[5]) {
                        ret.push("10^{" + m[5] + "}");
                    }
                    return ret;
                },
                'number^': function (_buffer, m) {
                    var ret = [];
                    if (m[0] === "+-" || m[0] === "+/-") {
                        ret.push("\\pm ");
                    }
                    else if (m[0]) {
                        ret.push(m[0]);
                    }
                    _mhchemParser.concatArray(ret, _mhchemParser.go(m[1], 'pu-9,9'));
                    ret.push("^{" + m[2] + "}");
                    return ret;
                },
                'operator': function (_buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; },
                'space': function () { return { type_: 'pu-space-1' }; },
                'output': function (buffer) {
                    var ret;
                    var md = _mhchemParser.patterns.match_('{(...)}', buffer.d || "");
                    if (md && md.remainder === '') {
                        buffer.d = md.match_;
                    }
                    var mq = _mhchemParser.patterns.match_('{(...)}', buffer.q || "");
                    if (mq && mq.remainder === '') {
                        buffer.q = mq.match_;
                    }
                    if (buffer.d) {
                        buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
                        buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
                    }
                    if (buffer.q) {
                        buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
                        buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
                        var b5 = {
                            d: _mhchemParser.go(buffer.d, 'pu'),
                            q: _mhchemParser.go(buffer.q, 'pu')
                        };
                        if (buffer.o === '//') {
                            ret = { type_: 'pu-frac', p1: b5.d, p2: b5.q };
                        }
                        else {
                            ret = b5.d;
                            if (b5.d.length > 1 || b5.q.length > 1) {
                                ret.push({ type_: ' / ' });
                            }
                            else {
                                ret.push({ type_: '/' });
                            }
                            _mhchemParser.concatArray(ret, b5.q);
                        }
                    }
                    else {
                        ret = _mhchemParser.go(buffer.d, 'pu-2');
                    }
                    for (var p in buffer) {
                        delete buffer[p];
                    }
                    return ret;
                }
            }
        },
        'pu-2': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '*': { action_: 'output' }
                },
                '*': {
                    '*': { action_: ['output', 'cdot'], nextState: '0' }
                },
                '\\x': {
                    '*': { action_: 'rm=' }
                },
                'space': {
                    '*': { action_: ['output', 'space'], nextState: '0' }
                },
                '^{(...)}|^(-1)': {
                    '1': { action_: '^(-1)' }
                },
                '-9.,9': {
                    '0': { action_: 'rm=', nextState: '0' },
                    '1': { action_: '^(-1)', nextState: '0' }
                },
                '{...}|else': {
                    '*': { action_: 'rm=', nextState: '1' }
                }
            }),
            actions: {
                'cdot': function () { return { type_: 'tight cdot' }; },
                '^(-1)': function (buffer, m) { buffer.rm += "^{" + m + "}"; return undefined; },
                'space': function () { return { type_: 'pu-space-2' }; },
                'output': function (buffer) {
                    var ret = [];
                    if (buffer.rm) {
                        var mrm = _mhchemParser.patterns.match_('{(...)}', buffer.rm || "");
                        if (mrm && mrm.remainder === '') {
                            ret = _mhchemParser.go(mrm.match_, 'pu');
                        }
                        else {
                            ret = { type_: 'rm', p1: buffer.rm };
                        }
                    }
                    for (var p in buffer) {
                        delete buffer[p];
                    }
                    return ret;
                }
            }
        },
        'pu-9,9': {
            transitions: _mhchemCreateTransitions({
                'empty': {
                    '0': { action_: 'output-0' },
                    'o': { action_: 'output-o' }
                },
                ',': {
                    '0': { action_: ['output-0', 'comma'], nextState: 'o' }
                },
                '.': {
                    '0': { action_: ['output-0', 'copy'], nextState: 'o' }
                },
                'else': {
                    '*': { action_: 'text=' }
                }
            }),
            actions: {
                'comma': function () { return { type_: 'commaDecimal' }; },
                'output-0': function (buffer) {
                    var ret = [];
                    buffer.text_ = buffer.text_ || "";
                    if (buffer.text_.length > 4) {
                        var a = buffer.text_.length % 3;
                        if (a === 0) {
                            a = 3;
                        }
                        for (var i = buffer.text_.length - 3; i > 0; i -= 3) {
                            ret.push(buffer.text_.substr(i, 3));
                            ret.push({ type_: '1000 separator' });
                        }
                        ret.push(buffer.text_.substr(0, a));
                        ret.reverse();
                    }
                    else {
                        ret.push(buffer.text_);
                    }
                    for (var p in buffer) {
                        delete buffer[p];
                    }
                    return ret;
                },
                'output-o': function (buffer) {
                    var ret = [];
                    buffer.text_ = buffer.text_ || "";
                    if (buffer.text_.length > 4) {
                        var a = buffer.text_.length - 3;
                        var i = void 0;
                        for (i = 0; i < a; i += 3) {
                            ret.push(buffer.text_.substr(i, 3));
                            ret.push({ type_: '1000 separator' });
                        }
                        ret.push(buffer.text_.substr(i));
                    }
                    else {
                        ret.push(buffer.text_);
                    }
                    for (var p in buffer) {
                        delete buffer[p];
                    }
                    return ret;
                }
            }
        }
    }
};
var _mhchemTexify = {
    go: function (input, addOuterBraces) {
        if (!input) {
            return "";
        }
        var res = "";
        var cee = false;
        for (var i = 0; i < input.length; i++) {
            var inputi = input[i];
            if (typeof inputi === "string") {
                res += inputi;
            }
            else {
                res += _mhchemTexify._go2(inputi);
                if (inputi.type_ === '1st-level escape') {
                    cee = true;
                }
            }
        }
        if (addOuterBraces && !cee && res) {
            res = "{" + res + "}";
        }
        return res;
    },
    _goInner: function (input) {
        return _mhchemTexify.go(input, false);
    },
    _go2: function (buf) {
        var res;
        switch (buf.type_) {
            case 'chemfive':
                res = "";
                var b5 = {
                    a: _mhchemTexify._goInner(buf.a),
                    b: _mhchemTexify._goInner(buf.b),
                    p: _mhchemTexify._goInner(buf.p),
                    o: _mhchemTexify._goInner(buf.o),
                    q: _mhchemTexify._goInner(buf.q),
                    d: _mhchemTexify._goInner(buf.d)
                };
                if (b5.a) {
                    if (b5.a.match(/^[+\-]/)) {
                        b5.a = "{" + b5.a + "}";
                    }
                    res += b5.a + "\\,";
                }
                if (b5.b || b5.p) {
                    res += "{\\vphantom{A}}";
                    res += "^{\\hphantom{" + (b5.b || "") + "}}_{\\hphantom{" + (b5.p || "") + "}}";
                    res += "\\mkern-1.5mu";
                    res += "{\\vphantom{A}}";
                    res += "^{\\smash[t]{\\vphantom{2}}\\llap{" + (b5.b || "") + "}}";
                    res += "_{\\vphantom{2}\\llap{\\smash[t]{" + (b5.p || "") + "}}}";
                }
                if (b5.o) {
                    if (b5.o.match(/^[+\-]/)) {
                        b5.o = "{" + b5.o + "}";
                    }
                    res += b5.o;
                }
                if (buf.dType === 'kv') {
                    if (b5.d || b5.q) {
                        res += "{\\vphantom{A}}";
                    }
                    if (b5.d) {
                        res += "^{" + b5.d + "}";
                    }
                    if (b5.q) {
                        res += "_{\\smash[t]{" + b5.q + "}}";
                    }
                }
                else if (buf.dType === 'oxidation') {
                    if (b5.d) {
                        res += "{\\vphantom{A}}";
                        res += "^{" + b5.d + "}";
                    }
                    if (b5.q) {
                        res += "{\\vphantom{A}}";
                        res += "_{\\smash[t]{" + b5.q + "}}";
                    }
                }
                else {
                    if (b5.q) {
                        res += "{\\vphantom{A}}";
                        res += "_{\\smash[t]{" + b5.q + "}}";
                    }
                    if (b5.d) {
                        res += "{\\vphantom{A}}";
                        res += "^{" + b5.d + "}";
                    }
                }
                break;
            case 'rm':
                res = "\\mathrm{" + buf.p1 + "}";
                break;
            case 'text':
                if (buf.p1.match(/[\^_]/)) {
                    buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
                    res = "\\mathrm{" + buf.p1 + "}";
                }
                else {
                    res = "\\text{" + buf.p1 + "}";
                }
                break;
            case 'roman numeral':
                res = "\\mathrm{" + buf.p1 + "}";
                break;
            case 'state of aggregation':
                res = "\\mskip2mu " + _mhchemTexify._goInner(buf.p1);
                break;
            case 'state of aggregation subscript':
                res = "\\mskip1mu " + _mhchemTexify._goInner(buf.p1);
                break;
            case 'bond':
                res = _mhchemTexify._getBond(buf.kind_);
                if (!res) {
                    throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + buf.kind_ + ")"];
                }
                break;
            case 'frac':
                var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
                res = "\\mathchoice{\\textstyle" + c + "}{" + c + "}{" + c + "}{" + c + "}";
                break;
            case 'pu-frac':
                var d = "\\frac{" + _mhchemTexify._goInner(buf.p1) + "}{" + _mhchemTexify._goInner(buf.p2) + "}";
                res = "\\mathchoice{\\textstyle" + d + "}{" + d + "}{" + d + "}{" + d + "}";
                break;
            case 'tex-math':
                res = buf.p1 + " ";
                break;
            case 'frac-ce':
                res = "\\frac{" + _mhchemTexify._goInner(buf.p1) + "}{" + _mhchemTexify._goInner(buf.p2) + "}";
                break;
            case 'overset':
                res = "\\overset{" + _mhchemTexify._goInner(buf.p1) + "}{" + _mhchemTexify._goInner(buf.p2) + "}";
                break;
            case 'underset':
                res = "\\underset{" + _mhchemTexify._goInner(buf.p1) + "}{" + _mhchemTexify._goInner(buf.p2) + "}";
                break;
            case 'underbrace':
                res = "\\underbrace{" + _mhchemTexify._goInner(buf.p1) + "}_{" + _mhchemTexify._goInner(buf.p2) + "}";
                break;
            case 'color':
                res = "{\\color{" + buf.color1 + "}{" + _mhchemTexify._goInner(buf.color2) + "}}";
                break;
            case 'color0':
                res = "\\color{" + buf.color + "}";
                break;
            case 'arrow':
                var b6 = {
                    rd: _mhchemTexify._goInner(buf.rd),
                    rq: _mhchemTexify._goInner(buf.rq)
                };
                var arrow = _mhchemTexify._getArrow(buf.r);
                if (b6.rd || b6.rq) {
                    if (buf.r === "<=>" || buf.r === "<=>>" || buf.r === "<<=>" || buf.r === "<-->") {
                        arrow = "\\long" + arrow;
                        if (b6.rd) {
                            arrow = "\\overset{" + b6.rd + "}{" + arrow + "}";
                        }
                        if (b6.rq) {
                            if (buf.r === "<-->") {
                                arrow = "\\underset{\\lower2mu{" + b6.rq + "}}{" + arrow + "}";
                            }
                            else {
                                arrow = "\\underset{\\lower6mu{" + b6.rq + "}}{" + arrow + "}";
                            }
                        }
                        arrow = " {}\\mathrel{" + arrow + "}{} ";
                    }
                    else {
                        if (b6.rq) {
                            arrow += "[{" + b6.rq + "}]";
                        }
                        arrow += "{" + b6.rd + "}";
                        arrow = " {}\\mathrel{\\x" + arrow + "}{} ";
                    }
                }
                else {
                    arrow = " {}\\mathrel{\\long" + arrow + "}{} ";
                }
                res = arrow;
                break;
            case 'operator':
                res = _mhchemTexify._getOperator(buf.kind_);
                break;
            case '1st-level escape':
                res = buf.p1 + " ";
                break;
            case 'space':
                res = " ";
                break;
            case 'tinySkip':
                res = '\\mkern2mu';
                break;
            case 'entitySkip':
                res = "~";
                break;
            case 'pu-space-1':
                res = "~";
                break;
            case 'pu-space-2':
                res = "\\mkern3mu ";
                break;
            case '1000 separator':
                res = "\\mkern2mu ";
                break;
            case 'commaDecimal':
                res = "{,}";
                break;
            case 'comma enumeration L':
                res = "{" + buf.p1 + "}\\mkern6mu ";
                break;
            case 'comma enumeration M':
                res = "{" + buf.p1 + "}\\mkern3mu ";
                break;
            case 'comma enumeration S':
                res = "{" + buf.p1 + "}\\mkern1mu ";
                break;
            case 'hyphen':
                res = "\\text{-}";
                break;
            case 'addition compound':
                res = "\\,{\\cdot}\\,";
                break;
            case 'electron dot':
                res = "\\mkern1mu \\bullet\\mkern1mu ";
                break;
            case 'KV x':
                res = "{\\times}";
                break;
            case 'prime':
                res = "\\prime ";
                break;
            case 'cdot':
                res = "\\cdot ";
                break;
            case 'tight cdot':
                res = "\\mkern1mu{\\cdot}\\mkern1mu ";
                break;
            case 'times':
                res = "\\times ";
                break;
            case 'circa':
                res = "{\\sim}";
                break;
            case '^':
                res = "uparrow";
                break;
            case 'v':
                res = "downarrow";
                break;
            case 'ellipsis':
                res = "\\ldots ";
                break;
            case '/':
                res = "/";
                break;
            case ' / ':
                res = "\\,/\\,";
                break;
            default:
                assertNever(buf);
                throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
        return res;
    },
    _getArrow: function (a) {
        switch (a) {
            case "->": return "rightarrow";
            case "\u2192": return "rightarrow";
            case "\u27F6": return "rightarrow";
            case "<-": return "leftarrow";
            case "<->": return "leftrightarrow";
            case "<-->": return "leftrightarrows";
            case "<=>": return "rightleftharpoons";
            case "\u21CC": return "rightleftharpoons";
            case "<=>>": return "Rightleftharpoons";
            case "<<=>": return "Leftrightharpoons";
            default:
                assertNever(a);
                throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
    },
    _getBond: function (a) {
        switch (a) {
            case "-": return "{-}";
            case "1": return "{-}";
            case "=": return "{=}";
            case "2": return "{=}";
            case "#": return "{\\equiv}";
            case "3": return "{\\equiv}";
            case "~": return "{\\tripledash}";
            case "~-": return "{\\rlap{\\lower.1em{-}}\\raise.1em{\\tripledash}}";
            case "~=": return "{\\rlap{\\lower.2em{-}}\\rlap{\\raise.2em{\\tripledash}}-}";
            case "~--": return "{\\rlap{\\lower.2em{-}}\\rlap{\\raise.2em{\\tripledash}}-}";
            case "-~-": return "{\\rlap{\\lower.2em{-}}\\rlap{\\raise.2em{-}}\\tripledash}";
            case "...": return "{{\\cdot}{\\cdot}{\\cdot}}";
            case "....": return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
            case "->": return "{\\rightarrow}";
            case "<-": return "{\\leftarrow}";
            case "<": return "{<}";
            case ">": return "{>}";
            default:
                assertNever(a);
                throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
    },
    _getOperator: function (a) {
        switch (a) {
            case "+": return " {}+{} ";
            case "-": return " {}-{} ";
            case "=": return " {}={} ";
            case "<": return " {}<{} ";
            case ">": return " {}>{} ";
            case "<<": return " {}\\ll{} ";
            case ">>": return " {}\\gg{} ";
            case "\\pm": return " {}\\pm{} ";
            case "\\approx": return " {}\\approx{} ";
            case "$\\approx$": return " {}\\approx{} ";
            case "v": return " \\downarrow{} ";
            case "(v)": return " \\downarrow{} ";
            case "^": return " \\uparrow{} ";
            case "(^)": return " \\uparrow{} ";
            default:
                assertNever(a);
                throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
    }
};
function assertNever(a) { }


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2lucHV0X3RleF9BbGxQYWNrYWdlc19qcy5mMWMwODFhYjA2NDY1MmJmYWUzMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDckMsbUJBQU8sQ0FBQywrR0FBaUM7QUFDekMsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDbkMsbUJBQU8sQ0FBQywyR0FBK0I7QUFDdkMsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDckMsbUJBQU8sQ0FBQywrSEFBeUM7QUFDakQsbUJBQU8sQ0FBQywrR0FBaUM7QUFDekMsbUJBQU8sQ0FBQywrSEFBeUM7QUFDakQsbUJBQU8sQ0FBQywrR0FBaUM7QUFDekMsbUJBQU8sQ0FBQywyR0FBK0I7QUFDdkMsbUJBQU8sQ0FBQywySEFBdUM7QUFDL0MsbUJBQU8sQ0FBQywyR0FBK0I7QUFDdkMsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQyx1SEFBcUM7QUFDN0MsbUJBQU8sQ0FBQyx1SUFBNkM7QUFDckQsbUJBQU8sQ0FBQywrR0FBaUM7QUFDekMsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQyx1SEFBcUM7QUFDN0MsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDckMsbUJBQU8sQ0FBQywySEFBdUM7QUFDL0MsbUJBQU8sQ0FBQywrR0FBaUM7QUFDekMsbUJBQU8sQ0FBQywrSEFBeUM7QUFDakQsbUJBQU8sQ0FBQyx1SEFBcUM7QUFDN0MsbUJBQU8sQ0FBQyxtSUFBMkM7QUFDbkQsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQywrSEFBeUM7QUFDakQsbUJBQU8sQ0FBQywySEFBdUM7QUFDL0MsbUJBQU8sQ0FBQyx1SEFBcUM7QUFDN0MsbUJBQU8sQ0FBQywrSEFBeUM7QUFDakQsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN2RWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsc0JBQXNCO0FBQ25GO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwrREFBK0QsdUJBQXVCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUksT0FBTyxJQUFJO0FBQ2pELENBQUM7QUFDRCwyQkFBMkIsdURBQXVELFdBQVcsNEJBQTRCO0FBQ3pIOzs7Ozs7Ozs7O0FDL0JhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsZUFBZTtBQUMxQyx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsK0VBQWU7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVk7QUFDcEMsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWlCO0FBQy9DLG1CQUFPLENBQUMscUZBQWtCO0FBQzFCLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmO0FBQ0EsNkRBQTZELElBQUk7QUFDakUsMkRBQTJELFdBQVcsa0NBQWtDO0FBQ3hHLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDbkVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ25ELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxxQkFBcUIsSUFBSTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsd0JBQXdCLG9CQUFvQixJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7QUMxS2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWlCO0FBQy9DLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFpQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDcEQsd0NBQXdDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BFLHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBa0M7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQTBCO0FBQ3JEO0FBQ0EseUJBQXlCLG9DQUFvQztBQUM3RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCLEdBQUcsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxFQUFFLFFBQVEsU0FBUztBQUM5RCxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLG1DQUFtQyxZQUFZLFdBQVcsSUFBSSxNQUFNO0FBQ3BFLG1DQUFtQyxXQUFXLFdBQVcsSUFBSSxNQUFNO0FBQ25FLG1DQUFtQyxrQkFBa0IsV0FBVyxJQUFJLE1BQU07QUFDMUUsb0NBQW9DLGlCQUFpQixXQUFXLElBQUksTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRSw0QkFBNEIsdUNBQXVDO0FBQ25FLDRCQUE0QixzQ0FBc0M7QUFDbEUsNEJBQTRCLHVDQUF1QztBQUNuRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUEyRDtBQUN0RiwyQkFBMkIsMkRBQTJEO0FBQ3RGLDJCQUEyQiwyREFBMkQ7QUFDdEYsNEJBQTRCLDJEQUEyRDtBQUN2Rix3QkFBd0IsMkRBQTJEO0FBQ25GLHdCQUF3QiwyREFBMkQ7QUFDbkYsMkJBQTJCLDJEQUEyRDtBQUN0Riw2QkFBNkIsMkRBQTJEO0FBQ3hGLHlCQUF5QiwyREFBMkQ7QUFDcEYseUJBQXlCLDJEQUEyRDtBQUNwRiwyQkFBMkIsMkRBQTJEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUEyRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRUFBaUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hELDJCQUEyQixtQkFBbUI7QUFDOUMsNkJBQTZCLG1CQUFtQjtBQUNoRCxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DLDRCQUE0QixtQkFBbUI7QUFDL0Msd0JBQXdCLG1CQUFtQjtBQUMzQyx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRCwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25ELGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDLDZCQUE2QixrQkFBa0I7QUFDL0MsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDOVdhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxrQkFBa0I7QUFDcEMscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELHdDQUF3QyxtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRSxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWM7QUFDeEMsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFrQztBQUM3RCxrQkFBa0I7QUFDbEIsOEJBQThCO0FBQzlCLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQSxvSEFBb0gsYUFBYTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQSxvSEFBb0gsd0JBQXdCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxnQkFBZ0I7QUFDckg7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGlFQUFpRSx1QkFBdUIsaUhBQWlIO0FBQ3pNO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyRUFBMkU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxVQUFVO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJFQUEyRTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkUsK0NBQStDLHFEQUFxRDtBQUNwRyx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsWUFBWTtBQUM3RSxpRUFBaUUsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0NBQW9DO0FBQzVGO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCOzs7Ozs7Ozs7O0FDcFZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQix5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsbUJBQU8sQ0FBQywyRkFBb0I7QUFDNUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQ3JCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDL0Msd0NBQXdDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BFLHdDQUF3QyxtQkFBTyxDQUFDLHlGQUFtQjtBQUNuRSxvRkFBb0YsVUFBVTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLGNBQWM7QUFDakQ7Ozs7Ozs7Ozs7QUNyQ2E7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsNkJBQTZCLG1CQUFPLENBQUMsd0dBQThCO0FBQ25FLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFrQztBQUM3RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFrRCxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwyQkFBMkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLFVBQVU7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csVUFBVTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsK0JBQStCO0FBQzFGO0FBQ0Esa0VBQWtFLDJCQUEyQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUN6SGE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxtQkFBbUI7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QyxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUUsWUFBWSxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCx5QkFBeUIscURBQXFELFdBQVcsbUJBQW1CO0FBQzVHOzs7Ozs7Ozs7O0FDdkVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCO0FBQ2pILHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsK0JBQStCO0FBQy9CLGVBQWUsdUJBQXVCO0FBQ3RDLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDakZhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDakQsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDN0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQ2hCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQWtDO0FBQzdELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsaUVBQWlFO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7Ozs7Ozs7Ozs7QUN6RWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMseUNBQXlDLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3JFO0FBQ0EscUJBQXFCLFVBQVUsSUFBSSxPQUFPO0FBQzFDLHFCQUFxQixRQUFRLElBQUksU0FBUztBQUMxQztBQUNBLHdCQUF3QixLQUFLO0FBQzdCLHFCQUFxQixnQkFBZ0IsSUFBSSxjQUFjO0FBQ3ZELHFCQUFxQixjQUFjLElBQUksZ0JBQWdCO0FBQ3ZEO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isd0JBQXdCLFFBQVEsSUFBSSxrQkFBa0IsSUFBSSxPQUFPO0FBQ2pFLHdCQUF3QixjQUFjLElBQUksK0JBQStCLElBQUksY0FBYztBQUMzRjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDdkJhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFrQztBQUM3RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNEQUFzRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0NBQWtDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx1Q0FBdUM7QUFDN0Y7QUFDQTtBQUNBLDBDQUEwQyxpQ0FBaUM7QUFDM0U7QUFDQSxrREFBa0Qsc0NBQXNDO0FBQ3hGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmOzs7Ozs7Ozs7O0FDcERhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCwyQkFBMkIsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3ZELG1CQUFPLENBQUMsMEdBQXlCO0FBQ2pDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDekJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlDLGlDQUFpQyxtQkFBTyxDQUFDLHNFQUFhO0FBQ3RELGtDQUFrQyxtQkFBTyxDQUFDLGtHQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCOzs7Ozs7Ozs7O0FDekZhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkNBQTZDLG1CQUFPLENBQUMsd0dBQXdCO0FBQzdFLHdDQUF3QyxtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzlDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxrQ0FBa0MsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGVBQWU7QUFDcEUscURBQXFELGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EscUVBQXFFLDRDQUE0QztBQUNqSDtBQUNBLE1BQU07QUFDTix1REFBdUQ7QUFDdkQseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixNQUFNO0FBQzlGLDBGQUEwRixNQUFNO0FBQ2hHLDhGQUE4RixzREFBc0Q7QUFDcEo7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG9EQUFvRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0RBQW9EO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELDJEQUEyRDtBQUMzRCw2REFBNkQ7QUFDN0Qsb0VBQW9FO0FBQ3BFLHlEQUF5RCxnREFBZ0Q7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EscUVBQXFFLDRDQUE0QztBQUNqSDtBQUNBLE1BQU07QUFDTix1REFBdUQ7QUFDdkQseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmOzs7Ozs7Ozs7O0FDbFBhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLDBCQUEwQixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQjtBQUNySyxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlDQUF5QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1CQUFtQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUseUNBQXlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDBCQUEwQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7Ozs7Ozs7Ozs7QUN4VWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELGdDQUFnQyxtQkFBTyxDQUFDLG9IQUFvQztBQUM1RSxxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrREFBa0Q7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkIsdURBQXVELFdBQVcscUJBQXFCO0FBQ2xIOzs7Ozs7Ozs7O0FDdENhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0I7QUFDOUYseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFLG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMsb0dBQTRCO0FBQ2hFLHNCQUFzQixtQkFBTyxDQUFDLDhGQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQkFBMkI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzNLYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHdCQUF3QjtBQUN6RCx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSyxRQUFRO0FBQ3BELENBQUM7QUFDRDtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw4QkFBOEI7QUFDekY7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxvQkFBb0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUNuRWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5Qyx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsd0JBQXdCLG1CQUFPLENBQUMseUZBQW1CO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLG1GQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnREFBZ0Qsd0NBQXdDO0FBQ3hGO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzdCYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDekVhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM3RWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLG9CQUFvQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Ysb0JBQW9CO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUN4SWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxzQkFBc0I7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGVBQWUscUJBQXFCO0FBQ3BDLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUMxR2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsc0JBQXNCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5Qyx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0QsMEJBQTBCLHdEQUF3RCxXQUFXLHNCQUFzQjtBQUNuSDs7Ozs7Ozs7OztBQ3ZCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDO0FBQ2pDLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBMEI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlDLHdDQUF3QyxtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRSxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBYztBQUN4Qyw2Q0FBNkMsbUJBQU8sQ0FBQyxvSEFBb0M7QUFDekYsMkJBQTJCLG1CQUFPLENBQUMsZ0hBQWtDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25ELCtGQUErRixJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLHFEQUFxRDtBQUNyRDtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzdGYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUI7QUFDN0UseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHFCQUFxQixtQkFBTyxDQUFDLHdGQUFzQjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRSx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLG1CQUFtQjtBQUN2RztBQUNBO0FBQ0EscUNBQXFDLFlBQVksV0FBVyxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1EQUFtRCxpQ0FBaUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDdEphO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSw4RUFBOEUsc0JBQXNCO0FBQ3BHO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZELDBDQUEwQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixVQUFVO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsK0NBQStDLFVBQVU7QUFDOUcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBd0M7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsVUFBVTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNsTGE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUI7QUFDL0UseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRCw0QkFBNEIsd0RBQXdELFdBQVcsc0JBQXNCO0FBQ3JIOzs7Ozs7Ozs7O0FDN0JhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsdUJBQXVCO0FBQ3ZELHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ3BELDBDQUEwQyxtQkFBTyxDQUFDLDhHQUFpQztBQUNuRixtQ0FBbUMsbUJBQU8sQ0FBQyxnSUFBMEM7QUFDckYsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDOUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1Qix5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUIsZUFBZSw0QkFBNEI7QUFDM0MsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDdkJhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsdUNBQXVDLG1CQUFPLENBQUMsc0ZBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLHFEQUFxRCxXQUFXLDBCQUEwQjtBQUNuSDs7Ozs7Ozs7OztBQ2hCYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUN6RGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQjtBQUM3RSx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlDLG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBMEI7QUFDckQsbUJBQU8sQ0FBQyx1R0FBd0I7QUFDaEMseUJBQXlCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3JELHlCQUF5QixtQkFBTyxDQUFDLCtGQUFvQjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBcUI7QUFDdkQsb0JBQW9CO0FBQ3BCO0FBQ0EsMERBQTBELElBQUk7QUFDOUQsMkRBQTJELFdBQVcsK0JBQStCLGdCQUFnQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFVBQVU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsZ0ZBQWdGLFVBQVU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzdJYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixvQkFBb0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDaEQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCOzs7Ozs7Ozs7O0FDL0RhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0NBQXdDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BFLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDcEQsNEJBQTRCLG1CQUFPLENBQUMscUdBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUIsRUFBRSxRQUFRLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUssVUFBVSxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0IsUUFBUSxZQUFZO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLFlBQVksS0FBSyxHQUFHLEdBQUcsWUFBWSxLQUFLLFVBQVUsR0FBRyxZQUFZLEtBQUssR0FBRyxHQUFHLFlBQVksS0FBSztBQUNuSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQ0FBZ0M7QUFDaEMsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0QyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUM5SGE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDcEQsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFLHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELG1CQUFtQixtQkFBTyxDQUFDLGdHQUFrQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBMEI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQTBCO0FBQ3JELDBDQUEwQyxtQkFBTyxDQUFDLDhHQUFpQztBQUNuRiw2Q0FBNkMsbUJBQU8sQ0FBQyxvSEFBb0M7QUFDekYseUJBQXlCLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3JELHdCQUF3QjtBQUN4QjtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csVUFBVTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNEJBQTRCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVSxvQkFBb0IsSUFBSSxnREFBZ0Q7QUFDbkssYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsc0JBQXNCO0FBQ2pGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFFBQVEsSUFBSSxJQUFJLHNCQUFzQixHQUFHLGFBQWEsR0FBRztBQUNoSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLLDJDQUEyQyxLQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEIsZUFBZSxxQ0FBcUMsSUFBSTtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQXlEO0FBQ2xHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxxRUFBcUUsNERBQTRELFlBQVksa0VBQWtFLElBQUk7QUFDbk47QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUNBQXFDO0FBQzVGO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWdFLEVBQUUsT0FBTztBQUN0RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUNBQXlDO0FBQ3ZHLHlCQUF5Qiw0RUFBNEU7QUFDckcscUJBQXFCLDJDQUEyQztBQUNoRTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0MsYUFBYSxxQ0FBcUM7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckMsaUJBQWlCLHlEQUF5RDtBQUMxRSxhQUFhLHVDQUF1QztBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQSxpQkFBaUIsc0RBQXNEO0FBQ3ZFLGFBQWEscUNBQXFDO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxVQUFVO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3ZlYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOzs7Ozs7Ozs7O0FDbEdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ25ELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUEwQjtBQUNyRCw0QkFBNEIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDM0Qsa0NBQWtDLG1CQUFPLENBQUMsaUhBQTZCO0FBQ3ZFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0RkFBNEY7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDekZhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHVDQUF1QyxtQkFBTyxDQUFDLDRGQUF3QjtBQUN2RSxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDcEQsd0JBQXdCLG1CQUFPLENBQUMsMkZBQW1DO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxFQUFFLE9BQU8sbUJBQW1CLFNBQVMsa0JBQWtCLE9BQU8sSUFBSTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxFQUFFLE9BQU8sbUJBQW1CLFFBQVEsbUJBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUIsSUFBSSxtQkFBbUIsU0FBUyxrQkFBa0IsT0FBTyxJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsUUFBUSxnQkFBZ0IsT0FBTyxLQUFLLE9BQU8sS0FBSztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRSxXQUFXLHNCQUFzQixFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLFVBQVU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkIsdURBQXVELFdBQVcscUJBQXFCO0FBQ2xIOzs7Ozs7Ozs7O0FDeERhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCwyQkFBMkIsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDekQsMENBQTBDLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3ZFLG1CQUFPLENBQUMsMEdBQXlCO0FBQ2pDLHdDQUF3QyxtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRSxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDL0M7QUFDQSwwR0FBMEc7QUFDMUcsaUVBQWlFLElBQUk7QUFDckUsZ0hBQWdILElBQUk7QUFDcEgsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0JBQXNCO0FBQ3RCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzFEYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsSUFBSSxpQkFBaUIsR0FBRztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxHQUFHO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjs7Ozs7Ozs7OztBQ3pEYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZDQUE2QyxtQkFBTyxDQUFDLHdHQUF3QjtBQUM3RSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUNmYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsc0JBQXNCLG1CQUFPLENBQUMsOEVBQWlCO0FBQy9DLHVDQUF1QyxtQkFBTyxDQUFDLDRGQUF3QjtBQUN2RSxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsMENBQTBDLG1CQUFPLENBQUMsa0dBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMsa0RBQWtELHdCQUF3QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmOzs7Ozs7Ozs7O0FDeEphO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDLGtCQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUNoTGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RDtBQUNBLG1EQUFtRDtBQUNuRCw0REFBNEQsMkNBQTJDO0FBQ3ZHO0FBQ0E7QUFDQSw2QkFBNkIseURBQXlELFNBQVMscUJBQXFCO0FBQ3BIOzs7Ozs7Ozs7O0FDVmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUNoRGE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLDJGQUFtQjtBQUNuRCxtQkFBTyxDQUFDLGlHQUFzQjtBQUM5Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQ2pDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHFCQUFxQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjtBQUNoQjs7Ozs7Ozs7OztBQ3JGYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QywwQ0FBMEMsbUJBQU8sQ0FBQywrRkFBcUI7QUFDdkUsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELHdDQUF3QyxtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBa0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQsZ0NBQWdDLE9BQU87QUFDdkMseUNBQXlDLE9BQU87QUFDaEQsNkJBQTZCLE9BQU87QUFDcEMsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCLHlEQUF5RDtBQUN0Rix1QkFBdUIseURBQXlEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBeUQ7QUFDekYsQ0FBQztBQUNEO0FBQ0EsdUJBQXVCLDJEQUEyRDtBQUNsRiw0QkFBNEIsMkRBQTJEO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLElBQUk7QUFDeEQsa0NBQWtDLFNBQVMsSUFBSTtBQUMvQywwQ0FBMEMsU0FBUyxJQUFJO0FBQ3ZELGtDQUFrQyxTQUFTLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDLDREQUE0RDtBQUM1RCxnREFBZ0QsUUFBUTtBQUN4RCxvQ0FBb0MsUUFBUTtBQUM1QyxvQ0FBb0MsVUFBVTtBQUM5Qyw0Q0FBNEMsR0FBRyxLQUFLO0FBQ3BELDRDQUE0QyxHQUFHLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQywrQkFBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DLCtCQUErQixHQUFHO0FBQ2xDLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUcsSUFBSSxHQUFHO0FBQzlDLDhCQUE4QixHQUFHLElBQUksR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQ25PYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLG1CQUFPLENBQUMsNEZBQXdCO0FBQ3ZFLHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQWtDO0FBQzdELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQ1g7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9DQUFvQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekMsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNENBQTRDLE1BQU0sR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHFDQUFxQztBQUNyQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsb0NBQW9DO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRCxVQUFVLGdEQUFnRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQixPQUFPLGlCQUFpQjtBQUM5RCw0QkFBNEIsZ0JBQWdCLGVBQWUsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0IsMkJBQTJCLGdCQUFnQixjQUFjLGlCQUFpQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCLE9BQU8saUJBQWlCO0FBQzlELDRCQUE0QixnQkFBZ0IsZUFBZSxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQixPQUFPLGlCQUFpQjtBQUM5RCw0QkFBNEIsZ0JBQWdCLGVBQWUsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCLG9CQUFvQixpQkFBaUI7QUFDekUsMEJBQTBCLGdCQUFnQixvQ0FBb0MsaUJBQWlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0Isb0JBQW9CLGlCQUFpQjtBQUN6RSwwQkFBMEIsZ0JBQWdCLG9DQUFvQyxpQkFBaUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQixlQUFlLGtCQUFrQixlQUFlLGtCQUFrQjtBQUMzRywyQkFBMkIsaUJBQWlCLE9BQU8sa0JBQWtCLE9BQU8sa0JBQWtCO0FBQzlGLDRCQUE0QixpQkFBaUIsY0FBYyxrQkFBa0IsYUFBYSxrQkFBa0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5Qyw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCLGlCQUFpQixjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQyw2Q0FBNkMsZ0JBQWdCLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0IsTUFBTSxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUM1bkJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsc0JBQXNCO0FBQ3hELHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFpQjtBQUM5RCxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBYztBQUN4Qyx1Q0FBdUMsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDdkUsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQTBCO0FBQ3JELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILEdBQUcsaUJBQWlCLEdBQUc7QUFDekk7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzdIYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyx1QkFBdUI7QUFDeEQseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLG9FQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQsa0NBQWtDLHlCQUF5QjtBQUMzRCxnQ0FBZ0MsNkNBQTZDO0FBQzdFLHVDQUF1Qyw2Q0FBNkM7QUFDcEY7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQy9EYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELG1CQUFPLENBQUMsb0dBQXVCO0FBQy9CLDZCQUE2QjtBQUM3QixlQUFlO0FBQ2YsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDUmE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELDZCQUE2QixtQkFBTyxDQUFDLG9IQUFvQztBQUN6RSxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsc0JBQXNCLG1CQUFPLENBQUMsc0dBQTZCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsb0JBQW9CLElBQUk7QUFDcEc7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7QUM1SWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLDZCQUE2QjtBQUMvRCx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsd0NBQXdDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BFLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFZO0FBQ3BDLHFCQUFxQixtQkFBTyxDQUFDLHdGQUFzQjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQywwRkFBaUI7QUFDL0MsNkJBQTZCLG1CQUFPLENBQUMsd0dBQXdCO0FBQzdELG1CQUFPLENBQUMsMEdBQXlCO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDJCQUEyQixJQUFJO0FBQ2pHO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVEQUF1RDtBQUM1RztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQ3ZFYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELDZCQUE2QixtQkFBTyxDQUFDLHdHQUF3QjtBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyw0QkFBNEIsUUFBUTtBQUNwQyx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzlHYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQTBCO0FBQ3JELHVDQUF1QyxtQkFBTyxDQUFDLDRGQUF3QjtBQUN2RSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMzSWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIscUNBQXFDLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlELG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQWtDO0FBQzdELG9DQUFvQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1RCxxQkFBcUIsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0RBQXdELDhDQUE4QztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDJCQUEyQixJQUFJO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixVQUFVO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjs7Ozs7Ozs7OztBQzNMYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHNCQUFzQjtBQUNyRCx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDOUQsb0NBQW9DLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLGtGQUEyQjtBQUN2RCxzQkFBc0I7QUFDdEI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRCw0QkFBNEIsd0RBQXdELFdBQVcsc0JBQXNCO0FBQ3JIOzs7Ozs7Ozs7O0FDakVhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1Qix5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCLGVBQWUsb0JBQW9CO0FBQ25DLENBQUM7QUFDRDs7Ozs7Ozs7OztBQzFEYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLG1CQUFtQjtBQUMvQyx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QyxvQ0FBb0MsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUQsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhEQUE4RDtBQUNoSDtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELHlCQUF5QixxREFBcUQsV0FBVyxtQkFBbUI7QUFDNUc7Ozs7Ozs7Ozs7QUM5QmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1DQUFtQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseVFBQXlRLEVBQUU7QUFDM1EsOE5BQThOLEVBQUU7QUFDaE87QUFDQTtBQUNBLDJOQUEyTixFQUFFO0FBQzdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU9BQWlPLGNBQWM7QUFDL087QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYixzSEFBc0gsY0FBYztBQUNwSTtBQUNBLHNGQUFzRixJQUFJO0FBQzFGLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZUFBZSx1QkFBdUIsU0FBUyxTQUFTLElBQUksS0FBSztBQUNqRSxjQUFjLGNBQWM7QUFDNUIsZ0JBQWdCLGtCQUFrQjtBQUNsQyx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTSxzQkFBc0IsMERBQTBELGFBQWEsS0FBSztBQUN2SCwyQ0FBMkMsNEVBQTRFO0FBQ3ZIO0FBQ0EscUJBQXFCLHNCQUFzQiwyRUFBMkUsS0FBSyxhQUFhLEtBQUssZUFBZTtBQUM1SixtQkFBbUIsc0JBQXNCLDJFQUEyRSxLQUFLLFNBQVM7QUFDbEk7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNLHNCQUFzQiwwREFBMEQsYUFBYSxLQUFLO0FBQ3ZILDJDQUEyQyw0RUFBNEU7QUFDdkg7QUFDQSxxQkFBcUIsc0JBQXNCLDJFQUEyRSxLQUFLLGFBQWEsS0FBSyxlQUFlO0FBQzVKLG1CQUFtQixzQkFBc0IsMkVBQTJFLEtBQUssU0FBUztBQUNsSTtBQUNBO0FBQ0EsZUFBZSxRQUFRLEVBQUU7QUFDekIsZUFBZSxPQUFPLEVBQUU7QUFDeEIsY0FBYyxJQUFJLHNCQUFzQiw2REFBNkQsS0FBSyxTQUFTO0FBQ25ILGNBQWMsTUFBTSxzQkFBc0IseURBQXlELGFBQWEsS0FBSztBQUNySCx3Q0FBd0MsMkVBQTJFO0FBQ25ILGVBQWUsTUFBTTtBQUNyQiwwRUFBMEUsYUFBYTtBQUN2RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRSxvQkFBb0IsTUFBTSxzQkFBc0IsK0RBQStELGFBQWEsS0FBSztBQUNqSTtBQUNBO0FBQ0EsMENBQTBDLDJFQUEyRTtBQUNySDtBQUNBLCtCQUErQjtBQUMvQixvQkFBb0Isc0JBQXNCLDBFQUEwRSxLQUFLLGFBQWEsS0FBSyxlQUFlO0FBQzFKLGtCQUFrQixzQkFBc0IsMEVBQTBFLEtBQUssU0FBUztBQUNoSTtBQUNBLDhDQUE4QztBQUM5QyxrQ0FBa0MsSUFBSSxlQUFlLElBQUk7QUFDekQ7QUFDQSxvQkFBb0IsTUFBTSxzQkFBc0IsK0RBQStELGFBQWEsS0FBSyxhQUFhLEtBQUs7QUFDbkosdUJBQXVCLE1BQU0sc0JBQXNCLGtFQUFrRSxhQUFhLEtBQUssYUFBYSxLQUFLO0FBQ3pKLHdCQUF3QixNQUFNLHNCQUFzQixtRUFBbUUsYUFBYSxLQUFLLGFBQWEsS0FBSztBQUMzSiwwQkFBMEIsTUFBTSxzQkFBc0IscUVBQXFFLGFBQWEsTUFBTSxhQUFhLEtBQUs7QUFDaEsscUJBQXFCLE1BQU0sc0JBQXNCLGdFQUFnRSxhQUFhLEtBQUs7QUFDbkkscUJBQXFCLE9BQU8sTUFBTTtBQUNsQyxnRkFBZ0YsYUFBYSxLQUFLLGFBQWE7QUFDL0csZ0dBQWdHLE1BQU0sYUFBYTtBQUNuSCxhQUFhO0FBQ2Isa0JBQWtCLE1BQU0sc0JBQXNCLDZEQUE2RCxhQUFhLEtBQUs7QUFDN0gsa0JBQWtCLE1BQU0sc0JBQXNCLDZEQUE2RCxhQUFhLEtBQUs7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQ0FBMEMsK0JBQStCO0FBQ3pFLDZDQUE2QyxJQUFJO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsaUNBQWlDLG1CQUFtQjtBQUN6RixxQ0FBcUMsaUNBQWlDLG1CQUFtQjtBQUN6RixxQ0FBcUMsaUNBQWlDLG1CQUFtQjtBQUN6RixxQ0FBcUMsaUNBQWlDLG1CQUFtQjtBQUN6RixxQ0FBcUMsaUNBQWlDLG1CQUFtQjtBQUN6RixxQ0FBcUMsaUNBQWlDLG1CQUFtQjtBQUN6RixzQ0FBc0MsbUNBQW1DLG1CQUFtQjtBQUM1Rix3Q0FBd0MseUNBQXlDLG1CQUFtQjtBQUNwRyw4Q0FBOEMsU0FBUyxhQUFhO0FBQ3BFLGdEQUFnRCxTQUFTLG9CQUFvQjtBQUM3RSxtREFBbUQsU0FBUyxpQ0FBaUM7QUFDN0Ysd0NBQXdDLFdBQVc7QUFDbkQsNkNBQTZDLFdBQVc7QUFDeEQsc0NBQXNDLFNBQVMsdUJBQXVCO0FBQ3RFLHdDQUF3QyxxQ0FBcUM7QUFDN0UsNENBQTRDLHlDQUF5QztBQUNyRixrREFBa0QsK0NBQStDO0FBQ2pHLDJDQUEyQyxTQUFTLGlDQUFpQztBQUNyRixpREFBaUQsU0FBUyw4QkFBOEI7QUFDeEYsc0NBQXNDLG1DQUFtQztBQUN6RSxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCLFlBQVksMEJBQTBCLEdBQUcsVUFBVSwwQkFBMEIsR0FBRztBQUMzRyxpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCLFlBQVksMEJBQTBCLEdBQUcsVUFBVSwwQkFBMEIsR0FBRztBQUMzRyxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdELDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQSxrQ0FBa0M7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakI7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFLDhCQUE4QiwyQ0FBMkM7QUFDekUsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0QsNkJBQTZCLCtCQUErQjtBQUM1RCwyQkFBMkIsZ0NBQWdDO0FBQzNELCtCQUErQixnQ0FBZ0M7QUFDL0QsNEJBQTRCLDJDQUEyQztBQUN2RSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBLG9DQUFvQyxrQ0FBa0MsbUNBQW1DO0FBQ3pHLGlCQUFpQjtBQUNqQjtBQUNBLG9DQUFvQztBQUNwQyxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkIsd0RBQXdEO0FBQ3JGLDJCQUEyQiwrQkFBK0I7QUFDMUQsMkJBQTJCLHNCQUFzQiw0QkFBNEIsbUJBQW1CO0FBQ2hHLDJCQUEyQixnQ0FBZ0M7QUFDM0QsNEJBQTRCLGdDQUFnQztBQUM1RCwrQkFBK0Isc0JBQXNCLDRCQUE0QjtBQUNqRixpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkIsc0JBQXNCLG1DQUFtQztBQUN0RixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsc0JBQXNCLG1DQUFtQyxtQkFBbUI7QUFDdkcsMkJBQTJCLHNCQUFzQixtQ0FBbUM7QUFDcEYsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCLFlBQVksNEJBQTRCLDJCQUEyQiw0QkFBNEIsbUJBQW1CO0FBQ2pKLDJCQUEyQixXQUFXLDhCQUE4QjtBQUNwRSwyQkFBMkIsc0JBQXNCLG1DQUFtQyxtQkFBbUI7QUFDdkcsNEJBQTRCLFlBQVksNEJBQTRCLElBQUksNEJBQTRCLG1CQUFtQjtBQUN2SCwyQkFBMkIsZUFBZTtBQUMxQywyQkFBMkIsV0FBVyxxQ0FBcUMsa0JBQWtCO0FBQzdGLDJCQUEyQixXQUFXLHFDQUFxQyxrQkFBa0I7QUFDN0YsaUNBQWlDLFdBQVcsb0NBQW9DLGtCQUFrQjtBQUNsRyxnQ0FBZ0Msc0JBQXNCLDRCQUE0QjtBQUNsRixpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsK0NBQStDLCtCQUErQjtBQUM5RSw4QkFBOEIsMkNBQTJDO0FBQ3pFLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFELDZCQUE2QixnQ0FBZ0M7QUFDN0QsMkJBQTJCLDJDQUEyQztBQUN0RSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsMkJBQTJCLHFCQUFxQjtBQUNoRCw2QkFBNkIsb0JBQW9CO0FBQ2pELHlDQUF5QyxtQ0FBbUM7QUFDNUUsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QixzQkFBc0IsZ0RBQWdELEdBQUc7QUFDdEcsMkJBQTJCLHNCQUFzQixnREFBZ0Q7QUFDakcsaUJBQWlCO0FBQ2pCO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRCxnQ0FBZ0M7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0Esd0NBQXdDLHNCQUFzQiw4QkFBOEIsbUJBQW1CO0FBQy9HLDJCQUEyQixZQUFZLDRCQUE0QixJQUFJLHFDQUFxQztBQUM1RyxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsc0JBQXNCLDhDQUE4QztBQUMvRixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixnQ0FBZ0MsaUVBQWlFO0FBQ2pHLGlDQUFpQyxpRUFBaUU7QUFDbEcsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsMENBQTBDLHVEQUF1RDtBQUNqRyw2Q0FBNkM7QUFDN0MsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsa0NBQWtDLCtCQUErQjtBQUNqRSwyQkFBMkIsZ0NBQWdDO0FBQzNELDZCQUE2QixrQ0FBa0M7QUFDL0QsMkJBQTJCLGdDQUFnQztBQUMzRCxzQ0FBc0M7QUFDdEMsaUJBQWlCO0FBQ2pCLDRCQUE0QixPQUFPO0FBQ25DLGtDQUFrQywrQkFBK0I7QUFDakUsMkJBQTJCLGdDQUFnQztBQUMzRCw2QkFBNkIsa0NBQWtDO0FBQy9ELDJCQUEyQixnQ0FBZ0M7QUFDM0QsbUNBQW1DLGVBQWU7QUFDbEQsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQixtQkFBbUIsdUJBQXVCO0FBQzFDLHdDQUF3QztBQUN4QyxpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU0scUJBQXFCLE9BQU87QUFDckQsa0NBQWtDLCtCQUErQjtBQUNqRSwyQkFBMkIsZ0NBQWdDO0FBQzNELDZCQUE2QiwrQkFBK0I7QUFDNUQsNkJBQTZCLGdDQUFnQztBQUM3RCxvQ0FBb0M7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0EsdURBQXVELFlBQVksNEJBQTRCO0FBQy9GLGlCQUFpQjtBQUNqQjtBQUNBLHdDQUF3QyxZQUFZLDRCQUE0QixJQUFJLDRCQUE0QjtBQUNoSCxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLDJCQUEyQixZQUFZLDRCQUE0QixJQUFJLHFDQUFxQztBQUM1RyxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLDJCQUEyQixXQUFXLDRCQUE0QjtBQUNsRSxpQkFBaUI7QUFDakIsa0JBQWtCLElBQUk7QUFDdEIsNkNBQTZDLCtCQUErQjtBQUM1RSwwQ0FBMEM7QUFDMUMsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUMsNkNBQTZDLCtCQUErQjtBQUM1RSw4QkFBOEIsZUFBZTtBQUM3Qyx3Q0FBd0M7QUFDeEMsaUJBQWlCO0FBQ2pCLHdCQUF3QixNQUFNO0FBQzlCLDJCQUEyQixZQUFZLDRCQUE0QjtBQUNuRSxpQkFBaUI7QUFDakIsd0JBQXdCLE1BQU07QUFDOUIsMkJBQTJCLFlBQVksNEJBQTRCO0FBQ25FLGlCQUFpQjtBQUNqQiwyQkFBMkIsTUFBTTtBQUNqQywyQkFBMkIsWUFBWSw0QkFBNEI7QUFDbkUsaUJBQWlCO0FBQ2pCLDRCQUE0QixNQUFNO0FBQ2xDLDJCQUEyQixZQUFZLDRCQUE0QjtBQUNuRSxpQkFBaUI7QUFDakIsOEJBQThCLE1BQU07QUFDcEMsMkJBQTJCLFlBQVksNEJBQTRCO0FBQ25FLGlCQUFpQjtBQUNqQix5QkFBeUIsT0FBTyxNQUFNO0FBQ3RDLDJCQUEyQixZQUFZLDRCQUE0QjtBQUNuRSxpQkFBaUI7QUFDakIseUJBQXlCLE1BQU07QUFDL0IsMkJBQTJCLFlBQVksNEJBQTRCO0FBQ25FLGlCQUFpQjtBQUNqQixzQkFBc0IsTUFBTTtBQUM1QiwyQkFBMkIsWUFBWSw0QkFBNEI7QUFDbkUsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLFlBQVksNEJBQTRCO0FBQ25FLGlCQUFpQjtBQUNqQixzQkFBc0IsTUFBTTtBQUM1QiwyQkFBMkIsc0JBQXNCLDBCQUEwQixHQUFHLFVBQVUsMEJBQTBCLEdBQUc7QUFDckgsaUJBQWlCO0FBQ2pCLHdCQUF3QixNQUFNO0FBQzlCLGtEQUFrRCwyQ0FBMkM7QUFDN0YsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixZQUFZLDRCQUE0QjtBQUNuRSxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsa0RBQWtEO0FBQzdFLDRCQUE0QiwrREFBK0Q7QUFDM0YseUNBQXlDLG9EQUFvRDtBQUM3RiwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwrQ0FBK0Msa0JBQWtCLG1CQUFtQjtBQUNwRixnREFBZ0QsbUJBQW1CLG1CQUFtQjtBQUN0RiwyREFBMkQsaUNBQWlDLG1CQUFtQjtBQUMvRyw0REFBNEQsa0NBQWtDLG1CQUFtQjtBQUNqSCwwREFBMEQsOEJBQThCLG1CQUFtQjtBQUMzRywwREFBMEQsOEJBQThCLG1CQUFtQjtBQUMzRztBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQiw2Q0FBNkMsY0FBYyxtQkFBbUI7QUFDOUUsK0NBQStDLGdCQUFnQixtQkFBbUI7QUFDbEYsOENBQThDLGVBQWUsbUJBQW1CO0FBQ2hGLCtDQUErQyxnQkFBZ0IsbUJBQW1CO0FBQ2xGLDhDQUE4QyxlQUFlLG1CQUFtQjtBQUNoRix3REFBd0QsU0FBUztBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsaUJBQWlCO0FBQ2pCLHNCQUFzQixNQUFNO0FBQzVCLDJCQUEyQixZQUFZLDBCQUEwQixHQUFHLFVBQVUsMEJBQTBCLEdBQUc7QUFDM0csaUJBQWlCO0FBQ2pCLHdCQUF3QixNQUFNO0FBQzlCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixrQkFBa0IsTUFBTTtBQUN4QiwyQkFBMkIsWUFBWSwwQkFBMEIsR0FBRyxZQUFZLDBCQUEwQixHQUFHO0FBQzdHLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLGtCQUFrQixJQUFJO0FBQ3RCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCLHNCQUFzQiwwQkFBMEIsR0FBRyxVQUFVLDBCQUEwQixHQUFHO0FBQ3JILGlCQUFpQjtBQUNqQiw0QkFBNEIsTUFBTTtBQUNsQywyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixrQkFBa0IsTUFBTTtBQUN4QiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsaUJBQWlCO0FBQ2pCLHlCQUF5QixPQUFPLE1BQU07QUFDdEMsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQix5QkFBeUIsTUFBTTtBQUMvQiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQixNQUFNO0FBQzVCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCLFlBQVksMEJBQTBCLEdBQUcsVUFBVSwwQkFBMEIsR0FBRztBQUMzRyxpQkFBaUI7QUFDakIsNEJBQTRCLE1BQU07QUFDbEMsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkIsV0FBVztBQUN0QyxpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixrQkFBa0IsTUFBTTtBQUN4QiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHlCQUF5QixPQUFPLE1BQU07QUFDdEMsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQix5QkFBeUIsTUFBTTtBQUMvQiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQixNQUFNO0FBQzVCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCLFlBQVksMEJBQTBCLEdBQUcsVUFBVSwwQkFBMEIsR0FBRztBQUMzRyxpQkFBaUI7QUFDakIsNEJBQTRCLE1BQU07QUFDbEMsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixzQkFBc0IsTUFBTTtBQUM1QiwyQkFBMkIsc0JBQXNCLDBCQUEwQixHQUFHLFVBQVUsMEJBQTBCLEdBQUc7QUFDckgsaUJBQWlCO0FBQ2pCLGtCQUFrQixJQUFJLFlBQVksTUFBTTtBQUN4QywyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCLE1BQU07QUFDNUIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixzQkFBc0IsTUFBTTtBQUM1QiwyQkFBMkIsc0JBQXNCLDBCQUEwQixHQUFHLFVBQVUsMEJBQTBCLEdBQUc7QUFDckgsaUJBQWlCO0FBQ2pCLGtCQUFrQixJQUFJLFlBQVksTUFBTTtBQUN4QywyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHlEQUF5RCxnQ0FBZ0MsVUFBVSxHQUFHLG1CQUFtQjtBQUN6SDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixrQkFBa0IsTUFBTTtBQUN4Qiw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCLFdBQVcsbUNBQW1DO0FBQzNFLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixrQkFBa0IsSUFBSTtBQUN0Qiw2QkFBNkIsK0JBQStCO0FBQzVELDJCQUEyQiwwQ0FBMEM7QUFDckUsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBLGlCQUFpQjtBQUNqQix3REFBd0QsU0FBUyx3Q0FBd0M7QUFDekcsdUNBQXVDLFNBQVMsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFLFFBQVEsRUFBRSxPQUFPO0FBQ3hGLHFFQUFxRSxFQUFFLFFBQVEsRUFBRSxPQUFPO0FBQ3hGO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRSxRQUFRLEVBQUUsT0FBTztBQUN4RixxRUFBcUUsRUFBRSxRQUFRLEVBQUUsT0FBTztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsbUJBQW1CLE1BQU07QUFDekIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0QsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixrQkFBa0IsSUFBSTtBQUN0QiwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0MsU0FBUyx3QkFBd0I7QUFDdkUsZ0RBQWdELGdCQUFnQixVQUFVLEdBQUcsbUJBQW1CO0FBQ2hHLHVDQUF1QyxTQUFTLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsTUFBTTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUNBQXVDLFNBQVMsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsT0FBTztBQUNyRTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXLEdBQUc7QUFDM0MsOEJBQThCLFdBQVcsc0JBQXNCLEVBQUUsV0FBVyxzQkFBc0I7QUFDbEc7QUFDQSw2QkFBNkIsV0FBVyxHQUFHO0FBQzNDLDhCQUE4QixXQUFXLFdBQVcsR0FBRyxPQUFPLHNCQUFzQjtBQUNwRiw4QkFBOEIsV0FBVyxFQUFFLE9BQU8sV0FBVyx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLEdBQUc7QUFDL0M7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsR0FBRztBQUMvQyxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsR0FBRztBQUMvQyxrQ0FBa0MsV0FBVyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsR0FBRztBQUMvQyxrQ0FBa0MsV0FBVyxjQUFjO0FBQzNEO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVyxHQUFHO0FBQy9DLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEVBQUU7QUFDN0Usb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCLGVBQWU7QUFDL0Qsb0NBQW9DLHNCQUFzQixXQUFXLFdBQVcsVUFBVTtBQUMxRjtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3Qyx1Q0FBdUM7QUFDL0csb0NBQW9DLHNCQUFzQixXQUFXLFdBQVcsVUFBVTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdDQUF3Qyx1Q0FBdUM7QUFDN0c7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0MsdUNBQXVDO0FBQ2hIO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQXdDLHVDQUF1QztBQUNqSDtBQUNBO0FBQ0Esb0NBQW9DLHVDQUF1QyxFQUFFLHVDQUF1QztBQUNwSDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsb0JBQW9CLDRDQUE0QztBQUNoRztBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVyxnQkFBZ0IsY0FBYztBQUM3RjtBQUNBO0FBQ0Esb0RBQW9ELFdBQVcsZ0JBQWdCLGNBQWM7QUFDN0Y7QUFDQTtBQUNBLG9DQUFvQyxVQUFVLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELG9DQUFvQyxVQUFVLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakMsK0JBQStCLEVBQUU7QUFDakMsK0JBQStCLEVBQUU7QUFDakMsK0JBQStCLEVBQUU7QUFDakMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLGFBQWE7QUFDNUMsZ0NBQWdDLE9BQU8sWUFBWSxHQUFHLFlBQVksY0FBYztBQUNoRixnQ0FBZ0MsT0FBTyxZQUFZLEdBQUcsT0FBTyxZQUFZLGNBQWMsRUFBRTtBQUN6RixpQ0FBaUMsT0FBTyxZQUFZLEdBQUcsT0FBTyxZQUFZLGNBQWMsRUFBRTtBQUMxRixpQ0FBaUMsT0FBTyxZQUFZLEdBQUcsT0FBTyxZQUFZLEdBQUcsYUFBYTtBQUMxRixrQ0FBa0MsUUFBUSxRQUFRLFFBQVE7QUFDMUQsbUNBQW1DLFFBQVEsUUFBUSxRQUFRLFFBQVE7QUFDbkUsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLFlBQVk7QUFDNUMsK0JBQStCLEVBQUU7QUFDakMsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDLGlDQUFpQyxJQUFJO0FBQ3JDLGlDQUFpQyxJQUFJO0FBQ3JDLGlDQUFpQyxJQUFJO0FBQ3JDLGlDQUFpQyxJQUFJO0FBQ3JDLGtDQUFrQyxPQUFPO0FBQ3pDLGtDQUFrQyxPQUFPO0FBQ3pDLG9DQUFvQyxPQUFPO0FBQzNDLHdDQUF3QyxXQUFXO0FBQ25ELDBDQUEwQyxXQUFXO0FBQ3JELDZDQUE2QztBQUM3QywrQ0FBK0M7QUFDL0MsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L0FsbFBhY2thZ2VzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2FjdGlvbi9BY3Rpb25Db25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2Ftcy9BbXNDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2Ftcy9BbXNJdGVtcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9hbXMvQW1zTWFwcGluZ3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYW1zL0Ftc01ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYW1zY2QvQW1zQ2RDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2Ftc2NkL0Ftc0NkTWFwcGluZ3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYW1zY2QvQW1zQ2RNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2Jib3gvQmJveENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYm9sZHN5bWJvbC9Cb2xkc3ltYm9sQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9icmFrZXQvQnJha2V0Q29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9icmFrZXQvQnJha2V0SXRlbXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYnJha2V0L0JyYWtldE1hcHBpbmdzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2JyYWtldC9CcmFrZXRNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2J1c3Nwcm9vZnMvQnVzc3Byb29mc0NvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYnVzc3Byb29mcy9CdXNzcHJvb2ZzSXRlbXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYnVzc3Byb29mcy9CdXNzcHJvb2ZzTWFwcGluZ3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvYnVzc3Byb29mcy9CdXNzcHJvb2ZzTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9idXNzcHJvb2ZzL0J1c3Nwcm9vZnNVdGlsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2NhbmNlbC9DYW5jZWxDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2Nhc2VzL0Nhc2VzQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9jZW50ZXJub3QvQ2VudGVybm90Q29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9jb2xvci9Db2xvckNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvY29sb3IvQ29sb3JDb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvY29sb3IvQ29sb3JNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2NvbG9yL0NvbG9yVXRpbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9jb2xvcnRibC9Db2xvcnRibENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvY29sb3J2Mi9Db2xvclYyQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9jb25maWdtYWNyb3MvQ29uZmlnTWFjcm9zQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9lbXBoZXEvRW1waGVxQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9lbXBoZXEvRW1waGVxVXRpbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9lbmNsb3NlL0VuY2xvc2VDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2V4dHBmZWlsL0V4dHBmZWlsQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9nZW5zeW1iL0dlbnN5bWJDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L2h0bWwvSHRtbENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvaHRtbC9IdG1sTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9tYXRodG9vbHMvTWF0aHRvb2xzQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9tYXRodG9vbHMvTWF0aHRvb2xzSXRlbXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvbWF0aHRvb2xzL01hdGh0b29sc01hcHBpbmdzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L21hdGh0b29scy9NYXRodG9vbHNNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L21hdGh0b29scy9NYXRodG9vbHNUYWdzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L21hdGh0b29scy9NYXRodG9vbHNVdGlsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L21oY2hlbS9NaGNoZW1Db25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L25ld2NvbW1hbmQvTmV3Y29tbWFuZENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvbmV3Y29tbWFuZC9OZXdjb21tYW5kSXRlbXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvbmV3Y29tbWFuZC9OZXdjb21tYW5kTWFwcGluZ3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvbmV3Y29tbWFuZC9OZXdjb21tYW5kTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9uZXdjb21tYW5kL05ld2NvbW1hbmRVdGlsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L25vZXJyb3JzL05vRXJyb3JzQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9ub3VuZGVmaW5lZC9Ob1VuZGVmaW5lZENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvcGh5c2ljcy9QaHlzaWNzQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9waHlzaWNzL1BoeXNpY3NJdGVtcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9waHlzaWNzL1BoeXNpY3NNYXBwaW5ncy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9waHlzaWNzL1BoeXNpY3NNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L3NldG9wdGlvbnMvU2V0T3B0aW9uc0NvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvdGFnZm9ybWF0L1RhZ0Zvcm1hdENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvdGV4dGNvbXAvVGV4dGNvbXBDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L3RleHRjb21wL1RleHRjb21wTWFwcGluZ3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvdGV4dG1hY3Jvcy9UZXh0TWFjcm9zQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC90ZXh0bWFjcm9zL1RleHRNYWNyb3NNYXBwaW5ncy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC90ZXh0bWFjcm9zL1RleHRNYWNyb3NNZXRob2RzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L3RleHRtYWNyb3MvVGV4dFBhcnNlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC91bmljb2RlL1VuaWNvZGVDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L3VwZ3JlZWsvVXBncmVla0NvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvdmVyYi9WZXJiQ29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWhjaGVtcGFyc2VyL2Rpc3QvbWhjaGVtUGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbGxQYWNrYWdlcyA9IHZvaWQgMDtcbnJlcXVpcmUoXCIuL2Jhc2UvQmFzZUNvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi9hY3Rpb24vQWN0aW9uQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2Ftcy9BbXNDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vYW1zY2QvQW1zQ2RDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vYmJveC9CYm94Q29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2JvbGRzeW1ib2wvQm9sZHN5bWJvbENvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi9icmFrZXQvQnJha2V0Q29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2J1c3Nwcm9vZnMvQnVzc3Byb29mc0NvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi9jYW5jZWwvQ2FuY2VsQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2Nhc2VzL0Nhc2VzQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2NlbnRlcm5vdC9DZW50ZXJub3RDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vY29sb3IvQ29sb3JDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vY29sb3J2Mi9Db2xvclYyQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2NvbG9ydGJsL0NvbG9ydGJsQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2NvbmZpZ21hY3Jvcy9Db25maWdNYWNyb3NDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vZW1waGVxL0VtcGhlcUNvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi9lbmNsb3NlL0VuY2xvc2VDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vZXh0cGZlaWwvRXh0cGZlaWxDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vZ2Vuc3ltYi9HZW5zeW1iQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL2h0bWwvSHRtbENvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi9tYXRodG9vbHMvTWF0aHRvb2xzQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL21oY2hlbS9NaGNoZW1Db25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vbmV3Y29tbWFuZC9OZXdjb21tYW5kQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL25vZXJyb3JzL05vRXJyb3JzQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL25vdW5kZWZpbmVkL05vVW5kZWZpbmVkQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL3BoeXNpY3MvUGh5c2ljc0NvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi9zZXRvcHRpb25zL1NldE9wdGlvbnNDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vdGFnZm9ybWF0L1RhZ0Zvcm1hdENvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi90ZXh0Y29tcC9UZXh0Y29tcENvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi90ZXh0bWFjcm9zL1RleHRNYWNyb3NDb25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vdXBncmVlay9VcGdyZWVrQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL3VuaWNvZGUvVW5pY29kZUNvbmZpZ3VyYXRpb24uanNcIik7XG5yZXF1aXJlKFwiLi92ZXJiL1ZlcmJDb25maWd1cmF0aW9uLmpzXCIpO1xuaWYgKHR5cGVvZiBNYXRoSmF4ICE9PSAndW5kZWZpbmVkJyAmJiBNYXRoSmF4LmxvYWRlcikge1xuICAgIE1hdGhKYXgubG9hZGVyLnByZUxvYWQoJ1t0ZXhdL2FjdGlvbicsICdbdGV4XS9hbXMnLCAnW3RleF0vYW1zY2QnLCAnW3RleF0vYmJveCcsICdbdGV4XS9ib2xkc3ltYm9sJywgJ1t0ZXhdL2JyYWtldCcsICdbdGV4XS9idXNzcHJvb2ZzJywgJ1t0ZXhdL2NhbmNlbCcsICdbdGV4XS9jYXNlcycsICdbdGV4XS9jZW50ZXJub3QnLCAnW3RleF0vY29sb3InLCAnW3RleF0vY29sb3J2MicsICdbdGV4XS9jb2xvcnRibCcsICdbdGV4XS9lbXBoZXEnLCAnW3RleF0vZW5jbG9zZScsICdbdGV4XS9leHRwZmVpbCcsICdbdGV4XS9nZW5zeW1iJywgJ1t0ZXhdL2h0bWwnLCAnW3RleF0vbWF0aHRvb2xzJywgJ1t0ZXhdL21oY2hlbScsICdbdGV4XS9uZXdjb21tYW5kJywgJ1t0ZXhdL25vZXJyb3JzJywgJ1t0ZXhdL25vdW5kZWZpbmVkJywgJ1t0ZXhdL3BoeXNpY3MnLCAnW3RleF0vdXBncmVlaycsICdbdGV4XS91bmljb2RlJywgJ1t0ZXhdL3ZlcmInLCAnW3RleF0vY29uZmlnbWFjcm9zJywgJ1t0ZXhdL3RhZ2Zvcm1hdCcsICdbdGV4XS90ZXh0Y29tcCcsICdbdGV4XS90ZXh0bWFjcm9zJywgJ1t0ZXhdL3NldG9wdGlvbnMnKTtcbn1cbmV4cG9ydHMuQWxsUGFja2FnZXMgPSBbXG4gICAgJ2Jhc2UnLFxuICAgICdhY3Rpb24nLFxuICAgICdhbXMnLFxuICAgICdhbXNjZCcsXG4gICAgJ2Jib3gnLFxuICAgICdib2xkc3ltYm9sJyxcbiAgICAnYnJha2V0JyxcbiAgICAnYnVzc3Byb29mcycsXG4gICAgJ2NhbmNlbCcsXG4gICAgJ2Nhc2VzJyxcbiAgICAnY2VudGVybm90JyxcbiAgICAnY29sb3InLFxuICAgICdjb2xvcnRibCcsXG4gICAgJ2VtcGhlcScsXG4gICAgJ2VuY2xvc2UnLFxuICAgICdleHRwZmVpbCcsXG4gICAgJ2dlbnN5bWInLFxuICAgICdodG1sJyxcbiAgICAnbWF0aHRvb2xzJyxcbiAgICAnbWhjaGVtJyxcbiAgICAnbmV3Y29tbWFuZCcsXG4gICAgJ25vZXJyb3JzJyxcbiAgICAnbm91bmRlZmluZWQnLFxuICAgICd1cGdyZWVrJyxcbiAgICAndW5pY29kZScsXG4gICAgJ3ZlcmInLFxuICAgICdjb25maWdtYWNyb3MnLFxuICAgICd0YWdmb3JtYXQnLFxuICAgICd0ZXh0Y29tcCcsXG4gICAgJ3RleHRtYWNyb3MnXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWxsUGFja2FnZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjdGlvbkNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkFjdGlvbk1ldGhvZHMgPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgVGV4UGFyc2VyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleFBhcnNlci5qc1wiKSk7XG52YXIgU3ltYm9sTWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpO1xudmFyIEJhc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Jhc2UvQmFzZU1ldGhvZHMuanNcIikpO1xuZXhwb3J0cy5BY3Rpb25NZXRob2RzID0ge307XG5leHBvcnRzLkFjdGlvbk1ldGhvZHMuTWFjcm8gPSBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuTWFjcm87XG5leHBvcnRzLkFjdGlvbk1ldGhvZHMuVG9nZ2xlID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIHZhciBhcmc7XG4gICAgd2hpbGUgKChhcmcgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkpICE9PSAnXFxcXGVuZHRvZ2dsZScpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChhcmcsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG4gICAgfVxuICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbWFjdGlvbicsIGNoaWxkcmVuLCB7IGFjdGlvbnR5cGU6ICd0b2dnbGUnIH0pKTtcbn07XG5leHBvcnRzLkFjdGlvbk1ldGhvZHMuTWF0aHRpcCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgYXJnID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIHZhciB0aXAgPSBwYXJzZXIuUGFyc2VBcmcobmFtZSk7XG4gICAgcGFyc2VyLlB1c2gocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtYWN0aW9uJywgW2FyZywgdGlwXSwgeyBhY3Rpb250eXBlOiAndG9vbHRpcCcgfSkpO1xufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdhY3Rpb24tbWFjcm9zJywge1xuICAgIHRvZ2dsZTogJ1RvZ2dsZScsXG4gICAgbWF0aHRpcDogJ01hdGh0aXAnLFxuICAgIHRleHR0aXA6IFsnTWFjcm8nLCAnXFxcXG1hdGh0aXB7IzF9e1xcXFx0ZXh0eyMyfX0nLCAyXVxufSwgZXhwb3J0cy5BY3Rpb25NZXRob2RzKTtcbmV4cG9ydHMuQWN0aW9uQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnYWN0aW9uJywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ2FjdGlvbi1tYWNyb3MnXSB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFtc0NvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkFtc1RhZ3MgPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgQW1zSXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuL0Ftc0l0ZW1zLmpzXCIpO1xudmFyIFRhZ3NfanNfMSA9IHJlcXVpcmUoXCIuLi9UYWdzLmpzXCIpO1xudmFyIEFtc01ldGhvZHNfanNfMSA9IHJlcXVpcmUoXCIuL0Ftc01ldGhvZHMuanNcIik7XG5yZXF1aXJlKFwiLi9BbXNNYXBwaW5ncy5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgQW1zVGFncyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFtc1RhZ3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW1zVGFncygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQW1zVGFncztcbn0oVGFnc19qc18xLkFic3RyYWN0VGFncykpO1xuZXhwb3J0cy5BbXNUYWdzID0gQW1zVGFncztcbnZhciBpbml0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIG5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKEFtc01ldGhvZHNfanNfMS5ORVdfT1BTLCB7fSwge30pO1xuICAgIGNvbmZpZy5hcHBlbmQoQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24ubG9jYWwoeyBoYW5kbGVyOiB7IG1hY3JvOiBbQW1zTWV0aG9kc19qc18xLk5FV19PUFNdIH0sXG4gICAgICAgIHByaW9yaXR5OiAtMSB9KSk7XG59O1xuZXhwb3J0cy5BbXNDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdhbXMnLCB7XG4gICAgaGFuZGxlcjoge1xuICAgICAgICBjaGFyYWN0ZXI6IFsnQU1TbWF0aC1vcGVyYXRvckxldHRlciddLFxuICAgICAgICBkZWxpbWl0ZXI6IFsnQU1Tc3ltYm9scy1kZWxpbWl0ZXInLCAnQU1TbWF0aC1kZWxpbWl0ZXInXSxcbiAgICAgICAgbWFjcm86IFsnQU1Tc3ltYm9scy1tYXRoY2hhcjBtaScsICdBTVNzeW1ib2xzLW1hdGhjaGFyMG1vJyxcbiAgICAgICAgICAgICdBTVNzeW1ib2xzLWRlbGltaXRlcicsICdBTVNzeW1ib2xzLW1hY3JvcycsXG4gICAgICAgICAgICAnQU1TbWF0aC1tYXRoY2hhcjBtbycsICdBTVNtYXRoLW1hY3JvcycsICdBTVNtYXRoLWRlbGltaXRlciddLFxuICAgICAgICBlbnZpcm9ubWVudDogWydBTVNtYXRoLWVudmlyb25tZW50J11cbiAgICB9LFxuICAgIGl0ZW1zOiAoX2EgPSB7fSxcbiAgICAgICAgX2FbQW1zSXRlbXNfanNfMS5NdWx0bGluZUl0ZW0ucHJvdG90eXBlLmtpbmRdID0gQW1zSXRlbXNfanNfMS5NdWx0bGluZUl0ZW0sXG4gICAgICAgIF9hW0Ftc0l0ZW1zX2pzXzEuRmxhbGlnbkl0ZW0ucHJvdG90eXBlLmtpbmRdID0gQW1zSXRlbXNfanNfMS5GbGFsaWduSXRlbSxcbiAgICAgICAgX2EpLFxuICAgIHRhZ3M6IHsgJ2Ftcyc6IEFtc1RhZ3MgfSxcbiAgICBpbml0OiBpbml0LFxuICAgIGNvbmZpZzogZnVuY3Rpb24gKF9jb25maWcsIGpheCkge1xuICAgICAgICBpZiAoamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLm11bHRsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy5hbXMubXVsdGxpbmVXaWR0aCA9IGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy5tdWx0bGluZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBqYXgucGFyc2VPcHRpb25zLm9wdGlvbnMubXVsdGxpbmVXaWR0aDtcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgbXVsdGxpbmVXaWR0aDogJycsXG4gICAgICAgIGFtczoge1xuICAgICAgICAgICAgbXVsdGxpbmVXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgbXVsdGxpbmVJbmRlbnQ6ICcxZW0nLFxuICAgICAgICB9XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbXNDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZsYWxpZ25JdGVtID0gZXhwb3J0cy5NdWx0bGluZUl0ZW0gPSB2b2lkIDA7XG52YXIgQmFzZUl0ZW1zX2pzXzEgPSByZXF1aXJlKFwiLi4vYmFzZS9CYXNlSXRlbXMuanNcIik7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vTm9kZVV0aWwuanNcIikpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBUZXhDb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuLi9UZXhDb25zdGFudHMuanNcIik7XG52YXIgTXVsdGxpbmVJdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVsdGxpbmVJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRsaW5lSXRlbShmYWN0b3J5KSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcnkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZhY3RvcnkuY29uZmlndXJhdGlvbi50YWdzLnN0YXJ0KCdtdWx0bGluZScsIHRydWUsIGFyZ3NbMF0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdWx0bGluZUl0ZW0ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbXVsdGxpbmUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTXVsdGxpbmVJdGVtLnByb3RvdHlwZS5FbmRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmZpeEluaXRpYWxNTyh0aGlzLmZhY3RvcnkuY29uZmlndXJhdGlvbiwgdGhpcy5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3ZlID0gdGhpcy5nZXRQcm9wZXJ0eSgnc2hvdmUnKTtcbiAgICAgICAgdmFyIG10ZCA9IHRoaXMuY3JlYXRlKCdub2RlJywgJ210ZCcsIHRoaXMubm9kZXMsIHNob3ZlID8geyBjb2x1bW5hbGlnbjogc2hvdmUgfSA6IHt9KTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eSgnc2hvdmUnLCBudWxsKTtcbiAgICAgICAgdGhpcy5yb3cucHVzaChtdGQpO1xuICAgICAgICB0aGlzLkNsZWFyKCk7XG4gICAgfTtcbiAgICBNdWx0bGluZUl0ZW0ucHJvdG90eXBlLkVuZFJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTXVsdGxpbmVSb3dzT25lQ29sJywgJ1RoZSByb3dzIHdpdGhpbiB0aGUgJTEgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNvbHVtbicsICdtdWx0bGluZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmNyZWF0ZSgnbm9kZScsICdtdHInLCB0aGlzLnJvdyk7XG4gICAgICAgIHRoaXMudGFibGUucHVzaChyb3cpO1xuICAgICAgICB0aGlzLnJvdyA9IFtdO1xuICAgIH07XG4gICAgTXVsdGxpbmVJdGVtLnByb3RvdHlwZS5FbmRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5FbmRUYWJsZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy50YWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50YWJsZS5sZW5ndGggLSAxLCBsYWJlbCA9IC0xO1xuICAgICAgICAgICAgaWYgKCFOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0QXR0cmlidXRlKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbih0aGlzLnRhYmxlWzBdKVswXSwgJ2NvbHVtbmFsaWduJykpIHtcbiAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbih0aGlzLnRhYmxlWzBdKVswXSwgJ2NvbHVtbmFsaWduJywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuQWxpZ24uTEVGVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRBdHRyaWJ1dGUoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKHRoaXMudGFibGVbbV0pWzBdLCAnY29sdW1uYWxpZ24nKSkge1xuICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKHRoaXMudGFibGVbbV0pWzBdLCAnY29sdW1uYWxpZ24nLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5BbGlnbi5SSUdIVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5mYWN0b3J5LmNvbmZpZ3VyYXRpb24udGFncy5nZXRUYWcoKTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9ICh0aGlzLmFycmF5ZGVmLnNpZGUgPT09IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LkFsaWduLkxFRlQgPyAwIDogdGhpcy50YWJsZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB2YXIgbXRyID0gdGhpcy50YWJsZVtsYWJlbF07XG4gICAgICAgICAgICAgICAgdmFyIG1sYWJlbCA9IHRoaXMuY3JlYXRlKCdub2RlJywgJ21sYWJlbGVkdHInLCBbdGFnXS5jb25jYXQoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKG10cikpKTtcbiAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuY29weUF0dHJpYnV0ZXMobXRyLCBtbGFiZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGVbbGFiZWxdID0gbWxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFjdG9yeS5jb25maWd1cmF0aW9uLnRhZ3MuZW5kKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGxpbmVJdGVtO1xufShCYXNlSXRlbXNfanNfMS5BcnJheUl0ZW0pKTtcbmV4cG9ydHMuTXVsdGxpbmVJdGVtID0gTXVsdGxpbmVJdGVtO1xudmFyIEZsYWxpZ25JdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxhbGlnbkl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmxhbGlnbkl0ZW0oZmFjdG9yeSwgbmFtZSwgbnVtYmVyZWQsIHBhZGRlZCwgY2VudGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcnkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5udW1iZXJlZCA9IG51bWJlcmVkO1xuICAgICAgICBfdGhpcy5wYWRkZWQgPSBwYWRkZWQ7XG4gICAgICAgIF90aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgX3RoaXMuZmFjdG9yeS5jb25maWd1cmF0aW9uLnRhZ3Muc3RhcnQobmFtZSwgbnVtYmVyZWQsIG51bWJlcmVkKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxhbGlnbkl0ZW0ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZmxhbGlnbic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGbGFsaWduSXRlbS5wcm90b3R5cGUuRW5kRW50cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuRW5kRW50cnkuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmdldFByb3BlcnR5KCd4YWxpZ25hdCcpO1xuICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJvdy5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdYYWxpZ25PdmVyZmxvdycsICdFeHRyYSAlMSBpbiByb3cgb2YgJTInLCAnJicsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZsYWxpZ25JdGVtLnByb3RvdHlwZS5FbmRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsO1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3c7XG4gICAgICAgIHZhciBuID0gdGhpcy5nZXRQcm9wZXJ0eSgneGFsaWduYXQnKTtcbiAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBuKSB7XG4gICAgICAgICAgICByb3cucHVzaCh0aGlzLmNyZWF0ZSgnbm9kZScsICdtdGQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3cgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucGFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvdy5wdXNoKHRoaXMuY3JlYXRlKCdub2RlJywgJ210ZCcpKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKGNlbGwgPSByb3cuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIHRoaXMucm93LnB1c2goY2VsbCk7XG4gICAgICAgICAgICBjZWxsID0gcm93LnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoY2VsbClcbiAgICAgICAgICAgICAgICB0aGlzLnJvdy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggfHwgdGhpcy5wYWRkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdy5wdXNoKHRoaXMuY3JlYXRlKCdub2RlJywgJ210ZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3cubGVuZ3RoID4gdGhpcy5tYXhyb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWF4cm93ID0gdGhpcy5yb3cubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuRW5kUm93LmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBtdHIgPSB0aGlzLnRhYmxlW3RoaXMudGFibGUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmdldFByb3BlcnR5KCd6ZXJvV2lkdGhMYWJlbCcpICYmIG10ci5pc0tpbmQoJ21sYWJlbGVkdHInKSkge1xuICAgICAgICAgICAgdmFyIG10ZCA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbihtdHIpWzBdO1xuICAgICAgICAgICAgdmFyIHNpZGUgPSB0aGlzLmZhY3RvcnkuY29uZmlndXJhdGlvbi5vcHRpb25zWyd0YWdTaWRlJ107XG4gICAgICAgICAgICB2YXIgZGVmID0gX19hc3NpZ24oeyB3aWR0aDogMCB9LCAoc2lkZSA9PT0gJ3JpZ2h0JyA/IHsgbHNwYWNlOiAnLTF3aWR0aCcgfSA6IHt9KSk7XG4gICAgICAgICAgICB2YXIgbXBhZGRlZCA9IHRoaXMuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRyZW4obXRkKSwgZGVmKTtcbiAgICAgICAgICAgIG10ZC5zZXRDaGlsZHJlbihbbXBhZGRlZF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGbGFsaWduSXRlbS5wcm90b3R5cGUuRW5kVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuRW5kVGFibGUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhyb3cgPD0gMikge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLmFycmF5ZGVmO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWYud2lkdGg7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2xvYmFsLmluZGVudGFsaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmxhbGlnbkl0ZW07XG59KEJhc2VJdGVtc19qc18xLkVxbkFycmF5SXRlbSkpO1xuZXhwb3J0cy5GbGFsaWduSXRlbSA9IEZsYWxpZ25JdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW1zSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBbXNNZXRob2RzX2pzXzEgPSByZXF1aXJlKFwiLi9BbXNNZXRob2RzLmpzXCIpO1xudmFyIHNtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIikpO1xudmFyIFRleENvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4uL1RleENvbnN0YW50cy5qc1wiKTtcbnZhciBQYXJzZU1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VNZXRob2RzLmpzXCIpKTtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG52YXIgbGVuZ3Roc19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvbGVuZ3Rocy5qc1wiKTtcbm5ldyBzbS5DaGFyYWN0ZXJNYXAoJ0FNU21hdGgtbWF0aGNoYXIwbW8nLCBQYXJzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lm1hdGhjaGFyMG1vLCB7XG4gICAgaWlpaW50OiBbJ1xcdTJBMEMnLCB7IHRleENsYXNzOiBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuT1AgfV1cbn0pO1xubmV3IHNtLlJlZ0V4cE1hcCgnQU1TbWF0aC1vcGVyYXRvckxldHRlcicsIEFtc01ldGhvZHNfanNfMS5BbXNNZXRob2RzLm9wZXJhdG9yTGV0dGVyLCAvWy0qXS9pKTtcbm5ldyBzbS5Db21tYW5kTWFwKCdBTVNtYXRoLW1hY3JvcycsIHtcbiAgICBtYXRocmluZzogWydBY2NlbnQnLCAnMDJEQSddLFxuICAgIG5vYnJlYWtzcGFjZTogJ1RpbGRlJyxcbiAgICBuZWdtZWRzcGFjZTogWydTcGFjZXInLCBsZW5ndGhzX2pzXzEuTUFUSFNQQUNFLm5lZ2F0aXZlbWVkaXVtbWF0aHNwYWNlXSxcbiAgICBuZWd0aGlja3NwYWNlOiBbJ1NwYWNlcicsIGxlbmd0aHNfanNfMS5NQVRIU1BBQ0UubmVnYXRpdmV0aGlja21hdGhzcGFjZV0sXG4gICAgaWRvdHNpbnQ6IFsnTXVsdGlJbnRlZ3JhbCcsICdcXFxcaW50XFxcXGNkb3RzXFxcXGludCddLFxuICAgIGRkZG90OiBbJ0FjY2VudCcsICcyMERCJ10sXG4gICAgZGRkZG90OiBbJ0FjY2VudCcsICcyMERDJ10sXG4gICAgc2lkZXNldDogJ1NpZGVTZXQnLFxuICAgIGJveGVkOiBbJ01hY3JvJywgJ1xcXFxmYm94eyRcXFxcZGlzcGxheXN0eWxleyMxfSR9JywgMV0sXG4gICAgdGFnOiAnSGFuZGxlVGFnJyxcbiAgICBub3RhZzogJ0hhbmRsZU5vVGFnJyxcbiAgICBlcXJlZjogWydIYW5kbGVSZWYnLCB0cnVlXSxcbiAgICBzdWJzdGFjazogWydNYWNybycsICdcXFxcYmVnaW57c3ViYXJyYXl9e2N9IzFcXFxcZW5ke3N1YmFycmF5fScsIDFdLFxuICAgIGluamxpbTogWydOYW1lZE9wJywgJ2luaiZ0aGluc3A7bGltJ10sXG4gICAgcHJvamxpbTogWydOYW1lZE9wJywgJ3Byb2omdGhpbnNwO2xpbSddLFxuICAgIHZhcmxpbWluZjogWydNYWNybycsICdcXFxcbWF0aG9we1xcXFx1bmRlcmxpbmV7XFxcXG1tbFRva2Vue21pfXtsaW19fX0nXSxcbiAgICB2YXJsaW1zdXA6IFsnTWFjcm8nLCAnXFxcXG1hdGhvcHtcXFxcb3ZlcmxpbmV7XFxcXG1tbFRva2Vue21pfXtsaW19fX0nXSxcbiAgICB2YXJpbmpsaW06IFsnTWFjcm8nLCAnXFxcXG1hdGhvcHtcXFxcdW5kZXJyaWdodGFycm93e1xcXFxtbWxUb2tlbnttaX17bGltfX19J10sXG4gICAgdmFycHJvamxpbTogWydNYWNybycsICdcXFxcbWF0aG9we1xcXFx1bmRlcmxlZnRhcnJvd3tcXFxcbW1sVG9rZW57bWl9e2xpbX19fSddLFxuICAgIERlY2xhcmVNYXRoT3BlcmF0b3I6ICdIYW5kbGVEZWNsYXJlT3AnLFxuICAgIG9wZXJhdG9ybmFtZTogJ0hhbmRsZU9wZXJhdG9yTmFtZScsXG4gICAgZ2VuZnJhYzogJ0dlbmZyYWMnLFxuICAgIGZyYWM6IFsnR2VuZnJhYycsICcnLCAnJywgJycsICcnXSxcbiAgICB0ZnJhYzogWydHZW5mcmFjJywgJycsICcnLCAnJywgJzEnXSxcbiAgICBkZnJhYzogWydHZW5mcmFjJywgJycsICcnLCAnJywgJzAnXSxcbiAgICBiaW5vbTogWydHZW5mcmFjJywgJygnLCAnKScsICcwJywgJyddLFxuICAgIHRiaW5vbTogWydHZW5mcmFjJywgJygnLCAnKScsICcwJywgJzEnXSxcbiAgICBkYmlub206IFsnR2VuZnJhYycsICcoJywgJyknLCAnMCcsICcwJ10sXG4gICAgY2ZyYWM6ICdDRnJhYycsXG4gICAgc2hvdmVsZWZ0OiBbJ0hhbmRsZVNob3ZlJywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuQWxpZ24uTEVGVF0sXG4gICAgc2hvdmVyaWdodDogWydIYW5kbGVTaG92ZScsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LkFsaWduLlJJR0hUXSxcbiAgICB4cmlnaHRhcnJvdzogWyd4QXJyb3cnLCAweDIxOTIsIDUsIDEwXSxcbiAgICB4bGVmdGFycm93OiBbJ3hBcnJvdycsIDB4MjE5MCwgMTAsIDVdXG59LCBBbXNNZXRob2RzX2pzXzEuQW1zTWV0aG9kcyk7XG5uZXcgc20uRW52aXJvbm1lbnRNYXAoJ0FNU21hdGgtZW52aXJvbm1lbnQnLCBQYXJzZU1ldGhvZHNfanNfMS5kZWZhdWx0LmVudmlyb25tZW50LCB7XG4gICAgJ2VxdWF0aW9uKic6IFsnRXF1YXRpb24nLCBudWxsLCBmYWxzZV0sXG4gICAgJ2VxbmFycmF5Kic6IFsnRXFuQXJyYXknLCBudWxsLCBmYWxzZSwgdHJ1ZSwgJ3JjbCcsXG4gICAgICAgIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuY29scygwLCBsZW5ndGhzX2pzXzEuTUFUSFNQQUNFLnRoaWNrbWF0aHNwYWNlKSwgJy41ZW0nXSxcbiAgICBhbGlnbjogWydFcW5BcnJheScsIG51bGwsIHRydWUsIHRydWUsICdybCcsIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuY29scygwLCAyKV0sXG4gICAgJ2FsaWduKic6IFsnRXFuQXJyYXknLCBudWxsLCBmYWxzZSwgdHJ1ZSwgJ3JsJywgUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jb2xzKDAsIDIpXSxcbiAgICBtdWx0bGluZTogWydNdWx0bGluZScsIG51bGwsIHRydWVdLFxuICAgICdtdWx0bGluZSonOiBbJ011bHRsaW5lJywgbnVsbCwgZmFsc2VdLFxuICAgIHNwbGl0OiBbJ0VxbkFycmF5JywgbnVsbCwgZmFsc2UsIGZhbHNlLCAncmwnLCBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmNvbHMoMCldLFxuICAgIGdhdGhlcjogWydFcW5BcnJheScsIG51bGwsIHRydWUsIHRydWUsICdjJ10sXG4gICAgJ2dhdGhlcionOiBbJ0VxbkFycmF5JywgbnVsbCwgZmFsc2UsIHRydWUsICdjJ10sXG4gICAgYWxpZ25hdDogWydBbGlnbkF0JywgbnVsbCwgdHJ1ZSwgdHJ1ZV0sXG4gICAgJ2FsaWduYXQqJzogWydBbGlnbkF0JywgbnVsbCwgZmFsc2UsIHRydWVdLFxuICAgIGFsaWduZWRhdDogWydBbGlnbkF0JywgbnVsbCwgZmFsc2UsIGZhbHNlXSxcbiAgICBhbGlnbmVkOiBbJ0Ftc0VxbkFycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgJ3JsJywgUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jb2xzKDAsIDIpLCAnLjVlbScsICdEJ10sXG4gICAgZ2F0aGVyZWQ6IFsnQW1zRXFuQXJyYXknLCBudWxsLCBudWxsLCBudWxsLCAnYycsIG51bGwsICcuNWVtJywgJ0QnXSxcbiAgICB4YWxpZ25hdDogWydYYWxpZ25BdCcsIG51bGwsIHRydWUsIHRydWVdLFxuICAgICd4YWxpZ25hdConOiBbJ1hhbGlnbkF0JywgbnVsbCwgZmFsc2UsIHRydWVdLFxuICAgIHh4YWxpZ25hdDogWydYYWxpZ25BdCcsIG51bGwsIGZhbHNlLCBmYWxzZV0sXG4gICAgZmxhbGlnbjogWydGbGFsaWduQXJyYXknLCBudWxsLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgJ3JsYycsICdhdXRvIGF1dG8gZml0J10sXG4gICAgJ2ZsYWxpZ24qJzogWydGbGFsaWduQXJyYXknLCBudWxsLCBmYWxzZSwgZmFsc2UsIHRydWUsICdybGMnLCAnYXV0byBhdXRvIGZpdCddLFxuICAgIHN1YmFycmF5OiBbJ0FycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jb2xzKDApLCAnMC4xZW0nLCAnUycsIDFdLFxuICAgIHNtYWxsbWF0cml4OiBbJ0FycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgJ2MnLCBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmNvbHMoMSAvIDMpLFxuICAgICAgICAnLjJlbScsICdTJywgMV0sXG4gICAgbWF0cml4OiBbJ0FycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgJ2MnXSxcbiAgICBwbWF0cml4OiBbJ0FycmF5JywgbnVsbCwgJygnLCAnKScsICdjJ10sXG4gICAgYm1hdHJpeDogWydBcnJheScsIG51bGwsICdbJywgJ10nLCAnYyddLFxuICAgIEJtYXRyaXg6IFsnQXJyYXknLCBudWxsLCAnXFxcXHsnLCAnXFxcXH0nLCAnYyddLFxuICAgIHZtYXRyaXg6IFsnQXJyYXknLCBudWxsLCAnXFxcXHZlcnQnLCAnXFxcXHZlcnQnLCAnYyddLFxuICAgIFZtYXRyaXg6IFsnQXJyYXknLCBudWxsLCAnXFxcXFZlcnQnLCAnXFxcXFZlcnQnLCAnYyddLFxuICAgIGNhc2VzOiBbJ0FycmF5JywgbnVsbCwgJ1xcXFx7JywgJy4nLCAnbGwnLCBudWxsLCAnLjJlbScsICdUJ11cbn0sIEFtc01ldGhvZHNfanNfMS5BbXNNZXRob2RzKTtcbm5ldyBzbS5EZWxpbWl0ZXJNYXAoJ0FNU21hdGgtZGVsaW1pdGVyJywgUGFyc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5kZWxpbWl0ZXIsIHtcbiAgICAnXFxcXGx2ZXJ0JzogWydcXHUwMDdDJywgeyB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLk9QRU4gfV0sXG4gICAgJ1xcXFxydmVydCc6IFsnXFx1MDA3QycsIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5DTE9TRSB9XSxcbiAgICAnXFxcXGxWZXJ0JzogWydcXHUyMDE2JywgeyB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLk9QRU4gfV0sXG4gICAgJ1xcXFxyVmVydCc6IFsnXFx1MjAxNicsIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5DTE9TRSB9XVxufSk7XG5uZXcgc20uQ2hhcmFjdGVyTWFwKCdBTVNzeW1ib2xzLW1hdGhjaGFyMG1pJywgUGFyc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5tYXRoY2hhcjBtaSwge1xuICAgIGRpZ2FtbWE6ICdcXHUwM0REJyxcbiAgICB2YXJrYXBwYTogJ1xcdTAzRjAnLFxuICAgIHZhckdhbW1hOiBbJ1xcdTAzOTMnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LklUQUxJQyB9XSxcbiAgICB2YXJEZWx0YTogWydcXHUwMzk0JywgeyBtYXRodmFyaWFudDogVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5JVEFMSUMgfV0sXG4gICAgdmFyVGhldGE6IFsnXFx1MDM5OCcsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuSVRBTElDIH1dLFxuICAgIHZhckxhbWJkYTogWydcXHUwMzlCJywgeyBtYXRodmFyaWFudDogVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5JVEFMSUMgfV0sXG4gICAgdmFyWGk6IFsnXFx1MDM5RScsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuSVRBTElDIH1dLFxuICAgIHZhclBpOiBbJ1xcdTAzQTAnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LklUQUxJQyB9XSxcbiAgICB2YXJTaWdtYTogWydcXHUwM0EzJywgeyBtYXRodmFyaWFudDogVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5JVEFMSUMgfV0sXG4gICAgdmFyVXBzaWxvbjogWydcXHUwM0E1JywgeyBtYXRodmFyaWFudDogVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5JVEFMSUMgfV0sXG4gICAgdmFyUGhpOiBbJ1xcdTAzQTYnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LklUQUxJQyB9XSxcbiAgICB2YXJQc2k6IFsnXFx1MDNBOCcsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuSVRBTElDIH1dLFxuICAgIHZhck9tZWdhOiBbJ1xcdTAzQTknLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LklUQUxJQyB9XSxcbiAgICBiZXRoOiAnXFx1MjEzNicsXG4gICAgZ2ltZWw6ICdcXHUyMTM3JyxcbiAgICBkYWxldGg6ICdcXHUyMTM4JyxcbiAgICBiYWNrcHJpbWU6IFsnXFx1MjAzNScsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgaHNsYXNoOiAnXFx1MjEwRicsXG4gICAgdmFybm90aGluZzogWydcXHUyMjA1JywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBibGFja3RyaWFuZ2xlOiAnXFx1MjVCNCcsXG4gICAgdHJpYW5nbGVkb3duOiBbJ1xcdTI1QkQnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIGJsYWNrdHJpYW5nbGVkb3duOiAnXFx1MjVCRScsXG4gICAgc3F1YXJlOiAnXFx1MjVGQicsXG4gICAgQm94OiAnXFx1MjVGQicsXG4gICAgYmxhY2tzcXVhcmU6ICdcXHUyNUZDJyxcbiAgICBsb3plbmdlOiAnXFx1MjVDQScsXG4gICAgRGlhbW9uZDogJ1xcdTI1Q0EnLFxuICAgIGJsYWNrbG96ZW5nZTogJ1xcdTI5RUInLFxuICAgIGNpcmNsZWRTOiBbJ1xcdTI0QzgnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk5PUk1BTCB9XSxcbiAgICBiaWdzdGFyOiAnXFx1MjYwNScsXG4gICAgc3BoZXJpY2FsYW5nbGU6ICdcXHUyMjIyJyxcbiAgICBtZWFzdXJlZGFuZ2xlOiAnXFx1MjIyMScsXG4gICAgbmV4aXN0czogJ1xcdTIyMDQnLFxuICAgIGNvbXBsZW1lbnQ6ICdcXHUyMjAxJyxcbiAgICBtaG86ICdcXHUyMTI3JyxcbiAgICBldGg6IFsnXFx1MDBGMCcsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuTk9STUFMIH1dLFxuICAgIEZpbnY6ICdcXHUyMTMyJyxcbiAgICBkaWFndXA6ICdcXHUyNTcxJyxcbiAgICBHYW1lOiAnXFx1MjE0MScsXG4gICAgZGlhZ2Rvd246ICdcXHUyNTcyJyxcbiAgICBCYmJrOiBbJ1xcdTAwNkInLFxuICAgICAgICB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkRPVUJMRVNUUlVDSyB9XSxcbiAgICB5ZW46ICdcXHUwMEE1JyxcbiAgICBjaXJjbGVkUjogJ1xcdTAwQUUnLFxuICAgIGNoZWNrbWFyazogJ1xcdTI3MTMnLFxuICAgIG1hbHRlc2U6ICdcXHUyNzIwJ1xufSk7XG5uZXcgc20uQ2hhcmFjdGVyTWFwKCdBTVNzeW1ib2xzLW1hdGhjaGFyMG1vJywgUGFyc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5tYXRoY2hhcjBtbywge1xuICAgIGRvdHBsdXM6ICdcXHUyMjE0JyxcbiAgICBsdGltZXM6ICdcXHUyMkM5JyxcbiAgICBzbWFsbHNldG1pbnVzOiBbJ1xcdTIyMTYnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIHJ0aW1lczogJ1xcdTIyQ0EnLFxuICAgIENhcDogJ1xcdTIyRDInLFxuICAgIGRvdWJsZWNhcDogJ1xcdTIyRDInLFxuICAgIGxlZnR0aHJlZXRpbWVzOiAnXFx1MjJDQicsXG4gICAgQ3VwOiAnXFx1MjJEMycsXG4gICAgZG91YmxlY3VwOiAnXFx1MjJEMycsXG4gICAgcmlnaHR0aHJlZXRpbWVzOiAnXFx1MjJDQycsXG4gICAgYmFyd2VkZ2U6ICdcXHUyMkJDJyxcbiAgICBjdXJseXdlZGdlOiAnXFx1MjJDRicsXG4gICAgdmVlYmFyOiAnXFx1MjJCQicsXG4gICAgY3VybHl2ZWU6ICdcXHUyMkNFJyxcbiAgICBkb3VibGViYXJ3ZWRnZTogJ1xcdTJBNUUnLFxuICAgIGJveG1pbnVzOiAnXFx1MjI5RicsXG4gICAgY2lyY2xlZGRhc2g6ICdcXHUyMjlEJyxcbiAgICBib3h0aW1lczogJ1xcdTIyQTAnLFxuICAgIGNpcmNsZWRhc3Q6ICdcXHUyMjlCJyxcbiAgICBib3hkb3Q6ICdcXHUyMkExJyxcbiAgICBjaXJjbGVkY2lyYzogJ1xcdTIyOUEnLFxuICAgIGJveHBsdXM6ICdcXHUyMjlFJyxcbiAgICBjZW50ZXJkb3Q6IFsnXFx1MjJDNScsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgZGl2aWRlb250aW1lczogJ1xcdTIyQzcnLFxuICAgIGludGVyY2FsOiAnXFx1MjJCQScsXG4gICAgbGVxcTogJ1xcdTIyNjYnLFxuICAgIGdlcXE6ICdcXHUyMjY3JyxcbiAgICBsZXFzbGFudDogJ1xcdTJBN0QnLFxuICAgIGdlcXNsYW50OiAnXFx1MkE3RScsXG4gICAgZXFzbGFudGxlc3M6ICdcXHUyQTk1JyxcbiAgICBlcXNsYW50Z3RyOiAnXFx1MkE5NicsXG4gICAgbGVzc3NpbTogJ1xcdTIyNzInLFxuICAgIGd0cnNpbTogJ1xcdTIyNzMnLFxuICAgIGxlc3NhcHByb3g6ICdcXHUyQTg1JyxcbiAgICBndHJhcHByb3g6ICdcXHUyQTg2JyxcbiAgICBhcHByb3hlcTogJ1xcdTIyNEEnLFxuICAgIGxlc3Nkb3Q6ICdcXHUyMkQ2JyxcbiAgICBndHJkb3Q6ICdcXHUyMkQ3JyxcbiAgICBsbGw6ICdcXHUyMkQ4JyxcbiAgICBsbGxlc3M6ICdcXHUyMkQ4JyxcbiAgICBnZ2c6ICdcXHUyMkQ5JyxcbiAgICBnZ2d0cjogJ1xcdTIyRDknLFxuICAgIGxlc3NndHI6ICdcXHUyMjc2JyxcbiAgICBndHJsZXNzOiAnXFx1MjI3NycsXG4gICAgbGVzc2VxZ3RyOiAnXFx1MjJEQScsXG4gICAgZ3RyZXFsZXNzOiAnXFx1MjJEQicsXG4gICAgbGVzc2VxcWd0cjogJ1xcdTJBOEInLFxuICAgIGd0cmVxcWxlc3M6ICdcXHUyQThDJyxcbiAgICBkb3RlcWRvdDogJ1xcdTIyNTEnLFxuICAgIERvdGVxOiAnXFx1MjI1MScsXG4gICAgZXFjaXJjOiAnXFx1MjI1NicsXG4gICAgcmlzaW5nZG90c2VxOiAnXFx1MjI1MycsXG4gICAgY2lyY2VxOiAnXFx1MjI1NycsXG4gICAgZmFsbGluZ2RvdHNlcTogJ1xcdTIyNTInLFxuICAgIHRyaWFuZ2xlcTogJ1xcdTIyNUMnLFxuICAgIGJhY2tzaW06ICdcXHUyMjNEJyxcbiAgICB0aGlja3NpbTogWydcXHUyMjNDJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBiYWNrc2ltZXE6ICdcXHUyMkNEJyxcbiAgICB0aGlja2FwcHJveDogWydcXHUyMjQ4JywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBzdWJzZXRlcXE6ICdcXHUyQUM1JyxcbiAgICBzdXBzZXRlcXE6ICdcXHUyQUM2JyxcbiAgICBTdWJzZXQ6ICdcXHUyMkQwJyxcbiAgICBTdXBzZXQ6ICdcXHUyMkQxJyxcbiAgICBzcXN1YnNldDogJ1xcdTIyOEYnLFxuICAgIHNxc3Vwc2V0OiAnXFx1MjI5MCcsXG4gICAgcHJlY2N1cmx5ZXE6ICdcXHUyMjdDJyxcbiAgICBzdWNjY3VybHllcTogJ1xcdTIyN0QnLFxuICAgIGN1cmx5ZXFwcmVjOiAnXFx1MjJERScsXG4gICAgY3VybHllcXN1Y2M6ICdcXHUyMkRGJyxcbiAgICBwcmVjc2ltOiAnXFx1MjI3RScsXG4gICAgc3VjY3NpbTogJ1xcdTIyN0YnLFxuICAgIHByZWNhcHByb3g6ICdcXHUyQUI3JyxcbiAgICBzdWNjYXBwcm94OiAnXFx1MkFCOCcsXG4gICAgdmFydHJpYW5nbGVsZWZ0OiAnXFx1MjJCMicsXG4gICAgbGhkOiAnXFx1MjJCMicsXG4gICAgdmFydHJpYW5nbGVyaWdodDogJ1xcdTIyQjMnLFxuICAgIHJoZDogJ1xcdTIyQjMnLFxuICAgIHRyaWFuZ2xlbGVmdGVxOiAnXFx1MjJCNCcsXG4gICAgdW5saGQ6ICdcXHUyMkI0JyxcbiAgICB0cmlhbmdsZXJpZ2h0ZXE6ICdcXHUyMkI1JyxcbiAgICB1bnJoZDogJ1xcdTIyQjUnLFxuICAgIHZEYXNoOiBbJ1xcdTIyQTgnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIFZkYXNoOiAnXFx1MjJBOScsXG4gICAgVnZkYXNoOiAnXFx1MjJBQScsXG4gICAgc21hbGxzbWlsZTogWydcXHUyMzIzJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBzaG9ydG1pZDogWydcXHUyMjIzJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBzbWFsbGZyb3duOiBbJ1xcdTIzMjInLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIHNob3J0cGFyYWxsZWw6IFsnXFx1MjIyNScsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgYnVtcGVxOiAnXFx1MjI0RicsXG4gICAgYmV0d2VlbjogJ1xcdTIyNkMnLFxuICAgIEJ1bXBlcTogJ1xcdTIyNEUnLFxuICAgIHBpdGNoZm9yazogJ1xcdTIyRDQnLFxuICAgIHZhcnByb3B0bzogWydcXHUyMjFEJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBiYWNrZXBzaWxvbjogJ1xcdTIyMEQnLFxuICAgIGJsYWNrdHJpYW5nbGVsZWZ0OiAnXFx1MjVDMicsXG4gICAgYmxhY2t0cmlhbmdsZXJpZ2h0OiAnXFx1MjVCOCcsXG4gICAgdGhlcmVmb3JlOiAnXFx1MjIzNCcsXG4gICAgYmVjYXVzZTogJ1xcdTIyMzUnLFxuICAgIGVxc2ltOiAnXFx1MjI0MicsXG4gICAgdmFydHJpYW5nbGU6IFsnXFx1MjVCMycsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgSm9pbjogJ1xcdTIyQzgnLFxuICAgIG5sZXNzOiAnXFx1MjI2RScsXG4gICAgbmd0cjogJ1xcdTIyNkYnLFxuICAgIG5sZXE6ICdcXHUyMjcwJyxcbiAgICBuZ2VxOiAnXFx1MjI3MScsXG4gICAgbmxlcXNsYW50OiBbJ1xcdTJBODcnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIG5nZXFzbGFudDogWydcXHUyQTg4JywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBubGVxcTogWydcXHUyMjcwJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBuZ2VxcTogWydcXHUyMjcxJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBsbmVxOiAnXFx1MkE4NycsXG4gICAgZ25lcTogJ1xcdTJBODgnLFxuICAgIGxuZXFxOiAnXFx1MjI2OCcsXG4gICAgZ25lcXE6ICdcXHUyMjY5JyxcbiAgICBsdmVydG5lcXE6IFsnXFx1MjI2OCcsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgZ3ZlcnRuZXFxOiBbJ1xcdTIyNjknLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIGxuc2ltOiAnXFx1MjJFNicsXG4gICAgZ25zaW06ICdcXHUyMkU3JyxcbiAgICBsbmFwcHJveDogJ1xcdTJBODknLFxuICAgIGduYXBwcm94OiAnXFx1MkE4QScsXG4gICAgbnByZWM6ICdcXHUyMjgwJyxcbiAgICBuc3VjYzogJ1xcdTIyODEnLFxuICAgIG5wcmVjZXE6IFsnXFx1MjJFMCcsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgbnN1Y2NlcTogWydcXHUyMkUxJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBwcmVjbmVxcTogJ1xcdTJBQjUnLFxuICAgIHN1Y2NuZXFxOiAnXFx1MkFCNicsXG4gICAgcHJlY25zaW06ICdcXHUyMkU4JyxcbiAgICBzdWNjbnNpbTogJ1xcdTIyRTknLFxuICAgIHByZWNuYXBwcm94OiAnXFx1MkFCOScsXG4gICAgc3VjY25hcHByb3g6ICdcXHUyQUJBJyxcbiAgICBuc2ltOiAnXFx1MjI0MScsXG4gICAgbmNvbmc6ICdcXHUyMjQ3JyxcbiAgICBuc2hvcnRtaWQ6IFsnXFx1MjIyNCcsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgbnNob3J0cGFyYWxsZWw6IFsnXFx1MjIyNicsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgbm1pZDogJ1xcdTIyMjQnLFxuICAgIG5wYXJhbGxlbDogJ1xcdTIyMjYnLFxuICAgIG52ZGFzaDogJ1xcdTIyQUMnLFxuICAgIG52RGFzaDogJ1xcdTIyQUQnLFxuICAgIG5WZGFzaDogJ1xcdTIyQUUnLFxuICAgIG5WRGFzaDogJ1xcdTIyQUYnLFxuICAgIG50cmlhbmdsZWxlZnQ6ICdcXHUyMkVBJyxcbiAgICBudHJpYW5nbGVyaWdodDogJ1xcdTIyRUInLFxuICAgIG50cmlhbmdsZWxlZnRlcTogJ1xcdTIyRUMnLFxuICAgIG50cmlhbmdsZXJpZ2h0ZXE6ICdcXHUyMkVEJyxcbiAgICBuc3Vic2V0ZXE6ICdcXHUyMjg4JyxcbiAgICBuc3Vwc2V0ZXE6ICdcXHUyMjg5JyxcbiAgICBuc3Vic2V0ZXFxOiBbJ1xcdTIyODgnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIG5zdXBzZXRlcXE6IFsnXFx1MjI4OScsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgc3Vic2V0bmVxOiAnXFx1MjI4QScsXG4gICAgc3Vwc2V0bmVxOiAnXFx1MjI4QicsXG4gICAgdmFyc3Vic2V0bmVxOiBbJ1xcdTIyOEEnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIHZhcnN1cHNldG5lcTogWydcXHUyMjhCJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBzdWJzZXRuZXFxOiAnXFx1MkFDQicsXG4gICAgc3Vwc2V0bmVxcTogJ1xcdTJBQ0MnLFxuICAgIHZhcnN1YnNldG5lcXE6IFsnXFx1MkFDQicsIHsgdmFyaWFudEZvcm06IHRydWUgfV0sXG4gICAgdmFyc3Vwc2V0bmVxcTogWydcXHUyQUNDJywgeyB2YXJpYW50Rm9ybTogdHJ1ZSB9XSxcbiAgICBsZWZ0bGVmdGFycm93czogJ1xcdTIxQzcnLFxuICAgIHJpZ2h0cmlnaHRhcnJvd3M6ICdcXHUyMUM5JyxcbiAgICBsZWZ0cmlnaHRhcnJvd3M6ICdcXHUyMUM2JyxcbiAgICByaWdodGxlZnRhcnJvd3M6ICdcXHUyMUM0JyxcbiAgICBMbGVmdGFycm93OiAnXFx1MjFEQScsXG4gICAgUnJpZ2h0YXJyb3c6ICdcXHUyMURCJyxcbiAgICB0d29oZWFkbGVmdGFycm93OiAnXFx1MjE5RScsXG4gICAgdHdvaGVhZHJpZ2h0YXJyb3c6ICdcXHUyMUEwJyxcbiAgICBsZWZ0YXJyb3d0YWlsOiAnXFx1MjFBMicsXG4gICAgcmlnaHRhcnJvd3RhaWw6ICdcXHUyMUEzJyxcbiAgICBsb29wYXJyb3dsZWZ0OiAnXFx1MjFBQicsXG4gICAgbG9vcGFycm93cmlnaHQ6ICdcXHUyMUFDJyxcbiAgICBsZWZ0cmlnaHRoYXJwb29uczogJ1xcdTIxQ0InLFxuICAgIHJpZ2h0bGVmdGhhcnBvb25zOiBbJ1xcdTIxQ0MnLCB7IHZhcmlhbnRGb3JtOiB0cnVlIH1dLFxuICAgIGN1cnZlYXJyb3dsZWZ0OiAnXFx1MjFCNicsXG4gICAgY3VydmVhcnJvd3JpZ2h0OiAnXFx1MjFCNycsXG4gICAgY2lyY2xlYXJyb3dsZWZ0OiAnXFx1MjFCQScsXG4gICAgY2lyY2xlYXJyb3dyaWdodDogJ1xcdTIxQkInLFxuICAgIExzaDogJ1xcdTIxQjAnLFxuICAgIFJzaDogJ1xcdTIxQjEnLFxuICAgIHVwdXBhcnJvd3M6ICdcXHUyMUM4JyxcbiAgICBkb3duZG93bmFycm93czogJ1xcdTIxQ0EnLFxuICAgIHVwaGFycG9vbmxlZnQ6ICdcXHUyMUJGJyxcbiAgICB1cGhhcnBvb25yaWdodDogJ1xcdTIxQkUnLFxuICAgIGRvd25oYXJwb29ubGVmdDogJ1xcdTIxQzMnLFxuICAgIHJlc3RyaWN0aW9uOiAnXFx1MjFCRScsXG4gICAgbXVsdGltYXA6ICdcXHUyMkI4JyxcbiAgICBkb3duaGFycG9vbnJpZ2h0OiAnXFx1MjFDMicsXG4gICAgbGVmdHJpZ2h0c3F1aWdhcnJvdzogJ1xcdTIxQUQnLFxuICAgIHJpZ2h0c3F1aWdhcnJvdzogJ1xcdTIxREQnLFxuICAgIGxlYWRzdG86ICdcXHUyMUREJyxcbiAgICBkYXNocmlnaHRhcnJvdzogJ1xcdTIxRTInLFxuICAgIGRhc2hsZWZ0YXJyb3c6ICdcXHUyMUUwJyxcbiAgICBubGVmdGFycm93OiAnXFx1MjE5QScsXG4gICAgbnJpZ2h0YXJyb3c6ICdcXHUyMTlCJyxcbiAgICBuTGVmdGFycm93OiAnXFx1MjFDRCcsXG4gICAgblJpZ2h0YXJyb3c6ICdcXHUyMUNGJyxcbiAgICBubGVmdHJpZ2h0YXJyb3c6ICdcXHUyMUFFJyxcbiAgICBuTGVmdHJpZ2h0YXJyb3c6ICdcXHUyMUNFJ1xufSk7XG5uZXcgc20uRGVsaW1pdGVyTWFwKCdBTVNzeW1ib2xzLWRlbGltaXRlcicsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQuZGVsaW1pdGVyLCB7XG4gICAgJ1xcXFx1bGNvcm5lcic6ICdcXHUyMzFDJyxcbiAgICAnXFxcXHVyY29ybmVyJzogJ1xcdTIzMUQnLFxuICAgICdcXFxcbGxjb3JuZXInOiAnXFx1MjMxRScsXG4gICAgJ1xcXFxscmNvcm5lcic6ICdcXHUyMzFGJ1xufSk7XG5uZXcgc20uQ29tbWFuZE1hcCgnQU1Tc3ltYm9scy1tYWNyb3MnLCB7XG4gICAgaW1wbGllczogWydNYWNybycsICdcXFxcO1xcXFxMb25ncmlnaHRhcnJvd1xcXFw7J10sXG4gICAgaW1wbGllZGJ5OiBbJ01hY3JvJywgJ1xcXFw7XFxcXExvbmdsZWZ0YXJyb3dcXFxcOyddXG59LCBBbXNNZXRob2RzX2pzXzEuQW1zTWV0aG9kcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbXNNYXBwaW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5FV19PUFMgPSBleHBvcnRzLkFtc01ldGhvZHMgPSB2b2lkIDA7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgUGFyc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlTWV0aG9kcy5qc1wiKSk7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vTm9kZVV0aWwuanNcIikpO1xudmFyIFRleENvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4uL1RleENvbnN0YW50cy5qc1wiKTtcbnZhciBUZXhQYXJzZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4UGFyc2VyLmpzXCIpKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgU3ltYm9sX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sLmpzXCIpO1xudmFyIEJhc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Jhc2UvQmFzZU1ldGhvZHMuanNcIikpO1xudmFyIE1tbE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZS5qc1wiKTtcbmV4cG9ydHMuQW1zTWV0aG9kcyA9IHt9O1xuZXhwb3J0cy5BbXNNZXRob2RzLkFtc0VxbkFycmF5ID0gZnVuY3Rpb24gKHBhcnNlciwgYmVnaW4sIG51bWJlcmVkLCB0YWdnYWJsZSwgYWxpZ24sIHNwYWNpbmcsIHN0eWxlKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJzZXIuR2V0QnJhY2tldHMoJ1xcXFxiZWdpbnsnICsgYmVnaW4uZ2V0TmFtZSgpICsgJ30nKTtcbiAgICB2YXIgYXJyYXkgPSBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuRXFuQXJyYXkocGFyc2VyLCBiZWdpbiwgbnVtYmVyZWQsIHRhZ2dhYmxlLCBhbGlnbiwgc3BhY2luZywgc3R5bGUpO1xuICAgIHJldHVybiBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnNldEFycmF5QWxpZ24oYXJyYXksIGFyZ3MpO1xufTtcbmV4cG9ydHMuQW1zTWV0aG9kcy5BbGlnbkF0ID0gZnVuY3Rpb24gKHBhcnNlciwgYmVnaW4sIG51bWJlcmVkLCB0YWdnYWJsZSkge1xuICAgIHZhciBuYW1lID0gYmVnaW4uZ2V0TmFtZSgpO1xuICAgIHZhciBuLCB2YWxpZ24sIGFsaWduID0gJycsIHNwYWNpbmcgPSBbXTtcbiAgICBpZiAoIXRhZ2dhYmxlKSB7XG4gICAgICAgIHZhbGlnbiA9IHBhcnNlci5HZXRCcmFja2V0cygnXFxcXGJlZ2lueycgKyBuYW1lICsgJ30nKTtcbiAgICB9XG4gICAgbiA9IHBhcnNlci5HZXRBcmd1bWVudCgnXFxcXGJlZ2lueycgKyBuYW1lICsgJ30nKTtcbiAgICBpZiAobi5tYXRjaCgvW14wLTldLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnUG9zaXRpdmVJbnRlZ2VyQXJnJywgJ0FyZ3VtZW50IHRvICUxIG11c3QgbWUgYSBwb3NpdGl2ZSBpbnRlZ2VyJywgJ1xcXFxiZWdpbnsnICsgbmFtZSArICd9Jyk7XG4gICAgfVxuICAgIHZhciBjb3VudCA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGFsaWduICs9ICdybCc7XG4gICAgICAgIHNwYWNpbmcucHVzaCgnMGVtIDBlbScpO1xuICAgICAgICBjb3VudC0tO1xuICAgIH1cbiAgICB2YXIgc3BhY2VTdHIgPSBzcGFjaW5nLmpvaW4oJyAnKTtcbiAgICBpZiAodGFnZ2FibGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQW1zTWV0aG9kcy5FcW5BcnJheShwYXJzZXIsIGJlZ2luLCBudW1iZXJlZCwgdGFnZ2FibGUsIGFsaWduLCBzcGFjZVN0cik7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IGV4cG9ydHMuQW1zTWV0aG9kcy5FcW5BcnJheShwYXJzZXIsIGJlZ2luLCBudW1iZXJlZCwgdGFnZ2FibGUsIGFsaWduLCBzcGFjZVN0cik7XG4gICAgcmV0dXJuIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXJyYXlBbGlnbihhcnJheSwgdmFsaWduKTtcbn07XG5leHBvcnRzLkFtc01ldGhvZHMuTXVsdGxpbmUgPSBmdW5jdGlvbiAocGFyc2VyLCBiZWdpbiwgbnVtYmVyZWQpIHtcbiAgICBwYXJzZXIuUHVzaChiZWdpbik7XG4gICAgUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jaGVja0VxbkVudihwYXJzZXIpO1xuICAgIHZhciBpdGVtID0gcGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnbXVsdGxpbmUnLCBudW1iZXJlZCwgcGFyc2VyLnN0YWNrKTtcbiAgICBpdGVtLmFycmF5ZGVmID0ge1xuICAgICAgICBkaXNwbGF5c3R5bGU6IHRydWUsXG4gICAgICAgIHJvd3NwYWNpbmc6ICcuNWVtJyxcbiAgICAgICAgY29sdW1uc3BhY2luZzogJzEwMCUnLFxuICAgICAgICB3aWR0aDogcGFyc2VyLm9wdGlvbnMuYW1zWydtdWx0bGluZVdpZHRoJ10sXG4gICAgICAgIHNpZGU6IHBhcnNlci5vcHRpb25zWyd0YWdTaWRlJ10sXG4gICAgICAgIG1pbmxhYmVsc3BhY2luZzogcGFyc2VyLm9wdGlvbnNbJ3RhZ0luZGVudCddLFxuICAgICAgICBmcmFtZXNwYWNpbmc6IHBhcnNlci5vcHRpb25zLmFtc1snbXVsdGxpbmVJbmRlbnQnXSArICcgMCcsXG4gICAgICAgIGZyYW1lOiAnJyxcbiAgICAgICAgJ2RhdGEtd2lkdGgtaW5jbHVkZXMtbGFiZWwnOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gaXRlbTtcbn07XG5leHBvcnRzLkFtc01ldGhvZHMuWGFsaWduQXQgPSBmdW5jdGlvbiAocGFyc2VyLCBiZWdpbiwgbnVtYmVyZWQsIHBhZGRlZCkge1xuICAgIHZhciBuID0gcGFyc2VyLkdldEFyZ3VtZW50KCdcXFxcYmVnaW57JyArIGJlZ2luLmdldE5hbWUoKSArICd9Jyk7XG4gICAgaWYgKG4ubWF0Y2goL1teMC05XS8pKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ1Bvc2l0aXZlSW50ZWdlckFyZycsICdBcmd1bWVudCB0byAlMSBtdXN0IG1lIGEgcG9zaXRpdmUgaW50ZWdlcicsICdcXFxcYmVnaW57JyArIGJlZ2luLmdldE5hbWUoKSArICd9Jyk7XG4gICAgfVxuICAgIHZhciBhbGlnbiA9IChwYWRkZWQgPyAnY3JsJyA6ICdybGMnKTtcbiAgICB2YXIgd2lkdGggPSAocGFkZGVkID8gJ2ZpdCBhdXRvIGF1dG8nIDogJ2F1dG8gYXV0byBmaXQnKTtcbiAgICB2YXIgaXRlbSA9IGV4cG9ydHMuQW1zTWV0aG9kcy5GbGFsaWduQXJyYXkocGFyc2VyLCBiZWdpbiwgbnVtYmVyZWQsIHBhZGRlZCwgZmFsc2UsIGFsaWduLCB3aWR0aCwgdHJ1ZSk7XG4gICAgaXRlbS5zZXRQcm9wZXJ0eSgneGFsaWduYXQnLCAyICogcGFyc2VJbnQobikpO1xuICAgIHJldHVybiBpdGVtO1xufTtcbmV4cG9ydHMuQW1zTWV0aG9kcy5GbGFsaWduQXJyYXkgPSBmdW5jdGlvbiAocGFyc2VyLCBiZWdpbiwgbnVtYmVyZWQsIHBhZGRlZCwgY2VudGVyLCBhbGlnbiwgd2lkdGgsIHplcm9XaWR0aExhYmVsKSB7XG4gICAgaWYgKHplcm9XaWR0aExhYmVsID09PSB2b2lkIDApIHsgemVyb1dpZHRoTGFiZWwgPSBmYWxzZTsgfVxuICAgIHBhcnNlci5QdXNoKGJlZ2luKTtcbiAgICBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmNoZWNrRXFuRW52KHBhcnNlcik7XG4gICAgYWxpZ24gPSBhbGlnblxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5qb2luKCcgJylcbiAgICAgICAgLnJlcGxhY2UoL3IvZywgJ3JpZ2h0JylcbiAgICAgICAgLnJlcGxhY2UoL2wvZywgJ2xlZnQnKVxuICAgICAgICAucmVwbGFjZSgvYy9nLCAnY2VudGVyJyk7XG4gICAgdmFyIGl0ZW0gPSBwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKCdmbGFsaWduJywgYmVnaW4uZ2V0TmFtZSgpLCBudW1iZXJlZCwgcGFkZGVkLCBjZW50ZXIsIHBhcnNlci5zdGFjayk7XG4gICAgaXRlbS5hcnJheWRlZiA9IHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgZGlzcGxheXN0eWxlOiB0cnVlLFxuICAgICAgICBjb2x1bW5hbGlnbjogYWxpZ24sXG4gICAgICAgIGNvbHVtbnNwYWNpbmc6ICcwZW0nLFxuICAgICAgICBjb2x1bW53aWR0aDogd2lkdGgsXG4gICAgICAgIHJvd3NwYWNpbmc6ICczcHQnLFxuICAgICAgICBzaWRlOiBwYXJzZXIub3B0aW9uc1sndGFnU2lkZSddLFxuICAgICAgICBtaW5sYWJlbHNwYWNpbmc6ICh6ZXJvV2lkdGhMYWJlbCA/ICcwJyA6IHBhcnNlci5vcHRpb25zWyd0YWdJbmRlbnQnXSksXG4gICAgICAgICdkYXRhLXdpZHRoLWluY2x1ZGVzLWxhYmVsJzogdHJ1ZSxcbiAgICB9O1xuICAgIGl0ZW0uc2V0UHJvcGVydHkoJ3plcm9XaWR0aExhYmVsJywgemVyb1dpZHRoTGFiZWwpO1xuICAgIHJldHVybiBpdGVtO1xufTtcbmV4cG9ydHMuTkVXX09QUyA9ICdhbXMtZGVjbGFyZS1vcHMnO1xuZXhwb3J0cy5BbXNNZXRob2RzLkhhbmRsZURlY2xhcmVPcCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgc3RhciA9IChwYXJzZXIuR2V0U3RhcigpID8gJyonIDogJycpO1xuICAgIHZhciBjcyA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQudHJpbVNwYWNlcyhwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkpO1xuICAgIGlmIChjcy5jaGFyQXQoMCkgPT09ICdcXFxcJykge1xuICAgICAgICBjcyA9IGNzLnN1YnN0cigxKTtcbiAgICB9XG4gICAgdmFyIG9wID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHBhcnNlci5jb25maWd1cmF0aW9uLmhhbmRsZXJzLnJldHJpZXZlKGV4cG9ydHMuTkVXX09QUykuXG4gICAgICAgIGFkZChjcywgbmV3IFN5bWJvbF9qc18xLk1hY3JvKGNzLCBleHBvcnRzLkFtc01ldGhvZHMuTWFjcm8sIFtcIlxcXFxvcGVyYXRvcm5hbWVcIi5jb25jYXQoc3RhciwgXCJ7XCIpLmNvbmNhdChvcCwgXCJ9XCIpXSkpO1xufTtcbmV4cG9ydHMuQW1zTWV0aG9kcy5IYW5kbGVPcGVyYXRvck5hbWUgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0YXIgPSBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBvcCA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQudHJpbVNwYWNlcyhwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkpO1xuICAgIHZhciBtbWwgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChvcCwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcnNlci5zdGFjay5lbnYpLCB7IGZvbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuTk9STUFMLCBtdWx0aUxldHRlcklkZW50aWZpZXJzOiAvXlstKmEtel0rL2ksIG9wZXJhdG9yTGV0dGVyczogdHJ1ZSB9KSwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgIGlmICghbW1sLmlzS2luZCgnbWknKSkge1xuICAgICAgICBtbWwgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ1RlWEF0b20nLCBbbW1sXSk7XG4gICAgfVxuICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRQcm9wZXJ0aWVzKG1tbCwgeyBtb3Zlc3Vwc3ViOiBzdGFyLCBtb3ZhYmxlbGltaXRzOiB0cnVlLCB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLk9QIH0pO1xuICAgIGlmICghc3Rhcikge1xuICAgICAgICB2YXIgYyA9IHBhcnNlci5HZXROZXh0KCksIGkgPSBwYXJzZXIuaTtcbiAgICAgICAgaWYgKGMgPT09ICdcXFxcJyAmJiArK3BhcnNlci5pICYmIHBhcnNlci5HZXRDUygpICE9PSAnbGltaXRzJykge1xuICAgICAgICAgICAgcGFyc2VyLmkgPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlci5QdXNoKG1tbCk7XG59O1xuZXhwb3J0cy5BbXNNZXRob2RzLlNpZGVTZXQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHNwbGl0U2lkZVNldChwYXJzZXIuUGFyc2VBcmcobmFtZSkpLCAyKSwgcHJlU2NyaXB0cyA9IF9hWzBdLCBwcmVSZXN0ID0gX2FbMV07XG4gICAgdmFyIF9iID0gX19yZWFkKHNwbGl0U2lkZVNldChwYXJzZXIuUGFyc2VBcmcobmFtZSkpLCAyKSwgcG9zdFNjcmlwdHMgPSBfYlswXSwgcG9zdFJlc3QgPSBfYlsxXTtcbiAgICB2YXIgYmFzZSA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICB2YXIgbW1sID0gYmFzZTtcbiAgICBpZiAocHJlU2NyaXB0cykge1xuICAgICAgICBpZiAocHJlUmVzdCkge1xuICAgICAgICAgICAgcHJlU2NyaXB0cy5yZXBsYWNlQ2hpbGQocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGhhbnRvbScsIFtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBbUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jb3B5Tm9kZShiYXNlLCBwYXJzZXIpXSwgeyB3aWR0aDogMCB9KVxuICAgICAgICAgICAgXSksIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZEF0KHByZVNjcmlwdHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbW11bHRpc2NyaXB0cycsIFtiYXNlXSk7XG4gICAgICAgICAgICBpZiAocG9zdFNjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuYXBwZW5kQ2hpbGRyZW4obW1sLCBbXG4gICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZEF0KHBvc3RTY3JpcHRzLCAxKSB8fCBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ25vbmUnKSxcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkQXQocG9zdFNjcmlwdHMsIDIpIHx8IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbm9uZScpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0UHJvcGVydHkobW1sLCAnc2NyaXB0YWxpZ24nLCAnbGVmdCcpO1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmFwcGVuZENoaWxkcmVuKG1tbCwgW1xuICAgICAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXByZXNjcmlwdHMnKSxcbiAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRBdChwcmVTY3JpcHRzLCAxKSB8fCBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ25vbmUnKSxcbiAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRBdChwcmVTY3JpcHRzLCAyKSB8fCBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ25vbmUnKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvc3RTY3JpcHRzICYmIG1tbCA9PT0gYmFzZSkge1xuICAgICAgICBwb3N0U2NyaXB0cy5yZXBsYWNlQ2hpbGQoYmFzZSwgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkQXQocG9zdFNjcmlwdHMsIDApKTtcbiAgICAgICAgbW1sID0gcG9zdFNjcmlwdHM7XG4gICAgfVxuICAgIHZhciBtcm93ID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgW10sIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5PUCwgbW92ZXN1cHN1YjogdHJ1ZSwgbW92YWJsZWxpbWl0czogdHJ1ZSB9KTtcbiAgICBpZiAocHJlUmVzdCkge1xuICAgICAgICBwcmVTY3JpcHRzICYmIG1yb3cuYXBwZW5kQ2hpbGQocHJlU2NyaXB0cyk7XG4gICAgICAgIG1yb3cuYXBwZW5kQ2hpbGQocHJlUmVzdCk7XG4gICAgfVxuICAgIG1yb3cuYXBwZW5kQ2hpbGQobW1sKTtcbiAgICBwb3N0UmVzdCAmJiBtcm93LmFwcGVuZENoaWxkKHBvc3RSZXN0KTtcbiAgICBwYXJzZXIuUHVzaChtcm93KTtcbn07XG5mdW5jdGlvbiBzcGxpdFNpZGVTZXQobW1sKSB7XG4gICAgaWYgKCFtbWwgfHwgKG1tbC5pc0luZmVycmVkICYmIG1tbC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgaWYgKG1tbC5pc0tpbmQoJ21zdWJzdXAnKSAmJiBjaGVja1NpZGVTZXRCYXNlKG1tbCkpXG4gICAgICAgIHJldHVybiBbbW1sLCBudWxsXTtcbiAgICB2YXIgY2hpbGQgPSBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRBdChtbWwsIDApO1xuICAgIGlmICghKG1tbC5pc0luZmVycmVkICYmIGNoaWxkICYmIGNoZWNrU2lkZVNldEJhc2UoY2hpbGQpKSlcbiAgICAgICAgcmV0dXJuIFtudWxsLCBtbWxdO1xuICAgIG1tbC5jaGlsZE5vZGVzLnNwbGljZSgwLCAxKTtcbiAgICByZXR1cm4gW2NoaWxkLCBtbWxdO1xufVxuZnVuY3Rpb24gY2hlY2tTaWRlU2V0QmFzZShtbWwpIHtcbiAgICB2YXIgYmFzZSA9IG1tbC5jaGlsZE5vZGVzWzBdO1xuICAgIHJldHVybiBiYXNlICYmIGJhc2UuaXNLaW5kKCdtaScpICYmIGJhc2UuZ2V0VGV4dCgpID09PSAnJztcbn1cbmV4cG9ydHMuQW1zTWV0aG9kcy5vcGVyYXRvckxldHRlciA9IGZ1bmN0aW9uIChwYXJzZXIsIGMpIHtcbiAgICByZXR1cm4gcGFyc2VyLnN0YWNrLmVudi5vcGVyYXRvckxldHRlcnMgPyBQYXJzZU1ldGhvZHNfanNfMS5kZWZhdWx0LnZhcmlhYmxlKHBhcnNlciwgYykgOiBmYWxzZTtcbn07XG5leHBvcnRzLkFtc01ldGhvZHMuTXVsdGlJbnRlZ3JhbCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUsIGludGVncmFsKSB7XG4gICAgdmFyIG5leHQgPSBwYXJzZXIuR2V0TmV4dCgpO1xuICAgIGlmIChuZXh0ID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFyIGkgPSBwYXJzZXIuaTtcbiAgICAgICAgbmV4dCA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAgICAgcGFyc2VyLmkgPSBpO1xuICAgICAgICBpZiAobmV4dCA9PT0gJ1xcXFxsaW1pdHMnKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ1xcXFxpZG90c2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbnRlZ3JhbCA9ICdcXFxcIVxcXFwhXFxcXG1hdGhvcHtcXFxcLFxcXFwsJyArIGludGVncmFsICsgJ30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZWdyYWwgPSAnXFxcXCFcXFxcIVxcXFwhXFxcXG1hdGhvcHtcXFxcLFxcXFwsXFxcXCwnICsgaW50ZWdyYWwgKyAnfSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VyLnN0cmluZyA9IGludGVncmFsICsgJyAnICsgcGFyc2VyLnN0cmluZy5zbGljZShwYXJzZXIuaSk7XG4gICAgcGFyc2VyLmkgPSAwO1xufTtcbmV4cG9ydHMuQW1zTWV0aG9kcy54QXJyb3cgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBjaHIsIGwsIHIpIHtcbiAgICB2YXIgZGVmID0geyB3aWR0aDogJysnICsgUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5FbSgobCArIHIpIC8gMTgpLCBsc3BhY2U6IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuRW0obCAvIDE4KSB9O1xuICAgIHZhciBib3QgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSk7XG4gICAgdmFyIGZpcnN0ID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIHZhciBkc3RydXQgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zcGFjZScsIFtdLCB7IGRlcHRoOiAnLjI1ZW0nIH0pO1xuICAgIHZhciBhcnJvdyA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywgeyBzdHJldGNoeTogdHJ1ZSwgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5SRUwgfSwgU3RyaW5nLmZyb21Db2RlUG9pbnQoY2hyKSk7XG4gICAgYXJyb3cgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zdHlsZScsIFthcnJvd10sIHsgc2NyaXB0bGV2ZWw6IDAgfSk7XG4gICAgdmFyIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXVuZGVyb3ZlcicsIFthcnJvd10pO1xuICAgIHZhciBtcGFkZGVkID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW2ZpcnN0LCBkc3RydXRdLCBkZWYpO1xuICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobXBhZGRlZCwgJ3ZvZmZzZXQnLCAnLS4yZW0nKTtcbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKG1wYWRkZWQsICdoZWlnaHQnLCAnLS4yZW0nKTtcbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0Q2hpbGQobW1sLCBtbWwub3ZlciwgbXBhZGRlZCk7XG4gICAgaWYgKGJvdCkge1xuICAgICAgICB2YXIgYm90dG9tID0gbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoYm90LCBwYXJzZXIuc3RhY2suZW52LCBwYXJzZXIuY29uZmlndXJhdGlvbikubW1sKCk7XG4gICAgICAgIHZhciBic3RydXQgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zcGFjZScsIFtdLCB7IGhlaWdodDogJy43NWVtJyB9KTtcbiAgICAgICAgbXBhZGRlZCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtib3R0b20sIGJzdHJ1dF0sIGRlZik7XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobXBhZGRlZCwgJ3ZvZmZzZXQnLCAnLjE1ZW0nKTtcbiAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShtcGFkZGVkLCAnZGVwdGgnLCAnLS4xNWVtJyk7XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRDaGlsZChtbWwsIG1tbC51bmRlciwgbXBhZGRlZCk7XG4gICAgfVxuICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRQcm9wZXJ0eShtbWwsICdzdWJzdXBPSycsIHRydWUpO1xuICAgIHBhcnNlci5QdXNoKG1tbCk7XG59O1xuZXhwb3J0cy5BbXNNZXRob2RzLkhhbmRsZVNob3ZlID0gZnVuY3Rpb24gKHBhcnNlciwgX25hbWUsIHNob3ZlKSB7XG4gICAgdmFyIHRvcCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICBpZiAodG9wLmtpbmQgIT09ICdtdWx0bGluZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnQ29tbWFuZE9ubHlBbGxvd2VkSW5FbnYnLCAnJTEgb25seSBhbGxvd2VkIGluICUyIGVudmlyb25tZW50JywgcGFyc2VyLmN1cnJlbnRDUywgJ211bHRsaW5lJyk7XG4gICAgfVxuICAgIGlmICh0b3AuU2l6ZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0NvbW1hbmRBdFRoZUJlZ2luaW5nT2ZMaW5lJywgJyUxIG11c3QgY29tZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lJywgcGFyc2VyLmN1cnJlbnRDUyk7XG4gICAgfVxuICAgIHRvcC5zZXRQcm9wZXJ0eSgnc2hvdmUnLCBzaG92ZSk7XG59O1xuZXhwb3J0cy5BbXNNZXRob2RzLkNGcmFjID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBsciA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQudHJpbVNwYWNlcyhwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpKTtcbiAgICB2YXIgbnVtID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBkZW4gPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIGxyTWFwID0ge1xuICAgICAgICBsOiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5BbGlnbi5MRUZULCByOiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5BbGlnbi5SSUdIVCwgJyc6ICcnXG4gICAgfTtcbiAgICB2YXIgbnVtTm9kZSA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KCdcXFxcc3RydXRcXFxcdGV4dHN0eWxleycgKyBudW0gKyAnfScsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICB2YXIgZGVuTm9kZSA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KCdcXFxcc3RydXRcXFxcdGV4dHN0eWxleycgKyBkZW4gKyAnfScsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICB2YXIgZnJhYyA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbWZyYWMnLCBbbnVtTm9kZSwgZGVuTm9kZV0pO1xuICAgIGxyID0gbHJNYXBbbHJdO1xuICAgIGlmIChsciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxBbGlnbicsICdJbGxlZ2FsIGFsaWdubWVudCBzcGVjaWZpZWQgaW4gJTEnLCBwYXJzZXIuY3VycmVudENTKTtcbiAgICB9XG4gICAgaWYgKGxyKSB7XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRQcm9wZXJ0aWVzKGZyYWMsIHsgbnVtYWxpZ246IGxyLCBkZW5vbWFsaWduOiBsciB9KTtcbiAgICB9XG4gICAgcGFyc2VyLlB1c2goZnJhYyk7XG59O1xuZXhwb3J0cy5BbXNNZXRob2RzLkdlbmZyYWMgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBsZWZ0LCByaWdodCwgdGhpY2ssIHN0eWxlKSB7XG4gICAgaWYgKGxlZnQgPT0gbnVsbCkge1xuICAgICAgICBsZWZ0ID0gcGFyc2VyLkdldERlbGltaXRlckFyZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgcmlnaHQgPSBwYXJzZXIuR2V0RGVsaW1pdGVyQXJnKG5hbWUpO1xuICAgIH1cbiAgICBpZiAodGhpY2sgPT0gbnVsbCkge1xuICAgICAgICB0aGljayA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09IG51bGwpIHtcbiAgICAgICAgc3R5bGUgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnRyaW1TcGFjZXMocGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKTtcbiAgICB9XG4gICAgdmFyIG51bSA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICB2YXIgZGVuID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIHZhciBmcmFjID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtZnJhYycsIFtudW0sIGRlbl0pO1xuICAgIGlmICh0aGljayAhPT0gJycpIHtcbiAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShmcmFjLCAnbGluZXRoaWNrbmVzcycsIHRoaWNrKTtcbiAgICB9XG4gICAgaWYgKGxlZnQgfHwgcmlnaHQpIHtcbiAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnR5KGZyYWMsICd3aXRoRGVsaW1zJywgdHJ1ZSk7XG4gICAgICAgIGZyYWMgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmZpeGVkRmVuY2UocGFyc2VyLmNvbmZpZ3VyYXRpb24sIGxlZnQsIGZyYWMsIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgICB2YXIgc3R5bGVEaWdpdCA9IHBhcnNlSW50KHN0eWxlLCAxMCk7XG4gICAgICAgIHZhciBzdHlsZUFscGhhID0gWydEJywgJ1QnLCAnUycsICdTUyddW3N0eWxlRGlnaXRdO1xuICAgICAgICBpZiAoc3R5bGVBbHBoYSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdCYWRNYXRoU3R5bGVGb3InLCAnQmFkIG1hdGggc3R5bGUgZm9yICUxJywgcGFyc2VyLmN1cnJlbnRDUyk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhYyA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXN0eWxlJywgW2ZyYWNdKTtcbiAgICAgICAgaWYgKHN0eWxlQWxwaGEgPT09ICdEJykge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnRpZXMoZnJhYywgeyBkaXNwbGF5c3R5bGU6IHRydWUsIHNjcmlwdGxldmVsOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnRpZXMoZnJhYywgeyBkaXNwbGF5c3R5bGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjcmlwdGxldmVsOiBzdHlsZURpZ2l0IC0gMSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuUHVzaChmcmFjKTtcbn07XG5leHBvcnRzLkFtc01ldGhvZHMuSGFuZGxlVGFnID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIGlmICghcGFyc2VyLnRhZ3MuY3VycmVudFRhZy50YWdnYWJsZSAmJiBwYXJzZXIudGFncy5lbnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnQ29tbWFuZE5vdEFsbG93ZWRJbkVudicsICclMSBub3QgYWxsb3dlZCBpbiAlMiBlbnZpcm9ubWVudCcsIHBhcnNlci5jdXJyZW50Q1MsIHBhcnNlci50YWdzLmVudik7XG4gICAgfVxuICAgIGlmIChwYXJzZXIudGFncy5jdXJyZW50VGFnLnRhZykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNdWx0aXBsZUNvbW1hbmQnLCAnTXVsdGlwbGUgJTEnLCBwYXJzZXIuY3VycmVudENTKTtcbiAgICB9XG4gICAgdmFyIHN0YXIgPSBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciB0YWdJZCA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQudHJpbVNwYWNlcyhwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkpO1xuICAgIHBhcnNlci50YWdzLnRhZyh0YWdJZCwgc3Rhcik7XG59O1xuZXhwb3J0cy5BbXNNZXRob2RzLkhhbmRsZU5vVGFnID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0LkhhbmRsZU5vVGFnO1xuZXhwb3J0cy5BbXNNZXRob2RzLkhhbmRsZVJlZiA9IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5IYW5kbGVSZWY7XG5leHBvcnRzLkFtc01ldGhvZHMuTWFjcm8gPSBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuTWFjcm87XG5leHBvcnRzLkFtc01ldGhvZHMuQWNjZW50ID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0LkFjY2VudDtcbmV4cG9ydHMuQW1zTWV0aG9kcy5UaWxkZSA9IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5UaWxkZTtcbmV4cG9ydHMuQW1zTWV0aG9kcy5BcnJheSA9IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5BcnJheTtcbmV4cG9ydHMuQW1zTWV0aG9kcy5TcGFjZXIgPSBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuU3BhY2VyO1xuZXhwb3J0cy5BbXNNZXRob2RzLk5hbWVkT3AgPSBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuTmFtZWRPcDtcbmV4cG9ydHMuQW1zTWV0aG9kcy5FcW5BcnJheSA9IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5FcW5BcnJheTtcbmV4cG9ydHMuQW1zTWV0aG9kcy5FcXVhdGlvbiA9IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5FcXVhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFtc01ldGhvZHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFtc0NkQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuL0Ftc0NkTWFwcGluZ3MuanNcIik7XG5leHBvcnRzLkFtc0NkQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnYW1zY2QnLCB7XG4gICAgaGFuZGxlcjoge1xuICAgICAgICBjaGFyYWN0ZXI6IFsnYW1zY2Rfc3BlY2lhbCddLFxuICAgICAgICBtYWNybzogWydhbXNjZF9tYWNyb3MnXSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IFsnYW1zY2RfZW52aXJvbm1lbnQnXVxuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBhbXNjZDoge1xuICAgICAgICAgICAgY29sc3BhY2U6ICc1cHQnLFxuICAgICAgICAgICAgcm93c3BhY2U6ICc1cHQnLFxuICAgICAgICAgICAgaGFycm93c2l6ZTogJzIuNzVlbScsXG4gICAgICAgICAgICB2YXJyb3dzaXplOiAnMS43NWVtJyxcbiAgICAgICAgICAgIGhpZGVIb3Jpem9udGFsTGFiZWxzOiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbXNDZENvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpKTtcbnZhciBQYXJzZU1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VNZXRob2RzLmpzXCIpKTtcbnZhciBBbXNDZE1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9BbXNDZE1ldGhvZHMuanNcIikpO1xubmV3IHNtLkVudmlyb25tZW50TWFwKCdhbXNjZF9lbnZpcm9ubWVudCcsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQuZW52aXJvbm1lbnQsIHsgQ0Q6ICdDRCcgfSwgQW1zQ2RNZXRob2RzX2pzXzEuZGVmYXVsdCk7XG5uZXcgc20uQ29tbWFuZE1hcCgnYW1zY2RfbWFjcm9zJywge1xuICAgIG1pbkNEYXJyb3d3aWR0aDogJ21pbkNEYXJyb3d3aWR0aCcsXG4gICAgbWluQ0RhcnJvd2hlaWdodDogJ21pbkNEYXJyb3doZWlnaHQnLFxufSwgQW1zQ2RNZXRob2RzX2pzXzEuZGVmYXVsdCk7XG5uZXcgc20uTWFjcm9NYXAoJ2Ftc2NkX3NwZWNpYWwnLCB7ICdAJzogJ2Fycm93JyB9LCBBbXNDZE1ldGhvZHNfanNfMS5kZWZhdWx0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFtc0NkTWFwcGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4UGFyc2VyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleFBhcnNlci5qc1wiKSk7XG52YXIgQmFzZUNvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9iYXNlL0Jhc2VDb25maWd1cmF0aW9uLmpzXCIpO1xudmFyIE1tbE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZS5qc1wiKTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgQW1zQ2RNZXRob2RzID0ge307XG5BbXNDZE1ldGhvZHMuQ0QgPSBmdW5jdGlvbiAocGFyc2VyLCBiZWdpbikge1xuICAgIHBhcnNlci5QdXNoKGJlZ2luKTtcbiAgICB2YXIgaXRlbSA9IHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2FycmF5Jyk7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIuY29uZmlndXJhdGlvbi5vcHRpb25zLmFtc2NkO1xuICAgIGl0ZW0uc2V0UHJvcGVydGllcyh7XG4gICAgICAgIG1pbnc6IHBhcnNlci5zdGFjay5lbnYuQ0RfbWludyB8fCBvcHRpb25zLmhhcnJvd3NpemUsXG4gICAgICAgIG1pbmg6IHBhcnNlci5zdGFjay5lbnYuQ0RfbWluaCB8fCBvcHRpb25zLnZhcnJvd3NpemVcbiAgICB9KTtcbiAgICBpdGVtLmFycmF5ZGVmID0ge1xuICAgICAgICBjb2x1bW5hbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGNvbHVtbnNwYWNpbmc6IG9wdGlvbnMuY29sc3BhY2UsXG4gICAgICAgIHJvd3NwYWNpbmc6IG9wdGlvbnMucm93c3BhY2UsXG4gICAgICAgIGRpc3BsYXlzdHlsZTogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIGl0ZW07XG59O1xuQW1zQ2RNZXRob2RzLmFycm93ID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBjID0gcGFyc2VyLnN0cmluZy5jaGFyQXQocGFyc2VyLmkpO1xuICAgIGlmICghYy5tYXRjaCgvWz48VkEufD1dLykpIHtcbiAgICAgICAgcmV0dXJuICgwLCBCYXNlQ29uZmlndXJhdGlvbl9qc18xLk90aGVyKShwYXJzZXIsIG5hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyc2VyLmkrKztcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gcGFyc2VyLnN0YWNrLlRvcCgpO1xuICAgIGlmICghZmlyc3QuaXNLaW5kKCdhcnJheScpIHx8IGZpcnN0LlNpemUoKSkge1xuICAgICAgICBBbXNDZE1ldGhvZHMuY2VsbChwYXJzZXIsIG5hbWUpO1xuICAgICAgICBmaXJzdCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICB9XG4gICAgdmFyIHRvcCA9IGZpcnN0O1xuICAgIHZhciBhcnJvd1JvdyA9ICgodG9wLnRhYmxlLmxlbmd0aCAlIDIpID09PSAxKTtcbiAgICB2YXIgbiA9ICh0b3Aucm93Lmxlbmd0aCArIChhcnJvd1JvdyA/IDAgOiAxKSkgJSAyO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICAgIEFtc0NkTWV0aG9kcy5jZWxsKHBhcnNlciwgbmFtZSk7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgdmFyIG1tbDtcbiAgICB2YXIgaGRlZiA9IHsgbWluc2l6ZTogdG9wLmdldFByb3BlcnR5KCdtaW53JyksIHN0cmV0Y2h5OiB0cnVlIH0sIHZkZWYgPSB7IG1pbnNpemU6IHRvcC5nZXRQcm9wZXJ0eSgnbWluaCcpLFxuICAgICAgICBzdHJldGNoeTogdHJ1ZSwgc3ltbWV0cmljOiB0cnVlLCBsc3BhY2U6IDAsIHJzcGFjZTogMCB9O1xuICAgIGlmIChjID09PSAnLicpIHtcbiAgICB9XG4gICAgZWxzZSBpZiAoYyA9PT0gJ3wnKSB7XG4gICAgICAgIG1tbCA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywgdmRlZiwgJ1xcdTIyMjUnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgIG1tbCA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywgaGRlZiwgJz0nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBhcnJvdyA9IHtcbiAgICAgICAgICAgICc+JzogJ1xcdTIxOTInLCAnPCc6ICdcXHUyMTkwJywgJ1YnOiAnXFx1MjE5MycsICdBJzogJ1xcdTIxOTEnXG4gICAgICAgIH1bY107XG4gICAgICAgIHZhciBhID0gcGFyc2VyLkdldFVwVG8obmFtZSArIGMsIGMpO1xuICAgICAgICB2YXIgYiA9IHBhcnNlci5HZXRVcFRvKG5hbWUgKyBjLCBjKTtcbiAgICAgICAgaWYgKGMgPT09ICc+JyB8fCBjID09PSAnPCcpIHtcbiAgICAgICAgICAgIG1tbCA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywgaGRlZiwgYXJyb3cpO1xuICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgICAgYSA9ICdcXFxca2VybiAnICsgdG9wLmdldFByb3BlcnR5KCdtaW53Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSB8fCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZCA9IHsgd2lkdGg6ICcrLjY3ZW0nLCBsc3BhY2U6ICcuMzNlbScgfTtcbiAgICAgICAgICAgICAgICBtbWwgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ211bmRlcm92ZXInLCBbbW1sXSk7XG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVBID0gbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoYSwgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXBhZGRlZCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtub2RlQV0sIHBhZCk7XG4gICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobXBhZGRlZCwgJ3ZvZmZzZXQnLCAnLjFlbScpO1xuICAgICAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0Q2hpbGQobW1sLCBtbWwub3ZlciwgbXBhZGRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlQiA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KGIsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldENoaWxkKG1tbCwgbW1sLnVuZGVyLCBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBbbm9kZUJdLCBwYWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5jb25maWd1cmF0aW9uLm9wdGlvbnMuYW1zY2QuaGlkZUhvcml6b250YWxMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbW1sID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgbW1sLCB7IGRlcHRoOiAwLCBoZWlnaHQ6ICcuNjdlbScgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFycm93Tm9kZSA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywgdmRlZiwgYXJyb3cpO1xuICAgICAgICAgICAgbW1sID0gYXJyb3dOb2RlO1xuICAgICAgICAgICAgaWYgKGEgfHwgYikge1xuICAgICAgICAgICAgICAgIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXJvdycpO1xuICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5hcHBlbmRDaGlsZHJlbihtbWwsIFtuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdCgnXFxcXHNjcmlwdHN0eWxlXFxcXGxsYXB7JyArIGEgKyAnfScsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJvd05vZGUudGV4Q2xhc3MgPSBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuT1JEO1xuICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5hcHBlbmRDaGlsZHJlbihtbWwsIFthcnJvd05vZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuYXBwZW5kQ2hpbGRyZW4obW1sLCBbbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoJ1xcXFxzY3JpcHRzdHlsZVxcXFxybGFweycgKyBiICsgJ30nLCBwYXJzZXIuc3RhY2suZW52LCBwYXJzZXIuY29uZmlndXJhdGlvbikubW1sKCldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1tbCkge1xuICAgICAgICBwYXJzZXIuUHVzaChtbWwpO1xuICAgIH1cbiAgICBBbXNDZE1ldGhvZHMuY2VsbChwYXJzZXIsIG5hbWUpO1xufTtcbkFtc0NkTWV0aG9kcy5jZWxsID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciB0b3AgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgaWYgKCh0b3AudGFibGUgfHwgW10pLmxlbmd0aCAlIDIgPT09IDAgJiYgKHRvcC5yb3cgfHwgW10pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJzZXIuUHVzaChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBbXSwgeyBoZWlnaHQ6ICc4LjVwdCcsIGRlcHRoOiAnMnB0JyB9KSk7XG4gICAgfVxuICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2NlbGwnKS5zZXRQcm9wZXJ0aWVzKHsgaXNFbnRyeTogdHJ1ZSwgbmFtZTogbmFtZSB9KSk7XG59O1xuQW1zQ2RNZXRob2RzLm1pbkNEYXJyb3d3aWR0aCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICBwYXJzZXIuc3RhY2suZW52LkNEX21pbncgPSBwYXJzZXIuR2V0RGltZW4obmFtZSk7XG59O1xuQW1zQ2RNZXRob2RzLm1pbkNEYXJyb3doZWlnaHQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgcGFyc2VyLnN0YWNrLmVudi5DRF9taW5oID0gcGFyc2VyLkdldERpbWVuKG5hbWUpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFtc0NkTWV0aG9kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFtc0NkTWV0aG9kcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmJveENvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkJib3hNZXRob2RzID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG5leHBvcnRzLkJib3hNZXRob2RzID0ge307XG5leHBvcnRzLkJib3hNZXRob2RzLkJCb3ggPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGJib3ggPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgIHZhciBtYXRoID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIHZhciBwYXJ0cyA9IGJib3guc3BsaXQoLywvKTtcbiAgICB2YXIgZGVmLCBiYWNrZ3JvdW5kLCBzdHlsZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbSA9IHBhcnRzLmxlbmd0aDsgaSA8IG07IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldLnRyaW0oKTtcbiAgICAgICAgdmFyIG1hdGNoID0gcGFydC5tYXRjaCgvXihcXC5cXGQrfFxcZCsoXFwuXFxkKik/KShwdHxlbXxleHxtdXxweHxpbnxjbXxtbSkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ011bHRpcGxlQkJveFByb3BlcnR5JywgJyUxIHNwZWNpZmllZCB0d2ljZSBpbiAlMicsICdQYWRkaW5nJywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFkID0gQkJveFBhZGRpbmcobWF0Y2hbMV0gKyBtYXRjaFszXSk7XG4gICAgICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgICAgICAgZGVmID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcrJyArIHBhZCxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGg6ICcrJyArIHBhZCxcbiAgICAgICAgICAgICAgICAgICAgbHNwYWNlOiBwYWQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnKycgKyAoMiAqIHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpICsgbWF0Y2hbM11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnQubWF0Y2goL14oW2EtejAtOV0rfFxcI1swLTlhLWZdezZ9fFxcI1swLTlhLWZdezN9KSQvaSkpIHtcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTXVsdGlwbGVCQm94UHJvcGVydHknLCAnJTEgc3BlY2lmaWVkIHR3aWNlIGluICUyJywgJ0JhY2tncm91bmQnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBwYXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnQubWF0Y2goL15bLWEtel0rOi9pKSkge1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTXVsdGlwbGVCQm94UHJvcGVydHknLCAnJTEgc3BlY2lmaWVkIHR3aWNlIGluICUyJywgJ1N0eWxlJywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZSA9IEJCb3hTdHlsZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0ICE9PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSW52YWxpZEJCb3hQcm9wZXJ0eScsICdcIiUxXCIgZG9lc25cXCd0IGxvb2sgbGlrZSBhIGNvbG9yLCBhIHBhZGRpbmcgZGltZW5zaW9uLCBvciBhIHN0eWxlJywgcGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZikge1xuICAgICAgICBtYXRoID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW21hdGhdLCBkZWYpO1xuICAgIH1cbiAgICBpZiAoYmFja2dyb3VuZCB8fCBzdHlsZSkge1xuICAgICAgICBkZWYgPSB7fTtcbiAgICAgICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGVmLCB7IG1hdGhiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkZWYsIHsgc3R5bGU6IHN0eWxlIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1hdGggPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zdHlsZScsIFttYXRoXSwgZGVmKTtcbiAgICB9XG4gICAgcGFyc2VyLlB1c2gobWF0aCk7XG59O1xudmFyIEJCb3hTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICByZXR1cm4gc3R5bGVzO1xufTtcbnZhciBCQm94UGFkZGluZyA9IGZ1bmN0aW9uIChwYWQpIHtcbiAgICByZXR1cm4gcGFkO1xufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdiYm94JywgeyBiYm94OiAnQkJveCcgfSwgZXhwb3J0cy5CYm94TWV0aG9kcyk7XG5leHBvcnRzLkJib3hDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdiYm94JywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ2Jib3gnXSB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmJveENvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvbGRzeW1ib2xDb25maWd1cmF0aW9uID0gZXhwb3J0cy5yZXdyaXRlQm9sZFRva2VucyA9IGV4cG9ydHMuY3JlYXRlQm9sZFRva2VuID0gZXhwb3J0cy5Cb2xkc3ltYm9sTWV0aG9kcyA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgVGV4Q29uc3RhbnRzX2pzXzEgPSByZXF1aXJlKFwiLi4vVGV4Q29uc3RhbnRzLmpzXCIpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBOb2RlRmFjdG9yeV9qc18xID0gcmVxdWlyZShcIi4uL05vZGVGYWN0b3J5LmpzXCIpO1xudmFyIEJPTERWQVJJQU5UID0ge307XG5CT0xEVkFSSUFOVFtUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk5PUk1BTF0gPSBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkJPTEQ7XG5CT0xEVkFSSUFOVFtUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LklUQUxJQ10gPSBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkJPTERJVEFMSUM7XG5CT0xEVkFSSUFOVFtUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkZSQUtUVVJdID0gVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5CT0xERlJBS1RVUjtcbkJPTERWQVJJQU5UW1RleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuU0NSSVBUXSA9IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQk9MRFNDUklQVDtcbkJPTERWQVJJQU5UW1RleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuU0FOU1NFUklGXSA9IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQk9MRFNBTlNTRVJJRjtcbkJPTERWQVJJQU5UWyctdGV4LWNhbGxpZ3JhcGhpYyddID0gJy10ZXgtYm9sZC1jYWxsaWdyYXBoaWMnO1xuQk9MRFZBUklBTlRbJy10ZXgtb2xkc3R5bGUnXSA9ICctdGV4LWJvbGQtb2xkc3R5bGUnO1xuQk9MRFZBUklBTlRbJy10ZXgtbWF0aGl0J10gPSBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkJPTERJVEFMSUM7XG5leHBvcnRzLkJvbGRzeW1ib2xNZXRob2RzID0ge307XG5leHBvcnRzLkJvbGRzeW1ib2xNZXRob2RzLkJvbGRzeW1ib2wgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGJvbGRzeW1ib2wgPSBwYXJzZXIuc3RhY2suZW52Wydib2xkc3ltYm9sJ107XG4gICAgcGFyc2VyLnN0YWNrLmVudlsnYm9sZHN5bWJvbCddID0gdHJ1ZTtcbiAgICB2YXIgbW1sID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIHBhcnNlci5zdGFjay5lbnZbJ2JvbGRzeW1ib2wnXSA9IGJvbGRzeW1ib2w7XG4gICAgcGFyc2VyLlB1c2gobW1sKTtcbn07XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnYm9sZHN5bWJvbCcsIHsgYm9sZHN5bWJvbDogJ0JvbGRzeW1ib2wnIH0sIGV4cG9ydHMuQm9sZHN5bWJvbE1ldGhvZHMpO1xuZnVuY3Rpb24gY3JlYXRlQm9sZFRva2VuKGZhY3RvcnksIGtpbmQsIGRlZiwgdGV4dCkge1xuICAgIHZhciB0b2tlbiA9IE5vZGVGYWN0b3J5X2pzXzEuTm9kZUZhY3RvcnkuY3JlYXRlVG9rZW4oZmFjdG9yeSwga2luZCwgZGVmLCB0ZXh0KTtcbiAgICBpZiAoa2luZCAhPT0gJ210ZXh0JyAmJlxuICAgICAgICBmYWN0b3J5LmNvbmZpZ3VyYXRpb24ucGFyc2VyLnN0YWNrLmVudlsnYm9sZHN5bWJvbCddKSB7XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRQcm9wZXJ0eSh0b2tlbiwgJ2ZpeEJvbGQnLCB0cnVlKTtcbiAgICAgICAgZmFjdG9yeS5jb25maWd1cmF0aW9uLmFkZE5vZGUoJ2ZpeEJvbGQnLCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbn1cbmV4cG9ydHMuY3JlYXRlQm9sZFRva2VuID0gY3JlYXRlQm9sZFRva2VuO1xuZnVuY3Rpb24gcmV3cml0ZUJvbGRUb2tlbnMoYXJnKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhhcmcuZGF0YS5nZXRMaXN0KCdmaXhCb2xkJykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRQcm9wZXJ0eShub2RlLCAnZml4Qm9sZCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhbnQgPSBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0QXR0cmlidXRlKG5vZGUsICdtYXRodmFyaWFudCcpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShub2RlLCAnbWF0aHZhcmlhbnQnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkJPTEQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShub2RlLCAnbWF0aHZhcmlhbnQnLCBCT0xEVkFSSUFOVFt2YXJpYW50XSB8fCB2YXJpYW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnJlbW92ZVByb3BlcnRpZXMobm9kZSwgJ2ZpeEJvbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG59XG5leHBvcnRzLnJld3JpdGVCb2xkVG9rZW5zID0gcmV3cml0ZUJvbGRUb2tlbnM7XG5leHBvcnRzLkJvbGRzeW1ib2xDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdib2xkc3ltYm9sJywge1xuICAgIGhhbmRsZXI6IHsgbWFjcm86IFsnYm9sZHN5bWJvbCddIH0sXG4gICAgbm9kZXM6IHsgJ3Rva2VuJzogY3JlYXRlQm9sZFRva2VuIH0sXG4gICAgcG9zdHByb2Nlc3NvcnM6IFtyZXdyaXRlQm9sZFRva2Vuc11cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9sZHN5bWJvbENvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyYWtldENvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgQnJha2V0SXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuL0JyYWtldEl0ZW1zLmpzXCIpO1xucmVxdWlyZShcIi4vQnJha2V0TWFwcGluZ3MuanNcIik7XG5leHBvcnRzLkJyYWtldENvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ2JyYWtldCcsIHtcbiAgICBoYW5kbGVyOiB7XG4gICAgICAgIGNoYXJhY3RlcjogWydCcmFrZXQtY2hhcmFjdGVycyddLFxuICAgICAgICBtYWNybzogWydCcmFrZXQtbWFjcm9zJ11cbiAgICB9LFxuICAgIGl0ZW1zOiAoX2EgPSB7fSxcbiAgICAgICAgX2FbQnJha2V0SXRlbXNfanNfMS5CcmFrZXRJdGVtLnByb3RvdHlwZS5raW5kXSA9IEJyYWtldEl0ZW1zX2pzXzEuQnJha2V0SXRlbSxcbiAgICAgICAgX2EpXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyYWtldENvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CcmFrZXRJdGVtID0gdm9pZCAwO1xudmFyIFN0YWNrSXRlbV9qc18xID0gcmVxdWlyZShcIi4uL1N0YWNrSXRlbS5qc1wiKTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgQnJha2V0SXRlbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyYWtldEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJha2V0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJha2V0SXRlbS5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdicmFrZXQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyYWtldEl0ZW0ucHJvdG90eXBlLCBcImlzT3BlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCcmFrZXRJdGVtLnByb3RvdHlwZS5jaGVja0l0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5pc0tpbmQoJ2Nsb3NlJykpIHtcbiAgICAgICAgICAgIHJldHVybiBbW3RoaXMuZmFjdG9yeS5jcmVhdGUoJ21tbCcsIHRoaXMudG9NbWwoKSldLCB0cnVlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5pc0tpbmQoJ21tbCcpKSB7XG4gICAgICAgICAgICB0aGlzLlB1c2goaXRlbS50b01tbCgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFByb3BlcnR5KCdzaW5nbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW3RoaXMudG9NbWwoKV0sIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0YWNrSXRlbV9qc18xLkJhc2VJdGVtLmZhaWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY2hlY2tJdGVtLmNhbGwodGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICBCcmFrZXRJdGVtLnByb3RvdHlwZS50b01tbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyID0gX3N1cGVyLnByb3RvdHlwZS50b01tbC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgb3BlbiA9IHRoaXMuZ2V0UHJvcGVydHkoJ29wZW4nKTtcbiAgICAgICAgdmFyIGNsb3NlID0gdGhpcy5nZXRQcm9wZXJ0eSgnY2xvc2UnKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UHJvcGVydHkoJ3N0cmV0Y2h5JykpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmZlbmNlZCh0aGlzLmZhY3RvcnkuY29uZmlndXJhdGlvbiwgb3BlbiwgaW5uZXIsIGNsb3NlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0cnMgPSB7IGZlbmNlOiB0cnVlLCBzdHJldGNoeTogZmFsc2UsIHN5bW1ldHJpYzogdHJ1ZSwgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5PUEVOIH07XG4gICAgICAgIHZhciBvcGVuTm9kZSA9IHRoaXMuY3JlYXRlKCd0b2tlbicsICdtbycsIGF0dHJzLCBvcGVuKTtcbiAgICAgICAgYXR0cnMudGV4Q2xhc3MgPSBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuQ0xPU0U7XG4gICAgICAgIHZhciBjbG9zZU5vZGUgPSB0aGlzLmNyZWF0ZSgndG9rZW4nLCAnbW8nLCBhdHRycywgY2xvc2UpO1xuICAgICAgICB2YXIgbXJvdyA9IHRoaXMuY3JlYXRlKCdub2RlJywgJ21yb3cnLCBbb3Blbk5vZGUsIGlubmVyLCBjbG9zZU5vZGVdLCB7IG9wZW46IG9wZW4sIGNsb3NlOiBjbG9zZSwgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5JTk5FUiB9KTtcbiAgICAgICAgcmV0dXJuIG1yb3c7XG4gICAgfTtcbiAgICByZXR1cm4gQnJha2V0SXRlbTtcbn0oU3RhY2tJdGVtX2pzXzEuQmFzZUl0ZW0pKTtcbmV4cG9ydHMuQnJha2V0SXRlbSA9IEJyYWtldEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CcmFrZXRJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgQnJha2V0TWV0aG9kc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0JyYWtldE1ldGhvZHMuanNcIikpO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ0JyYWtldC1tYWNyb3MnLCB7XG4gICAgYnJhOiBbJ01hY3JvJywgJ3tcXFxcbGFuZ2xlIHsjMX0gXFxcXHZlcnR9JywgMV0sXG4gICAga2V0OiBbJ01hY3JvJywgJ3tcXFxcdmVydCB7IzF9IFxcXFxyYW5nbGV9JywgMV0sXG4gICAgYnJha2V0OiBbJ0JyYWtldCcsICdcXHUyN0U4JywgJ1xcdTI3RTknLCBmYWxzZSwgSW5maW5pdHldLFxuICAgICdzZXQnOiBbJ0JyYWtldCcsICd7JywgJ30nLCBmYWxzZSwgMV0sXG4gICAgQnJhOiBbJ01hY3JvJywgJ3tcXFxcbGVmdFxcXFxsYW5nbGUgeyMxfSBcXFxccmlnaHRcXFxcdmVydH0nLCAxXSxcbiAgICBLZXQ6IFsnTWFjcm8nLCAne1xcXFxsZWZ0XFxcXHZlcnQgeyMxfSBcXFxccmlnaHRcXFxccmFuZ2xlfScsIDFdLFxuICAgIEJyYWtldDogWydCcmFrZXQnLCAnXFx1MjdFOCcsICdcXHUyN0U5JywgdHJ1ZSwgSW5maW5pdHldLFxuICAgIFNldDogWydCcmFrZXQnLCAneycsICd9JywgdHJ1ZSwgMV0sXG4gICAga2V0YnJhOiBbJ01hY3JvJywgJ3tcXFxcdmVydCB7IzF9IFxcXFxyYW5nbGVcXFxcbGFuZ2xlIHsjMn0gXFxcXHZlcnR9JywgMl0sXG4gICAgS2V0YnJhOiBbJ01hY3JvJywgJ3tcXFxcbGVmdFxcXFx2ZXJ0IHsjMX0gXFxcXHJpZ2h0XFxcXHJhbmdsZVxcXFxsZWZ0XFxcXGxhbmdsZSB7IzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fScsIDJdLFxuICAgICd8JzogJ0Jhcidcbn0sIEJyYWtldE1ldGhvZHNfanNfMS5kZWZhdWx0KTtcbm5ldyBTeW1ib2xNYXBfanNfMS5NYWNyb01hcCgnQnJha2V0LWNoYXJhY3RlcnMnLCB7XG4gICAgJ3wnOiAnQmFyJ1xufSwgQnJha2V0TWV0aG9kc19qc18xLmRlZmF1bHQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJha2V0TWFwcGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmFzZU1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYmFzZS9CYXNlTWV0aG9kcy5qc1wiKSk7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBCcmFrZXRNZXRob2RzID0ge307XG5CcmFrZXRNZXRob2RzLk1hY3JvID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lk1hY3JvO1xuQnJha2V0TWV0aG9kcy5CcmFrZXQgPSBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSwgb3BlbiwgY2xvc2UsIHN0cmV0Y2h5LCBiYXJtYXgpIHtcbiAgICB2YXIgbmV4dCA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgaWYgKG5leHQgPT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdBcmdGb3InLCAnTWlzc2luZyBhcmd1bWVudCBmb3IgJTEnLCBwYXJzZXIuY3VycmVudENTKTtcbiAgICB9XG4gICAgdmFyIHNpbmdsZSA9IHRydWU7XG4gICAgaWYgKG5leHQgPT09ICd7Jykge1xuICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICBzaW5nbGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcGFyc2VyLlB1c2gocGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnYnJha2V0JylcbiAgICAgICAgLnNldFByb3BlcnRpZXMoeyBiYXJtYXg6IGJhcm1heCwgYmFyY291bnQ6IDAsIG9wZW46IG9wZW4sXG4gICAgICAgIGNsb3NlOiBjbG9zZSwgc3RyZXRjaHk6IHN0cmV0Y2h5LCBzaW5nbGU6IHNpbmdsZSB9KSk7XG59O1xuQnJha2V0TWV0aG9kcy5CYXIgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGMgPSBuYW1lID09PSAnfCcgPyAnfCcgOiAnXFx1MjIyNSc7XG4gICAgdmFyIHRvcCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICBpZiAodG9wLmtpbmQgIT09ICdicmFrZXQnIHx8XG4gICAgICAgIHRvcC5nZXRQcm9wZXJ0eSgnYmFyY291bnQnKSA+PSB0b3AuZ2V0UHJvcGVydHkoJ2Jhcm1heCcpKSB7XG4gICAgICAgIHZhciBtbWwgPSBwYXJzZXIuY3JlYXRlKCd0b2tlbicsICdtbycsIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5PUkQsIHN0cmV0Y2h5OiBmYWxzZSB9LCBjKTtcbiAgICAgICAgcGFyc2VyLlB1c2gobW1sKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYyA9PT0gJ3wnICYmIHBhcnNlci5HZXROZXh0KCkgPT09ICd8Jykge1xuICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICBjID0gJ1xcdTIyMjUnO1xuICAgIH1cbiAgICB2YXIgc3RyZXRjaHkgPSB0b3AuZ2V0UHJvcGVydHkoJ3N0cmV0Y2h5Jyk7XG4gICAgaWYgKCFzdHJldGNoeSkge1xuICAgICAgICB2YXIgbm9kZV8xID0gcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbW8nLCB7IHN0cmV0Y2h5OiBmYWxzZSwgYnJha2V0YmFyOiB0cnVlIH0sIGMpO1xuICAgICAgICBwYXJzZXIuUHVzaChub2RlXzEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgW10sIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5DTE9TRSB9KTtcbiAgICBwYXJzZXIuUHVzaChub2RlKTtcbiAgICB0b3Auc2V0UHJvcGVydHkoJ2JhcmNvdW50JywgdG9wLmdldFByb3BlcnR5KCdiYXJjb3VudCcpICsgMSk7XG4gICAgbm9kZSA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywgeyBzdHJldGNoeTogdHJ1ZSwgYnJha2V0YmFyOiB0cnVlIH0sIGMpO1xuICAgIHBhcnNlci5QdXNoKG5vZGUpO1xuICAgIG5vZGUgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ1RlWEF0b20nLCBbXSwgeyB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLk9QRU4gfSk7XG4gICAgcGFyc2VyLlB1c2gobm9kZSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gQnJha2V0TWV0aG9kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyYWtldE1ldGhvZHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1c3Nwcm9vZnNDb25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIEJ1c3Nwcm9vZnNJdGVtc19qc18xID0gcmVxdWlyZShcIi4vQnVzc3Byb29mc0l0ZW1zLmpzXCIpO1xudmFyIEJ1c3Nwcm9vZnNVdGlsX2pzXzEgPSByZXF1aXJlKFwiLi9CdXNzcHJvb2ZzVXRpbC5qc1wiKTtcbnJlcXVpcmUoXCIuL0J1c3Nwcm9vZnNNYXBwaW5ncy5qc1wiKTtcbmV4cG9ydHMuQnVzc3Byb29mc0NvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ2J1c3Nwcm9vZnMnLCB7XG4gICAgaGFuZGxlcjoge1xuICAgICAgICBtYWNybzogWydCdXNzcHJvb2ZzLW1hY3JvcyddLFxuICAgICAgICBlbnZpcm9ubWVudDogWydCdXNzcHJvb2ZzLWVudmlyb25tZW50cyddXG4gICAgfSxcbiAgICBpdGVtczogKF9hID0ge30sXG4gICAgICAgIF9hW0J1c3Nwcm9vZnNJdGVtc19qc18xLlByb29mVHJlZUl0ZW0ucHJvdG90eXBlLmtpbmRdID0gQnVzc3Byb29mc0l0ZW1zX2pzXzEuUHJvb2ZUcmVlSXRlbSxcbiAgICAgICAgX2EpLFxuICAgIHByZXByb2Nlc3NvcnM6IFtcbiAgICAgICAgW0J1c3Nwcm9vZnNVdGlsX2pzXzEuc2F2ZURvY3VtZW50LCAxXVxuICAgIF0sXG4gICAgcG9zdHByb2Nlc3NvcnM6IFtcbiAgICAgICAgW0J1c3Nwcm9vZnNVdGlsX2pzXzEuY2xlYXJEb2N1bWVudCwgM10sXG4gICAgICAgIFtCdXNzcHJvb2ZzVXRpbF9qc18xLm1ha2VCc3ByQXR0cmlidXRlcywgMl0sXG4gICAgICAgIFtCdXNzcHJvb2ZzVXRpbF9qc18xLmJhbGFuY2VSdWxlcywgMV1cbiAgICBdXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1c3Nwcm9vZnNDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9vZlRyZWVJdGVtID0gdm9pZCAwO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBTdGFja0l0ZW1fanNfMSA9IHJlcXVpcmUoXCIuLi9TdGFja0l0ZW0uanNcIik7XG52YXIgU3RhY2tfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vU3RhY2suanNcIikpO1xudmFyIEJ1c3Nwcm9vZnNVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL0J1c3Nwcm9vZnNVdGlsLmpzXCIpKTtcbnZhciBQcm9vZlRyZWVJdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvb2ZUcmVlSXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9vZlRyZWVJdGVtKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVmdExhYmVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmlndGhMYWJlbCA9IG51bGw7XG4gICAgICAgIF90aGlzLmlubmVyU3RhY2sgPSBuZXcgU3RhY2tfanNfMS5kZWZhdWx0KF90aGlzLmZhY3RvcnksIHt9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvb2ZUcmVlSXRlbS5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdwcm9vZlRyZWUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUHJvb2ZUcmVlSXRlbS5wcm90b3R5cGUuY2hlY2tJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNLaW5kKCdlbmQnKSAmJiBpdGVtLmdldE5hbWUoKSA9PT0gJ3Byb29mdHJlZScpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy50b01tbCgpO1xuICAgICAgICAgICAgQnVzc3Byb29mc1V0aWwuc2V0UHJvcGVydHkobm9kZSwgJ3Byb29mJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW1t0aGlzLmZhY3RvcnkuY3JlYXRlKCdtbWwnLCBub2RlKSwgaXRlbV0sIHRydWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmlzS2luZCgnc3RvcCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdFbnZNaXNzaW5nRW5kJywgJ01pc3NpbmcgXFxcXGVuZHslMX0nLCB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbm5lclN0YWNrLlB1c2goaXRlbSk7XG4gICAgICAgIHJldHVybiBTdGFja0l0ZW1fanNfMS5CYXNlSXRlbS5mYWlsO1xuICAgIH07XG4gICAgUHJvb2ZUcmVlSXRlbS5wcm90b3R5cGUudG9NbWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmVlID0gX3N1cGVyLnByb3RvdHlwZS50b01tbC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlubmVyU3RhY2suVG9wKCk7XG4gICAgICAgIGlmIChzdGFydC5pc0tpbmQoJ3N0YXJ0JykgJiYgIXN0YXJ0LlNpemUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbm5lclN0YWNrLlB1c2godGhpcy5mYWN0b3J5LmNyZWF0ZSgnc3RvcCcpKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaW5uZXJTdGFjay5Ub3AoKS50b01tbCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoJ25vZGUnLCAnbXJvdycsIFtwcmVmaXgsIHRyZWVdLCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvb2ZUcmVlSXRlbTtcbn0oU3RhY2tJdGVtX2pzXzEuQmFzZUl0ZW0pKTtcbmV4cG9ydHMuUHJvb2ZUcmVlSXRlbSA9IFByb29mVHJlZUl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXNzcHJvb2ZzSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnVzc3Byb29mc01ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CdXNzcHJvb2ZzTWV0aG9kcy5qc1wiKSk7XG52YXIgUGFyc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlTWV0aG9kcy5qc1wiKSk7XG52YXIgU3ltYm9sTWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ0J1c3Nwcm9vZnMtbWFjcm9zJywge1xuICAgIEF4aW9tQzogJ0F4aW9tJyxcbiAgICBVbmFyeUluZkM6IFsnSW5mZXJlbmNlJywgMV0sXG4gICAgQmluYXJ5SW5mQzogWydJbmZlcmVuY2UnLCAyXSxcbiAgICBUcmluYXJ5SW5mQzogWydJbmZlcmVuY2UnLCAzXSxcbiAgICBRdWF0ZXJuYXJ5SW5mQzogWydJbmZlcmVuY2UnLCA0XSxcbiAgICBRdWluYXJ5SW5mQzogWydJbmZlcmVuY2UnLCA1XSxcbiAgICBSaWdodExhYmVsOiBbJ0xhYmVsJywgJ3JpZ2h0J10sXG4gICAgTGVmdExhYmVsOiBbJ0xhYmVsJywgJ2xlZnQnXSxcbiAgICBBWEM6ICdBeGlvbScsXG4gICAgVUlDOiBbJ0luZmVyZW5jZScsIDFdLFxuICAgIEJJQzogWydJbmZlcmVuY2UnLCAyXSxcbiAgICBUSUM6IFsnSW5mZXJlbmNlJywgM10sXG4gICAgUkw6IFsnTGFiZWwnLCAncmlnaHQnXSxcbiAgICBMTDogWydMYWJlbCcsICdsZWZ0J10sXG4gICAgbm9MaW5lOiBbJ1NldExpbmUnLCAnbm9uZScsIGZhbHNlXSxcbiAgICBzaW5nbGVMaW5lOiBbJ1NldExpbmUnLCAnc29saWQnLCBmYWxzZV0sXG4gICAgc29saWRMaW5lOiBbJ1NldExpbmUnLCAnc29saWQnLCBmYWxzZV0sXG4gICAgZGFzaGVkTGluZTogWydTZXRMaW5lJywgJ2Rhc2hlZCcsIGZhbHNlXSxcbiAgICBhbHdheXNOb0xpbmU6IFsnU2V0TGluZScsICdub25lJywgdHJ1ZV0sXG4gICAgYWx3YXlzU2luZ2xlTGluZTogWydTZXRMaW5lJywgJ3NvbGlkJywgdHJ1ZV0sXG4gICAgYWx3YXlzU29saWRMaW5lOiBbJ1NldExpbmUnLCAnc29saWQnLCB0cnVlXSxcbiAgICBhbHdheXNEYXNoZWRMaW5lOiBbJ1NldExpbmUnLCAnZGFzaGVkJywgdHJ1ZV0sXG4gICAgcm9vdEF0VG9wOiBbJ1Jvb3RBdFRvcCcsIHRydWVdLFxuICAgIGFsd2F5c1Jvb3RBdFRvcDogWydSb290QXRUb3AnLCB0cnVlXSxcbiAgICByb290QXRCb3R0b206IFsnUm9vdEF0VG9wJywgZmFsc2VdLFxuICAgIGFsd2F5c1Jvb3RBdEJvdHRvbTogWydSb290QXRUb3AnLCBmYWxzZV0sXG4gICAgZkNlbnRlcjogJ0ZDZW50ZXInLFxuICAgIEF4aW9tOiAnQXhpb21GJyxcbiAgICBVbmFyeUluZjogWydJbmZlcmVuY2VGJywgMV0sXG4gICAgQmluYXJ5SW5mOiBbJ0luZmVyZW5jZUYnLCAyXSxcbiAgICBUcmluYXJ5SW5mOiBbJ0luZmVyZW5jZUYnLCAzXSxcbiAgICBRdWF0ZXJuYXJ5SW5mOiBbJ0luZmVyZW5jZUYnLCA0XSxcbiAgICBRdWluYXJ5SW5mOiBbJ0luZmVyZW5jZUYnLCA1XVxufSwgQnVzc3Byb29mc01ldGhvZHNfanNfMS5kZWZhdWx0KTtcbm5ldyBTeW1ib2xNYXBfanNfMS5FbnZpcm9ubWVudE1hcCgnQnVzc3Byb29mcy1lbnZpcm9ubWVudHMnLCBQYXJzZU1ldGhvZHNfanNfMS5kZWZhdWx0LmVudmlyb25tZW50LCB7XG4gICAgcHJvb2Z0cmVlOiBbJ1Byb29mdHJlZScsIG51bGwsIGZhbHNlXVxufSwgQnVzc3Byb29mc01ldGhvZHNfanNfMS5kZWZhdWx0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1c3Nwcm9vZnNNYXBwaW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBUZXhQYXJzZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4UGFyc2VyLmpzXCIpKTtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBCdXNzcHJvb2ZzVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9CdXNzcHJvb2ZzVXRpbC5qc1wiKSk7XG52YXIgQnVzc3Byb29mc01ldGhvZHMgPSB7fTtcbkJ1c3Nwcm9vZnNNZXRob2RzLlByb29mdHJlZSA9IGZ1bmN0aW9uIChwYXJzZXIsIGJlZ2luKSB7XG4gICAgcGFyc2VyLlB1c2goYmVnaW4pO1xuICAgIHZhciBuZXdJdGVtID0gcGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgncHJvb2ZUcmVlJykuXG4gICAgICAgIHNldFByb3BlcnRpZXMoeyBuYW1lOiBiZWdpbi5nZXROYW1lKCksXG4gICAgICAgIGxpbmU6ICdzb2xpZCcsIGN1cnJlbnRMaW5lOiAnc29saWQnLCByb290QXRUb3A6IGZhbHNlIH0pO1xuICAgIHJldHVybiBuZXdJdGVtO1xufTtcbkJ1c3Nwcm9vZnNNZXRob2RzLkF4aW9tID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciB0b3AgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgaWYgKHRvcC5raW5kICE9PSAncHJvb2ZUcmVlJykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdJbGxlZ2FsUHJvb2ZDb21tYW5kJywgJ1Byb29mIGNvbW1hbmRzIG9ubHkgYWxsb3dlZCBpbiBwcm9vZnRyZWUgZW52aXJvbm1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBjb250ZW50ID0gcGFkZGVkQ29udGVudChwYXJzZXIsIHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgQnVzc3Byb29mc1V0aWwuc2V0UHJvcGVydHkoY29udGVudCwgJ2F4aW9tJywgdHJ1ZSk7XG4gICAgdG9wLlB1c2goY29udGVudCk7XG59O1xudmFyIHBhZGRlZENvbnRlbnQgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250ZW50KSB7XG4gICAgdmFyIG5vZGVzID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5pbnRlcm5hbE1hdGgocGFyc2VyLCBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnRyaW1TcGFjZXMoY29udGVudCksIDApO1xuICAgIGlmICghbm9kZXNbMF0uY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcm93JywgW10pO1xuICAgIH1cbiAgICB2YXIgbHBhZCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXNwYWNlJywgW10sIHsgd2lkdGg6ICcuNWV4JyB9KTtcbiAgICB2YXIgcnBhZCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXNwYWNlJywgW10sIHsgd2lkdGg6ICcuNWV4JyB9KTtcbiAgICByZXR1cm4gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcm93JywgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtscGFkXSwgX19yZWFkKG5vZGVzKSwgZmFsc2UpLCBbcnBhZF0sIGZhbHNlKSk7XG59O1xuQnVzc3Byb29mc01ldGhvZHMuSW5mZXJlbmNlID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgbikge1xuICAgIHZhciB0b3AgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgaWYgKHRvcC5raW5kICE9PSAncHJvb2ZUcmVlJykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdJbGxlZ2FsUHJvb2ZDb21tYW5kJywgJ1Byb29mIGNvbW1hbmRzIG9ubHkgYWxsb3dlZCBpbiBwcm9vZnRyZWUgZW52aXJvbm1lbnQuJyk7XG4gICAgfVxuICAgIGlmICh0b3AuU2l6ZSgpIDwgbikge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdCYWRQcm9vZlRyZWUnLCAnUHJvb2YgdHJlZSBiYWRseSBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHZhciByb290QXRUb3AgPSB0b3AuZ2V0UHJvcGVydHkoJ3Jvb3RBdFRvcCcpO1xuICAgIHZhciBjaGlsZENvdW50ID0gKG4gPT09IDEgJiYgIXRvcC5QZWVrKClbMF0uY2hpbGROb2Rlcy5sZW5ndGgpID8gMCA6IG47XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZG8ge1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi51bnNoaWZ0KHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRkJywgW10sIHt9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4udW5zaGlmdChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ210ZCcsIFt0b3AuUG9wKCldLCB7ICdyb3dhbGlnbic6IChyb290QXRUb3AgPyAndG9wJyA6ICdib3R0b20nKSB9KSk7XG4gICAgICAgIG4tLTtcbiAgICB9IHdoaWxlIChuID4gMCk7XG4gICAgdmFyIHJvdyA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRyJywgY2hpbGRyZW4sIHt9KTtcbiAgICB2YXIgdGFibGUgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ210YWJsZScsIFtyb3ddLCB7IGZyYW1lc3BhY2luZzogJzAgMCcgfSk7XG4gICAgdmFyIGNvbmNsdXNpb24gPSBwYWRkZWRDb250ZW50KHBhcnNlciwgcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKTtcbiAgICB2YXIgc3R5bGUgPSB0b3AuZ2V0UHJvcGVydHkoJ2N1cnJlbnRMaW5lJyk7XG4gICAgaWYgKHN0eWxlICE9PSB0b3AuZ2V0UHJvcGVydHkoJ2xpbmUnKSkge1xuICAgICAgICB0b3Auc2V0UHJvcGVydHkoJ2N1cnJlbnRMaW5lJywgdG9wLmdldFByb3BlcnR5KCdsaW5lJykpO1xuICAgIH1cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUocGFyc2VyLCB0YWJsZSwgW2NvbmNsdXNpb25dLCB0b3AuZ2V0UHJvcGVydHkoJ2xlZnQnKSwgdG9wLmdldFByb3BlcnR5KCdyaWdodCcpLCBzdHlsZSwgcm9vdEF0VG9wKTtcbiAgICB0b3Auc2V0UHJvcGVydHkoJ2xlZnQnLCBudWxsKTtcbiAgICB0b3Auc2V0UHJvcGVydHkoJ3JpZ2h0JywgbnVsbCk7XG4gICAgQnVzc3Byb29mc1V0aWwuc2V0UHJvcGVydHkocnVsZSwgJ2luZmVyZW5jZScsIGNoaWxkQ291bnQpO1xuICAgIHBhcnNlci5jb25maWd1cmF0aW9uLmFkZE5vZGUoJ2luZmVyZW5jZScsIHJ1bGUpO1xuICAgIHRvcC5QdXNoKHJ1bGUpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUocGFyc2VyLCBwcmVtaXNlLCBjb25jbHVzaW9ucywgbGVmdCwgcmlnaHQsIHN0eWxlLCByb290QXRUb3ApIHtcbiAgICB2YXIgdXBwZXIgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ210cicsIFtwYXJzZXIuY3JlYXRlKCdub2RlJywgJ210ZCcsIFtwcmVtaXNlXSwge30pXSwge30pO1xuICAgIHZhciBsb3dlciA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRyJywgW3BhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRkJywgY29uY2x1c2lvbnMsIHt9KV0sIHt9KTtcbiAgICB2YXIgcnVsZSA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRhYmxlJywgcm9vdEF0VG9wID8gW2xvd2VyLCB1cHBlcl0gOiBbdXBwZXIsIGxvd2VyXSwgeyBhbGlnbjogJ3RvcCAyJywgcm93bGluZXM6IHN0eWxlLCBmcmFtZXNwYWNpbmc6ICcwIDAnIH0pO1xuICAgIEJ1c3Nwcm9vZnNVdGlsLnNldFByb3BlcnR5KHJ1bGUsICdpbmZlcmVuY2VSdWxlJywgcm9vdEF0VG9wID8gJ3VwJyA6ICdkb3duJyk7XG4gICAgdmFyIGxlZnRMYWJlbCwgcmlnaHRMYWJlbDtcbiAgICBpZiAobGVmdCkge1xuICAgICAgICBsZWZ0TGFiZWwgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBbbGVmdF0sIHsgaGVpZ2h0OiAnKy41ZW0nLCB3aWR0aDogJysuNWVtJywgdm9mZnNldDogJy0uMTVlbScgfSk7XG4gICAgICAgIEJ1c3Nwcm9vZnNVdGlsLnNldFByb3BlcnR5KGxlZnRMYWJlbCwgJ3Byb29mbGFiZWwnLCAnbGVmdCcpO1xuICAgIH1cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgcmlnaHRMYWJlbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtyaWdodF0sIHsgaGVpZ2h0OiAnKy41ZW0nLCB3aWR0aDogJysuNWVtJywgdm9mZnNldDogJy0uMTVlbScgfSk7XG4gICAgICAgIEJ1c3Nwcm9vZnNVdGlsLnNldFByb3BlcnR5KHJpZ2h0TGFiZWwsICdwcm9vZmxhYmVsJywgJ3JpZ2h0Jyk7XG4gICAgfVxuICAgIHZhciBjaGlsZHJlbiwgbGFiZWw7XG4gICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBbbGVmdExhYmVsLCBydWxlLCByaWdodExhYmVsXTtcbiAgICAgICAgbGFiZWwgPSAnYm90aCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBbbGVmdExhYmVsLCBydWxlXTtcbiAgICAgICAgbGFiZWwgPSAnbGVmdCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGNoaWxkcmVuID0gW3J1bGUsIHJpZ2h0TGFiZWxdO1xuICAgICAgICBsYWJlbCA9ICdyaWdodCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgcnVsZSA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXJvdycsIGNoaWxkcmVuKTtcbiAgICBCdXNzcHJvb2ZzVXRpbC5zZXRQcm9wZXJ0eShydWxlLCAnbGFiZWxsZWRSdWxlJywgbGFiZWwpO1xuICAgIHJldHVybiBydWxlO1xufVxuQnVzc3Byb29mc01ldGhvZHMuTGFiZWwgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBzaWRlKSB7XG4gICAgdmFyIHRvcCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICBpZiAodG9wLmtpbmQgIT09ICdwcm9vZlRyZWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxQcm9vZkNvbW1hbmQnLCAnUHJvb2YgY29tbWFuZHMgb25seSBhbGxvd2VkIGluIHByb29mdHJlZSBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgdmFyIGNvbnRlbnQgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmludGVybmFsTWF0aChwYXJzZXIsIHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSwgMCk7XG4gICAgdmFyIGxhYmVsID0gKGNvbnRlbnQubGVuZ3RoID4gMSkgP1xuICAgICAgICBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21yb3cnLCBjb250ZW50LCB7fSkgOiBjb250ZW50WzBdO1xuICAgIHRvcC5zZXRQcm9wZXJ0eShzaWRlLCBsYWJlbCk7XG59O1xuQnVzc3Byb29mc01ldGhvZHMuU2V0TGluZSA9IGZ1bmN0aW9uIChwYXJzZXIsIF9uYW1lLCBzdHlsZSwgYWx3YXlzKSB7XG4gICAgdmFyIHRvcCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICBpZiAodG9wLmtpbmQgIT09ICdwcm9vZlRyZWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxQcm9vZkNvbW1hbmQnLCAnUHJvb2YgY29tbWFuZHMgb25seSBhbGxvd2VkIGluIHByb29mdHJlZSBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgdG9wLnNldFByb3BlcnR5KCdjdXJyZW50TGluZScsIHN0eWxlKTtcbiAgICBpZiAoYWx3YXlzKSB7XG4gICAgICAgIHRvcC5zZXRQcm9wZXJ0eSgnbGluZScsIHN0eWxlKTtcbiAgICB9XG59O1xuQnVzc3Byb29mc01ldGhvZHMuUm9vdEF0VG9wID0gZnVuY3Rpb24gKHBhcnNlciwgX25hbWUsIHdoZXJlKSB7XG4gICAgdmFyIHRvcCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICBpZiAodG9wLmtpbmQgIT09ICdwcm9vZlRyZWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxQcm9vZkNvbW1hbmQnLCAnUHJvb2YgY29tbWFuZHMgb25seSBhbGxvd2VkIGluIHByb29mdHJlZSBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgdG9wLnNldFByb3BlcnR5KCdyb290QXRUb3AnLCB3aGVyZSk7XG59O1xuQnVzc3Byb29mc01ldGhvZHMuQXhpb21GID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciB0b3AgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgaWYgKHRvcC5raW5kICE9PSAncHJvb2ZUcmVlJykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdJbGxlZ2FsUHJvb2ZDb21tYW5kJywgJ1Byb29mIGNvbW1hbmRzIG9ubHkgYWxsb3dlZCBpbiBwcm9vZnRyZWUgZW52aXJvbm1lbnQuJyk7XG4gICAgfVxuICAgIHZhciBsaW5lID0gcGFyc2VGQ2VudGVyTGluZShwYXJzZXIsIG5hbWUpO1xuICAgIEJ1c3Nwcm9vZnNVdGlsLnNldFByb3BlcnR5KGxpbmUsICdheGlvbScsIHRydWUpO1xuICAgIHRvcC5QdXNoKGxpbmUpO1xufTtcbmZ1bmN0aW9uIHBhcnNlRkNlbnRlckxpbmUocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGRvbGxhciA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgaWYgKGRvbGxhciAhPT0gJyQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxVc2VPZkNvbW1hbmQnLCAnVXNlIG9mICUxIGRvZXMgbm90IG1hdGNoIGl0XFwncyBkZWZpbml0aW9uLicsIG5hbWUpO1xuICAgIH1cbiAgICBwYXJzZXIuaSsrO1xuICAgIHZhciBheGlvbSA9IHBhcnNlci5HZXRVcFRvKG5hbWUsICckJyk7XG4gICAgaWYgKGF4aW9tLmluZGV4T2YoJ1xcXFxmQ2VudGVyJykgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxVc2VPZkNvbW1hbmQnLCAnTWlzc2luZyBcXFxcZkNlbnRlciBpbiAlMS4nLCBuYW1lKTtcbiAgICB9XG4gICAgdmFyIF9hID0gX19yZWFkKGF4aW9tLnNwbGl0KCdcXFxcZkNlbnRlcicpLCAyKSwgcHJlbSA9IF9hWzBdLCBjb25jID0gX2FbMV07XG4gICAgdmFyIHByZW1pc2UgPSAobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQocHJlbSwgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pKS5tbWwoKTtcbiAgICB2YXIgY29uY2x1c2lvbiA9IChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChjb25jLCBwYXJzZXIuc3RhY2suZW52LCBwYXJzZXIuY29uZmlndXJhdGlvbikpLm1tbCgpO1xuICAgIHZhciBmY2VudGVyID0gKG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KCdcXFxcZkNlbnRlcicsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKSkubW1sKCk7XG4gICAgdmFyIGxlZnQgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ210ZCcsIFtwcmVtaXNlXSwge30pO1xuICAgIHZhciBtaWRkbGUgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ210ZCcsIFtmY2VudGVyXSwge30pO1xuICAgIHZhciByaWdodCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRkJywgW2NvbmNsdXNpb25dLCB7fSk7XG4gICAgdmFyIHJvdyA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRyJywgW2xlZnQsIG1pZGRsZSwgcmlnaHRdLCB7fSk7XG4gICAgdmFyIHRhYmxlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdGFibGUnLCBbcm93XSwgeyBjb2x1bW5zcGFjaW5nOiAnLjVleCcsIGNvbHVtbmFsaWduOiAnY2VudGVyIDInIH0pO1xuICAgIEJ1c3Nwcm9vZnNVdGlsLnNldFByb3BlcnR5KHRhYmxlLCAnc2VxdWVudCcsIHRydWUpO1xuICAgIHBhcnNlci5jb25maWd1cmF0aW9uLmFkZE5vZGUoJ3NlcXVlbnQnLCByb3cpO1xuICAgIHJldHVybiB0YWJsZTtcbn1cbkJ1c3Nwcm9vZnNNZXRob2RzLkZDZW50ZXIgPSBmdW5jdGlvbiAoX3BhcnNlciwgX25hbWUpIHsgfTtcbkJ1c3Nwcm9vZnNNZXRob2RzLkluZmVyZW5jZUYgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBuKSB7XG4gICAgdmFyIHRvcCA9IHBhcnNlci5zdGFjay5Ub3AoKTtcbiAgICBpZiAodG9wLmtpbmQgIT09ICdwcm9vZlRyZWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxQcm9vZkNvbW1hbmQnLCAnUHJvb2YgY29tbWFuZHMgb25seSBhbGxvd2VkIGluIHByb29mdHJlZSBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgaWYgKHRvcC5TaXplKCkgPCBuKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0JhZFByb29mVHJlZScsICdQcm9vZiB0cmVlIGJhZGx5IHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgdmFyIHJvb3RBdFRvcCA9IHRvcC5nZXRQcm9wZXJ0eSgncm9vdEF0VG9wJyk7XG4gICAgdmFyIGNoaWxkQ291bnQgPSAobiA9PT0gMSAmJiAhdG9wLlBlZWsoKVswXS5jaGlsZE5vZGVzLmxlbmd0aCkgPyAwIDogbjtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdGQnLCBbXSwge30pKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi51bnNoaWZ0KHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRkJywgW3RvcC5Qb3AoKV0sIHsgJ3Jvd2FsaWduJzogKHJvb3RBdFRvcCA/ICd0b3AnIDogJ2JvdHRvbScpIH0pKTtcbiAgICAgICAgbi0tO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcbiAgICB2YXIgcm93ID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdHInLCBjaGlsZHJlbiwge30pO1xuICAgIHZhciB0YWJsZSA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRhYmxlJywgW3Jvd10sIHsgZnJhbWVzcGFjaW5nOiAnMCAwJyB9KTtcbiAgICB2YXIgY29uY2x1c2lvbiA9IHBhcnNlRkNlbnRlckxpbmUocGFyc2VyLCBuYW1lKTtcbiAgICB2YXIgc3R5bGUgPSB0b3AuZ2V0UHJvcGVydHkoJ2N1cnJlbnRMaW5lJyk7XG4gICAgaWYgKHN0eWxlICE9PSB0b3AuZ2V0UHJvcGVydHkoJ2xpbmUnKSkge1xuICAgICAgICB0b3Auc2V0UHJvcGVydHkoJ2N1cnJlbnRMaW5lJywgdG9wLmdldFByb3BlcnR5KCdsaW5lJykpO1xuICAgIH1cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUocGFyc2VyLCB0YWJsZSwgW2NvbmNsdXNpb25dLCB0b3AuZ2V0UHJvcGVydHkoJ2xlZnQnKSwgdG9wLmdldFByb3BlcnR5KCdyaWdodCcpLCBzdHlsZSwgcm9vdEF0VG9wKTtcbiAgICB0b3Auc2V0UHJvcGVydHkoJ2xlZnQnLCBudWxsKTtcbiAgICB0b3Auc2V0UHJvcGVydHkoJ3JpZ2h0JywgbnVsbCk7XG4gICAgQnVzc3Byb29mc1V0aWwuc2V0UHJvcGVydHkocnVsZSwgJ2luZmVyZW5jZScsIGNoaWxkQ291bnQpO1xuICAgIHBhcnNlci5jb25maWd1cmF0aW9uLmFkZE5vZGUoJ2luZmVyZW5jZScsIHJ1bGUpO1xuICAgIHRvcC5QdXNoKHJ1bGUpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c3Nwcm9vZnNNZXRob2RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVzc3Byb29mc01ldGhvZHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsZWFyRG9jdW1lbnQgPSBleHBvcnRzLnNhdmVEb2N1bWVudCA9IGV4cG9ydHMubWFrZUJzcHJBdHRyaWJ1dGVzID0gZXhwb3J0cy5yZW1vdmVQcm9wZXJ0eSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNldFByb3BlcnR5ID0gZXhwb3J0cy5iYWxhbmNlUnVsZXMgPSB2b2lkIDA7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vTm9kZVV0aWwuanNcIikpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIGRvYyA9IG51bGw7XG52YXIgaXRlbSA9IG51bGw7XG52YXIgZ2V0QkJveCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaXRlbS5yb290ID0gbm9kZTtcbiAgICB2YXIgd2lkdGggPSBkb2Mub3V0cHV0SmF4LmdldEJCb3goaXRlbSwgZG9jKS53O1xuICAgIHJldHVybiB3aWR0aDtcbn07XG52YXIgZ2V0UnVsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChub2RlICYmICFOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKG5vZGUsICdtdGFibGUnKSkge1xuICAgICAgICBpZiAoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzVHlwZShub2RlLCAndGV4dCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzVHlwZShub2RlLCAnbXJvdycpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG52YXIgZ2V0UHJlbWlzZXMgPSBmdW5jdGlvbiAocnVsZSwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJ1bGUuY2hpbGROb2Rlc1tkaXJlY3Rpb24gPT09ICd1cCcgPyAxIDogMF0uY2hpbGROb2Rlc1swXS5cbiAgICAgICAgY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF07XG59O1xudmFyIGdldFByZW1pc2UgPSBmdW5jdGlvbiAocHJlbWlzZXMsIG4pIHtcbiAgICByZXR1cm4gcHJlbWlzZXMuY2hpbGROb2Rlc1tuXS5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF07XG59O1xudmFyIGZpcnN0UHJlbWlzZSA9IGZ1bmN0aW9uIChwcmVtaXNlcykge1xuICAgIHJldHVybiBnZXRQcmVtaXNlKHByZW1pc2VzLCAwKTtcbn07XG52YXIgbGFzdFByZW1pc2UgPSBmdW5jdGlvbiAocHJlbWlzZXMpIHtcbiAgICByZXR1cm4gZ2V0UHJlbWlzZShwcmVtaXNlcywgcHJlbWlzZXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbn07XG52YXIgZ2V0Q29uY2x1c2lvbiA9IGZ1bmN0aW9uIChydWxlLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gcnVsZS5jaGlsZE5vZGVzW2RpcmVjdGlvbiA9PT0gJ3VwJyA/IDAgOiAxXS5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXTtcbn07XG52YXIgZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGluZikge1xuICAgIHdoaWxlIChpbmYgJiYgIU5vZGVVdGlsX2pzXzEuZGVmYXVsdC5pc1R5cGUoaW5mLCAnbXRkJykpIHtcbiAgICAgICAgaW5mID0gaW5mLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGluZjtcbn07XG52YXIgbmV4dFNpYmxpbmcgPSBmdW5jdGlvbiAoaW5mKSB7XG4gICAgcmV0dXJuIGluZi5wYXJlbnQuY2hpbGROb2Rlc1tpbmYucGFyZW50LmNoaWxkTm9kZXMuaW5kZXhPZihpbmYpICsgMV07XG59O1xudmFyIHByZXZpb3VzU2libGluZyA9IGZ1bmN0aW9uIChpbmYpIHtcbiAgICByZXR1cm4gaW5mLnBhcmVudC5jaGlsZE5vZGVzW2luZi5wYXJlbnQuY2hpbGROb2Rlcy5pbmRleE9mKGluZikgLSAxXTtcbn07XG52YXIgZ2V0UGFyZW50SW5mID0gZnVuY3Rpb24gKGluZikge1xuICAgIHdoaWxlIChpbmYgJiYgKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKGluZiwgJ2luZmVyZW5jZScpID09IG51bGwpIHtcbiAgICAgICAgaW5mID0gaW5mLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGluZjtcbn07XG52YXIgZ2V0U3BhY2VzID0gZnVuY3Rpb24gKGluZiwgcnVsZSwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgPT09IHZvaWQgMCkgeyByaWdodCA9IGZhbHNlOyB9XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgaWYgKGluZiA9PT0gcnVsZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoaW5mICE9PSBydWxlLnBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IGluZi5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgaW5kZXhfMSA9IHJpZ2h0ID8gY2hpbGRyZW5fMS5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgaWYgKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5pc1R5cGUoY2hpbGRyZW5fMVtpbmRleF8xXSwgJ21zcGFjZScpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZ2V0QkJveChjaGlsZHJlbl8xW2luZGV4XzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpbmYgPSBydWxlLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKGluZiA9PT0gcnVsZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgY2hpbGRyZW4gPSBpbmYuY2hpbGROb2RlcztcbiAgICB2YXIgaW5kZXggPSByaWdodCA/IGNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuICAgIGlmIChjaGlsZHJlbltpbmRleF0gIT09IHJ1bGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGdldEJCb3goY2hpbGRyZW5baW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgYWRqdXN0VmFsdWUgPSBmdW5jdGlvbiAoaW5mLCByaWdodCkge1xuICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gZmFsc2U7IH1cbiAgICB2YXIgcnVsZSA9IGdldFJ1bGUoaW5mKTtcbiAgICB2YXIgY29uYyA9IGdldENvbmNsdXNpb24ocnVsZSwgKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKHJ1bGUsICdpbmZlcmVuY2VSdWxlJykpO1xuICAgIHZhciB3ID0gZ2V0U3BhY2VzKGluZiwgcnVsZSwgcmlnaHQpO1xuICAgIHZhciB4ID0gZ2V0QkJveChydWxlKTtcbiAgICB2YXIgeSA9IGdldEJCb3goY29uYyk7XG4gICAgcmV0dXJuIHcgKyAoKHggLSB5KSAvIDIpO1xufTtcbnZhciBhZGRTcGFjZSA9IGZ1bmN0aW9uIChjb25maWcsIGluZiwgc3BhY2UsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSBmYWxzZTsgfVxuICAgIGlmICgoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkoaW5mLCAnaW5mZXJlbmNlUnVsZScpIHx8XG4gICAgICAgICgwLCBleHBvcnRzLmdldFByb3BlcnR5KShpbmYsICdsYWJlbGxlZFJ1bGUnKSkge1xuICAgICAgICB2YXIgbXJvdyA9IGNvbmZpZy5ub2RlRmFjdG9yeS5jcmVhdGUoJ25vZGUnLCAnbXJvdycpO1xuICAgICAgICBpbmYucGFyZW50LnJlcGxhY2VDaGlsZChtcm93LCBpbmYpO1xuICAgICAgICBtcm93LnNldENoaWxkcmVuKFtpbmZdKTtcbiAgICAgICAgbW92ZVByb3BlcnRpZXMoaW5mLCBtcm93KTtcbiAgICAgICAgaW5mID0gbXJvdztcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gcmlnaHQgPyBpbmYuY2hpbGROb2Rlcy5sZW5ndGggLSAxIDogMDtcbiAgICB2YXIgbXNwYWNlID0gaW5mLmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgIGlmIChOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKG1zcGFjZSwgJ21zcGFjZScpKSB7XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobXNwYWNlLCAnd2lkdGgnLCBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LkVtKFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuZGltZW4yZW0oTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldEF0dHJpYnV0ZShtc3BhY2UsICd3aWR0aCcpKSArIHNwYWNlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbXNwYWNlID0gY29uZmlnLm5vZGVGYWN0b3J5LmNyZWF0ZSgnbm9kZScsICdtc3BhY2UnLCBbXSwgeyB3aWR0aDogUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5FbShzcGFjZSkgfSk7XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGluZi5hcHBlbmRDaGlsZChtc3BhY2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG1zcGFjZS5wYXJlbnQgPSBpbmY7XG4gICAgaW5mLmNoaWxkTm9kZXMudW5zaGlmdChtc3BhY2UpO1xufTtcbnZhciBtb3ZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBbJ2luZmVyZW5jZScsICdwcm9vZicsICdtYXhBZGp1c3QnLCAnbGFiZWxsZWRSdWxlJ107XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkoc3JjLCB4KTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICgwLCBleHBvcnRzLnNldFByb3BlcnR5KShkZXN0LCB4LCB2YWx1ZSk7XG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5yZW1vdmVQcm9wZXJ0eSkoc3JjLCB4KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbnZhciBhZGp1c3RTZXF1ZW50cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgc2VxdWVudHMgPSBjb25maWcubm9kZUxpc3RzWydzZXF1ZW50J107XG4gICAgaWYgKCFzZXF1ZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBzZXF1ZW50cy5sZW5ndGggLSAxLCBzZXEgPSB2b2lkIDA7IHNlcSA9IHNlcXVlbnRzW2ldOyBpLS0pIHtcbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmdldFByb3BlcnR5KShzZXEsICdzZXF1ZW50UHJvY2Vzc2VkJykpIHtcbiAgICAgICAgICAgICgwLCBleHBvcnRzLnJlbW92ZVByb3BlcnR5KShzZXEsICdzZXF1ZW50UHJvY2Vzc2VkJyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICB2YXIgaW5mID0gZ2V0UGFyZW50SW5mKHNlcSk7XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkoaW5mLCAnaW5mZXJlbmNlJykgIT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3QucHVzaChzZXEpO1xuICAgICAgICB3aGlsZSAoKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKGluZiwgJ2luZmVyZW5jZScpID09PSAxKSB7XG4gICAgICAgICAgICBpbmYgPSBnZXRSdWxlKGluZik7XG4gICAgICAgICAgICB2YXIgcHJlbWlzZSA9IGZpcnN0UHJlbWlzZShnZXRQcmVtaXNlcyhpbmYsICgwLCBleHBvcnRzLmdldFByb3BlcnR5KShpbmYsICdpbmZlcmVuY2VSdWxlJykpKTtcbiAgICAgICAgICAgIHZhciBzZXF1ZW50ID0gKCgwLCBleHBvcnRzLmdldFByb3BlcnR5KShwcmVtaXNlLCAnaW5mZXJlbmNlUnVsZScpKSA/XG4gICAgICAgICAgICAgICAgZ2V0Q29uY2x1c2lvbihwcmVtaXNlLCAoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkocHJlbWlzZSwgJ2luZmVyZW5jZVJ1bGUnKSkgOlxuICAgICAgICAgICAgICAgIHByZW1pc2U7XG4gICAgICAgICAgICBpZiAoKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKHNlcXVlbnQsICdzZXF1ZW50JykpIHtcbiAgICAgICAgICAgICAgICBzZXEgPSBzZXF1ZW50LmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgY29sbGVjdC5wdXNoKHNlcSk7XG4gICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMuc2V0UHJvcGVydHkpKHNlcSwgJ3NlcXVlbnRQcm9jZXNzZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZiA9IHByZW1pc2U7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0U2VxdWVudFBhaXJ3aXNlKGNvbmZpZywgY29sbGVjdCk7XG4gICAgfVxufTtcbnZhciBhZGRTZXF1ZW50U3BhY2UgPSBmdW5jdGlvbiAoY29uZmlnLCBzZXF1ZW50LCBwb3NpdGlvbiwgZGlyZWN0aW9uLCB3aWR0aCkge1xuICAgIHZhciBtc3BhY2UgPSBjb25maWcubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ21zcGFjZScsIFtdLCB7IHdpZHRoOiBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LkVtKHdpZHRoKSB9KTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdmFyIHJvdyA9IHNlcXVlbnQuY2hpbGROb2Rlc1twb3NpdGlvbl0uY2hpbGROb2Rlc1swXTtcbiAgICAgICAgbXNwYWNlLnBhcmVudCA9IHJvdztcbiAgICAgICAgcm93LmNoaWxkTm9kZXMudW5zaGlmdChtc3BhY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VxdWVudC5jaGlsZE5vZGVzW3Bvc2l0aW9uXS5hcHBlbmRDaGlsZChtc3BhY2UpO1xuICAgIH1cbiAgICAoMCwgZXhwb3J0cy5zZXRQcm9wZXJ0eSkoc2VxdWVudC5wYXJlbnQsICdzZXF1ZW50QWRqdXN0XycgKyBkaXJlY3Rpb24sIHdpZHRoKTtcbn07XG52YXIgYWRqdXN0U2VxdWVudFBhaXJ3aXNlID0gZnVuY3Rpb24gKGNvbmZpZywgc2VxdWVudHMpIHtcbiAgICB2YXIgdG9wID0gc2VxdWVudHMucG9wKCk7XG4gICAgd2hpbGUgKHNlcXVlbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYm90dG9tID0gc2VxdWVudHMucG9wKCk7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChjb21wYXJlU2VxdWVudHModG9wLCBib3R0b20pLCAyKSwgbGVmdCA9IF9hWzBdLCByaWdodCA9IF9hWzFdO1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKHRvcC5wYXJlbnQsICdheGlvbScpKSB7XG4gICAgICAgICAgICBhZGRTZXF1ZW50U3BhY2UoY29uZmlnLCBsZWZ0IDwgMCA/IHRvcCA6IGJvdHRvbSwgMCwgJ2xlZnQnLCBNYXRoLmFicyhsZWZ0KSk7XG4gICAgICAgICAgICBhZGRTZXF1ZW50U3BhY2UoY29uZmlnLCByaWdodCA8IDAgPyB0b3AgOiBib3R0b20sIDIsICdyaWdodCcsIE1hdGguYWJzKHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9wID0gYm90dG9tO1xuICAgIH1cbn07XG52YXIgY29tcGFyZVNlcXVlbnRzID0gZnVuY3Rpb24gKHRvcCwgYm90dG9tKSB7XG4gICAgdmFyIHRyID0gZ2V0QkJveCh0b3AuY2hpbGROb2Rlc1syXSk7XG4gICAgdmFyIGJyID0gZ2V0QkJveChib3R0b20uY2hpbGROb2Rlc1syXSk7XG4gICAgdmFyIHRsID0gZ2V0QkJveCh0b3AuY2hpbGROb2Rlc1swXSk7XG4gICAgdmFyIGJsID0gZ2V0QkJveChib3R0b20uY2hpbGROb2Rlc1swXSk7XG4gICAgdmFyIGRsID0gdGwgLSBibDtcbiAgICB2YXIgZHIgPSB0ciAtIGJyO1xuICAgIHJldHVybiBbZGwsIGRyXTtcbn07XG52YXIgYmFsYW5jZVJ1bGVzID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIGl0ZW0gPSBuZXcgYXJnLmRvY3VtZW50Lm9wdGlvbnMuTWF0aEl0ZW0oJycsIG51bGwsIGFyZy5tYXRoLmRpc3BsYXkpO1xuICAgIHZhciBjb25maWcgPSBhcmcuZGF0YTtcbiAgICBhZGp1c3RTZXF1ZW50cyhjb25maWcpO1xuICAgIHZhciBpbmZlcmVuY2VzID0gY29uZmlnLm5vZGVMaXN0c1snaW5mZXJlbmNlJ10gfHwgW107XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaW5mZXJlbmNlc18xID0gX192YWx1ZXMoaW5mZXJlbmNlcyksIGluZmVyZW5jZXNfMV8xID0gaW5mZXJlbmNlc18xLm5leHQoKTsgIWluZmVyZW5jZXNfMV8xLmRvbmU7IGluZmVyZW5jZXNfMV8xID0gaW5mZXJlbmNlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGluZiA9IGluZmVyZW5jZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGlzUHJvb2YgPSAoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkoaW5mLCAncHJvb2YnKTtcbiAgICAgICAgICAgIHZhciBydWxlID0gZ2V0UnVsZShpbmYpO1xuICAgICAgICAgICAgdmFyIHByZW1pc2VzID0gZ2V0UHJlbWlzZXMocnVsZSwgKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKHJ1bGUsICdpbmZlcmVuY2VSdWxlJykpO1xuICAgICAgICAgICAgdmFyIHByZW1pc2VGID0gZmlyc3RQcmVtaXNlKHByZW1pc2VzKTtcbiAgICAgICAgICAgIGlmICgoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkocHJlbWlzZUYsICdpbmZlcmVuY2UnKSkge1xuICAgICAgICAgICAgICAgIHZhciBhZGp1c3RfMSA9IGFkanVzdFZhbHVlKHByZW1pc2VGKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRqdXN0XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3BhY2UoY29uZmlnLCBwcmVtaXNlRiwgLWFkanVzdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdfMSA9IGdldFNwYWNlcyhpbmYsIHJ1bGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3BhY2UoY29uZmlnLCBpbmYsIGFkanVzdF8xIC0gd18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlbWlzZUwgPSBsYXN0UHJlbWlzZShwcmVtaXNlcyk7XG4gICAgICAgICAgICBpZiAoKDAsIGV4cG9ydHMuZ2V0UHJvcGVydHkpKHByZW1pc2VMLCAnaW5mZXJlbmNlJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkanVzdCA9IGFkanVzdFZhbHVlKHByZW1pc2VMLCB0cnVlKTtcbiAgICAgICAgICAgIGFkZFNwYWNlKGNvbmZpZywgcHJlbWlzZUwsIC1hZGp1c3QsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHcgPSBnZXRTcGFjZXMoaW5mLCBydWxlLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBtYXhBZGp1c3QgPSAoMCwgZXhwb3J0cy5nZXRQcm9wZXJ0eSkoaW5mLCAnbWF4QWRqdXN0Jyk7XG4gICAgICAgICAgICBpZiAobWF4QWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3QgPSBNYXRoLm1heChhZGp1c3QsIG1heEFkanVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGlzUHJvb2YgfHwgIShjb2x1bW4gPSBnZXRDb2x1bW4oaW5mKSkpIHtcbiAgICAgICAgICAgICAgICBhZGRTcGFjZShjb25maWcsICgwLCBleHBvcnRzLmdldFByb3BlcnR5KShpbmYsICdwcm9vZicpID8gaW5mIDogaW5mLnBhcmVudCwgYWRqdXN0IC0gdywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2libGluZyA9IG5leHRTaWJsaW5nKGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBjb25maWcubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ21zcGFjZScsIFtdLCB7IHdpZHRoOiBhZGp1c3QgLSB3ICsgJ2VtJyB9KTtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLmFwcGVuZENoaWxkKHBvcyk7XG4gICAgICAgICAgICAgICAgaW5mLnJlbW92ZVByb3BlcnR5KCdtYXhBZGp1c3QnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnRSdWxlID0gZ2V0UGFyZW50SW5mKGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoIXBhcmVudFJ1bGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkanVzdCA9ICgwLCBleHBvcnRzLmdldFByb3BlcnR5KShwYXJlbnRSdWxlLCAnbWF4QWRqdXN0JykgP1xuICAgICAgICAgICAgICAgIE1hdGgubWF4KCgwLCBleHBvcnRzLmdldFByb3BlcnR5KShwYXJlbnRSdWxlLCAnbWF4QWRqdXN0JyksIGFkanVzdCkgOiBhZGp1c3Q7XG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5zZXRQcm9wZXJ0eSkocGFyZW50UnVsZSwgJ21heEFkanVzdCcsIGFkanVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpbmZlcmVuY2VzXzFfMSAmJiAhaW5mZXJlbmNlc18xXzEuZG9uZSAmJiAoX2EgPSBpbmZlcmVuY2VzXzEucmV0dXJuKSkgX2EuY2FsbChpbmZlcmVuY2VzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG59O1xuZXhwb3J0cy5iYWxhbmNlUnVsZXMgPSBiYWxhbmNlUnVsZXM7XG52YXIgcHJvcGVydHlfcHJlZml4ID0gJ2JzcHJfJztcbnZhciBibGFja2xpc3RlZFByb3BlcnRpZXMgPSAoX2EgPSB7fSxcbiAgICBfYVtwcm9wZXJ0eV9wcmVmaXggKyAnbWF4QWRqdXN0J10gPSB0cnVlLFxuICAgIF9hKTtcbnZhciBzZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0UHJvcGVydHkobm9kZSwgcHJvcGVydHlfcHJlZml4ICsgcHJvcGVydHksIHZhbHVlKTtcbn07XG5leHBvcnRzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG52YXIgZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldFByb3BlcnR5KG5vZGUsIHByb3BlcnR5X3ByZWZpeCArIHByb3BlcnR5KTtcbn07XG5leHBvcnRzLmdldFByb3BlcnR5ID0gZ2V0UHJvcGVydHk7XG52YXIgcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHkpIHtcbiAgICBub2RlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5X3ByZWZpeCArIHByb3BlcnR5KTtcbn07XG5leHBvcnRzLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG52YXIgbWFrZUJzcHJBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGFyZykge1xuICAgIGFyZy5kYXRhLnJvb3Qud2Fsa1RyZWUoZnVuY3Rpb24gKG1tbCwgX2RhdGEpIHtcbiAgICAgICAgdmFyIGF0dHIgPSBbXTtcbiAgICAgICAgbW1sLmdldFByb3BlcnR5TmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpZiAoIWJsYWNrbGlzdGVkUHJvcGVydGllc1t4XSAmJiB4Lm1hdGNoKFJlZ0V4cCgnXicgKyBwcm9wZXJ0eV9wcmVmaXgpKSkge1xuICAgICAgICAgICAgICAgIGF0dHIucHVzaCh4ICsgJzonICsgbW1sLmdldFByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhdHRyLmxlbmd0aCkge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShtbWwsICdzZW1hbnRpY3MnLCBhdHRyLmpvaW4oJzsnKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLm1ha2VCc3ByQXR0cmlidXRlcyA9IG1ha2VCc3ByQXR0cmlidXRlcztcbnZhciBzYXZlRG9jdW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgZG9jID0gYXJnLmRvY3VtZW50O1xuICAgIGlmICghKCdnZXRCQm94JyBpbiBkb2Mub3V0cHV0SmF4KSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVGhlIGJ1c3Nwcm9vZnMgZXh0ZW5zaW9uIHJlcXVpcmVzIGFuIG91dHB1dCBqYXggd2l0aCBhIGdldEJCb3goKSBtZXRob2QnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zYXZlRG9jdW1lbnQgPSBzYXZlRG9jdW1lbnQ7XG52YXIgY2xlYXJEb2N1bWVudCA9IGZ1bmN0aW9uIChfYXJnKSB7XG4gICAgZG9jID0gbnVsbDtcbn07XG5leHBvcnRzLmNsZWFyRG9jdW1lbnQgPSBjbGVhckRvY3VtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVzc3Byb29mc1V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbmNlbENvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkNhbmNlbE1ldGhvZHMgPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgVGV4Q29uc3RhbnRzX2pzXzEgPSByZXF1aXJlKFwiLi4vVGV4Q29uc3RhbnRzLmpzXCIpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBFbmNsb3NlQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL2VuY2xvc2UvRW5jbG9zZUNvbmZpZ3VyYXRpb24uanNcIik7XG5leHBvcnRzLkNhbmNlbE1ldGhvZHMgPSB7fTtcbmV4cG9ydHMuQ2FuY2VsTWV0aG9kcy5DYW5jZWwgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBub3RhdGlvbikge1xuICAgIHZhciBhdHRyID0gcGFyc2VyLkdldEJyYWNrZXRzKG5hbWUsICcnKTtcbiAgICB2YXIgbWF0aCA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICB2YXIgZGVmID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5rZXl2YWxPcHRpb25zKGF0dHIsIEVuY2xvc2VDb25maWd1cmF0aW9uX2pzXzEuRU5DTE9TRV9PUFRJT05TKTtcbiAgICBkZWZbJ25vdGF0aW9uJ10gPSBub3RhdGlvbjtcbiAgICBwYXJzZXIuUHVzaChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21lbmNsb3NlJywgW21hdGhdLCBkZWYpKTtcbn07XG5leHBvcnRzLkNhbmNlbE1ldGhvZHMuQ2FuY2VsVG8gPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGF0dHIgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICB2YXIgbWF0aCA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICB2YXIgZGVmID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5rZXl2YWxPcHRpb25zKGF0dHIsIEVuY2xvc2VDb25maWd1cmF0aW9uX2pzXzEuRU5DTE9TRV9PUFRJT05TKTtcbiAgICBkZWZbJ25vdGF0aW9uJ10gPSBbVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuTm90YXRpb24uVVBESUFHT05BTFNUUklLRSxcbiAgICAgICAgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuTm90YXRpb24uVVBESUFHT05BTEFSUk9XLFxuICAgICAgICBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5Ob3RhdGlvbi5OT1JUSEVBU1RBUlJPV10uam9pbignICcpO1xuICAgIHZhbHVlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW3ZhbHVlXSwgeyBkZXB0aDogJy0uMWVtJywgaGVpZ2h0OiAnKy4xZW0nLCB2b2Zmc2V0OiAnLjFlbScgfSk7XG4gICAgcGFyc2VyLlB1c2gocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtc3VwJywgW3BhcnNlci5jcmVhdGUoJ25vZGUnLCAnbWVuY2xvc2UnLCBbbWF0aF0sIGRlZiksIHZhbHVlXSkpO1xufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdjYW5jZWwnLCB7XG4gICAgY2FuY2VsOiBbJ0NhbmNlbCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50Lk5vdGF0aW9uLlVQRElBR09OQUxTVFJJS0VdLFxuICAgIGJjYW5jZWw6IFsnQ2FuY2VsJywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuTm90YXRpb24uRE9XTkRJQUdPTkFMU1RSSUtFXSxcbiAgICB4Y2FuY2VsOiBbJ0NhbmNlbCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50Lk5vdGF0aW9uLlVQRElBR09OQUxTVFJJS0UgKyAnICcgK1xuICAgICAgICAgICAgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuTm90YXRpb24uRE9XTkRJQUdPTkFMU1RSSUtFXSxcbiAgICBjYW5jZWx0bzogJ0NhbmNlbFRvJ1xufSwgZXhwb3J0cy5DYW5jZWxNZXRob2RzKTtcbmV4cG9ydHMuQ2FuY2VsQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnY2FuY2VsJywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ2NhbmNlbCddIH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW5jZWxDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FzZXNDb25maWd1cmF0aW9uID0gZXhwb3J0cy5DYXNlc01ldGhvZHMgPSBleHBvcnRzLkNhc2VzVGFncyA9IGV4cG9ydHMuQ2FzZXNCZWdpbkl0ZW0gPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgU3ltYm9sTWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIEJhc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Jhc2UvQmFzZU1ldGhvZHMuanNcIikpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBCYXNlSXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuLi9iYXNlL0Jhc2VJdGVtcy5qc1wiKTtcbnZhciBBbXNDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vYW1zL0Ftc0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgRW1waGVxVXRpbF9qc18xID0gcmVxdWlyZShcIi4uL2VtcGhlcS9FbXBoZXFVdGlsLmpzXCIpO1xudmFyIENhc2VzQmVnaW5JdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FzZXNCZWdpbkl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FzZXNCZWdpbkl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhc2VzQmVnaW5JdGVtLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Nhc2VzLWJlZ2luJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhc2VzQmVnaW5JdGVtLnByb3RvdHlwZS5jaGVja0l0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5pc0tpbmQoJ2VuZCcpICYmIGl0ZW0uZ2V0TmFtZSgpID09PSB0aGlzLmdldE5hbWUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UHJvcGVydHkoJ2VuZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eSgnZW5kJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbW10sIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNoZWNrSXRlbS5jYWxsKHRoaXMsIGl0ZW0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhc2VzQmVnaW5JdGVtO1xufShCYXNlSXRlbXNfanNfMS5CZWdpbkl0ZW0pKTtcbmV4cG9ydHMuQ2FzZXNCZWdpbkl0ZW0gPSBDYXNlc0JlZ2luSXRlbTtcbnZhciBDYXNlc1RhZ3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXNlc1RhZ3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FzZXNUYWdzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3ViY291bnRlciA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FzZXNUYWdzLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChlbnYsIHRhZ2dhYmxlLCBkZWZhdWx0VGFncykge1xuICAgICAgICB0aGlzLnN1YmNvdW50ZXIgPSAwO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnN0YXJ0LmNhbGwodGhpcywgZW52LCB0YWdnYWJsZSwgZGVmYXVsdFRhZ3MpO1xuICAgIH07XG4gICAgQ2FzZXNUYWdzLnByb3RvdHlwZS5hdXRvVGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGFnLnRhZyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGFnLmVudiA9PT0gJ3N1Ym51bWNhc2VzJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViY291bnRlciA9PT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgICAgIHRoaXMuc3ViY291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy50YWcodGhpcy5mb3JtYXROdW1iZXIodGhpcy5jb3VudGVyLCB0aGlzLnN1YmNvdW50ZXIpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJjb3VudGVyID09PSAwIHx8IHRoaXMuY3VycmVudFRhZy5lbnYgIT09ICdudW1jYXNlcy1sZWZ0JylcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgICAgIHRoaXMudGFnKHRoaXMuZm9ybWF0TnVtYmVyKHRoaXMuY291bnRlciksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FzZXNUYWdzLnByb3RvdHlwZS5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiAobiwgbSkge1xuICAgICAgICBpZiAobSA9PT0gdm9pZCAwKSB7IG0gPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCkgKyAobSA9PT0gbnVsbCA/ICcnIDogU3RyaW5nLmZyb21DaGFyQ29kZSgweDYwICsgbSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhc2VzVGFncztcbn0oQW1zQ29uZmlndXJhdGlvbl9qc18xLkFtc1RhZ3MpKTtcbmV4cG9ydHMuQ2FzZXNUYWdzID0gQ2FzZXNUYWdzO1xuZXhwb3J0cy5DYXNlc01ldGhvZHMgPSB7XG4gICAgTnVtQ2FzZXM6IGZ1bmN0aW9uIChwYXJzZXIsIGJlZ2luKSB7XG4gICAgICAgIGlmIChwYXJzZXIuc3RhY2suZW52LmNsb3NpbmcgPT09IGJlZ2luLmdldE5hbWUoKSkge1xuICAgICAgICAgICAgZGVsZXRlIHBhcnNlci5zdGFjay5lbnYuY2xvc2luZztcbiAgICAgICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2VuZCcpLnNldFByb3BlcnR5KCduYW1lJywgYmVnaW4uZ2V0TmFtZSgpKSk7XG4gICAgICAgICAgICB2YXIgY2FzZXMgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgICAgICAgICB2YXIgdGFibGUgPSBjYXNlcy5MYXN0O1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jb3B5Tm9kZSh0YWJsZSwgcGFyc2VyKTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gY2FzZXMuZ2V0UHJvcGVydHkoJ2xlZnQnKTtcbiAgICAgICAgICAgIEVtcGhlcVV0aWxfanNfMS5FbXBoZXFVdGlsLmxlZnQodGFibGUsIG9yaWdpbmFsLCBsZWZ0ICsgJ1xcXFxlbXBoZXFsYnJhY2VcXFxcLCcsIHBhcnNlciwgJ251bWNhc2VzLWxlZnQnKTtcbiAgICAgICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2VuZCcpLnNldFByb3BlcnR5KCduYW1lJywgYmVnaW4uZ2V0TmFtZSgpKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcGFyc2VyLkdldEFyZ3VtZW50KCdcXFxcYmVnaW57JyArIGJlZ2luLmdldE5hbWUoKSArICd9Jyk7XG4gICAgICAgICAgICBiZWdpbi5zZXRQcm9wZXJ0eSgnbGVmdCcsIGxlZnQpO1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0LkVxbkFycmF5KHBhcnNlciwgYmVnaW4sIHRydWUsIHRydWUsICdsbCcpO1xuICAgICAgICAgICAgYXJyYXkuYXJyYXlkZWYuZGlzcGxheXN0eWxlID0gZmFsc2U7XG4gICAgICAgICAgICBhcnJheS5hcnJheWRlZi5yb3dzcGFjaW5nID0gJy4yZW0nO1xuICAgICAgICAgICAgYXJyYXkuc2V0UHJvcGVydHkoJ251bUNhc2VzJywgdHJ1ZSk7XG4gICAgICAgICAgICBwYXJzZXIuUHVzaChiZWdpbik7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIEVudHJ5OiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIGlmICghcGFyc2VyLnN0YWNrLlRvcCgpLmdldFByb3BlcnR5KCdudW1DYXNlcycpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0LkVudHJ5KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLlB1c2gocGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnY2VsbCcpLnNldFByb3BlcnRpZXMoeyBpc0VudHJ5OiB0cnVlLCBuYW1lOiBuYW1lIH0pKTtcbiAgICAgICAgdmFyIHRleCA9IHBhcnNlci5zdHJpbmc7XG4gICAgICAgIHZhciBicmFjZXMgPSAwLCBpID0gcGFyc2VyLmksIG0gPSB0ZXgubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgICAgICAgIHZhciBjID0gdGV4LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnJicgJiYgYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnRXh0cmFDYXNlc0FsaWduVGFiJywgJ0V4dHJhIGFsaWdubWVudCB0YWIgaW4gdGV4dCBmb3IgbnVtY2FzZSBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1xcXFwnICYmIGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjcyA9ICh0ZXguc2xpY2UoaSArIDEpLm1hdGNoKC9eW2Etel0rfC4vaSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gJ1xcXFwnIHx8IGNzID09PSAnY3InIHx8IGNzID09PSAnZW5kJyB8fCBjcyA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IHRleC5zdWJzdHIocGFyc2VyLmksIGkgLSBwYXJzZXIuaSkucmVwbGFjZSgvXlxccyovLCAnJyk7XG4gICAgICAgIHBhcnNlci5QdXNoQWxsKFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuaW50ZXJuYWxNYXRoKHBhcnNlciwgdGV4dCwgMCkpO1xuICAgICAgICBwYXJzZXIuaSA9IGk7XG4gICAgfVxufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5FbnZpcm9ubWVudE1hcCgnY2FzZXMtZW52JywgRW1waGVxVXRpbF9qc18xLkVtcGhlcVV0aWwuZW52aXJvbm1lbnQsIHtcbiAgICBudW1jYXNlczogWydOdW1DYXNlcycsICdjYXNlcyddLFxuICAgIHN1Ym51bWNhc2VzOiBbJ051bUNhc2VzJywgJ2Nhc2VzJ11cbn0sIGV4cG9ydHMuQ2FzZXNNZXRob2RzKTtcbm5ldyBTeW1ib2xNYXBfanNfMS5NYWNyb01hcCgnY2FzZXMtbWFjcm9zJywge1xuICAgICcmJzogJ0VudHJ5J1xufSwgZXhwb3J0cy5DYXNlc01ldGhvZHMpO1xuZXhwb3J0cy5DYXNlc0NvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ2Nhc2VzJywge1xuICAgIGhhbmRsZXI6IHtcbiAgICAgICAgZW52aXJvbm1lbnQ6IFsnY2FzZXMtZW52J10sXG4gICAgICAgIGNoYXJhY3RlcjogWydjYXNlcy1tYWNyb3MnXVxuICAgIH0sXG4gICAgaXRlbXM6IChfYSA9IHt9LFxuICAgICAgICBfYVtDYXNlc0JlZ2luSXRlbS5wcm90b3R5cGUua2luZF0gPSBDYXNlc0JlZ2luSXRlbSxcbiAgICAgICAgX2EpLFxuICAgIHRhZ3M6IHsgJ2Nhc2VzJzogQ2FzZXNUYWdzIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FzZXNDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZW50ZXJub3RDb25maWd1cmF0aW9uID0gZXhwb3J0cy5maWx0ZXJDZW50ZXJPdmVyID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFRleFBhcnNlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhQYXJzZXIuanNcIikpO1xudmFyIE5vZGVVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL05vZGVVdGlsLmpzXCIpKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgQmFzZU1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYmFzZS9CYXNlTWV0aG9kcy5qc1wiKSk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnY2VudGVybm90Jywge1xuICAgIGNlbnRlck92ZXI6ICdDZW50ZXJPdmVyJyxcbiAgICBjZW50ZXJub3Q6IFsnTWFjcm8nLCAnXFxcXGNlbnRlck92ZXJ7IzF9e3tcXHUyOUY4fX0nLCAxXVxufSwge1xuICAgIENlbnRlck92ZXI6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIGFyZyA9ICd7JyArIHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSArICd9JztcbiAgICAgICAgdmFyIG92ZXIgPSBwYXJzZXIuUGFyc2VBcmcobmFtZSk7XG4gICAgICAgIHZhciBiYXNlID0gbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoYXJnLCBwYXJzZXIuc3RhY2suZW52LCBwYXJzZXIuY29uZmlndXJhdGlvbikubW1sKCk7XG4gICAgICAgIHZhciBtbWwgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ1RlWEF0b20nLCBbXG4gICAgICAgICAgICBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChhcmcsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSxcbiAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBbb3Zlcl0sIHsgd2lkdGg6IDAsIGxzcGFjZTogJy0uNXdpZHRoJyB9KSxcbiAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21waGFudG9tJywgW2Jhc2VdKVxuICAgICAgICAgICAgXSwgeyB3aWR0aDogMCwgbHNwYWNlOiAnLS41d2lkdGgnIH0pXG4gICAgICAgIF0pO1xuICAgICAgICBwYXJzZXIuY29uZmlndXJhdGlvbi5hZGROb2RlKCdjZW50ZXJPdmVyJywgYmFzZSk7XG4gICAgICAgIHBhcnNlci5QdXNoKG1tbCk7XG4gICAgfSxcbiAgICBNYWNybzogQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lk1hY3JvXG59KTtcbmZ1bmN0aW9uIGZpbHRlckNlbnRlck92ZXIoX2EpIHtcbiAgICB2YXIgZV8xLCBfYjtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhkYXRhLmdldExpc3QoJ2NlbnRlck92ZXInKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gX2QudmFsdWU7XG4gICAgICAgICAgICB2YXIgdGV4Q2xhc3MgPSBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0VGV4Q2xhc3MoYmFzZS5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgaWYgKHRleENsYXNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnRpZXMoYmFzZS5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudCwgeyB0ZXhDbGFzczogdGV4Q2xhc3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2IgPSBfYy5yZXR1cm4pKSBfYi5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxufVxuZXhwb3J0cy5maWx0ZXJDZW50ZXJPdmVyID0gZmlsdGVyQ2VudGVyT3ZlcjtcbmV4cG9ydHMuQ2VudGVybm90Q29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnY2VudGVybm90Jywge1xuICAgIGhhbmRsZXI6IHsgbWFjcm86IFsnY2VudGVybm90J10gfSxcbiAgICBwb3N0cHJvY2Vzc29yczogW2ZpbHRlckNlbnRlck92ZXJdXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNlbnRlcm5vdENvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbG9yQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgQ29sb3JNZXRob2RzX2pzXzEgPSByZXF1aXJlKFwiLi9Db2xvck1ldGhvZHMuanNcIik7XG52YXIgQ29sb3JVdGlsX2pzXzEgPSByZXF1aXJlKFwiLi9Db2xvclV0aWwuanNcIik7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnY29sb3InLCB7XG4gICAgY29sb3I6ICdDb2xvcicsXG4gICAgdGV4dGNvbG9yOiAnVGV4dENvbG9yJyxcbiAgICBkZWZpbmVjb2xvcjogJ0RlZmluZUNvbG9yJyxcbiAgICBjb2xvcmJveDogJ0NvbG9yQm94JyxcbiAgICBmY29sb3Jib3g6ICdGQ29sb3JCb3gnXG59LCBDb2xvck1ldGhvZHNfanNfMS5Db2xvck1ldGhvZHMpO1xudmFyIGNvbmZpZyA9IGZ1bmN0aW9uIChfY29uZmlnLCBqYXgpIHtcbiAgICBqYXgucGFyc2VPcHRpb25zLnBhY2thZ2VEYXRhLnNldCgnY29sb3InLCB7IG1vZGVsOiBuZXcgQ29sb3JVdGlsX2pzXzEuQ29sb3JNb2RlbCgpIH0pO1xufTtcbmV4cG9ydHMuQ29sb3JDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdjb2xvcicsIHtcbiAgICBoYW5kbGVyOiB7XG4gICAgICAgIG1hY3JvOiBbJ2NvbG9yJ10sXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAnNXB4JyxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAnMnB4J1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb25maWc6IGNvbmZpZ1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvckNvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNPTE9SUyA9IHZvaWQgMDtcbmV4cG9ydHMuQ09MT1JTID0gbmV3IE1hcChbXG4gICAgWydBcHJpY290JywgJyNGQkI5ODInXSxcbiAgICBbJ0FxdWFtYXJpbmUnLCAnIzAwQjVCRSddLFxuICAgIFsnQml0dGVyc3dlZXQnLCAnI0MwNEYxNyddLFxuICAgIFsnQmxhY2snLCAnIzIyMUUxRiddLFxuICAgIFsnQmx1ZScsICcjMkQyRjkyJ10sXG4gICAgWydCbHVlR3JlZW4nLCAnIzAwQjNCOCddLFxuICAgIFsnQmx1ZVZpb2xldCcsICcjNDczOTkyJ10sXG4gICAgWydCcmlja1JlZCcsICcjQjYzMjFDJ10sXG4gICAgWydCcm93bicsICcjNzkyNTAwJ10sXG4gICAgWydCdXJudE9yYW5nZScsICcjRjc5MjFEJ10sXG4gICAgWydDYWRldEJsdWUnLCAnIzc0NzI5QSddLFxuICAgIFsnQ2FybmF0aW9uUGluaycsICcjRjI4MkI0J10sXG4gICAgWydDZXJ1bGVhbicsICcjMDBBMkUzJ10sXG4gICAgWydDb3JuZmxvd2VyQmx1ZScsICcjNDFCMEU0J10sXG4gICAgWydDeWFuJywgJyMwMEFFRUYnXSxcbiAgICBbJ0RhbmRlbGlvbicsICcjRkRCQzQyJ10sXG4gICAgWydEYXJrT3JjaGlkJywgJyNBNDUzOEEnXSxcbiAgICBbJ0VtZXJhbGQnLCAnIzAwQTk5RCddLFxuICAgIFsnRm9yZXN0R3JlZW4nLCAnIzAwOUI1NSddLFxuICAgIFsnRnVjaHNpYScsICcjOEMzNjhDJ10sXG4gICAgWydHb2xkZW5yb2QnLCAnI0ZGREY0MiddLFxuICAgIFsnR3JheScsICcjOTQ5Njk4J10sXG4gICAgWydHcmVlbicsICcjMDBBNjRGJ10sXG4gICAgWydHcmVlblllbGxvdycsICcjREZFNjc0J10sXG4gICAgWydKdW5nbGVHcmVlbicsICcjMDBBOTlBJ10sXG4gICAgWydMYXZlbmRlcicsICcjRjQ5RUM0J10sXG4gICAgWydMaW1lR3JlZW4nLCAnIzhEQzczRSddLFxuICAgIFsnTWFnZW50YScsICcjRUMwMDhDJ10sXG4gICAgWydNYWhvZ2FueScsICcjQTkzNDFGJ10sXG4gICAgWydNYXJvb24nLCAnI0FGMzIzNSddLFxuICAgIFsnTWVsb24nLCAnI0Y4OUU3QiddLFxuICAgIFsnTWlkbmlnaHRCbHVlJywgJyMwMDY3OTUnXSxcbiAgICBbJ011bGJlcnJ5JywgJyNBOTNDOTMnXSxcbiAgICBbJ05hdnlCbHVlJywgJyMwMDZFQjgnXSxcbiAgICBbJ09saXZlR3JlZW4nLCAnIzNDODAzMSddLFxuICAgIFsnT3JhbmdlJywgJyNGNTgxMzcnXSxcbiAgICBbJ09yYW5nZVJlZCcsICcjRUQxMzVBJ10sXG4gICAgWydPcmNoaWQnLCAnI0FGNzJCMCddLFxuICAgIFsnUGVhY2gnLCAnI0Y3OTY1QSddLFxuICAgIFsnUGVyaXdpbmtsZScsICcjNzk3N0I4J10sXG4gICAgWydQaW5lR3JlZW4nLCAnIzAwOEI3MiddLFxuICAgIFsnUGx1bScsICcjOTIyNjhGJ10sXG4gICAgWydQcm9jZXNzQmx1ZScsICcjMDBCMEYwJ10sXG4gICAgWydQdXJwbGUnLCAnIzk5NDc5QiddLFxuICAgIFsnUmF3U2llbm5hJywgJyM5NzQwMDYnXSxcbiAgICBbJ1JlZCcsICcjRUQxQjIzJ10sXG4gICAgWydSZWRPcmFuZ2UnLCAnI0YyNjAzNSddLFxuICAgIFsnUmVkVmlvbGV0JywgJyNBMTI0NkInXSxcbiAgICBbJ1Job2RhbWluZScsICcjRUY1NTlGJ10sXG4gICAgWydSb3lhbEJsdWUnLCAnIzAwNzFCQyddLFxuICAgIFsnUm95YWxQdXJwbGUnLCAnIzYxM0Y5OSddLFxuICAgIFsnUnViaW5lUmVkJywgJyNFRDAxN0QnXSxcbiAgICBbJ1NhbG1vbicsICcjRjY5Mjg5J10sXG4gICAgWydTZWFHcmVlbicsICcjM0ZCQzlEJ10sXG4gICAgWydTZXBpYScsICcjNjcxODAwJ10sXG4gICAgWydTa3lCbHVlJywgJyM0NkM1REQnXSxcbiAgICBbJ1NwcmluZ0dyZWVuJywgJyNDNkRDNjcnXSxcbiAgICBbJ1RhbicsICcjREE5RDc2J10sXG4gICAgWydUZWFsQmx1ZScsICcjMDBBRUIzJ10sXG4gICAgWydUaGlzdGxlJywgJyNEODgzQjcnXSxcbiAgICBbJ1R1cnF1b2lzZScsICcjMDBCNENFJ10sXG4gICAgWydWaW9sZXQnLCAnIzU4NDI5QiddLFxuICAgIFsnVmlvbGV0UmVkJywgJyNFRjU4QTAnXSxcbiAgICBbJ1doaXRlJywgJyNGRkZGRkYnXSxcbiAgICBbJ1dpbGRTdHJhd2JlcnJ5JywgJyNFRTI5NjcnXSxcbiAgICBbJ1llbGxvdycsICcjRkZGMjAwJ10sXG4gICAgWydZZWxsb3dHcmVlbicsICcjOThDQzcwJ10sXG4gICAgWydZZWxsb3dPcmFuZ2UnLCAnI0ZBQTIxQSddLFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvckNvbnN0YW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sb3JNZXRob2RzID0gdm9pZCAwO1xudmFyIE5vZGVVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL05vZGVVdGlsLmpzXCIpKTtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbmZ1bmN0aW9uIHBhZGRpbmcoY29sb3JQYWRkaW5nKSB7XG4gICAgdmFyIHBhZCA9IFwiK1wiLmNvbmNhdChjb2xvclBhZGRpbmcpO1xuICAgIHZhciB1bml0ID0gY29sb3JQYWRkaW5nLnJlcGxhY2UoL14uKj8oW2Etel0qKSQvLCAnJDEnKTtcbiAgICB2YXIgcGFkMiA9IDIgKiBwYXJzZUZsb2F0KHBhZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IFwiK1wiLmNvbmNhdChwYWQyKS5jb25jYXQodW5pdCksXG4gICAgICAgIGhlaWdodDogcGFkLFxuICAgICAgICBkZXB0aDogcGFkLFxuICAgICAgICBsc3BhY2U6IGNvbG9yUGFkZGluZyxcbiAgICB9O1xufVxuZXhwb3J0cy5Db2xvck1ldGhvZHMgPSB7fTtcbmV4cG9ydHMuQ29sb3JNZXRob2RzLkNvbG9yID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBtb2RlbCA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lLCAnJyk7XG4gICAgdmFyIGNvbG9yRGVmID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBjb2xvck1vZGVsID0gcGFyc2VyLmNvbmZpZ3VyYXRpb24ucGFja2FnZURhdGEuZ2V0KCdjb2xvcicpLm1vZGVsO1xuICAgIHZhciBjb2xvciA9IGNvbG9yTW9kZWwuZ2V0Q29sb3IobW9kZWwsIGNvbG9yRGVmKTtcbiAgICB2YXIgc3R5bGUgPSBwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKCdzdHlsZScpXG4gICAgICAgIC5zZXRQcm9wZXJ0aWVzKHsgc3R5bGVzOiB7IG1hdGhjb2xvcjogY29sb3IgfSB9KTtcbiAgICBwYXJzZXIuc3RhY2suZW52Wydjb2xvciddID0gY29sb3I7XG4gICAgcGFyc2VyLlB1c2goc3R5bGUpO1xufTtcbmV4cG9ydHMuQ29sb3JNZXRob2RzLlRleHRDb2xvciA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgbW9kZWwgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgIHZhciBjb2xvckRlZiA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgY29sb3JNb2RlbCA9IHBhcnNlci5jb25maWd1cmF0aW9uLnBhY2thZ2VEYXRhLmdldCgnY29sb3InKS5tb2RlbDtcbiAgICB2YXIgY29sb3IgPSBjb2xvck1vZGVsLmdldENvbG9yKG1vZGVsLCBjb2xvckRlZik7XG4gICAgdmFyIG9sZCA9IHBhcnNlci5zdGFjay5lbnZbJ2NvbG9yJ107XG4gICAgcGFyc2VyLnN0YWNrLmVudlsnY29sb3InXSA9IGNvbG9yO1xuICAgIHZhciBtYXRoID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIGlmIChvbGQpIHtcbiAgICAgICAgcGFyc2VyLnN0YWNrLmVudlsnY29sb3InXSA9IG9sZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwYXJzZXIuc3RhY2suZW52Wydjb2xvciddO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXN0eWxlJywgW21hdGhdLCB7IG1hdGhjb2xvcjogY29sb3IgfSk7XG4gICAgcGFyc2VyLlB1c2gobm9kZSk7XG59O1xuZXhwb3J0cy5Db2xvck1ldGhvZHMuRGVmaW5lQ29sb3IgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGNuYW1lID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBtb2RlbCA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgZGVmID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBjb2xvck1vZGVsID0gcGFyc2VyLmNvbmZpZ3VyYXRpb24ucGFja2FnZURhdGEuZ2V0KCdjb2xvcicpLm1vZGVsO1xuICAgIGNvbG9yTW9kZWwuZGVmaW5lQ29sb3IobW9kZWwsIGNuYW1lLCBkZWYpO1xufTtcbmV4cG9ydHMuQ29sb3JNZXRob2RzLkNvbG9yQm94ID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBjbmFtZSA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgbWF0aCA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuaW50ZXJuYWxNYXRoKHBhcnNlciwgcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKTtcbiAgICB2YXIgY29sb3JNb2RlbCA9IHBhcnNlci5jb25maWd1cmF0aW9uLnBhY2thZ2VEYXRhLmdldCgnY29sb3InKS5tb2RlbDtcbiAgICB2YXIgbm9kZSA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIG1hdGgsIHtcbiAgICAgICAgbWF0aGJhY2tncm91bmQ6IGNvbG9yTW9kZWwuZ2V0Q29sb3IoJ25hbWVkJywgY25hbWUpXG4gICAgfSk7XG4gICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnRpZXMobm9kZSwgcGFkZGluZyhwYXJzZXIub3B0aW9ucy5jb2xvci5wYWRkaW5nKSk7XG4gICAgcGFyc2VyLlB1c2gobm9kZSk7XG59O1xuZXhwb3J0cy5Db2xvck1ldGhvZHMuRkNvbG9yQm94ID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBmbmFtZSA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgY25hbWUgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIG1hdGggPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmludGVybmFsTWF0aChwYXJzZXIsIHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIub3B0aW9ucy5jb2xvcjtcbiAgICB2YXIgY29sb3JNb2RlbCA9IHBhcnNlci5jb25maWd1cmF0aW9uLnBhY2thZ2VEYXRhLmdldCgnY29sb3InKS5tb2RlbDtcbiAgICB2YXIgbm9kZSA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIG1hdGgsIHtcbiAgICAgICAgbWF0aGJhY2tncm91bmQ6IGNvbG9yTW9kZWwuZ2V0Q29sb3IoJ25hbWVkJywgY25hbWUpLFxuICAgICAgICBzdHlsZTogXCJib3JkZXI6IFwiLmNvbmNhdChvcHRpb25zLmJvcmRlcldpZHRoLCBcIiBzb2xpZCBcIikuY29uY2F0KGNvbG9yTW9kZWwuZ2V0Q29sb3IoJ25hbWVkJywgZm5hbWUpKVxuICAgIH0pO1xuICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRQcm9wZXJ0aWVzKG5vZGUsIHBhZGRpbmcob3B0aW9ucy5wYWRkaW5nKSk7XG4gICAgcGFyc2VyLlB1c2gobm9kZSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JNZXRob2RzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xvck1vZGVsID0gdm9pZCAwO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBDb2xvckNvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4vQ29sb3JDb25zdGFudHMuanNcIik7XG52YXIgQ29sb3JNb2RlbFByb2Nlc3NvcnMgPSBuZXcgTWFwKCk7XG52YXIgQ29sb3JNb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JNb2RlbCgpIHtcbiAgICAgICAgdGhpcy51c2VyQ29sb3JzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBDb2xvck1vZGVsLnByb3RvdHlwZS5ub3JtYWxpemVDb2xvciA9IGZ1bmN0aW9uIChtb2RlbCwgZGVmKSB7XG4gICAgICAgIGlmICghbW9kZWwgfHwgbW9kZWwgPT09ICduYW1lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbG9yTW9kZWxQcm9jZXNzb3JzLmhhcyhtb2RlbCkpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbFByb2Nlc3NvciA9IENvbG9yTW9kZWxQcm9jZXNzb3JzLmdldChtb2RlbCk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxQcm9jZXNzb3IoZGVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdVbmRlZmluZWRDb2xvck1vZGVsJywgJ0NvbG9yIG1vZGVsIFxcJyUxXFwnIG5vdCBkZWZpbmVkJywgbW9kZWwpO1xuICAgIH07XG4gICAgQ29sb3JNb2RlbC5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiAobW9kZWwsIGRlZikge1xuICAgICAgICBpZiAoIW1vZGVsIHx8IG1vZGVsID09PSAnbmFtZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xvckJ5TmFtZShkZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUNvbG9yKG1vZGVsLCBkZWYpO1xuICAgIH07XG4gICAgQ29sb3JNb2RlbC5wcm90b3R5cGUuZ2V0Q29sb3JCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy51c2VyQ29sb3JzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNvbG9ycy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbG9yQ29uc3RhbnRzX2pzXzEuQ09MT1JTLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbG9yQ29uc3RhbnRzX2pzXzEuQ09MT1JTLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIENvbG9yTW9kZWwucHJvdG90eXBlLmRlZmluZUNvbG9yID0gZnVuY3Rpb24gKG1vZGVsLCBuYW1lLCBkZWYpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZUNvbG9yKG1vZGVsLCBkZWYpO1xuICAgICAgICB0aGlzLnVzZXJDb2xvcnMuc2V0KG5hbWUsIG5vcm1hbGl6ZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbG9yTW9kZWw7XG59KCkpO1xuZXhwb3J0cy5Db2xvck1vZGVsID0gQ29sb3JNb2RlbDtcbkNvbG9yTW9kZWxQcm9jZXNzb3JzLnNldCgncmdiJywgZnVuY3Rpb24gKHJnYikge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciByZ2JQYXJ0cyA9IHJnYi50cmltKCkuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIHZhciBSR0IgPSAnIyc7XG4gICAgaWYgKHJnYlBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNb2RlbEFyZzEnLCAnQ29sb3IgdmFsdWVzIGZvciB0aGUgJTEgbW9kZWwgcmVxdWlyZSAzIG51bWJlcnMnLCAncmdiJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHJnYlBhcnRzXzEgPSBfX3ZhbHVlcyhyZ2JQYXJ0cyksIHJnYlBhcnRzXzFfMSA9IHJnYlBhcnRzXzEubmV4dCgpOyAhcmdiUGFydHNfMV8xLmRvbmU7IHJnYlBhcnRzXzFfMSA9IHJnYlBhcnRzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgcmdiUGFydCA9IHJnYlBhcnRzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghcmdiUGFydC5tYXRjaCgvXihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKSQvKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0ludmFsaWREZWNpbWFsTnVtYmVyJywgJ0ludmFsaWQgZGVjaW1hbCBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuID0gcGFyc2VGbG9hdChyZ2JQYXJ0KTtcbiAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01vZGVsQXJnMicsICdDb2xvciB2YWx1ZXMgZm9yIHRoZSAlMSBtb2RlbCBtdXN0IGJlIGJldHdlZW4gJTIgYW5kICUzJywgJ3JnYicsICcwJywgJzEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbiA9IE1hdGguZmxvb3IobiAqIDI1NSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKHBuLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBwbiA9ICcwJyArIHBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUkdCICs9IHBuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocmdiUGFydHNfMV8xICYmICFyZ2JQYXJ0c18xXzEuZG9uZSAmJiAoX2EgPSByZ2JQYXJ0c18xLnJldHVybikpIF9hLmNhbGwocmdiUGFydHNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gUkdCO1xufSk7XG5Db2xvck1vZGVsUHJvY2Vzc29ycy5zZXQoJ1JHQicsIGZ1bmN0aW9uIChyZ2IpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICB2YXIgcmdiUGFydHMgPSByZ2IudHJpbSgpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICB2YXIgUkdCID0gJyMnO1xuICAgIGlmIChyZ2JQYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTW9kZWxBcmcxJywgJ0NvbG9yIHZhbHVlcyBmb3IgdGhlICUxIG1vZGVsIHJlcXVpcmUgMyBudW1iZXJzJywgJ1JHQicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciByZ2JQYXJ0c18yID0gX192YWx1ZXMocmdiUGFydHMpLCByZ2JQYXJ0c18yXzEgPSByZ2JQYXJ0c18yLm5leHQoKTsgIXJnYlBhcnRzXzJfMS5kb25lOyByZ2JQYXJ0c18yXzEgPSByZ2JQYXJ0c18yLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHJnYlBhcnQgPSByZ2JQYXJ0c18yXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAoIXJnYlBhcnQubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSW52YWxpZE51bWJlcicsICdJbnZhbGlkIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUludChyZ2JQYXJ0KTtcbiAgICAgICAgICAgIGlmIChuID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTW9kZWxBcmcyJywgJ0NvbG9yIHZhbHVlcyBmb3IgdGhlICUxIG1vZGVsIG11c3QgYmUgYmV0d2VlbiAlMiBhbmQgJTMnLCAnUkdCJywgJzAnLCAnMjU1Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG4gPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChwbi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcG4gPSAnMCcgKyBwbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJHQiArPSBwbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJnYlBhcnRzXzJfMSAmJiAhcmdiUGFydHNfMl8xLmRvbmUgJiYgKF9hID0gcmdiUGFydHNfMi5yZXR1cm4pKSBfYS5jYWxsKHJnYlBhcnRzXzIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIFJHQjtcbn0pO1xuQ29sb3JNb2RlbFByb2Nlc3NvcnMuc2V0KCdncmF5JywgZnVuY3Rpb24gKGdyYXkpIHtcbiAgICBpZiAoIWdyYXkubWF0Y2goL15cXHMqKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspXFxzKiQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdJbnZhbGlkRGVjaW1hbE51bWJlcicsICdJbnZhbGlkIGRlY2ltYWwgbnVtYmVyJyk7XG4gICAgfVxuICAgIHZhciBuID0gcGFyc2VGbG9hdChncmF5KTtcbiAgICBpZiAobiA8IDAgfHwgbiA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTW9kZWxBcmcyJywgJ0NvbG9yIHZhbHVlcyBmb3IgdGhlICUxIG1vZGVsIG11c3QgYmUgYmV0d2VlbiAlMiBhbmQgJTMnLCAnZ3JheScsICcwJywgJzEnKTtcbiAgICB9XG4gICAgdmFyIHBuID0gTWF0aC5mbG9vcihuICogMjU1KS50b1N0cmluZygxNik7XG4gICAgaWYgKHBuLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcG4gPSAnMCcgKyBwbjtcbiAgICB9XG4gICAgcmV0dXJuIFwiI1wiLmNvbmNhdChwbikuY29uY2F0KHBuKS5jb25jYXQocG4pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xvcnRibENvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkNvbG9yQXJyYXlJdGVtID0gdm9pZCAwO1xudmFyIEJhc2VJdGVtc19qc18xID0gcmVxdWlyZShcIi4uL2Jhc2UvQmFzZUl0ZW1zLmpzXCIpO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgQ29sb3JBcnJheUl0ZW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2xvckFycmF5SXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2xvckFycmF5SXRlbSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbG9yID0ge1xuICAgICAgICAgICAgY2VsbDogJycsXG4gICAgICAgICAgICByb3c6ICcnLFxuICAgICAgICAgICAgY29sOiBbXVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYXNDb2xvciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbG9yQXJyYXlJdGVtLnByb3RvdHlwZS5FbmRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5FbmRFbnRyeS5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMucm93W3RoaXMucm93Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yLmNlbGwgfHwgdGhpcy5jb2xvci5yb3cgfHwgdGhpcy5jb2xvci5jb2xbdGhpcy5yb3cubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgY2VsbC5hdHRyaWJ1dGVzLnNldCgnbWF0aGJhY2tncm91bmQnLCBjb2xvcik7XG4gICAgICAgICAgICB0aGlzLmNvbG9yLmNlbGwgPSAnJztcbiAgICAgICAgICAgIHRoaXMuaGFzQ29sb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvckFycmF5SXRlbS5wcm90b3R5cGUuRW5kUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLkVuZFJvdy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbG9yLnJvdyA9ICcnO1xuICAgIH07XG4gICAgQ29sb3JBcnJheUl0ZW0ucHJvdG90eXBlLmNyZWF0ZU1tbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1tbCA9IF9zdXBlci5wcm90b3R5cGUuY3JlYXRlTW1sLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciB0YWJsZSA9IChtbWwuaXNLaW5kKCdtcm93JykgPyBtbWwuY2hpbGROb2Rlc1sxXSA6IG1tbCk7XG4gICAgICAgIGlmICh0YWJsZS5pc0tpbmQoJ21lbmNsb3NlJykpIHtcbiAgICAgICAgICAgIHRhYmxlID0gdGFibGUuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbG9yICYmIHRhYmxlLmF0dHJpYnV0ZXMuZ2V0KCdmcmFtZScpID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRhYmxlLmF0dHJpYnV0ZXMuc2V0KCdmcmFtZScsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW1sO1xuICAgIH07XG4gICAgcmV0dXJuIENvbG9yQXJyYXlJdGVtO1xufShCYXNlSXRlbXNfanNfMS5BcnJheUl0ZW0pKTtcbmV4cG9ydHMuQ29sb3JBcnJheUl0ZW0gPSBDb2xvckFycmF5SXRlbTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdjb2xvcnRibCcsIHtcbiAgICBjZWxsY29sb3I6IFsnVGFibGVDb2xvcicsICdjZWxsJ10sXG4gICAgcm93Y29sb3I6IFsnVGFibGVDb2xvcicsICdyb3cnXSxcbiAgICBjb2x1bW5jb2xvcjogWydUYWJsZUNvbG9yJywgJ2NvbCddXG59LCB7XG4gICAgVGFibGVDb2xvcjogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgdHlwZSkge1xuICAgICAgICB2YXIgbG9va3VwID0gcGFyc2VyLmNvbmZpZ3VyYXRpb24ucGFja2FnZURhdGEuZ2V0KCdjb2xvcicpLm1vZGVsO1xuICAgICAgICB2YXIgbW9kZWwgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgICAgICB2YXIgY29sb3IgPSBsb29rdXAuZ2V0Q29sb3IobW9kZWwsIHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgICAgIHZhciB0b3AgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgICAgIGlmICghKHRvcCBpbnN0YW5jZW9mIENvbG9yQXJyYXlJdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnVW5zdXBwb3J0ZWRUYWJsZUNvbG9yJywgJ1Vuc3VwcG9ydGVkIHVzZSBvZiAlMScsIHBhcnNlci5jdXJyZW50Q1MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29sJykge1xuICAgICAgICAgICAgaWYgKHRvcC50YWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdDb2x1bW5Db2xvck5vdFRvcCcsICclMSBtdXN0IGJlIGluIHRoZSB0b3Agcm93JywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AuY29sb3IuY29sW3RvcC5yb3cubGVuZ3RoXSA9IGNvbG9yO1xuICAgICAgICAgICAgaWYgKHBhcnNlci5HZXRCcmFja2V0cyhuYW1lLCAnJykpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9wLmNvbG9yW3R5cGVdID0gY29sb3I7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JvdycgJiYgKHRvcC5TaXplKCkgfHwgdG9wLnJvdy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnUm93Q29sb3JOb3RGaXJzdCcsICclMSBtdXN0IGJlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSByb3cnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xudmFyIGNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIGpheCkge1xuICAgIGlmICghamF4LnBhcnNlT3B0aW9ucy5wYWNrYWdlRGF0YS5oYXMoJ2NvbG9yJykpIHtcbiAgICAgICAgQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb25IYW5kbGVyLmdldCgnY29sb3InKS5jb25maWcoY29uZmlnLCBqYXgpO1xuICAgIH1cbn07XG5leHBvcnRzLkNvbG9ydGJsQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnY29sb3J0YmwnLCB7XG4gICAgaGFuZGxlcjogeyBtYWNybzogWydjb2xvcnRibCddIH0sXG4gICAgaXRlbXM6IHsgJ2FycmF5JzogQ29sb3JBcnJheUl0ZW0gfSxcbiAgICBwcmlvcml0eTogMTAsXG4gICAgY29uZmlnOiBbY29uZmlnLCAxMF1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3J0YmxDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xvckNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkNvbG9yVjJNZXRob2RzID0gdm9pZCAwO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbmV4cG9ydHMuQ29sb3JWMk1ldGhvZHMgPSB7XG4gICAgQ29sb3I6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgb2xkID0gcGFyc2VyLnN0YWNrLmVudlsnY29sb3InXTtcbiAgICAgICAgcGFyc2VyLnN0YWNrLmVudlsnY29sb3InXSA9IGNvbG9yO1xuICAgICAgICB2YXIgbWF0aCA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YWNrLmVudlsnY29sb3InXSA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJzZXIuc3RhY2suZW52Wydjb2xvciddO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtc3R5bGUnLCBbbWF0aF0sIHsgbWF0aGNvbG9yOiBjb2xvciB9KTtcbiAgICAgICAgcGFyc2VyLlB1c2gobm9kZSk7XG4gICAgfVxufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdjb2xvcnYyJywgeyBjb2xvcjogJ0NvbG9yJyB9LCBleHBvcnRzLkNvbG9yVjJNZXRob2RzKTtcbmV4cG9ydHMuQ29sb3JDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdjb2xvcnYyJywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ2NvbG9ydjInXSB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JWMkNvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbmZpZ01hY3Jvc0NvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgUGFyc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlTWV0aG9kcy5qc1wiKSk7XG52YXIgU3ltYm9sX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sLmpzXCIpO1xudmFyIE5ld2NvbW1hbmRNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL25ld2NvbW1hbmQvTmV3Y29tbWFuZE1ldGhvZHMuanNcIikpO1xudmFyIE5ld2NvbW1hbmRJdGVtc19qc18xID0gcmVxdWlyZShcIi4uL25ld2NvbW1hbmQvTmV3Y29tbWFuZEl0ZW1zLmpzXCIpO1xudmFyIE1BQ1JPU01BUCA9ICdjb25maWdtYWNyb3MtbWFwJztcbnZhciBFTlZJUk9OTUVOVE1BUCA9ICdjb25maWdtYWNyb3MtZW52LW1hcCc7XG5mdW5jdGlvbiBjb25maWdtYWNyb3NJbml0KGNvbmZpZykge1xuICAgIG5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKE1BQ1JPU01BUCwge30sIHt9KTtcbiAgICBuZXcgU3ltYm9sTWFwX2pzXzEuRW52aXJvbm1lbnRNYXAoRU5WSVJPTk1FTlRNQVAsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQuZW52aXJvbm1lbnQsIHt9LCB7fSk7XG4gICAgY29uZmlnLmFwcGVuZChDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5sb2NhbCh7XG4gICAgICAgIGhhbmRsZXI6IHtcbiAgICAgICAgICAgIG1hY3JvOiBbTUFDUk9TTUFQXSxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBbRU5WSVJPTk1FTlRNQVBdXG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiAzXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gY29uZmlnbWFjcm9zQ29uZmlnKF9jb25maWcsIGpheCkge1xuICAgIGNvbmZpZ01hY3JvcyhqYXgpO1xuICAgIGNvbmZpZ0Vudmlyb25tZW50cyhqYXgpO1xufVxuZnVuY3Rpb24gY29uZmlnTWFjcm9zKGpheCkge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBoYW5kbGVyID0gamF4LnBhcnNlT3B0aW9ucy5oYW5kbGVycy5yZXRyaWV2ZShNQUNST1NNQVApO1xuICAgIHZhciBtYWNyb3MgPSBqYXgucGFyc2VPcHRpb25zLm9wdGlvbnMubWFjcm9zO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMobWFjcm9zKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBjcyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGRlZiA9ICh0eXBlb2YgbWFjcm9zW2NzXSA9PT0gJ3N0cmluZycgPyBbbWFjcm9zW2NzXV0gOiBtYWNyb3NbY3NdKTtcbiAgICAgICAgICAgIHZhciBtYWNybyA9IEFycmF5LmlzQXJyYXkoZGVmWzJdKSA/XG4gICAgICAgICAgICAgICAgbmV3IFN5bWJvbF9qc18xLk1hY3JvKGNzLCBOZXdjb21tYW5kTWV0aG9kc19qc18xLmRlZmF1bHQuTWFjcm9XaXRoVGVtcGxhdGUsIGRlZi5zbGljZSgwLCAyKS5jb25jYXQoZGVmWzJdKSkgOlxuICAgICAgICAgICAgICAgIG5ldyBTeW1ib2xfanNfMS5NYWNybyhjcywgTmV3Y29tbWFuZE1ldGhvZHNfanNfMS5kZWZhdWx0Lk1hY3JvLCBkZWYpO1xuICAgICAgICAgICAgaGFuZGxlci5hZGQoY3MsIG1hY3JvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb25maWdFbnZpcm9ubWVudHMoamF4KSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgdmFyIGhhbmRsZXIgPSBqYXgucGFyc2VPcHRpb25zLmhhbmRsZXJzLnJldHJpZXZlKEVOVklST05NRU5UTUFQKTtcbiAgICB2YXIgZW52aXJvbm1lbnRzID0gamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLmVudmlyb25tZW50cztcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGVudmlyb25tZW50cykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgZW52ID0gX2MudmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVyLmFkZChlbnYsIG5ldyBTeW1ib2xfanNfMS5NYWNybyhlbnYsIE5ld2NvbW1hbmRNZXRob2RzX2pzXzEuZGVmYXVsdC5CZWdpbkVudiwgW3RydWVdLmNvbmNhdChlbnZpcm9ubWVudHNbZW52XSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG59XG5leHBvcnRzLkNvbmZpZ01hY3Jvc0NvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ2NvbmZpZ21hY3JvcycsIHtcbiAgICBpbml0OiBjb25maWdtYWNyb3NJbml0LFxuICAgIGNvbmZpZzogY29uZmlnbWFjcm9zQ29uZmlnLFxuICAgIGl0ZW1zOiAoX2EgPSB7fSxcbiAgICAgICAgX2FbTmV3Y29tbWFuZEl0ZW1zX2pzXzEuQmVnaW5FbnZJdGVtLnByb3RvdHlwZS5raW5kXSA9IE5ld2NvbW1hbmRJdGVtc19qc18xLkJlZ2luRW52SXRlbSxcbiAgICAgICAgX2EpLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgbWFjcm9zOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHt9KSxcbiAgICAgICAgZW52aXJvbm1lbnRzOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHt9KVxuICAgIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uZmlnTWFjcm9zQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVtcGhlcUNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkVtcGhlcU1ldGhvZHMgPSBleHBvcnRzLkVtcGhlcUJlZ2luSXRlbSA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4RXJyb3IuanNcIikpO1xudmFyIEJhc2VJdGVtc19qc18xID0gcmVxdWlyZShcIi4uL2Jhc2UvQmFzZUl0ZW1zLmpzXCIpO1xudmFyIEVtcGhlcVV0aWxfanNfMSA9IHJlcXVpcmUoXCIuL0VtcGhlcVV0aWwuanNcIik7XG52YXIgRW1waGVxQmVnaW5JdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1waGVxQmVnaW5JdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcGhlcUJlZ2luSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1waGVxQmVnaW5JdGVtLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VtcGhlcS1iZWdpbic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbXBoZXFCZWdpbkl0ZW0ucHJvdG90eXBlLmNoZWNrSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmlzS2luZCgnZW5kJykgJiYgaXRlbS5nZXROYW1lKCkgPT09IHRoaXMuZ2V0TmFtZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KCdlbmQnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY2hlY2tJdGVtLmNhbGwodGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICByZXR1cm4gRW1waGVxQmVnaW5JdGVtO1xufShCYXNlSXRlbXNfanNfMS5CZWdpbkl0ZW0pKTtcbmV4cG9ydHMuRW1waGVxQmVnaW5JdGVtID0gRW1waGVxQmVnaW5JdGVtO1xuZXhwb3J0cy5FbXBoZXFNZXRob2RzID0ge1xuICAgIEVtcGhlcTogZnVuY3Rpb24gKHBhcnNlciwgYmVnaW4pIHtcbiAgICAgICAgaWYgKHBhcnNlci5zdGFjay5lbnYuY2xvc2luZyA9PT0gYmVnaW4uZ2V0TmFtZSgpKSB7XG4gICAgICAgICAgICBkZWxldGUgcGFyc2VyLnN0YWNrLmVudi5jbG9zaW5nO1xuICAgICAgICAgICAgcGFyc2VyLlB1c2gocGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnZW5kJykuc2V0UHJvcGVydHkoJ25hbWUnLCBwYXJzZXIuc3RhY2suZ2xvYmFsLmVtcGhlcSkpO1xuICAgICAgICAgICAgcGFyc2VyLnN0YWNrLmdsb2JhbC5lbXBoZXEgPSAnJztcbiAgICAgICAgICAgIHZhciBlbXBoZXEgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgICAgICAgICBFbXBoZXFVdGlsX2pzXzEuRW1waGVxVXRpbC5hZGp1c3RUYWJsZShlbXBoZXEsIHBhcnNlcik7XG4gICAgICAgICAgICBwYXJzZXIuUHVzaChwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKCdlbmQnKS5zZXRQcm9wZXJ0eSgnbmFtZScsICdlbXBoZXEnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmNoZWNrRXFuRW52KHBhcnNlcik7XG4gICAgICAgICAgICBkZWxldGUgcGFyc2VyLnN0YWNrLmdsb2JhbC5lcW5lbnY7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHBhcnNlci5HZXRCcmFja2V0cygnXFxcXGJlZ2lueycgKyBiZWdpbi5nZXROYW1lKCkgKyAnfScpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKChwYXJzZXIuR2V0QXJndW1lbnQoJ1xcXFxiZWdpbnsnICsgYmVnaW4uZ2V0TmFtZSgpICsgJ30nKSB8fCAnJykuc3BsaXQoLz0vKSwgMiksIGVudiA9IF9hWzBdLCBuID0gX2FbMV07XG4gICAgICAgICAgICBpZiAoIUVtcGhlcVV0aWxfanNfMS5FbXBoZXFVdGlsLmNoZWNrRW52KGVudikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdVbmtub3duRW52JywgJ1Vua25vd24gZW52aXJvbm1lbnQgXCIlMVwiJywgZW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgYmVnaW4uc2V0UHJvcGVydGllcyhFbXBoZXFVdGlsX2pzXzEuRW1waGVxVXRpbC5zcGxpdE9wdGlvbnMob3B0cywgeyBsZWZ0OiAxLCByaWdodDogMSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuc3RhY2suZ2xvYmFsLmVtcGhlcSA9IGVudjtcbiAgICAgICAgICAgIHBhcnNlci5zdHJpbmcgPSAnXFxcXGJlZ2lueycgKyBlbnYgKyAnfScgKyAobiA/ICd7JyArIG4gKyAnfScgOiAnJykgKyBwYXJzZXIuc3RyaW5nLnNsaWNlKHBhcnNlci5pKTtcbiAgICAgICAgICAgIHBhcnNlci5pID0gMDtcbiAgICAgICAgICAgIHBhcnNlci5QdXNoKGJlZ2luKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgRW1waGVxTU86IGZ1bmN0aW9uIChwYXJzZXIsIF9uYW1lLCBjKSB7XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywge30sIGMpKTtcbiAgICB9LFxuICAgIEVtcGhlcURlbGltOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VyLkdldERlbGltaXRlcihuYW1lKTtcbiAgICAgICAgcGFyc2VyLlB1c2gocGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbW8nLCB7IHN0cmV0Y2h5OiB0cnVlLCBzeW1tZXRyaWM6IHRydWUgfSwgYykpO1xuICAgIH1cbn07XG5uZXcgU3ltYm9sTWFwX2pzXzEuRW52aXJvbm1lbnRNYXAoJ2VtcGhlcS1lbnYnLCBFbXBoZXFVdGlsX2pzXzEuRW1waGVxVXRpbC5lbnZpcm9ubWVudCwge1xuICAgIGVtcGhlcTogWydFbXBoZXEnLCAnZW1waGVxJ10sXG59LCBleHBvcnRzLkVtcGhlcU1ldGhvZHMpO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ2VtcGhlcS1tYWNyb3MnLCB7XG4gICAgZW1waGVxbGJyYWNlOiBbJ0VtcGhlcU1PJywgJ3snXSxcbiAgICBlbXBoZXFyYnJhY2U6IFsnRW1waGVxTU8nLCAnfSddLFxuICAgIGVtcGhlcWxicmFjazogWydFbXBoZXFNTycsICdbJ10sXG4gICAgZW1waGVxcmJyYWNrOiBbJ0VtcGhlcU1PJywgJ10nXSxcbiAgICBlbXBoZXFsYW5nbGU6IFsnRW1waGVxTU8nLCAnXFx1MjdFOCddLFxuICAgIGVtcGhlcXJhbmdsZTogWydFbXBoZXFNTycsICdcXHUyN0U5J10sXG4gICAgZW1waGVxbHBhcmVuOiBbJ0VtcGhlcU1PJywgJygnXSxcbiAgICBlbXBoZXFycGFyZW46IFsnRW1waGVxTU8nLCAnKSddLFxuICAgIGVtcGhlcWx2ZXJ0OiBbJ0VtcGhlcU1PJywgJ3wnXSxcbiAgICBlbXBoZXFydmVydDogWydFbXBoZXFNTycsICd8J10sXG4gICAgZW1waGVxbFZlcnQ6IFsnRW1waGVxTU8nLCAnXFx1MjAxNiddLFxuICAgIGVtcGhlcXJWZXJ0OiBbJ0VtcGhlcU1PJywgJ1xcdTIwMTYnXSxcbiAgICBlbXBoZXFsZmxvb3I6IFsnRW1waGVxTU8nLCAnXFx1MjMwQSddLFxuICAgIGVtcGhlcXJmbG9vcjogWydFbXBoZXFNTycsICdcXHUyMzBCJ10sXG4gICAgZW1waGVxbGNlaWw6IFsnRW1waGVxTU8nLCAnXFx1MjMwOCddLFxuICAgIGVtcGhlcXJjZWlsOiBbJ0VtcGhlcU1PJywgJ1xcdTIzMDknXSxcbiAgICBlbXBoZXFiaWdsYnJhY2U6IFsnRW1waGVxTU8nLCAneyddLFxuICAgIGVtcGhlcWJpZ3JicmFjZTogWydFbXBoZXFNTycsICd9J10sXG4gICAgZW1waGVxYmlnbGJyYWNrOiBbJ0VtcGhlcU1PJywgJ1snXSxcbiAgICBlbXBoZXFiaWdyYnJhY2s6IFsnRW1waGVxTU8nLCAnXSddLFxuICAgIGVtcGhlcWJpZ2xhbmdsZTogWydFbXBoZXFNTycsICdcXHUyN0U4J10sXG4gICAgZW1waGVxYmlncmFuZ2xlOiBbJ0VtcGhlcU1PJywgJ1xcdTI3RTknXSxcbiAgICBlbXBoZXFiaWdscGFyZW46IFsnRW1waGVxTU8nLCAnKCddLFxuICAgIGVtcGhlcWJpZ3JwYXJlbjogWydFbXBoZXFNTycsICcpJ10sXG4gICAgZW1waGVxYmlnbHZlcnQ6IFsnRW1waGVxTU8nLCAnfCddLFxuICAgIGVtcGhlcWJpZ3J2ZXJ0OiBbJ0VtcGhlcU1PJywgJ3wnXSxcbiAgICBlbXBoZXFiaWdsVmVydDogWydFbXBoZXFNTycsICdcXHUyMDE2J10sXG4gICAgZW1waGVxYmlnclZlcnQ6IFsnRW1waGVxTU8nLCAnXFx1MjAxNiddLFxuICAgIGVtcGhlcWJpZ2xmbG9vcjogWydFbXBoZXFNTycsICdcXHUyMzBBJ10sXG4gICAgZW1waGVxYmlncmZsb29yOiBbJ0VtcGhlcU1PJywgJ1xcdTIzMEInXSxcbiAgICBlbXBoZXFiaWdsY2VpbDogWydFbXBoZXFNTycsICdcXHUyMzA4J10sXG4gICAgZW1waGVxYmlncmNlaWw6IFsnRW1waGVxTU8nLCAnXFx1MjMwOSddLFxuICAgIGVtcGhlcWw6ICdFbXBoZXFEZWxpbScsXG4gICAgZW1waGVxcjogJ0VtcGhlcURlbGltJyxcbiAgICBlbXBoZXFiaWdsOiAnRW1waGVxRGVsaW0nLFxuICAgIGVtcGhlcWJpZ3I6ICdFbXBoZXFEZWxpbSdcbn0sIGV4cG9ydHMuRW1waGVxTWV0aG9kcyk7XG5leHBvcnRzLkVtcGhlcUNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ2VtcGhlcScsIHtcbiAgICBoYW5kbGVyOiB7XG4gICAgICAgIG1hY3JvOiBbJ2VtcGhlcS1tYWNyb3MnXSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IFsnZW1waGVxLWVudiddLFxuICAgIH0sXG4gICAgaXRlbXM6IChfYSA9IHt9LFxuICAgICAgICBfYVtFbXBoZXFCZWdpbkl0ZW0ucHJvdG90eXBlLmtpbmRdID0gRW1waGVxQmVnaW5JdGVtLFxuICAgICAgICBfYSlcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1waGVxQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1waGVxVXRpbCA9IHZvaWQgMDtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBUZXhQYXJzZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4UGFyc2VyLmpzXCIpKTtcbmV4cG9ydHMuRW1waGVxVXRpbCA9IHtcbiAgICBlbnZpcm9ubWVudDogZnVuY3Rpb24gKHBhcnNlciwgZW52LCBmdW5jLCBhcmdzKSB7XG4gICAgICAgIHZhciBuYW1lID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGl0ZW0gPSBwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKG5hbWUgKyAnLWJlZ2luJykuc2V0UHJvcGVydGllcyh7IG5hbWU6IGVudiwgZW5kOiBuYW1lIH0pO1xuICAgICAgICBwYXJzZXIuUHVzaChmdW5jLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbcGFyc2VyLCBpdGVtXSwgX19yZWFkKGFyZ3Muc2xpY2UoMSkpLCBmYWxzZSkpKTtcbiAgICB9LFxuICAgIHNwbGl0T3B0aW9uczogZnVuY3Rpb24gKHRleHQsIGFsbG93ZWQpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQgPT09IHZvaWQgMCkgeyBhbGxvd2VkID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5rZXl2YWxPcHRpb25zKHRleHQsIGFsbG93ZWQsIHRydWUpO1xuICAgIH0sXG4gICAgY29sdW1uQ291bnQ6IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIG0gPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0YWJsZS5jaGlsZE5vZGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHJvdy5jaGlsZE5vZGVzLmxlbmd0aCAtIChyb3cuaXNLaW5kKCdtbGFiZWxlZHRyJykgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPiBtKVxuICAgICAgICAgICAgICAgICAgICBtID0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgY2VsbEJsb2NrOiBmdW5jdGlvbiAodGV4LCB0YWJsZSwgcGFyc2VyLCBlbnYpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBtcGFkZGVkID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW10sIHsgaGVpZ2h0OiAwLCBkZXB0aDogMCwgdm9mZnNldDogJy0xaGVpZ2h0JyB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KHRleCwgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB2YXIgbW1sID0gcmVzdWx0Lm1tbCgpO1xuICAgICAgICBpZiAoZW52ICYmIHJlc3VsdC5jb25maWd1cmF0aW9uLnRhZ3MubGFiZWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb25maWd1cmF0aW9uLnRhZ3MuY3VycmVudFRhZy5lbnYgPSBlbnY7XG4gICAgICAgICAgICByZXN1bHQuY29uZmlndXJhdGlvbi50YWdzLmdldFRhZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcygobW1sLmlzSW5mZXJyZWQgPyBtbWwuY2hpbGROb2RlcyA6IFttbWxdKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBtcGFkZGVkLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIG1wYWRkZWQuYXBwZW5kQ2hpbGQocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGhhbnRvbScsIFtcbiAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFt0YWJsZV0sIHsgd2lkdGg6IDAgfSlcbiAgICAgICAgXSkpO1xuICAgICAgICByZXR1cm4gbXBhZGRlZDtcbiAgICB9LFxuICAgIHRvcFJvd1RhYmxlOiBmdW5jdGlvbiAob3JpZ2luYWwsIHBhcnNlcikge1xuICAgICAgICB2YXIgdGFibGUgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmNvcHlOb2RlKG9yaWdpbmFsLCBwYXJzZXIpO1xuICAgICAgICB0YWJsZS5zZXRDaGlsZHJlbih0YWJsZS5jaGlsZE5vZGVzLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgdGFibGUuYXR0cmlidXRlcy5zZXQoJ2FsaWduJywgJ2Jhc2VsaW5lIDEnKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmZhY3RvcnkuY3JlYXRlKCdtcGhhbnRvbScsIHt9LCBbcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW3RhYmxlXSwgeyB3aWR0aDogMCB9KV0pO1xuICAgIH0sXG4gICAgcm93c3BhbkNlbGw6IGZ1bmN0aW9uIChtdGQsIHRleCwgdGFibGUsIHBhcnNlciwgZW52KSB7XG4gICAgICAgIG10ZC5hcHBlbmRDaGlsZChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21wYWRkZWQnLCBbXG4gICAgICAgICAgICB0aGlzLmNlbGxCbG9jayh0ZXgsIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuY29weU5vZGUodGFibGUsIHBhcnNlciksIHBhcnNlciwgZW52KSxcbiAgICAgICAgICAgIHRoaXMudG9wUm93VGFibGUodGFibGUsIHBhcnNlcilcbiAgICAgICAgXSwgeyBoZWlnaHQ6IDAsIGRlcHRoOiAwLCB2b2Zmc2V0OiAnaGVpZ2h0JyB9KSk7XG4gICAgfSxcbiAgICBsZWZ0OiBmdW5jdGlvbiAodGFibGUsIG9yaWdpbmFsLCBsZWZ0LCBwYXJzZXIsIGVudikge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgaWYgKGVudiA9PT0gdm9pZCAwKSB7IGVudiA9ICcnOyB9XG4gICAgICAgIHRhYmxlLmF0dHJpYnV0ZXMuc2V0KCdjb2x1bW5hbGlnbicsICdyaWdodCAnICsgKHRhYmxlLmF0dHJpYnV0ZXMuZ2V0KCdjb2x1bW5hbGlnbicpIHx8ICcnKSk7XG4gICAgICAgIHRhYmxlLmF0dHJpYnV0ZXMuc2V0KCdjb2x1bW5zcGFjaW5nJywgJzBlbSAnICsgKHRhYmxlLmF0dHJpYnV0ZXMuZ2V0KCdjb2x1bW5zcGFjaW5nJykgfHwgJycpKTtcbiAgICAgICAgdmFyIG10ZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGFibGUuY2hpbGROb2Rlcy5zbGljZSgwKS5yZXZlcnNlKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIG10ZCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRkJyk7XG4gICAgICAgICAgICAgICAgcm93LmNoaWxkTm9kZXMudW5zaGlmdChtdGQpO1xuICAgICAgICAgICAgICAgIG10ZC5wYXJlbnQgPSByb3c7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5pc0tpbmQoJ21sYWJlbGVkdHInKSkge1xuICAgICAgICAgICAgICAgICAgICByb3cuY2hpbGROb2Rlc1swXSA9IHJvdy5jaGlsZE5vZGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICByb3cuY2hpbGROb2Rlc1sxXSA9IG10ZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd3NwYW5DZWxsKG10ZCwgbGVmdCwgb3JpZ2luYWwsIHBhcnNlciwgZW52KTtcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbiAodGFibGUsIG9yaWdpbmFsLCByaWdodCwgcGFyc2VyLCBlbnYpIHtcbiAgICAgICAgaWYgKGVudiA9PT0gdm9pZCAwKSB7IGVudiA9ICcnOyB9XG4gICAgICAgIGlmICh0YWJsZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdHInKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSBleHBvcnRzLkVtcGhlcVV0aWwuY29sdW1uQ291bnQodGFibGUpO1xuICAgICAgICB2YXIgcm93ID0gdGFibGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgd2hpbGUgKHJvdy5jaGlsZE5vZGVzLmxlbmd0aCA8IG0pXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdGQnKSk7XG4gICAgICAgIHZhciBtdGQgPSByb3cuYXBwZW5kQ2hpbGQocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdGQnKSk7XG4gICAgICAgIGV4cG9ydHMuRW1waGVxVXRpbC5yb3dzcGFuQ2VsbChtdGQsIHJpZ2h0LCBvcmlnaW5hbCwgcGFyc2VyLCBlbnYpO1xuICAgICAgICB0YWJsZS5hdHRyaWJ1dGVzLnNldCgnY29sdW1uYWxpZ24nLCAodGFibGUuYXR0cmlidXRlcy5nZXQoJ2NvbHVtbmFsaWduJykgfHwgJycpLnNwbGl0KC8gLykuc2xpY2UoMCwgbSkuam9pbignICcpICsgJyBsZWZ0Jyk7XG4gICAgICAgIHRhYmxlLmF0dHJpYnV0ZXMuc2V0KCdjb2x1bW5zcGFjaW5nJywgKHRhYmxlLmF0dHJpYnV0ZXMuZ2V0KCdjb2x1bW5zcGFjaW5nJykgfHwgJycpLnNwbGl0KC8gLykuc2xpY2UoMCwgbSAtIDEpLmpvaW4oJyAnKSArICcgMGVtJyk7XG4gICAgfSxcbiAgICBhZGp1c3RUYWJsZTogZnVuY3Rpb24gKGVtcGhlcSwgcGFyc2VyKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gZW1waGVxLmdldFByb3BlcnR5KCdsZWZ0Jyk7XG4gICAgICAgIHZhciByaWdodCA9IGVtcGhlcS5nZXRQcm9wZXJ0eSgncmlnaHQnKTtcbiAgICAgICAgaWYgKGxlZnQgfHwgcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IGVtcGhlcS5MYXN0O1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jb3B5Tm9kZSh0YWJsZSwgcGFyc2VyKTtcbiAgICAgICAgICAgIGlmIChsZWZ0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdCh0YWJsZSwgb3JpZ2luYWwsIGxlZnQsIHBhcnNlcik7XG4gICAgICAgICAgICBpZiAocmlnaHQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCh0YWJsZSwgb3JpZ2luYWwsIHJpZ2h0LCBwYXJzZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhbGxvd0Vudjoge1xuICAgICAgICBlcXVhdGlvbjogdHJ1ZSxcbiAgICAgICAgYWxpZ246IHRydWUsXG4gICAgICAgIGdhdGhlcjogdHJ1ZSxcbiAgICAgICAgZmxhbGlnbjogdHJ1ZSxcbiAgICAgICAgYWxpZ25hdDogdHJ1ZSxcbiAgICAgICAgbXVsdGxpbmU6IHRydWVcbiAgICB9LFxuICAgIGNoZWNrRW52OiBmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbG93RW52Lmhhc093blByb3BlcnR5KGVudi5yZXBsYWNlKC9cXCokLywgJycpKSB8fCBmYWxzZTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1waGVxVXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5jbG9zZUNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLkVuY2xvc2VNZXRob2RzID0gZXhwb3J0cy5FTkNMT1NFX09QVElPTlMgPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgU3ltYm9sTWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xuZXhwb3J0cy5FTkNMT1NFX09QVElPTlMgPSB7XG4gICAgJ2RhdGEtYXJyb3doZWFkJzogMSxcbiAgICBjb2xvcjogMSxcbiAgICBtYXRoY29sb3I6IDEsXG4gICAgYmFja2dyb3VuZDogMSxcbiAgICBtYXRoYmFja2dyb3VuZDogMSxcbiAgICAnZGF0YS1wYWRkaW5nJzogMSxcbiAgICAnZGF0YS10aGlja25lc3MnOiAxXG59O1xuZXhwb3J0cy5FbmNsb3NlTWV0aG9kcyA9IHt9O1xuZXhwb3J0cy5FbmNsb3NlTWV0aG9kcy5FbmNsb3NlID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBub3RhdGlvbiA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKS5yZXBsYWNlKC8sL2csICcgJyk7XG4gICAgdmFyIGF0dHIgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgIHZhciBtYXRoID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgIHZhciBkZWYgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmtleXZhbE9wdGlvbnMoYXR0ciwgZXhwb3J0cy5FTkNMT1NFX09QVElPTlMpO1xuICAgIGRlZi5ub3RhdGlvbiA9IG5vdGF0aW9uO1xuICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbWVuY2xvc2UnLCBbbWF0aF0sIGRlZikpO1xufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdlbmNsb3NlJywgeyBlbmNsb3NlOiAnRW5jbG9zZScgfSwgZXhwb3J0cy5FbmNsb3NlTWV0aG9kcyk7XG5leHBvcnRzLkVuY2xvc2VDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdlbmNsb3NlJywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ2VuY2xvc2UnXSB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5jbG9zZUNvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4dHBmZWlsQ29uZmlndXJhdGlvbiA9IGV4cG9ydHMuRXh0cGZlaWxNZXRob2RzID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBBbXNNZXRob2RzX2pzXzEgPSByZXF1aXJlKFwiLi4vYW1zL0Ftc01ldGhvZHMuanNcIik7XG52YXIgTmV3Y29tbWFuZFV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbmV3Y29tbWFuZC9OZXdjb21tYW5kVXRpbC5qc1wiKSk7XG52YXIgTmV3Y29tbWFuZENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9uZXdjb21tYW5kL05ld2NvbW1hbmRDb25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbmV4cG9ydHMuRXh0cGZlaWxNZXRob2RzID0ge307XG5leHBvcnRzLkV4dHBmZWlsTWV0aG9kcy54QXJyb3cgPSBBbXNNZXRob2RzX2pzXzEuQW1zTWV0aG9kcy54QXJyb3c7XG5leHBvcnRzLkV4dHBmZWlsTWV0aG9kcy5OZXdFeHRBcnJvdyA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgY3MgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIHNwYWNlID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBjaHIgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgaWYgKCFjcy5tYXRjaCgvXlxcXFwoW2Etel0rfC4pJC9pKSkge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdOZXdleHRhcnJvd0FyZzEnLCAnRmlyc3QgYXJndW1lbnQgdG8gJTEgbXVzdCBiZSBhIGNvbnRyb2wgc2VxdWVuY2UgbmFtZScsIG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIXNwYWNlLm1hdGNoKC9eKFxcZCspLChcXGQrKSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdOZXdleHRhcnJvd0FyZzInLCAnU2Vjb25kIGFyZ3VtZW50IHRvICUxIG11c3QgYmUgdHdvIGludGVnZXJzIHNlcGFyYXRlZCBieSBhIGNvbW1hJywgbmFtZSk7XG4gICAgfVxuICAgIGlmICghY2hyLm1hdGNoKC9eKFxcZCt8MHhbMC05QS1GXSspJC9pKSkge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdOZXdleHRhcnJvd0FyZzMnLCAnVGhpcmQgYXJndW1lbnQgdG8gJTEgbXVzdCBiZSBhIHVuaWNvZGUgY2hhcmFjdGVyIG51bWJlcicsIG5hbWUpO1xuICAgIH1cbiAgICBjcyA9IGNzLnN1YnN0cigxKTtcbiAgICB2YXIgc3BhY2VzID0gc3BhY2Uuc3BsaXQoJywnKTtcbiAgICBOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuYWRkTWFjcm8ocGFyc2VyLCBjcywgZXhwb3J0cy5FeHRwZmVpbE1ldGhvZHMueEFycm93LCBbcGFyc2VJbnQoY2hyKSwgcGFyc2VJbnQoc3BhY2VzWzBdKSwgcGFyc2VJbnQoc3BhY2VzWzFdKV0pO1xufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdleHRwZmVpbCcsIHtcbiAgICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFsneEFycm93JywgMHgyMUEwLCAxMiwgMTZdLFxuICAgIHh0d29oZWFkbGVmdGFycm93OiBbJ3hBcnJvdycsIDB4MjE5RSwgMTcsIDEzXSxcbiAgICB4bWFwc3RvOiBbJ3hBcnJvdycsIDB4MjFBNiwgNiwgN10sXG4gICAgeGxvbmdlcXVhbDogWyd4QXJyb3cnLCAweDAwM0QsIDcsIDddLFxuICAgIHh0b2Zyb206IFsneEFycm93JywgMHgyMUM0LCAxMiwgMTJdLFxuICAgIE5ld2V4dGFycm93OiAnTmV3RXh0QXJyb3cnXG59LCBleHBvcnRzLkV4dHBmZWlsTWV0aG9kcyk7XG52YXIgaW5pdCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBOZXdjb21tYW5kQ29uZmlndXJhdGlvbl9qc18xLk5ld2NvbW1hbmRDb25maWd1cmF0aW9uLmluaXQoY29uZmlnKTtcbn07XG5leHBvcnRzLkV4dHBmZWlsQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnZXh0cGZlaWwnLCB7XG4gICAgaGFuZGxlcjogeyBtYWNybzogWydleHRwZmVpbCddIH0sXG4gICAgaW5pdDogaW5pdFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRwZmVpbENvbmZpZ3VyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdlbnN5bWJDb25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFRleENvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4uL1RleENvbnN0YW50cy5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG5mdW5jdGlvbiBtYXRoY2hhclVuaXQocGFyc2VyLCBtY2hhcikge1xuICAgIHZhciBkZWYgPSBtY2hhci5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGRlZi5tYXRodmFyaWFudCA9IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuTk9STUFMO1xuICAgIGRlZi5jbGFzcyA9ICdNYXRoTUwtVW5pdCc7XG4gICAgdmFyIG5vZGUgPSBwYXJzZXIuY3JlYXRlKCd0b2tlbicsICdtaScsIGRlZiwgbWNoYXIuY2hhcik7XG4gICAgcGFyc2VyLlB1c2gobm9kZSk7XG59XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ2hhcmFjdGVyTWFwKCdnZW5zeW1iLXN5bWJvbHMnLCBtYXRoY2hhclVuaXQsIHtcbiAgICBvaG06ICdcXHUyMTI2JyxcbiAgICBkZWdyZWU6ICdcXHUwMEIwJyxcbiAgICBjZWxzaXVzOiAnXFx1MjEwMycsXG4gICAgcGVydGhvdXNhbmQ6ICdcXHUyMDMwJyxcbiAgICBtaWNybzogJ1xcdTAwQjUnXG59KTtcbmV4cG9ydHMuR2Vuc3ltYkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ2dlbnN5bWInLCB7XG4gICAgaGFuZGxlcjogeyBtYWNybzogWydnZW5zeW1iLXN5bWJvbHMnXSB9LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5zeW1iQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHRtbENvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgU3ltYm9sTWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpO1xudmFyIEh0bWxNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vSHRtbE1ldGhvZHMuanNcIikpO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ2h0bWxfbWFjcm9zJywge1xuICAgIGhyZWY6ICdIcmVmJyxcbiAgICAnY2xhc3MnOiAnQ2xhc3MnLFxuICAgIHN0eWxlOiAnU3R5bGUnLFxuICAgIGNzc0lkOiAnSWQnXG59LCBIdG1sTWV0aG9kc19qc18xLmRlZmF1bHQpO1xuZXhwb3J0cy5IdG1sQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnaHRtbCcsIHsgaGFuZGxlcjogeyBtYWNybzogWydodG1sX21hY3JvcyddIH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdG1sQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgSHRtbE1ldGhvZHMgPSB7fTtcbkh0bWxNZXRob2RzLkhyZWYgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHVybCA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgYXJnID0gR2V0QXJndW1lbnRNTUwocGFyc2VyLCBuYW1lKTtcbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKGFyZywgJ2hyZWYnLCB1cmwpO1xuICAgIHBhcnNlci5QdXNoKGFyZyk7XG59O1xuSHRtbE1ldGhvZHMuQ2xhc3MgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIENMQVNTID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmcgPSBHZXRBcmd1bWVudE1NTChwYXJzZXIsIG5hbWUpO1xuICAgIHZhciBvbGRDbGFzcyA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRBdHRyaWJ1dGUoYXJnLCAnY2xhc3MnKTtcbiAgICBpZiAob2xkQ2xhc3MpIHtcbiAgICAgICAgQ0xBU1MgPSBvbGRDbGFzcyArICcgJyArIENMQVNTO1xuICAgIH1cbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKGFyZywgJ2NsYXNzJywgQ0xBU1MpO1xuICAgIHBhcnNlci5QdXNoKGFyZyk7XG59O1xuSHRtbE1ldGhvZHMuU3R5bGUgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmcgPSBHZXRBcmd1bWVudE1NTChwYXJzZXIsIG5hbWUpO1xuICAgIHZhciBvbGRTdHlsZSA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRBdHRyaWJ1dGUoYXJnLCAnc3R5bGUnKTtcbiAgICBpZiAob2xkU3R5bGUpIHtcbiAgICAgICAgaWYgKHN0eWxlLmNoYXJBdChzdHlsZS5sZW5ndGggLSAxKSAhPT0gJzsnKSB7XG4gICAgICAgICAgICBzdHlsZSArPSAnOyc7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUgPSBvbGRTdHlsZSArICcgJyArIHN0eWxlO1xuICAgIH1cbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKGFyZywgJ3N0eWxlJywgc3R5bGUpO1xuICAgIHBhcnNlci5QdXNoKGFyZyk7XG59O1xuSHRtbE1ldGhvZHMuSWQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIElEID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmcgPSBHZXRBcmd1bWVudE1NTChwYXJzZXIsIG5hbWUpO1xuICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUoYXJnLCAnaWQnLCBJRCk7XG4gICAgcGFyc2VyLlB1c2goYXJnKTtcbn07XG52YXIgR2V0QXJndW1lbnRNTUwgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGFyZyA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICBpZiAoIU5vZGVVdGlsX2pzXzEuZGVmYXVsdC5pc0luZmVycmVkKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKGFyZyk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIHZhciBtcm93ID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcm93Jyk7XG4gICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmNvcHlDaGlsZHJlbihhcmcsIG1yb3cpO1xuICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5jb3B5QXR0cmlidXRlcyhhcmcsIG1yb3cpO1xuICAgIHJldHVybiBtcm93O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEh0bWxNZXRob2RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHRtbE1ldGhvZHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hdGh0b29sc0NvbmZpZ3VyYXRpb24gPSBleHBvcnRzLmZpeFByZXNjcmlwdHMgPSBleHBvcnRzLlBBSVJFRERFTElNUyA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vTm9kZVV0aWwuanNcIikpO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL09wdGlvbnMuanNcIik7XG5yZXF1aXJlKFwiLi9NYXRodG9vbHNNYXBwaW5ncy5qc1wiKTtcbnZhciBNYXRodG9vbHNVdGlsX2pzXzEgPSByZXF1aXJlKFwiLi9NYXRodG9vbHNVdGlsLmpzXCIpO1xudmFyIE1hdGh0b29sc1RhZ3NfanNfMSA9IHJlcXVpcmUoXCIuL01hdGh0b29sc1RhZ3MuanNcIik7XG52YXIgTWF0aHRvb2xzSXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuL01hdGh0b29sc0l0ZW1zLmpzXCIpO1xuZXhwb3J0cy5QQUlSRURERUxJTVMgPSAnbWF0aHRvb2xzLXBhaXJlZC1kZWxpbXMnO1xuZnVuY3Rpb24gaW5pdE1hdGh0b29scyhjb25maWcpIHtcbiAgICBuZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcChleHBvcnRzLlBBSVJFRERFTElNUywge30sIHt9KTtcbiAgICBjb25maWcuYXBwZW5kKENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmxvY2FsKHsgaGFuZGxlcjogeyBtYWNybzogW2V4cG9ydHMuUEFJUkVEREVMSU1TXSB9LCBwcmlvcml0eTogLTUgfSkpO1xufVxuZnVuY3Rpb24gY29uZmlnTWF0aHRvb2xzKGNvbmZpZywgamF4KSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIHBhcnNlciA9IGpheC5wYXJzZU9wdGlvbnM7XG4gICAgdmFyIHBhaXJlZERlbGltcyA9IHBhcnNlci5vcHRpb25zLm1hdGh0b29scy5wYWlyZWREZWxpbWl0ZXJzO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMocGFpcmVkRGVsaW1zKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBjcyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgTWF0aHRvb2xzVXRpbF9qc18xLk1hdGh0b29sc1V0aWwuYWRkUGFpcmVkRGVsaW1zKHBhcnNlciwgY3MsIHBhaXJlZERlbGltc1tjc10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICAoMCwgTWF0aHRvb2xzVGFnc19qc18xLk1hdGh0b29sc1RhZ0Zvcm1hdCkoY29uZmlnLCBqYXgpO1xufVxuZnVuY3Rpb24gZml4UHJlc2NyaXB0cyhfYSkge1xuICAgIHZhciBlXzIsIF9iLCBlXzMsIF9jLCBlXzQsIF9kO1xuICAgIHZhciBkYXRhID0gX2EuZGF0YTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKGRhdGEuZ2V0TGlzdCgnbW11bHRpc2NyaXB0cycpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZS5nZXRQcm9wZXJ0eSgnZml4UHJlc2NyaXB0JykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbihub2RlKTtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2cgPSAoZV8zID0gdm9pZCAwLCBfX3ZhbHVlcyhbMSwgMl0pKSwgX2ggPSBfZy5uZXh0KCk7ICFfaC5kb25lOyBfaCA9IF9nLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IF9oLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRDaGlsZChub2RlLCBpLCBkYXRhLm5vZGVGYWN0b3J5LmNyZWF0ZSgnbm9kZScsICdub25lJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaCAmJiAhX2guZG9uZSAmJiAoX2MgPSBfZy5yZXR1cm4pKSBfYy5jYWxsKF9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IChlXzQgPSB2b2lkIDAsIF9fdmFsdWVzKFs0LCA1XSkpLCBfayA9IF9qLm5leHQoKTsgIV9rLmRvbmU7IF9rID0gX2oubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gX2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKGNoaWxkTm9kZXNbaV0sICdtcm93JykgJiYgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKGNoaWxkTm9kZXNbaV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldENoaWxkKG5vZGUsIGksIGRhdGEubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ25vbmUnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9rICYmICFfay5kb25lICYmIChfZCA9IF9qLnJldHVybikpIF9kLmNhbGwoX2opO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMuc3BsaWNlKDEsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbn1cbmV4cG9ydHMuZml4UHJlc2NyaXB0cyA9IGZpeFByZXNjcmlwdHM7XG5leHBvcnRzLk1hdGh0b29sc0NvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ21hdGh0b29scycsIHtcbiAgICBoYW5kbGVyOiB7XG4gICAgICAgIG1hY3JvOiBbJ21hdGh0b29scy1tYWNyb3MnLCAnbWF0aHRvb2xzLWRlbGltaXRlcnMnXSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IFsnbWF0aHRvb2xzLWVudmlyb25tZW50cyddLFxuICAgICAgICBkZWxpbWl0ZXI6IFsnbWF0aHRvb2xzLWRlbGltaXRlcnMnXSxcbiAgICAgICAgY2hhcmFjdGVyOiBbJ21hdGh0b29scy1jaGFyYWN0ZXJzJ11cbiAgICB9LFxuICAgIGl0ZW1zOiAoX2EgPSB7fSxcbiAgICAgICAgX2FbTWF0aHRvb2xzSXRlbXNfanNfMS5NdWx0bGluZWRJdGVtLnByb3RvdHlwZS5raW5kXSA9IE1hdGh0b29sc0l0ZW1zX2pzXzEuTXVsdGxpbmVkSXRlbSxcbiAgICAgICAgX2EpLFxuICAgIGluaXQ6IGluaXRNYXRodG9vbHMsXG4gICAgY29uZmlnOiBjb25maWdNYXRodG9vbHMsXG4gICAgcG9zdHByb2Nlc3NvcnM6IFtbZml4UHJlc2NyaXB0cywgLTZdXSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIG1hdGh0b29sczoge1xuICAgICAgICAgICAgJ211bHRsaW5lZ2FwJzogJzFlbScsXG4gICAgICAgICAgICAnbXVsdGxpbmVkLXBvcyc6ICdjJyxcbiAgICAgICAgICAgICdmaXJzdGxpbmUtYWZ0ZXJza2lwJzogJycsXG4gICAgICAgICAgICAnbGFzdGxpbmUtcHJlc2tpcCc6ICcnLFxuICAgICAgICAgICAgJ3NtYWxsbWF0cml4LWFsaWduJzogJ2MnLFxuICAgICAgICAgICAgJ3Nob3J0dmRvdHNhZGp1c3RhYm92ZSc6ICcuMmVtJyxcbiAgICAgICAgICAgICdzaG9ydHZkb3RzYWRqdXN0YmVsb3cnOiAnLjJlbScsXG4gICAgICAgICAgICAnY2VudGVyY29sb24nOiBmYWxzZSxcbiAgICAgICAgICAgICdjZW50ZXJjb2xvbi1vZmZzZXQnOiAnLjA0ZW0nLFxuICAgICAgICAgICAgJ3RoaW5jb2xvbi1keCc6ICctLjA0ZW0nLFxuICAgICAgICAgICAgJ3RoaW5jb2xvbi1kdyc6ICctLjA4ZW0nLFxuICAgICAgICAgICAgJ3VzZS11bmljb2RlJzogZmFsc2UsXG4gICAgICAgICAgICAncHJlc2NyaXB0LXN1Yi1mb3JtYXQnOiAnJyxcbiAgICAgICAgICAgICdwcmVzY3JpcHQtc3VwLWZvcm1hdCc6ICcnLFxuICAgICAgICAgICAgJ3ByZXNjcmlwdC1hcmctZm9ybWF0JzogJycsXG4gICAgICAgICAgICAnYWxsb3ctbWF0aHRvb2xzc2V0JzogdHJ1ZSxcbiAgICAgICAgICAgIHBhaXJlZERlbGltaXRlcnM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoe30pLFxuICAgICAgICAgICAgdGFnZm9ybXM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoe30pLFxuICAgICAgICB9XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRodG9vbHNDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGxpbmVkSXRlbSA9IHZvaWQgMDtcbnZhciBBbXNJdGVtc19qc18xID0gcmVxdWlyZShcIi4uL2Ftcy9BbXNJdGVtcy5qc1wiKTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgVGV4Q29uc3RhbnRzX2pzXzEgPSByZXF1aXJlKFwiLi4vVGV4Q29uc3RhbnRzLmpzXCIpO1xudmFyIE11bHRsaW5lZEl0ZW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0bGluZWRJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRsaW5lZEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE11bHRsaW5lZEl0ZW0ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbXVsdGxpbmVkJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE11bHRsaW5lZEl0ZW0ucHJvdG90eXBlLkVuZFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5TaXplKCkgfHwgdGhpcy5yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLkVuZEVudHJ5KCk7XG4gICAgICAgICAgICB0aGlzLkVuZFJvdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRhYmxlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5mYWN0b3J5LmNvbmZpZ3VyYXRpb24ub3B0aW9ucy5tYXRodG9vbHM7XG4gICAgICAgICAgICB2YXIgZ2FwID0gb3B0aW9ucy5tdWx0bGluZWdhcDtcbiAgICAgICAgICAgIHZhciBmaXJzdHNraXAgPSBvcHRpb25zWydmaXJzdGxpbmUtYWZ0ZXJza2lwJ10gfHwgZ2FwO1xuICAgICAgICAgICAgdmFyIGxhc3Rza2lwID0gb3B0aW9uc1snbGFzdGxpbmUtcHJlc2tpcCddIHx8IGdhcDtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbih0aGlzLnRhYmxlWzBdKVswXTtcbiAgICAgICAgICAgIGlmIChOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0QXR0cmlidXRlKGZpcnN0LCAnY29sdW1uYWxpZ24nKSAhPT0gVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuQWxpZ24uUklHSFQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZSgnbm9kZScsICdtc3BhY2UnLCBbXSwgeyB3aWR0aDogZmlyc3Rza2lwIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0ID0gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKHRoaXMudGFibGVbdGhpcy50YWJsZS5sZW5ndGggLSAxXSlbMF07XG4gICAgICAgICAgICBpZiAoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldEF0dHJpYnV0ZShsYXN0LCAnY29sdW1uYWxpZ24nKSAhPT0gVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuQWxpZ24uTEVGVCkge1xuICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbihsYXN0KVswXTtcbiAgICAgICAgICAgICAgICB0b3BfMS5jaGlsZE5vZGVzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlID0gdGhpcy5jcmVhdGUoJ25vZGUnLCAnbXNwYWNlJywgW10sIHsgd2lkdGg6IGxhc3Rza2lwIH0pO1xuICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRDaGlsZCh0b3BfMSwgMCwgc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuRW5kVGFibGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0bGluZWRJdGVtO1xufShBbXNJdGVtc19qc18xLk11bHRsaW5lSXRlbSkpO1xuZXhwb3J0cy5NdWx0bGluZWRJdGVtID0gTXVsdGxpbmVkSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdGh0b29sc0l0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhcnNlTWV0aG9kc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZU1ldGhvZHMuanNcIikpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBUZXhDb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuLi9UZXhDb25zdGFudHMuanNcIik7XG52YXIgTWF0aHRvb2xzTWV0aG9kc19qc18xID0gcmVxdWlyZShcIi4vTWF0aHRvb2xzTWV0aG9kcy5qc1wiKTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdtYXRodG9vbHMtbWFjcm9zJywge1xuICAgIHNob3ZlbGVmdDogWydIYW5kbGVTaG92ZScsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LkFsaWduLkxFRlRdLFxuICAgIHNob3ZlcmlnaHQ6IFsnSGFuZGxlU2hvdmUnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5BbGlnbi5SSUdIVF0sXG4gICAgeGxlZnRyaWdodGFycm93OiBbJ3hBcnJvdycsIDB4MjE5NCwgMTAsIDEwXSxcbiAgICB4TGVmdGFycm93OiBbJ3hBcnJvdycsIDB4MjFEMCwgMTIsIDddLFxuICAgIHhSaWdodGFycm93OiBbJ3hBcnJvdycsIDB4MjFEMiwgNywgMTJdLFxuICAgIHhMZWZ0cmlnaHRhcnJvdzogWyd4QXJyb3cnLCAweDIxRDQsIDEyLCAxMl0sXG4gICAgeGhvb2tsZWZ0YXJyb3c6IFsneEFycm93JywgMHgyMUE5LCAxMCwgNV0sXG4gICAgeGhvb2tyaWdodGFycm93OiBbJ3hBcnJvdycsIDB4MjFBQSwgNSwgMTBdLFxuICAgIHhtYXBzdG86IFsneEFycm93JywgMHgyMUE2LCAxMCwgMTBdLFxuICAgIHhyaWdodGhhcnBvb25kb3duOiBbJ3hBcnJvdycsIDB4MjFDMSwgNSwgMTBdLFxuICAgIHhsZWZ0aGFycG9vbmRvd246IFsneEFycm93JywgMHgyMUJELCAxMCwgNV0sXG4gICAgeHJpZ2h0bGVmdGhhcnBvb25zOiBbJ3hBcnJvdycsIDB4MjFDQywgMTAsIDEwXSxcbiAgICB4cmlnaHRoYXJwb29udXA6IFsneEFycm93JywgMHgyMUMwLCA1LCAxMF0sXG4gICAgeGxlZnRoYXJwb29udXA6IFsneEFycm93JywgMHgyMUJDLCAxMCwgNV0sXG4gICAgeGxlZnRyaWdodGhhcnBvb25zOiBbJ3hBcnJvdycsIDB4MjFDQiwgMTAsIDEwXSxcbiAgICBtYXRobGxhcDogWydNYXRoTGFwJywgJ2wnLCBmYWxzZV0sXG4gICAgbWF0aHJsYXA6IFsnTWF0aExhcCcsICdyJywgZmFsc2VdLFxuICAgIG1hdGhjbGFwOiBbJ01hdGhMYXAnLCAnYycsIGZhbHNlXSxcbiAgICBjbGFwOiBbJ010TGFwJywgJ2MnXSxcbiAgICB0ZXh0bGxhcDogWydNdExhcCcsICdsJ10sXG4gICAgdGV4dHJsYXA6IFsnTXRMYXAnLCAnciddLFxuICAgIHRleHRjbGFwOiBbJ010TGFwJywgJ2MnXSxcbiAgICBjcmFtcGVkOiAnQ3JhbXBlZCcsXG4gICAgY3JhbXBlZGxsYXA6IFsnTWF0aExhcCcsICdsJywgdHJ1ZV0sXG4gICAgY3JhbXBlZHJsYXA6IFsnTWF0aExhcCcsICdyJywgdHJ1ZV0sXG4gICAgY3JhbXBlZGNsYXA6IFsnTWF0aExhcCcsICdjJywgdHJ1ZV0sXG4gICAgY3JhbXBlZHN1YnN0YWNrOiBbJ01hY3JvJywgJ1xcXFxiZWdpbntjcmFtcGVkc3ViYXJyYXl9e2N9IzFcXFxcZW5ke2NyYW1wZWRzdWJhcnJheX0nLCAxXSxcbiAgICBtYXRobWJveDogJ01hdGhNQm94JyxcbiAgICBtYXRobWFrZWJveDogJ01hdGhNYWtlQm94JyxcbiAgICBvdmVyYnJhY2tldDogJ1VuZGVyT3ZlckJyYWNrZXQnLFxuICAgIHVuZGVyYnJhY2tldDogJ1VuZGVyT3ZlckJyYWNrZXQnLFxuICAgIHJlZmVxOiAnSGFuZGxlUmVmJyxcbiAgICBNb3ZlRXFMZWZ0OiBbJ01hY3JvJywgJ1xcXFxoc3BhY2V7IzFlbX0mXFxcXGhzcGFjZXstIzFlbX0nLCAxLCAnMiddLFxuICAgIEFib3hlZDogJ0Fib3hlZCcsXG4gICAgQXJyb3dCZXR3ZWVuTGluZXM6ICdBcnJvd0JldHdlZW5MaW5lcycsXG4gICAgdmRvdHN3aXRoaW46ICdWRG90c1dpdGhpbicsXG4gICAgc2hvcnR2ZG90c3dpdGhpbjogJ1Nob3J0VkRvdHNXaXRoaW4nLFxuICAgIE1URmx1c2hTcGFjZUFib3ZlOiAnRmx1c2hTcGFjZUFib3ZlJyxcbiAgICBNVEZsdXNoU3BhY2VCZWxvdzogJ0ZsdXNoU3BhY2VCZWxvdycsXG4gICAgRGVjbGFyZVBhaXJlZERlbGltaXRlcjogJ0RlY2xhcmVQYWlyZWREZWxpbWl0ZXInLFxuICAgIERlY2xhcmVQYWlyZWREZWxpbWl0ZXJYOiAnRGVjbGFyZVBhaXJlZERlbGltaXRlclgnLFxuICAgIERlY2xhcmVQYWlyZWREZWxpbWl0ZXJYUFA6ICdEZWNsYXJlUGFpcmVkRGVsaW1pdGVyWFBQJyxcbiAgICBEZWNsYXJlUGFpcmVkRGVsaW1pdGVyczogJ0RlY2xhcmVQYWlyZWREZWxpbWl0ZXInLFxuICAgIERlY2xhcmVQYWlyZWREZWxpbWl0ZXJzWDogJ0RlY2xhcmVQYWlyZWREZWxpbWl0ZXJYJyxcbiAgICBEZWNsYXJlUGFpcmVkRGVsaW1pdGVyc1hQUDogJ0RlY2xhcmVQYWlyZWREZWxpbWl0ZXJYUFAnLFxuICAgIGNlbnRlcmNvbG9uOiBbJ0NlbnRlckNvbG9uJywgdHJ1ZSwgdHJ1ZV0sXG4gICAgb3JkaW5hcnljb2xvbjogWydDZW50ZXJDb2xvbicsIGZhbHNlXSxcbiAgICBNVFRoaW5Db2xvbjogWydDZW50ZXJDb2xvbicsIHRydWUsIHRydWUsIHRydWVdLFxuICAgIGNvbG9uZXFxOiBbJ1JlbGF0aW9uJywgJzo9JywgJ1xcdTIyNTQnXSxcbiAgICBDb2xvbmVxcTogWydSZWxhdGlvbicsICc6Oj0nLCAnXFx1MkE3NCddLFxuICAgIGNvbG9uZXE6IFsnUmVsYXRpb24nLCAnOi0nXSxcbiAgICBDb2xvbmVxOiBbJ1JlbGF0aW9uJywgJzo6LSddLFxuICAgIGVxcWNvbG9uOiBbJ1JlbGF0aW9uJywgJz06JywgJ1xcdTIyNTUnXSxcbiAgICBFcXFjb2xvbjogWydSZWxhdGlvbicsICc9OjonXSxcbiAgICBlcWNvbG9uOiBbJ1JlbGF0aW9uJywgJy06JywgJ1xcdTIyMzknXSxcbiAgICBFcWNvbG9uOiBbJ1JlbGF0aW9uJywgJy06OiddLFxuICAgIGNvbG9uYXBwcm94OiBbJ1JlbGF0aW9uJywgJzpcXFxcYXBwcm94J10sXG4gICAgQ29sb25hcHByb3g6IFsnUmVsYXRpb24nLCAnOjpcXFxcYXBwcm94J10sXG4gICAgY29sb25zaW06IFsnUmVsYXRpb24nLCAnOlxcXFxzaW0nXSxcbiAgICBDb2xvbnNpbTogWydSZWxhdGlvbicsICc6OlxcXFxzaW0nXSxcbiAgICBkYmxjb2xvbjogWydSZWxhdGlvbicsICc6OicsICdcXHUyMjM3J10sXG4gICAgbnVwYXJyb3c6IFsnTkFycm93JywgJ1xcdTIxOTEnLCAnLjA2ZW0nXSxcbiAgICBuZG93bmFycm93OiBbJ05BcnJvdycsICdcXHUyMTkzJywgJy4yNWVtJ10sXG4gICAgYmlndGltZXM6IFsnTWFjcm8nLCAnXFxcXG1hdGhvcHtcXFxcTGFyZ2VcXFxca2Vybi0uMWVtXFxcXGJvbGRzeW1ib2x7XFxcXHRpbWVzfVxcXFxrZXJuLS4xZW19J10sXG4gICAgc3BsaXRmcmFjOiBbJ1NwbGl0RnJhYycsIGZhbHNlXSxcbiAgICBzcGxpdGRmcmFjOiBbJ1NwbGl0RnJhYycsIHRydWVdLFxuICAgIHhtYXRoc3RydXQ6ICdYTWF0aFN0cnV0JyxcbiAgICBwcmVzY3JpcHQ6ICdQcmVzY3JpcHQnLFxuICAgIG5ld3RhZ2Zvcm06IFsnTmV3VGFnRm9ybScsIGZhbHNlXSxcbiAgICByZW5ld3RhZ2Zvcm06IFsnTmV3VGFnRm9ybScsIHRydWVdLFxuICAgIHVzZXRhZ2Zvcm06ICdVc2VUYWdGb3JtJyxcbiAgICBhZGp1c3RsaW1pdHM6IFtcbiAgICAgICAgJ01hY3JvV2l0aFRlbXBsYXRlJyxcbiAgICAgICAgJ1xcXFxtYXRob3B7eyMxfVxcXFx2cGhhbnRvbXt7IzN9fX1fe3sjMn1cXFxcdnBoYW50b217eyM0fX19XFxcXG1hdGhvcHt7IzN9XFxcXHZwaGFudG9te3sjMX19fV97eyM0fVxcXFx2cGhhbnRvbXt7IzJ9fX0nLFxuICAgICAgICA0LCAsICdfJywgLCAnXydcbiAgICBdLFxuICAgIG1hdGh0b29sc3NldDogJ1NldE9wdGlvbnMnXG59LCBNYXRodG9vbHNNZXRob2RzX2pzXzEuTWF0aHRvb2xzTWV0aG9kcyk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuRW52aXJvbm1lbnRNYXAoJ21hdGh0b29scy1lbnZpcm9ubWVudHMnLCBQYXJzZU1ldGhvZHNfanNfMS5kZWZhdWx0LmVudmlyb25tZW50LCB7XG4gICAgZGNhc2VzOiBbJ0FycmF5JywgbnVsbCwgJ1xcXFx7JywgJycsICdsbCcsIG51bGwsICcuMmVtJywgJ0QnXSxcbiAgICByY2FzZXM6IFsnQXJyYXknLCBudWxsLCAnJywgJ1xcXFx9JywgJ2xsJywgbnVsbCwgJy4yZW0nXSxcbiAgICBkcmNhc2VzOiBbJ0FycmF5JywgbnVsbCwgJycsICdcXFxcfScsICdsbCcsIG51bGwsICcuMmVtJywgJ0QnXSxcbiAgICAnZGNhc2VzKic6IFsnQ2FzZXMnLCBudWxsLCAneycsICcnLCAnRCddLFxuICAgICdyY2FzZXMqJzogWydDYXNlcycsIG51bGwsICcnLCAnfSddLFxuICAgICdkcmNhc2VzKic6IFsnQ2FzZXMnLCBudWxsLCAnJywgJ30nLCAnRCddLFxuICAgICdjYXNlcyonOiBbJ0Nhc2VzJywgbnVsbCwgJ3snLCAnJ10sXG4gICAgJ21hdHJpeConOiBbJ010TWF0cml4JywgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgJ3BtYXRyaXgqJzogWydNdE1hdHJpeCcsIG51bGwsICcoJywgJyknXSxcbiAgICAnYm1hdHJpeConOiBbJ010TWF0cml4JywgbnVsbCwgJ1snLCAnXSddLFxuICAgICdCbWF0cml4Kic6IFsnTXRNYXRyaXgnLCBudWxsLCAnXFxcXHsnLCAnXFxcXH0nXSxcbiAgICAndm1hdHJpeConOiBbJ010TWF0cml4JywgbnVsbCwgJ1xcXFx2ZXJ0JywgJ1xcXFx2ZXJ0J10sXG4gICAgJ1ZtYXRyaXgqJzogWydNdE1hdHJpeCcsIG51bGwsICdcXFxcVmVydCcsICdcXFxcVmVydCddLFxuICAgICdzbWFsbG1hdHJpeConOiBbJ010U21hbGxNYXRyaXgnLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICBwc21hbGxtYXRyaXg6IFsnTXRTbWFsbE1hdHJpeCcsIG51bGwsICcoJywgJyknLCAnYyddLFxuICAgICdwc21hbGxtYXRyaXgqJzogWydNdFNtYWxsTWF0cml4JywgbnVsbCwgJygnLCAnKSddLFxuICAgIGJzbWFsbG1hdHJpeDogWydNdFNtYWxsTWF0cml4JywgbnVsbCwgJ1snLCAnXScsICdjJ10sXG4gICAgJ2JzbWFsbG1hdHJpeConOiBbJ010U21hbGxNYXRyaXgnLCBudWxsLCAnWycsICddJ10sXG4gICAgQnNtYWxsbWF0cml4OiBbJ010U21hbGxNYXRyaXgnLCBudWxsLCAnXFxcXHsnLCAnXFxcXH0nLCAnYyddLFxuICAgICdCc21hbGxtYXRyaXgqJzogWydNdFNtYWxsTWF0cml4JywgbnVsbCwgJ1xcXFx7JywgJ1xcXFx9J10sXG4gICAgdnNtYWxsbWF0cml4OiBbJ010U21hbGxNYXRyaXgnLCBudWxsLCAnXFxcXHZlcnQnLCAnXFxcXHZlcnQnLCAnYyddLFxuICAgICd2c21hbGxtYXRyaXgqJzogWydNdFNtYWxsTWF0cml4JywgbnVsbCwgJ1xcXFx2ZXJ0JywgJ1xcXFx2ZXJ0J10sXG4gICAgVnNtYWxsbWF0cml4OiBbJ010U21hbGxNYXRyaXgnLCBudWxsLCAnXFxcXFZlcnQnLCAnXFxcXFZlcnQnLCAnYyddLFxuICAgICdWc21hbGxtYXRyaXgqJzogWydNdFNtYWxsTWF0cml4JywgbnVsbCwgJ1xcXFxWZXJ0JywgJ1xcXFxWZXJ0J10sXG4gICAgY3JhbXBlZHN1YmFycmF5OiBbJ0FycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgJzBlbScsICcwLjFlbScsICdTXFwnJywgMV0sXG4gICAgbXVsdGxpbmVkOiAnTXRNdWx0bGluZWQnLFxuICAgIHNwcmVhZGxpbmVzOiBbJ1NwcmVhZExpbmVzJywgdHJ1ZV0sXG4gICAgbGdhdGhlcmVkOiBbJ0Ftc0VxbkFycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgJ2wnLCBudWxsLCAnLjVlbScsICdEJ10sXG4gICAgcmdhdGhlcmVkOiBbJ0Ftc0VxbkFycmF5JywgbnVsbCwgbnVsbCwgbnVsbCwgJ3InLCBudWxsLCAnLjVlbScsICdEJ10sXG59LCBNYXRodG9vbHNNZXRob2RzX2pzXzEuTWF0aHRvb2xzTWV0aG9kcyk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuRGVsaW1pdGVyTWFwKCdtYXRodG9vbHMtZGVsaW1pdGVycycsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQuZGVsaW1pdGVyLCB7XG4gICAgJ1xcXFxscGFyZW4nOiAnKCcsXG4gICAgJ1xcXFxycGFyZW4nOiAnKSdcbn0pO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ21hdGh0b29scy1jaGFyYWN0ZXJzJywge1xuICAgICc6JzogWydDZW50ZXJDb2xvbicsIHRydWVdXG59LCBNYXRodG9vbHNNZXRob2RzX2pzXzEuTWF0aHRvb2xzTWV0aG9kcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRodG9vbHNNYXBwaW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hdGh0b29sc01ldGhvZHMgPSB2b2lkIDA7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgQW1zTWV0aG9kc19qc18xID0gcmVxdWlyZShcIi4uL2Ftcy9BbXNNZXRob2RzLmpzXCIpO1xudmFyIEJhc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Jhc2UvQmFzZU1ldGhvZHMuanNcIikpO1xudmFyIFRleFBhcnNlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhQYXJzZXIuanNcIikpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xudmFyIGxlbmd0aHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL2xlbmd0aHMuanNcIik7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBOZXdjb21tYW5kVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9uZXdjb21tYW5kL05ld2NvbW1hbmRVdGlsLmpzXCIpKTtcbnZhciBOZXdjb21tYW5kTWV0aG9kc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9uZXdjb21tYW5kL05ld2NvbW1hbmRNZXRob2RzLmpzXCIpKTtcbnZhciBNYXRodG9vbHNVdGlsX2pzXzEgPSByZXF1aXJlKFwiLi9NYXRodG9vbHNVdGlsLmpzXCIpO1xuZXhwb3J0cy5NYXRodG9vbHNNZXRob2RzID0ge1xuICAgIE10TWF0cml4OiBmdW5jdGlvbiAocGFyc2VyLCBiZWdpbiwgb3BlbiwgY2xvc2UpIHtcbiAgICAgICAgdmFyIGFsaWduID0gcGFyc2VyLkdldEJyYWNrZXRzKFwiXFxcXGJlZ2lue1wiLmNvbmNhdChiZWdpbi5nZXROYW1lKCksIFwifVwiKSwgJ2MnKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTWF0aHRvb2xzTWV0aG9kcy5BcnJheShwYXJzZXIsIGJlZ2luLCBvcGVuLCBjbG9zZSwgYWxpZ24pO1xuICAgIH0sXG4gICAgTXRTbWFsbE1hdHJpeDogZnVuY3Rpb24gKHBhcnNlciwgYmVnaW4sIG9wZW4sIGNsb3NlLCBhbGlnbikge1xuICAgICAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgICAgICBhbGlnbiA9IHBhcnNlci5HZXRCcmFja2V0cyhcIlxcXFxiZWdpbntcIi5jb25jYXQoYmVnaW4uZ2V0TmFtZSgpLCBcIn1cIiksIHBhcnNlci5vcHRpb25zLm1hdGh0b29sc1snc21hbGxtYXRyaXgtYWxpZ24nXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTWF0aHRvb2xzTWV0aG9kcy5BcnJheShwYXJzZXIsIGJlZ2luLCBvcGVuLCBjbG9zZSwgYWxpZ24sIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuRW0oMSAvIDMpLCAnLjJlbScsICdTJywgMSk7XG4gICAgfSxcbiAgICBNdE11bHRsaW5lZDogZnVuY3Rpb24gKHBhcnNlciwgYmVnaW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgbmFtZSA9IFwiXFxcXGJlZ2lue1wiLmNvbmNhdChiZWdpbi5nZXROYW1lKCksIFwifVwiKTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lLCBwYXJzZXIub3B0aW9ucy5tYXRodG9vbHNbJ211bHRsaW5lZC1wb3MnXSB8fCAnYycpO1xuICAgICAgICB2YXIgd2lkdGggPSBwb3MgPyBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpIDogJyc7XG4gICAgICAgIGlmIChwb3MgJiYgIXBvcy5tYXRjaCgvXltjYnRdJC8pKSB7XG4gICAgICAgICAgICBfYSA9IF9fcmVhZChbcG9zLCB3aWR0aF0sIDIpLCB3aWR0aCA9IF9hWzBdLCBwb3MgPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuUHVzaChiZWdpbik7XG4gICAgICAgIHZhciBpdGVtID0gcGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnbXVsdGxpbmVkJywgcGFyc2VyLCBiZWdpbik7XG4gICAgICAgIGl0ZW0uYXJyYXlkZWYgPSB7XG4gICAgICAgICAgICBkaXNwbGF5c3R5bGU6IHRydWUsXG4gICAgICAgICAgICByb3dzcGFjaW5nOiAnLjVlbScsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggfHwgJ2F1dG8nLFxuICAgICAgICAgICAgY29sdW1ud2lkdGg6ICcxMDAlJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXJyYXlBbGlnbihpdGVtLCBwb3MgfHwgJ2MnKTtcbiAgICB9LFxuICAgIEhhbmRsZVNob3ZlOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBzaG92ZSkge1xuICAgICAgICB2YXIgdG9wID0gcGFyc2VyLnN0YWNrLlRvcCgpO1xuICAgICAgICBpZiAodG9wLmtpbmQgIT09ICdtdWx0bGluZScgJiYgdG9wLmtpbmQgIT09ICdtdWx0bGluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdDb21tYW5kSW5NdWx0bGluZWQnLCAnJTEgY2FuIG9ubHkgYXBwZWFyIHdpdGhpbiB0aGUgbXVsdGxpbmUgb3IgbXVsdGxpbmVkIGVudmlyb25tZW50cycsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3AuU2l6ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdDb21tYW5kQXRUaGVCZWdpbmluZ09mTGluZScsICclMSBtdXN0IGNvbWUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZScsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRvcC5zZXRQcm9wZXJ0eSgnc2hvdmUnLCBzaG92ZSk7XG4gICAgICAgIHZhciBzaGlmdCA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lKTtcbiAgICAgICAgdmFyIG1tbCA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICAgICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgICAgICB2YXIgbXJvdyA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXJvdycsIFtdKTtcbiAgICAgICAgICAgIHZhciBtc3BhY2UgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zcGFjZScsIFtdLCB7IHdpZHRoOiBzaGlmdCB9KTtcbiAgICAgICAgICAgIGlmIChzaG92ZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgbXJvdy5hcHBlbmRDaGlsZChtc3BhY2UpO1xuICAgICAgICAgICAgICAgIG1yb3cuYXBwZW5kQ2hpbGQobW1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1yb3cuYXBwZW5kQ2hpbGQobW1sKTtcbiAgICAgICAgICAgICAgICBtcm93LmFwcGVuZENoaWxkKG1zcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtbWwgPSBtcm93O1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5QdXNoKG1tbCk7XG4gICAgfSxcbiAgICBTcHJlYWRMaW5lczogZnVuY3Rpb24gKHBhcnNlciwgYmVnaW4pIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmIChwYXJzZXIuc3RhY2suZW52LmNsb3NpbmcgPT09IGJlZ2luLmdldE5hbWUoKSkge1xuICAgICAgICAgICAgZGVsZXRlIHBhcnNlci5zdGFjay5lbnYuY2xvc2luZztcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IHBhcnNlci5zdGFjay5Qb3AoKTtcbiAgICAgICAgICAgIHZhciBtbWwgPSB0b3BfMS50b01tbCgpO1xuICAgICAgICAgICAgdmFyIHNwcmVhZCA9IHRvcF8xLmdldFByb3BlcnR5KCdzcHJlYWQnKTtcbiAgICAgICAgICAgIGlmIChtbWwuaXNJbmZlcnJlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENoaWxkcmVuKG1tbCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGh0b29sc1V0aWxfanNfMS5NYXRodG9vbHNVdGlsLnNwcmVhZExpbmVzKGNoaWxkLCBzcHJlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE1hdGh0b29sc1V0aWxfanNfMS5NYXRodG9vbHNVdGlsLnNwcmVhZExpbmVzKG1tbCwgc3ByZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5QdXNoKG1tbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3ByZWFkID0gcGFyc2VyLkdldERpbWVuKFwiXFxcXGJlZ2lue1wiLmNvbmNhdChiZWdpbi5nZXROYW1lKCksIFwifVwiKSk7XG4gICAgICAgICAgICBiZWdpbi5zZXRQcm9wZXJ0eSgnc3ByZWFkJywgc3ByZWFkKTtcbiAgICAgICAgICAgIHBhcnNlci5QdXNoKGJlZ2luKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQ2FzZXM6IGZ1bmN0aW9uIChwYXJzZXIsIGJlZ2luLCBvcGVuLCBjbG9zZSwgc3R5bGUpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gcGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnYXJyYXknKS5zZXRQcm9wZXJ0eSgnY2FzZXNFbnYnLCBiZWdpbi5nZXROYW1lKCkpO1xuICAgICAgICBhcnJheS5hcnJheWRlZiA9IHtcbiAgICAgICAgICAgIHJvd3NwYWNpbmc6ICcuMmVtJyxcbiAgICAgICAgICAgIGNvbHVtbnNwYWNpbmc6ICcxZW0nLFxuICAgICAgICAgICAgY29sdW1uYWxpZ246ICdsZWZ0J1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3R5bGUgPT09ICdEJykge1xuICAgICAgICAgICAgYXJyYXkuYXJyYXlkZWYuZGlzcGxheXN0eWxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheS5zZXRQcm9wZXJ0aWVzKHsgb3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlIH0pO1xuICAgICAgICBwYXJzZXIuUHVzaChiZWdpbik7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuICAgIE1hdGhMYXA6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUsIHBvcywgY3JhbXBlZCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpLnRyaW0oKTtcbiAgICAgICAgdmFyIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXN0eWxlJywgW1xuICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW3BhcnNlci5QYXJzZUFyZyhuYW1lKV0sIF9fYXNzaWduKHsgd2lkdGg6IDAgfSwgKHBvcyA9PT0gJ3InID8ge30gOiB7IGxzcGFjZTogKHBvcyA9PT0gJ2wnID8gJy0xd2lkdGgnIDogJy0uNXdpZHRoJykgfSkpKVxuICAgICAgICBdLCB7ICdkYXRhLWNyYW1wZWQnOiBjcmFtcGVkIH0pO1xuICAgICAgICBNYXRodG9vbHNVdGlsX2pzXzEuTWF0aHRvb2xzVXRpbC5zZXREaXNwbGF5TGV2ZWwobW1sLCBzdHlsZSk7XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnVGVYQXRvbScsIFttbWxdKSk7XG4gICAgfSxcbiAgICBDcmFtcGVkOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lLCAnJykudHJpbSgpO1xuICAgICAgICB2YXIgYXJnID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgICAgICB2YXIgbW1sID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtc3R5bGUnLCBbYXJnXSwgeyAnZGF0YS1jcmFtcGVkJzogdHJ1ZSB9KTtcbiAgICAgICAgTWF0aHRvb2xzVXRpbF9qc18xLk1hdGh0b29sc1V0aWwuc2V0RGlzcGxheUxldmVsKG1tbCwgc3R5bGUpO1xuICAgICAgICBwYXJzZXIuUHVzaChtbWwpO1xuICAgIH0sXG4gICAgTXRMYXA6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUsIHBvcykge1xuICAgICAgICB2YXIgY29udGVudCA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuaW50ZXJuYWxNYXRoKHBhcnNlciwgcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpLCAwKTtcbiAgICAgICAgdmFyIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIGNvbnRlbnQsIHsgd2lkdGg6IDAgfSk7XG4gICAgICAgIGlmIChwb3MgIT09ICdyJykge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShtbWwsICdsc3BhY2UnLCBwb3MgPT09ICdsJyA/ICctMXdpZHRoJyA6ICctLjV3aWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5QdXNoKG1tbCk7XG4gICAgfSxcbiAgICBNYXRoTWFrZUJveDogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSk7XG4gICAgICAgIHZhciBwb3MgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJ2MnKTtcbiAgICAgICAgdmFyIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtwYXJzZXIuUGFyc2VBcmcobmFtZSldKTtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKG1tbCwgJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGlnbiA9ICgwLCBPcHRpb25zX2pzXzEubG9va3VwKShwb3MsIHsgYzogJ2NlbnRlcicsIHI6ICdyaWdodCcgfSwgJycpO1xuICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobW1sLCAnZGF0YS1hbGlnbicsIGFsaWduKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuUHVzaChtbWwpO1xuICAgIH0sXG4gICAgTWF0aE1Cb3g6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgcGFyc2VyLlB1c2gocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcm93JywgW3BhcnNlci5QYXJzZUFyZyhuYW1lKV0pKTtcbiAgICB9LFxuICAgIFVuZGVyT3ZlckJyYWNrZXQ6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIHRoaWNrbmVzcyA9ICgwLCBsZW5ndGhzX2pzXzEubGVuZ3RoMmVtKShwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJy4xZW0nKSwgLjEpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VyLkdldEJyYWNrZXRzKG5hbWUsICcuMmVtJyk7XG4gICAgICAgIHZhciBhcmcgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCgobmFtZS5jaGFyQXQoMSkgPT09ICdvJyA/XG4gICAgICAgICAgICBbJ292ZXInLCAnYWNjZW50JywgJ2JvdHRvbSddIDpcbiAgICAgICAgICAgIFsndW5kZXInLCAnYWNjZW50dW5kZXInLCAndG9wJ10pLCAzKSwgcG9zID0gX2FbMF0sIGFjY2VudCA9IF9hWzFdLCBib3JkZXIgPSBfYVsyXTtcbiAgICAgICAgdmFyIHQgPSAoMCwgbGVuZ3Roc19qc18xLmVtKSh0aGlja25lc3MpO1xuICAgICAgICB2YXIgYmFzZSA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KGFyZywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgICAgICB2YXIgY29weSA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KGFyZywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgICAgICB2YXIgc2NyaXB0ID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW1xuICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGhhbnRvbScsIFtjb3B5XSlcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgc3R5bGU6IFwiYm9yZGVyOiBcIi5jb25jYXQodCwgXCIgc29saWQ7IGJvcmRlci1cIikuY29uY2F0KGJvcmRlciwgXCI6IG5vbmVcIiksXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGRlcHRoOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQudW5kZXJPdmVyKHBhcnNlciwgYmFzZSwgc2NyaXB0LCBwb3MsIHRydWUpO1xuICAgICAgICB2YXIgbXVuZGVyb3ZlciA9IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZEF0KE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZEF0KG5vZGUsIDApLCAwKTtcbiAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShtdW5kZXJvdmVyLCBhY2NlbnQsIHRydWUpO1xuICAgICAgICBwYXJzZXIuUHVzaChub2RlKTtcbiAgICB9LFxuICAgIEFib3hlZDogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgICAgICB2YXIgdG9wID0gTWF0aHRvb2xzVXRpbF9qc18xLk1hdGh0b29sc1V0aWwuY2hlY2tBbGlnbm1lbnQocGFyc2VyLCBuYW1lKTtcbiAgICAgICAgaWYgKHRvcC5yb3cubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgdG9wLnJvdy5wdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRkJywgW10pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgcmVzdCA9IHBhcnNlci5zdHJpbmcuc3Vic3RyKHBhcnNlci5pKTtcbiAgICAgICAgcGFyc2VyLnN0cmluZyA9IGFyZyArICcmJlxcXFxlbmRBYm94ZWQnO1xuICAgICAgICBwYXJzZXIuaSA9IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gcGFyc2VyLkdldFVwVG8obmFtZSwgJyYnKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VyLkdldFVwVG8obmFtZSwgJyYnKTtcbiAgICAgICAgcGFyc2VyLkdldFVwVG8obmFtZSwgJ1xcXFxlbmRBYm94ZWQnKTtcbiAgICAgICAgdmFyIHRleCA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuc3Vic3RpdHV0ZUFyZ3MocGFyc2VyLCBbbGVmdCwgcmlnaHRdLCAnXFxcXHJsYXB7XFxcXGJveGVkeyMxe30jMn19XFxcXGtlcm4uMjY3ZW1cXFxccGhhbnRvbXsjMX0mXFxcXHBoYW50b217e30jMn1cXFxca2Vybi4yNjdlbScpO1xuICAgICAgICBwYXJzZXIuc3RyaW5nID0gdGV4ICsgcmVzdDtcbiAgICAgICAgcGFyc2VyLmkgPSAwO1xuICAgIH0sXG4gICAgQXJyb3dCZXR3ZWVuTGluZXM6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIHRvcCA9IE1hdGh0b29sc1V0aWxfanNfMS5NYXRodG9vbHNVdGlsLmNoZWNrQWxpZ25tZW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIGlmICh0b3AuU2l6ZSgpIHx8IHRvcC5yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdCZXR3ZWVuTGluZXMnLCAnJTEgbXVzdCBiZSBvbiBhIHJvdyBieSBpdHNlbGYnLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgICAgIHZhciBzeW1ib2wgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJ1xcXFxVcGRvd25hcnJvdycpO1xuICAgICAgICBpZiAoc3Rhcikge1xuICAgICAgICAgICAgdG9wLkVuZEVudHJ5KCk7XG4gICAgICAgICAgICB0b3AuRW5kRW50cnkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4ID0gKHN0YXIgPyAnXFxcXHF1YWQnICsgc3ltYm9sIDogc3ltYm9sICsgJ1xcXFxxdWFkJyk7XG4gICAgICAgIHZhciBtbWwgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdCh0ZXgsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICAgICAgcGFyc2VyLlB1c2gobW1sKTtcbiAgICAgICAgdG9wLkVuZEVudHJ5KCk7XG4gICAgICAgIHRvcC5FbmRSb3coKTtcbiAgICB9LFxuICAgIFZEb3RzV2l0aGluOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciB0b3AgPSBwYXJzZXIuc3RhY2suVG9wKCk7XG4gICAgICAgIHZhciBpc0ZsdXNoID0gKHRvcC5nZXRQcm9wZXJ0eSgnZmx1c2hzcGFjZWFib3ZlJykgPT09IHRvcC50YWJsZS5sZW5ndGgpO1xuICAgICAgICB2YXIgYXJnID0gJ1xcXFxtbWxUb2tlbnttaX17fScgKyBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkgKyAnXFxcXG1tbFRva2Vue21pfXt9JztcbiAgICAgICAgdmFyIGJhc2UgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChhcmcsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICAgICAgdmFyIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtcbiAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21vJywgW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCd0ZXh0JywgJ1xcdTIyRUUnKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdLCBfX2Fzc2lnbih7IHdpZHRoOiAwLCBsc3BhY2U6ICctLjV3aWR0aCcgfSwgKGlzRmx1c2ggPyB7IGhlaWdodDogJy0uNmVtJywgdm9mZnNldDogJy0uMThlbScgfSA6IHt9KSkpLFxuICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGhhbnRvbScsIFtiYXNlXSlcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgbHNwYWNlOiAnLjV3aWR0aCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcnNlci5QdXNoKG1tbCk7XG4gICAgfSxcbiAgICBTaG9ydFZEb3RzV2l0aGluOiBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSkge1xuICAgICAgICB2YXIgdG9wID0gcGFyc2VyLnN0YWNrLlRvcCgpO1xuICAgICAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgICAgIGV4cG9ydHMuTWF0aHRvb2xzTWV0aG9kcy5GbHVzaFNwYWNlQWJvdmUocGFyc2VyLCAnXFxcXE1URmx1c2hTcGFjZUFib3ZlJyk7XG4gICAgICAgICFzdGFyICYmIHRvcC5FbmRFbnRyeSgpO1xuICAgICAgICBleHBvcnRzLk1hdGh0b29sc01ldGhvZHMuVkRvdHNXaXRoaW4ocGFyc2VyLCAnXFxcXHZkb3Rzd2l0aGluJyk7XG4gICAgICAgIHN0YXIgJiYgdG9wLkVuZEVudHJ5KCk7XG4gICAgICAgIGV4cG9ydHMuTWF0aHRvb2xzTWV0aG9kcy5GbHVzaFNwYWNlQmVsb3cocGFyc2VyLCAnXFxcXE1URmx1c2hTcGFjZUJlbG93Jyk7XG4gICAgfSxcbiAgICBGbHVzaFNwYWNlQWJvdmU6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIHRvcCA9IE1hdGh0b29sc1V0aWxfanNfMS5NYXRodG9vbHNVdGlsLmNoZWNrQWxpZ25tZW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHRvcC5zZXRQcm9wZXJ0eSgnZmx1c2hzcGFjZWFib3ZlJywgdG9wLnRhYmxlLmxlbmd0aCk7XG4gICAgICAgIHRvcC5hZGRSb3dTcGFjaW5nKCctJyArIHBhcnNlci5vcHRpb25zLm1hdGh0b29sc1snc2hvcnR2ZG90c2FkanVzdGFib3ZlJ10pO1xuICAgIH0sXG4gICAgRmx1c2hTcGFjZUJlbG93OiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciB0b3AgPSBNYXRodG9vbHNVdGlsX2pzXzEuTWF0aHRvb2xzVXRpbC5jaGVja0FsaWdubWVudChwYXJzZXIsIG5hbWUpO1xuICAgICAgICB0b3AuU2l6ZSgpICYmIHRvcC5FbmRFbnRyeSgpO1xuICAgICAgICB0b3AuRW5kUm93KCk7XG4gICAgICAgIHRvcC5hZGRSb3dTcGFjaW5nKCctJyArIHBhcnNlci5vcHRpb25zLm1hdGh0b29sc1snc2hvcnR2ZG90c2FkanVzdGJlbG93J10pO1xuICAgIH0sXG4gICAgUGFpcmVkRGVsaW1pdGVyczogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgb3BlbiwgY2xvc2UsIGJvZHksIG4sIHByZSwgcG9zdCkge1xuICAgICAgICBpZiAoYm9keSA9PT0gdm9pZCAwKSB7IGJvZHkgPSAnIzEnOyB9XG4gICAgICAgIGlmIChuID09PSB2b2lkIDApIHsgbiA9IDE7IH1cbiAgICAgICAgaWYgKHByZSA9PT0gdm9pZCAwKSB7IHByZSA9ICcnOyB9XG4gICAgICAgIGlmIChwb3N0ID09PSB2b2lkIDApIHsgcG9zdCA9ICcnOyB9XG4gICAgICAgIHZhciBzdGFyID0gcGFyc2VyLkdldFN0YXIoKTtcbiAgICAgICAgdmFyIHNpemUgPSAoc3RhciA/ICcnIDogcGFyc2VyLkdldEJyYWNrZXRzKG5hbWUpKTtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKChzdGFyID8gWydcXFxcbGVmdCcsICdcXFxccmlnaHQnXSA6IHNpemUgPyBbc2l6ZSArICdsJywgc2l6ZSArICdyJ10gOiBbJycsICcnXSksIDIpLCBsZWZ0ID0gX2FbMF0sIHJpZ2h0ID0gX2FbMV07XG4gICAgICAgIHZhciBkZWxpbSA9IChzdGFyID8gJ1xcXFxtaWRkbGUnIDogc2l6ZSB8fCAnJyk7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmUgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnN1YnN0aXR1dGVBcmdzKHBhcnNlciwgYXJncywgcHJlKTtcbiAgICAgICAgICAgIGJvZHkgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnN1YnN0aXR1dGVBcmdzKHBhcnNlciwgYXJncywgYm9keSk7XG4gICAgICAgICAgICBwb3N0ID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5zdWJzdGl0dXRlQXJncyhwYXJzZXIsIGFyZ3MsIHBvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL1xcXFxkZWxpbXNpemUvZywgZGVsaW0pO1xuICAgICAgICBwYXJzZXIuc3RyaW5nID0gW3ByZSwgbGVmdCwgb3BlbiwgYm9keSwgcmlnaHQsIGNsb3NlLCBwb3N0LCBwYXJzZXIuc3RyaW5nLnN1YnN0cihwYXJzZXIuaSldXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChzLCBwYXJ0KSB7IHJldHVybiBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmFkZEFyZ3MocGFyc2VyLCBzLCBwYXJ0KTsgfSwgJycpO1xuICAgICAgICBwYXJzZXIuaSA9IDA7XG4gICAgICAgIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuY2hlY2tNYXhNYWNyb3MocGFyc2VyKTtcbiAgICB9LFxuICAgIERlY2xhcmVQYWlyZWREZWxpbWl0ZXI6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIGNzID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldENzTmFtZUFyZ3VtZW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHZhciBvcGVuID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgY2xvc2UgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIE1hdGh0b29sc1V0aWxfanNfMS5NYXRodG9vbHNVdGlsLmFkZFBhaXJlZERlbGltcyhwYXJzZXIuY29uZmlndXJhdGlvbiwgY3MsIFtvcGVuLCBjbG9zZV0pO1xuICAgIH0sXG4gICAgRGVjbGFyZVBhaXJlZERlbGltaXRlclg6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIGNzID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldENzTmFtZUFyZ3VtZW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHZhciBuID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldEFyZ0NvdW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHZhciBvcGVuID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgY2xvc2UgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIHZhciBib2R5ID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICBNYXRodG9vbHNVdGlsX2pzXzEuTWF0aHRvb2xzVXRpbC5hZGRQYWlyZWREZWxpbXMocGFyc2VyLmNvbmZpZ3VyYXRpb24sIGNzLCBbb3BlbiwgY2xvc2UsIGJvZHksIG5dKTtcbiAgICB9LFxuICAgIERlY2xhcmVQYWlyZWREZWxpbWl0ZXJYUFA6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIGNzID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldENzTmFtZUFyZ3VtZW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHZhciBuID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldEFyZ0NvdW50KHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHZhciBwcmUgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIHZhciBvcGVuID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgY2xvc2UgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIHZhciBwb3N0ID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgYm9keSA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAgICAgTWF0aHRvb2xzVXRpbF9qc18xLk1hdGh0b29sc1V0aWwuYWRkUGFpcmVkRGVsaW1zKHBhcnNlci5jb25maWd1cmF0aW9uLCBjcywgW29wZW4sIGNsb3NlLCBib2R5LCBuLCBwcmUsIHBvc3RdKTtcbiAgICB9LFxuICAgIENlbnRlckNvbG9uOiBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSwgY2VudGVyLCBmb3JjZSwgdGhpbikge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGluID09PSB2b2lkIDApIHsgdGhpbiA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLm9wdGlvbnMubWF0aHRvb2xzO1xuICAgICAgICB2YXIgbW1sID0gcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbW8nLCB7fSwgJzonKTtcbiAgICAgICAgaWYgKGNlbnRlciAmJiAob3B0aW9uc1snY2VudGVyY29sb24nXSB8fCBmb3JjZSkpIHtcbiAgICAgICAgICAgIHZhciBkeSA9IG9wdGlvbnNbJ2NlbnRlcmNvbG9uLW9mZnNldCddO1xuICAgICAgICAgICAgbW1sID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW21tbF0sIF9fYXNzaWduKHsgdm9mZnNldDogZHksIGhlaWdodDogXCIrXCIuY29uY2F0KGR5KSwgZGVwdGg6IFwiLVwiLmNvbmNhdChkeSkgfSwgKHRoaW4gPyB7IHdpZHRoOiBvcHRpb25zWyd0aGluY29sb24tZHcnXSwgbHNwYWNlOiBvcHRpb25zWyd0aGluY29sb24tZHgnXSB9IDoge30pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLlB1c2gobW1sKTtcbiAgICB9LFxuICAgIFJlbGF0aW9uOiBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSwgdGV4LCB1bmljb2RlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLm9wdGlvbnMubWF0aHRvb2xzO1xuICAgICAgICBpZiAob3B0aW9uc1sndXNlLXVuaWNvZGUnXSAmJiB1bmljb2RlKSB7XG4gICAgICAgICAgICBwYXJzZXIuUHVzaChwYXJzZXIuY3JlYXRlKCd0b2tlbicsICdtbycsIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5SRUwgfSwgdW5pY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4ID0gJ1xcXFxtYXRocmVseycgKyB0ZXgucmVwbGFjZSgvOi9nLCAnXFxcXE1UVGhpbkNvbG9uJykucmVwbGFjZSgvLS9nLCAnXFxcXG1hdGhyZWx7LX0nKSArICd9JztcbiAgICAgICAgICAgIHBhcnNlci5zdHJpbmcgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmFkZEFyZ3MocGFyc2VyLCB0ZXgsIHBhcnNlci5zdHJpbmcuc3Vic3RyKHBhcnNlci5pKSk7XG4gICAgICAgICAgICBwYXJzZXIuaSA9IDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIE5BcnJvdzogZnVuY3Rpb24gKHBhcnNlciwgX25hbWUsIGMsIGR5KSB7XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnVGVYQXRvbScsIFtcbiAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ210ZXh0Jywge30sIGMpLFxuICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcGFkZGVkJywgW1xuICAgICAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtZW5jbG9zZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXNwYWNlJywgW10sIHsgaGVpZ2h0OiAnLjJlbScsIGRlcHRoOiAwLCB3aWR0aDogJy40ZW0nIH0pXG4gICAgICAgICAgICAgICAgICAgIF0sIHsgbm90YXRpb246ICd1cGRpYWdvbmFsc3RyaWtlJywgJ2RhdGEtdGhpY2tuZXNzJzogJy4wNWVtJywgJ2RhdGEtcGFkZGluZyc6IDAgfSlcbiAgICAgICAgICAgICAgICBdLCB7IHdpZHRoOiAwLCBsc3BhY2U6ICctLjV3aWR0aCcsIHZvZmZzZXQ6IGR5IH0pLFxuICAgICAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBoYW50b20nLCBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ210ZXh0Jywge30sIGMpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0sIHsgd2lkdGg6IDAsIGxzcGFjZTogJy0uNXdpZHRoJyB9KVxuICAgICAgICBdLCB7IHRleENsYXNzOiBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuUkVMIH0pKTtcbiAgICB9LFxuICAgIFNwbGl0RnJhYzogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgZGlzcGxheSkge1xuICAgICAgICB2YXIgbnVtID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgICAgICB2YXIgZGVuID0gcGFyc2VyLlBhcnNlQXJnKG5hbWUpO1xuICAgICAgICBwYXJzZXIuUHVzaChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zdHlsZScsIFtcbiAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbWZyYWMnLCBbXG4gICAgICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtc3R5bGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIG51bSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbWknKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbXNwYWNlJywgeyB3aWR0aDogJzFlbScgfSlcbiAgICAgICAgICAgICAgICBdLCB7IHNjcmlwdGxldmVsOiAwIH0pLFxuICAgICAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXN0eWxlJywgW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCd0b2tlbicsICdtc3BhY2UnLCB7IHdpZHRoOiAnMWVtJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbWknKSxcbiAgICAgICAgICAgICAgICAgICAgZGVuXG4gICAgICAgICAgICAgICAgXSwgeyBzY3JpcHRsZXZlbDogMCB9KVxuICAgICAgICAgICAgXSwgeyBsaW5ldGhpY2tuZXNzOiAwLCBudW1hbGlnbjogJ2xlZnQnLCBkZW5vbWFsaWduOiAncmlnaHQnIH0pXG4gICAgICAgIF0sIHsgZGlzcGxheXN0eWxlOiBkaXNwbGF5LCBzY3JpcHRsZXZlbDogMCB9KSk7XG4gICAgfSxcbiAgICBYTWF0aFN0cnV0OiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciBkZCA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lKTtcbiAgICAgICAgdmFyIGRoID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICBkaCA9IE1hdGh0b29sc1V0aWxfanNfMS5NYXRodG9vbHNVdGlsLnBsdXNPck1pbnVzKG5hbWUsIGRoKTtcbiAgICAgICAgZGQgPSBNYXRodG9vbHNVdGlsX2pzXzEuTWF0aHRvb2xzVXRpbC5wbHVzT3JNaW51cyhuYW1lLCBkZCB8fCBkaCk7XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnVGVYQXRvbScsIFtcbiAgICAgICAgICAgIHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21waGFudG9tJywgW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY3JlYXRlKCd0b2tlbicsICdtbycsIHsgc3RyZXRjaHk6IGZhbHNlIH0sICcoJylcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSwgeyB3aWR0aDogMCwgaGVpZ2h0OiBkaCArICdoZWlnaHQnLCBkZXB0aDogZGQgKyAnZGVwdGgnIH0pXG4gICAgICAgIF0sIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5PUkQgfSkpO1xuICAgIH0sXG4gICAgUHJlc2NyaXB0OiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciBzdXAgPSBNYXRodG9vbHNVdGlsX2pzXzEuTWF0aHRvb2xzVXRpbC5nZXRTY3JpcHQocGFyc2VyLCBuYW1lLCAnc3VwJyk7XG4gICAgICAgIHZhciBzdWIgPSBNYXRodG9vbHNVdGlsX2pzXzEuTWF0aHRvb2xzVXRpbC5nZXRTY3JpcHQocGFyc2VyLCBuYW1lLCAnc3ViJyk7XG4gICAgICAgIHZhciBiYXNlID0gTWF0aHRvb2xzVXRpbF9qc18xLk1hdGh0b29sc1V0aWwuZ2V0U2NyaXB0KHBhcnNlciwgbmFtZSwgJ2FyZycpO1xuICAgICAgICBpZiAoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzVHlwZShzdXAsICdub25lJykgJiYgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzVHlwZShzdWIsICdub25lJykpIHtcbiAgICAgICAgICAgIHBhcnNlci5QdXNoKGJhc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtbWwgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21tdWx0aXNjcmlwdHMnLCBbYmFzZV0pO1xuICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRyZW4obW1sKS5wdXNoKG51bGwsIG51bGwpO1xuICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuYXBwZW5kQ2hpbGRyZW4obW1sLCBbcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcHJlc2NyaXB0cycpLCBzdWIsIHN1cF0pO1xuICAgICAgICBtbWwuc2V0UHJvcGVydHkoJ2ZpeFByZXNjcmlwdCcsIHRydWUpO1xuICAgICAgICBwYXJzZXIuUHVzaChtbWwpO1xuICAgIH0sXG4gICAgTmV3VGFnRm9ybTogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgcmVuZXcpIHtcbiAgICAgICAgaWYgKHJlbmV3ID09PSB2b2lkIDApIHsgcmVuZXcgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgdGFncyA9IHBhcnNlci50YWdzO1xuICAgICAgICBpZiAoISgnbXRGb3JtYXRzJyBpbiB0YWdzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnVGFnc05vdE1UJywgJyUxIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhbXMgb3IgbWF0aHRvb2xzIHRhZ3MnLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkudHJpbSgpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdJbnZhbGlkVGFnRm9ybUlEJywgJ1RhZyBmb3JtIG5hbWUgY2FuXFwndCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXQgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSwgJycpO1xuICAgICAgICB2YXIgbGVmdCA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICBpZiAoIXJlbmV3ICYmIHRhZ3MubXRGb3JtYXRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0R1cGxpY2F0ZVRhZ0Zvcm0nLCAnRHVwbGljYXRlIHRhZyBmb3JtOiAlMScsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0YWdzLm10Rm9ybWF0cy5zZXQoaWQsIFtsZWZ0LCByaWdodCwgZm9ybWF0XSk7XG4gICAgfSxcbiAgICBVc2VUYWdGb3JtOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciB0YWdzID0gcGFyc2VyLnRhZ3M7XG4gICAgICAgIGlmICghKCdtdEZvcm1hdHMnIGluIHRhZ3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdUYWdzTm90TVQnLCAnJTEgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGFtcyBvciBtYXRodG9vbHMgdGFncycsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKS50cmltKCk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHRhZ3MubXRDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhZ3MubXRGb3JtYXRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ1VuZGVmaW5lZFRhZ0Zvcm0nLCAnVW5kZWZpbmVkIHRhZyBmb3JtOiAlMScsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0YWdzLm10Q3VycmVudCA9IHRhZ3MubXRGb3JtYXRzLmdldChpZCk7XG4gICAgfSxcbiAgICBTZXRPcHRpb25zOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5vcHRpb25zLm1hdGh0b29scztcbiAgICAgICAgaWYgKCFvcHRpb25zWydhbGxvdy1tYXRodG9vbHNzZXQnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnRm9yYmlkZGVuTWF0aHRvb2xzU2V0JywgJyUxIGlzIGRpc2FibGVkJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbG93ZWQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gJ3BhcmllZERlbGltaXRlcnMnICYmIGlkICE9PSAndGFnZm9ybXMnICYmIGlkICE9PSAnYWxsb3ctbWF0aHRvb2xzc2V0Jykge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhcmdzID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIga2V5cyA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQua2V5dmFsT3B0aW9ucyhhcmdzLCBhbGxvd2VkLCB0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMoa2V5cykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tpZF0gPSBrZXlzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBBcnJheTogQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0LkFycmF5LFxuICAgIE1hY3JvOiBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuTWFjcm8sXG4gICAgeEFycm93OiBBbXNNZXRob2RzX2pzXzEuQW1zTWV0aG9kcy54QXJyb3csXG4gICAgSGFuZGxlUmVmOiBBbXNNZXRob2RzX2pzXzEuQW1zTWV0aG9kcy5IYW5kbGVSZWYsXG4gICAgQW1zRXFuQXJyYXk6IEFtc01ldGhvZHNfanNfMS5BbXNNZXRob2RzLkFtc0VxbkFycmF5LFxuICAgIE1hY3JvV2l0aFRlbXBsYXRlOiBOZXdjb21tYW5kTWV0aG9kc19qc18xLmRlZmF1bHQuTWFjcm9XaXRoVGVtcGxhdGUsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0aHRvb2xzTWV0aG9kcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hdGh0b29sc1RhZ0Zvcm1hdCA9IHZvaWQgMDtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgVGFnc19qc18xID0gcmVxdWlyZShcIi4uL1RhZ3MuanNcIik7XG52YXIgdGFnSUQgPSAwO1xuZnVuY3Rpb24gTWF0aHRvb2xzVGFnRm9ybWF0KGNvbmZpZywgamF4KSB7XG4gICAgdmFyIHRhZ3MgPSBqYXgucGFyc2VPcHRpb25zLm9wdGlvbnMudGFncztcbiAgICBpZiAodGFncyAhPT0gJ2Jhc2UnICYmIGNvbmZpZy50YWdzLmhhc093blByb3BlcnR5KHRhZ3MpKSB7XG4gICAgICAgIFRhZ3NfanNfMS5UYWdzRmFjdG9yeS5hZGQodGFncywgY29uZmlnLnRhZ3NbdGFnc10pO1xuICAgIH1cbiAgICB2YXIgVGFnQ2xhc3MgPSBUYWdzX2pzXzEuVGFnc0ZhY3RvcnkuY3JlYXRlKGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy50YWdzKS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgVGFnRm9ybWF0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFRhZ0Zvcm1hdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVGFnRm9ybWF0KCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubXRGb3JtYXRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgX3RoaXMubXRDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBmb3JtcyA9IGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy5tYXRodG9vbHMudGFnZm9ybXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMoZm9ybXMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZm9ybXNbZm9ybV0pIHx8IGZvcm1zW2Zvcm1dLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSW52YWxpZFRhZ0Zvcm1EZWYnLCAnVGhlIHRhZyBmb3JtIGRlZmluaXRpb24gZm9yIFwiJTFcIiBzaG91bGQgYmUgYW4gYXJyYXkgZm8gdGhyZWUgc3RyaW5ncycsIGZvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm10Rm9ybWF0cy5zZXQoZm9ybSwgZm9ybXNbZm9ybV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBUYWdGb3JtYXQucHJvdG90eXBlLmZvcm1hdFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm10Q3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCh0aGlzLm10Q3VycmVudCwgMyksIGxlZnQgPSBfYVswXSwgcmlnaHQgPSBfYVsxXSwgZm9ybWF0ID0gX2FbMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmb3JtYXQgPyBcIlwiLmNvbmNhdChsZWZ0KS5jb25jYXQoZm9ybWF0LCBcIntcIikuY29uY2F0KHRhZywgXCJ9XCIpLmNvbmNhdChyaWdodCkgOiBcIlwiLmNvbmNhdChsZWZ0KS5jb25jYXQodGFnKS5jb25jYXQocmlnaHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmZvcm1hdFRhZy5jYWxsKHRoaXMsIHRhZyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUYWdGb3JtYXQ7XG4gICAgfShUYWdDbGFzcykpO1xuICAgIHRhZ0lEKys7XG4gICAgdmFyIHRhZ05hbWUgPSAnTWF0aHRvb2xzVGFncy0nICsgdGFnSUQ7XG4gICAgVGFnc19qc18xLlRhZ3NGYWN0b3J5LmFkZCh0YWdOYW1lLCBUYWdGb3JtYXQpO1xuICAgIGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy50YWdzID0gdGFnTmFtZTtcbn1cbmV4cG9ydHMuTWF0aHRvb2xzVGFnRm9ybWF0ID0gTWF0aHRvb2xzVGFnRm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0aHRvb2xzVGFncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF0aHRvb2xzVXRpbCA9IHZvaWQgMDtcbnZhciBCYXNlSXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuLi9iYXNlL0Jhc2VJdGVtcy5qc1wiKTtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBUZXhQYXJzZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4UGFyc2VyLmpzXCIpKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgU3ltYm9sX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sLmpzXCIpO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgTWF0aHRvb2xzTWV0aG9kc19qc18xID0gcmVxdWlyZShcIi4vTWF0aHRvb2xzTWV0aG9kcy5qc1wiKTtcbnZhciBNYXRodG9vbHNDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9NYXRodG9vbHNDb25maWd1cmF0aW9uLmpzXCIpO1xuZXhwb3J0cy5NYXRodG9vbHNVdGlsID0ge1xuICAgIHNldERpc3BsYXlMZXZlbDogZnVuY3Rpb24gKG1tbCwgc3R5bGUpIHtcbiAgICAgICAgaWYgKCFzdHlsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKCgwLCBPcHRpb25zX2pzXzEubG9va3VwKShzdHlsZSwge1xuICAgICAgICAgICAgJ1xcXFxkaXNwbGF5c3R5bGUnOiBbdHJ1ZSwgMF0sXG4gICAgICAgICAgICAnXFxcXHRleHRzdHlsZSc6IFtmYWxzZSwgMF0sXG4gICAgICAgICAgICAnXFxcXHNjcmlwdHN0eWxlJzogW2ZhbHNlLCAxXSxcbiAgICAgICAgICAgICdcXFxcc2NyaXB0c2NyaXB0c3R5bGUnOiBbZmFsc2UsIDJdXG4gICAgICAgIH0sIFtudWxsLCBudWxsXSksIDIpLCBkaXNwbGF5ID0gX2FbMF0sIHNjcmlwdCA9IF9hWzFdO1xuICAgICAgICBpZiAoZGlzcGxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbW1sLmF0dHJpYnV0ZXMuc2V0KCdkaXNwbGF5c3R5bGUnLCBkaXNwbGF5KTtcbiAgICAgICAgICAgIG1tbC5hdHRyaWJ1dGVzLnNldCgnc2NyaXB0bGV2ZWwnLCBzY3JpcHQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjaGVja0FsaWdubWVudDogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgICAgICB2YXIgdG9wID0gcGFyc2VyLnN0YWNrLlRvcCgpO1xuICAgICAgICBpZiAodG9wLmtpbmQgIT09IEJhc2VJdGVtc19qc18xLkVxbkFycmF5SXRlbS5wcm90b3R5cGUua2luZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTm90SW5BbGlnbm1lbnQnLCAnJTEgY2FuIG9ubHkgYmUgdXNlZCBpbiBhbGlnbWVudCBlbnZpcm9ubWVudHMnLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG4gICAgYWRkUGFpcmVkRGVsaW1zOiBmdW5jdGlvbiAoY29uZmlnLCBjcywgYXJncykge1xuICAgICAgICB2YXIgZGVsaW1zID0gY29uZmlnLmhhbmRsZXJzLnJldHJpZXZlKE1hdGh0b29sc0NvbmZpZ3VyYXRpb25fanNfMS5QQUlSRURERUxJTVMpO1xuICAgICAgICBkZWxpbXMuYWRkKGNzLCBuZXcgU3ltYm9sX2pzXzEuTWFjcm8oY3MsIE1hdGh0b29sc01ldGhvZHNfanNfMS5NYXRodG9vbHNNZXRob2RzLlBhaXJlZERlbGltaXRlcnMsIGFyZ3MpKTtcbiAgICB9LFxuICAgIHNwcmVhZExpbmVzOiBmdW5jdGlvbiAobXRhYmxlLCBzcHJlYWQpIHtcbiAgICAgICAgaWYgKCFtdGFibGUuaXNLaW5kKCdtdGFibGUnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJvd3NwYWNpbmcgPSBtdGFibGUuYXR0cmlidXRlcy5nZXQoJ3Jvd3NwYWNpbmcnKTtcbiAgICAgICAgaWYgKHJvd3NwYWNpbmcpIHtcbiAgICAgICAgICAgIHZhciBhZGRfMSA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuZGltZW4yZW0oc3ByZWFkKTtcbiAgICAgICAgICAgIHJvd3NwYWNpbmcgPSByb3dzcGFjaW5nXG4gICAgICAgICAgICAgICAgLnNwbGl0KC8gLylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LkVtKE1hdGgubWF4KDAsIFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuZGltZW4yZW0ocykgKyBhZGRfMSkpOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dzcGFjaW5nID0gc3ByZWFkO1xuICAgICAgICB9XG4gICAgICAgIG10YWJsZS5hdHRyaWJ1dGVzLnNldCgncm93c3BhY2luZycsIHJvd3NwYWNpbmcpO1xuICAgIH0sXG4gICAgcGx1c09yTWludXM6IGZ1bmN0aW9uIChuYW1lLCBuKSB7XG4gICAgICAgIG4gPSBuLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuLm1hdGNoKC9eWy0rXT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdOb3RBTnVtYmVyJywgJ0FyZ3VtZW50IHRvICUxIGlzIG5vdCBhIG51bWJlcicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobi5tYXRjaCgvXlstK10vKSA/IG4gOiAnKycgKyBuKTtcbiAgICB9LFxuICAgIGdldFNjcmlwdDogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgcG9zKSB7XG4gICAgICAgIHZhciBhcmcgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnRyaW1TcGFjZXMocGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKTtcbiAgICAgICAgaWYgKGFyZyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLm9wdGlvbnMubWF0aHRvb2xzW1wicHJlc2NyaXB0LVwiLmNvbmNhdChwb3MsIFwiLWZvcm1hdFwiKV07XG4gICAgICAgIGZvcm1hdCAmJiAoYXJnID0gXCJcIi5jb25jYXQoZm9ybWF0LCBcIntcIikuY29uY2F0KGFyZywgXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KGFyZywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRodG9vbHNVdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaGNoZW1Db25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgQmFzZU1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYmFzZS9CYXNlTWV0aG9kcy5qc1wiKSk7XG52YXIgQW1zTWV0aG9kc19qc18xID0gcmVxdWlyZShcIi4uL2Ftcy9BbXNNZXRob2RzLmpzXCIpO1xudmFyIG1oY2hlbVBhcnNlcl9qc18xID0gcmVxdWlyZShcIm1oY2hlbXBhcnNlci9kaXN0L21oY2hlbVBhcnNlci5qc1wiKTtcbnZhciBNaGNoZW1NZXRob2RzID0ge307XG5NaGNoZW1NZXRob2RzLk1hY3JvID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lk1hY3JvO1xuTWhjaGVtTWV0aG9kcy54QXJyb3cgPSBBbXNNZXRob2RzX2pzXzEuQW1zTWV0aG9kcy54QXJyb3c7XG5NaGNoZW1NZXRob2RzLk1hY2hpbmUgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBtYWNoaW5lKSB7XG4gICAgdmFyIGFyZyA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgdGV4O1xuICAgIHRyeSB7XG4gICAgICAgIHRleCA9IG1oY2hlbVBhcnNlcl9qc18xLm1oY2hlbVBhcnNlci50b1RleChhcmcsIG1hY2hpbmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoZXJyWzBdLCBlcnJbMV0pO1xuICAgIH1cbiAgICBwYXJzZXIuc3RyaW5nID0gdGV4ICsgcGFyc2VyLnN0cmluZy5zdWJzdHIocGFyc2VyLmkpO1xuICAgIHBhcnNlci5pID0gMDtcbn07XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnbWhjaGVtJywge1xuICAgIGNlOiBbJ01hY2hpbmUnLCAnY2UnXSxcbiAgICBwdTogWydNYWNoaW5lJywgJ3B1J10sXG4gICAgbG9uZ3JpZ2h0bGVmdGhhcnBvb25zOiBbXG4gICAgICAgICdNYWNybycsXG4gICAgICAgICdcXFxcc3RhY2tyZWx7XFxcXHRleHRzdHlsZXstfVxcXFwhXFxcXCF7XFxcXHJpZ2h0aGFycG9vbnVwfX17XFxcXHNtYXNoe3tcXFxcbGVmdGhhcnBvb25kb3dufVxcXFwhXFxcXCF7LX19fSdcbiAgICBdLFxuICAgIGxvbmdSaWdodGxlZnRoYXJwb29uczogW1xuICAgICAgICAnTWFjcm8nLFxuICAgICAgICAnXFxcXHN0YWNrcmVse1xcXFx0ZXh0c3R5bGV7LX1cXFxcIVxcXFwhe1xcXFxyaWdodGhhcnBvb251cH19e1xcXFxzbWFzaHtcXFxcbGVmdGhhcnBvb25kb3dufX0nXG4gICAgXSxcbiAgICBsb25nTGVmdHJpZ2h0aGFycG9vbnM6IFtcbiAgICAgICAgJ01hY3JvJyxcbiAgICAgICAgJ1xcXFxzdGFja3JlbHtcXFxcdGV4dHN0eWxlXFxcXHZwaGFudG9te3stfX17XFxcXHJpZ2h0aGFycG9vbnVwfX17XFxcXHNtYXNoe3tcXFxcbGVmdGhhcnBvb25kb3dufVxcXFwhXFxcXCF7LX19fSdcbiAgICBdLFxuICAgIGxvbmdsZWZ0cmlnaHRhcnJvd3M6IFtcbiAgICAgICAgJ01hY3JvJyxcbiAgICAgICAgJ1xcXFxzdGFja3JlbHtcXFxcbG9uZ3JpZ2h0YXJyb3d9e1xcXFxzbWFzaHtcXFxcbG9uZ2xlZnRhcnJvd31cXFxcUnVsZXswcHh9ey4yNWVtfXswcHh9fSdcbiAgICBdLFxuICAgIHRyaXBsZWRhc2g6IFtcbiAgICAgICAgJ01hY3JvJyxcbiAgICAgICAgJ1xcXFx2cGhhbnRvbXstfVxcXFxyYWlzZTJtdXtcXFxca2VybjJtdVxcXFx0aW55XFxcXHRleHR7LX1cXFxca2VybjFtdVxcXFx0ZXh0ey19XFxcXGtlcm4xbXVcXFxcdGV4dHstfVxcXFxrZXJuMm11fSdcbiAgICBdLFxuICAgIHhsZWZ0cmlnaHRhcnJvdzogWyd4QXJyb3cnLCAweDIxOTQsIDYsIDZdLFxuICAgIHhyaWdodGxlZnRoYXJwb29uczogWyd4QXJyb3cnLCAweDIxQ0MsIDUsIDddLFxuICAgIHhSaWdodGxlZnRoYXJwb29uczogWyd4QXJyb3cnLCAweDIxQ0MsIDUsIDddLFxuICAgIHhMZWZ0cmlnaHRoYXJwb29uczogWyd4QXJyb3cnLCAweDIxQ0MsIDUsIDddXG59LCBNaGNoZW1NZXRob2RzKTtcbmV4cG9ydHMuTWhjaGVtQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgnbWhjaGVtJywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ21oY2hlbSddIH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NaGNoZW1Db25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ld2NvbW1hbmRDb25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIE5ld2NvbW1hbmRJdGVtc19qc18xID0gcmVxdWlyZShcIi4vTmV3Y29tbWFuZEl0ZW1zLmpzXCIpO1xudmFyIE5ld2NvbW1hbmRVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTmV3Y29tbWFuZFV0aWwuanNcIikpO1xucmVxdWlyZShcIi4vTmV3Y29tbWFuZE1hcHBpbmdzLmpzXCIpO1xudmFyIFBhcnNlTWV0aG9kc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZU1ldGhvZHMuanNcIikpO1xudmFyIHNtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIikpO1xudmFyIGluaXQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgbmV3IHNtLkRlbGltaXRlck1hcChOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuTkVXX0RFTElNSVRFUiwgUGFyc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5kZWxpbWl0ZXIsIHt9KTtcbiAgICBuZXcgc20uQ29tbWFuZE1hcChOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuTkVXX0NPTU1BTkQsIHt9LCB7fSk7XG4gICAgbmV3IHNtLkVudmlyb25tZW50TWFwKE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5ORVdfRU5WSVJPTk1FTlQsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQuZW52aXJvbm1lbnQsIHt9LCB7fSk7XG4gICAgY29uZmlnLmFwcGVuZChDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5sb2NhbCh7IGhhbmRsZXI6IHsgY2hhcmFjdGVyOiBbXSxcbiAgICAgICAgICAgIGRlbGltaXRlcjogW05ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5ORVdfREVMSU1JVEVSXSxcbiAgICAgICAgICAgIG1hY3JvOiBbTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0Lk5FV19ERUxJTUlURVIsXG4gICAgICAgICAgICAgICAgTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0Lk5FV19DT01NQU5EXSxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBbTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0Lk5FV19FTlZJUk9OTUVOVF1cbiAgICAgICAgfSxcbiAgICAgICAgcHJpb3JpdHk6IC0xIH0pKTtcbn07XG5leHBvcnRzLk5ld2NvbW1hbmRDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCduZXdjb21tYW5kJywge1xuICAgIGhhbmRsZXI6IHtcbiAgICAgICAgbWFjcm86IFsnTmV3Y29tbWFuZC1tYWNyb3MnXVxuICAgIH0sXG4gICAgaXRlbXM6IChfYSA9IHt9LFxuICAgICAgICBfYVtOZXdjb21tYW5kSXRlbXNfanNfMS5CZWdpbkVudkl0ZW0ucHJvdG90eXBlLmtpbmRdID0gTmV3Y29tbWFuZEl0ZW1zX2pzXzEuQmVnaW5FbnZJdGVtLFxuICAgICAgICBfYSksXG4gICAgb3B0aW9uczogeyBtYXhNYWNyb3M6IDEwMDAgfSxcbiAgICBpbml0OiBpbml0XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ld2NvbW1hbmRDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVnaW5FbnZJdGVtID0gdm9pZCAwO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBTdGFja0l0ZW1fanNfMSA9IHJlcXVpcmUoXCIuLi9TdGFja0l0ZW0uanNcIik7XG52YXIgQmVnaW5FbnZJdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmVnaW5FbnZJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJlZ2luRW52SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmVnaW5FbnZJdGVtLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JlZ2luRW52JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCZWdpbkVudkl0ZW0ucHJvdG90eXBlLCBcImlzT3BlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCZWdpbkVudkl0ZW0ucHJvdG90eXBlLmNoZWNrSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmlzS2luZCgnZW5kJykpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmdldE5hbWUoKSAhPT0gdGhpcy5nZXROYW1lKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdFbnZCYWRFbmQnLCAnXFxcXGJlZ2lueyUxfSBlbmRlZCB3aXRoIFxcXFxlbmR7JTJ9JywgdGhpcy5nZXROYW1lKCksIGl0ZW0uZ2V0TmFtZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbW3RoaXMuZmFjdG9yeS5jcmVhdGUoJ21tbCcsIHRoaXMudG9NbWwoKSldLCB0cnVlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5pc0tpbmQoJ3N0b3AnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnRW52TWlzc2luZ0VuZCcsICdNaXNzaW5nIFxcXFxlbmR7JTF9JywgdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNoZWNrSXRlbS5jYWxsKHRoaXMsIGl0ZW0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJlZ2luRW52SXRlbTtcbn0oU3RhY2tJdGVtX2pzXzEuQmFzZUl0ZW0pKTtcbmV4cG9ydHMuQmVnaW5FbnZJdGVtID0gQmVnaW5FbnZJdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV3Y29tbWFuZEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE5ld2NvbW1hbmRNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTmV3Y29tbWFuZE1ldGhvZHMuanNcIikpO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdOZXdjb21tYW5kLW1hY3JvcycsIHtcbiAgICBuZXdjb21tYW5kOiAnTmV3Q29tbWFuZCcsXG4gICAgcmVuZXdjb21tYW5kOiAnTmV3Q29tbWFuZCcsXG4gICAgbmV3ZW52aXJvbm1lbnQ6ICdOZXdFbnZpcm9ubWVudCcsXG4gICAgcmVuZXdlbnZpcm9ubWVudDogJ05ld0Vudmlyb25tZW50JyxcbiAgICBkZWY6ICdNYWNyb0RlZicsXG4gICAgJ2xldCc6ICdMZXQnXG59LCBOZXdjb21tYW5kTWV0aG9kc19qc18xLmRlZmF1bHQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV3Y29tbWFuZE1hcHBpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4RXJyb3IuanNcIikpO1xudmFyIHNtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIikpO1xudmFyIEJhc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Jhc2UvQmFzZU1ldGhvZHMuanNcIikpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIE5ld2NvbW1hbmRVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTmV3Y29tbWFuZFV0aWwuanNcIikpO1xudmFyIE5ld2NvbW1hbmRNZXRob2RzID0ge307XG5OZXdjb21tYW5kTWV0aG9kcy5OZXdDb21tYW5kID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBjcyA9IE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5HZXRDc05hbWVBcmd1bWVudChwYXJzZXIsIG5hbWUpO1xuICAgIHZhciBuID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldEFyZ0NvdW50KHBhcnNlciwgbmFtZSk7XG4gICAgdmFyIG9wdCA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lKTtcbiAgICB2YXIgZGVmID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5hZGRNYWNybyhwYXJzZXIsIGNzLCBOZXdjb21tYW5kTWV0aG9kcy5NYWNybywgW2RlZiwgbiwgb3B0XSk7XG59O1xuTmV3Y29tbWFuZE1ldGhvZHMuTmV3RW52aXJvbm1lbnQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGVudiA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQudHJpbVNwYWNlcyhwYXJzZXIuR2V0QXJndW1lbnQobmFtZSkpO1xuICAgIHZhciBuID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldEFyZ0NvdW50KHBhcnNlciwgbmFtZSk7XG4gICAgdmFyIG9wdCA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lKTtcbiAgICB2YXIgYmRlZiA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgZWRlZiA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICBOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuYWRkRW52aXJvbm1lbnQocGFyc2VyLCBlbnYsIE5ld2NvbW1hbmRNZXRob2RzLkJlZ2luRW52LCBbdHJ1ZSwgYmRlZiwgZWRlZiwgbiwgb3B0XSk7XG59O1xuTmV3Y29tbWFuZE1ldGhvZHMuTWFjcm9EZWYgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGNzID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldENTbmFtZShwYXJzZXIsIG5hbWUpO1xuICAgIHZhciBwYXJhbXMgPSBOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuR2V0VGVtcGxhdGUocGFyc2VyLCBuYW1lLCAnXFxcXCcgKyBjcyk7XG4gICAgdmFyIGRlZiA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAhKHBhcmFtcyBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgIE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5hZGRNYWNybyhwYXJzZXIsIGNzLCBOZXdjb21tYW5kTWV0aG9kcy5NYWNybywgW2RlZiwgcGFyYW1zXSkgOlxuICAgICAgICBOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuYWRkTWFjcm8ocGFyc2VyLCBjcywgTmV3Y29tbWFuZE1ldGhvZHMuTWFjcm9XaXRoVGVtcGxhdGUsIFtkZWZdLmNvbmNhdChwYXJhbXMpKTtcbn07XG5OZXdjb21tYW5kTWV0aG9kcy5MZXQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIGNzID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldENTbmFtZShwYXJzZXIsIG5hbWUpO1xuICAgIHZhciBjID0gcGFyc2VyLkdldE5leHQoKTtcbiAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgIHBhcnNlci5pKys7XG4gICAgICAgIGMgPSBwYXJzZXIuR2V0TmV4dCgpO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlcnMgPSBwYXJzZXIuY29uZmlndXJhdGlvbi5oYW5kbGVycztcbiAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIG5hbWUgPSBOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuR2V0Q1NuYW1lKHBhcnNlciwgbmFtZSk7XG4gICAgICAgIHZhciBtYWNyb18xID0gaGFuZGxlcnMuZ2V0KCdkZWxpbWl0ZXInKS5sb29rdXAoJ1xcXFwnICsgbmFtZSk7XG4gICAgICAgIGlmIChtYWNyb18xKSB7XG4gICAgICAgICAgICBOZXdjb21tYW5kVXRpbF9qc18xLmRlZmF1bHQuYWRkRGVsaW1pdGVyKHBhcnNlciwgJ1xcXFwnICsgY3MsIG1hY3JvXzEuY2hhciwgbWFjcm9fMS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwXzEgPSBoYW5kbGVycy5nZXQoJ21hY3JvJykuYXBwbGljYWJsZShuYW1lKTtcbiAgICAgICAgaWYgKCFtYXBfMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBfMSBpbnN0YW5jZW9mIHNtLk1hY3JvTWFwKSB7XG4gICAgICAgICAgICB2YXIgbWFjcm9fMiA9IG1hcF8xLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5hZGRNYWNybyhwYXJzZXIsIGNzLCBtYWNyb18yLmZ1bmMsIG1hY3JvXzIuYXJncywgbWFjcm9fMi5zeW1ib2wpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hY3JvXzEgPSBtYXBfMS5sb29rdXAobmFtZSk7XG4gICAgICAgIHZhciBuZXdBcmdzID0gTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LmRpc2Fzc2VtYmxlU3ltYm9sKGNzLCBtYWNyb18xKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGZ1bmN0aW9uIChwLCBfY3MpIHtcbiAgICAgICAgICAgIHZhciByZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHJlc3RbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ltYiA9IE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5hc3NlbWJsZVN5bWJvbChyZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBtYXBfMS5wYXJzZXIocCwgc3ltYik7XG4gICAgICAgIH07XG4gICAgICAgIE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5hZGRNYWNybyhwYXJzZXIsIGNzLCBtZXRob2QsIG5ld0FyZ3MpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcnNlci5pKys7XG4gICAgdmFyIG1hY3JvID0gaGFuZGxlcnMuZ2V0KCdkZWxpbWl0ZXInKS5sb29rdXAoYyk7XG4gICAgaWYgKG1hY3JvKSB7XG4gICAgICAgIE5ld2NvbW1hbmRVdGlsX2pzXzEuZGVmYXVsdC5hZGREZWxpbWl0ZXIocGFyc2VyLCAnXFxcXCcgKyBjcywgbWFjcm8uY2hhciwgbWFjcm8uYXR0cmlidXRlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LmFkZE1hY3JvKHBhcnNlciwgY3MsIE5ld2NvbW1hbmRNZXRob2RzLk1hY3JvLCBbY10pO1xufTtcbk5ld2NvbW1hbmRNZXRob2RzLk1hY3JvV2l0aFRlbXBsYXRlID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgdGV4dCwgbikge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwYXJhbXNbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBhcmdDb3VudCA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICBpZiAoYXJnQ291bnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgcGFyc2VyLkdldE5leHQoKTtcbiAgICAgICAgaWYgKHBhcmFtc1swXSAmJiAhTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0Lk1hdGNoUGFyYW0ocGFyc2VyLCBwYXJhbXNbMF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNaXNtYXRjaFVzZURlZicsICdVc2Ugb2YgJTEgZG9lc25cXCd0IG1hdGNoIGl0cyBkZWZpbml0aW9uJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goTmV3Y29tbWFuZFV0aWxfanNfMS5kZWZhdWx0LkdldFBhcmFtZXRlcihwYXJzZXIsIG5hbWUsIHBhcmFtc1tpICsgMV0pKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5zdWJzdGl0dXRlQXJncyhwYXJzZXIsIGFyZ3MsIHRleHQpO1xuICAgIH1cbiAgICBwYXJzZXIuc3RyaW5nID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5hZGRBcmdzKHBhcnNlciwgdGV4dCwgcGFyc2VyLnN0cmluZy5zbGljZShwYXJzZXIuaSkpO1xuICAgIHBhcnNlci5pID0gMDtcbiAgICBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmNoZWNrTWF4TWFjcm9zKHBhcnNlcik7XG59O1xuTmV3Y29tbWFuZE1ldGhvZHMuQmVnaW5FbnYgPSBmdW5jdGlvbiAocGFyc2VyLCBiZWdpbiwgYmRlZiwgZWRlZiwgbiwgZGVmKSB7XG4gICAgaWYgKGJlZ2luLmdldFByb3BlcnR5KCdlbmQnKSAmJiBwYXJzZXIuc3RhY2suZW52WydjbG9zaW5nJ10gPT09IGJlZ2luLmdldE5hbWUoKSkge1xuICAgICAgICBkZWxldGUgcGFyc2VyLnN0YWNrLmVudlsnY2xvc2luZyddO1xuICAgICAgICB2YXIgcmVzdCA9IHBhcnNlci5zdHJpbmcuc2xpY2UocGFyc2VyLmkpO1xuICAgICAgICBwYXJzZXIuc3RyaW5nID0gZWRlZjtcbiAgICAgICAgcGFyc2VyLmkgPSAwO1xuICAgICAgICBwYXJzZXIuUGFyc2UoKTtcbiAgICAgICAgcGFyc2VyLnN0cmluZyA9IHJlc3Q7XG4gICAgICAgIHBhcnNlci5pID0gMDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2VuZCcpLnNldFByb3BlcnR5KCduYW1lJywgYmVnaW4uZ2V0TmFtZSgpKTtcbiAgICB9XG4gICAgaWYgKG4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgaWYgKGRlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSBwYXJzZXIuR2V0QnJhY2tldHMoJ1xcXFxiZWdpbnsnICsgYmVnaW4uZ2V0TmFtZSgpICsgJ30nKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChvcHRpb25hbCA9PSBudWxsID8gZGVmIDogb3B0aW9uYWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlci5HZXRBcmd1bWVudCgnXFxcXGJlZ2lueycgKyBiZWdpbi5nZXROYW1lKCkgKyAnfScpKTtcbiAgICAgICAgfVxuICAgICAgICBiZGVmID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5zdWJzdGl0dXRlQXJncyhwYXJzZXIsIGFyZ3MsIGJkZWYpO1xuICAgICAgICBlZGVmID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5zdWJzdGl0dXRlQXJncyhwYXJzZXIsIFtdLCBlZGVmKTtcbiAgICB9XG4gICAgcGFyc2VyLnN0cmluZyA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuYWRkQXJncyhwYXJzZXIsIGJkZWYsIHBhcnNlci5zdHJpbmcuc2xpY2UocGFyc2VyLmkpKTtcbiAgICBwYXJzZXIuaSA9IDA7XG4gICAgcmV0dXJuIHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2JlZ2luRW52Jykuc2V0UHJvcGVydHkoJ25hbWUnLCBiZWdpbi5nZXROYW1lKCkpO1xufTtcbk5ld2NvbW1hbmRNZXRob2RzLk1hY3JvID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lk1hY3JvO1xuZXhwb3J0cy5kZWZhdWx0ID0gTmV3Y29tbWFuZE1ldGhvZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXdjb21tYW5kTWV0aG9kcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYXJzZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgU3ltYm9sX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sLmpzXCIpO1xudmFyIE5ld2NvbW1hbmRVdGlsO1xuKGZ1bmN0aW9uIChOZXdjb21tYW5kVXRpbCkge1xuICAgIGZ1bmN0aW9uIGRpc2Fzc2VtYmxlU3ltYm9sKG5hbWUsIHN5bWJvbCkge1xuICAgICAgICB2YXIgbmV3QXJncyA9IFtuYW1lLCBzeW1ib2wuY2hhcl07XG4gICAgICAgIGlmIChzeW1ib2wuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN5bWJvbC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgbmV3QXJncy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgbmV3QXJncy5wdXNoKHN5bWJvbC5hdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBcmdzO1xuICAgIH1cbiAgICBOZXdjb21tYW5kVXRpbC5kaXNhc3NlbWJsZVN5bWJvbCA9IGRpc2Fzc2VtYmxlU3ltYm9sO1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlU3ltYm9sKGFyZ3MpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY2hhciA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgIGF0dHJzW2FyZ3NbaV1dID0gYXJnc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2xfanNfMS5TeW1ib2wobmFtZSwgY2hhciwgYXR0cnMpO1xuICAgIH1cbiAgICBOZXdjb21tYW5kVXRpbC5hc3NlbWJsZVN5bWJvbCA9IGFzc2VtYmxlU3ltYm9sO1xuICAgIGZ1bmN0aW9uIEdldENTbmFtZShwYXJzZXIsIGNtZCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgICAgIGlmIChjICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdDUycsICclMSBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgY29udHJvbCBzZXF1ZW5jZScsIGNtZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNzID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC50cmltU3BhY2VzKHBhcnNlci5HZXRBcmd1bWVudChjbWQpKTtcbiAgICAgICAgcmV0dXJuIGNzLnN1YnN0cigxKTtcbiAgICB9XG4gICAgTmV3Y29tbWFuZFV0aWwuR2V0Q1NuYW1lID0gR2V0Q1NuYW1lO1xuICAgIGZ1bmN0aW9uIEdldENzTmFtZUFyZ3VtZW50KHBhcnNlciwgbmFtZSkge1xuICAgICAgICB2YXIgY3MgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnRyaW1TcGFjZXMocGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKTtcbiAgICAgICAgaWYgKGNzLmNoYXJBdCgwKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNzLm1hdGNoKC9eKC58W2Etel0rKSQvaSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0lsbGVnYWxDb250cm9sU2VxdWVuY2VOYW1lJywgJ0lsbGVnYWwgY29udHJvbCBzZXF1ZW5jZSBuYW1lIGZvciAlMScsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcztcbiAgICB9XG4gICAgTmV3Y29tbWFuZFV0aWwuR2V0Q3NOYW1lQXJndW1lbnQgPSBHZXRDc05hbWVBcmd1bWVudDtcbiAgICBmdW5jdGlvbiBHZXRBcmdDb3VudChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSk7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBuID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC50cmltU3BhY2VzKG4pO1xuICAgICAgICAgICAgaWYgKCFuLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSWxsZWdhbFBhcmFtTnVtYmVyJywgJ0lsbGVnYWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluICUxJywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIE5ld2NvbW1hbmRVdGlsLkdldEFyZ0NvdW50ID0gR2V0QXJnQ291bnQ7XG4gICAgZnVuY3Rpb24gR2V0VGVtcGxhdGUocGFyc2VyLCBjbWQsIGNzKSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VyLkdldE5leHQoKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIHZhciBpID0gcGFyc2VyLmk7XG4gICAgICAgIHdoaWxlIChwYXJzZXIuaSA8IHBhcnNlci5zdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjID0gcGFyc2VyLkdldE5leHQoKTtcbiAgICAgICAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gcGFyc2VyLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW25dID0gcGFyc2VyLnN0cmluZy5zdWJzdHIoaSwgcGFyc2VyLmkgLSBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYyA9IHBhcnNlci5zdHJpbmcuY2hhckF0KCsrcGFyc2VyLmkpO1xuICAgICAgICAgICAgICAgIGlmICghYy5tYXRjaCgvXlsxLTldJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0NhbnRVc2VIYXNoMicsICdJbGxlZ2FsIHVzZSBvZiAjIGluIHRlbXBsYXRlIGZvciAlMScsIGNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KGMpICE9PSArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnU2VxdWVudGlhbFBhcmFtJywgJ1BhcmFtZXRlcnMgZm9yICUxIG11c3QgYmUgbnVtYmVyZWQgc2VxdWVudGlhbGx5JywgY3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpID0gcGFyc2VyLmkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IHBhcnNlci5pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tuXSA9IHBhcnNlci5zdHJpbmcuc3Vic3RyKGksIHBhcnNlci5pIC0gaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW24udG9TdHJpbmcoKV0uY29uY2F0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdSZXBsYWNlbWVudFN0cmluZycsICdNaXNzaW5nIHJlcGxhY2VtZW50IHN0cmluZyBmb3IgZGVmaW5pdGlvbiBvZiAlMScsIGNtZCk7XG4gICAgfVxuICAgIE5ld2NvbW1hbmRVdGlsLkdldFRlbXBsYXRlID0gR2V0VGVtcGxhdGU7XG4gICAgZnVuY3Rpb24gR2V0UGFyYW1ldGVyKHBhcnNlciwgbmFtZSwgcGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBwYXJzZXIuaTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgaGFzQnJhY2VzID0gMDtcbiAgICAgICAgd2hpbGUgKHBhcnNlci5pIDwgcGFyc2VyLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gcGFyc2VyLnN0cmluZy5jaGFyQXQocGFyc2VyLmkpO1xuICAgICAgICAgICAgaWYgKGMgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuaSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNCcmFjZXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgICAgICAgICAgaiA9IHBhcnNlci5pIC0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGNoUGFyYW0ocGFyc2VyLCBwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaiAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyLnN0cmluZy5zdWJzdHIoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBoYXNCcmFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhcnNlci5zdHJpbmcuc3Vic3RyKHBhcnNlci5pKS5tYXRjaCgvW2Etel0rfC4vaSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5pICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaiA9IHBhcnNlci5pIC0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBoYXNCcmFjZXMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ1J1bmF3YXlBcmd1bWVudCcsICdSdW5hd2F5IGFyZ3VtZW50IGZvciAlMT8nLCBuYW1lKTtcbiAgICB9XG4gICAgTmV3Y29tbWFuZFV0aWwuR2V0UGFyYW1ldGVyID0gR2V0UGFyYW1ldGVyO1xuICAgIGZ1bmN0aW9uIE1hdGNoUGFyYW0ocGFyc2VyLCBwYXJhbSkge1xuICAgICAgICBpZiAocGFyc2VyLnN0cmluZy5zdWJzdHIocGFyc2VyLmksIHBhcmFtLmxlbmd0aCkgIT09IHBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0ubWF0Y2goL1xcXFxbYS16XSskL2kpICYmXG4gICAgICAgICAgICBwYXJzZXIuc3RyaW5nLmNoYXJBdChwYXJzZXIuaSArIHBhcmFtLmxlbmd0aCkubWF0Y2goL1thLXpdL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuaSArPSBwYXJhbS5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBOZXdjb21tYW5kVXRpbC5NYXRjaFBhcmFtID0gTWF0Y2hQYXJhbTtcbiAgICBmdW5jdGlvbiBhZGREZWxpbWl0ZXIocGFyc2VyLCBjcywgY2hhciwgYXR0cikge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBwYXJzZXIuY29uZmlndXJhdGlvbi5oYW5kbGVycztcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVycy5yZXRyaWV2ZShOZXdjb21tYW5kVXRpbC5ORVdfREVMSU1JVEVSKTtcbiAgICAgICAgaGFuZGxlci5hZGQoY3MsIG5ldyBTeW1ib2xfanNfMS5TeW1ib2woY3MsIGNoYXIsIGF0dHIpKTtcbiAgICB9XG4gICAgTmV3Y29tbWFuZFV0aWwuYWRkRGVsaW1pdGVyID0gYWRkRGVsaW1pdGVyO1xuICAgIGZ1bmN0aW9uIGFkZE1hY3JvKHBhcnNlciwgY3MsIGZ1bmMsIGF0dHIsIHN5bWJvbCkge1xuICAgICAgICBpZiAoc3ltYm9sID09PSB2b2lkIDApIHsgc3ltYm9sID0gJyc7IH1cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gcGFyc2VyLmNvbmZpZ3VyYXRpb24uaGFuZGxlcnM7XG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnMucmV0cmlldmUoTmV3Y29tbWFuZFV0aWwuTkVXX0NPTU1BTkQpO1xuICAgICAgICBoYW5kbGVyLmFkZChjcywgbmV3IFN5bWJvbF9qc18xLk1hY3JvKHN5bWJvbCA/IHN5bWJvbCA6IGNzLCBmdW5jLCBhdHRyKSk7XG4gICAgfVxuICAgIE5ld2NvbW1hbmRVdGlsLmFkZE1hY3JvID0gYWRkTWFjcm87XG4gICAgZnVuY3Rpb24gYWRkRW52aXJvbm1lbnQocGFyc2VyLCBlbnYsIGZ1bmMsIGF0dHIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gcGFyc2VyLmNvbmZpZ3VyYXRpb24uaGFuZGxlcnM7XG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnMucmV0cmlldmUoTmV3Y29tbWFuZFV0aWwuTkVXX0VOVklST05NRU5UKTtcbiAgICAgICAgaGFuZGxlci5hZGQoZW52LCBuZXcgU3ltYm9sX2pzXzEuTWFjcm8oZW52LCBmdW5jLCBhdHRyKSk7XG4gICAgfVxuICAgIE5ld2NvbW1hbmRVdGlsLmFkZEVudmlyb25tZW50ID0gYWRkRW52aXJvbm1lbnQ7XG4gICAgTmV3Y29tbWFuZFV0aWwuTkVXX0RFTElNSVRFUiA9ICduZXctRGVsaW1pdGVyJztcbiAgICBOZXdjb21tYW5kVXRpbC5ORVdfQ09NTUFORCA9ICduZXctQ29tbWFuZCc7XG4gICAgTmV3Y29tbWFuZFV0aWwuTkVXX0VOVklST05NRU5UID0gJ25ldy1FbnZpcm9ubWVudCc7XG59KShOZXdjb21tYW5kVXRpbCB8fCAoTmV3Y29tbWFuZFV0aWwgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTmV3Y29tbWFuZFV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXdjb21tYW5kVXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm9FcnJvcnNDb25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xuZnVuY3Rpb24gbm9FcnJvcnMoZmFjdG9yeSwgbWVzc2FnZSwgX2lkLCBleHByKSB7XG4gICAgdmFyIG10ZXh0ID0gZmFjdG9yeS5jcmVhdGUoJ3Rva2VuJywgJ210ZXh0Jywge30sIGV4cHIucmVwbGFjZSgvXFxuL2csICcgJykpO1xuICAgIHZhciBlcnJvciA9IGZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ21lcnJvcicsIFttdGV4dF0sIHsgJ2RhdGEtbWp4LWVycm9yJzogbWVzc2FnZSwgdGl0bGU6IG1lc3NhZ2UgfSk7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5Ob0Vycm9yc0NvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ25vZXJyb3JzJywgeyBub2RlczogeyAnZXJyb3InOiBub0Vycm9ycyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9FcnJvcnNDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob1VuZGVmaW5lZENvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG5mdW5jdGlvbiBub1VuZGVmaW5lZChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgdGV4dE5vZGUgPSBwYXJzZXIuY3JlYXRlKCd0ZXh0JywgJ1xcXFwnICsgbmFtZSk7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIub3B0aW9ucy5ub3VuZGVmaW5lZCB8fCB7fTtcbiAgICB2YXIgZGVmID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhbJ2NvbG9yJywgJ2JhY2tncm91bmQnLCAnc2l6ZSddKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2MudmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBkZWZbJ21hdGgnICsgaWRdID0gb3B0aW9uc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHBhcnNlci5QdXNoKHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXRleHQnLCBbXSwgZGVmLCB0ZXh0Tm9kZSkpO1xufVxuZXhwb3J0cy5Ob1VuZGVmaW5lZENvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ25vdW5kZWZpbmVkJywge1xuICAgIGZhbGxiYWNrOiB7IG1hY3JvOiBub1VuZGVmaW5lZCB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgbm91bmRlZmluZWQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmVkJyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICcnLFxuICAgICAgICAgICAgc2l6ZTogJydcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJpb3JpdHk6IDNcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9VbmRlZmluZWRDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QaHlzaWNzQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBQaHlzaWNzSXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuL1BoeXNpY3NJdGVtcy5qc1wiKTtcbnJlcXVpcmUoXCIuL1BoeXNpY3NNYXBwaW5ncy5qc1wiKTtcbmV4cG9ydHMuUGh5c2ljc0NvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ3BoeXNpY3MnLCB7XG4gICAgaGFuZGxlcjoge1xuICAgICAgICBtYWNybzogW1xuICAgICAgICAgICAgJ1BoeXNpY3MtYXV0b21hdGljLWJyYWNpbmctbWFjcm9zJyxcbiAgICAgICAgICAgICdQaHlzaWNzLXZlY3Rvci1tYWNyb3MnLFxuICAgICAgICAgICAgJ1BoeXNpY3MtdmVjdG9yLW1vJyxcbiAgICAgICAgICAgICdQaHlzaWNzLXZlY3Rvci1taScsXG4gICAgICAgICAgICAnUGh5c2ljcy1kZXJpdmF0aXZlLW1hY3JvcycsXG4gICAgICAgICAgICAnUGh5c2ljcy1leHByZXNzaW9ucy1tYWNyb3MnLFxuICAgICAgICAgICAgJ1BoeXNpY3MtcXVpY2stcXVhZC1tYWNyb3MnLFxuICAgICAgICAgICAgJ1BoeXNpY3MtYnJhLWtldC1tYWNyb3MnLFxuICAgICAgICAgICAgJ1BoeXNpY3MtbWF0cml4LW1hY3JvcydcbiAgICAgICAgXSxcbiAgICAgICAgY2hhcmFjdGVyOiBbJ1BoeXNpY3MtY2hhcmFjdGVycyddLFxuICAgICAgICBlbnZpcm9ubWVudDogWydQaHlzaWNzLWF1eC1lbnZzJ11cbiAgICB9LFxuICAgIGl0ZW1zOiAoX2EgPSB7fSxcbiAgICAgICAgX2FbUGh5c2ljc0l0ZW1zX2pzXzEuQXV0b09wZW4ucHJvdG90eXBlLmtpbmRdID0gUGh5c2ljc0l0ZW1zX2pzXzEuQXV0b09wZW4sXG4gICAgICAgIF9hKSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBoeXNpY3M6IHtcbiAgICAgICAgICAgIGl0YWxpY2RpZmY6IGZhbHNlLFxuICAgICAgICAgICAgYXJyb3dkZWw6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBoeXNpY3NDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXV0b09wZW4gPSB2b2lkIDA7XG52YXIgU3RhY2tJdGVtX2pzXzEgPSByZXF1aXJlKFwiLi4vU3RhY2tJdGVtLmpzXCIpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIE5vZGVVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL05vZGVVdGlsLmpzXCIpKTtcbnZhciBUZXhQYXJzZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4UGFyc2VyLmpzXCIpKTtcbnZhciBBdXRvT3BlbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1dG9PcGVuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1dG9PcGVuKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3BlbkNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXV0b09wZW4ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXV0byBvcGVuJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRvT3Blbi5wcm90b3R5cGUsIFwiaXNPcGVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEF1dG9PcGVuLnByb3RvdHlwZS50b01tbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXMuZmFjdG9yeS5jb25maWd1cmF0aW9uLnBhcnNlcjtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5nZXRQcm9wZXJ0eSgncmlnaHQnKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UHJvcGVydHkoJ3NtYXNoJykpIHtcbiAgICAgICAgICAgIHZhciBtbWxfMSA9IF9zdXBlci5wcm90b3R5cGUudG9NbWwuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzbWFzaCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXBhZGRlZCcsIFttbWxfMV0sIHsgaGVpZ2h0OiAwLCBkZXB0aDogMCB9KTtcbiAgICAgICAgICAgIHRoaXMuQ2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuUHVzaChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ1RlWEF0b20nLCBbc21hc2hdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQocmlnaHQsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1tbCA9IFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuZmVuY2VkKHRoaXMuZmFjdG9yeS5jb25maWd1cmF0aW9uLCB0aGlzLmdldFByb3BlcnR5KCdvcGVuJyksIF9zdXBlci5wcm90b3R5cGUudG9NbWwuY2FsbCh0aGlzKSwgdGhpcy5nZXRQcm9wZXJ0eSgnY2xvc2UnKSwgdGhpcy5nZXRQcm9wZXJ0eSgnYmlnJykpO1xuICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQucmVtb3ZlUHJvcGVydGllcyhtbWwsICdvcGVuJywgJ2Nsb3NlJywgJ3RleENsYXNzJyk7XG4gICAgICAgIHJldHVybiBtbWw7XG4gICAgfTtcbiAgICBBdXRvT3Blbi5wcm90b3R5cGUuY2hlY2tJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNLaW5kKCdtbWwnKSAmJiBpdGVtLlNpemUoKSA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIG1tbCA9IGl0ZW0udG9NbWwoKTtcbiAgICAgICAgICAgIGlmIChtbWwuaXNLaW5kKCdtbycpICYmIG1tbC5nZXRUZXh0KCkgPT09IHRoaXMuZ2V0UHJvcGVydHkoJ29wZW4nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsb3NlID0gaXRlbS5nZXRQcm9wZXJ0eSgnYXV0b2Nsb3NlJyk7XG4gICAgICAgIGlmIChjbG9zZSAmJiBjbG9zZSA9PT0gdGhpcy5nZXRQcm9wZXJ0eSgnY2xvc2UnKSAmJiAhdGhpcy5vcGVuQ291bnQtLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UHJvcGVydHkoJ2lnbm9yZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5DbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbW10sIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtbdGhpcy50b01tbCgpXSwgdHJ1ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY2hlY2tJdGVtLmNhbGwodGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICBBdXRvT3Blbi5lcnJvcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoU3RhY2tJdGVtX2pzXzEuQmFzZUl0ZW0uZXJyb3JzKSwge1xuICAgICAgICAnc3RvcCc6IFsnRXh0cmFPck1pc3NpbmdEZWxpbXMnLCAnRXh0cmEgb3BlbiBvciBtaXNzaW5nIGNsb3NlIGRlbGltaXRlciddXG4gICAgfSk7XG4gICAgcmV0dXJuIEF1dG9PcGVuO1xufShTdGFja0l0ZW1fanNfMS5CYXNlSXRlbSkpO1xuZXhwb3J0cy5BdXRvT3BlbiA9IEF1dG9PcGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGh5c2ljc0l0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBQaHlzaWNzTWV0aG9kc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1BoeXNpY3NNZXRob2RzLmpzXCIpKTtcbnZhciBUZXhDb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuLi9UZXhDb25zdGFudHMuanNcIik7XG52YXIgUGFyc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlTWV0aG9kcy5qc1wiKSk7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ1BoeXNpY3MtYXV0b21hdGljLWJyYWNpbmctbWFjcm9zJywge1xuICAgICdxdWFudGl0eSc6ICdRdWFudGl0eScsXG4gICAgJ3F0eSc6ICdRdWFudGl0eScsXG4gICAgJ3BxdHknOiBbJ1F1YW50aXR5JywgJygnLCAnKScsIHRydWVdLFxuICAgICdicXR5JzogWydRdWFudGl0eScsICdbJywgJ10nLCB0cnVlXSxcbiAgICAndnF0eSc6IFsnUXVhbnRpdHknLCAnfCcsICd8JywgdHJ1ZV0sXG4gICAgJ0JxdHknOiBbJ1F1YW50aXR5JywgJ1xcXFx7JywgJ1xcXFx9JywgdHJ1ZV0sXG4gICAgJ2Fic29sdXRldmFsdWUnOiBbJ1F1YW50aXR5JywgJ3wnLCAnfCcsIHRydWVdLFxuICAgICdhYnMnOiBbJ1F1YW50aXR5JywgJ3wnLCAnfCcsIHRydWVdLFxuICAgICdub3JtJzogWydRdWFudGl0eScsICdcXFxcfCcsICdcXFxcfCcsIHRydWVdLFxuICAgICdldmFsdWF0ZWQnOiAnRXZhbCcsXG4gICAgJ2V2YWwnOiAnRXZhbCcsXG4gICAgJ29yZGVyJzogWydRdWFudGl0eScsICcoJywgJyknLCB0cnVlLCAnTycsXG4gICAgICAgIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQ0FMTElHUkFQSElDXSxcbiAgICAnY29tbXV0YXRvcic6ICdDb21tdXRhdG9yJyxcbiAgICAnY29tbSc6ICdDb21tdXRhdG9yJyxcbiAgICAnYW50aWNvbW11dGF0b3InOiBbJ0NvbW11dGF0b3InLCAnXFxcXHsnLCAnXFxcXH0nXSxcbiAgICAnYWNvbW0nOiBbJ0NvbW11dGF0b3InLCAnXFxcXHsnLCAnXFxcXH0nXSxcbiAgICAncG9pc3NvbmJyYWNrZXQnOiBbJ0NvbW11dGF0b3InLCAnXFxcXHsnLCAnXFxcXH0nXSxcbiAgICAncGInOiBbJ0NvbW11dGF0b3InLCAnXFxcXHsnLCAnXFxcXH0nXVxufSwgUGh5c2ljc01ldGhvZHNfanNfMS5kZWZhdWx0KTtcbm5ldyBTeW1ib2xNYXBfanNfMS5DaGFyYWN0ZXJNYXAoJ1BoeXNpY3MtdmVjdG9yLW1vJywgUGFyc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5tYXRoY2hhcjBtbywge1xuICAgIGRvdHByb2R1Y3Q6IFsnXFx1MjJDNScsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQk9MRCB9XSxcbiAgICB2ZG90OiBbJ1xcdTIyQzUnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkJPTEQgfV0sXG4gICAgY3Jvc3Nwcm9kdWN0OiAnXFx1MDBENycsXG4gICAgY3Jvc3M6ICdcXHUwMEQ3JyxcbiAgICBjcDogJ1xcdTAwRDcnLFxuICAgIGdyYWRpZW50bmFibGE6IFsnXFx1MjIwNycsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQk9MRCB9XVxufSk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ2hhcmFjdGVyTWFwKCdQaHlzaWNzLXZlY3Rvci1taScsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQubWF0aGNoYXIwbWksIHtcbiAgICByZWFsOiBbJ1xcdTIxMUMnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk5PUk1BTCB9XSxcbiAgICBpbWFnaW5hcnk6IFsnXFx1MjExMScsIHsgbWF0aHZhcmlhbnQ6IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuTk9STUFMIH1dXG59KTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdQaHlzaWNzLXZlY3Rvci1tYWNyb3MnLCB7XG4gICAgJ3ZuYWJsYSc6ICdWbmFibGEnLFxuICAgICd2ZWN0b3Jib2xkJzogJ1ZlY3RvckJvbGQnLFxuICAgICd2Yic6ICdWZWN0b3JCb2xkJyxcbiAgICAndmVjdG9yYXJyb3cnOiBbJ1N0YXJNYWNybycsIDEsICdcXFxcdmVje1xcXFx2YicsICd7IzF9fSddLFxuICAgICd2YSc6IFsnU3Rhck1hY3JvJywgMSwgJ1xcXFx2ZWN7XFxcXHZiJywgJ3sjMX19J10sXG4gICAgJ3ZlY3RvcnVuaXQnOiBbJ1N0YXJNYWNybycsIDEsICdcXFxcaGF0e1xcXFx2YicsICd7IzF9fSddLFxuICAgICd2dSc6IFsnU3Rhck1hY3JvJywgMSwgJ1xcXFxoYXR7XFxcXHZiJywgJ3sjMX19J10sXG4gICAgJ2dyYWRpZW50JzogWydPcGVyYXRvckFwcGxpY2F0aW9uJywgJ1xcXFx2bmFibGEnLCAnKCcsICdbJ10sXG4gICAgJ2dyYWQnOiBbJ09wZXJhdG9yQXBwbGljYXRpb24nLCAnXFxcXHZuYWJsYScsICcoJywgJ1snXSxcbiAgICAnZGl2ZXJnZW5jZSc6IFsnVmVjdG9yT3BlcmF0b3InLCAnXFxcXHZuYWJsYVxcXFx2ZG90JywgJygnLCAnWyddLFxuICAgICdkaXYnOiBbJ1ZlY3Rvck9wZXJhdG9yJywgJ1xcXFx2bmFibGFcXFxcdmRvdCcsICcoJywgJ1snXSxcbiAgICAnY3VybCc6IFsnVmVjdG9yT3BlcmF0b3InLCAnXFxcXHZuYWJsYVxcXFxjcm9zc3Byb2R1Y3QnLCAnKCcsICdbJ10sXG4gICAgJ2xhcGxhY2lhbic6IFsnT3BlcmF0b3JBcHBsaWNhdGlvbicsICdcXFxcbmFibGFeMicsICcoJywgJ1snXSxcbn0sIFBoeXNpY3NNZXRob2RzX2pzXzEuZGVmYXVsdCk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnUGh5c2ljcy1leHByZXNzaW9ucy1tYWNyb3MnLCB7XG4gICAgJ3Npbic6ICdFeHByZXNzaW9uJyxcbiAgICAnc2luaCc6ICdFeHByZXNzaW9uJyxcbiAgICAnYXJjc2luJzogJ0V4cHJlc3Npb24nLFxuICAgICdhc2luJzogJ0V4cHJlc3Npb24nLFxuICAgICdjb3MnOiAnRXhwcmVzc2lvbicsXG4gICAgJ2Nvc2gnOiAnRXhwcmVzc2lvbicsXG4gICAgJ2FyY2Nvcyc6ICdFeHByZXNzaW9uJyxcbiAgICAnYWNvcyc6ICdFeHByZXNzaW9uJyxcbiAgICAndGFuJzogJ0V4cHJlc3Npb24nLFxuICAgICd0YW5oJzogJ0V4cHJlc3Npb24nLFxuICAgICdhcmN0YW4nOiAnRXhwcmVzc2lvbicsXG4gICAgJ2F0YW4nOiAnRXhwcmVzc2lvbicsXG4gICAgJ2NzYyc6ICdFeHByZXNzaW9uJyxcbiAgICAnY3NjaCc6ICdFeHByZXNzaW9uJyxcbiAgICAnYXJjY3NjJzogJ0V4cHJlc3Npb24nLFxuICAgICdhY3NjJzogJ0V4cHJlc3Npb24nLFxuICAgICdzZWMnOiAnRXhwcmVzc2lvbicsXG4gICAgJ3NlY2gnOiAnRXhwcmVzc2lvbicsXG4gICAgJ2FyY3NlYyc6ICdFeHByZXNzaW9uJyxcbiAgICAnYXNlYyc6ICdFeHByZXNzaW9uJyxcbiAgICAnY290JzogJ0V4cHJlc3Npb24nLFxuICAgICdjb3RoJzogJ0V4cHJlc3Npb24nLFxuICAgICdhcmNjb3QnOiAnRXhwcmVzc2lvbicsXG4gICAgJ2Fjb3QnOiAnRXhwcmVzc2lvbicsXG4gICAgJ2V4cCc6IFsnRXhwcmVzc2lvbicsIGZhbHNlXSxcbiAgICAnbG9nJzogJ0V4cHJlc3Npb24nLFxuICAgICdsbic6ICdFeHByZXNzaW9uJyxcbiAgICAnZGV0JzogWydFeHByZXNzaW9uJywgZmFsc2VdLFxuICAgICdQcic6IFsnRXhwcmVzc2lvbicsIGZhbHNlXSxcbiAgICAndHInOiBbJ0V4cHJlc3Npb24nLCBmYWxzZV0sXG4gICAgJ3RyYWNlJzogWydFeHByZXNzaW9uJywgZmFsc2UsICd0ciddLFxuICAgICdUcic6IFsnRXhwcmVzc2lvbicsIGZhbHNlXSxcbiAgICAnVHJhY2UnOiBbJ0V4cHJlc3Npb24nLCBmYWxzZSwgJ1RyJ10sXG4gICAgJ3JhbmsnOiAnTmFtZWRGbicsXG4gICAgJ2VyZic6IFsnRXhwcmVzc2lvbicsIGZhbHNlXSxcbiAgICAnUmVzaWR1ZSc6IFsnTWFjcm8nLCAnXFxcXG1hdGhybXtSZXN9J10sXG4gICAgJ1Jlcyc6IFsnT3BlcmF0b3JBcHBsaWNhdGlvbicsICdcXFxcUmVzaWR1ZScsICcoJywgJ1snLCAneyddLFxuICAgICdwcmluY2lwYWx2YWx1ZSc6IFsnT3BlcmF0b3JBcHBsaWNhdGlvbicsICd7XFxcXGNhbCBQfSddLFxuICAgICdwdic6IFsnT3BlcmF0b3JBcHBsaWNhdGlvbicsICd7XFxcXGNhbCBQfSddLFxuICAgICdQVic6IFsnT3BlcmF0b3JBcHBsaWNhdGlvbicsICd7XFxcXHJtIFAuVi59J10sXG4gICAgJ1JlJzogWydPcGVyYXRvckFwcGxpY2F0aW9uJywgJ1xcXFxtYXRocm17UmV9JywgJ3snXSxcbiAgICAnSW0nOiBbJ09wZXJhdG9yQXBwbGljYXRpb24nLCAnXFxcXG1hdGhybXtJbX0nLCAneyddLFxuICAgICdzaW5lJzogWydOYW1lZEZuJywgJ3NpbiddLFxuICAgICdoeXBzaW5lJzogWydOYW1lZEZuJywgJ3NpbmgnXSxcbiAgICAnYXJjc2luZSc6IFsnTmFtZWRGbicsICdhcmNzaW4nXSxcbiAgICAnYXNpbmUnOiBbJ05hbWVkRm4nLCAnYXNpbiddLFxuICAgICdjb3NpbmUnOiBbJ05hbWVkRm4nLCAnY29zJ10sXG4gICAgJ2h5cGNvc2luZSc6IFsnTmFtZWRGbicsICdjb3NoJ10sXG4gICAgJ2FyY2Nvc2luZSc6IFsnTmFtZWRGbicsICdhcmNjb3MnXSxcbiAgICAnYWNvc2luZSc6IFsnTmFtZWRGbicsICdhY29zJ10sXG4gICAgJ3RhbmdlbnQnOiBbJ05hbWVkRm4nLCAndGFuJ10sXG4gICAgJ2h5cHRhbmdlbnQnOiBbJ05hbWVkRm4nLCAndGFuaCddLFxuICAgICdhcmN0YW5nZW50JzogWydOYW1lZEZuJywgJ2FyY3RhbiddLFxuICAgICdhdGFuZ2VudCc6IFsnTmFtZWRGbicsICdhdGFuJ10sXG4gICAgJ2Nvc2VjYW50JzogWydOYW1lZEZuJywgJ2NzYyddLFxuICAgICdoeXBjb3NlY2FudCc6IFsnTmFtZWRGbicsICdjc2NoJ10sXG4gICAgJ2FyY2Nvc2VjYW50JzogWydOYW1lZEZuJywgJ2FyY2NzYyddLFxuICAgICdhY29zZWNhbnQnOiBbJ05hbWVkRm4nLCAnYWNzYyddLFxuICAgICdzZWNhbnQnOiBbJ05hbWVkRm4nLCAnc2VjJ10sXG4gICAgJ2h5cHNlY2FudCc6IFsnTmFtZWRGbicsICdzZWNoJ10sXG4gICAgJ2FyY3NlY2FudCc6IFsnTmFtZWRGbicsICdhcmNzZWMnXSxcbiAgICAnYXNlY2FudCc6IFsnTmFtZWRGbicsICdhc2VjJ10sXG4gICAgJ2NvdGFuZ2VudCc6IFsnTmFtZWRGbicsICdjb3QnXSxcbiAgICAnaHlwY290YW5nZW50JzogWydOYW1lZEZuJywgJ2NvdGgnXSxcbiAgICAnYXJjY290YW5nZW50JzogWydOYW1lZEZuJywgJ2FyY2NvdCddLFxuICAgICdhY290YW5nZW50JzogWydOYW1lZEZuJywgJ2Fjb3QnXSxcbiAgICAnZXhwb25lbnRpYWwnOiBbJ05hbWVkRm4nLCAnZXhwJ10sXG4gICAgJ2xvZ2FyaXRobSc6IFsnTmFtZWRGbicsICdsb2cnXSxcbiAgICAnbmF0dXJhbGxvZ2FyaXRobSc6IFsnTmFtZWRGbicsICdsbiddLFxuICAgICdkZXRlcm1pbmFudCc6IFsnTmFtZWRGbicsICdkZXQnXSxcbiAgICAnUHJvYmFiaWxpdHknOiBbJ05hbWVkRm4nLCAnUHInXSxcbn0sIFBoeXNpY3NNZXRob2RzX2pzXzEuZGVmYXVsdCk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnUGh5c2ljcy1xdWljay1xdWFkLW1hY3JvcycsIHtcbiAgICAncXF0ZXh0JzogJ1FxdGV4dCcsXG4gICAgJ3FxJzogJ1FxdGV4dCcsXG4gICAgJ3Fjb21tYSc6IFsnTWFjcm8nLCAnXFxcXHFxdGV4dCp7LH0nXSxcbiAgICAncWMnOiBbJ01hY3JvJywgJ1xcXFxxcXRleHQqeyx9J10sXG4gICAgJ3FjYyc6IFsnUXF0ZXh0JywgJ2MuYy4nXSxcbiAgICAncWlmJzogWydRcXRleHQnLCAnaWYnXSxcbiAgICAncXRoZW4nOiBbJ1FxdGV4dCcsICd0aGVuJ10sXG4gICAgJ3FlbHNlJzogWydRcXRleHQnLCAnZWxzZSddLFxuICAgICdxb3RoZXJ3aXNlJzogWydRcXRleHQnLCAnb3RoZXJ3aXNlJ10sXG4gICAgJ3F1bmxlc3MnOiBbJ1FxdGV4dCcsICd1bmxlc3MnXSxcbiAgICAncWdpdmVuJzogWydRcXRleHQnLCAnZ2l2ZW4nXSxcbiAgICAncXVzaW5nJzogWydRcXRleHQnLCAndXNpbmcnXSxcbiAgICAncWFzc3VtZSc6IFsnUXF0ZXh0JywgJ2Fzc3VtZSddLFxuICAgICdxc2luY2UnOiBbJ1FxdGV4dCcsICdzaW5jZSddLFxuICAgICdxbGV0JzogWydRcXRleHQnLCAnbGV0J10sXG4gICAgJ3Fmb3InOiBbJ1FxdGV4dCcsICdmb3InXSxcbiAgICAncWFsbCc6IFsnUXF0ZXh0JywgJ2FsbCddLFxuICAgICdxZXZlbic6IFsnUXF0ZXh0JywgJ2V2ZW4nXSxcbiAgICAncW9kZCc6IFsnUXF0ZXh0JywgJ29kZCddLFxuICAgICdxaW50ZWdlcic6IFsnUXF0ZXh0JywgJ2ludGVnZXInXSxcbiAgICAncWFuZCc6IFsnUXF0ZXh0JywgJ2FuZCddLFxuICAgICdxb3InOiBbJ1FxdGV4dCcsICdvciddLFxuICAgICdxYXMnOiBbJ1FxdGV4dCcsICdhcyddLFxuICAgICdxaW4nOiBbJ1FxdGV4dCcsICdpbiddLFxufSwgUGh5c2ljc01ldGhvZHNfanNfMS5kZWZhdWx0KTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdQaHlzaWNzLWRlcml2YXRpdmUtbWFjcm9zJywge1xuICAgICdkaWZmZCc6ICdEaWZmRCcsXG4gICAgJ2ZsYXRmcmFjJzogWydNYWNybycsICdcXFxcbGVmdC4jMVxcXFxtaWRkbGUvIzJcXFxccmlnaHQuJywgMl0sXG4gICAgJ2RpZmZlcmVudGlhbCc6IFsnRGlmZmVyZW50aWFsJywgJ1xcXFxkaWZmZCddLFxuICAgICdkZCc6IFsnRGlmZmVyZW50aWFsJywgJ1xcXFxkaWZmZCddLFxuICAgICd2YXJpYXRpb24nOiBbJ0RpZmZlcmVudGlhbCcsICdcXFxcZGVsdGEnXSxcbiAgICAndmFyJzogWydEaWZmZXJlbnRpYWwnLCAnXFxcXGRlbHRhJ10sXG4gICAgJ2Rlcml2YXRpdmUnOiBbJ0Rlcml2YXRpdmUnLCAyLCAnXFxcXGRpZmZkJ10sXG4gICAgJ2R2JzogWydEZXJpdmF0aXZlJywgMiwgJ1xcXFxkaWZmZCddLFxuICAgICdwYXJ0aWFsZGVyaXZhdGl2ZSc6IFsnRGVyaXZhdGl2ZScsIDMsICdcXFxccGFydGlhbCddLFxuICAgICdwZGVyaXZhdGl2ZSc6IFsnRGVyaXZhdGl2ZScsIDMsICdcXFxccGFydGlhbCddLFxuICAgICdwZHYnOiBbJ0Rlcml2YXRpdmUnLCAzLCAnXFxcXHBhcnRpYWwnXSxcbiAgICAnZnVuY3Rpb25hbGRlcml2YXRpdmUnOiBbJ0Rlcml2YXRpdmUnLCAyLCAnXFxcXGRlbHRhJ10sXG4gICAgJ2ZkZXJpdmF0aXZlJzogWydEZXJpdmF0aXZlJywgMiwgJ1xcXFxkZWx0YSddLFxuICAgICdmZHYnOiBbJ0Rlcml2YXRpdmUnLCAyLCAnXFxcXGRlbHRhJ10sXG59LCBQaHlzaWNzTWV0aG9kc19qc18xLmRlZmF1bHQpO1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ1BoeXNpY3MtYnJhLWtldC1tYWNyb3MnLCB7XG4gICAgJ2JyYSc6ICdCcmEnLFxuICAgICdrZXQnOiAnS2V0JyxcbiAgICAnaW5uZXJwcm9kdWN0JzogJ0JyYUtldCcsXG4gICAgJ2lwJzogJ0JyYUtldCcsXG4gICAgJ2JyYWtldCc6ICdCcmFLZXQnLFxuICAgICdvdXRlcnByb2R1Y3QnOiAnS2V0QnJhJyxcbiAgICAnZHlhZCc6ICdLZXRCcmEnLFxuICAgICdrZXRicmEnOiAnS2V0QnJhJyxcbiAgICAnb3AnOiAnS2V0QnJhJyxcbiAgICAnZXhwZWN0YXRpb252YWx1ZSc6ICdFeHBlY3RhdGlvbicsXG4gICAgJ2V4cHZhbCc6ICdFeHBlY3RhdGlvbicsXG4gICAgJ2V2JzogJ0V4cGVjdGF0aW9uJyxcbiAgICAnbWF0cml4ZWxlbWVudCc6ICdNYXRyaXhFbGVtZW50JyxcbiAgICAnbWF0cml4ZWwnOiAnTWF0cml4RWxlbWVudCcsXG4gICAgJ21lbCc6ICdNYXRyaXhFbGVtZW50Jyxcbn0sIFBoeXNpY3NNZXRob2RzX2pzXzEuZGVmYXVsdCk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgnUGh5c2ljcy1tYXRyaXgtbWFjcm9zJywge1xuICAgICdtYXRyaXhxdWFudGl0eSc6ICdNYXRyaXhRdWFudGl0eScsXG4gICAgJ21xdHknOiAnTWF0cml4UXVhbnRpdHknLFxuICAgICdwbXF0eSc6IFsnTWFjcm8nLCAnXFxcXG1xdHkoIzEpJywgMV0sXG4gICAgJ1BtcXR5JzogWydNYWNybycsICdcXFxcbXF0eSooIzEpJywgMV0sXG4gICAgJ2JtcXR5JzogWydNYWNybycsICdcXFxcbXF0eVsjMV0nLCAxXSxcbiAgICAndm1xdHknOiBbJ01hY3JvJywgJ1xcXFxtcXR5fCMxfCcsIDFdLFxuICAgICdzbWFsbG1hdHJpeHF1YW50aXR5JzogWydNYXRyaXhRdWFudGl0eScsIHRydWVdLFxuICAgICdzbXF0eSc6IFsnTWF0cml4UXVhbnRpdHknLCB0cnVlXSxcbiAgICAnc3BtcXR5JzogWydNYWNybycsICdcXFxcc21xdHkoIzEpJywgMV0sXG4gICAgJ3NQbXF0eSc6IFsnTWFjcm8nLCAnXFxcXHNtcXR5KigjMSknLCAxXSxcbiAgICAnc2JtcXR5JzogWydNYWNybycsICdcXFxcc21xdHlbIzFdJywgMV0sXG4gICAgJ3N2bXF0eSc6IFsnTWFjcm8nLCAnXFxcXHNtcXR5fCMxfCcsIDFdLFxuICAgICdtYXRyaXhkZXRlcm1pbmFudCc6IFsnTWFjcm8nLCAnXFxcXHZtcXR5eyMxfScsIDFdLFxuICAgICdtZGV0JzogWydNYWNybycsICdcXFxcdm1xdHl7IzF9JywgMV0sXG4gICAgJ3NtZGV0JzogWydNYWNybycsICdcXFxcc3ZtcXR5eyMxfScsIDFdLFxuICAgICdpZGVudGl0eW1hdHJpeCc6ICdJZGVudGl0eU1hdHJpeCcsXG4gICAgJ2ltYXQnOiAnSWRlbnRpdHlNYXRyaXgnLFxuICAgICd4bWF0cml4JzogJ1hNYXRyaXgnLFxuICAgICd4bWF0JzogJ1hNYXRyaXgnLFxuICAgICd6ZXJvbWF0cml4JzogWydNYWNybycsICdcXFxceG1hdHswfXsjMX17IzJ9JywgMl0sXG4gICAgJ3ptYXQnOiBbJ01hY3JvJywgJ1xcXFx4bWF0ezB9eyMxfXsjMn0nLCAyXSxcbiAgICAncGF1bGltYXRyaXgnOiAnUGF1bGlNYXRyaXgnLFxuICAgICdwbWF0JzogJ1BhdWxpTWF0cml4JyxcbiAgICAnZGlhZ29uYWxtYXRyaXgnOiAnRGlhZ29uYWxNYXRyaXgnLFxuICAgICdkbWF0JzogJ0RpYWdvbmFsTWF0cml4JyxcbiAgICAnYW50aWRpYWdvbmFsbWF0cml4JzogWydEaWFnb25hbE1hdHJpeCcsIHRydWVdLFxuICAgICdhZG1hdCc6IFsnRGlhZ29uYWxNYXRyaXgnLCB0cnVlXVxufSwgUGh5c2ljc01ldGhvZHNfanNfMS5kZWZhdWx0KTtcbm5ldyBTeW1ib2xNYXBfanNfMS5FbnZpcm9ubWVudE1hcCgnUGh5c2ljcy1hdXgtZW52cycsIFBhcnNlTWV0aG9kc19qc18xLmRlZmF1bHQuZW52aXJvbm1lbnQsIHtcbiAgICBzbWFsbG1hdHJpeDogWydBcnJheScsIG51bGwsIG51bGwsIG51bGwsICdjJywgJzAuMzMzZW0nLCAnLjJlbScsICdTJywgMV1cbn0sIFBoeXNpY3NNZXRob2RzX2pzXzEuZGVmYXVsdCk7XG5uZXcgU3ltYm9sTWFwX2pzXzEuTWFjcm9NYXAoJ1BoeXNpY3MtY2hhcmFjdGVycycsIHtcbiAgICAnfCc6IFsnQXV0b0Nsb3NlJywgTW1sTm9kZV9qc18xLlRFWENMQVNTLk9SRF0sXG4gICAgJyknOiAnQXV0b0Nsb3NlJyxcbiAgICAnXSc6ICdBdXRvQ2xvc2UnXG59LCBQaHlzaWNzTWV0aG9kc19qc18xLmRlZmF1bHQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGh5c2ljc01hcHBpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJhc2VNZXRob2RzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Jhc2UvQmFzZU1ldGhvZHMuanNcIikpO1xudmFyIFRleFBhcnNlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhQYXJzZXIuanNcIikpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vTm9kZVV0aWwuanNcIikpO1xudmFyIE5vZGVGYWN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi4vTm9kZUZhY3RvcnkuanNcIik7XG52YXIgUGh5c2ljc01ldGhvZHMgPSB7fTtcbnZhciBwYWlycyA9IHtcbiAgICAnKCc6ICcpJyxcbiAgICAnWyc6ICddJyxcbiAgICAneyc6ICd9JyxcbiAgICAnfCc6ICd8Jyxcbn07XG52YXIgYmlnZ3MgPSAvXihifEIpaShnezEsMn0pJC87XG5QaHlzaWNzTWV0aG9kcy5RdWFudGl0eSA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUsIG9wZW4sIGNsb3NlLCBhcmcsIG5hbWVkLCB2YXJpYW50KSB7XG4gICAgaWYgKG9wZW4gPT09IHZvaWQgMCkgeyBvcGVuID0gJygnOyB9XG4gICAgaWYgKGNsb3NlID09PSB2b2lkIDApIHsgY2xvc2UgPSAnKSc7IH1cbiAgICBpZiAoYXJnID09PSB2b2lkIDApIHsgYXJnID0gZmFsc2U7IH1cbiAgICBpZiAobmFtZWQgPT09IHZvaWQgMCkgeyBuYW1lZCA9ICcnOyB9XG4gICAgaWYgKHZhcmlhbnQgPT09IHZvaWQgMCkgeyB2YXJpYW50ID0gJyc7IH1cbiAgICB2YXIgc3RhciA9IGFyZyA/IHBhcnNlci5HZXRTdGFyKCkgOiBmYWxzZTtcbiAgICB2YXIgbmV4dCA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgdmFyIHBvc2l0aW9uID0gcGFyc2VyLmk7XG4gICAgdmFyIGJpZyA9IG51bGw7XG4gICAgaWYgKG5leHQgPT09ICdcXFxcJykge1xuICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICBiaWcgPSBwYXJzZXIuR2V0Q1MoKTtcbiAgICAgICAgaWYgKCFiaWcubWF0Y2goYmlnZ3MpKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21yb3cnKTtcbiAgICAgICAgICAgIHBhcnNlci5QdXNoKFBhcnNlVXRpbF9qc18xLmRlZmF1bHQuZmVuY2VkKHBhcnNlci5jb25maWd1cmF0aW9uLCBvcGVuLCBlbXB0eSwgY2xvc2UpKTtcbiAgICAgICAgICAgIHBhcnNlci5pID0gcG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgfVxuICAgIHZhciByaWdodCA9IHBhaXJzW25leHRdO1xuICAgIGlmIChhcmcgJiYgbmV4dCAhPT0gJ3snKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdBcmdGb3InLCAnTWlzc2luZyBhcmd1bWVudCBmb3IgJTEnLCBwYXJzZXIuY3VycmVudENTKTtcbiAgICB9XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgICB2YXIgZW1wdHkgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21yb3cnKTtcbiAgICAgICAgcGFyc2VyLlB1c2goUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5mZW5jZWQocGFyc2VyLmNvbmZpZ3VyYXRpb24sIG9wZW4sIGVtcHR5LCBjbG9zZSkpO1xuICAgICAgICBwYXJzZXIuaSA9IHBvc2l0aW9uO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lZCkge1xuICAgICAgICB2YXIgbW1sID0gcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbWknLCB7IHRleENsYXNzOiBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuT1AgfSwgbmFtZWQpO1xuICAgICAgICBpZiAodmFyaWFudCkge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShtbWwsICdtYXRodmFyaWFudCcsIHZhcmlhbnQpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2ZuJywgbW1sKSk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAneycpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICBuZXh0ID0gYXJnID8gb3BlbiA6ICdcXFxceyc7XG4gICAgICAgIHJpZ2h0ID0gYXJnID8gY2xvc2UgOiAnXFxcXH0nO1xuICAgICAgICBhcmd1bWVudCA9IHN0YXIgPyBuZXh0ICsgJyAnICsgYXJndW1lbnQgKyAnICcgKyByaWdodCA6XG4gICAgICAgICAgICAoYmlnID9cbiAgICAgICAgICAgICAgICAnXFxcXCcgKyBiaWcgKyAnbCcgKyBuZXh0ICsgJyAnICsgYXJndW1lbnQgKyAnICcgKyAnXFxcXCcgKyBiaWcgKyAncicgKyByaWdodCA6XG4gICAgICAgICAgICAgICAgJ1xcXFxsZWZ0JyArIG5leHQgKyAnICcgKyBhcmd1bWVudCArICcgJyArICdcXFxccmlnaHQnICsgcmlnaHQpO1xuICAgICAgICBwYXJzZXIuUHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChhcmd1bWVudCwgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJnKSB7XG4gICAgICAgIG5leHQgPSBvcGVuO1xuICAgICAgICByaWdodCA9IGNsb3NlO1xuICAgIH1cbiAgICBwYXJzZXIuaSsrO1xuICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2F1dG8gb3BlbicpXG4gICAgICAgIC5zZXRQcm9wZXJ0aWVzKHsgb3BlbjogbmV4dCwgY2xvc2U6IHJpZ2h0LCBiaWc6IGJpZyB9KSk7XG59O1xuUGh5c2ljc01ldGhvZHMuRXZhbCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgdmFyIG5leHQgPSBwYXJzZXIuR2V0TmV4dCgpO1xuICAgIGlmIChuZXh0ID09PSAneycpIHtcbiAgICAgICAgdmFyIGFyZyA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSAnXFxcXGxlZnQuICcgK1xuICAgICAgICAgICAgKHN0YXIgPyAnXFxcXHNtYXNoeycgKyBhcmcgKyAnfScgOiBhcmcpICtcbiAgICAgICAgICAgICcgJyArICdcXFxcdnBoYW50b217XFxcXGludH1cXFxccmlnaHR8JztcbiAgICAgICAgcGFyc2VyLnN0cmluZyA9IHBhcnNlci5zdHJpbmcuc2xpY2UoMCwgcGFyc2VyLmkpICsgcmVwbGFjZSArXG4gICAgICAgICAgICBwYXJzZXIuc3RyaW5nLnNsaWNlKHBhcnNlci5pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gJygnIHx8IG5leHQgPT09ICdbJykge1xuICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICBwYXJzZXIuUHVzaChwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKCdhdXRvIG9wZW4nKVxuICAgICAgICAgICAgLnNldFByb3BlcnRpZXMoeyBvcGVuOiBuZXh0LCBjbG9zZTogJ3wnLFxuICAgICAgICAgICAgc21hc2g6IHN0YXIsIHJpZ2h0OiAnXFxcXHZwaGFudG9te1xcXFxpbnR9JyB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTWlzc2luZ0FyZ0ZvcicsICdNaXNzaW5nIGFyZ3VtZW50IGZvciAlMScsIHBhcnNlci5jdXJyZW50Q1MpO1xufTtcblBoeXNpY3NNZXRob2RzLkNvbW11dGF0b3IgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBvcGVuLCBjbG9zZSkge1xuICAgIGlmIChvcGVuID09PSB2b2lkIDApIHsgb3BlbiA9ICdbJzsgfVxuICAgIGlmIChjbG9zZSA9PT0gdm9pZCAwKSB7IGNsb3NlID0gJ10nOyB9XG4gICAgdmFyIHN0YXIgPSBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBuZXh0ID0gcGFyc2VyLkdldE5leHQoKTtcbiAgICB2YXIgYmlnID0gbnVsbDtcbiAgICBpZiAobmV4dCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHBhcnNlci5pKys7XG4gICAgICAgIGJpZyA9IHBhcnNlci5HZXRDUygpO1xuICAgICAgICBpZiAoIWJpZy5tYXRjaChiaWdncykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdBcmdGb3InLCAnTWlzc2luZyBhcmd1bWVudCBmb3IgJTEnLCBwYXJzZXIuY3VycmVudENTKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gcGFyc2VyLkdldE5leHQoKTtcbiAgICB9XG4gICAgaWYgKG5leHQgIT09ICd7Jykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNaXNzaW5nQXJnRm9yJywgJ01pc3NpbmcgYXJndW1lbnQgZm9yICUxJywgcGFyc2VyLmN1cnJlbnRDUyk7XG4gICAgfVxuICAgIHZhciBhcmcxID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmcyID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmd1bWVudCA9IGFyZzEgKyAnLCcgKyBhcmcyO1xuICAgIGFyZ3VtZW50ID0gc3RhciA/IG9wZW4gKyAnICcgKyBhcmd1bWVudCArICcgJyArIGNsb3NlIDpcbiAgICAgICAgKGJpZyA/XG4gICAgICAgICAgICAnXFxcXCcgKyBiaWcgKyAnbCcgKyBvcGVuICsgJyAnICsgYXJndW1lbnQgKyAnICcgKyAnXFxcXCcgKyBiaWcgKyAncicgKyBjbG9zZSA6XG4gICAgICAgICAgICAnXFxcXGxlZnQnICsgb3BlbiArICcgJyArIGFyZ3VtZW50ICsgJyAnICsgJ1xcXFxyaWdodCcgKyBjbG9zZSk7XG4gICAgcGFyc2VyLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoYXJndW1lbnQsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG59O1xudmFyIGxhdGluQ2FwID0gWzB4NDEsIDB4NUFdO1xudmFyIGxhdGluU21hbGwgPSBbMHg2MSwgMHg3QV07XG52YXIgZ3JlZWtDYXAgPSBbMHgzOTEsIDB4M0E5XTtcbnZhciBncmVla1NtYWxsID0gWzB4M0IxLCAweDNDOV07XG52YXIgZGlnaXRzID0gWzB4MzAsIDB4MzldO1xuZnVuY3Rpb24gaW5SYW5nZSh2YWx1ZSwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKHZhbHVlID49IHJhbmdlWzBdICYmIHZhbHVlIDw9IHJhbmdlWzFdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZlY3RvclRva2VuKGZhY3RvcnksIGtpbmQsIGRlZiwgdGV4dCkge1xuICAgIHZhciBwYXJzZXIgPSBmYWN0b3J5LmNvbmZpZ3VyYXRpb24ucGFyc2VyO1xuICAgIHZhciB0b2tlbiA9IE5vZGVGYWN0b3J5X2pzXzEuTm9kZUZhY3RvcnkuY3JlYXRlVG9rZW4oZmFjdG9yeSwga2luZCwgZGVmLCB0ZXh0KTtcbiAgICB2YXIgY29kZSA9IHRleHQuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAxICYmICFwYXJzZXIuc3RhY2suZW52LmZvbnQgJiZcbiAgICAgICAgcGFyc2VyLnN0YWNrLmVudi52ZWN0b3JGb250ICYmXG4gICAgICAgIChpblJhbmdlKGNvZGUsIGxhdGluQ2FwKSB8fCBpblJhbmdlKGNvZGUsIGxhdGluU21hbGwpIHx8XG4gICAgICAgICAgICBpblJhbmdlKGNvZGUsIGdyZWVrQ2FwKSB8fCBpblJhbmdlKGNvZGUsIGRpZ2l0cykgfHxcbiAgICAgICAgICAgIChpblJhbmdlKGNvZGUsIGdyZWVrU21hbGwpICYmIHBhcnNlci5zdGFjay5lbnYudmVjdG9yU3RhcikgfHxcbiAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRBdHRyaWJ1dGUodG9rZW4sICdhY2NlbnQnKSkpIHtcbiAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZSh0b2tlbiwgJ21hdGh2YXJpYW50JywgcGFyc2VyLnN0YWNrLmVudi52ZWN0b3JGb250KTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xufVxuUGh5c2ljc01ldGhvZHMuVmVjdG9yQm9sZCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgdmFyIGFyZyA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgb2xkVG9rZW4gPSBwYXJzZXIuY29uZmlndXJhdGlvbi5ub2RlRmFjdG9yeS5nZXQoJ3Rva2VuJyk7XG4gICAgdmFyIG9sZEZvbnQgPSBwYXJzZXIuc3RhY2suZW52LmZvbnQ7XG4gICAgZGVsZXRlIHBhcnNlci5zdGFjay5lbnYuZm9udDtcbiAgICBwYXJzZXIuY29uZmlndXJhdGlvbi5ub2RlRmFjdG9yeS5zZXQoJ3Rva2VuJywgY3JlYXRlVmVjdG9yVG9rZW4pO1xuICAgIHBhcnNlci5zdGFjay5lbnYudmVjdG9yRm9udCA9IHN0YXIgPyAnYm9sZC1pdGFsaWMnIDogJ2JvbGQnO1xuICAgIHBhcnNlci5zdGFjay5lbnYudmVjdG9yU3RhciA9IHN0YXI7XG4gICAgdmFyIG5vZGUgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChhcmcsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICBpZiAob2xkRm9udCkge1xuICAgICAgICBwYXJzZXIuc3RhY2suZW52LmZvbnQgPSBvbGRGb250O1xuICAgIH1cbiAgICBkZWxldGUgcGFyc2VyLnN0YWNrLmVudi52ZWN0b3JGb250O1xuICAgIGRlbGV0ZSBwYXJzZXIuc3RhY2suZW52LnZlY3RvclN0YXI7XG4gICAgcGFyc2VyLmNvbmZpZ3VyYXRpb24ubm9kZUZhY3Rvcnkuc2V0KCd0b2tlbicsIG9sZFRva2VuKTtcbiAgICBwYXJzZXIuUHVzaChub2RlKTtcbn07XG5QaHlzaWNzTWV0aG9kcy5TdGFyTWFjcm8gPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBhcmdjb3VudCkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHBhcnRzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBpZiAoYXJnY291bnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoOyBpIDwgYXJnY291bnQ7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hY3JvID0gcGFydHMuam9pbihzdGFyID8gJyonIDogJycpO1xuICAgIG1hY3JvID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5zdWJzdGl0dXRlQXJncyhwYXJzZXIsIGFyZ3MsIG1hY3JvKTtcbiAgICBwYXJzZXIuc3RyaW5nID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5hZGRBcmdzKHBhcnNlciwgbWFjcm8sIHBhcnNlci5zdHJpbmcuc2xpY2UocGFyc2VyLmkpKTtcbiAgICBwYXJzZXIuaSA9IDA7XG4gICAgUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5jaGVja01heE1hY3JvcyhwYXJzZXIpO1xufTtcbnZhciB2ZWN0b3JBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uIChwYXJzZXIsIGtpbmQsIG5hbWUsIG9wZXJhdG9yLCBmZW5jZXMpIHtcbiAgICB2YXIgb3AgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChvcGVyYXRvciwgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoa2luZCwgb3ApKTtcbiAgICB2YXIgbGVmdCA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgdmFyIHJpZ2h0ID0gcGFpcnNbbGVmdF07XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZmVuY2UgPSAnJywgcmZlbmNlID0gJycsIGFyZyA9ICcnO1xuICAgIHZhciBlbmxhcmdlID0gZmVuY2VzLmluZGV4T2YobGVmdCkgIT09IC0xO1xuICAgIGlmIChsZWZ0ID09PSAneycpIHtcbiAgICAgICAgYXJnID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICBsZmVuY2UgPSBlbmxhcmdlID8gJ1xcXFxsZWZ0XFxcXHsnIDogJyc7XG4gICAgICAgIHJmZW5jZSA9IGVubGFyZ2UgPyAnXFxcXHJpZ2h0XFxcXH0nIDogJyc7XG4gICAgICAgIHZhciBtYWNybyA9IGxmZW5jZSArICcgJyArIGFyZyArICcgJyArIHJmZW5jZTtcbiAgICAgICAgcGFyc2VyLnN0cmluZyA9IG1hY3JvICsgcGFyc2VyLnN0cmluZy5zbGljZShwYXJzZXIuaSk7XG4gICAgICAgIHBhcnNlci5pID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVubGFyZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJzZXIuaSsrO1xuICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2F1dG8gb3BlbicpXG4gICAgICAgIC5zZXRQcm9wZXJ0aWVzKHsgb3BlbjogbGVmdCwgY2xvc2U6IHJpZ2h0IH0pKTtcbn07XG5QaHlzaWNzTWV0aG9kcy5PcGVyYXRvckFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgb3BlcmF0b3IpIHtcbiAgICB2YXIgZmVuY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZmVuY2VzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2ZWN0b3JBcHBsaWNhdGlvbihwYXJzZXIsICdmbicsIG5hbWUsIG9wZXJhdG9yLCBmZW5jZXMpO1xufTtcblBoeXNpY3NNZXRob2RzLlZlY3Rvck9wZXJhdG9yID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgb3BlcmF0b3IpIHtcbiAgICB2YXIgZmVuY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZmVuY2VzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2ZWN0b3JBcHBsaWNhdGlvbihwYXJzZXIsICdtbWwnLCBuYW1lLCBvcGVyYXRvciwgZmVuY2VzKTtcbn07XG5QaHlzaWNzTWV0aG9kcy5FeHByZXNzaW9uID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgb3B0LCBpZCkge1xuICAgIGlmIChvcHQgPT09IHZvaWQgMCkgeyBvcHQgPSB0cnVlOyB9XG4gICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSAnJzsgfVxuICAgIGlkID0gaWQgfHwgbmFtZS5zbGljZSgxKTtcbiAgICB2YXIgZXhwID0gb3B0ID8gcGFyc2VyLkdldEJyYWNrZXRzKG5hbWUpIDogbnVsbDtcbiAgICB2YXIgbW1sID0gcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbWknLCB7IHRleENsYXNzOiBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuT1AgfSwgaWQpO1xuICAgIGlmIChleHApIHtcbiAgICAgICAgdmFyIHN1cCA9IG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KGV4cCwgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgICAgICBtbWwgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zdXAnLCBbbW1sLCBzdXBdKTtcbiAgICB9XG4gICAgcGFyc2VyLlB1c2gocGFyc2VyLml0ZW1GYWN0b3J5LmNyZWF0ZSgnZm4nLCBtbWwpKTtcbiAgICBpZiAocGFyc2VyLkdldE5leHQoKSAhPT0gJygnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyc2VyLmkrKztcbiAgICBwYXJzZXIuUHVzaChwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKCdhdXRvIG9wZW4nKVxuICAgICAgICAuc2V0UHJvcGVydGllcyh7IG9wZW46ICcoJywgY2xvc2U6ICcpJyB9KSk7XG59O1xuUGh5c2ljc01ldGhvZHMuUXF0ZXh0ID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgdGV4dCkge1xuICAgIHZhciBzdGFyID0gcGFyc2VyLkdldFN0YXIoKTtcbiAgICB2YXIgYXJnID0gdGV4dCA/IHRleHQgOiBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIHJlcGxhY2UgPSAoc3RhciA/ICcnIDogJ1xcXFxxdWFkJykgKyAnXFxcXHRleHR7JyArIGFyZyArICd9XFxcXHF1YWQgJztcbiAgICBwYXJzZXIuc3RyaW5nID0gcGFyc2VyLnN0cmluZy5zbGljZSgwLCBwYXJzZXIuaSkgKyByZXBsYWNlICtcbiAgICAgICAgcGFyc2VyLnN0cmluZy5zbGljZShwYXJzZXIuaSk7XG59O1xuUGh5c2ljc01ldGhvZHMuRGlmZmVyZW50aWFsID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgb3ApIHtcbiAgICB2YXIgb3B0QXJnID0gcGFyc2VyLkdldEJyYWNrZXRzKG5hbWUpO1xuICAgIHZhciBwb3dlciA9IG9wdEFyZyAhPSBudWxsID8gJ157JyArIG9wdEFyZyArICd9JyA6ICcgJztcbiAgICB2YXIgcGFyZW5zID0gcGFyc2VyLkdldE5leHQoKSA9PT0gJygnO1xuICAgIHZhciBicmFjZXMgPSBwYXJzZXIuR2V0TmV4dCgpID09PSAneyc7XG4gICAgdmFyIG1hY3JvID0gb3AgKyBwb3dlcjtcbiAgICBpZiAoIShwYXJlbnMgfHwgYnJhY2VzKSkge1xuICAgICAgICBtYWNybyArPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSwgdHJ1ZSkgfHwgJyc7XG4gICAgICAgIHZhciBtbWwgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChtYWNybywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgICAgICBwYXJzZXIuUHVzaChtbWwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChicmFjZXMpIHtcbiAgICAgICAgbWFjcm8gKz0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgICAgICB2YXIgbW1sID0gbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQobWFjcm8sIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICAgICAgcGFyc2VyLlB1c2gocGFyc2VyLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgW21tbF0sIHsgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5PUCB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyc2VyLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQobWFjcm8sIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG4gICAgcGFyc2VyLmkrKztcbiAgICBwYXJzZXIuUHVzaChwYXJzZXIuaXRlbUZhY3RvcnkuY3JlYXRlKCdhdXRvIG9wZW4nKVxuICAgICAgICAuc2V0UHJvcGVydGllcyh7IG9wZW46ICcoJywgY2xvc2U6ICcpJyB9KSk7XG59O1xuUGh5c2ljc01ldGhvZHMuRGVyaXZhdGl2ZSA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUsIGFyZ01heCwgb3ApIHtcbiAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgdmFyIG9wdEFyZyA9IHBhcnNlci5HZXRCcmFja2V0cyhuYW1lKTtcbiAgICB2YXIgYXJnQ291bnRlciA9IDE7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBhcmdzLnB1c2gocGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKTtcbiAgICB3aGlsZSAocGFyc2VyLkdldE5leHQoKSA9PT0gJ3snICYmIGFyZ0NvdW50ZXIgPCBhcmdNYXgpIHtcbiAgICAgICAgYXJncy5wdXNoKHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgICAgIGFyZ0NvdW50ZXIrKztcbiAgICB9XG4gICAgdmFyIGlnbm9yZSA9IGZhbHNlO1xuICAgIHZhciBwb3dlcjEgPSAnICc7XG4gICAgdmFyIHBvd2VyMiA9ICcgJztcbiAgICBpZiAoYXJnTWF4ID4gMiAmJiBhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcG93ZXIxID0gJ157JyArIChhcmdzLmxlbmd0aCAtIDEpICsgJ30nO1xuICAgICAgICBpZ25vcmUgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRBcmcgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYXJnTWF4ID4gMiAmJiBhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcG93ZXIxID0gJ157JyArIG9wdEFyZyArICd9JztcbiAgICAgICAgcG93ZXIyID0gcG93ZXIxO1xuICAgIH1cbiAgICB2YXIgZnJhYyA9IHN0YXIgPyAnXFxcXGZsYXRmcmFjJyA6ICdcXFxcZnJhYyc7XG4gICAgdmFyIGZpcnN0ID0gYXJncy5sZW5ndGggPiAxID8gYXJnc1swXSA6ICcnO1xuICAgIHZhciBzZWNvbmQgPSBhcmdzLmxlbmd0aCA+IDEgPyBhcmdzWzFdIDogYXJnc1swXTtcbiAgICB2YXIgcmVzdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAyLCBhcmcgPSB2b2lkIDA7IGFyZyA9IGFyZ3NbaV07IGkrKykge1xuICAgICAgICByZXN0ICs9IG9wICsgJyAnICsgYXJnO1xuICAgIH1cbiAgICB2YXIgbWFjcm8gPSBmcmFjICsgJ3snICsgb3AgKyBwb3dlcjEgKyBmaXJzdCArICd9JyArXG4gICAgICAgICd7JyArIG9wICsgJyAnICsgc2Vjb25kICsgcG93ZXIyICsgJyAnICsgcmVzdCArICd9JztcbiAgICBwYXJzZXIuUHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChtYWNybywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpKTtcbiAgICBpZiAocGFyc2VyLkdldE5leHQoKSA9PT0gJygnKSB7XG4gICAgICAgIHBhcnNlci5pKys7XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ2F1dG8gb3BlbicpXG4gICAgICAgICAgICAuc2V0UHJvcGVydGllcyh7IG9wZW46ICcoJywgY2xvc2U6ICcpJywgaWdub3JlOiBpZ25vcmUgfSkpO1xuICAgIH1cbn07XG5QaHlzaWNzTWV0aG9kcy5CcmEgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0YXJCcmEgPSBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBicmEgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIGtldCA9ICcnO1xuICAgIHZhciBoYXNLZXQgPSBmYWxzZTtcbiAgICB2YXIgc3RhcktldCA9IGZhbHNlO1xuICAgIGlmIChwYXJzZXIuR2V0TmV4dCgpID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFyIHNhdmVJID0gcGFyc2VyLmk7XG4gICAgICAgIHBhcnNlci5pKys7XG4gICAgICAgIHZhciBjcyA9IHBhcnNlci5HZXRDUygpO1xuICAgICAgICB2YXIgc3ltYm9sID0gcGFyc2VyLmxvb2t1cCgnbWFjcm8nLCBjcyk7XG4gICAgICAgIGlmIChzeW1ib2wgJiYgc3ltYm9sLnN5bWJvbCA9PT0gJ2tldCcpIHtcbiAgICAgICAgICAgIGhhc0tldCA9IHRydWU7XG4gICAgICAgICAgICBzYXZlSSA9IHBhcnNlci5pO1xuICAgICAgICAgICAgc3RhcktldCA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgICAgICAgICBpZiAocGFyc2VyLkdldE5leHQoKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAga2V0ID0gcGFyc2VyLkdldEFyZ3VtZW50KGNzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlci5pID0gc2F2ZUk7XG4gICAgICAgICAgICAgICAgc3RhcktldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmkgPSBzYXZlSTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFjcm8gPSAnJztcbiAgICBpZiAoaGFzS2V0KSB7XG4gICAgICAgIG1hY3JvID0gKHN0YXJCcmEgfHwgc3RhcktldCkgP1xuICAgICAgICAgICAgXCJcXFxcbGFuZ2xle1wiLmNvbmNhdChicmEsIFwifVxcXFx2ZXJ0e1wiKS5jb25jYXQoa2V0LCBcIn1cXFxccmFuZ2xlXCIpIDpcbiAgICAgICAgICAgIFwiXFxcXGxlZnRcXFxcbGFuZ2xle1wiLmNvbmNhdChicmEsIFwifVxcXFxtaWRkbGVcXFxcdmVydHtcIikuY29uY2F0KGtldCwgXCJ9XFxcXHJpZ2h0XFxcXHJhbmdsZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hY3JvID0gKHN0YXJCcmEgfHwgc3RhcktldCkgP1xuICAgICAgICAgICAgXCJcXFxcbGFuZ2xle1wiLmNvbmNhdChicmEsIFwifVxcXFx2ZXJ0XCIpIDogXCJcXFxcbGVmdFxcXFxsYW5nbGV7XCIuY29uY2F0KGJyYSwgXCJ9XFxcXHJpZ2h0XFxcXHZlcnR7XCIpLmNvbmNhdChrZXQsIFwifVwiKTtcbiAgICB9XG4gICAgcGFyc2VyLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQobWFjcm8sIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG59O1xuUGh5c2ljc01ldGhvZHMuS2V0ID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBzdGFyID0gcGFyc2VyLkdldFN0YXIoKTtcbiAgICB2YXIga2V0ID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBtYWNybyA9IHN0YXIgPyBcIlxcXFx2ZXJ0e1wiLmNvbmNhdChrZXQsIFwifVxcXFxyYW5nbGVcIikgOlxuICAgICAgICBcIlxcXFxsZWZ0XFxcXHZlcnR7XCIuY29uY2F0KGtldCwgXCJ9XFxcXHJpZ2h0XFxcXHJhbmdsZVwiKTtcbiAgICBwYXJzZXIuUHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChtYWNybywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpKTtcbn07XG5QaHlzaWNzTWV0aG9kcy5CcmFLZXQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0YXIgPSBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBicmEgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIGtldCA9IG51bGw7XG4gICAgaWYgKHBhcnNlci5HZXROZXh0KCkgPT09ICd7Jykge1xuICAgICAgICBrZXQgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHZhciBtYWNybyA9ICcnO1xuICAgIGlmIChrZXQgPT0gbnVsbCkge1xuICAgICAgICBtYWNybyA9IHN0YXIgP1xuICAgICAgICAgICAgXCJcXFxcbGFuZ2xle1wiLmNvbmNhdChicmEsIFwifVxcXFx2ZXJ0e1wiKS5jb25jYXQoYnJhLCBcIn1cXFxccmFuZ2xlXCIpIDpcbiAgICAgICAgICAgIFwiXFxcXGxlZnRcXFxcbGFuZ2xle1wiLmNvbmNhdChicmEsIFwifVxcXFxtaWRkbGVcXFxcdmVydHtcIikuY29uY2F0KGJyYSwgXCJ9XFxcXHJpZ2h0XFxcXHJhbmdsZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hY3JvID0gc3RhciA/XG4gICAgICAgICAgICBcIlxcXFxsYW5nbGV7XCIuY29uY2F0KGJyYSwgXCJ9XFxcXHZlcnR7XCIpLmNvbmNhdChrZXQsIFwifVxcXFxyYW5nbGVcIikgOlxuICAgICAgICAgICAgXCJcXFxcbGVmdFxcXFxsYW5nbGV7XCIuY29uY2F0KGJyYSwgXCJ9XFxcXG1pZGRsZVxcXFx2ZXJ0e1wiKS5jb25jYXQoa2V0LCBcIn1cXFxccmlnaHRcXFxccmFuZ2xlXCIpO1xuICAgIH1cbiAgICBwYXJzZXIuUHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChtYWNybywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpKTtcbn07XG5QaHlzaWNzTWV0aG9kcy5LZXRCcmEgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0YXIgPSBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBrZXQgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIGJyYSA9IG51bGw7XG4gICAgaWYgKHBhcnNlci5HZXROZXh0KCkgPT09ICd7Jykge1xuICAgICAgICBicmEgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHZhciBtYWNybyA9ICcnO1xuICAgIGlmIChicmEgPT0gbnVsbCkge1xuICAgICAgICBtYWNybyA9IHN0YXIgP1xuICAgICAgICAgICAgXCJcXFxcdmVydHtcIi5jb25jYXQoa2V0LCBcIn1cXFxccmFuZ2xlXFxcXCFcXFxcbGFuZ2xle1wiKS5jb25jYXQoa2V0LCBcIn1cXFxcdmVydFwiKSA6XG4gICAgICAgICAgICBcIlxcXFxsZWZ0XFxcXHZlcnR7XCIuY29uY2F0KGtldCwgXCJ9XFxcXG1pZGRsZVxcXFxyYW5nbGVcXFxcIVxcXFxtaWRkbGVcXFxcbGFuZ2xle1wiKS5jb25jYXQoa2V0LCBcIn1cXFxccmlnaHRcXFxcdmVydFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hY3JvID0gc3RhciA/XG4gICAgICAgICAgICBcIlxcXFx2ZXJ0e1wiLmNvbmNhdChrZXQsIFwifVxcXFxyYW5nbGVcXFxcIVxcXFxsYW5nbGV7XCIpLmNvbmNhdChicmEsIFwifVxcXFx2ZXJ0XCIpIDpcbiAgICAgICAgICAgIFwiXFxcXGxlZnRcXFxcdmVydHtcIi5jb25jYXQoa2V0LCBcIn1cXFxcbWlkZGxlXFxcXHJhbmdsZVxcXFwhXFxcXG1pZGRsZVxcXFxsYW5nbGV7XCIpLmNvbmNhdChicmEsIFwifVxcXFxyaWdodFxcXFx2ZXJ0XCIpO1xuICAgIH1cbiAgICBwYXJzZXIuUHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChtYWNybywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpKTtcbn07XG5mdW5jdGlvbiBvdXRwdXRCcmFrZXQoX2EsIHN0YXIxLCBzdGFyMikge1xuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMyksIGFyZzEgPSBfYlswXSwgYXJnMiA9IF9iWzFdLCBhcmczID0gX2JbMl07XG4gICAgcmV0dXJuIChzdGFyMSAmJiBzdGFyMikgP1xuICAgICAgICBcIlxcXFxsZWZ0XFxcXGxhbmdsZXtcIi5jb25jYXQoYXJnMSwgXCJ9XFxcXG1pZGRsZVxcXFx2ZXJ0e1wiKS5jb25jYXQoYXJnMiwgXCJ9XFxcXG1pZGRsZVxcXFx2ZXJ0e1wiKS5jb25jYXQoYXJnMywgXCJ9XFxcXHJpZ2h0XFxcXHJhbmdsZVwiKSA6XG4gICAgICAgIChzdGFyMSA/IFwiXFxcXGxhbmdsZXtcIi5jb25jYXQoYXJnMSwgXCJ9XFxcXHZlcnR7XCIpLmNvbmNhdChhcmcyLCBcIn1cXFxcdmVydHtcIikuY29uY2F0KGFyZzMsIFwifVxcXFxyYW5nbGVcIikgOlxuICAgICAgICAgICAgXCJcXFxcbGVmdFxcXFxsYW5nbGV7XCIuY29uY2F0KGFyZzEsIFwifVxcXFxyaWdodFxcXFx2ZXJ0e1wiKS5jb25jYXQoYXJnMiwgXCJ9XFxcXGxlZnRcXFxcdmVydHtcIikuY29uY2F0KGFyZzMsIFwifVxcXFxyaWdodFxcXFxyYW5nbGVcIikpO1xufVxuUGh5c2ljc01ldGhvZHMuRXhwZWN0YXRpb24gPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0YXIxID0gcGFyc2VyLkdldFN0YXIoKTtcbiAgICB2YXIgc3RhcjIgPSBzdGFyMSAmJiBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBhcmcxID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmcyID0gbnVsbDtcbiAgICBpZiAocGFyc2VyLkdldE5leHQoKSA9PT0gJ3snKSB7XG4gICAgICAgIGFyZzIgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHZhciBtYWNybyA9IChhcmcxICYmIGFyZzIpID9cbiAgICAgICAgb3V0cHV0QnJha2V0KFthcmcyLCBhcmcxLCBhcmcyXSwgc3RhcjEsIHN0YXIyKSA6XG4gICAgICAgIChzdGFyMSA/IFwiXFxcXGxhbmdsZSB7XCIuY29uY2F0KGFyZzEsIFwifSBcXFxccmFuZ2xlXCIpIDpcbiAgICAgICAgICAgIFwiXFxcXGxlZnRcXFxcbGFuZ2xlIHtcIi5jb25jYXQoYXJnMSwgXCJ9IFxcXFxyaWdodFxcXFxyYW5nbGVcIikpO1xuICAgIHBhcnNlci5QdXNoKG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KG1hY3JvLCBwYXJzZXIuc3RhY2suZW52LCBwYXJzZXIuY29uZmlndXJhdGlvbikubW1sKCkpO1xufTtcblBoeXNpY3NNZXRob2RzLk1hdHJpeEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIHN0YXIxID0gcGFyc2VyLkdldFN0YXIoKTtcbiAgICB2YXIgc3RhcjIgPSBzdGFyMSAmJiBwYXJzZXIuR2V0U3RhcigpO1xuICAgIHZhciBhcmcxID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmcyID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBhcmczID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBtYWNybyA9IG91dHB1dEJyYWtldChbYXJnMSwgYXJnMiwgYXJnM10sIHN0YXIxLCBzdGFyMik7XG4gICAgcGFyc2VyLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQobWFjcm8sIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG59O1xuUGh5c2ljc01ldGhvZHMuTWF0cml4UXVhbnRpdHkgPSBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBzbWFsbCkge1xuICAgIHZhciBzdGFyID0gcGFyc2VyLkdldFN0YXIoKTtcbiAgICB2YXIgbmV4dCA9IHBhcnNlci5HZXROZXh0KCk7XG4gICAgdmFyIGFycmF5ID0gc21hbGwgPyAnc21hbGxtYXRyaXgnIDogJ2FycmF5JztcbiAgICB2YXIgYXJnID0gJyc7XG4gICAgdmFyIG9wZW4gPSAnJztcbiAgICB2YXIgY2xvc2UgPSAnJztcbiAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICAgICAgb3BlbiA9IHN0YXIgPyAnXFxcXGxncm91cCcgOiAnKCc7XG4gICAgICAgICAgICBjbG9zZSA9IHN0YXIgPyAnXFxcXHJncm91cCcgOiAnKSc7XG4gICAgICAgICAgICBhcmcgPSBwYXJzZXIuR2V0VXBUbyhuYW1lLCAnKScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcGFyc2VyLmkrKztcbiAgICAgICAgICAgIG9wZW4gPSAnWyc7XG4gICAgICAgICAgICBjbG9zZSA9ICddJztcbiAgICAgICAgICAgIGFyZyA9IHBhcnNlci5HZXRVcFRvKG5hbWUsICddJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICAgICAgb3BlbiA9ICd8JztcbiAgICAgICAgICAgIGNsb3NlID0gJ3wnO1xuICAgICAgICAgICAgYXJnID0gcGFyc2VyLkdldFVwVG8obmFtZSwgJ3wnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3BlbiA9ICcoJztcbiAgICAgICAgICAgIGNsb3NlID0gJyknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtYWNybyA9IChvcGVuID8gJ1xcXFxsZWZ0JyA6ICcnKSArIG9wZW4gK1xuICAgICAgICAnXFxcXGJlZ2lueycgKyBhcnJheSArICd9e30gJyArIGFyZyArICdcXFxcZW5keycgKyBhcnJheSArICd9JyArXG4gICAgICAgIChvcGVuID8gJ1xcXFxyaWdodCcgOiAnJykgKyBjbG9zZTtcbiAgICBwYXJzZXIuUHVzaChuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdChtYWNybywgcGFyc2VyLnN0YWNrLmVudiwgcGFyc2VyLmNvbmZpZ3VyYXRpb24pLm1tbCgpKTtcbn07XG5QaHlzaWNzTWV0aG9kcy5JZGVudGl0eU1hdHJpeCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgYXJnID0gcGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpO1xuICAgIHZhciBzaXplID0gcGFyc2VJbnQoYXJnLCAxMCk7XG4gICAgaWYgKGlzTmFOKHNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0ludmFsaWROdW1iZXInLCAnSW52YWxpZCBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPD0gMSkge1xuICAgICAgICBwYXJzZXIuc3RyaW5nID0gJzEnICsgcGFyc2VyLnN0cmluZy5zbGljZShwYXJzZXIuaSk7XG4gICAgICAgIHBhcnNlci5pID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgemVyb3MgPSBBcnJheShzaXplKS5maWxsKCcwJyk7XG4gICAgdmFyIGNvbHVtbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB2YXIgcm93ID0gemVyb3Muc2xpY2UoKTtcbiAgICAgICAgcm93W2ldID0gJzEnO1xuICAgICAgICBjb2x1bW5zLnB1c2gocm93LmpvaW4oJyAmICcpKTtcbiAgICB9XG4gICAgcGFyc2VyLnN0cmluZyA9IGNvbHVtbnMuam9pbignXFxcXFxcXFwgJykgKyBwYXJzZXIuc3RyaW5nLnNsaWNlKHBhcnNlci5pKTtcbiAgICBwYXJzZXIuaSA9IDA7XG59O1xuUGh5c2ljc01ldGhvZHMuWE1hdHJpeCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgc3RhciA9IHBhcnNlci5HZXRTdGFyKCk7XG4gICAgdmFyIGFyZzEgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIGFyZzIgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIGFyZzMgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIG4gPSBwYXJzZUludChhcmcyLCAxMCk7XG4gICAgdmFyIG0gPSBwYXJzZUludChhcmczLCAxMCk7XG4gICAgaWYgKGlzTmFOKG4pIHx8IGlzTmFOKG0pIHx8IG0udG9TdHJpbmcoKSAhPT0gYXJnMyB8fCBuLnRvU3RyaW5nKCkgIT09IGFyZzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSW52YWxpZE51bWJlcicsICdJbnZhbGlkIG51bWJlcicpO1xuICAgIH1cbiAgICBuID0gbiA8IDEgPyAxIDogbjtcbiAgICBtID0gbSA8IDEgPyAxIDogbTtcbiAgICBpZiAoIXN0YXIpIHtcbiAgICAgICAgdmFyIHJvdyA9IEFycmF5KG0pLmZpbGwoYXJnMSkuam9pbignICYgJyk7XG4gICAgICAgIHZhciBtYXRyaXhfMSA9IEFycmF5KG4pLmZpbGwocm93KS5qb2luKCdcXFxcXFxcXCAnKTtcbiAgICAgICAgcGFyc2VyLnN0cmluZyA9IG1hdHJpeF8xICsgcGFyc2VyLnN0cmluZy5zbGljZShwYXJzZXIuaSk7XG4gICAgICAgIHBhcnNlci5pID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWF0cml4ID0gJyc7XG4gICAgaWYgKG4gPT09IDEgJiYgbSA9PT0gMSkge1xuICAgICAgICBtYXRyaXggPSBhcmcxO1xuICAgIH1cbiAgICBlbHNlIGlmIChuID09PSAxKSB7XG4gICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbTsgaSsrKSB7XG4gICAgICAgICAgICByb3cucHVzaChcIlwiLmNvbmNhdChhcmcxLCBcIl97XCIpLmNvbmNhdChpLCBcIn1cIikpO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeCA9IHJvdy5qb2luKCcgJiAnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobSA9PT0gMSkge1xuICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgcm93LnB1c2goXCJcIi5jb25jYXQoYXJnMSwgXCJfe1wiKS5jb25jYXQoaSwgXCJ9XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXggPSByb3cuam9pbignXFxcXFxcXFwgJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IG07IGorKykge1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKFwiXCIuY29uY2F0KGFyZzEsIFwiX3t7XCIpLmNvbmNhdChpLCBcIn17XCIpLmNvbmNhdChqLCBcIn19XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cuam9pbignICYgJykpO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeCA9IHJvd3Muam9pbignXFxcXFxcXFwgJyk7XG4gICAgfVxuICAgIHBhcnNlci5zdHJpbmcgPSBtYXRyaXggKyBwYXJzZXIuc3RyaW5nLnNsaWNlKHBhcnNlci5pKTtcbiAgICBwYXJzZXIuaSA9IDA7XG4gICAgcmV0dXJuO1xufTtcblBoeXNpY3NNZXRob2RzLlBhdWxpTWF0cml4ID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBhcmcgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgdmFyIG1hdHJpeCA9IGFyZy5zbGljZSgxKTtcbiAgICBzd2l0Y2ggKGFyZ1swXSkge1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIG1hdHJpeCArPSAnIDEgJiAwXFxcXFxcXFwgMCAmIDEnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzEnOlxuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIG1hdHJpeCArPSAnIDAgJiAxXFxcXFxcXFwgMSAmIDAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzInOlxuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIG1hdHJpeCArPSAnIDAgJiAtaVxcXFxcXFxcIGkgJiAwJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICczJzpcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICBtYXRyaXggKz0gJyAxICYgMFxcXFxcXFxcIDAgJiAtMSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgcGFyc2VyLnN0cmluZyA9IG1hdHJpeCArIHBhcnNlci5zdHJpbmcuc2xpY2UocGFyc2VyLmkpO1xuICAgIHBhcnNlci5pID0gMDtcbn07XG5QaHlzaWNzTWV0aG9kcy5EaWFnb25hbE1hdHJpeCA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUsIGFudGkpIHtcbiAgICBpZiAocGFyc2VyLkdldE5leHQoKSAhPT0gJ3snKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YXJ0SSA9IHBhcnNlci5pO1xuICAgIHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICB2YXIgZW5kSSA9IHBhcnNlci5pO1xuICAgIHBhcnNlci5pID0gc3RhcnRJICsgMTtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgZWxlbWVudCA9ICcnO1xuICAgIHZhciBjdXJyZW50SSA9IHBhcnNlci5pO1xuICAgIHdoaWxlIChjdXJyZW50SSA8IGVuZEkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwYXJzZXIuR2V0VXBUbyhuYW1lLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBwYXJzZXIuaSA9IGVuZEk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlci5zdHJpbmcuc2xpY2UoY3VycmVudEksIGVuZEkgLSAxKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLmkgPj0gZW5kSSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZXIuc3RyaW5nLnNsaWNlKGN1cnJlbnRJLCBlbmRJKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SSA9IHBhcnNlci5pO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBwYXJzZXIuc3RyaW5nID0gbWFrZURpYWdNYXRyaXgoZWxlbWVudHMsIGFudGkpICsgcGFyc2VyLnN0cmluZy5zbGljZShlbmRJKTtcbiAgICBwYXJzZXIuaSA9IDA7XG59O1xuZnVuY3Rpb24gbWFrZURpYWdNYXRyaXgoZWxlbWVudHMsIGFudGkpIHtcbiAgICB2YXIgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdHJpeC5wdXNoKEFycmF5KGFudGkgPyBsZW5ndGggLSBpIDogaSArIDEpLmpvaW4oJyYnKSArXG4gICAgICAgICAgICAnXFxcXG1xdHl7JyArIGVsZW1lbnRzW2ldICsgJ30nKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeC5qb2luKCdcXFxcXFxcXCAnKTtcbn1cblBoeXNpY3NNZXRob2RzLkF1dG9DbG9zZSA9IGZ1bmN0aW9uIChwYXJzZXIsIGZlbmNlLCBfdGV4Y2xhc3MpIHtcbiAgICB2YXIgbW8gPSBwYXJzZXIuY3JlYXRlKCd0b2tlbicsICdtbycsIHsgc3RyZXRjaHk6IGZhbHNlIH0sIGZlbmNlKTtcbiAgICB2YXIgaXRlbSA9IHBhcnNlci5pdGVtRmFjdG9yeS5jcmVhdGUoJ21tbCcsIG1vKS5cbiAgICAgICAgc2V0UHJvcGVydGllcyh7IGF1dG9jbG9zZTogZmVuY2UgfSk7XG4gICAgcGFyc2VyLlB1c2goaXRlbSk7XG59O1xuUGh5c2ljc01ldGhvZHMuVm5hYmxhID0gZnVuY3Rpb24gKHBhcnNlciwgX25hbWUpIHtcbiAgICB2YXIgYXJndW1lbnQgPSBwYXJzZXIub3B0aW9ucy5waHlzaWNzLmFycm93ZGVsID9cbiAgICAgICAgJ1xcXFx2ZWN7XFxcXGdyYWRpZW50bmFibGF9JyA6ICd7XFxcXGdyYWRpZW50bmFibGF9JztcbiAgICByZXR1cm4gcGFyc2VyLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoYXJndW1lbnQsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG59O1xuUGh5c2ljc01ldGhvZHMuRGlmZkQgPSBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSkge1xuICAgIHZhciBhcmd1bWVudCA9IHBhcnNlci5vcHRpb25zLnBoeXNpY3MuaXRhbGljZGlmZiA/ICdkJyA6ICd7XFxcXHJtIGR9JztcbiAgICByZXR1cm4gcGFyc2VyLlB1c2gobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoYXJndW1lbnQsIHBhcnNlci5zdGFjay5lbnYsIHBhcnNlci5jb25maWd1cmF0aW9uKS5tbWwoKSk7XG59O1xuUGh5c2ljc01ldGhvZHMuTWFjcm8gPSBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuTWFjcm87XG5QaHlzaWNzTWV0aG9kcy5OYW1lZEZuID0gQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lk5hbWVkRm47XG5QaHlzaWNzTWV0aG9kcy5BcnJheSA9IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5BcnJheTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBoeXNpY3NNZXRob2RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGh5c2ljc01ldGhvZHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNldE9wdGlvbnNDb25maWd1cmF0aW9uID0gZXhwb3J0cy5TZXRPcHRpb25zVXRpbCA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4RXJyb3IuanNcIikpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIFN5bWJvbF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbC5qc1wiKTtcbnZhciBCYXNlTWV0aG9kc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9iYXNlL0Jhc2VNZXRob2RzLmpzXCIpKTtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xuZXhwb3J0cy5TZXRPcHRpb25zVXRpbCA9IHtcbiAgICBmaWx0ZXJQYWNrYWdlOiBmdW5jdGlvbiAocGFyc2VyLCBleHRlbnNpb24pIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gJ3RleCcgJiYgIUNvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uSGFuZGxlci5nZXQoZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTm90QVBhY2thZ2UnLCAnTm90IGEgZGVmaW5lZCBwYWNrYWdlOiAlMScsIGV4dGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbmZpZyA9IHBhcnNlci5vcHRpb25zLnNldG9wdGlvbnM7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29uZmlnLmFsbG93T3B0aW9uc1tleHRlbnNpb25dO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiAhY29uZmlnLmFsbG93UGFja2FnZURlZmF1bHQpIHx8IG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdQYWNrYWdlTm90U2V0dGFibGUnLCAnT3B0aW9ucyBjYW5cXCd0IGJlIHNldCBmb3IgcGFja2FnZSBcIiUxXCInLCBleHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZmlsdGVyT3B0aW9uOiBmdW5jdGlvbiAocGFyc2VyLCBleHRlbnNpb24sIG9wdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjb25maWcgPSBwYXJzZXIub3B0aW9ucy5zZXRvcHRpb25zO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbmZpZy5hbGxvd09wdGlvbnNbZXh0ZW5zaW9uXSB8fCB7fTtcbiAgICAgICAgdmFyIGFsbG93ID0gKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKDAsIE9wdGlvbnNfanNfMS5pc09iamVjdCkob3B0aW9uc1tvcHRpb25dKSA/IG9wdGlvbnNbb3B0aW9uXSA6IG51bGwpO1xuICAgICAgICBpZiAoYWxsb3cgPT09IGZhbHNlIHx8IChhbGxvdyA9PT0gbnVsbCAmJiAhY29uZmlnLmFsbG93T3B0aW9uc0RlZmF1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdPcHRpb25Ob3RTZXR0YWJsZScsICdPcHRpb24gXCIlMVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHNldCcsIG9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF9hID0gKGV4dGVuc2lvbiA9PT0gJ3RleCcgPyBwYXJzZXIub3B0aW9ucyA6IHBhcnNlci5vcHRpb25zW2V4dGVuc2lvbl0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzT3duUHJvcGVydHkob3B0aW9uKSkpIHtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24gPT09ICd0ZXgnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSW52YWxpZFRleE9wdGlvbicsICdJbnZhbGlkIFRlWCBvcHRpb24gXCIlMVwiJywgb3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0ludmFsaWRPcHRpb25LZXknLCAnSW52YWxpZCBvcHRpb24gXCIlMVwiIGZvciBwYWNrYWdlIFwiJTJcIicsIG9wdGlvbiwgZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGZpbHRlclZhbHVlOiBmdW5jdGlvbiAoX3BhcnNlciwgX2V4dGVuc2lvbiwgX29wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG52YXIgc2V0T3B0aW9uc01hcCA9IG5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdzZXRvcHRpb25zJywge1xuICAgIHNldE9wdGlvbnM6ICdTZXRPcHRpb25zJ1xufSwge1xuICAgIFNldE9wdGlvbnM6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSkgfHwgJ3RleCc7XG4gICAgICAgIHZhciBvcHRpb25zID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5rZXl2YWxPcHRpb25zKHBhcnNlci5HZXRBcmd1bWVudChuYW1lKSk7XG4gICAgICAgIHZhciBjb25maWcgPSBwYXJzZXIub3B0aW9ucy5zZXRvcHRpb25zO1xuICAgICAgICBpZiAoIWNvbmZpZy5maWx0ZXJQYWNrYWdlKHBhcnNlciwgZXh0ZW5zaW9uKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMob3B0aW9ucykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZmlsdGVyT3B0aW9uKHBhcnNlciwgZXh0ZW5zaW9uLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIChleHRlbnNpb24gPT09ICd0ZXgnID8gcGFyc2VyLm9wdGlvbnMgOiBwYXJzZXIub3B0aW9uc1tleHRlbnNpb25dKVtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5maWx0ZXJWYWx1ZShwYXJzZXIsIGV4dGVuc2lvbiwga2V5LCBvcHRpb25zW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5mdW5jdGlvbiBzZXRvcHRpb25zQ29uZmlnKF9jb25maWcsIGpheCkge1xuICAgIHZhciByZXF1aXJlID0gamF4LnBhcnNlT3B0aW9ucy5oYW5kbGVycy5nZXQoJ21hY3JvJykubG9va3VwKCdyZXF1aXJlJyk7XG4gICAgaWYgKHJlcXVpcmUpIHtcbiAgICAgICAgc2V0T3B0aW9uc01hcC5hZGQoJ1JlcXVpcmUnLCBuZXcgU3ltYm9sX2pzXzEuTWFjcm8oJ1JlcXVpcmUnLCByZXF1aXJlLl9mdW5jKSk7XG4gICAgICAgIHNldE9wdGlvbnNNYXAuYWRkKCdyZXF1aXJlJywgbmV3IFN5bWJvbF9qc18xLk1hY3JvKCdyZXF1aXJlJywgQmFzZU1ldGhvZHNfanNfMS5kZWZhdWx0Lk1hY3JvLCBbJ1xcXFxSZXF1aXJleyMyfVxcXFxzZXRPcHRpb25zWyMyXXsjMX0nLCAyLCAnJ10pKTtcbiAgICB9XG59XG5leHBvcnRzLlNldE9wdGlvbnNDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdzZXRvcHRpb25zJywge1xuICAgIGhhbmRsZXI6IHsgbWFjcm86IFsnc2V0b3B0aW9ucyddIH0sXG4gICAgY29uZmlnOiBzZXRvcHRpb25zQ29uZmlnLFxuICAgIHByaW9yaXR5OiAzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2V0b3B0aW9uczoge1xuICAgICAgICAgICAgZmlsdGVyUGFja2FnZTogZXhwb3J0cy5TZXRPcHRpb25zVXRpbC5maWx0ZXJQYWNrYWdlLFxuICAgICAgICAgICAgZmlsdGVyT3B0aW9uOiBleHBvcnRzLlNldE9wdGlvbnNVdGlsLmZpbHRlck9wdGlvbixcbiAgICAgICAgICAgIGZpbHRlclZhbHVlOiBleHBvcnRzLlNldE9wdGlvbnNVdGlsLmZpbHRlclZhbHVlLFxuICAgICAgICAgICAgYWxsb3dQYWNrYWdlRGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93T3B0aW9uc0RlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICBhbGxvd09wdGlvbnM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoe1xuICAgICAgICAgICAgICAgIHRleDoge1xuICAgICAgICAgICAgICAgICAgICBGaW5kVGVYOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0RXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYWNrYWdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVSTDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtYXhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtYXhNYXhyb3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtYWNyb3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudHM6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXRvcHRpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvbG9hZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlnbWFjcm9zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWdmb3JtYXQ6IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXRPcHRpb25zQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhZ0Zvcm1hdENvbmZpZ3VyYXRpb24gPSBleHBvcnRzLnRhZ2Zvcm1hdENvbmZpZyA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBUYWdzX2pzXzEgPSByZXF1aXJlKFwiLi4vVGFncy5qc1wiKTtcbnZhciB0YWdJRCA9IDA7XG5mdW5jdGlvbiB0YWdmb3JtYXRDb25maWcoY29uZmlnLCBqYXgpIHtcbiAgICB2YXIgdGFncyA9IGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy50YWdzO1xuICAgIGlmICh0YWdzICE9PSAnYmFzZScgJiYgY29uZmlnLnRhZ3MuaGFzT3duUHJvcGVydHkodGFncykpIHtcbiAgICAgICAgVGFnc19qc18xLlRhZ3NGYWN0b3J5LmFkZCh0YWdzLCBjb25maWcudGFnc1t0YWdzXSk7XG4gICAgfVxuICAgIHZhciBUYWdDbGFzcyA9IFRhZ3NfanNfMS5UYWdzRmFjdG9yeS5jcmVhdGUoamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLnRhZ3MpLmNvbnN0cnVjdG9yO1xuICAgIHZhciBUYWdGb3JtYXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVGFnRm9ybWF0LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUYWdGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgVGFnRm9ybWF0LnByb3RvdHlwZS5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy50YWdmb3JtYXQubnVtYmVyKG4pO1xuICAgICAgICB9O1xuICAgICAgICBUYWdGb3JtYXQucHJvdG90eXBlLmZvcm1hdFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBqYXgucGFyc2VPcHRpb25zLm9wdGlvbnMudGFnZm9ybWF0LnRhZyh0YWcpO1xuICAgICAgICB9O1xuICAgICAgICBUYWdGb3JtYXQucHJvdG90eXBlLmZvcm1hdElkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLnRhZ2Zvcm1hdC5pZChpZCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhZ0Zvcm1hdC5wcm90b3R5cGUuZm9ybWF0VXJsID0gZnVuY3Rpb24gKGlkLCBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLnRhZ2Zvcm1hdC51cmwoaWQsIGJhc2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGFnRm9ybWF0O1xuICAgIH0oVGFnQ2xhc3MpKTtcbiAgICB0YWdJRCsrO1xuICAgIHZhciB0YWdOYW1lID0gJ2NvbmZpZ1RhZ3MtJyArIHRhZ0lEO1xuICAgIFRhZ3NfanNfMS5UYWdzRmFjdG9yeS5hZGQodGFnTmFtZSwgVGFnRm9ybWF0KTtcbiAgICBqYXgucGFyc2VPcHRpb25zLm9wdGlvbnMudGFncyA9IHRhZ05hbWU7XG59XG5leHBvcnRzLnRhZ2Zvcm1hdENvbmZpZyA9IHRhZ2Zvcm1hdENvbmZpZztcbmV4cG9ydHMuVGFnRm9ybWF0Q29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgndGFnZm9ybWF0Jywge1xuICAgIGNvbmZpZzogW3RhZ2Zvcm1hdENvbmZpZywgMTBdLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdGFnZm9ybWF0OiB7XG4gICAgICAgICAgICBudW1iZXI6IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnRvU3RyaW5nKCk7IH0sXG4gICAgICAgICAgICB0YWc6IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuICcoJyArIHRhZyArICcpJzsgfSxcbiAgICAgICAgICAgIGlkOiBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICdtangtZXFuOicgKyBpZC5yZXBsYWNlKC9cXHMvZywgJ18nKTsgfSxcbiAgICAgICAgICAgIHVybDogZnVuY3Rpb24gKGlkLCBiYXNlKSB7IHJldHVybiBiYXNlICsgJyMnICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTsgfSxcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFnRm9ybWF0Q29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGV4dGNvbXBDb25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vVGV4dGNvbXBNYXBwaW5ncy5qc1wiKTtcbmV4cG9ydHMuVGV4dGNvbXBDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCd0ZXh0Y29tcCcsIHtcbiAgICBoYW5kbGVyOiB7IG1hY3JvOiBbJ3RleHRjb21wLW1hY3JvcyddIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dGNvbXBDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBUZXhDb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuLi9UZXhDb25zdGFudHMuanNcIik7XG52YXIgVGV4dE1hY3Jvc01ldGhvZHNfanNfMSA9IHJlcXVpcmUoXCIuLi90ZXh0bWFjcm9zL1RleHRNYWNyb3NNZXRob2RzLmpzXCIpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIFRleHRQYXJzZXJfanNfMSA9IHJlcXVpcmUoXCIuLi90ZXh0bWFjcm9zL1RleHRQYXJzZXIuanNcIik7XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgndGV4dGNvbXAtbWFjcm9zJywge1xuICAgICd0ZXh0YXNjaWljaXJjdW0nOiBbJ0luc2VydCcsICdcXHUwMDVFJ10sXG4gICAgJ3RleHRhc2NpaXRpbGRlJzogWydJbnNlcnQnLCAnXFx1MDA3RSddLFxuICAgICd0ZXh0YXN0ZXJpc2tjZW50ZXJlZCc6IFsnSW5zZXJ0JywgJ1xcdTAwMkEnXSxcbiAgICAndGV4dGJhY2tzbGFzaCc6IFsnSW5zZXJ0JywgJ1xcdTAwNUMnXSxcbiAgICAndGV4dGJhcic6IFsnSW5zZXJ0JywgJ1xcdTAwN0MnXSxcbiAgICAndGV4dGJyYWNlbGVmdCc6IFsnSW5zZXJ0JywgJ1xcdTAwN0InXSxcbiAgICAndGV4dGJyYWNlcmlnaHQnOiBbJ0luc2VydCcsICdcXHUwMDdEJ10sXG4gICAgJ3RleHRidWxsZXQnOiBbJ0luc2VydCcsICdcXHUyMDIyJ10sXG4gICAgJ3RleHRkYWdnZXInOiBbJ0luc2VydCcsICdcXHUyMDIwJ10sXG4gICAgJ3RleHRkYWdnZXJkYmwnOiBbJ0luc2VydCcsICdcXHUyMDIxJ10sXG4gICAgJ3RleHRlbGxpcHNpcyc6IFsnSW5zZXJ0JywgJ1xcdTIwMjYnXSxcbiAgICAndGV4dGVtZGFzaCc6IFsnSW5zZXJ0JywgJ1xcdTIwMTQnXSxcbiAgICAndGV4dGVuZGFzaCc6IFsnSW5zZXJ0JywgJ1xcdTIwMTMnXSxcbiAgICAndGV4dGV4Y2xhbWRvd24nOiBbJ0luc2VydCcsICdcXHUwMEExJ10sXG4gICAgJ3RleHRncmVhdGVyJzogWydJbnNlcnQnLCAnXFx1MDAzRSddLFxuICAgICd0ZXh0bGVzcyc6IFsnSW5zZXJ0JywgJ1xcdTAwM0MnXSxcbiAgICAndGV4dG9yZGZlbWluaW5lJzogWydJbnNlcnQnLCAnXFx1MDBBQSddLFxuICAgICd0ZXh0b3JkbWFzY3VsaW5lJzogWydJbnNlcnQnLCAnXFx1MDBCQSddLFxuICAgICd0ZXh0cGFyYWdyYXBoJzogWydJbnNlcnQnLCAnXFx1MDBCNiddLFxuICAgICd0ZXh0cGVyaW9kY2VudGVyZWQnOiBbJ0luc2VydCcsICdcXHUwMEI3J10sXG4gICAgJ3RleHRxdWVzdGlvbmRvd24nOiBbJ0luc2VydCcsICdcXHUwMEJGJ10sXG4gICAgJ3RleHRxdW90ZWRibGxlZnQnOiBbJ0luc2VydCcsICdcXHUyMDFDJ10sXG4gICAgJ3RleHRxdW90ZWRibHJpZ2h0JzogWydJbnNlcnQnLCAnXFx1MjAxRCddLFxuICAgICd0ZXh0cXVvdGVsZWZ0JzogWydJbnNlcnQnLCAnXFx1MjAxOCddLFxuICAgICd0ZXh0cXVvdGVyaWdodCc6IFsnSW5zZXJ0JywgJ1xcdTIwMTknXSxcbiAgICAndGV4dHNlY3Rpb24nOiBbJ0luc2VydCcsICdcXHUwMEE3J10sXG4gICAgJ3RleHR1bmRlcnNjb3JlJzogWydJbnNlcnQnLCAnXFx1MDA1RiddLFxuICAgICd0ZXh0dmlzaWJsZXNwYWNlJzogWydJbnNlcnQnLCAnXFx1MjQyMyddLFxuICAgICd0ZXh0YWN1dGVkYmwnOiBbJ0luc2VydCcsICdcXHUwMkREJ10sXG4gICAgJ3RleHRhc2NpaWFjdXRlJzogWydJbnNlcnQnLCAnXFx1MDBCNCddLFxuICAgICd0ZXh0YXNjaWlicmV2ZSc6IFsnSW5zZXJ0JywgJ1xcdTAyRDgnXSxcbiAgICAndGV4dGFzY2lpY2Fyb24nOiBbJ0luc2VydCcsICdcXHUwMkM3J10sXG4gICAgJ3RleHRhc2NpaWRpZXJlc2lzJzogWydJbnNlcnQnLCAnXFx1MDBBOCddLFxuICAgICd0ZXh0YXNjaWltYWNyb24nOiBbJ0luc2VydCcsICdcXHUwMEFGJ10sXG4gICAgJ3RleHRncmF2ZWRibCc6IFsnSW5zZXJ0JywgJ1xcdTAyRjUnXSxcbiAgICAndGV4dHRpbGRlbG93JzogWydJbnNlcnQnLCAnXFx1MDJGNyddLFxuICAgICd0ZXh0YmFodCc6IFsnSW5zZXJ0JywgJ1xcdTBFM0YnXSxcbiAgICAndGV4dGNlbnQnOiBbJ0luc2VydCcsICdcXHUwMEEyJ10sXG4gICAgJ3RleHRjb2xvbm1vbmV0YXJ5JzogWydJbnNlcnQnLCAnXFx1MjBBMSddLFxuICAgICd0ZXh0Y3VycmVuY3knOiBbJ0luc2VydCcsICdcXHUwMEE0J10sXG4gICAgJ3RleHRkb2xsYXInOiBbJ0luc2VydCcsICdcXHUwMDI0J10sXG4gICAgJ3RleHRkb25nJzogWydJbnNlcnQnLCAnXFx1MjBBQiddLFxuICAgICd0ZXh0ZXVybyc6IFsnSW5zZXJ0JywgJ1xcdTIwQUMnXSxcbiAgICAndGV4dGZsb3Jpbic6IFsnSW5zZXJ0JywgJ1xcdTAxOTInXSxcbiAgICAndGV4dGd1YXJhbmknOiBbJ0luc2VydCcsICdcXHUyMEIyJ10sXG4gICAgJ3RleHRsaXJhJzogWydJbnNlcnQnLCAnXFx1MjBBNCddLFxuICAgICd0ZXh0bmFpcmEnOiBbJ0luc2VydCcsICdcXHUyMEE2J10sXG4gICAgJ3RleHRwZXNvJzogWydJbnNlcnQnLCAnXFx1MjBCMSddLFxuICAgICd0ZXh0c3RlcmxpbmcnOiBbJ0luc2VydCcsICdcXHUwMEEzJ10sXG4gICAgJ3RleHR3b24nOiBbJ0luc2VydCcsICdcXHUyMEE5J10sXG4gICAgJ3RleHR5ZW4nOiBbJ0luc2VydCcsICdcXHUwMEE1J10sXG4gICAgJ3RleHRjaXJjbGVkUCc6IFsnSW5zZXJ0JywgJ1xcdTIxMTcnXSxcbiAgICAndGV4dGNvbXB3b3JkbWFyayc6IFsnSW5zZXJ0JywgJ1xcdTIwMEMnXSxcbiAgICAndGV4dGNvcHlsZWZ0JzogWydJbnNlcnQnLCBcIlxcdUQ4M0NcXHVERDJGXCJdLFxuICAgICd0ZXh0Y29weXJpZ2h0JzogWydJbnNlcnQnLCAnXFx1MDBBOSddLFxuICAgICd0ZXh0cmVnaXN0ZXJlZCc6IFsnSW5zZXJ0JywgJ1xcdTAwQUUnXSxcbiAgICAndGV4dHNlcnZpY2VtYXJrJzogWydJbnNlcnQnLCAnXFx1MjEyMCddLFxuICAgICd0ZXh0dHJhZGVtYXJrJzogWydJbnNlcnQnLCAnXFx1MjEyMiddLFxuICAgICd0ZXh0YmFyZGJsJzogWydJbnNlcnQnLCAnXFx1MjAxNiddLFxuICAgICd0ZXh0YmlnY2lyY2xlJzogWydJbnNlcnQnLCAnXFx1MjVFRiddLFxuICAgICd0ZXh0YmxhbmsnOiBbJ0luc2VydCcsICdcXHUyNDIyJ10sXG4gICAgJ3RleHRicm9rZW5iYXInOiBbJ0luc2VydCcsICdcXHUwMEE2J10sXG4gICAgJ3RleHRkaXNjb3VudCc6IFsnSW5zZXJ0JywgJ1xcdTIwNTInXSxcbiAgICAndGV4dGVzdGltYXRlZCc6IFsnSW5zZXJ0JywgJ1xcdTIxMkUnXSxcbiAgICAndGV4dGludGVycm9iYW5nJzogWydJbnNlcnQnLCAnXFx1MjAzRCddLFxuICAgICd0ZXh0aW50ZXJyb2Jhbmdkb3duJzogWydJbnNlcnQnLCAnXFx1MkUxOCddLFxuICAgICd0ZXh0bXVzaWNhbG5vdGUnOiBbJ0luc2VydCcsICdcXHUyNjZBJ10sXG4gICAgJ3RleHRudW1lcm8nOiBbJ0luc2VydCcsICdcXHUyMTE2J10sXG4gICAgJ3RleHRvcGVuYnVsbGV0JzogWydJbnNlcnQnLCAnXFx1MjVFNiddLFxuICAgICd0ZXh0cGVydGVudGhvdXNhbmQnOiBbJ0luc2VydCcsICdcXHUyMDMxJ10sXG4gICAgJ3RleHRwZXJ0aG91c2FuZCc6IFsnSW5zZXJ0JywgJ1xcdTIwMzAnXSxcbiAgICAndGV4dHJlY2lwZSc6IFsnSW5zZXJ0JywgJ1xcdTIxMUUnXSxcbiAgICAndGV4dHJlZmVyZW5jZW1hcmsnOiBbJ0luc2VydCcsICdcXHUyMDNCJ10sXG4gICAgJ3RleHRsYW5nbGUnOiBbJ0luc2VydCcsICdcXHUyMzI5J10sXG4gICAgJ3RleHRyYW5nbGUnOiBbJ0luc2VydCcsICdcXHUyMzJBJ10sXG4gICAgJ3RleHRsYnJhY2tkYmwnOiBbJ0luc2VydCcsICdcXHUyN0U2J10sXG4gICAgJ3RleHRyYnJhY2tkYmwnOiBbJ0luc2VydCcsICdcXHUyN0U3J10sXG4gICAgJ3RleHRscXVpbGwnOiBbJ0luc2VydCcsICdcXHUyMDQ1J10sXG4gICAgJ3RleHRycXVpbGwnOiBbJ0luc2VydCcsICdcXHUyMDQ2J10sXG4gICAgJ3RleHRjZWxzaXVzJzogWydJbnNlcnQnLCAnXFx1MjEwMyddLFxuICAgICd0ZXh0ZGVncmVlJzogWydJbnNlcnQnLCAnXFx1MDBCMCddLFxuICAgICd0ZXh0ZGl2JzogWydJbnNlcnQnLCAnXFx1MDBGNyddLFxuICAgICd0ZXh0ZG93bmFycm93JzogWydJbnNlcnQnLCAnXFx1MjE5MyddLFxuICAgICd0ZXh0ZnJhY3Rpb25zb2xpZHVzJzogWydJbnNlcnQnLCAnXFx1MjA0NCddLFxuICAgICd0ZXh0bGVmdGFycm93JzogWydJbnNlcnQnLCAnXFx1MjE5MCddLFxuICAgICd0ZXh0bG5vdCc6IFsnSW5zZXJ0JywgJ1xcdTAwQUMnXSxcbiAgICAndGV4dG1obyc6IFsnSW5zZXJ0JywgJ1xcdTIxMjcnXSxcbiAgICAndGV4dG1pbnVzJzogWydJbnNlcnQnLCAnXFx1MjIxMiddLFxuICAgICd0ZXh0bXUnOiBbJ0luc2VydCcsICdcXHUwMEI1J10sXG4gICAgJ3RleHRvaG0nOiBbJ0luc2VydCcsICdcXHUyMTI2J10sXG4gICAgJ3RleHRvbmVoYWxmJzogWydJbnNlcnQnLCAnXFx1MDBCRCddLFxuICAgICd0ZXh0b25lcXVhcnRlcic6IFsnSW5zZXJ0JywgJ1xcdTAwQkMnXSxcbiAgICAndGV4dG9uZXN1cGVyaW9yJzogWydJbnNlcnQnLCAnXFx1MDBCOSddLFxuICAgICd0ZXh0cG0nOiBbJ0luc2VydCcsICdcXHUwMEIxJ10sXG4gICAgJ3RleHRyaWdodGFycm93JzogWydJbnNlcnQnLCAnXFx1MjE5MiddLFxuICAgICd0ZXh0c3VyZCc6IFsnSW5zZXJ0JywgJ1xcdTIyMUEnXSxcbiAgICAndGV4dHRocmVlcXVhcnRlcnMnOiBbJ0luc2VydCcsICdcXHUwMEJFJ10sXG4gICAgJ3RleHR0aHJlZXN1cGVyaW9yJzogWydJbnNlcnQnLCAnXFx1MDBCMyddLFxuICAgICd0ZXh0dGltZXMnOiBbJ0luc2VydCcsICdcXHUwMEQ3J10sXG4gICAgJ3RleHR0d29zdXBlcmlvcic6IFsnSW5zZXJ0JywgJ1xcdTAwQjInXSxcbiAgICAndGV4dHVwYXJyb3cnOiBbJ0luc2VydCcsICdcXHUyMTkxJ10sXG4gICAgJ3RleHRib3JuJzogWydJbnNlcnQnLCAnXFx1MDAyQSddLFxuICAgICd0ZXh0ZGllZCc6IFsnSW5zZXJ0JywgJ1xcdTIwMjAnXSxcbiAgICAndGV4dGRpdm9yY2VkJzogWydJbnNlcnQnLCAnXFx1MjZBRSddLFxuICAgICd0ZXh0bWFycmllZCc6IFsnSW5zZXJ0JywgJ1xcdTI2QUQnXSxcbiAgICAndGV4dGNlbnRvbGRzdHlsZSc6IFsnSW5zZXJ0JywgJ1xcdTAwQTInLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk9MRFNUWUxFXSxcbiAgICAndGV4dGRvbGxhcm9sZHN0eWxlJzogWydJbnNlcnQnLCAnXFx1MDAyNCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuT0xEU1RZTEVdLFxuICAgICd0ZXh0emVyb29sZHN0eWxlJzogWydJbnNlcnQnLCAnMCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuT0xEU1RZTEVdLFxuICAgICd0ZXh0b25lb2xkc3R5bGUnOiBbJ0luc2VydCcsICcxJywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5PTERTVFlMRV0sXG4gICAgJ3RleHR0d29vbGRzdHlsZSc6IFsnSW5zZXJ0JywgJzInLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk9MRFNUWUxFXSxcbiAgICAndGV4dHRocmVlb2xkc3R5bGUnOiBbJ0luc2VydCcsICczJywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5PTERTVFlMRV0sXG4gICAgJ3RleHRmb3Vyb2xkc3R5bGUnOiBbJ0luc2VydCcsICc0JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5PTERTVFlMRV0sXG4gICAgJ3RleHRmaXZlb2xkc3R5bGUnOiBbJ0luc2VydCcsICc1JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5PTERTVFlMRV0sXG4gICAgJ3RleHRzaXhvbGRzdHlsZSc6IFsnSW5zZXJ0JywgJzYnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk9MRFNUWUxFXSxcbiAgICAndGV4dHNldmVub2xkc3R5bGUnOiBbJ0luc2VydCcsICc3JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5PTERTVFlMRV0sXG4gICAgJ3RleHRlaWdodG9sZHN0eWxlJzogWydJbnNlcnQnLCAnOCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuT0xEU1RZTEVdLFxuICAgICd0ZXh0bmluZW9sZHN0eWxlJzogWydJbnNlcnQnLCAnOScsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuT0xEU1RZTEVdXG59LCB7XG4gICAgSW5zZXJ0OiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lLCBjLCBmb250KSB7XG4gICAgICAgIGlmIChwYXJzZXIgaW5zdGFuY2VvZiBUZXh0UGFyc2VyX2pzXzEuVGV4dFBhcnNlcikge1xuICAgICAgICAgICAgaWYgKCFmb250KSB7XG4gICAgICAgICAgICAgICAgVGV4dE1hY3Jvc01ldGhvZHNfanNfMS5UZXh0TWFjcm9zTWV0aG9kcy5JbnNlcnQocGFyc2VyLCBuYW1lLCBjKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuc2F2ZVRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuUHVzaChQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmludGVybmFsVGV4dChwYXJzZXIsIGMsIGZvbnQgPyB7IG1hdGh2YXJpYW50OiBmb250IH0gOiB7fSkpO1xuICAgIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dGNvbXBNYXBwaW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGV4dE1hY3Jvc0NvbmZpZ3VyYXRpb24gPSBleHBvcnRzLlRleHRCYXNlQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBQYXJzZU9wdGlvbnNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vUGFyc2VPcHRpb25zLmpzXCIpKTtcbnZhciBUYWdzX2pzXzEgPSByZXF1aXJlKFwiLi4vVGFncy5qc1wiKTtcbnZhciBCYXNlSXRlbXNfanNfMSA9IHJlcXVpcmUoXCIuLi9iYXNlL0Jhc2VJdGVtcy5qc1wiKTtcbnZhciBUZXh0UGFyc2VyX2pzXzEgPSByZXF1aXJlKFwiLi9UZXh0UGFyc2VyLmpzXCIpO1xudmFyIFRleHRNYWNyb3NNZXRob2RzX2pzXzEgPSByZXF1aXJlKFwiLi9UZXh0TWFjcm9zTWV0aG9kcy5qc1wiKTtcbnJlcXVpcmUoXCIuL1RleHRNYWNyb3NNYXBwaW5ncy5qc1wiKTtcbmV4cG9ydHMuVGV4dEJhc2VDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCd0ZXh0LWJhc2UnLCB7XG4gICAgcGFyc2VyOiAndGV4dCcsXG4gICAgaGFuZGxlcjoge1xuICAgICAgICBjaGFyYWN0ZXI6IFsnY29tbWFuZCcsICd0ZXh0LXNwZWNpYWwnXSxcbiAgICAgICAgbWFjcm86IFsndGV4dC1tYWNyb3MnXVxuICAgIH0sXG4gICAgZmFsbGJhY2s6IHtcbiAgICAgICAgY2hhcmFjdGVyOiBmdW5jdGlvbiAocGFyc2VyLCBjKSB7XG4gICAgICAgICAgICBwYXJzZXIudGV4dCArPSBjO1xuICAgICAgICB9LFxuICAgICAgICBtYWNybzogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHRleFBhcnNlciA9IHBhcnNlci50ZXhQYXJzZXI7XG4gICAgICAgICAgICB2YXIgbWFjcm8gPSB0ZXhQYXJzZXIubG9va3VwKCdtYWNybycsIG5hbWUpO1xuICAgICAgICAgICAgaWYgKG1hY3JvICYmIG1hY3JvLl9mdW5jICE9PSBUZXh0TWFjcm9zTWV0aG9kc19qc18xLlRleHRNYWNyb3NNZXRob2RzLk1hY3JvKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLkVycm9yKCdNYXRoTWFjcm8nLCAnJTEgaXMgb25seSBzdXBwb3J0ZWQgaW4gbWF0aCBtb2RlJywgJ1xcXFwnICsgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXhQYXJzZXIucGFyc2UoJ21hY3JvJywgW3BhcnNlciwgbmFtZV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpdGVtczogKF9hID0ge30sXG4gICAgICAgIF9hW0Jhc2VJdGVtc19qc18xLlN0YXJ0SXRlbS5wcm90b3R5cGUua2luZF0gPSBCYXNlSXRlbXNfanNfMS5TdGFydEl0ZW0sXG4gICAgICAgIF9hW0Jhc2VJdGVtc19qc18xLlN0b3BJdGVtLnByb3RvdHlwZS5raW5kXSA9IEJhc2VJdGVtc19qc18xLlN0b3BJdGVtLFxuICAgICAgICBfYVtCYXNlSXRlbXNfanNfMS5NbWxJdGVtLnByb3RvdHlwZS5raW5kXSA9IEJhc2VJdGVtc19qc18xLk1tbEl0ZW0sXG4gICAgICAgIF9hW0Jhc2VJdGVtc19qc18xLlN0eWxlSXRlbS5wcm90b3R5cGUua2luZF0gPSBCYXNlSXRlbXNfanNfMS5TdHlsZUl0ZW0sXG4gICAgICAgIF9hKVxufSk7XG5mdW5jdGlvbiBpbnRlcm5hbE1hdGgocGFyc2VyLCB0ZXh0LCBsZXZlbCwgbWF0aHZhcmlhbnQpIHtcbiAgICB2YXIgY29uZmlnID0gcGFyc2VyLmNvbmZpZ3VyYXRpb24ucGFja2FnZURhdGEuZ2V0KCd0ZXh0bWFjcm9zJyk7XG4gICAgaWYgKCEocGFyc2VyIGluc3RhbmNlb2YgVGV4dFBhcnNlcl9qc18xLlRleHRQYXJzZXIpKSB7XG4gICAgICAgIGNvbmZpZy50ZXhQYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIHJldHVybiBbKG5ldyBUZXh0UGFyc2VyX2pzXzEuVGV4dFBhcnNlcih0ZXh0LCBtYXRodmFyaWFudCA/IHsgbWF0aHZhcmlhbnQ6IG1hdGh2YXJpYW50IH0gOiB7fSwgY29uZmlnLnBhcnNlT3B0aW9ucywgbGV2ZWwpKS5tbWwoKV07XG59XG5leHBvcnRzLlRleHRNYWNyb3NDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCd0ZXh0bWFjcm9zJywge1xuICAgIGNvbmZpZzogZnVuY3Rpb24gKF9jb25maWcsIGpheCkge1xuICAgICAgICB2YXIgdGV4dENvbmYgPSBuZXcgQ29uZmlndXJhdGlvbl9qc18xLlBhcnNlckNvbmZpZ3VyYXRpb24oamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLnRleHRtYWNyb3MucGFja2FnZXMsIFsndGV4JywgJ3RleHQnXSk7XG4gICAgICAgIHRleHRDb25mLmluaXQoKTtcbiAgICAgICAgdmFyIHBhcnNlT3B0aW9ucyA9IG5ldyBQYXJzZU9wdGlvbnNfanNfMS5kZWZhdWx0KHRleHRDb25mLCBbXSk7XG4gICAgICAgIHBhcnNlT3B0aW9ucy5vcHRpb25zID0gamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zO1xuICAgICAgICB0ZXh0Q29uZi5jb25maWcoamF4KTtcbiAgICAgICAgVGFnc19qc18xLlRhZ3NGYWN0b3J5LmFkZFRhZ3ModGV4dENvbmYudGFncyk7XG4gICAgICAgIHBhcnNlT3B0aW9ucy50YWdzID0gVGFnc19qc18xLlRhZ3NGYWN0b3J5LmdldERlZmF1bHQoKTtcbiAgICAgICAgcGFyc2VPcHRpb25zLnRhZ3MuY29uZmlndXJhdGlvbiA9IHBhcnNlT3B0aW9ucztcbiAgICAgICAgcGFyc2VPcHRpb25zLnBhY2thZ2VEYXRhID0gamF4LnBhcnNlT3B0aW9ucy5wYWNrYWdlRGF0YTtcbiAgICAgICAgcGFyc2VPcHRpb25zLnBhY2thZ2VEYXRhLnNldCgndGV4dG1hY3JvcycsIHsgcGFyc2VPcHRpb25zOiBwYXJzZU9wdGlvbnMsIGpheDogamF4LCB0ZXhQYXJzZXI6IG51bGwgfSk7XG4gICAgICAgIHBhcnNlT3B0aW9ucy5vcHRpb25zLmludGVybmFsTWF0aCA9IGludGVybmFsTWF0aDtcbiAgICB9LFxuICAgIHByZXByb2Nlc3NvcnM6IFtmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGRhdGEuZGF0YS5wYWNrYWdlRGF0YS5nZXQoJ3RleHRtYWNyb3MnKTtcbiAgICAgICAgICAgIGNvbmZpZy5wYXJzZU9wdGlvbnMubm9kZUZhY3Rvcnkuc2V0TW1sRmFjdG9yeShjb25maWcuamF4Lm1tbEZhY3RvcnkpO1xuICAgICAgICB9XSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHRleHRtYWNyb3M6IHtcbiAgICAgICAgICAgIHBhY2thZ2VzOiBbJ3RleHQtYmFzZSddXG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRNYWNyb3NDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN5bWJvbE1hcF9qc18xID0gcmVxdWlyZShcIi4uL1N5bWJvbE1hcC5qc1wiKTtcbnZhciBUZXhDb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuLi9UZXhDb25zdGFudHMuanNcIik7XG52YXIgVGV4dE1hY3Jvc01ldGhvZHNfanNfMSA9IHJlcXVpcmUoXCIuL1RleHRNYWNyb3NNZXRob2RzLmpzXCIpO1xudmFyIGxlbmd0aHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL2xlbmd0aHMuanNcIik7XG5uZXcgU3ltYm9sTWFwX2pzXzEuTWFjcm9NYXAoJ3RleHQtc3BlY2lhbCcsIHtcbiAgICAnJCc6ICdNYXRoJyxcbiAgICAnJSc6ICdDb21tZW50JyxcbiAgICAnXic6ICdNYXRoTW9kZU9ubHknLFxuICAgICdfJzogJ01hdGhNb2RlT25seScsXG4gICAgJyYnOiAnTWlzcGxhY2VkJyxcbiAgICAnIyc6ICdNaXNwbGFjZWQnLFxuICAgICd+JzogJ1RpbGRlJyxcbiAgICAnICc6ICdTcGFjZScsXG4gICAgJ1xcdCc6ICdTcGFjZScsXG4gICAgJ1xccic6ICdTcGFjZScsXG4gICAgJ1xcbic6ICdTcGFjZScsXG4gICAgJ1xcdTAwQTAnOiAnVGlsZGUnLFxuICAgICd7JzogJ09wZW5CcmFjZScsXG4gICAgJ30nOiAnQ2xvc2VCcmFjZScsXG4gICAgJ2AnOiAnT3BlblF1b3RlJyxcbiAgICAnXFwnJzogJ0Nsb3NlUXVvdGUnXG59LCBUZXh0TWFjcm9zTWV0aG9kc19qc18xLlRleHRNYWNyb3NNZXRob2RzKTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCd0ZXh0LW1hY3JvcycsIHtcbiAgICAnKCc6ICdNYXRoJyxcbiAgICAnJCc6ICdTZWxmUXVvdGUnLFxuICAgICdfJzogJ1NlbGZRdW90ZScsXG4gICAgJyUnOiAnU2VsZlF1b3RlJyxcbiAgICAneyc6ICdTZWxmUXVvdGUnLFxuICAgICd9JzogJ1NlbGZRdW90ZScsXG4gICAgJyAnOiAnU2VsZlF1b3RlJyxcbiAgICAnJic6ICdTZWxmUXVvdGUnLFxuICAgICcjJzogJ1NlbGZRdW90ZScsXG4gICAgJ1xcXFwnOiAnU2VsZlF1b3RlJyxcbiAgICAnXFwnJzogWydBY2NlbnQnLCAnXFx1MDBCNCddLFxuICAgICdcXHUyMDE5JzogWydBY2NlbnQnLCAnXFx1MDBCNCddLFxuICAgICdgJzogWydBY2NlbnQnLCAnXFx1MDA2MCddLFxuICAgICdcXHUyMDE4JzogWydBY2NlbnQnLCAnXFx1MDA2MCddLFxuICAgICdeJzogWydBY2NlbnQnLCAnXiddLFxuICAgICdcXFwiJzogWydBY2NlbnQnLCAnXFx1MDBBOCddLFxuICAgICd+JzogWydBY2NlbnQnLCAnfiddLFxuICAgICc9JzogWydBY2NlbnQnLCAnXFx1MDBBRiddLFxuICAgICcuJzogWydBY2NlbnQnLCAnXFx1MDJEOSddLFxuICAgICd1JzogWydBY2NlbnQnLCAnXFx1MDJEOCddLFxuICAgICd2JzogWydBY2NlbnQnLCAnXFx1MDJDNyddLFxuICAgIGVtcGg6ICdFbXBoJyxcbiAgICBybTogWydTZXRGb250JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5OT1JNQUxdLFxuICAgIG1pdDogWydTZXRGb250JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5JVEFMSUNdLFxuICAgIG9sZHN0eWxlOiBbJ1NldEZvbnQnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk9MRFNUWUxFXSxcbiAgICBjYWw6IFsnU2V0Rm9udCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQ0FMTElHUkFQSElDXSxcbiAgICBpdDogWydTZXRGb250JywgJy10ZXgtbWF0aGl0J10sXG4gICAgYmY6IFsnU2V0Rm9udCcsIFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuQk9MRF0sXG4gICAgYmJGb250OiBbJ1NldEZvbnQnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LkRPVUJMRVNUUlVDS10sXG4gICAgc2NyOiBbJ1NldEZvbnQnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50LlNDUklQVF0sXG4gICAgZnJhazogWydTZXRGb250JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5GUkFLVFVSXSxcbiAgICBzZjogWydTZXRGb250JywgVGV4Q29uc3RhbnRzX2pzXzEuVGV4Q29uc3RhbnQuVmFyaWFudC5TQU5TU0VSSUZdLFxuICAgIHR0OiBbJ1NldEZvbnQnLCBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk1PTk9TUEFDRV0sXG4gICAgdGlueTogWydTZXRTaXplJywgMC41XSxcbiAgICBUaW55OiBbJ1NldFNpemUnLCAwLjZdLFxuICAgIHNjcmlwdHNpemU6IFsnU2V0U2l6ZScsIDAuN10sXG4gICAgc21hbGw6IFsnU2V0U2l6ZScsIDAuODVdLFxuICAgIG5vcm1hbHNpemU6IFsnU2V0U2l6ZScsIDEuMF0sXG4gICAgbGFyZ2U6IFsnU2V0U2l6ZScsIDEuMl0sXG4gICAgTGFyZ2U6IFsnU2V0U2l6ZScsIDEuNDRdLFxuICAgIExBUkdFOiBbJ1NldFNpemUnLCAxLjczXSxcbiAgICBodWdlOiBbJ1NldFNpemUnLCAyLjA3XSxcbiAgICBIdWdlOiBbJ1NldFNpemUnLCAyLjQ5XSxcbiAgICBCYmI6IFsnTWFjcm8nLCAne1xcXFxiYkZvbnQgIzF9JywgMV0sXG4gICAgdGV4dG5vcm1hbDogWydNYWNybycsICd7XFxcXHJtICMxfScsIDFdLFxuICAgIHRleHR1cDogWydNYWNybycsICd7XFxcXHJtICMxfScsIDFdLFxuICAgIHRleHRybTogWydNYWNybycsICd7XFxcXHJtICMxfScsIDFdLFxuICAgIHRleHRpdDogWydNYWNybycsICd7XFxcXGl0ICMxfScsIDFdLFxuICAgIHRleHRiZjogWydNYWNybycsICd7XFxcXGJmICMxfScsIDFdLFxuICAgIHRleHRzZjogWydNYWNybycsICd7XFxcXHNmICMxfScsIDFdLFxuICAgIHRleHR0dDogWydNYWNybycsICd7XFxcXHR0ICMxfScsIDFdLFxuICAgIGRhZ2dlcjogWydJbnNlcnQnLCAnXFx1MjAyMCddLFxuICAgIGRkYWdnZXI6IFsnSW5zZXJ0JywgJ1xcdTIwMjEnXSxcbiAgICBTOiBbJ0luc2VydCcsICdcXHUwMEE3J10sXG4gICAgJywnOiBbJ1NwYWNlcicsIGxlbmd0aHNfanNfMS5NQVRIU1BBQ0UudGhpbm1hdGhzcGFjZV0sXG4gICAgJzonOiBbJ1NwYWNlcicsIGxlbmd0aHNfanNfMS5NQVRIU1BBQ0UubWVkaXVtbWF0aHNwYWNlXSxcbiAgICAnPic6IFsnU3BhY2VyJywgbGVuZ3Roc19qc18xLk1BVEhTUEFDRS5tZWRpdW1tYXRoc3BhY2VdLFxuICAgICc7JzogWydTcGFjZXInLCBsZW5ndGhzX2pzXzEuTUFUSFNQQUNFLnRoaWNrbWF0aHNwYWNlXSxcbiAgICAnISc6IFsnU3BhY2VyJywgbGVuZ3Roc19qc18xLk1BVEhTUEFDRS5uZWdhdGl2ZXRoaW5tYXRoc3BhY2VdLFxuICAgIGVuc3BhY2U6IFsnU3BhY2VyJywgLjVdLFxuICAgIHF1YWQ6IFsnU3BhY2VyJywgMV0sXG4gICAgcXF1YWQ6IFsnU3BhY2VyJywgMl0sXG4gICAgdGhpbnNwYWNlOiBbJ1NwYWNlcicsIGxlbmd0aHNfanNfMS5NQVRIU1BBQ0UudGhpbm1hdGhzcGFjZV0sXG4gICAgbmVndGhpbnNwYWNlOiBbJ1NwYWNlcicsIGxlbmd0aHNfanNfMS5NQVRIU1BBQ0UubmVnYXRpdmV0aGlubWF0aHNwYWNlXSxcbiAgICBoc2tpcDogJ0hza2lwJyxcbiAgICBoc3BhY2U6ICdIc2tpcCcsXG4gICAga2VybjogJ0hza2lwJyxcbiAgICBtc2tpcDogJ0hza2lwJyxcbiAgICBtc3BhY2U6ICdIc2tpcCcsXG4gICAgbWtlcm46ICdIc2tpcCcsXG4gICAgcnVsZTogJ3J1bGUnLFxuICAgIFJ1bGU6IFsnUnVsZSddLFxuICAgIFNwYWNlOiBbJ1J1bGUnLCAnYmxhbmsnXSxcbiAgICBjb2xvcjogJ0NoZWNrQXV0b2xvYWQnLFxuICAgIHRleHRjb2xvcjogJ0NoZWNrQXV0b2xvYWQnLFxuICAgIGNvbG9yYm94OiAnQ2hlY2tBdXRvbG9hZCcsXG4gICAgZmNvbG9yYm94OiAnQ2hlY2tBdXRvbG9hZCcsXG4gICAgaHJlZjogJ0NoZWNrQXV0b2xvYWQnLFxuICAgIHN0eWxlOiAnQ2hlY2tBdXRvbG9hZCcsXG4gICAgY2xhc3M6ICdDaGVja0F1dG9sb2FkJyxcbiAgICBjc3NJZDogJ0NoZWNrQXV0b2xvYWQnLFxuICAgIHVuaWNvZGU6ICdDaGVja0F1dG9sb2FkJyxcbiAgICByZWY6IFsnSGFuZGxlUmVmJywgZmFsc2VdLFxuICAgIGVxcmVmOiBbJ0hhbmRsZVJlZicsIHRydWVdLFxufSwgVGV4dE1hY3Jvc01ldGhvZHNfanNfMS5UZXh0TWFjcm9zTWV0aG9kcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0TWFjcm9zTWFwcGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHRNYWNyb3NNZXRob2RzID0gdm9pZCAwO1xudmFyIFRleFBhcnNlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9UZXhQYXJzZXIuanNcIikpO1xudmFyIFJldHJpZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL1JldHJpZXMuanNcIik7XG52YXIgQmFzZU1ldGhvZHNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYmFzZS9CYXNlTWV0aG9kcy5qc1wiKSk7XG5leHBvcnRzLlRleHRNYWNyb3NNZXRob2RzID0ge1xuICAgIENvbW1lbnQ6IGZ1bmN0aW9uIChwYXJzZXIsIF9jKSB7XG4gICAgICAgIHdoaWxlIChwYXJzZXIuaSA8IHBhcnNlci5zdHJpbmcubGVuZ3RoICYmIHBhcnNlci5zdHJpbmcuY2hhckF0KHBhcnNlci5pKSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHBhcnNlci5pKys7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmkrKztcbiAgICB9LFxuICAgIE1hdGg6IGZ1bmN0aW9uIChwYXJzZXIsIG9wZW4pIHtcbiAgICAgICAgcGFyc2VyLnNhdmVUZXh0KCk7XG4gICAgICAgIHZhciBpID0gcGFyc2VyLmk7XG4gICAgICAgIHZhciBqLCBjO1xuICAgICAgICB2YXIgYnJhY2VzID0gMDtcbiAgICAgICAgd2hpbGUgKChjID0gcGFyc2VyLkdldE5leHQoKSkpIHtcbiAgICAgICAgICAgIGogPSBwYXJzZXIuaSsrO1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcyA9IHBhcnNlci5HZXRDUygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3MgPT09ICcpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnXFxcXCgnO1xuICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VzID09PSAwICYmIG9wZW4gPT09IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBwYXJzZXIudGV4UGFyc2VyLmNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW1sID0gKG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KHBhcnNlci5zdHJpbmcuc3Vic3RyKGksIGogLSBpKSwgcGFyc2VyLnN0YWNrLmVudiwgY29uZmlnKSkubW1sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuUHVzaE1hdGgobW1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VzKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuRXJyb3IoJ0V4dHJhQ2xvc2VNaXNzaW5nT3BlbicsICdFeHRyYSBjbG9zZSBicmFjZSBvciBtaXNzaW5nIG9wZW4gYnJhY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmFjZXMtLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLkVycm9yKCdNYXRoTm90VGVybWluYXRlZCcsICdNYXRoLW1vZGUgaXMgbm90IHByb3Blcmx5IHRlcm1pbmF0ZWQnKTtcbiAgICB9LFxuICAgIE1hdGhNb2RlT25seTogZnVuY3Rpb24gKHBhcnNlciwgYykge1xuICAgICAgICBwYXJzZXIuRXJyb3IoJ01hdGhNb2RlT25seScsICdcXCclMVxcJyBhbGxvd2VkIG9ubHkgaW4gbWF0aCBtb2RlJywgYyk7XG4gICAgfSxcbiAgICBNaXNwbGFjZWQ6IGZ1bmN0aW9uIChwYXJzZXIsIGMpIHtcbiAgICAgICAgcGFyc2VyLkVycm9yKCdNaXNwbGFjZWQnLCAnXFwnJTFcXCcgY2FuIG5vdCBiZSB1c2VkIGhlcmUnLCBjKTtcbiAgICB9LFxuICAgIE9wZW5CcmFjZTogZnVuY3Rpb24gKHBhcnNlciwgX2MpIHtcbiAgICAgICAgdmFyIGVudiA9IHBhcnNlci5zdGFjay5lbnY7XG4gICAgICAgIHBhcnNlci5lbnZTdGFjay5wdXNoKGVudik7XG4gICAgICAgIHBhcnNlci5zdGFjay5lbnYgPSBPYmplY3QuYXNzaWduKHt9LCBlbnYpO1xuICAgIH0sXG4gICAgQ2xvc2VCcmFjZTogZnVuY3Rpb24gKHBhcnNlciwgX2MpIHtcbiAgICAgICAgaWYgKHBhcnNlci5lbnZTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnNlci5zYXZlVGV4dCgpO1xuICAgICAgICAgICAgcGFyc2VyLnN0YWNrLmVudiA9IHBhcnNlci5lbnZTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5FcnJvcignRXh0cmFDbG9zZU1pc3NpbmdPcGVuJywgJ0V4dHJhIGNsb3NlIGJyYWNlIG9yIG1pc3Npbmcgb3BlbiBicmFjZScpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBPcGVuUXVvdGU6IGZ1bmN0aW9uIChwYXJzZXIsIGMpIHtcbiAgICAgICAgaWYgKHBhcnNlci5zdHJpbmcuY2hhckF0KHBhcnNlci5pKSA9PT0gYykge1xuICAgICAgICAgICAgcGFyc2VyLnRleHQgKz0gJ1xcdTIwMUMnO1xuICAgICAgICAgICAgcGFyc2VyLmkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci50ZXh0ICs9ICdcXHUyMDE4JztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQ2xvc2VRdW90ZTogZnVuY3Rpb24gKHBhcnNlciwgYykge1xuICAgICAgICBpZiAocGFyc2VyLnN0cmluZy5jaGFyQXQocGFyc2VyLmkpID09PSBjKSB7XG4gICAgICAgICAgICBwYXJzZXIudGV4dCArPSAnXFx1MjAxRCc7XG4gICAgICAgICAgICBwYXJzZXIuaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnRleHQgKz0gJ1xcdTIwMTknO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBUaWxkZTogZnVuY3Rpb24gKHBhcnNlciwgX2MpIHtcbiAgICAgICAgcGFyc2VyLnRleHQgKz0gJ1xcdTAwQTAnO1xuICAgIH0sXG4gICAgU3BhY2U6IGZ1bmN0aW9uIChwYXJzZXIsIF9jKSB7XG4gICAgICAgIHBhcnNlci50ZXh0ICs9ICcgJztcbiAgICAgICAgd2hpbGUgKHBhcnNlci5HZXROZXh0KCkubWF0Y2goL1xccy8pKVxuICAgICAgICAgICAgcGFyc2VyLmkrKztcbiAgICB9LFxuICAgIFNlbGZRdW90ZTogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgICAgICBwYXJzZXIudGV4dCArPSBuYW1lLnN1YnN0cigxKTtcbiAgICB9LFxuICAgIEluc2VydDogZnVuY3Rpb24gKHBhcnNlciwgX25hbWUsIGMpIHtcbiAgICAgICAgcGFyc2VyLnRleHQgKz0gYztcbiAgICB9LFxuICAgIEFjY2VudDogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSwgYykge1xuICAgICAgICB2YXIgYmFzZSA9IHBhcnNlci5QYXJzZUFyZyhuYW1lKTtcbiAgICAgICAgdmFyIGFjY2VudCA9IHBhcnNlci5jcmVhdGUoJ3Rva2VuJywgJ21vJywge30sIGMpO1xuICAgICAgICBwYXJzZXIuYWRkQXR0cmlidXRlcyhhY2NlbnQpO1xuICAgICAgICBwYXJzZXIuUHVzaChwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21vdmVyJywgW2Jhc2UsIGFjY2VudF0pKTtcbiAgICB9LFxuICAgIEVtcGg6IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhcmlhbnQgPSAocGFyc2VyLnN0YWNrLmVudi5tYXRodmFyaWFudCA9PT0gJy10ZXgtbWF0aGl0JyA/ICdub3JtYWwnIDogJy10ZXgtbWF0aGl0Jyk7XG4gICAgICAgIHBhcnNlci5QdXNoKHBhcnNlci5QYXJzZVRleHRBcmcobmFtZSwgeyBtYXRodmFyaWFudDogdmFyaWFudCB9KSk7XG4gICAgfSxcbiAgICBTZXRGb250OiBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSwgdmFyaWFudCkge1xuICAgICAgICBwYXJzZXIuc2F2ZVRleHQoKTtcbiAgICAgICAgcGFyc2VyLnN0YWNrLmVudi5tYXRodmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgfSxcbiAgICBTZXRTaXplOiBmdW5jdGlvbiAocGFyc2VyLCBfbmFtZSwgc2l6ZSkge1xuICAgICAgICBwYXJzZXIuc2F2ZVRleHQoKTtcbiAgICAgICAgcGFyc2VyLnN0YWNrLmVudi5tYXRoc2l6ZSA9IHNpemU7XG4gICAgfSxcbiAgICBDaGVja0F1dG9sb2FkOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciBhdXRvbG9hZCA9IHBhcnNlci5jb25maWd1cmF0aW9uLnBhY2thZ2VEYXRhLmdldCgnYXV0b2xvYWQnKTtcbiAgICAgICAgdmFyIHRleFBhcnNlciA9IHBhcnNlci50ZXhQYXJzZXI7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB2YXIgbWFjcm8gPSB0ZXhQYXJzZXIubG9va3VwKCdtYWNybycsIG5hbWUpO1xuICAgICAgICBpZiAoIW1hY3JvIHx8IChhdXRvbG9hZCAmJiBtYWNyby5fZnVuYyA9PT0gYXV0b2xvYWQuQXV0b2xvYWQpKSB7XG4gICAgICAgICAgICB0ZXhQYXJzZXIucGFyc2UoJ21hY3JvJywgW3RleFBhcnNlciwgbmFtZV0pO1xuICAgICAgICAgICAgaWYgKCFtYWNybylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAoMCwgUmV0cmllc19qc18xLnJldHJ5QWZ0ZXIpKFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXhQYXJzZXIucGFyc2UoJ21hY3JvJywgW3BhcnNlciwgbmFtZV0pO1xuICAgIH0sXG4gICAgTWFjcm86IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5NYWNybyxcbiAgICBTcGFjZXI6IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5TcGFjZXIsXG4gICAgSHNraXA6IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5Ic2tpcCxcbiAgICBydWxlOiBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQucnVsZSxcbiAgICBSdWxlOiBCYXNlTWV0aG9kc19qc18xLmRlZmF1bHQuUnVsZSxcbiAgICBIYW5kbGVSZWY6IEJhc2VNZXRob2RzX2pzXzEuZGVmYXVsdC5IYW5kbGVSZWZcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0TWFjcm9zTWV0aG9kcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHRQYXJzZXIgPSB2b2lkIDA7XG52YXIgVGV4UGFyc2VyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleFBhcnNlci5qc1wiKSk7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4RXJyb3IuanNcIikpO1xudmFyIFBhcnNlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9QYXJzZVV0aWwuanNcIikpO1xudmFyIE1tbE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZS5qc1wiKTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgQmFzZUl0ZW1zX2pzXzEgPSByZXF1aXJlKFwiLi4vYmFzZS9CYXNlSXRlbXMuanNcIik7XG52YXIgVGV4dFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dFBhcnNlcih0ZXh0LCBlbnYsIGNvbmZpZ3VyYXRpb24sIGxldmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRleHQsIGVudiwgY29uZmlndXJhdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dFBhcnNlci5wcm90b3R5cGUsIFwidGV4UGFyc2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBhY2thZ2VEYXRhLmdldCgndGV4dG1hY3JvcycpLnRleFBhcnNlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0UGFyc2VyLnByb3RvdHlwZSwgXCJ0YWdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXhQYXJzZXIudGFncztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRleHRQYXJzZXIucHJvdG90eXBlLm1tbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxldmVsICE9IG51bGwgP1xuICAgICAgICAgICAgdGhpcy5jcmVhdGUoJ25vZGUnLCAnbXN0eWxlJywgdGhpcy5ub2RlcywgeyBkaXNwbGF5c3R5bGU6IGZhbHNlLCBzY3JpcHRsZXZlbDogdGhpcy5sZXZlbCB9KSA6XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMSA/IHRoaXMubm9kZXNbMF0gOiB0aGlzLmNyZWF0ZSgnbm9kZScsICdtcm93JywgdGhpcy5ub2RlcykpO1xuICAgIH07XG4gICAgVGV4dFBhcnNlci5wcm90b3R5cGUuUGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuZW52U3RhY2sgPSBbXTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5QYXJzZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgVGV4dFBhcnNlci5wcm90b3R5cGUuc2F2ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIHZhciBtYXRodmFyaWFudCA9IHRoaXMuc3RhY2suZW52Lm1hdGh2YXJpYW50O1xuICAgICAgICAgICAgdmFyIHRleHQgPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LmludGVybmFsVGV4dCh0aGlzLCB0aGlzLnRleHQsIG1hdGh2YXJpYW50ID8geyBtYXRodmFyaWFudDogbWF0aHZhcmlhbnQgfSA6IHt9KTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5QdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0UGFyc2VyLnByb3RvdHlwZS5QdXNoID0gZnVuY3Rpb24gKG1tbCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnNhdmVUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1tbCBpbnN0YW5jZW9mIEJhc2VJdGVtc19qc18xLlN0b3BJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5QdXNoLmNhbGwodGhpcywgbW1sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW1sIGluc3RhbmNlb2YgQmFzZUl0ZW1zX2pzXzEuU3R5bGVJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLmVudi5tYXRoY29sb3IgPSB0aGlzLnN0YWNrLmVudi5jb2xvcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW1sIGluc3RhbmNlb2YgTW1sTm9kZV9qc18xLkFic3RyYWN0TW1sTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGVzKG1tbCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobW1sKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dFBhcnNlci5wcm90b3R5cGUuUHVzaE1hdGggPSBmdW5jdGlvbiAobW1sKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgZW52ID0gdGhpcy5zdGFjay5lbnY7XG4gICAgICAgIGlmICghbW1sLmlzS2luZCgnVGVYQXRvbScpKSB7XG4gICAgICAgICAgICBtbWwgPSB0aGlzLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgW21tbF0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFsnbWF0aHNpemUnLCAnbWF0aGNvbG9yJ10pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlbnZbbmFtZV8xXSAmJiAhbW1sLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQobmFtZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1tbC5pc1Rva2VuICYmICFtbWwuaXNLaW5kKCdtc3R5bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW1sID0gdGhpcy5jcmVhdGUoJ25vZGUnLCAnbXN0eWxlJywgW21tbF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobW1sLCBuYW1lXzEsIGVudltuYW1lXzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW1sLmlzSW5mZXJyZWQpIHtcbiAgICAgICAgICAgIG1tbCA9IHRoaXMuY3JlYXRlKCdub2RlJywgJ21yb3cnLCBtbWwuY2hpbGROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG1tbCk7XG4gICAgfTtcbiAgICBUZXh0UGFyc2VyLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG1tbCkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdmFyIGVudiA9IHRoaXMuc3RhY2suZW52O1xuICAgICAgICBpZiAoIW1tbC5pc1Rva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhbJ21hdGhzaXplJywgJ21hdGhjb2xvcicsICdtYXRodmFyaWFudCddKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW52W25hbWVfMl0gJiYgIW1tbC5hdHRyaWJ1dGVzLmdldEV4cGxpY2l0KG5hbWVfMikpIHtcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShtbWwsIG5hbWVfMiwgZW52W25hbWVfMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0UGFyc2VyLnByb3RvdHlwZS5QYXJzZVRleHRBcmcgPSBmdW5jdGlvbiAobmFtZSwgZW52KSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAgICAgZW52ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YWNrLmVudiksIGVudik7XG4gICAgICAgIHJldHVybiAobmV3IFRleHRQYXJzZXIodGV4dCwgZW52LCB0aGlzLmNvbmZpZ3VyYXRpb24pKS5tbWwoKTtcbiAgICB9O1xuICAgIFRleHRQYXJzZXIucHJvdG90eXBlLlBhcnNlQXJnID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgVGV4dFBhcnNlcih0aGlzLkdldEFyZ3VtZW50KG5hbWUpLCB0aGlzLnN0YWNrLmVudiwgdGhpcy5jb25maWd1cmF0aW9uKSkubW1sKCk7XG4gICAgfTtcbiAgICBUZXh0UGFyc2VyLnByb3RvdHlwZS5FcnJvciA9IGZ1bmN0aW9uIChpZCwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgKFRleEVycm9yX2pzXzEuZGVmYXVsdC5iaW5kLmFwcGx5KFRleEVycm9yX2pzXzEuZGVmYXVsdCwgX19zcHJlYWRBcnJheShbdm9pZCAwLCBpZCwgbWVzc2FnZV0sIF9fcmVhZChhcmdzKSwgZmFsc2UpKSkoKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0UGFyc2VyO1xufShUZXhQYXJzZXJfanNfMS5kZWZhdWx0KSk7XG5leHBvcnRzLlRleHRQYXJzZXIgPSBUZXh0UGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pY29kZUNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLlVuaWNvZGVNZXRob2RzID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1BhcnNlVXRpbC5qc1wiKSk7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vTm9kZVV0aWwuanNcIikpO1xudmFyIEVudGl0aWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9FbnRpdGllcy5qc1wiKTtcbmV4cG9ydHMuVW5pY29kZU1ldGhvZHMgPSB7fTtcbnZhciBVbmljb2RlQ2FjaGUgPSB7fTtcbmV4cG9ydHMuVW5pY29kZU1ldGhvZHMuVW5pY29kZSA9IGZ1bmN0aW9uIChwYXJzZXIsIG5hbWUpIHtcbiAgICB2YXIgSEQgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSk7XG4gICAgdmFyIEhEc3BsaXQgPSBudWxsO1xuICAgIHZhciBmb250ID0gbnVsbDtcbiAgICBpZiAoSEQpIHtcbiAgICAgICAgaWYgKEhELnJlcGxhY2UoLyAvZywgJycpLlxuICAgICAgICAgICAgbWF0Y2goL14oXFxkKyhcXC5cXGQqKT98XFwuXFxkKyksKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspJC8pKSB7XG4gICAgICAgICAgICBIRHNwbGl0ID0gSEQucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoLywvKTtcbiAgICAgICAgICAgIGZvbnQgPSBwYXJzZXIuR2V0QnJhY2tldHMobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb250ID0gSEQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG4gPSBQYXJzZVV0aWxfanNfMS5kZWZhdWx0LnRyaW1TcGFjZXMocGFyc2VyLkdldEFyZ3VtZW50KG5hbWUpKS5yZXBsYWNlKC9eMHgvLCAneCcpO1xuICAgIGlmICghbi5tYXRjaCgvXih4WzAtOUEtRmEtZl0rfFswLTldKykkLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnQmFkVW5pY29kZScsICdBcmd1bWVudCB0byBcXFxcdW5pY29kZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIHZhciBOID0gcGFyc2VJbnQobi5tYXRjaCgvXngvKSA/ICcwJyArIG4gOiBuKTtcbiAgICBpZiAoIVVuaWNvZGVDYWNoZVtOXSkge1xuICAgICAgICBVbmljb2RlQ2FjaGVbTl0gPSBbODAwLCAyMDAsIGZvbnQsIE5dO1xuICAgIH1cbiAgICBlbHNlIGlmICghZm9udCkge1xuICAgICAgICBmb250ID0gVW5pY29kZUNhY2hlW05dWzJdO1xuICAgIH1cbiAgICBpZiAoSERzcGxpdCkge1xuICAgICAgICBVbmljb2RlQ2FjaGVbTl1bMF0gPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQoSERzcGxpdFswXSkgKiAxMDAwKTtcbiAgICAgICAgVW5pY29kZUNhY2hlW05dWzFdID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KEhEc3BsaXRbMV0pICogMTAwMCk7XG4gICAgfVxuICAgIHZhciB2YXJpYW50ID0gcGFyc2VyLnN0YWNrLmVudi5mb250O1xuICAgIHZhciBkZWYgPSB7fTtcbiAgICBpZiAoZm9udCkge1xuICAgICAgICBVbmljb2RlQ2FjaGVbTl1bMl0gPSBkZWYuZm9udGZhbWlseSA9IGZvbnQucmVwbGFjZSgvJy9nLCAnXFwnJyk7XG4gICAgICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgICAgICBpZiAodmFyaWFudC5tYXRjaCgvYm9sZC8pKSB7XG4gICAgICAgICAgICAgICAgZGVmLmZvbnR3ZWlnaHQgPSAnYm9sZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFyaWFudC5tYXRjaCgvaXRhbGljfC1tYXRoaXQvKSkge1xuICAgICAgICAgICAgICAgIGRlZi5mb250c3R5bGUgPSAnaXRhbGljJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2YXJpYW50KSB7XG4gICAgICAgIGRlZi5tYXRodmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgfVxuICAgIHZhciBub2RlID0gcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbXRleHQnLCBkZWYsICgwLCBFbnRpdGllc19qc18xLm51bWVyaWMpKG4pKTtcbiAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0UHJvcGVydHkobm9kZSwgJ3VuaWNvZGUnLCB0cnVlKTtcbiAgICBwYXJzZXIuUHVzaChub2RlKTtcbn07XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgndW5pY29kZScsIHsgdW5pY29kZTogJ1VuaWNvZGUnIH0sIGV4cG9ydHMuVW5pY29kZU1ldGhvZHMpO1xuZXhwb3J0cy5Vbmljb2RlQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgndW5pY29kZScsIHsgaGFuZGxlcjogeyBtYWNybzogWyd1bmljb2RlJ10gfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuaWNvZGVDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcGdyZWVrQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgVGV4Q29uc3RhbnRzX2pzXzEgPSByZXF1aXJlKFwiLi4vVGV4Q29uc3RhbnRzLmpzXCIpO1xuZnVuY3Rpb24gbWF0aGNoYXIwbWlOb3JtYWwocGFyc2VyLCBtY2hhcikge1xuICAgIHZhciBkZWYgPSBtY2hhci5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGRlZi5tYXRodmFyaWFudCA9IFRleENvbnN0YW50c19qc18xLlRleENvbnN0YW50LlZhcmlhbnQuTk9STUFMO1xuICAgIHZhciBub2RlID0gcGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbWknLCBkZWYsIG1jaGFyLmNoYXIpO1xuICAgIHBhcnNlci5QdXNoKG5vZGUpO1xufVxubmV3IFN5bWJvbE1hcF9qc18xLkNoYXJhY3Rlck1hcCgndXBncmVlaycsIG1hdGhjaGFyMG1pTm9ybWFsLCB7XG4gICAgdXBhbHBoYTogJ1xcdTAzQjEnLFxuICAgIHVwYmV0YTogJ1xcdTAzQjInLFxuICAgIHVwZ2FtbWE6ICdcXHUwM0IzJyxcbiAgICB1cGRlbHRhOiAnXFx1MDNCNCcsXG4gICAgdXBlcHNpbG9uOiAnXFx1MDNGNScsXG4gICAgdXB6ZXRhOiAnXFx1MDNCNicsXG4gICAgdXBldGE6ICdcXHUwM0I3JyxcbiAgICB1cHRoZXRhOiAnXFx1MDNCOCcsXG4gICAgdXBpb3RhOiAnXFx1MDNCOScsXG4gICAgdXBrYXBwYTogJ1xcdTAzQkEnLFxuICAgIHVwbGFtYmRhOiAnXFx1MDNCQicsXG4gICAgdXBtdTogJ1xcdTAzQkMnLFxuICAgIHVwbnU6ICdcXHUwM0JEJyxcbiAgICB1cHhpOiAnXFx1MDNCRScsXG4gICAgdXBvbWljcm9uOiAnXFx1MDNCRicsXG4gICAgdXBwaTogJ1xcdTAzQzAnLFxuICAgIHVwcmhvOiAnXFx1MDNDMScsXG4gICAgdXBzaWdtYTogJ1xcdTAzQzMnLFxuICAgIHVwdGF1OiAnXFx1MDNDNCcsXG4gICAgdXB1cHNpbG9uOiAnXFx1MDNDNScsXG4gICAgdXBwaGk6ICdcXHUwM0Q1JyxcbiAgICB1cGNoaTogJ1xcdTAzQzcnLFxuICAgIHVwcHNpOiAnXFx1MDNDOCcsXG4gICAgdXBvbWVnYTogJ1xcdTAzQzknLFxuICAgIHVwdmFyZXBzaWxvbjogJ1xcdTAzQjUnLFxuICAgIHVwdmFydGhldGE6ICdcXHUwM0QxJyxcbiAgICB1cHZhcnBpOiAnXFx1MDNENicsXG4gICAgdXB2YXJyaG86ICdcXHUwM0YxJyxcbiAgICB1cHZhcnNpZ21hOiAnXFx1MDNDMicsXG4gICAgdXB2YXJwaGk6ICdcXHUwM0M2JyxcbiAgICBVcGdhbW1hOiAnXFx1MDM5MycsXG4gICAgVXBkZWx0YTogJ1xcdTAzOTQnLFxuICAgIFVwdGhldGE6ICdcXHUwMzk4JyxcbiAgICBVcGxhbWJkYTogJ1xcdTAzOUInLFxuICAgIFVweGk6ICdcXHUwMzlFJyxcbiAgICBVcHBpOiAnXFx1MDNBMCcsXG4gICAgVXBzaWdtYTogJ1xcdTAzQTMnLFxuICAgIFVwdXBzaWxvbjogJ1xcdTAzQTUnLFxuICAgIFVwcGhpOiAnXFx1MDNBNicsXG4gICAgVXBwc2k6ICdcXHUwM0E4JyxcbiAgICBVcG9tZWdhOiAnXFx1MDNBOSdcbn0pO1xuZXhwb3J0cy5VcGdyZWVrQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgndXBncmVlaycsIHtcbiAgICBoYW5kbGVyOiB7IG1hY3JvOiBbJ3VwZ3JlZWsnXSB9LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VcGdyZWVrQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmVyYkNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLlZlcmJNZXRob2RzID0gdm9pZCAwO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9Db25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFRleENvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4uL1RleENvbnN0YW50cy5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4RXJyb3IuanNcIikpO1xuZXhwb3J0cy5WZXJiTWV0aG9kcyA9IHt9O1xuZXhwb3J0cy5WZXJiTWV0aG9kcy5WZXJiID0gZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBjID0gcGFyc2VyLkdldE5leHQoKTtcbiAgICB2YXIgc3RhcnQgPSArK3BhcnNlci5pO1xuICAgIGlmIChjID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNaXNzaW5nQXJnRm9yJywgJ01pc3NpbmcgYXJndW1lbnQgZm9yICUxJywgbmFtZSk7XG4gICAgfVxuICAgIHdoaWxlIChwYXJzZXIuaSA8IHBhcnNlci5zdHJpbmcubGVuZ3RoICYmXG4gICAgICAgIHBhcnNlci5zdHJpbmcuY2hhckF0KHBhcnNlci5pKSAhPT0gYykge1xuICAgICAgICBwYXJzZXIuaSsrO1xuICAgIH1cbiAgICBpZiAocGFyc2VyLmkgPT09IHBhcnNlci5zdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ05vQ2xvc2luZ0RlbGltJywgJ0NhblxcJ3QgZmluZCBjbG9zaW5nIGRlbGltaXRlciBmb3IgJTEnLCBwYXJzZXIuY3VycmVudENTKTtcbiAgICB9XG4gICAgdmFyIHRleHQgPSBwYXJzZXIuc3RyaW5nLnNsaWNlKHN0YXJ0LCBwYXJzZXIuaSkucmVwbGFjZSgvIC9nLCAnXFx1MDBBMCcpO1xuICAgIHBhcnNlci5pKys7XG4gICAgcGFyc2VyLlB1c2gocGFyc2VyLmNyZWF0ZSgndG9rZW4nLCAnbXRleHQnLCB7IG1hdGh2YXJpYW50OiBUZXhDb25zdGFudHNfanNfMS5UZXhDb25zdGFudC5WYXJpYW50Lk1PTk9TUEFDRSB9LCB0ZXh0KSk7XG59O1xubmV3IFN5bWJvbE1hcF9qc18xLkNvbW1hbmRNYXAoJ3ZlcmInLCB7IHZlcmI6ICdWZXJiJyB9LCBleHBvcnRzLlZlcmJNZXRob2RzKTtcbmV4cG9ydHMuVmVyYkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uX2pzXzEuQ29uZmlndXJhdGlvbi5jcmVhdGUoJ3ZlcmInLCB7IGhhbmRsZXI6IHsgbWFjcm86IFsndmVyYiddIH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZXJiQ29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiAgbWhjaGVtUGFyc2VyLnRzXG4gKiAgNC4xLjFcbiAqXG4gKiAgUGFyc2VyIGZvciB0aGUgXFxjZSBjb21tYW5kIGFuZCBcXHB1IGNvbW1hbmQgZm9yIE1hdGhKYXggYW5kIENvLlxuICpcbiAqICBtaGNoZW0ncyBcXGNlIGlzIGEgdG9vbCBmb3Igd3JpdGluZyBiZWF1dGlmdWwgY2hlbWljYWwgZXF1YXRpb25zIGVhc2lseS5cbiAqICBtaGNoZW0ncyBcXHB1IGlzIGEgdG9vbCBmb3Igd3JpdGluZyBwaHlzaWNhbCB1bml0cyBlYXNpbHkuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE1LTIwMjEgTWFydGluIEhlbnNlbFxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBodHRwczovL2dpdGh1Yi5jb20vbWhjaGVtL21oY2hlbVBhcnNlclxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taGNoZW1QYXJzZXIgPSB2b2lkIDA7XG52YXIgbWhjaGVtUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBtaGNoZW1QYXJzZXIoKSB7XG4gICAgfVxuICAgIG1oY2hlbVBhcnNlci50b1RleCA9IGZ1bmN0aW9uIChpbnB1dCwgdHlwZSkge1xuICAgICAgICByZXR1cm4gX21oY2hlbVRleGlmeS5nbyhfbWhjaGVtUGFyc2VyLmdvKGlucHV0LCB0eXBlKSwgdHlwZSAhPT0gXCJ0ZXhcIik7XG4gICAgfTtcbiAgICByZXR1cm4gbWhjaGVtUGFyc2VyO1xufSgpKTtcbmV4cG9ydHMubWhjaGVtUGFyc2VyID0gbWhjaGVtUGFyc2VyO1xuZnVuY3Rpb24gX21oY2hlbUNyZWF0ZVRyYW5zaXRpb25zKG8pIHtcbiAgICB2YXIgcGF0dGVybiwgc3RhdGU7XG4gICAgdmFyIHRyYW5zaXRpb25zID0ge307XG4gICAgZm9yIChwYXR0ZXJuIGluIG8pIHtcbiAgICAgICAgZm9yIChzdGF0ZSBpbiBvW3BhdHRlcm5dKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVBcnJheSA9IHN0YXRlLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICAgIG9bcGF0dGVybl1bc3RhdGVdLnN0YXRlQXJyYXkgPSBzdGF0ZUFycmF5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnNbc3RhdGVBcnJheVtpXV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHBhdHRlcm4gaW4gbykge1xuICAgICAgICBmb3IgKHN0YXRlIGluIG9bcGF0dGVybl0pIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZUFycmF5ID0gb1twYXR0ZXJuXVtzdGF0ZV0uc3RhdGVBcnJheSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gb1twYXR0ZXJuXVtzdGF0ZV07XG4gICAgICAgICAgICAgICAgcC5hY3Rpb25fID0gW10uY29uY2F0KHAuYWN0aW9uXyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwLmFjdGlvbl8ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwLmFjdGlvbl9ba10gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuYWN0aW9uX1trXSA9IHsgdHlwZV86IHAuYWN0aW9uX1trXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuQXJyYXkgPSBwYXR0ZXJuLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVBcnJheVtpXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodCBpbiB0cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zW3RdLnB1c2goeyBwYXR0ZXJuOiBwYXR0ZXJuQXJyYXlbal0sIHRhc2s6IHAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1tzdGF0ZUFycmF5W2ldXS5wdXNoKHsgcGF0dGVybjogcGF0dGVybkFycmF5W2pdLCB0YXNrOiBwIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9ucztcbn1cbjtcbnZhciBfbWhjaGVtUGFyc2VyID0ge1xuICAgIGdvOiBmdW5jdGlvbiAoaW5wdXQsIHN0YXRlTWFjaGluZSkge1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlTWFjaGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGF0ZU1hY2hpbmUgPSAnY2UnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9ICcwJztcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHt9O1xuICAgICAgICBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXSA9IDA7XG4gICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxuL2csIFwiIFwiKTtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXFx1MjIxMlxcdTIwMTNcXHUyMDE0XFx1MjAxMF0vZywgXCItXCIpO1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1tcXHUyMDI2XS9nLCBcIi4uLlwiKTtcbiAgICAgICAgdmFyIGxhc3RJbnB1dDtcbiAgICAgICAgdmFyIHdhdGNoZG9nID0gMTA7XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0SW5wdXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hkb2cgPSAxMDtcbiAgICAgICAgICAgICAgICBsYXN0SW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhdGNoZG9nLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWFjaGluZSA9IF9taGNoZW1QYXJzZXIuc3RhdGVNYWNoaW5lc1tzdGF0ZU1hY2hpbmVdO1xuICAgICAgICAgICAgdmFyIHQgPSBtYWNoaW5lLnRyYW5zaXRpb25zW3N0YXRlXSB8fCBtYWNoaW5lLnRyYW5zaXRpb25zWycqJ107XG4gICAgICAgICAgICBpdGVyYXRlVHJhbnNpdGlvbnM6IGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8odFtpXS5wYXR0ZXJuLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0W2ldLnRhc2s7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlBID0gMDsgaUEgPCB0YXNrLmFjdGlvbl8ubGVuZ3RoOyBpQSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWNoaW5lLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gbWFjaGluZS5hY3Rpb25zW3Rhc2suYWN0aW9uX1tpQV0udHlwZV9dKGJ1ZmZlciwgbWF0Y2hlcy5tYXRjaF8sIHRhc2suYWN0aW9uX1tpQV0ub3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9taGNoZW1QYXJzZXIuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBfbWhjaGVtUGFyc2VyLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10oYnVmZmVyLCBtYXRjaGVzLm1hdGNoXywgdGFzay5hY3Rpb25fW2lBXS5vcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnQVwiLCBcIm1oY2hlbSBidWcgQS4gUGxlYXNlIHJlcG9ydC4gKFwiICsgdGFzay5hY3Rpb25fW2lBXS50eXBlXyArIFwiKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9taGNoZW1QYXJzZXIuY29uY2F0QXJyYXkob3V0cHV0LCBvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHRhc2submV4dFN0YXRlIHx8IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXNrLnJldmlzaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IG1hdGNoZXMucmVtYWluZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXNrLnRvQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpdGVyYXRlVHJhbnNpdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhdGNoZG9nIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdVXCIsIFwibWhjaGVtIGJ1ZyBVLiBQbGVhc2UgcmVwb3J0LlwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29uY2F0QXJyYXk6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlCID0gMDsgaUIgPCBiLmxlbmd0aDsgaUIrKykge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goYltpQl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEucHVzaChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGF0dGVybnM6IHtcbiAgICAgICAgcGF0dGVybnM6IHtcbiAgICAgICAgICAgICdlbXB0eSc6IC9eJC8sXG4gICAgICAgICAgICAnZWxzZSc6IC9eLi8sXG4gICAgICAgICAgICAnZWxzZTInOiAvXi4vLFxuICAgICAgICAgICAgJ3NwYWNlJzogL15cXHMvLFxuICAgICAgICAgICAgJ3NwYWNlIEEnOiAvXlxccyg/PVtBLVpcXFxcJF0pLyxcbiAgICAgICAgICAgICdzcGFjZSQnOiAvXlxccyQvLFxuICAgICAgICAgICAgJ2Eteic6IC9eW2Etel0vLFxuICAgICAgICAgICAgJ3gnOiAvXngvLFxuICAgICAgICAgICAgJ3gkJzogL154JC8sXG4gICAgICAgICAgICAnaSQnOiAvXmkkLyxcbiAgICAgICAgICAgICdsZXR0ZXJzJzogL14oPzpbYS16QS1aXFx1MDNCMS1cXHUwM0M5XFx1MDM5MS1cXHUwM0E5P0BdfCg/OlxcXFwoPzphbHBoYXxiZXRhfGdhbW1hfGRlbHRhfGVwc2lsb258emV0YXxldGF8dGhldGF8aW90YXxrYXBwYXxsYW1iZGF8bXV8bnV8eGl8b21pY3JvbnxwaXxyaG98c2lnbWF8dGF1fHVwc2lsb258cGhpfGNoaXxwc2l8b21lZ2F8R2FtbWF8RGVsdGF8VGhldGF8TGFtYmRhfFhpfFBpfFNpZ21hfFVwc2lsb258UGhpfFBzaXxPbWVnYSkoPzpcXHMrfFxce1xcfXwoPyFbYS16QS1aXSkpKSkrLyxcbiAgICAgICAgICAgICdcXFxcZ3JlZWsnOiAvXlxcXFwoPzphbHBoYXxiZXRhfGdhbW1hfGRlbHRhfGVwc2lsb258emV0YXxldGF8dGhldGF8aW90YXxrYXBwYXxsYW1iZGF8bXV8bnV8eGl8b21pY3JvbnxwaXxyaG98c2lnbWF8dGF1fHVwc2lsb258cGhpfGNoaXxwc2l8b21lZ2F8R2FtbWF8RGVsdGF8VGhldGF8TGFtYmRhfFhpfFBpfFNpZ21hfFVwc2lsb258UGhpfFBzaXxPbWVnYSkoPzpcXHMrfFxce1xcfXwoPyFbYS16QS1aXSkpLyxcbiAgICAgICAgICAgICdvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciAkJzogL14oPzooW2Etel0pKD86JHxbXmEtekEtWl0pKSQvLFxuICAgICAgICAgICAgJyRvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciQgJCc6IC9eXFwkKD86KFthLXpdKSg/OiR8W15hLXpBLVpdKSlcXCQkLyxcbiAgICAgICAgICAgICdvbmUgbG93ZXJjYXNlIGdyZWVrIGxldHRlciAkJzogL14oPzpcXCQ/W1xcdTAzQjEtXFx1MDNDOV1cXCQ/fFxcJD9cXFxcKD86YWxwaGF8YmV0YXxnYW1tYXxkZWx0YXxlcHNpbG9ufHpldGF8ZXRhfHRoZXRhfGlvdGF8a2FwcGF8bGFtYmRhfG11fG51fHhpfG9taWNyb258cGl8cmhvfHNpZ21hfHRhdXx1cHNpbG9ufHBoaXxjaGl8cHNpfG9tZWdhKVxccypcXCQ/KSg/Olxccyt8XFx7XFx9fCg/IVthLXpBLVpdKSkkLyxcbiAgICAgICAgICAgICdkaWdpdHMnOiAvXlswLTldKy8sXG4gICAgICAgICAgICAnLTkuLDknOiAvXlsrXFwtXT8oPzpbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKSkvLFxuICAgICAgICAgICAgJy05Liw5IG5vIG1pc3NpbmcgMCc6IC9eWytcXC1dP1swLTldKyg/OlsuLF1bMC05XSspPy8sXG4gICAgICAgICAgICAnKC0pKDkuLDkpKGUpKDk5KSc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKC9eKFxcK1xcLXxcXCtcXC9cXC18XFwrfFxcLXxcXFxccG1cXHM/KT8oWzAtOV0rKD86WywuXVswLTldKyk/fFswLTldKig/OlxcLlswLTldKykpPyhcXCgoPzpbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKSlcXCkpPyg/Oig/OihbZUVdKXxcXHMqKFxcKnx4fFxcXFx0aW1lc3xcXHUwMEQ3KVxccyoxMFxcXikoWytcXC1dP1swLTldK3xcXHtbK1xcLV0/WzAtOV0rXFx9KSk/Lyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2guc2xpY2UoMSksIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJygtKSg5KV4oLTkpJzogL14oXFwrXFwtfFxcK1xcL1xcLXxcXCt8XFwtfFxcXFxwbVxccz8pPyhbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKT8pXFxeKFsrXFwtXT9bMC05XSt8XFx7WytcXC1dP1swLTldK1xcfSkvLFxuICAgICAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uICQnOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIC9eXFwoW2Etel17MSwzfSg/PVtcXCksXSkvLCBcIilcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGEgJiYgYS5yZW1haW5kZXIubWF0Y2goL14oJHxbXFxzLDtcXClcXF1cXH1dKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvXig/OlxcKCg/OlxcXFxjYVxccz8pP1xcJFthbW90aGNdXFwkXFwpKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1hdGNoWzBdLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdfeyhzdGF0ZSBvZiBhZ2dyZWdhdGlvbil9JCc6IC9eX1xceyhcXChbYS16XXsxLDN9XFwpKVxcfS8sXG4gICAgICAgICAgICAne1soJzogL14oPzpcXFxcXFx7fFxcW3xcXCgpLyxcbiAgICAgICAgICAgICcpXX0nOiAvXig/OlxcKXxcXF18XFxcXFxcfSkvLFxuICAgICAgICAgICAgJywgJzogL15bLDtdXFxzKi8sXG4gICAgICAgICAgICAnLCc6IC9eWyw7XS8sXG4gICAgICAgICAgICAnLic6IC9eWy5dLyxcbiAgICAgICAgICAgICcuIF9fKiAnOiAvXihbLlxcdTIyQzVcXHUwMEI3XFx1MjAyMl18WypdKVxccyovLFxuICAgICAgICAgICAgJy4uLic6IC9eXFwuXFwuXFwuKD89JHxbXi5dKS8sXG4gICAgICAgICAgICAnXnsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAgICAgJ14oJC4uLiQpJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl5cIiwgXCIkXCIsIFwiJFwiLCBcIlwiKTsgfSxcbiAgICAgICAgICAgICdeYSc6IC9eXFxeKFswLTldK3xbXlxcXFxfXSkvLFxuICAgICAgICAgICAgJ15cXFxceHt9e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgICAgICdeXFxcXHh7fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJeXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgICAgICdeXFxcXHgnOiAvXlxcXihcXFxcW2EtekEtWl0rKVxccyovLFxuICAgICAgICAgICAgJ14oLTEpJzogL15cXF4oLT9cXGQrKS8sXG4gICAgICAgICAgICAnXFwnJzogL14nLyxcbiAgICAgICAgICAgICdfeyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJfe1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICAgICAnXygkLi4uJCknOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCBcIiRcIiwgXCIkXCIsIFwiXCIpOyB9LFxuICAgICAgICAgICAgJ185JzogL15fKFsrXFwtXT9bMC05XSt8W15cXFxcXSkvLFxuICAgICAgICAgICAgJ19cXFxceHt9e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgICAgICdfXFxcXHh7fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJfXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgICAgICdfXFxcXHgnOiAvXl8oXFxcXFthLXpBLVpdKylcXHMqLyxcbiAgICAgICAgICAgICdeXyc6IC9eKD86XFxeKD89Xyl8XFxfKD89XFxeKXxbXFxeX10kKS8sXG4gICAgICAgICAgICAne31eJzogL15cXHtcXH0oPz1cXF4pLyxcbiAgICAgICAgICAgICd7fSc6IC9eXFx7XFx9LyxcbiAgICAgICAgICAgICd7Li4ufSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgICAgICd7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAgICAgJyQuLi4kJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCBcIiRcIiwgXCIkXCIsIFwiXCIpOyB9LFxuICAgICAgICAgICAgJyR7KC4uLil9JF9fJCguLi4pJCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIiR7XCIsIFwiXCIsIFwiXCIsIFwifSRcIikgfHwgX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCIkXCIsIFwiXCIsIFwiXCIsIFwiJFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnPTw+JzogL15bPTw+XS8sXG4gICAgICAgICAgICAnIyc6IC9eWyNcXHUyMjYxXS8sXG4gICAgICAgICAgICAnKyc6IC9eXFwrLyxcbiAgICAgICAgICAgICctJCc6IC9eLSg/PVtcXHNffSw7XFxdL118JHxcXChbYS16XStcXCkpLyxcbiAgICAgICAgICAgICctOSc6IC9eLSg/PVswLTldKS8sXG4gICAgICAgICAgICAnLSBvcmJpdGFsIG92ZXJsYXAnOiAvXi0oPz0oPzpbc3BkXXxzcCkoPzokfFtcXHMsO1xcKVxcXVxcfV0pKS8sXG4gICAgICAgICAgICAnLSc6IC9eLS8sXG4gICAgICAgICAgICAncG0tb3BlcmF0b3InOiAvXig/OlxcXFxwbXxcXCRcXFxccG1cXCR8XFwrLXxcXCtcXC8tKS8sXG4gICAgICAgICAgICAnb3BlcmF0b3InOiAvXig/OlxcK3woPzpbXFwtPTw+XXw8PHw+PnxcXFxcYXBwcm94fFxcJFxcXFxhcHByb3hcXCQpKD89XFxzfCR8LT9bMC05XSkpLyxcbiAgICAgICAgICAgICdhcnJvd1VwRG93bic6IC9eKD86dnxcXCh2XFwpfFxcXnxcXChcXF5cXCkpKD89JHxbXFxzLDtcXClcXF1cXH1dKS8sXG4gICAgICAgICAgICAnXFxcXGJvbmR7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxib25ke1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICAgICAnLT4nOiAvXig/OjwtPnw8LS0+fC0+fDwtfDw9Pj58PDw9Pnw8PT58W1xcdTIxOTJcXHUyN0Y2XFx1MjFDQ10pLyxcbiAgICAgICAgICAgICdDTVQnOiAvXltDTVRdKD89XFxbKS8sXG4gICAgICAgICAgICAnWyguLi4pXSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJbXCIsIFwiXCIsIFwiXCIsIFwiXVwiKTsgfSxcbiAgICAgICAgICAgICcxc3QtbGV2ZWwgZXNjYXBlJzogL14oJnxcXFxcXFxcXHxcXFxcaGxpbmUpXFxzKi8sXG4gICAgICAgICAgICAnXFxcXCwnOiAvXig/OlxcXFxbLFxcIDs6XSkvLFxuICAgICAgICAgICAgJ1xcXFx4e317fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIsIFwiXCIsIFwie1wiLCBcIn1cIiwgXCJcIiwgdHJ1ZSk7IH0sXG4gICAgICAgICAgICAnXFxcXHh7fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIpOyB9LFxuICAgICAgICAgICAgJ1xcXFxjYSc6IC9eXFxcXGNhKD86XFxzK3woPyFbYS16QS1aXSkpLyxcbiAgICAgICAgICAgICdcXFxceCc6IC9eKD86XFxcXFthLXpBLVpdK1xccyp8XFxcXFtfJnt9JV0pLyxcbiAgICAgICAgICAgICdvcmJpdGFsJzogL14oPzpbMC05XXsxLDJ9W3NwZGZnaF18WzAtOV17MCwyfXNwKSg/PSR8W15hLXpBLVpdKS8sXG4gICAgICAgICAgICAnb3RoZXJzJzogL15bXFwvfnxdLyxcbiAgICAgICAgICAgICdcXFxcZnJhY3soLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGZyYWN7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAgICAgJ1xcXFxvdmVyc2V0eyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcb3ZlcnNldHtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICAgICAnXFxcXHVuZGVyc2V0eyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcdW5kZXJzZXR7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAgICAgJ1xcXFx1bmRlcmJyYWNleyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcdW5kZXJicmFjZXtcIiwgXCJcIiwgXCJcIiwgXCJ9X1wiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNvbG9ye1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcY29sb3J7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNvbG9yXCIsIFwiXFxcXFwiLCBcIlwiLCAvXig/PVxceykvLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdcXFxcY2V7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxjZXtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAgICAgJ1xcXFxwdXsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXHB1e1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICAgICAnb3hpZGF0aW9uJCc6IC9eKD86WystXVtJVlhdK3xcXFxccG1cXHMqMHxcXCRcXFxccG1cXCRcXHMqMCkkLyxcbiAgICAgICAgICAgICdkLW94aWRhdGlvbiQnOiAvXig/OlsrLV0/XFxzP1tJVlhdK3xcXFxccG1cXHMqMHxcXCRcXFxccG1cXCRcXHMqMCkkLyxcbiAgICAgICAgICAgICdyb21hbiBudW1lcmFsJzogL15bSVZYXSsvLFxuICAgICAgICAgICAgJzEvMiQnOiAvXlsrXFwtXT8oPzpbMC05XSt8XFwkW2Etel1cXCR8W2Etel0pXFwvWzAtOV0rKD86XFwkW2Etel1cXCR8W2Etel0pPyQvLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKC9eKD86KD86KD86XFwoWytcXC1dP1swLTldK1xcL1swLTldK1xcKXxbK1xcLV0/KD86WzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcL1swLTldK3xbK1xcLV0/WzAtOV0rWy4sXVswLTldK3xbK1xcLV0/XFwuWzAtOV0rfFsrXFwtXT9bMC05XSspKD86W2Etel0oPz1cXHMqW0EtWl0pKT8pfFsrXFwtXT9bYS16XSg/PVxccypbQS1aXSl8XFwrKD8hXFxzKSkvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtYXRjaFswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYSA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBhLm1hdGNoXy5tYXRjaCgvXlxcJCg/OlxcKD9bK1xcLV0/KD86WzAtOV0qW2Etel0/WytcXC1dKT9bMC05XSpbYS16XSg/OlsrXFwtXVswLTldKlthLXpdPyk/XFwpP3xcXCt8LSlcXCQkLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtYXRjaFswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhbW91bnQyJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiB0aGlzWydhbW91bnQnXShpbnB1dCk7IH0sXG4gICAgICAgICAgICAnKEtWIGxldHRlcnMpLCc6IC9eKD86W0EtWl1bYS16XXswLDJ9fGkpKD89LCkvLFxuICAgICAgICAgICAgJ2Zvcm11bGEkJzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9eXFwoW2Etel0rXFwpJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvXig/OlthLXpdfCg/OlswLTlcXCBcXCtcXC1cXCxcXC5cXChcXCldK1thLXpdKStbMC05XFwgXFwrXFwtXFwsXFwuXFwoXFwpXSp8KD86W2Etel1bMC05XFwgXFwrXFwtXFwsXFwuXFwoXFwpXSspK1thLXpdPykkLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2hbMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VwcmlnaHRFbnRpdGllcyc6IC9eKD86cEh8cE9IfHBDfHBLfGlQcnxpQnUpKD89JHxbXmEtekEtWl0pLyxcbiAgICAgICAgICAgICcvJzogL15cXHMqKFxcLylcXHMqLyxcbiAgICAgICAgICAgICcvLyc6IC9eXFxzKihcXC9cXC8pXFxzKi8sXG4gICAgICAgICAgICAnKic6IC9eXFxzKlsqLl1cXHMqL1xuICAgICAgICB9LFxuICAgICAgICBmaW5kT2JzZXJ2ZUdyb3VwczogZnVuY3Rpb24gKGlucHV0LCBiZWdFeGNsLCBiZWdJbmNsLCBlbmRJbmNsLCBlbmRFeGNsLCBiZWcyRXhjbCwgYmVnMkluY2wsIGVuZDJJbmNsLCBlbmQyRXhjbCwgY29tYmluZSkge1xuICAgICAgICAgICAgdmFyIF9tYXRjaCA9IGZ1bmN0aW9uIChpbnB1dCwgcGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hfMSA9IGlucHV0Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaF8xWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2ZpbmRPYnNlcnZlR3JvdXBzID0gZnVuY3Rpb24gKGlucHV0LCBpLCBlbmRDaGFycykge1xuICAgICAgICAgICAgICAgIHZhciBicmFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hfMiA9IF9tYXRjaChpbnB1dC5zdWJzdHIoaSksIGVuZENoYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoXzIgIT09IG51bGwgJiYgYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlbmRNYXRjaEJlZ2luOiBpLCBlbmRNYXRjaEVuZDogaSArIG1hdGNoXzIubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgW1wiRXh0cmFDbG9zZU1pc3NpbmdPcGVuXCIsIFwiRXh0cmEgY2xvc2UgYnJhY2Ugb3IgbWlzc2luZyBvcGVuIGJyYWNlXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnJhY2VzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gX21hdGNoKGlucHV0LCBiZWdFeGNsKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hdGNoID0gX21hdGNoKGlucHV0LCBiZWdJbmNsKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGUgPSBfZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIG1hdGNoLmxlbmd0aCwgZW5kSW5jbCB8fCBlbmRFeGNsKTtcbiAgICAgICAgICAgIGlmIChlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWF0Y2gxID0gaW5wdXQuc3Vic3RyaW5nKDAsIChlbmRJbmNsID8gZS5lbmRNYXRjaEVuZCA6IGUuZW5kTWF0Y2hCZWdpbikpO1xuICAgICAgICAgICAgaWYgKCEoYmVnMkV4Y2wgfHwgYmVnMkluY2wpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfOiBtYXRjaDEsXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKGUuZW5kTWF0Y2hFbmQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBncm91cDIgPSB0aGlzLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LnN1YnN0cihlLmVuZE1hdGNoRW5kKSwgYmVnMkV4Y2wsIGJlZzJJbmNsLCBlbmQySW5jbCwgZW5kMkV4Y2wpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXRjaFJldCA9IFttYXRjaDEsIGdyb3VwMi5tYXRjaF9dO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoXzogKGNvbWJpbmUgPyBtYXRjaFJldC5qb2luKFwiXCIpIDogbWF0Y2hSZXQpLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXI6IGdyb3VwMi5yZW1haW5kZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXRjaF86IGZ1bmN0aW9uIChtLCBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLnBhdHRlcm5zW21dO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1BcIiwgXCJtaGNoZW0gYnVnIFAuIFBsZWFzZSByZXBvcnQuIChcIiArIG0gKyBcIilcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9taGNoZW1QYXJzZXIucGF0dGVybnMucGF0dGVybnNbbV0oaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1hdGNoLnNsaWNlKDEpLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1hdGNoWzFdIHx8IG1hdGNoWzBdLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2E9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuYSA9IChidWZmZXIuYSB8fCBcIlwiKSArIG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICdiPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLmIgPSAoYnVmZmVyLmIgfHwgXCJcIikgKyBtOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAncD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5wID0gKGJ1ZmZlci5wIHx8IFwiXCIpICsgbTsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgJ289JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIubyA9IChidWZmZXIubyB8fCBcIlwiKSArIG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICdxPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnEgPSAoYnVmZmVyLnEgfHwgXCJcIikgKyBtOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAnZD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5kID0gKGJ1ZmZlci5kIHx8IFwiXCIpICsgbTsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgJ3JtPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJtID0gKGJ1ZmZlci5ybSB8fCBcIlwiKSArIG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICd0ZXh0PSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnRleHRfID0gKGJ1ZmZlci50ZXh0XyB8fCBcIlwiKSArIG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICdpbnNlcnQnOiBmdW5jdGlvbiAoX2J1ZmZlciwgX20sIGEpIHsgcmV0dXJuIHsgdHlwZV86IGEgfTsgfSxcbiAgICAgICAgJ2luc2VydCtwMSc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtLCBhKSB7IHJldHVybiB7IHR5cGVfOiBhLCBwMTogbSB9OyB9LFxuICAgICAgICAnaW5zZXJ0K3AxK3AyJzogZnVuY3Rpb24gKF9idWZmZXIsIG0sIGEpIHsgcmV0dXJuIHsgdHlwZV86IGEsIHAxOiBtWzBdLCBwMjogbVsxXSB9OyB9LFxuICAgICAgICAnY29weSc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7IHJldHVybiBtOyB9LFxuICAgICAgICAnd3JpdGUnOiBmdW5jdGlvbiAoX2J1ZmZlciwgX20sIGEpIHsgcmV0dXJuIGE7IH0sXG4gICAgICAgICdybSc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7IHJldHVybiB7IHR5cGVfOiAncm0nLCBwMTogbSB9OyB9LFxuICAgICAgICAndGV4dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLmdvKG0sICd0ZXh0Jyk7IH0sXG4gICAgICAgICd0ZXgtbWF0aCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLmdvKG0sICd0ZXgtbWF0aCcpOyB9LFxuICAgICAgICAndGV4LW1hdGggdGlnaHQnOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5nbyhtLCAndGV4LW1hdGggdGlnaHQnKTsgfSxcbiAgICAgICAgJ2JvbmQnOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSwgaykgeyByZXR1cm4geyB0eXBlXzogJ2JvbmQnLCBraW5kXzogayB8fCBtIH07IH0sXG4gICAgICAgICdjb2xvcjAtb3V0cHV0JzogZnVuY3Rpb24gKF9idWZmZXIsIG0pIHsgcmV0dXJuIHsgdHlwZV86ICdjb2xvcjAnLCBjb2xvcjogbSB9OyB9LFxuICAgICAgICAnY2UnOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkgeyByZXR1cm4gX21oY2hlbVBhcnNlci5nbyhtLCAnY2UnKTsgfSxcbiAgICAgICAgJ3B1JzogZnVuY3Rpb24gKF9idWZmZXIsIG0pIHsgcmV0dXJuIF9taGNoZW1QYXJzZXIuZ28obSwgJ3B1Jyk7IH0sXG4gICAgICAgICcxLzInOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2goL15bK1xcLV0vKSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKG0uc3Vic3RyKDAsIDEpKTtcbiAgICAgICAgICAgICAgICBtID0gbS5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbiA9IG0ubWF0Y2goL14oWzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcLyhbMC05XSspKFxcJFthLXpdXFwkfFthLXpdKT8kLyk7XG4gICAgICAgICAgICBuWzFdID0gblsxXS5yZXBsYWNlKC9cXCQvZywgXCJcIik7XG4gICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnZnJhYycsIHAxOiBuWzFdLCBwMjogblsyXSB9KTtcbiAgICAgICAgICAgIGlmIChuWzNdKSB7XG4gICAgICAgICAgICAgICAgblszXSA9IG5bM10ucmVwbGFjZSgvXFwkL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBuWzNdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJzksOSc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7IHJldHVybiBfbWhjaGVtUGFyc2VyLmdvKG0sICc5LDknKTsgfVxuICAgIH0sXG4gICAgc3RhdGVNYWNoaW5lczoge1xuICAgICAgICAndGV4Jzoge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnM6IF9taGNoZW1DcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ2NvcHknIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogW3sgdHlwZV86ICd3cml0ZScsIG9wdGlvbjogXCJ7XCIgfSwgJ2NlJywgeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIn1cIiB9XSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHB1eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwie1wiIH0sICdwdScsIHsgdHlwZV86ICd3cml0ZScsIG9wdGlvbjogXCJ9XCIgfV0gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnY29weScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgICdjZSc6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zOiBfbWhjaGVtQ3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAgICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86ICdiZWdpbnNXaXRoQm9uZD1mYWxzZScsIHJldmlzaXQ6IHRydWUsIHRvQ29udGludWU6IHRydWUgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ294aWRhdGlvbiQnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnb3hpZGF0aW9uLW91dHB1dCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ0NNVCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3InOiB7IGFjdGlvbl86ICdyZHQ9JywgbmV4dFN0YXRlOiAncnQnIH0sXG4gICAgICAgICAgICAgICAgICAgICdyZCc6IHsgYWN0aW9uXzogJ3JxdD0nLCBuZXh0U3RhdGU6ICdyZHQnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhcnJvd1VwRG93bic6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiBbJ3NiPWZhbHNlJywgJ291dHB1dCcsICdvcGVyYXRvciddLCBuZXh0U3RhdGU6ICcxJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndXByaWdodEVudGl0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86IFsnbz0nLCAnb3V0cHV0J10sIG5leHRTdGF0ZTogJzEnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdvcmJpdGFsJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDJ8Myc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJy0+Jzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDJ8Myc6IHsgYWN0aW9uXzogJ3I9JywgbmV4dFN0YXRlOiAncicgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2F8YXMnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ3I9J10sIG5leHRTdGF0ZTogJ3InIH0sXG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdyPSddLCBuZXh0U3RhdGU6ICdyJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnKyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ28nOiB7IGFjdGlvbl86ICdkPSBrdicsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3FkfHFEJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RxJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdkPSddLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICAgICAgICAgICAnMyc6IHsgYWN0aW9uXzogWydzYj1mYWxzZScsICdvdXRwdXQnLCAnb3BlcmF0b3InXSwgbmV4dFN0YXRlOiAnMCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8Mic6IHsgYWN0aW9uXzogJ2E9JywgbmV4dFN0YXRlOiAnYScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BtLW9wZXJhdG9yJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDJ8YXxhcyc6IHsgYWN0aW9uXzogWydzYj1mYWxzZScsICdvdXRwdXQnLCB7IHR5cGVfOiAnb3BlcmF0b3InLCBvcHRpb246ICdcXFxccG0nIH1dLCBuZXh0U3RhdGU6ICcwJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnb3BlcmF0b3InOiB7XG4gICAgICAgICAgICAgICAgICAgICcwfDF8MnxhfGFzJzogeyBhY3Rpb25fOiBbJ3NiPWZhbHNlJywgJ291dHB1dCcsICdvcGVyYXRvciddLCBuZXh0U3RhdGU6ICcwJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnLSQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdvfHEnOiB7IGFjdGlvbl86IFsnY2hhcmdlIG9yIGJvbmQnLCAnb3V0cHV0J10sIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ0QnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH1dLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICAgICAgICAgICAncSc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICdxZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICdxRHxkcSc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfV0sIG5leHRTdGF0ZTogJzMnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICctOSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9XSwgbmV4dFN0YXRlOiAnMycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJy0gb3JiaXRhbCBvdmVybGFwJzoge1xuICAgICAgICAgICAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9XSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2QnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2h5cGhlbicgfV0sIG5leHRTdGF0ZTogJzInIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICctJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICdiZWdpbnNXaXRoQm9uZD10cnVlJywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH1dLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICAgICAgICAgICAnMyc6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgJ2EnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2h5cGhlbicgfV0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgICAgICAgICAgICdhcyc6IHsgYWN0aW9uXzogW3sgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH1dLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICAgICAgICAgICAnYic6IHsgYWN0aW9uXzogJ2I9JyB9LFxuICAgICAgICAgICAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiBmYWxzZSB9LCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICAgICAgICAgICAncSc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiBmYWxzZSB9LCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZHxxZHxkcSc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiB0cnVlIH0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgICAgICAgICAgICdEfHFEfHAnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH1dLCBuZXh0U3RhdGU6ICczJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYW1vdW50Mic6IHtcbiAgICAgICAgICAgICAgICAgICAgJzF8Myc6IHsgYWN0aW9uXzogJ2E9JywgbmV4dFN0YXRlOiAnYScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwfG8nOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgICAgICAgICAgICdxfGRxJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdvPSddLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZHxEfHFkfHFEJzogeyBhY3Rpb25fOiAnbyBhZnRlciBkJywgbmV4dFN0YXRlOiAnbycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RpZ2l0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ28nOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ3EnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ2RxJyB9LFxuICAgICAgICAgICAgICAgICAgICAncSc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnbz0nXSwgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzcGFjZSBBJzoge1xuICAgICAgICAgICAgICAgICAgICAnYnxwfGJwJzogeyBhY3Rpb25fOiBbXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc3BhY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhJzogeyBhY3Rpb25fOiBbXSwgbmV4dFN0YXRlOiAnYXMnIH0sXG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnc2I9ZmFsc2UnIH0sXG4gICAgICAgICAgICAgICAgICAgICcxfDInOiB7IGFjdGlvbl86ICdzYj10cnVlJyB9LFxuICAgICAgICAgICAgICAgICAgICAncnxydHxyZHxyZHR8cmRxJzogeyBhY3Rpb25fOiAnb3V0cHV0JywgbmV4dFN0YXRlOiAnMCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ3NiPXRydWUnXSwgbmV4dFN0YXRlOiAnMScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJzFzdC1sZXZlbCBlc2NhcGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICcxfDInOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCtwMScsIG9wdGlvbjogJzFzdC1sZXZlbCBlc2NhcGUnIH1dIH0sXG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQrcDEnLCBvcHRpb246ICcxc3QtbGV2ZWwgZXNjYXBlJyB9XSwgbmV4dFN0YXRlOiAnMCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1soLi4uKV0nOiB7XG4gICAgICAgICAgICAgICAgICAgICdyfHJ0JzogeyBhY3Rpb25fOiAncmQ9JywgbmV4dFN0YXRlOiAncmQnIH0sXG4gICAgICAgICAgICAgICAgICAgICdyZHxyZHQnOiB7IGFjdGlvbl86ICdycT0nLCBuZXh0U3RhdGU6ICdyZHEnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICcuLi4nOiB7XG4gICAgICAgICAgICAgICAgICAgICdvfGR8RHxkcXxxZHxxRCc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCIuLi5cIiB9XSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdlbGxpcHNpcycgfV0sIG5leHRTdGF0ZTogJzEnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICcuIF9fKiAnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdhZGRpdGlvbiBjb21wb3VuZCcgfV0sIG5leHRTdGF0ZTogJzEnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiAkJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnc3RhdGUgb2YgYWdncmVnYXRpb24nXSwgbmV4dFN0YXRlOiAnMScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3tbKCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2F8YXN8byc6IHsgYWN0aW9uXzogWydvPScsICdvdXRwdXQnLCAncGFyZW50aGVzaXNMZXZlbCsrJ10sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgICAgICAgICAgICcwfDF8MnwzJzogeyBhY3Rpb25fOiBbJ289JywgJ291dHB1dCcsICdwYXJlbnRoZXNpc0xldmVsKysnXSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ289JywgJ291dHB1dCcsICdwYXJlbnRoZXNpc0xldmVsKysnXSwgbmV4dFN0YXRlOiAnMicgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyldfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8MXwyfDN8YnxwfGJwfG8nOiB7IGFjdGlvbl86IFsnbz0nLCAncGFyZW50aGVzaXNMZXZlbC0tJ10sIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgICAgICAgICAgICdhfGFzfGR8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdvPScsICdwYXJlbnRoZXNpc0xldmVsLS0nXSwgbmV4dFN0YXRlOiAnbycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJywgJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnY29tbWEnXSwgbmV4dFN0YXRlOiAnMCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15fJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogW10gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ157KC4uLil9fF4oJC4uLiQpJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2InIH0sXG4gICAgICAgICAgICAgICAgICAgICdwJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdicCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogJ2Q9IGt2JywgbmV4dFN0YXRlOiAnRCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FEJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdkPSddLCBuZXh0U3RhdGU6ICdEJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXmF8XlxcXFx4e317fXxeXFxcXHh7fXxeXFxcXHh8XFwnJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2InIH0sXG4gICAgICAgICAgICAgICAgICAgICdwJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdicCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogJ2Q9IGt2JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZHxxZHxEfHFEJzogeyBhY3Rpb25fOiAnZD0nIH0sXG4gICAgICAgICAgICAgICAgICAgICdkcSc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnZD0nXSwgbmV4dFN0YXRlOiAnZCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ197KHN0YXRlIG9mIGFnZ3JlZ2F0aW9uKX0kJzoge1xuICAgICAgICAgICAgICAgICAgICAnZHxEfHF8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ3E9J10sIG5leHRTdGF0ZTogJ3EnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdfeyguLi4pfXxfKCQuLi4kKXxfOXxfXFxcXHh7fXt9fF9cXFxceHt9fF9cXFxceCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiAncD0nLCBuZXh0U3RhdGU6ICdwJyB9LFxuICAgICAgICAgICAgICAgICAgICAnYic6IHsgYWN0aW9uXzogJ3A9JywgbmV4dFN0YXRlOiAnYnAnIH0sXG4gICAgICAgICAgICAgICAgICAgICczfG8nOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ3EnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ2RxJyB9LFxuICAgICAgICAgICAgICAgICAgICAncXxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAncT0nXSwgbmV4dFN0YXRlOiAncScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJz08Pic6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8MXwyfDN8YXxhc3xvfHF8ZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnYm9uZCddLCBuZXh0U3RhdGU6ICczJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnIyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8MXwyfDN8YXxhc3xvJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCIjXCIgfV0sIG5leHRTdGF0ZTogJzMnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7fV4nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAndGlueVNraXAnIH1dLCBuZXh0U3RhdGU6ICcxJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAne30nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sIG5leHRTdGF0ZTogJzEnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7Li4ufSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzB8MXwyfDN8YXxhc3xifHB8YnAnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgICAgICAgICAgICdvfGR8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdvPSddLCBuZXh0U3RhdGU6ICdvJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJC4uLiQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhJzogeyBhY3Rpb25fOiAnYT0nIH0sXG4gICAgICAgICAgICAgICAgICAgICcwfDF8MnwzfGFzfGJ8cHxicHxvJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICAgICAgICAgICAnYXN8byc6IHsgYWN0aW9uXzogJ289JyB9LFxuICAgICAgICAgICAgICAgICAgICAncXxkfER8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ289J10sIG5leHRTdGF0ZTogJ28nIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcYm9uZHsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnYm9uZCddLCBuZXh0U3RhdGU6IFwiM1wiIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcZnJhY3soLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnZnJhYy1vdXRwdXQnXSwgbmV4dFN0YXRlOiAnMycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFxvdmVyc2V0eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdvdmVyc2V0LW91dHB1dCddLCBuZXh0U3RhdGU6ICczJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHVuZGVyc2V0eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICd1bmRlcnNldC1vdXRwdXQnXSwgbmV4dFN0YXRlOiAnMycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFx1bmRlcmJyYWNleyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICd1bmRlcmJyYWNlLW91dHB1dCddLCBuZXh0U3RhdGU6ICczJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnY29sb3Itb3V0cHV0J10sIG5leHRTdGF0ZTogJzMnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcY29sb3J7KC4uLil9Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogW3sgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2NvbG9yMC1vdXRwdXQnXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdjZSddLCBuZXh0U3RhdGU6ICczJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXCwnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnY29weSddLCBuZXh0U3RhdGU6ICcxJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHB1eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIntcIiB9LCAncHUnLCB7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwifVwiIH1dLCBuZXh0U3RhdGU6ICczJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwfG98YzAnOiB7IGFjdGlvbl86IFsnbz0nLCAnb3V0cHV0J10sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdvPScsICdvdXRwdXQnXSwgbmV4dFN0YXRlOiAnMycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ290aGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICdjb3B5J10sIG5leHRTdGF0ZTogJzMnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdhIHRvIG8nLCBuZXh0U3RhdGU6ICdvJywgcmV2aXNpdDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAnYXMnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ3NiPXRydWUnXSwgbmV4dFN0YXRlOiAnMScsIHJldmlzaXQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3J8cnR8cmR8cmR0fHJkcSc6IHsgYWN0aW9uXzogWydvdXRwdXQnXSwgbmV4dFN0YXRlOiAnMCcsIHJldmlzaXQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ2NvcHknXSwgbmV4dFN0YXRlOiAnMycgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICAgICdvIGFmdGVyIGQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYnVmZmVyLmQgfHwgXCJcIikubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IGJ1ZmZlci5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB0aGlzWydvdXRwdXQnXShidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ3RpbnlTa2lwJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5iID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gdGhpc1snb3V0cHV0J10oYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfbWhjaGVtUGFyc2VyLmFjdGlvbnNbJ289J10oYnVmZmVyLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkPSBrdic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmQgPSBtO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIuZFR5cGUgPSAna3YnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NoYXJnZSBvciBib25kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyWydiZWdpbnNXaXRoQm9uZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgX21oY2hlbVBhcnNlci5hY3Rpb25zWydib25kJ10oYnVmZmVyLCBtLCBcIi1cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kID0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICctIGFmdGVyIG8vZCc6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGlzQWZ0ZXJEKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMSA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvcmJpdGFsJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvbmUgbG93ZXJjYXNlIGdyZWVrIGxldHRlciAkJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMyA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciAkJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjNCA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCckb25lIGxvd2VyY2FzZSBsYXRpbiBsZXR0ZXIkICQnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh5cGhlbkZvbGxvd3MgPSBtID09PSBcIi1cIiAmJiAoYzEgJiYgYzEucmVtYWluZGVyID09PSBcIlwiIHx8IGMyIHx8IGMzIHx8IGM0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5cGhlbkZvbGxvd3MgJiYgIWJ1ZmZlci5hICYmICFidWZmZXIuYiAmJiAhYnVmZmVyLnAgJiYgIWJ1ZmZlci5kICYmICFidWZmZXIucSAmJiAhYzEgJiYgYzMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vID0gJyQnICsgYnVmZmVyLm8gKyAnJCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHlwaGVuRm9sbG93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX21oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIHRoaXNbJ291dHB1dCddKGJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2h5cGhlbicgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMSA9IF9taGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdkaWdpdHMnLCBidWZmZXIuZCB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FmdGVyRCAmJiBjMSAmJiBjMS5yZW1haW5kZXIgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIF9taGNoZW1QYXJzZXIuYWN0aW9uc1snZD0nXShidWZmZXIsIG0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIF9taGNoZW1QYXJzZXIuYWN0aW9uc1snYm9uZCddKGJ1ZmZlciwgbSwgXCItXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2EgdG8gbyc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm8gPSBidWZmZXIuYTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc2I9dHJ1ZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyLnNiID0gdHJ1ZTsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICAnc2I9ZmFsc2UnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlci5zYiA9IGZhbHNlOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICdiZWdpbnNXaXRoQm9uZD10cnVlJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXJbJ2JlZ2luc1dpdGhCb25kJ10gPSB0cnVlOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICdiZWdpbnNXaXRoQm9uZD1mYWxzZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydiZWdpbnNXaXRoQm9uZCddID0gZmFsc2U7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgJ3BhcmVudGhlc2lzTGV2ZWwrKyc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydwYXJlbnRoZXNpc0xldmVsJ10rKzsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICAncGFyZW50aGVzaXNMZXZlbC0tJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXS0tOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbic6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnc3RhdGUgb2YgYWdncmVnYXRpb24nLCBwMTogX21oY2hlbVBhcnNlci5nbyhtLCAnbycpIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpdGhTcGFjZSA9IChhICE9PSBtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpdGhTcGFjZSAmJiBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb21tYSBlbnVtZXJhdGlvbiBMJywgcDE6IGEgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29tbWEgZW51bWVyYXRpb24gTScsIHAxOiBhIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBfbSwgZW50aXR5Rm9sbG93cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlci5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyLmEgJiYgIWJ1ZmZlci5iICYmICFidWZmZXIucCAmJiAhYnVmZmVyLm8gJiYgIWJ1ZmZlci5xICYmICFidWZmZXIuZCAmJiAhZW50aXR5Rm9sbG93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5zYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnZW50aXR5U2tpcCcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyLm8gJiYgIWJ1ZmZlci5xICYmICFidWZmZXIuZCAmJiAhYnVmZmVyLmIgJiYgIWJ1ZmZlci5wICYmIGVudGl0eUZvbGxvd3MgIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm8gPSBidWZmZXIuYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFidWZmZXIubyAmJiAhYnVmZmVyLnEgJiYgIWJ1ZmZlci5kICYmIChidWZmZXIuYiB8fCBidWZmZXIucCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm8gPSBidWZmZXIuYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnEgPSBidWZmZXIucDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmEgPSBidWZmZXIuYiA9IGJ1ZmZlci5wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5vICYmIGJ1ZmZlci5kVHlwZSA9PT0gJ2t2JyAmJiBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnZC1veGlkYXRpb24kJywgYnVmZmVyLmQgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kVHlwZSA9ICdveGlkYXRpb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlci5vICYmIGJ1ZmZlci5kVHlwZSA9PT0gJ2t2JyAmJiAhYnVmZmVyLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVfOiAnY2hlbWZpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiBfbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5hLCAnYScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiOiBfbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5iLCAnYmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDogX21oY2hlbVBhcnNlci5nbyhidWZmZXIucCwgJ3BxJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG86IF9taGNoZW1QYXJzZXIuZ28oYnVmZmVyLm8sICdvJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHE6IF9taGNoZW1QYXJzZXIuZ28oYnVmZmVyLnEsICdwcScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBfbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5kLCAoYnVmZmVyLmRUeXBlID09PSAnb3hpZGF0aW9uJyA/ICdveGlkYXRpb24nIDogJ2JkJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkVHlwZTogYnVmZmVyLmRUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJkdCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmQgPSBfbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5yZCwgJ3RleC1tYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidWZmZXIucmR0ID09PSAnVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZCA9IFt7IHR5cGVfOiAndGV4dCcsIHAxOiBidWZmZXIucmQgfHwgXCJcIiB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkID0gX21oY2hlbVBhcnNlci5nbyhidWZmZXIucmQsICdjZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJxID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5ycXQgPT09ICdNJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJxID0gX21oY2hlbVBhcnNlci5nbyhidWZmZXIucnEsICd0ZXgtbWF0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyLnJxdCA9PT0gJ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnEgPSBbeyB0eXBlXzogJ3RleHQnLCBwMTogYnVmZmVyLnJxIHx8IFwiXCIgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBycSA9IF9taGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJxLCAnY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlXzogJ2Fycm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBidWZmZXIucixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZDogcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnE6IHJxXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gJ3BhcmVudGhlc2lzTGV2ZWwnICYmIHAgIT09ICdiZWdpbnNXaXRoQm9uZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYnVmZmVyW3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnb3hpZGF0aW9uLW91dHB1dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXCJ7XCJdO1xuICAgICAgICAgICAgICAgICAgICBfbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgX21oY2hlbVBhcnNlci5nbyhtLCAnb3hpZGF0aW9uJykpO1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnJhYy1vdXRwdXQnOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2ZyYWMtY2UnLCBwMTogX21oY2hlbVBhcnNlci5nbyhtWzBdLCAnY2UnKSwgcDI6IF9taGNoZW1QYXJzZXIuZ28obVsxXSwgJ2NlJykgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdvdmVyc2V0LW91dHB1dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnb3ZlcnNldCcsIHAxOiBfbWhjaGVtUGFyc2VyLmdvKG1bMF0sICdjZScpLCBwMjogX21oY2hlbVBhcnNlci5nbyhtWzFdLCAnY2UnKSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3VuZGVyc2V0LW91dHB1dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAndW5kZXJzZXQnLCBwMTogX21oY2hlbVBhcnNlci5nbyhtWzBdLCAnY2UnKSwgcDI6IF9taGNoZW1QYXJzZXIuZ28obVsxXSwgJ2NlJykgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd1bmRlcmJyYWNlLW91dHB1dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAndW5kZXJicmFjZScsIHAxOiBfbWhjaGVtUGFyc2VyLmdvKG1bMF0sICdjZScpLCBwMjogX21oY2hlbVBhcnNlci5nbyhtWzFdLCAnY2UnKSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NvbG9yLW91dHB1dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29sb3InLCBjb2xvcjE6IG1bMF0sIGNvbG9yMjogX21oY2hlbVBhcnNlci5nbyhtWzFdLCAnY2UnKSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3I9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuciA9IG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgJ3JkdD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5yZHQgPSBtOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICdyZD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5yZCA9IG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgJ3JxdD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ycXQgPSBtOyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgICdycT0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ycSA9IG07IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgJ29wZXJhdG9yJzogZnVuY3Rpb24gKF9idWZmZXIsIG0sIHAxKSB7IHJldHVybiB7IHR5cGVfOiAnb3BlcmF0b3InLCBraW5kXzogKHAxIHx8IG0pIH07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2EnOiB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uczogX21oY2hlbUNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnMS8yJCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICcxLzInIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogW10sIG5leHRTdGF0ZTogJzEnLCByZXZpc2l0OiB0cnVlIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckeyguLi4pfSRfXyQoLi4uKSQnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGggdGlnaHQnLCBuZXh0U3RhdGU6ICcxJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnLCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdjb21tYURlY2ltYWwnIH0gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgICdvJzoge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnM6IF9taGNoZW1DcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogW10gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJzEvMiQnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnMS8yJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86IFtdLCBuZXh0U3RhdGU6ICcxJywgcmV2aXNpdDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFxjYSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdjaXJjYScgfSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHB1eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFt7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwie1wiIH0sICdwdScsIHsgdHlwZV86ICd3cml0ZScsIG9wdGlvbjogXCJ9XCIgfV0gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckeyguLi4pfSRfXyQoLi4uKSQnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7KC4uLil9Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogW3sgdHlwZV86ICd3cml0ZScsIG9wdGlvbjogXCJ7XCIgfSwgJ3RleHQnLCB7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwifVwiIH1dIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhY3Rpb25zOiB7fVxuICAgICAgICB9LFxuICAgICAgICAndGV4dCc6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zOiBfbWhjaGVtQ3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAgICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7Li4ufSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0PScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyR7KC4uLil9JF9fJCguLi4pJCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFxncmVlayc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ3JtJ10gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFxwdXsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsIHsgdHlwZV86ICd3cml0ZScsIG9wdGlvbjogXCJ7XCIgfSwgJ3B1JywgeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIn1cIiB9XSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXCx8XFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdjb3B5J10gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dD0nIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRleHRfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0geyB0eXBlXzogJ3RleHQnLCBwMTogYnVmZmVyLnRleHRfIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAncHEnOiB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uczogX21oY2hlbUNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24gJCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbicgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2kkJzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogW10sIG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnKEtWIGxldHRlcnMpLCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdybScsIG5leHRTdGF0ZTogJzAnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtdWxhJCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86IFtdLCBuZXh0U3RhdGU6ICdmJywgcmV2aXNpdDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnMS8yJCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICcxLzInIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogW10sIG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHsoLi4uKX0kX18kKC4uLikkJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAneyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYS16Jzoge1xuICAgICAgICAgICAgICAgICAgICAnZic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJy05Liw5Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJzksOScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJywnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0K3AxJywgb3B0aW9uOiAnY29tbWEgZW51bWVyYXRpb24gUycgfSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3Itb3V0cHV0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNvbG9yeyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvcjAtb3V0cHV0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjZScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFxwdXsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIntcIiB9LCAncHUnLCB7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwifVwiIH1dIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbic6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnc3RhdGUgb2YgYWdncmVnYXRpb24gc3Vic2NyaXB0JywgcDE6IF9taGNoZW1QYXJzZXIuZ28obSwgJ28nKSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NvbG9yLW91dHB1dCc6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29sb3InLCBjb2xvcjE6IG1bMF0sIGNvbG9yMjogX21oY2hlbVBhcnNlci5nbyhtWzFdLCAncHEnKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2JkJzoge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnM6IF9taGNoZW1DcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogW10gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3gkJzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogW10sIG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZm9ybXVsYSQnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiBbXSwgbmV4dFN0YXRlOiAnZicsIHJldmlzaXQ6IHRydWUgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiBbXSwgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICctOS4sOSBubyBtaXNzaW5nIDAnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnOSw5JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnLic6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdlbGVjdHJvbiBkb3QnIH0gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Eteic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2YnOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3gnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnS1YgeCcgfSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcJyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdwcmltZScgfSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHsoLi4uKX0kX18kKC4uLikkJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAneyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3Itb3V0cHV0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNvbG9yeyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvcjAtb3V0cHV0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjZScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFxwdXsoLi4uKX0nOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIntcIiB9LCAncHUnLCB7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwifVwiIH1dIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICAgICdjb2xvci1vdXRwdXQnOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2NvbG9yJywgY29sb3IxOiBtWzBdLCBjb2xvcjI6IF9taGNoZW1QYXJzZXIuZ28obVsxXSwgJ2JkJykgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdveGlkYXRpb24nOiB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uczogX21oY2hlbUNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncm9tYW4gbnVtZXJhbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdyb21hbi1udW1lcmFsJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHsoLi4uKX0kX18kKC4uLikkJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgJ3JvbWFuLW51bWVyYWwnOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkgeyByZXR1cm4geyB0eXBlXzogJ3JvbWFuIG51bWVyYWwnLCBwMTogbSB9OyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICd0ZXgtbWF0aCc6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zOiBfbWhjaGVtQ3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAgICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnY2UnXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHB1eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIntcIiB9LCAncHUnLCB7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwifVwiIH1dIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7Li4ufXxcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB7IHR5cGVfOiAndGV4LW1hdGgnLCBwMTogYnVmZmVyLm8gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcltwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICd0ZXgtbWF0aCB0aWdodCc6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zOiBfbWhjaGVtQ3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAgICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnY2UnXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXFxcXHB1eyguLi4pfSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgeyB0eXBlXzogJ3dyaXRlJywgb3B0aW9uOiBcIntcIiB9LCAncHUnLCB7IHR5cGVfOiAnd3JpdGUnLCBvcHRpb246IFwifVwiIH1dIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7Li4ufXxcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJy18Kyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0aWdodCBvcGVyYXRvcicgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAndGlnaHQgb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5vID0gKGJ1ZmZlci5vIHx8IFwiXCIpICsgXCJ7XCIgKyBtICsgXCJ9XCI7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5vKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0geyB0eXBlXzogJ3RleC1tYXRoJywgcDE6IGJ1ZmZlci5vIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnOSw5Jzoge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnM6IF9taGNoZW1DcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogW10gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJywnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29tbWEnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAnY29tbWFEZWNpbWFsJyB9OyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdwdSc6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zOiBfbWhjaGVtQ3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAgICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzcGFjZSQnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdzcGFjZSddIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7Wyh8KV19Jzoge1xuICAgICAgICAgICAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiAnY29weScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJygtKSg5KV4oLTkpJzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ251bWJlcl4nLCBuZXh0U3RhdGU6ICdhJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnKC0pKDkuLDkpKGUpKDk5KSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdlbnVtYmVyJywgbmV4dFN0YXRlOiAnYScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiBbXSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncG0tb3BlcmF0b3InOiB7XG4gICAgICAgICAgICAgICAgICAgICcwfGEnOiB7IGFjdGlvbl86IHsgdHlwZV86ICdvcGVyYXRvcicsIG9wdGlvbjogJ1xcXFxwbScgfSwgbmV4dFN0YXRlOiAnMCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ29wZXJhdG9yJzoge1xuICAgICAgICAgICAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiAnY29weScsIG5leHRTdGF0ZTogJzAnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICcvLyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2QnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJy8nIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICcvJzoge1xuICAgICAgICAgICAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnLycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3suLi59fGVsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcwfGQnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgICAgICAgICAgICdhJzogeyBhY3Rpb25fOiBbJ3NwYWNlJywgJ2Q9J10sIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgICAgICAgICAgICcvfHEnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ3EnIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnZW51bWJlcic6IGZ1bmN0aW9uIChfYnVmZmVyLCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1bMF0gPT09IFwiKy1cIiB8fCBtWzBdID09PSBcIisvLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChcIlxcXFxwbSBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9taGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBfbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdwdS05LDknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobVsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtWzJdLm1hdGNoKC9bLC5dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX21oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIF9taGNoZW1QYXJzZXIuZ28obVsyXSwgJ3B1LTksOScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKG1bMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtWzNdIHx8IG1bNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobVszXSA9PT0gXCJlXCIgfHwgbVs0XSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2Nkb3QnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ3RpbWVzJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1bNV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKFwiMTBee1wiICsgbVs1XSArIFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ251bWJlcl4nOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtWzBdID09PSBcIistXCIgfHwgbVswXSA9PT0gXCIrLy1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goXCJcXFxccG0gXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKG1bMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9taGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBfbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdwdS05LDknKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKFwiXntcIiArIG1bMl0gKyBcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnb3BlcmF0b3InOiBmdW5jdGlvbiAoX2J1ZmZlciwgbSwgcDEpIHsgcmV0dXJuIHsgdHlwZV86ICdvcGVyYXRvcicsIGtpbmRfOiAocDEgfHwgbSkgfTsgfSxcbiAgICAgICAgICAgICAgICAnc3BhY2UnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAncHUtc3BhY2UtMScgfTsgfSxcbiAgICAgICAgICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWQgPSBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygneyguLi4pfScsIGJ1ZmZlci5kIHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWQgJiYgbWQucmVtYWluZGVyID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmQgPSBtZC5tYXRjaF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1xID0gX21oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ3soLi4uKX0nLCBidWZmZXIucSB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1xICYmIG1xLnJlbWFpbmRlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5xID0gbXEubWF0Y2hfO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuZC5yZXBsYWNlKC9cXHUwMEIwQ3xcXF5vQ3xcXF57b31DL2csIFwie31ee1xcXFxjaXJjfUNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuZCA9IGJ1ZmZlci5kLnJlcGxhY2UoL1xcdTAwQjBGfFxcXm9GfFxcXntvfUYvZywgXCJ7fV57XFxcXGNpcmN9RlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5xID0gYnVmZmVyLnEucmVwbGFjZSgvXFx1MDBCMEN8XFxeb0N8XFxee299Qy9nLCBcInt9XntcXFxcY2lyY31DXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnEgPSBidWZmZXIucS5yZXBsYWNlKC9cXHUwMEIwRnxcXF5vRnxcXF57b31GL2csIFwie31ee1xcXFxjaXJjfUZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYjUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogX21oY2hlbVBhcnNlci5nbyhidWZmZXIuZCwgJ3B1JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcTogX21oY2hlbVBhcnNlci5nbyhidWZmZXIucSwgJ3B1JylcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLm8gPT09ICcvLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB7IHR5cGVfOiAncHUtZnJhYycsIHAxOiBiNS5kLCBwMjogYjUucSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gYjUuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYjUuZC5sZW5ndGggPiAxIHx8IGI1LnEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnIC8gJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcvJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIGI1LnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gX21oY2hlbVBhcnNlci5nbyhidWZmZXIuZCwgJ3B1LTInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcltwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3B1LTInOiB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uczogX21oY2hlbUNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnKic6IHtcbiAgICAgICAgICAgICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ2Nkb3QnXSwgbmV4dFN0YXRlOiAnMCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1xcXFx4Jzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtPScgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnc3BhY2UnXSwgbmV4dFN0YXRlOiAnMCcgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ157KC4uLil9fF4oLTEpJzoge1xuICAgICAgICAgICAgICAgICAgICAnMSc6IHsgYWN0aW9uXzogJ14oLTEpJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnLTkuLDknOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAncm09JywgbmV4dFN0YXRlOiAnMCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJzEnOiB7IGFjdGlvbl86ICdeKC0xKScsIG5leHRTdGF0ZTogJzAnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd7Li4ufXxlbHNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtPScsIG5leHRTdGF0ZTogJzEnIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnY2RvdCc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICd0aWdodCBjZG90JyB9OyB9LFxuICAgICAgICAgICAgICAgICdeKC0xKSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJtICs9IFwiXntcIiArIG0gKyBcIn1cIjsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICAnc3BhY2UnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAncHUtc3BhY2UtMicgfTsgfSxcbiAgICAgICAgICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtcm0gPSBfbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygneyguLi4pfScsIGJ1ZmZlci5ybSB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtcm0gJiYgbXJtLnJlbWFpbmRlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBfbWhjaGVtUGFyc2VyLmdvKG1ybS5tYXRjaF8sICdwdScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0geyB0eXBlXzogJ3JtJywgcDE6IGJ1ZmZlci5ybSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYnVmZmVyW3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAncHUtOSw5Jzoge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnM6IF9taGNoZW1DcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ291dHB1dC0wJyB9LFxuICAgICAgICAgICAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogJ291dHB1dC1vJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnLCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJzAnOiB7IGFjdGlvbl86IFsnb3V0cHV0LTAnLCAnY29tbWEnXSwgbmV4dFN0YXRlOiAnbycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJy4nOiB7XG4gICAgICAgICAgICAgICAgICAgICcwJzogeyBhY3Rpb25fOiBbJ291dHB1dC0wJywgJ2NvcHknXSwgbmV4dFN0YXRlOiAnbycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dD0nIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAnY29tbWFEZWNpbWFsJyB9OyB9LFxuICAgICAgICAgICAgICAgICdvdXRwdXQtMCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIudGV4dF8gPSBidWZmZXIudGV4dF8gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci50ZXh0Xy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGJ1ZmZlci50ZXh0Xy5sZW5ndGggJSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBidWZmZXIudGV4dF8ubGVuZ3RoIC0gMzsgaSA+IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xy5zdWJzdHIoaSwgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcxMDAwIHNlcGFyYXRvcicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKDAsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYnVmZmVyW3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnb3V0cHV0LW8nOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnRleHRfID0gYnVmZmVyLnRleHRfIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIudGV4dF8ubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBidWZmZXIudGV4dF8ubGVuZ3RoIC0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGE7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xy5zdWJzdHIoaSwgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcxMDAwIHNlcGFyYXRvcicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJbcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIF9taGNoZW1UZXhpZnkgPSB7XG4gICAgZ286IGZ1bmN0aW9uIChpbnB1dCwgYWRkT3V0ZXJCcmFjZXMpIHtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFwiXCI7XG4gICAgICAgIHZhciBjZWUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0aSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dGkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gaW5wdXRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IF9taGNoZW1UZXhpZnkuX2dvMihpbnB1dGkpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dGkudHlwZV8gPT09ICcxc3QtbGV2ZWwgZXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICBjZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkT3V0ZXJCcmFjZXMgJiYgIWNlZSAmJiByZXMpIHtcbiAgICAgICAgICAgIHJlcyA9IFwie1wiICsgcmVzICsgXCJ9XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIF9nb0lubmVyOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9taGNoZW1UZXhpZnkuZ28oaW5wdXQsIGZhbHNlKTtcbiAgICB9LFxuICAgIF9nbzI6IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgc3dpdGNoIChidWYudHlwZV8pIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoZW1maXZlJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBiNSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogX21oY2hlbVRleGlmeS5fZ29Jbm5lcihidWYuYSksXG4gICAgICAgICAgICAgICAgICAgIGI6IF9taGNoZW1UZXhpZnkuX2dvSW5uZXIoYnVmLmIpLFxuICAgICAgICAgICAgICAgICAgICBwOiBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wKSxcbiAgICAgICAgICAgICAgICAgICAgbzogX21oY2hlbVRleGlmeS5fZ29Jbm5lcihidWYubyksXG4gICAgICAgICAgICAgICAgICAgIHE6IF9taGNoZW1UZXhpZnkuX2dvSW5uZXIoYnVmLnEpLFxuICAgICAgICAgICAgICAgICAgICBkOiBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5kKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGI1LmEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGI1LmEubWF0Y2goL15bK1xcLV0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjUuYSA9IFwie1wiICsgYjUuYSArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBiNS5hICsgXCJcXFxcLFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYjUuYiB8fCBiNS5wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217QX19XCI7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIl57XFxcXGhwaGFudG9te1wiICsgKGI1LmIgfHwgXCJcIikgKyBcIn19X3tcXFxcaHBoYW50b217XCIgKyAoYjUucCB8fCBcIlwiKSArIFwifX1cIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiXFxcXG1rZXJuLTEuNW11XCI7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217QX19XCI7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIl57XFxcXHNtYXNoW3Rde1xcXFx2cGhhbnRvbXsyfX1cXFxcbGxhcHtcIiArIChiNS5iIHx8IFwiXCIpICsgXCJ9fVwiO1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCJfe1xcXFx2cGhhbnRvbXsyfVxcXFxsbGFwe1xcXFxzbWFzaFt0XXtcIiArIChiNS5wIHx8IFwiXCIpICsgXCJ9fX1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGI1Lm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGI1Lm8ubWF0Y2goL15bK1xcLV0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjUubyA9IFwie1wiICsgYjUubyArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBiNS5vO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnVmLmRUeXBlID09PSAna3YnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiNS5kIHx8IGI1LnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217QX19XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGI1LmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIl57XCIgKyBiNS5kICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGI1LnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIl97XFxcXHNtYXNoW3Rde1wiICsgYjUucSArIFwifX1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChidWYuZFR5cGUgPT09ICdveGlkYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te0F9fVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiXntcIiArIGI1LmQgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYjUucSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtBfX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIl97XFxcXHNtYXNoW3Rde1wiICsgYjUucSArIFwifX1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGI1LnEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217QX19XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCJfe1xcXFxzbWFzaFt0XXtcIiArIGI1LnEgKyBcIn19XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGI1LmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217QX19XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCJee1wiICsgYjUuZCArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm0nOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhybXtcIiArIGJ1Zi5wMSArIFwifVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgaWYgKGJ1Zi5wMS5tYXRjaCgvW1xcXl9dLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLnAxID0gYnVmLnAxLnJlcGxhY2UoXCIgXCIsIFwiflwiKS5yZXBsYWNlKFwiLVwiLCBcIlxcXFx0ZXh0ey19XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxtYXRocm17XCIgKyBidWYucDEgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IFwiXFxcXHRleHR7XCIgKyBidWYucDEgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb21hbiBudW1lcmFsJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxtYXRocm17XCIgKyBidWYucDEgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxtc2tpcDJtdSBcIiArIF9taGNoZW1UZXhpZnkuX2dvSW5uZXIoYnVmLnAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uIHN1YnNjcmlwdCc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcbXNraXAxbXUgXCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib25kJzpcbiAgICAgICAgICAgICAgICByZXMgPSBfbWhjaGVtVGV4aWZ5Ll9nZXRCb25kKGJ1Zi5raW5kXyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgW1wiTWhjaGVtRXJyb3JCb25kXCIsIFwibWhjaGVtIEVycm9yLiBVbmtub3duIGJvbmQgdHlwZSAoXCIgKyBidWYua2luZF8gKyBcIilcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnJhYyc6XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBcIlxcXFxmcmFje1wiICsgYnVmLnAxICsgXCJ9e1wiICsgYnVmLnAyICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcbWF0aGNob2ljZXtcXFxcdGV4dHN0eWxlXCIgKyBjICsgXCJ9e1wiICsgYyArIFwifXtcIiArIGMgKyBcIn17XCIgKyBjICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdS1mcmFjJzpcbiAgICAgICAgICAgICAgICB2YXIgZCA9IFwiXFxcXGZyYWN7XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxtYXRoY2hvaWNle1xcXFx0ZXh0c3R5bGVcIiArIGQgKyBcIn17XCIgKyBkICsgXCJ9e1wiICsgZCArIFwifXtcIiArIGQgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleC1tYXRoJzpcbiAgICAgICAgICAgICAgICByZXMgPSBidWYucDEgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZyYWMtY2UnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiXFxcXGZyYWN7XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ292ZXJzZXQnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiXFxcXG92ZXJzZXR7XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVyc2V0JzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFx1bmRlcnNldHtcIiArIF9taGNoZW1UZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifXtcIiArIF9taGNoZW1UZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndW5kZXJicmFjZSc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcdW5kZXJicmFjZXtcIiArIF9taGNoZW1UZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifV97XCIgKyBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIntcXFxcY29sb3J7XCIgKyBidWYuY29sb3IxICsgXCJ9e1wiICsgX21oY2hlbVRleGlmeS5fZ29Jbm5lcihidWYuY29sb3IyKSArIFwifX1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9yMCc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcY29sb3J7XCIgKyBidWYuY29sb3IgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fycm93JzpcbiAgICAgICAgICAgICAgICB2YXIgYjYgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJkOiBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5yZCksXG4gICAgICAgICAgICAgICAgICAgIHJxOiBfbWhjaGVtVGV4aWZ5Ll9nb0lubmVyKGJ1Zi5ycSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IF9taGNoZW1UZXhpZnkuX2dldEFycm93KGJ1Zi5yKTtcbiAgICAgICAgICAgICAgICBpZiAoYjYucmQgfHwgYjYucnEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Zi5yID09PSBcIjw9PlwiIHx8IGJ1Zi5yID09PSBcIjw9Pj5cIiB8fCBidWYuciA9PT0gXCI8PD0+XCIgfHwgYnVmLnIgPT09IFwiPC0tPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IFwiXFxcXGxvbmdcIiArIGFycm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGI2LnJkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSBcIlxcXFxvdmVyc2V0e1wiICsgYjYucmQgKyBcIn17XCIgKyBhcnJvdyArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGI2LnJxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Zi5yID09PSBcIjwtLT5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IFwiXFxcXHVuZGVyc2V0e1xcXFxsb3dlcjJtdXtcIiArIGI2LnJxICsgXCJ9fXtcIiArIGFycm93ICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IFwiXFxcXHVuZGVyc2V0e1xcXFxsb3dlcjZtdXtcIiArIGI2LnJxICsgXCJ9fXtcIiArIGFycm93ICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSBcIiB7fVxcXFxtYXRocmVse1wiICsgYXJyb3cgKyBcIn17fSBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiNi5ycSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ICs9IFwiW3tcIiArIGI2LnJxICsgXCJ9XVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgKz0gXCJ7XCIgKyBiNi5yZCArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSBcIiB7fVxcXFxtYXRocmVse1xcXFx4XCIgKyBhcnJvdyArIFwifXt9IFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IFwiIHt9XFxcXG1hdGhyZWx7XFxcXGxvbmdcIiArIGFycm93ICsgXCJ9e30gXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGFycm93O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9taGNoZW1UZXhpZnkuX2dldE9wZXJhdG9yKGJ1Zi5raW5kXyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxc3QtbGV2ZWwgZXNjYXBlJzpcbiAgICAgICAgICAgICAgICByZXMgPSBidWYucDEgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIiBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RpbnlTa2lwJzpcbiAgICAgICAgICAgICAgICByZXMgPSAnXFxcXG1rZXJuMm11JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VudGl0eVNraXAnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiflwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHUtc3BhY2UtMSc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJ+XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdS1zcGFjZS0yJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjNtdSBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzEwMDAgc2VwYXJhdG9yJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjJtdSBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hRGVjaW1hbCc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJ7LH1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIEwnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwie1wiICsgYnVmLnAxICsgXCJ9XFxcXG1rZXJuNm11IFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWEgZW51bWVyYXRpb24gTSc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJ7XCIgKyBidWYucDEgKyBcIn1cXFxcbWtlcm4zbXUgXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tYSBlbnVtZXJhdGlvbiBTJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIntcIiArIGJ1Zi5wMSArIFwifVxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2h5cGhlbic6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcdGV4dHstfVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWRkaXRpb24gY29tcG91bmQnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiXFxcXCx7XFxcXGNkb3R9XFxcXCxcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VsZWN0cm9uIGRvdCc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcbWtlcm4xbXUgXFxcXGJ1bGxldFxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0tWIHgnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwie1xcXFx0aW1lc31cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ByaW1lJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxwcmltZSBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nkb3QnOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiXFxcXGNkb3QgXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0aWdodCBjZG90JzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjFtdXtcXFxcY2RvdH1cXFxcbWtlcm4xbXUgXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0aW1lcyc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcXFxcdGltZXMgXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaXJjYSc6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJ7XFxcXHNpbX1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwidXBhcnJvd1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgcmVzID0gXCJkb3duYXJyb3dcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2lzJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFxsZG90cyBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIHJlcyA9IFwiL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIC8gJzpcbiAgICAgICAgICAgICAgICByZXMgPSBcIlxcXFwsL1xcXFwsXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKGJ1Zik7XG4gICAgICAgICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIF9nZXRBcnJvdzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgICAgICBjYXNlIFwiLT5cIjogcmV0dXJuIFwicmlnaHRhcnJvd1wiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIxOTJcIjogcmV0dXJuIFwicmlnaHRhcnJvd1wiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTI3RjZcIjogcmV0dXJuIFwicmlnaHRhcnJvd1wiO1xuICAgICAgICAgICAgY2FzZSBcIjwtXCI6IHJldHVybiBcImxlZnRhcnJvd1wiO1xuICAgICAgICAgICAgY2FzZSBcIjwtPlwiOiByZXR1cm4gXCJsZWZ0cmlnaHRhcnJvd1wiO1xuICAgICAgICAgICAgY2FzZSBcIjwtLT5cIjogcmV0dXJuIFwibGVmdHJpZ2h0YXJyb3dzXCI7XG4gICAgICAgICAgICBjYXNlIFwiPD0+XCI6IHJldHVybiBcInJpZ2h0bGVmdGhhcnBvb25zXCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjFDQ1wiOiByZXR1cm4gXCJyaWdodGxlZnRoYXJwb29uc1wiO1xuICAgICAgICAgICAgY2FzZSBcIjw9Pj5cIjogcmV0dXJuIFwiUmlnaHRsZWZ0aGFycG9vbnNcIjtcbiAgICAgICAgICAgIGNhc2UgXCI8PD0+XCI6IHJldHVybiBcIkxlZnRyaWdodGhhcnBvb25zXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKGEpO1xuICAgICAgICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0Qm9uZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gXCJ7LX1cIjtcbiAgICAgICAgICAgIGNhc2UgXCIxXCI6IHJldHVybiBcInstfVwiO1xuICAgICAgICAgICAgY2FzZSBcIj1cIjogcmV0dXJuIFwiez19XCI7XG4gICAgICAgICAgICBjYXNlIFwiMlwiOiByZXR1cm4gXCJ7PX1cIjtcbiAgICAgICAgICAgIGNhc2UgXCIjXCI6IHJldHVybiBcIntcXFxcZXF1aXZ9XCI7XG4gICAgICAgICAgICBjYXNlIFwiM1wiOiByZXR1cm4gXCJ7XFxcXGVxdWl2fVwiO1xuICAgICAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVkYXNofVwiO1xuICAgICAgICAgICAgY2FzZSBcIn4tXCI6IHJldHVybiBcIntcXFxccmxhcHtcXFxcbG93ZXIuMWVtey19fVxcXFxyYWlzZS4xZW17XFxcXHRyaXBsZWRhc2h9fVwiO1xuICAgICAgICAgICAgY2FzZSBcIn49XCI6IHJldHVybiBcIntcXFxccmxhcHtcXFxcbG93ZXIuMmVtey19fVxcXFxybGFwe1xcXFxyYWlzZS4yZW17XFxcXHRyaXBsZWRhc2h9fS19XCI7XG4gICAgICAgICAgICBjYXNlIFwifi0tXCI6IHJldHVybiBcIntcXFxccmxhcHtcXFxcbG93ZXIuMmVtey19fVxcXFxybGFwe1xcXFxyYWlzZS4yZW17XFxcXHRyaXBsZWRhc2h9fS19XCI7XG4gICAgICAgICAgICBjYXNlIFwiLX4tXCI6IHJldHVybiBcIntcXFxccmxhcHtcXFxcbG93ZXIuMmVtey19fVxcXFxybGFwe1xcXFxyYWlzZS4yZW17LX19XFxcXHRyaXBsZWRhc2h9XCI7XG4gICAgICAgICAgICBjYXNlIFwiLi4uXCI6IHJldHVybiBcInt7XFxcXGNkb3R9e1xcXFxjZG90fXtcXFxcY2RvdH19XCI7XG4gICAgICAgICAgICBjYXNlIFwiLi4uLlwiOiByZXR1cm4gXCJ7e1xcXFxjZG90fXtcXFxcY2RvdH17XFxcXGNkb3R9e1xcXFxjZG90fX1cIjtcbiAgICAgICAgICAgIGNhc2UgXCItPlwiOiByZXR1cm4gXCJ7XFxcXHJpZ2h0YXJyb3d9XCI7XG4gICAgICAgICAgICBjYXNlIFwiPC1cIjogcmV0dXJuIFwie1xcXFxsZWZ0YXJyb3d9XCI7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gXCJ7PH1cIjtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBcIns+fVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhc3NlcnROZXZlcihhKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdUXCIsIFwibWhjaGVtIGJ1ZyBULiBQbGVhc2UgcmVwb3J0LlwiXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2dldE9wZXJhdG9yOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiBcIiB7fSt7fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCItXCI6IHJldHVybiBcIiB7fS17fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiBcIiB7fT17fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiBcIiB7fTx7fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBcIiB7fT57fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCI8PFwiOiByZXR1cm4gXCIge31cXFxcbGx7fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCI+PlwiOiByZXR1cm4gXCIge31cXFxcZ2d7fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXFxccG1cIjogcmV0dXJuIFwiIHt9XFxcXHBte30gXCI7XG4gICAgICAgICAgICBjYXNlIFwiXFxcXGFwcHJveFwiOiByZXR1cm4gXCIge31cXFxcYXBwcm94e30gXCI7XG4gICAgICAgICAgICBjYXNlIFwiJFxcXFxhcHByb3gkXCI6IHJldHVybiBcIiB7fVxcXFxhcHByb3h7fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6IHJldHVybiBcIiBcXFxcZG93bmFycm93e30gXCI7XG4gICAgICAgICAgICBjYXNlIFwiKHYpXCI6IHJldHVybiBcIiBcXFxcZG93bmFycm93e30gXCI7XG4gICAgICAgICAgICBjYXNlIFwiXlwiOiByZXR1cm4gXCIgXFxcXHVwYXJyb3d7fSBcIjtcbiAgICAgICAgICAgIGNhc2UgXCIoXilcIjogcmV0dXJuIFwiIFxcXFx1cGFycm93e30gXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKGEpO1xuICAgICAgICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKGEpIHsgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9