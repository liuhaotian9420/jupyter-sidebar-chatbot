"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_microsoft_fast-element_dist_esm_index_js"],{

/***/ "./node_modules/@microsoft/fast-element/dist/esm/components/attributes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/components/attributes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeConfiguration: () => (/* binding */ AttributeConfiguration),
/* harmony export */   AttributeDefinition: () => (/* binding */ AttributeDefinition),
/* harmony export */   attr: () => (/* binding */ attr),
/* harmony export */   booleanConverter: () => (/* binding */ booleanConverter),
/* harmony export */   nullableNumberConverter: () => (/* binding */ nullableNumberConverter)
/* harmony export */ });
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");



/**
 * Metadata used to configure a custom attribute's behavior.
 * @public
 */
const AttributeConfiguration = Object.freeze({
    /**
     * Locates all attribute configurations associated with a type.
     */
    locate: (0,_platform_js__WEBPACK_IMPORTED_MODULE_0__.createMetadataLocator)(),
});
/**
 * A {@link ValueConverter} that converts to and from `boolean` values.
 * @remarks
 * Used automatically when the `boolean` {@link AttributeMode} is selected.
 * @public
 */
const booleanConverter = {
    toView(value) {
        return value ? "true" : "false";
    },
    fromView(value) {
        if (value === null ||
            value === void 0 ||
            value === "false" ||
            value === false ||
            value === 0) {
            return false;
        }
        return true;
    },
};
/**
 * A {@link ValueConverter} that converts to and from `number` values.
 * @remarks
 * This converter allows for nullable numbers, returning `null` if the
 * input was `null`, `undefined`, or `NaN`.
 * @public
 */
const nullableNumberConverter = {
    toView(value) {
        if (value === null || value === undefined) {
            return null;
        }
        const number = value * 1;
        return isNaN(number) ? null : number.toString();
    },
    fromView(value) {
        if (value === null || value === undefined) {
            return null;
        }
        const number = value * 1;
        return isNaN(number) ? null : number;
    },
};
/**
 * An implementation of {@link Accessor} that supports reactivity,
 * change callbacks, attribute reflection, and type conversion for
 * custom elements.
 * @public
 */
class AttributeDefinition {
    /**
     * Creates an instance of AttributeDefinition.
     * @param Owner - The class constructor that owns this attribute.
     * @param name - The name of the property associated with the attribute.
     * @param attribute - The name of the attribute in HTML.
     * @param mode - The {@link AttributeMode} that describes the behavior of this attribute.
     * @param converter - A {@link ValueConverter} that integrates with the property getter/setter
     * to convert values to and from a DOM string.
     */
    constructor(Owner, name, attribute = name.toLowerCase(), mode = "reflect", converter) {
        this.guards = new Set();
        this.Owner = Owner;
        this.name = name;
        this.attribute = attribute;
        this.mode = mode;
        this.converter = converter;
        this.fieldName = `_${name}`;
        this.callbackName = `${name}Changed`;
        this.hasCallback = this.callbackName in Owner.prototype;
        if (mode === "boolean" && converter === void 0) {
            this.converter = booleanConverter;
        }
    }
    /**
     * Sets the value of the attribute/property on the source element.
     * @param source - The source element to access.
     * @param value - The value to set the attribute/property to.
     */
    setValue(source, newValue) {
        const oldValue = source[this.fieldName];
        const converter = this.converter;
        if (converter !== void 0) {
            newValue = converter.fromView(newValue);
        }
        if (oldValue !== newValue) {
            source[this.fieldName] = newValue;
            this.tryReflectToAttribute(source);
            if (this.hasCallback) {
                source[this.callbackName](oldValue, newValue);
            }
            source.$fastController.notify(this.name);
        }
    }
    /**
     * Gets the value of the attribute/property on the source element.
     * @param source - The source element to access.
     */
    getValue(source) {
        _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable.track(source, this.name);
        return source[this.fieldName];
    }
    /** @internal */
    onAttributeChangedCallback(element, value) {
        if (this.guards.has(element)) {
            return;
        }
        this.guards.add(element);
        this.setValue(element, value);
        this.guards.delete(element);
    }
    tryReflectToAttribute(element) {
        const mode = this.mode;
        const guards = this.guards;
        if (guards.has(element) || mode === "fromView") {
            return;
        }
        _dom_js__WEBPACK_IMPORTED_MODULE_2__.DOM.queueUpdate(() => {
            guards.add(element);
            const latestValue = element[this.fieldName];
            switch (mode) {
                case "reflect":
                    const converter = this.converter;
                    _dom_js__WEBPACK_IMPORTED_MODULE_2__.DOM.setAttribute(element, this.attribute, converter !== void 0 ? converter.toView(latestValue) : latestValue);
                    break;
                case "boolean":
                    _dom_js__WEBPACK_IMPORTED_MODULE_2__.DOM.setBooleanAttribute(element, this.attribute, latestValue);
                    break;
            }
            guards.delete(element);
        });
    }
    /**
     * Collects all attribute definitions associated with the owner.
     * @param Owner - The class constructor to collect attribute for.
     * @param attributeLists - Any existing attributes to collect and merge with those associated with the owner.
     * @internal
     */
    static collect(Owner, ...attributeLists) {
        const attributes = [];
        attributeLists.push(AttributeConfiguration.locate(Owner));
        for (let i = 0, ii = attributeLists.length; i < ii; ++i) {
            const list = attributeLists[i];
            if (list === void 0) {
                continue;
            }
            for (let j = 0, jj = list.length; j < jj; ++j) {
                const config = list[j];
                if (typeof config === "string") {
                    attributes.push(new AttributeDefinition(Owner, config));
                }
                else {
                    attributes.push(new AttributeDefinition(Owner, config.property, config.attribute, config.mode, config.converter));
                }
            }
        }
        return attributes;
    }
}
function attr(configOrTarget, prop) {
    let config;
    function decorator($target, $prop) {
        if (arguments.length > 1) {
            // Non invocation:
            // - @attr
            // Invocation with or w/o opts:
            // - @attr()
            // - @attr({...opts})
            config.property = $prop;
        }
        AttributeConfiguration.locate($target.constructor).push(config);
    }
    if (arguments.length > 1) {
        // Non invocation:
        // - @attr
        config = {};
        decorator(configOrTarget, prop);
        return;
    }
    // Invocation with or w/o opts:
    // - @attr()
    // - @attr({...opts})
    config = configOrTarget === void 0 ? {} : configOrTarget;
    return decorator;
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/components/controller.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/components/controller.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Controller: () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _observation_notifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation/notifier.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _fast_definitions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fast-definitions.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js");




const shadowRoots = new WeakMap();
const defaultEventOptions = {
    bubbles: true,
    composed: true,
    cancelable: true,
};
function getShadowRoot(element) {
    return element.shadowRoot || shadowRoots.get(element) || null;
}
/**
 * Controls the lifecycle and rendering of a `FASTElement`.
 * @public
 */
class Controller extends _observation_notifier_js__WEBPACK_IMPORTED_MODULE_0__.PropertyChangeNotifier {
    /**
     * Creates a Controller to control the specified element.
     * @param element - The element to be controlled by this controller.
     * @param definition - The element definition metadata that instructs this
     * controller in how to handle rendering and other platform integrations.
     * @internal
     */
    constructor(element, definition) {
        super(element);
        this.boundObservables = null;
        this.behaviors = null;
        this.needsInitialization = true;
        this._template = null;
        this._styles = null;
        this._isConnected = false;
        /**
         * This allows Observable.getNotifier(...) to return the Controller
         * when the notifier for the Controller itself is being requested. The
         * result is that the Observable system does not need to create a separate
         * instance of Notifier for observables on the Controller. The component and
         * the controller will now share the same notifier, removing one-object construct
         * per web component instance.
         */
        this.$fastController = this;
        /**
         * The view associated with the custom element.
         * @remarks
         * If `null` then the element is managing its own rendering.
         */
        this.view = null;
        this.element = element;
        this.definition = definition;
        const shadowOptions = definition.shadowOptions;
        if (shadowOptions !== void 0) {
            const shadowRoot = element.attachShadow(shadowOptions);
            if (shadowOptions.mode === "closed") {
                shadowRoots.set(element, shadowRoot);
            }
        }
        // Capture any observable values that were set by the binding engine before
        // the browser upgraded the element. Then delete the property since it will
        // shadow the getter/setter that is required to make the observable operate.
        // Later, in the connect callback, we'll re-apply the values.
        const accessors = _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable.getAccessors(element);
        if (accessors.length > 0) {
            const boundObservables = (this.boundObservables = Object.create(null));
            for (let i = 0, ii = accessors.length; i < ii; ++i) {
                const propertyName = accessors[i].name;
                const value = element[propertyName];
                if (value !== void 0) {
                    delete element[propertyName];
                    boundObservables[propertyName] = value;
                }
            }
        }
    }
    /**
     * Indicates whether or not the custom element has been
     * connected to the document.
     */
    get isConnected() {
        _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable.track(this, "isConnected");
        return this._isConnected;
    }
    setIsConnected(value) {
        this._isConnected = value;
        _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable.notify(this, "isConnected");
    }
    /**
     * Gets/sets the template used to render the component.
     * @remarks
     * This value can only be accurately read after connect but can be set at any time.
     */
    get template() {
        return this._template;
    }
    set template(value) {
        if (this._template === value) {
            return;
        }
        this._template = value;
        if (!this.needsInitialization) {
            this.renderTemplate(value);
        }
    }
    /**
     * Gets/sets the primary styles used for the component.
     * @remarks
     * This value can only be accurately read after connect but can be set at any time.
     */
    get styles() {
        return this._styles;
    }
    set styles(value) {
        if (this._styles === value) {
            return;
        }
        if (this._styles !== null) {
            this.removeStyles(this._styles);
        }
        this._styles = value;
        if (!this.needsInitialization && value !== null) {
            this.addStyles(value);
        }
    }
    /**
     * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.
     * @param styles - The styles to add.
     */
    addStyles(styles) {
        const target = getShadowRoot(this.element) ||
            this.element.getRootNode();
        if (styles instanceof HTMLStyleElement) {
            target.append(styles);
        }
        else if (!styles.isAttachedTo(target)) {
            const sourceBehaviors = styles.behaviors;
            styles.addStylesTo(target);
            if (sourceBehaviors !== null) {
                this.addBehaviors(sourceBehaviors);
            }
        }
    }
    /**
     * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.
     * @param styles - the styles to remove.
     */
    removeStyles(styles) {
        const target = getShadowRoot(this.element) ||
            this.element.getRootNode();
        if (styles instanceof HTMLStyleElement) {
            target.removeChild(styles);
        }
        else if (styles.isAttachedTo(target)) {
            const sourceBehaviors = styles.behaviors;
            styles.removeStylesFrom(target);
            if (sourceBehaviors !== null) {
                this.removeBehaviors(sourceBehaviors);
            }
        }
    }
    /**
     * Adds behaviors to this element.
     * @param behaviors - The behaviors to add.
     */
    addBehaviors(behaviors) {
        const targetBehaviors = this.behaviors || (this.behaviors = new Map());
        const length = behaviors.length;
        const behaviorsToBind = [];
        for (let i = 0; i < length; ++i) {
            const behavior = behaviors[i];
            if (targetBehaviors.has(behavior)) {
                targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);
            }
            else {
                targetBehaviors.set(behavior, 1);
                behaviorsToBind.push(behavior);
            }
        }
        if (this._isConnected) {
            const element = this.element;
            for (let i = 0; i < behaviorsToBind.length; ++i) {
                behaviorsToBind[i].bind(element, _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.defaultExecutionContext);
            }
        }
    }
    /**
     * Removes behaviors from this element.
     * @param behaviors - The behaviors to remove.
     * @param force - Forces unbinding of behaviors.
     */
    removeBehaviors(behaviors, force = false) {
        const targetBehaviors = this.behaviors;
        if (targetBehaviors === null) {
            return;
        }
        const length = behaviors.length;
        const behaviorsToUnbind = [];
        for (let i = 0; i < length; ++i) {
            const behavior = behaviors[i];
            if (targetBehaviors.has(behavior)) {
                const count = targetBehaviors.get(behavior) - 1;
                count === 0 || force
                    ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior)
                    : targetBehaviors.set(behavior, count);
            }
        }
        if (this._isConnected) {
            const element = this.element;
            for (let i = 0; i < behaviorsToUnbind.length; ++i) {
                behaviorsToUnbind[i].unbind(element);
            }
        }
    }
    /**
     * Runs connected lifecycle behavior on the associated element.
     */
    onConnectedCallback() {
        if (this._isConnected) {
            return;
        }
        const element = this.element;
        if (this.needsInitialization) {
            this.finishInitialization();
        }
        else if (this.view !== null) {
            this.view.bind(element, _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.defaultExecutionContext);
        }
        const behaviors = this.behaviors;
        if (behaviors !== null) {
            for (const [behavior] of behaviors) {
                behavior.bind(element, _observation_observable_js__WEBPACK_IMPORTED_MODULE_1__.defaultExecutionContext);
            }
        }
        this.setIsConnected(true);
    }
    /**
     * Runs disconnected lifecycle behavior on the associated element.
     */
    onDisconnectedCallback() {
        if (!this._isConnected) {
            return;
        }
        this.setIsConnected(false);
        const view = this.view;
        if (view !== null) {
            view.unbind();
        }
        const behaviors = this.behaviors;
        if (behaviors !== null) {
            const element = this.element;
            for (const [behavior] of behaviors) {
                behavior.unbind(element);
            }
        }
    }
    /**
     * Runs the attribute changed callback for the associated element.
     * @param name - The name of the attribute that changed.
     * @param oldValue - The previous value of the attribute.
     * @param newValue - The new value of the attribute.
     */
    onAttributeChangedCallback(name, oldValue, newValue) {
        const attrDef = this.definition.attributeLookup[name];
        if (attrDef !== void 0) {
            attrDef.onAttributeChangedCallback(this.element, newValue);
        }
    }
    /**
     * Emits a custom HTML event.
     * @param type - The type name of the event.
     * @param detail - The event detail object to send with the event.
     * @param options - The event options. By default bubbles and composed.
     * @remarks
     * Only emits events if connected.
     */
    emit(type, detail, options) {
        if (this._isConnected) {
            return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));
        }
        return false;
    }
    finishInitialization() {
        const element = this.element;
        const boundObservables = this.boundObservables;
        // If we have any observables that were bound, re-apply their values.
        if (boundObservables !== null) {
            const propertyNames = Object.keys(boundObservables);
            for (let i = 0, ii = propertyNames.length; i < ii; ++i) {
                const propertyName = propertyNames[i];
                element[propertyName] = boundObservables[propertyName];
            }
            this.boundObservables = null;
        }
        const definition = this.definition;
        // 1. Template overrides take top precedence.
        if (this._template === null) {
            if (this.element.resolveTemplate) {
                // 2. Allow for element instance overrides next.
                this._template = this.element.resolveTemplate();
            }
            else if (definition.template) {
                // 3. Default to the static definition.
                this._template = definition.template || null;
            }
        }
        // If we have a template after the above process, render it.
        // If there's no template, then the element author has opted into
        // custom rendering and they will managed the shadow root's content themselves.
        if (this._template !== null) {
            this.renderTemplate(this._template);
        }
        // 1. Styles overrides take top precedence.
        if (this._styles === null) {
            if (this.element.resolveStyles) {
                // 2. Allow for element instance overrides next.
                this._styles = this.element.resolveStyles();
            }
            else if (definition.styles) {
                // 3. Default to the static definition.
                this._styles = definition.styles || null;
            }
        }
        // If we have styles after the above process, add them.
        if (this._styles !== null) {
            this.addStyles(this._styles);
        }
        this.needsInitialization = false;
    }
    renderTemplate(template) {
        const element = this.element;
        // When getting the host to render to, we start by looking
        // up the shadow root. If there isn't one, then that means
        // we're doing a Light DOM render to the element's direct children.
        const host = getShadowRoot(element) || element;
        if (this.view !== null) {
            // If there's already a view, we need to unbind and remove through dispose.
            this.view.dispose();
            this.view = null;
        }
        else if (!this.needsInitialization) {
            // If there was previous custom rendering, we need to clear out the host.
            _dom_js__WEBPACK_IMPORTED_MODULE_2__.DOM.removeChildNodes(host);
        }
        if (template) {
            // If a new template was provided, render it.
            this.view = template.render(element, host, element);
        }
    }
    /**
     * Locates or creates a controller for the specified element.
     * @param element - The element to return the controller for.
     * @remarks
     * The specified element must have a {@link FASTElementDefinition}
     * registered either through the use of the {@link customElement}
     * decorator or a call to `FASTElement.define`.
     */
    static forCustomElement(element) {
        const controller = element.$fastController;
        if (controller !== void 0) {
            return controller;
        }
        const definition = _fast_definitions_js__WEBPACK_IMPORTED_MODULE_3__.FASTElementDefinition.forType(element.constructor);
        if (definition === void 0) {
            throw new Error("Missing FASTElement definition.");
        }
        return (element.$fastController = new Controller(element, definition));
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FASTElementDefinition: () => (/* binding */ FASTElementDefinition)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _styles_element_styles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/element-styles.js */ "./node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js");
/* harmony import */ var _attributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attributes.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/attributes.js");




const defaultShadowOptions = { mode: "open" };
const defaultElementOptions = {};
const fastRegistry = _platform_js__WEBPACK_IMPORTED_MODULE_0__.FAST.getById(4 /* elementRegistry */, () => {
    const typeToDefinition = new Map();
    return Object.freeze({
        register(definition) {
            if (typeToDefinition.has(definition.type)) {
                return false;
            }
            typeToDefinition.set(definition.type, definition);
            return true;
        },
        getByType(key) {
            return typeToDefinition.get(key);
        },
    });
});
/**
 * Defines metadata for a FASTElement.
 * @public
 */
class FASTElementDefinition {
    /**
     * Creates an instance of FASTElementDefinition.
     * @param type - The type this definition is being created for.
     * @param nameOrConfig - The name of the element to define or a config object
     * that describes the element to define.
     */
    constructor(type, nameOrConfig = type.definition) {
        if (typeof nameOrConfig === "string") {
            nameOrConfig = { name: nameOrConfig };
        }
        this.type = type;
        this.name = nameOrConfig.name;
        this.template = nameOrConfig.template;
        const attributes = _attributes_js__WEBPACK_IMPORTED_MODULE_1__.AttributeDefinition.collect(type, nameOrConfig.attributes);
        const observedAttributes = new Array(attributes.length);
        const propertyLookup = {};
        const attributeLookup = {};
        for (let i = 0, ii = attributes.length; i < ii; ++i) {
            const current = attributes[i];
            observedAttributes[i] = current.attribute;
            propertyLookup[current.name] = current;
            attributeLookup[current.attribute] = current;
        }
        this.attributes = attributes;
        this.observedAttributes = observedAttributes;
        this.propertyLookup = propertyLookup;
        this.attributeLookup = attributeLookup;
        this.shadowOptions =
            nameOrConfig.shadowOptions === void 0
                ? defaultShadowOptions
                : nameOrConfig.shadowOptions === null
                    ? void 0
                    : Object.assign(Object.assign({}, defaultShadowOptions), nameOrConfig.shadowOptions);
        this.elementOptions =
            nameOrConfig.elementOptions === void 0
                ? defaultElementOptions
                : Object.assign(Object.assign({}, defaultElementOptions), nameOrConfig.elementOptions);
        this.styles =
            nameOrConfig.styles === void 0
                ? void 0
                : Array.isArray(nameOrConfig.styles)
                    ? _styles_element_styles_js__WEBPACK_IMPORTED_MODULE_2__.ElementStyles.create(nameOrConfig.styles)
                    : nameOrConfig.styles instanceof _styles_element_styles_js__WEBPACK_IMPORTED_MODULE_2__.ElementStyles
                        ? nameOrConfig.styles
                        : _styles_element_styles_js__WEBPACK_IMPORTED_MODULE_2__.ElementStyles.create([nameOrConfig.styles]);
    }
    /**
     * Indicates if this element has been defined in at least one registry.
     */
    get isDefined() {
        return !!fastRegistry.getByType(this.type);
    }
    /**
     * Defines a custom element based on this definition.
     * @param registry - The element registry to define the element in.
     */
    define(registry = customElements) {
        const type = this.type;
        if (fastRegistry.register(this)) {
            const attributes = this.attributes;
            const proto = type.prototype;
            for (let i = 0, ii = attributes.length; i < ii; ++i) {
                _observation_observable_js__WEBPACK_IMPORTED_MODULE_3__.Observable.defineProperty(proto, attributes[i]);
            }
            Reflect.defineProperty(type, "observedAttributes", {
                value: this.observedAttributes,
                enumerable: true,
            });
        }
        if (!registry.get(this.name)) {
            registry.define(this.name, type, this.elementOptions);
        }
        return this;
    }
}
/**
 * Gets the element definition associated with the specified type.
 * @param type - The custom element type to retrieve the definition for.
 */
FASTElementDefinition.forType = fastRegistry.getByType;


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FASTElement: () => (/* binding */ FASTElement),
/* harmony export */   customElement: () => (/* binding */ customElement)
/* harmony export */ });
/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/controller.js");
/* harmony import */ var _fast_definitions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fast-definitions.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js");


/* eslint-disable-next-line @typescript-eslint/explicit-function-return-type */
function createFASTElement(BaseType) {
    return class extends BaseType {
        constructor() {
            /* eslint-disable-next-line */
            super();
            _controller_js__WEBPACK_IMPORTED_MODULE_0__.Controller.forCustomElement(this);
        }
        $emit(type, detail, options) {
            return this.$fastController.emit(type, detail, options);
        }
        connectedCallback() {
            this.$fastController.onConnectedCallback();
        }
        disconnectedCallback() {
            this.$fastController.onDisconnectedCallback();
        }
        attributeChangedCallback(name, oldValue, newValue) {
            this.$fastController.onAttributeChangedCallback(name, oldValue, newValue);
        }
    };
}
/**
 * A minimal base class for FASTElements that also provides
 * static helpers for working with FASTElements.
 * @public
 */
const FASTElement = Object.assign(createFASTElement(HTMLElement), {
    /**
     * Creates a new FASTElement base class inherited from the
     * provided base type.
     * @param BaseType - The base element type to inherit from.
     */
    from(BaseType) {
        return createFASTElement(BaseType);
    },
    /**
     * Defines a platform custom element based on the provided type and definition.
     * @param type - The custom element type to define.
     * @param nameOrDef - The name of the element to define or a definition object
     * that describes the element to define.
     */
    define(type, nameOrDef) {
        return new _fast_definitions_js__WEBPACK_IMPORTED_MODULE_1__.FASTElementDefinition(type, nameOrDef).define().type;
    },
});
/**
 * Decorator: Defines a platform custom element based on `FASTElement`.
 * @param nameOrDef - The name of the element to define or a definition object
 * that describes the element to define.
 * @public
 */
function customElement(nameOrDef) {
    /* eslint-disable-next-line @typescript-eslint/explicit-function-return-type */
    return function (type) {
        new _fast_definitions_js__WEBPACK_IMPORTED_MODULE_1__.FASTElementDefinition(type, nameOrDef).define();
    };
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/dom.js":
/*!**************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/dom.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOM: () => (/* binding */ DOM),
/* harmony export */   _interpolationEnd: () => (/* binding */ _interpolationEnd),
/* harmony export */   _interpolationStart: () => (/* binding */ _interpolationStart)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");

const updateQueue = _platform_js__WEBPACK_IMPORTED_MODULE_0__.$global.FAST.getById(1 /* updateQueue */, () => {
    const tasks = [];
    const pendingErrors = [];
    function throwFirstError() {
        if (pendingErrors.length) {
            throw pendingErrors.shift();
        }
    }
    function tryRunTask(task) {
        try {
            task.call();
        }
        catch (error) {
            pendingErrors.push(error);
            setTimeout(throwFirstError, 0);
        }
    }
    function process() {
        const capacity = 1024;
        let index = 0;
        while (index < tasks.length) {
            tryRunTask(tasks[index]);
            index++;
            // Prevent leaking memory for long chains of recursive calls to `DOM.queueUpdate`.
            // If we call `DOM.queueUpdate` within a task scheduled by `DOM.queueUpdate`, the queue will
            // grow, but to avoid an O(n) walk for every task we execute, we don't
            // shift tasks off the queue after they have been executed.
            // Instead, we periodically shift 1024 tasks off the queue.
            if (index > capacity) {
                // Manually shift all values starting at the index back to the
                // beginning of the queue.
                for (let scan = 0, newLength = tasks.length - index; scan < newLength; scan++) {
                    tasks[scan] = tasks[scan + index];
                }
                tasks.length -= index;
                index = 0;
            }
        }
        tasks.length = 0;
    }
    function enqueue(callable) {
        if (tasks.length < 1) {
            _platform_js__WEBPACK_IMPORTED_MODULE_0__.$global.requestAnimationFrame(process);
        }
        tasks.push(callable);
    }
    return Object.freeze({
        enqueue,
        process,
    });
});
/* eslint-disable */
const fastHTMLPolicy = _platform_js__WEBPACK_IMPORTED_MODULE_0__.$global.trustedTypes.createPolicy("fast-html", {
    createHTML: html => html,
});
/* eslint-enable */
let htmlPolicy = fastHTMLPolicy;
const marker = `fast-${Math.random().toString(36).substring(2, 8)}`;
/** @internal */
const _interpolationStart = `${marker}{`;
/** @internal */
const _interpolationEnd = `}${marker}`;
/**
 * Common DOM APIs.
 * @public
 */
const DOM = Object.freeze({
    /**
     * Indicates whether the DOM supports the adoptedStyleSheets feature.
     */
    supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) &&
        "replace" in CSSStyleSheet.prototype,
    /**
     * Sets the HTML trusted types policy used by the templating engine.
     * @param policy - The policy to set for HTML.
     * @remarks
     * This API can only be called once, for security reasons. It should be
     * called by the application developer at the start of their program.
     */
    setHTMLPolicy(policy) {
        if (htmlPolicy !== fastHTMLPolicy) {
            throw new Error("The HTML policy can only be set once.");
        }
        htmlPolicy = policy;
    },
    /**
     * Turns a string into trusted HTML using the configured trusted types policy.
     * @param html - The string to turn into trusted HTML.
     * @remarks
     * Used internally by the template engine when creating templates
     * and setting innerHTML.
     */
    createHTML(html) {
        return htmlPolicy.createHTML(html);
    },
    /**
     * Determines if the provided node is a template marker used by the runtime.
     * @param node - The node to test.
     */
    isMarker(node) {
        return node && node.nodeType === 8 && node.data.startsWith(marker);
    },
    /**
     * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.
     * @param node - The marker node to extract the index from.
     */
    extractDirectiveIndexFromMarker(node) {
        return parseInt(node.data.replace(`${marker}:`, ""));
    },
    /**
     * Creates a placeholder string suitable for marking out a location *within*
     * an attribute value or HTML content.
     * @param index - The directive index to create the placeholder for.
     * @remarks
     * Used internally by binding directives.
     */
    createInterpolationPlaceholder(index) {
        return `${_interpolationStart}${index}${_interpolationEnd}`;
    },
    /**
     * Creates a placeholder that manifests itself as an attribute on an
     * element.
     * @param attributeName - The name of the custom attribute.
     * @param index - The directive index to create the placeholder for.
     * @remarks
     * Used internally by attribute directives such as `ref`, `slotted`, and `children`.
     */
    createCustomAttributePlaceholder(attributeName, index) {
        return `${attributeName}="${this.createInterpolationPlaceholder(index)}"`;
    },
    /**
     * Creates a placeholder that manifests itself as a marker within the DOM structure.
     * @param index - The directive index to create the placeholder for.
     * @remarks
     * Used internally by structural directives such as `repeat`.
     */
    createBlockPlaceholder(index) {
        return `<!--${marker}:${index}-->`;
    },
    /**
     * Schedules DOM update work in the next async batch.
     * @param callable - The callable function or object to queue.
     */
    queueUpdate: updateQueue.enqueue,
    /**
     * Immediately processes all work previously scheduled
     * through queueUpdate.
     * @remarks
     * This also forces nextUpdate promises
     * to resolve.
     */
    processUpdates: updateQueue.process,
    /**
     * Resolves with the next DOM update.
     */
    nextUpdate() {
        return new Promise(updateQueue.enqueue);
    },
    /**
     * Sets an attribute value on an element.
     * @param element - The element to set the attribute value on.
     * @param attributeName - The attribute name to set.
     * @param value - The value of the attribute to set.
     * @remarks
     * If the value is `null` or `undefined`, the attribute is removed, otherwise
     * it is set to the provided value using the standard `setAttribute` API.
     */
    setAttribute(element, attributeName, value) {
        if (value === null || value === undefined) {
            element.removeAttribute(attributeName);
        }
        else {
            element.setAttribute(attributeName, value);
        }
    },
    /**
     * Sets a boolean attribute value.
     * @param element - The element to set the boolean attribute value on.
     * @param attributeName - The attribute name to set.
     * @param value - The value of the attribute to set.
     * @remarks
     * If the value is true, the attribute is added; otherwise it is removed.
     */
    setBooleanAttribute(element, attributeName, value) {
        value
            ? element.setAttribute(attributeName, "")
            : element.removeAttribute(attributeName);
    },
    /**
     * Removes all the child nodes of the provided parent node.
     * @param parent - The node to remove the children from.
     */
    removeChildNodes(parent) {
        for (let child = parent.firstChild; child !== null; child = parent.firstChild) {
            parent.removeChild(child);
        }
    },
    /**
     * Creates a TreeWalker configured to walk a template fragment.
     * @param fragment - The fragment to walk.
     */
    createTemplateWalker(fragment) {
        return document.createTreeWalker(fragment, 133, // element, text, comment
        null, false);
    },
});


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $global: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_0__.$global),
/* harmony export */   AttachedBehaviorHTMLDirective: () => (/* reexport safe */ _templating_html_directive_js__WEBPACK_IMPORTED_MODULE_16__.AttachedBehaviorHTMLDirective),
/* harmony export */   AttributeConfiguration: () => (/* reexport safe */ _components_attributes_js__WEBPACK_IMPORTED_MODULE_4__.AttributeConfiguration),
/* harmony export */   AttributeDefinition: () => (/* reexport safe */ _components_attributes_js__WEBPACK_IMPORTED_MODULE_4__.AttributeDefinition),
/* harmony export */   BindingBehavior: () => (/* reexport safe */ _templating_binding_js__WEBPACK_IMPORTED_MODULE_15__.BindingBehavior),
/* harmony export */   CSSDirective: () => (/* reexport safe */ _styles_css_directive_js__WEBPACK_IMPORTED_MODULE_9__.CSSDirective),
/* harmony export */   ChildrenBehavior: () => (/* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_21__.ChildrenBehavior),
/* harmony export */   Controller: () => (/* reexport safe */ _components_controller_js__WEBPACK_IMPORTED_MODULE_5__.Controller),
/* harmony export */   DOM: () => (/* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_14__.DOM),
/* harmony export */   ElementStyles: () => (/* reexport safe */ _styles_element_styles_js__WEBPACK_IMPORTED_MODULE_7__.ElementStyles),
/* harmony export */   ExecutionContext: () => (/* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_11__.ExecutionContext),
/* harmony export */   FAST: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_0__.FAST),
/* harmony export */   FASTElement: () => (/* reexport safe */ _components_fast_element_js__WEBPACK_IMPORTED_MODULE_2__.FASTElement),
/* harmony export */   FASTElementDefinition: () => (/* reexport safe */ _components_fast_definitions_js__WEBPACK_IMPORTED_MODULE_3__.FASTElementDefinition),
/* harmony export */   HTMLBindingDirective: () => (/* reexport safe */ _templating_binding_js__WEBPACK_IMPORTED_MODULE_15__.HTMLBindingDirective),
/* harmony export */   HTMLDirective: () => (/* reexport safe */ _templating_html_directive_js__WEBPACK_IMPORTED_MODULE_16__.HTMLDirective),
/* harmony export */   HTMLView: () => (/* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_10__.HTMLView),
/* harmony export */   Observable: () => (/* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_11__.Observable),
/* harmony export */   PropertyChangeNotifier: () => (/* reexport safe */ _observation_notifier_js__WEBPACK_IMPORTED_MODULE_12__.PropertyChangeNotifier),
/* harmony export */   RefBehavior: () => (/* reexport safe */ _templating_ref_js__WEBPACK_IMPORTED_MODULE_17__.RefBehavior),
/* harmony export */   RepeatBehavior: () => (/* reexport safe */ _templating_repeat_js__WEBPACK_IMPORTED_MODULE_19__.RepeatBehavior),
/* harmony export */   RepeatDirective: () => (/* reexport safe */ _templating_repeat_js__WEBPACK_IMPORTED_MODULE_19__.RepeatDirective),
/* harmony export */   SlottedBehavior: () => (/* reexport safe */ _templating_slotted_js__WEBPACK_IMPORTED_MODULE_20__.SlottedBehavior),
/* harmony export */   SubscriberSet: () => (/* reexport safe */ _observation_notifier_js__WEBPACK_IMPORTED_MODULE_12__.SubscriberSet),
/* harmony export */   TargetedHTMLDirective: () => (/* reexport safe */ _templating_html_directive_js__WEBPACK_IMPORTED_MODULE_16__.TargetedHTMLDirective),
/* harmony export */   ViewTemplate: () => (/* reexport safe */ _templating_template_js__WEBPACK_IMPORTED_MODULE_1__.ViewTemplate),
/* harmony export */   attr: () => (/* reexport safe */ _components_attributes_js__WEBPACK_IMPORTED_MODULE_4__.attr),
/* harmony export */   booleanConverter: () => (/* reexport safe */ _components_attributes_js__WEBPACK_IMPORTED_MODULE_4__.booleanConverter),
/* harmony export */   children: () => (/* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_21__.children),
/* harmony export */   compileTemplate: () => (/* reexport safe */ _templating_compiler_js__WEBPACK_IMPORTED_MODULE_6__.compileTemplate),
/* harmony export */   createMetadataLocator: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_0__.createMetadataLocator),
/* harmony export */   css: () => (/* reexport safe */ _styles_css_js__WEBPACK_IMPORTED_MODULE_8__.css),
/* harmony export */   cssPartial: () => (/* reexport safe */ _styles_css_js__WEBPACK_IMPORTED_MODULE_8__.cssPartial),
/* harmony export */   customElement: () => (/* reexport safe */ _components_fast_element_js__WEBPACK_IMPORTED_MODULE_2__.customElement),
/* harmony export */   defaultExecutionContext: () => (/* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_11__.defaultExecutionContext),
/* harmony export */   elements: () => (/* reexport safe */ _templating_node_observation_js__WEBPACK_IMPORTED_MODULE_22__.elements),
/* harmony export */   emptyArray: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray),
/* harmony export */   enableArrayObservation: () => (/* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_13__.enableArrayObservation),
/* harmony export */   html: () => (/* reexport safe */ _templating_template_js__WEBPACK_IMPORTED_MODULE_1__.html),
/* harmony export */   nullableNumberConverter: () => (/* reexport safe */ _components_attributes_js__WEBPACK_IMPORTED_MODULE_4__.nullableNumberConverter),
/* harmony export */   observable: () => (/* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_11__.observable),
/* harmony export */   ref: () => (/* reexport safe */ _templating_ref_js__WEBPACK_IMPORTED_MODULE_17__.ref),
/* harmony export */   repeat: () => (/* reexport safe */ _templating_repeat_js__WEBPACK_IMPORTED_MODULE_19__.repeat),
/* harmony export */   slotted: () => (/* reexport safe */ _templating_slotted_js__WEBPACK_IMPORTED_MODULE_20__.slotted),
/* harmony export */   volatile: () => (/* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_11__.volatile),
/* harmony export */   when: () => (/* reexport safe */ _templating_when_js__WEBPACK_IMPORTED_MODULE_18__.when)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");
/* harmony import */ var _templating_template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./templating/template.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/template.js");
/* harmony import */ var _components_fast_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/fast-element.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/fast-element.js");
/* harmony import */ var _components_fast_definitions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/fast-definitions.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/fast-definitions.js");
/* harmony import */ var _components_attributes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/attributes.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/attributes.js");
/* harmony import */ var _components_controller_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/controller.js */ "./node_modules/@microsoft/fast-element/dist/esm/components/controller.js");
/* harmony import */ var _templating_compiler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./templating/compiler.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js");
/* harmony import */ var _styles_element_styles_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./styles/element-styles.js */ "./node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js");
/* harmony import */ var _styles_css_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./styles/css.js */ "./node_modules/@microsoft/fast-element/dist/esm/styles/css.js");
/* harmony import */ var _styles_css_directive_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./styles/css-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./templating/view.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/view.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _observation_notifier_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./observation/notifier.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js");
/* harmony import */ var _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./observation/array-observer.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _templating_binding_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./templating/binding.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/binding.js");
/* harmony import */ var _templating_html_directive_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./templating/html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");
/* harmony import */ var _templating_ref_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./templating/ref.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/ref.js");
/* harmony import */ var _templating_when_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./templating/when.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/when.js");
/* harmony import */ var _templating_repeat_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./templating/repeat.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js");
/* harmony import */ var _templating_slotted_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./templating/slotted.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js");
/* harmony import */ var _templating_children_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./templating/children.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/children.js");
/* harmony import */ var _templating_node_observation_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./templating/node-observation.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js");


























/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/interfaces.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/interfaces.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
/**
 * Determines whether or not an object is a function.
 * @public
 */
const isFunction = (object) => typeof object === "function";


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcSplices: () => (/* binding */ calcSplices),
/* harmony export */   newSplice: () => (/* binding */ newSplice),
/* harmony export */   projectArraySplices: () => (/* binding */ projectArraySplices)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");

/** @internal */
function newSplice(index, removed, addedCount) {
    return {
        index: index,
        removed: removed,
        addedCount: addedCount,
    };
}
const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;
// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    const rowCount = oldEnd - oldStart + 1;
    const columnCount = currentEnd - currentStart + 1;
    const distances = new Array(rowCount);
    let north;
    let west;
    // "Addition" rows. Initialize null column.
    for (let i = 0; i < rowCount; ++i) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
    }
    // Initialize null row
    for (let j = 0; j < columnCount; ++j) {
        distances[0][j] = j;
    }
    for (let i = 1; i < rowCount; ++i) {
        for (let j = 1; j < columnCount; ++j) {
            if (current[currentStart + j - 1] === old[oldStart + i - 1]) {
                distances[i][j] = distances[i - 1][j - 1];
            }
            else {
                north = distances[i - 1][j] + 1;
                west = distances[i][j - 1] + 1;
                distances[i][j] = north < west ? north : west;
            }
        }
    }
    return distances;
}
// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
    let i = distances.length - 1;
    let j = distances[0].length - 1;
    let current = distances[i][j];
    const edits = [];
    while (i > 0 || j > 0) {
        if (i === 0) {
            edits.push(EDIT_ADD);
            j--;
            continue;
        }
        if (j === 0) {
            edits.push(EDIT_DELETE);
            i--;
            continue;
        }
        const northWest = distances[i - 1][j - 1];
        const west = distances[i - 1][j];
        const north = distances[i][j - 1];
        let min;
        if (west < north) {
            min = west < northWest ? west : northWest;
        }
        else {
            min = north < northWest ? north : northWest;
        }
        if (min === northWest) {
            if (northWest === current) {
                edits.push(EDIT_LEAVE);
            }
            else {
                edits.push(EDIT_UPDATE);
                current = northWest;
            }
            i--;
            j--;
        }
        else if (min === west) {
            edits.push(EDIT_DELETE);
            i--;
            current = west;
        }
        else {
            edits.push(EDIT_ADD);
            j--;
            current = north;
        }
    }
    edits.reverse();
    return edits;
}
function sharedPrefix(current, old, searchLength) {
    for (let i = 0; i < searchLength; ++i) {
        if (current[i] !== old[i]) {
            return i;
        }
    }
    return searchLength;
}
function sharedSuffix(current, old, searchLength) {
    let index1 = current.length;
    let index2 = old.length;
    let count = 0;
    while (count < searchLength && current[--index1] === old[--index2]) {
        count++;
    }
    return count;
}
function intersect(start1, end1, start2, end2) {
    // Disjoint
    if (end1 < start2 || end2 < start1) {
        return -1;
    }
    // Adjacent
    if (end1 === start2 || end2 === start1) {
        return 0;
    }
    // Non-zero intersect, span1 first
    if (start1 < start2) {
        if (end1 < end2) {
            return end1 - start2; // Overlap
        }
        return end2 - start2; // Contained
    }
    // Non-zero intersect, span2 first
    if (end2 < end1) {
        return end2 - start1; // Overlap
    }
    return end1 - start1; // Contained
}
/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */
/**
 * @internal
 * @remarks
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 */
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    let prefixCount = 0;
    let suffixCount = 0;
    const minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart === 0 && oldStart === 0) {
        prefixCount = sharedPrefix(current, old, minLength);
    }
    if (currentEnd === current.length && oldEnd === old.length) {
        suffixCount = sharedSuffix(current, old, minLength - prefixCount);
    }
    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;
    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
        return _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    if (currentStart === currentEnd) {
        const splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd) {
            splice.removed.push(old[oldStart++]);
        }
        return [splice];
    }
    else if (oldStart === oldEnd) {
        return [newSplice(currentStart, [], currentEnd - currentStart)];
    }
    const ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
    const splices = [];
    let splice = void 0;
    let index = currentStart;
    let oldIndex = oldStart;
    for (let i = 0; i < ops.length; ++i) {
        switch (ops[i]) {
            case EDIT_LEAVE:
                if (splice !== void 0) {
                    splices.push(splice);
                    splice = void 0;
                }
                index++;
                oldIndex++;
                break;
            case EDIT_UPDATE:
                if (splice === void 0) {
                    splice = newSplice(index, [], 0);
                }
                splice.addedCount++;
                index++;
                splice.removed.push(old[oldIndex]);
                oldIndex++;
                break;
            case EDIT_ADD:
                if (splice === void 0) {
                    splice = newSplice(index, [], 0);
                }
                splice.addedCount++;
                index++;
                break;
            case EDIT_DELETE:
                if (splice === void 0) {
                    splice = newSplice(index, [], 0);
                }
                splice.removed.push(old[oldIndex]);
                oldIndex++;
                break;
            // no default
        }
    }
    if (splice !== void 0) {
        splices.push(splice);
    }
    return splices;
}
const $push = Array.prototype.push;
function mergeSplice(splices, index, removed, addedCount) {
    const splice = newSplice(index, removed, addedCount);
    let inserted = false;
    let insertionOffset = 0;
    for (let i = 0; i < splices.length; i++) {
        const current = splices[i];
        current.index += insertionOffset;
        if (inserted) {
            continue;
        }
        const intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);
        if (intersectCount >= 0) {
            // Merge the two splices
            splices.splice(i, 1);
            i--;
            insertionOffset -= current.addedCount - current.removed.length;
            splice.addedCount += current.addedCount - intersectCount;
            const deleteCount = splice.removed.length + current.removed.length - intersectCount;
            if (!splice.addedCount && !deleteCount) {
                // merged splice is a noop. discard.
                inserted = true;
            }
            else {
                let currentRemoved = current.removed;
                if (splice.index < current.index) {
                    // some prefix of splice.removed is prepended to current.removed.
                    const prepend = splice.removed.slice(0, current.index - splice.index);
                    $push.apply(prepend, currentRemoved);
                    currentRemoved = prepend;
                }
                if (splice.index + splice.removed.length >
                    current.index + current.addedCount) {
                    // some suffix of splice.removed is appended to current.removed.
                    const append = splice.removed.slice(current.index + current.addedCount - splice.index);
                    $push.apply(currentRemoved, append);
                }
                splice.removed = currentRemoved;
                if (current.index < splice.index) {
                    splice.index = current.index;
                }
            }
        }
        else if (splice.index < current.index) {
            // Insert splice here.
            inserted = true;
            splices.splice(i, 0, splice);
            i++;
            const offset = splice.addedCount - splice.removed.length;
            current.index += offset;
            insertionOffset += offset;
        }
    }
    if (!inserted) {
        splices.push(splice);
    }
}
function createInitialSplices(changeRecords) {
    const splices = [];
    for (let i = 0, ii = changeRecords.length; i < ii; i++) {
        const record = changeRecords[i];
        mergeSplice(splices, record.index, record.removed, record.addedCount);
    }
    return splices;
}
/** @internal */
function projectArraySplices(array, changeRecords) {
    let splices = [];
    const initialSplices = createInitialSplices(changeRecords);
    for (let i = 0, ii = initialSplices.length; i < ii; ++i) {
        const splice = initialSplices[i];
        if (splice.addedCount === 1 && splice.removed.length === 1) {
            if (splice.removed[0] !== array[splice.index]) {
                splices.push(splice);
            }
            continue;
        }
        splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
    }
    return splices;
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   enableArrayObservation: () => (/* binding */ enableArrayObservation)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _array_change_records_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array-change-records.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/array-change-records.js");
/* harmony import */ var _notifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./notifier.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js");
/* harmony import */ var _observable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");




let arrayObservationEnabled = false;
function adjustIndex(changeRecord, array) {
    let index = changeRecord.index;
    const arrayLength = array.length;
    if (index > arrayLength) {
        index = arrayLength - changeRecord.addedCount;
    }
    else if (index < 0) {
        index =
            arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
    }
    if (index < 0) {
        index = 0;
    }
    changeRecord.index = index;
    return changeRecord;
}
class ArrayObserver extends _notifier_js__WEBPACK_IMPORTED_MODULE_0__.SubscriberSet {
    constructor(source) {
        super(source);
        this.oldCollection = void 0;
        this.splices = void 0;
        this.needsQueue = true;
        this.call = this.flush;
        Reflect.defineProperty(source, "$fastController", {
            value: this,
            enumerable: false,
        });
    }
    subscribe(subscriber) {
        this.flush();
        super.subscribe(subscriber);
    }
    addSplice(splice) {
        if (this.splices === void 0) {
            this.splices = [splice];
        }
        else {
            this.splices.push(splice);
        }
        if (this.needsQueue) {
            this.needsQueue = false;
            _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.queueUpdate(this);
        }
    }
    reset(oldCollection) {
        this.oldCollection = oldCollection;
        if (this.needsQueue) {
            this.needsQueue = false;
            _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.queueUpdate(this);
        }
    }
    flush() {
        const splices = this.splices;
        const oldCollection = this.oldCollection;
        if (splices === void 0 && oldCollection === void 0) {
            return;
        }
        this.needsQueue = true;
        this.splices = void 0;
        this.oldCollection = void 0;
        const finalSplices = oldCollection === void 0
            ? (0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.projectArraySplices)(this.source, splices)
            : (0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.calcSplices)(this.source, 0, this.source.length, oldCollection, 0, oldCollection.length);
        this.notify(finalSplices);
    }
}
/* eslint-disable prefer-rest-params */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/**
 * Enables the array observation mechanism.
 * @remarks
 * Array observation is enabled automatically when using the
 * {@link RepeatDirective}, so calling this API manually is
 * not typically necessary.
 * @public
 */
function enableArrayObservation() {
    if (arrayObservationEnabled) {
        return;
    }
    arrayObservationEnabled = true;
    _observable_js__WEBPACK_IMPORTED_MODULE_3__.Observable.setArrayObserverFactory((collection) => {
        return new ArrayObserver(collection);
    });
    const proto = Array.prototype;
    // Don't patch Array if it has already been patched
    // by another copy of fast-element.
    if (proto.$fastPatch) {
        return;
    }
    Reflect.defineProperty(proto, "$fastPatch", {
        value: 1,
        enumerable: false,
    });
    const pop = proto.pop;
    const push = proto.push;
    const reverse = proto.reverse;
    const shift = proto.shift;
    const sort = proto.sort;
    const splice = proto.splice;
    const unshift = proto.unshift;
    proto.pop = function () {
        const notEmpty = this.length > 0;
        const methodCallResult = pop.apply(this, arguments);
        const o = this.$fastController;
        if (o !== void 0 && notEmpty) {
            o.addSplice((0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.newSplice)(this.length, [methodCallResult], 0));
        }
        return methodCallResult;
    };
    proto.push = function () {
        const methodCallResult = push.apply(this, arguments);
        const o = this.$fastController;
        if (o !== void 0) {
            o.addSplice(adjustIndex((0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.newSplice)(this.length - arguments.length, [], arguments.length), this));
        }
        return methodCallResult;
    };
    proto.reverse = function () {
        let oldArray;
        const o = this.$fastController;
        if (o !== void 0) {
            o.flush();
            oldArray = this.slice();
        }
        const methodCallResult = reverse.apply(this, arguments);
        if (o !== void 0) {
            o.reset(oldArray);
        }
        return methodCallResult;
    };
    proto.shift = function () {
        const notEmpty = this.length > 0;
        const methodCallResult = shift.apply(this, arguments);
        const o = this.$fastController;
        if (o !== void 0 && notEmpty) {
            o.addSplice((0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.newSplice)(0, [methodCallResult], 0));
        }
        return methodCallResult;
    };
    proto.sort = function () {
        let oldArray;
        const o = this.$fastController;
        if (o !== void 0) {
            o.flush();
            oldArray = this.slice();
        }
        const methodCallResult = sort.apply(this, arguments);
        if (o !== void 0) {
            o.reset(oldArray);
        }
        return methodCallResult;
    };
    proto.splice = function () {
        const methodCallResult = splice.apply(this, arguments);
        const o = this.$fastController;
        if (o !== void 0) {
            o.addSplice(adjustIndex((0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.newSplice)(+arguments[0], methodCallResult, arguments.length > 2 ? arguments.length - 2 : 0), this));
        }
        return methodCallResult;
    };
    proto.unshift = function () {
        const methodCallResult = unshift.apply(this, arguments);
        const o = this.$fastController;
        if (o !== void 0) {
            o.addSplice(adjustIndex((0,_array_change_records_js__WEBPACK_IMPORTED_MODULE_2__.newSplice)(0, [], arguments.length), this));
        }
        return methodCallResult;
    };
}
/* eslint-enable prefer-rest-params */
/* eslint-enable @typescript-eslint/explicit-function-return-type */


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PropertyChangeNotifier: () => (/* binding */ PropertyChangeNotifier),
/* harmony export */   SubscriberSet: () => (/* binding */ SubscriberSet)
/* harmony export */ });
/**
 * An implementation of {@link Notifier} that efficiently keeps track of
 * subscribers interested in a specific change notification on an
 * observable source.
 *
 * @remarks
 * This set is optimized for the most common scenario of 1 or 2 subscribers.
 * With this in mind, it can store a subscriber in an internal field, allowing it to avoid Array#push operations.
 * If the set ever exceeds two subscribers, it upgrades to an array automatically.
 * @public
 */
class SubscriberSet {
    /**
     * Creates an instance of SubscriberSet for the specified source.
     * @param source - The object source that subscribers will receive notifications from.
     * @param initialSubscriber - An initial subscriber to changes.
     */
    constructor(source, initialSubscriber) {
        this.sub1 = void 0;
        this.sub2 = void 0;
        this.spillover = void 0;
        this.source = source;
        this.sub1 = initialSubscriber;
    }
    /**
     * Checks whether the provided subscriber has been added to this set.
     * @param subscriber - The subscriber to test for inclusion in this set.
     */
    has(subscriber) {
        return this.spillover === void 0
            ? this.sub1 === subscriber || this.sub2 === subscriber
            : this.spillover.indexOf(subscriber) !== -1;
    }
    /**
     * Subscribes to notification of changes in an object's state.
     * @param subscriber - The object that is subscribing for change notification.
     */
    subscribe(subscriber) {
        const spillover = this.spillover;
        if (spillover === void 0) {
            if (this.has(subscriber)) {
                return;
            }
            if (this.sub1 === void 0) {
                this.sub1 = subscriber;
                return;
            }
            if (this.sub2 === void 0) {
                this.sub2 = subscriber;
                return;
            }
            this.spillover = [this.sub1, this.sub2, subscriber];
            this.sub1 = void 0;
            this.sub2 = void 0;
        }
        else {
            const index = spillover.indexOf(subscriber);
            if (index === -1) {
                spillover.push(subscriber);
            }
        }
    }
    /**
     * Unsubscribes from notification of changes in an object's state.
     * @param subscriber - The object that is unsubscribing from change notification.
     */
    unsubscribe(subscriber) {
        const spillover = this.spillover;
        if (spillover === void 0) {
            if (this.sub1 === subscriber) {
                this.sub1 = void 0;
            }
            else if (this.sub2 === subscriber) {
                this.sub2 = void 0;
            }
        }
        else {
            const index = spillover.indexOf(subscriber);
            if (index !== -1) {
                spillover.splice(index, 1);
            }
        }
    }
    /**
     * Notifies all subscribers.
     * @param args - Data passed along to subscribers during notification.
     */
    notify(args) {
        const spillover = this.spillover;
        const source = this.source;
        if (spillover === void 0) {
            const sub1 = this.sub1;
            const sub2 = this.sub2;
            if (sub1 !== void 0) {
                sub1.handleChange(source, args);
            }
            if (sub2 !== void 0) {
                sub2.handleChange(source, args);
            }
        }
        else {
            for (let i = 0, ii = spillover.length; i < ii; ++i) {
                spillover[i].handleChange(source, args);
            }
        }
    }
}
/**
 * An implementation of Notifier that allows subscribers to be notified
 * of individual property changes on an object.
 * @public
 */
class PropertyChangeNotifier {
    /**
     * Creates an instance of PropertyChangeNotifier for the specified source.
     * @param source - The object source that subscribers will receive notifications from.
     */
    constructor(source) {
        this.subscribers = {};
        this.sourceSubscribers = null;
        this.source = source;
    }
    /**
     * Notifies all subscribers, based on the specified property.
     * @param propertyName - The property name, passed along to subscribers during notification.
     */
    notify(propertyName) {
        var _a;
        const subscribers = this.subscribers[propertyName];
        if (subscribers !== void 0) {
            subscribers.notify(propertyName);
        }
        (_a = this.sourceSubscribers) === null || _a === void 0 ? void 0 : _a.notify(propertyName);
    }
    /**
     * Subscribes to notification of changes in an object's state.
     * @param subscriber - The object that is subscribing for change notification.
     * @param propertyToWatch - The name of the property that the subscriber is interested in watching for changes.
     */
    subscribe(subscriber, propertyToWatch) {
        var _a;
        if (propertyToWatch) {
            let subscribers = this.subscribers[propertyToWatch];
            if (subscribers === void 0) {
                this.subscribers[propertyToWatch] = subscribers = new SubscriberSet(this.source);
            }
            subscribers.subscribe(subscriber);
        }
        else {
            this.sourceSubscribers =
                (_a = this.sourceSubscribers) !== null && _a !== void 0 ? _a : new SubscriberSet(this.source);
            this.sourceSubscribers.subscribe(subscriber);
        }
    }
    /**
     * Unsubscribes from notification of changes in an object's state.
     * @param subscriber - The object that is unsubscribing from change notification.
     * @param propertyToUnwatch - The name of the property that the subscriber is no longer interested in watching.
     */
    unsubscribe(subscriber, propertyToUnwatch) {
        var _a;
        if (propertyToUnwatch) {
            const subscribers = this.subscribers[propertyToUnwatch];
            if (subscribers !== void 0) {
                subscribers.unsubscribe(subscriber);
            }
        }
        else {
            (_a = this.sourceSubscribers) === null || _a === void 0 ? void 0 : _a.unsubscribe(subscriber);
        }
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExecutionContext: () => (/* binding */ ExecutionContext),
/* harmony export */   Observable: () => (/* binding */ Observable),
/* harmony export */   defaultExecutionContext: () => (/* binding */ defaultExecutionContext),
/* harmony export */   observable: () => (/* binding */ observable),
/* harmony export */   volatile: () => (/* binding */ volatile)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");
/* harmony import */ var _notifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifier.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/notifier.js");



/**
 * Common Observable APIs.
 * @public
 */
const Observable = _platform_js__WEBPACK_IMPORTED_MODULE_0__.FAST.getById(2 /* observable */, () => {
    const volatileRegex = /(:|&&|\|\||if)/;
    const notifierLookup = new WeakMap();
    const queueUpdate = _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.queueUpdate;
    let watcher = void 0;
    let createArrayObserver = (array) => {
        throw new Error("Must call enableArrayObservation before observing arrays.");
    };
    function getNotifier(source) {
        let found = source.$fastController || notifierLookup.get(source);
        if (found === void 0) {
            if (Array.isArray(source)) {
                found = createArrayObserver(source);
            }
            else {
                notifierLookup.set(source, (found = new _notifier_js__WEBPACK_IMPORTED_MODULE_2__.PropertyChangeNotifier(source)));
            }
        }
        return found;
    }
    const getAccessors = (0,_platform_js__WEBPACK_IMPORTED_MODULE_0__.createMetadataLocator)();
    class DefaultObservableAccessor {
        constructor(name) {
            this.name = name;
            this.field = `_${name}`;
            this.callback = `${name}Changed`;
        }
        getValue(source) {
            if (watcher !== void 0) {
                watcher.watch(source, this.name);
            }
            return source[this.field];
        }
        setValue(source, newValue) {
            const field = this.field;
            const oldValue = source[field];
            if (oldValue !== newValue) {
                source[field] = newValue;
                const callback = source[this.callback];
                if (typeof callback === "function") {
                    callback.call(source, oldValue, newValue);
                }
                getNotifier(source).notify(this.name);
            }
        }
    }
    class BindingObserverImplementation extends _notifier_js__WEBPACK_IMPORTED_MODULE_2__.SubscriberSet {
        constructor(binding, initialSubscriber, isVolatileBinding = false) {
            super(binding, initialSubscriber);
            this.binding = binding;
            this.isVolatileBinding = isVolatileBinding;
            this.needsRefresh = true;
            this.needsQueue = true;
            this.first = this;
            this.last = null;
            this.propertySource = void 0;
            this.propertyName = void 0;
            this.notifier = void 0;
            this.next = void 0;
        }
        observe(source, context) {
            if (this.needsRefresh && this.last !== null) {
                this.disconnect();
            }
            const previousWatcher = watcher;
            watcher = this.needsRefresh ? this : void 0;
            this.needsRefresh = this.isVolatileBinding;
            const result = this.binding(source, context);
            watcher = previousWatcher;
            return result;
        }
        disconnect() {
            if (this.last !== null) {
                let current = this.first;
                while (current !== void 0) {
                    current.notifier.unsubscribe(this, current.propertyName);
                    current = current.next;
                }
                this.last = null;
                this.needsRefresh = this.needsQueue = true;
            }
        }
        watch(propertySource, propertyName) {
            const prev = this.last;
            const notifier = getNotifier(propertySource);
            const current = prev === null ? this.first : {};
            current.propertySource = propertySource;
            current.propertyName = propertyName;
            current.notifier = notifier;
            notifier.subscribe(this, propertyName);
            if (prev !== null) {
                if (!this.needsRefresh) {
                    // Declaring the variable prior to assignment below circumvents
                    // a bug in Angular's optimization process causing infinite recursion
                    // of this watch() method. Details https://github.com/microsoft/fast/issues/4969
                    let prevValue;
                    watcher = void 0;
                    /* eslint-disable-next-line */
                    prevValue = prev.propertySource[prev.propertyName];
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                    watcher = this;
                    if (propertySource === prevValue) {
                        this.needsRefresh = true;
                    }
                }
                prev.next = current;
            }
            this.last = current;
        }
        handleChange() {
            if (this.needsQueue) {
                this.needsQueue = false;
                queueUpdate(this);
            }
        }
        call() {
            if (this.last !== null) {
                this.needsQueue = true;
                this.notify(this);
            }
        }
        records() {
            let next = this.first;
            return {
                next: () => {
                    const current = next;
                    if (current === undefined) {
                        return { value: void 0, done: true };
                    }
                    else {
                        next = next.next;
                        return {
                            value: current,
                            done: false,
                        };
                    }
                },
                [Symbol.iterator]: function () {
                    return this;
                },
            };
        }
    }
    return Object.freeze({
        /**
         * @internal
         * @param factory - The factory used to create array observers.
         */
        setArrayObserverFactory(factory) {
            createArrayObserver = factory;
        },
        /**
         * Gets a notifier for an object or Array.
         * @param source - The object or Array to get the notifier for.
         */
        getNotifier,
        /**
         * Records a property change for a source object.
         * @param source - The object to record the change against.
         * @param propertyName - The property to track as changed.
         */
        track(source, propertyName) {
            if (watcher !== void 0) {
                watcher.watch(source, propertyName);
            }
        },
        /**
         * Notifies watchers that the currently executing property getter or function is volatile
         * with respect to its observable dependencies.
         */
        trackVolatile() {
            if (watcher !== void 0) {
                watcher.needsRefresh = true;
            }
        },
        /**
         * Notifies subscribers of a source object of changes.
         * @param source - the object to notify of changes.
         * @param args - The change args to pass to subscribers.
         */
        notify(source, args) {
            getNotifier(source).notify(args);
        },
        /**
         * Defines an observable property on an object or prototype.
         * @param target - The target object to define the observable on.
         * @param nameOrAccessor - The name of the property to define as observable;
         * or a custom accessor that specifies the property name and accessor implementation.
         */
        defineProperty(target, nameOrAccessor) {
            if (typeof nameOrAccessor === "string") {
                nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);
            }
            getAccessors(target).push(nameOrAccessor);
            Reflect.defineProperty(target, nameOrAccessor.name, {
                enumerable: true,
                get: function () {
                    return nameOrAccessor.getValue(this);
                },
                set: function (newValue) {
                    nameOrAccessor.setValue(this, newValue);
                },
            });
        },
        /**
         * Finds all the observable accessors defined on the target,
         * including its prototype chain.
         * @param target - The target object to search for accessor on.
         */
        getAccessors,
        /**
         * Creates a {@link BindingObserver} that can watch the
         * provided {@link Binding} for changes.
         * @param binding - The binding to observe.
         * @param initialSubscriber - An initial subscriber to changes in the binding value.
         * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.
         */
        binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {
            return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);
        },
        /**
         * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated
         * on every evaluation of the value.
         * @param binding - The binding to inspect.
         */
        isVolatileBinding(binding) {
            return volatileRegex.test(binding.toString());
        },
    });
});
/**
 * Decorator: Defines an observable property on the target.
 * @param target - The target to define the observable on.
 * @param nameOrAccessor - The property name or accessor to define the observable as.
 * @public
 */
function observable(target, nameOrAccessor) {
    Observable.defineProperty(target, nameOrAccessor);
}
/**
 * Decorator: Marks a property getter as having volatile observable dependencies.
 * @param target - The target that the property is defined on.
 * @param name - The property name.
 * @param name - The existing descriptor.
 * @public
 */
function volatile(target, name, descriptor) {
    return Object.assign({}, descriptor, {
        get: function () {
            Observable.trackVolatile();
            return descriptor.get.apply(this);
        },
    });
}
const contextEvent = _platform_js__WEBPACK_IMPORTED_MODULE_0__.FAST.getById(3 /* contextEvent */, () => {
    let current = null;
    return {
        get() {
            return current;
        },
        set(event) {
            current = event;
        },
    };
});
/**
 * Provides additional contextual information available to behaviors and expressions.
 * @public
 */
class ExecutionContext {
    constructor() {
        /**
         * The index of the current item within a repeat context.
         */
        this.index = 0;
        /**
         * The length of the current collection within a repeat context.
         */
        this.length = 0;
        /**
         * The parent data object within a repeat context.
         */
        this.parent = null;
        /**
         * The parent execution context when in nested context scenarios.
         */
        this.parentContext = null;
    }
    /**
     * The current event within an event handler.
     */
    get event() {
        return contextEvent.get();
    }
    /**
     * Indicates whether the current item within a repeat context
     * has an even index.
     */
    get isEven() {
        return this.index % 2 === 0;
    }
    /**
     * Indicates whether the current item within a repeat context
     * has an odd index.
     */
    get isOdd() {
        return this.index % 2 !== 0;
    }
    /**
     * Indicates whether the current item within a repeat context
     * is the first item in the collection.
     */
    get isFirst() {
        return this.index === 0;
    }
    /**
     * Indicates whether the current item within a repeat context
     * is somewhere in the middle of the collection.
     */
    get isInMiddle() {
        return !this.isFirst && !this.isLast;
    }
    /**
     * Indicates whether the current item within a repeat context
     * is the last item in the collection.
     */
    get isLast() {
        return this.index === this.length - 1;
    }
    /**
     * Sets the event for the current execution context.
     * @param event - The event to set.
     * @internal
     */
    static setEvent(event) {
        contextEvent.set(event);
    }
}
Observable.defineProperty(ExecutionContext.prototype, "index");
Observable.defineProperty(ExecutionContext.prototype, "length");
/**
 * The default execution context used in binding expressions.
 * @public
 */
const defaultExecutionContext = Object.seal(new ExecutionContext());


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/platform.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/platform.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $global: () => (/* binding */ $global),
/* harmony export */   FAST: () => (/* binding */ FAST),
/* harmony export */   createMetadataLocator: () => (/* binding */ createMetadataLocator),
/* harmony export */   emptyArray: () => (/* binding */ emptyArray)
/* harmony export */ });
/**
 * A reference to globalThis, with support
 * for browsers that don't yet support the spec.
 * @public
 */
const $global = (function () {
    if (typeof globalThis !== "undefined") {
        // We're running in a modern environment.
        return globalThis;
    }
    if (typeof __webpack_require__.g !== "undefined") {
        // We're running in NodeJS
        return __webpack_require__.g;
    }
    if (typeof self !== "undefined") {
        // We're running in a worker.
        return self;
    }
    if (typeof window !== "undefined") {
        // We're running in the browser's main thread.
        return window;
    }
    try {
        // Hopefully we never get here...
        // Not all environments allow eval and Function. Use only as a last resort:
        // eslint-disable-next-line no-new-func
        return new Function("return this")();
    }
    catch (_a) {
        // If all fails, give up and create an object.
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return {};
    }
})();
// API-only Polyfill for trustedTypes
if ($global.trustedTypes === void 0) {
    $global.trustedTypes = { createPolicy: (n, r) => r };
}
const propConfig = {
    configurable: false,
    enumerable: false,
    writable: false,
};
if ($global.FAST === void 0) {
    Reflect.defineProperty($global, "FAST", Object.assign({ value: Object.create(null) }, propConfig));
}
/**
 * The FAST global.
 * @internal
 */
const FAST = $global.FAST;
if (FAST.getById === void 0) {
    const storage = Object.create(null);
    Reflect.defineProperty(FAST, "getById", Object.assign({ value(id, initialize) {
            let found = storage[id];
            if (found === void 0) {
                found = initialize ? (storage[id] = initialize()) : null;
            }
            return found;
        } }, propConfig));
}
/**
 * A readonly, empty array.
 * @remarks
 * Typically returned by APIs that return arrays when there are
 * no actual items to return.
 * @internal
 */
const emptyArray = Object.freeze([]);
/**
 * Creates a function capable of locating metadata associated with a type.
 * @returns A metadata locator function.
 * @internal
 */
function createMetadataLocator() {
    const metadataLookup = new WeakMap();
    return function (target) {
        let metadata = metadataLookup.get(target);
        if (metadata === void 0) {
            let currentTarget = Reflect.getPrototypeOf(target);
            while (metadata === void 0 && currentTarget !== null) {
                metadata = metadataLookup.get(currentTarget);
                currentTarget = Reflect.getPrototypeOf(currentTarget);
            }
            metadata = metadata === void 0 ? [] : metadata.slice(0);
            metadataLookup.set(target, metadata);
        }
        return metadata;
    };
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSDirective: () => (/* binding */ CSSDirective)
/* harmony export */ });
/**
 * Directive for use in {@link css}.
 *
 * @public
 */
class CSSDirective {
    /**
     * Creates a CSS fragment to interpolate into the CSS document.
     * @returns - the string to interpolate into CSS
     */
    createCSS() {
        return "";
    }
    /**
     * Creates a behavior to bind to the host element.
     * @returns - the behavior to bind to the host element, or undefined.
     */
    createBehavior() {
        return undefined;
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/styles/css.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/styles/css.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   css: () => (/* binding */ css),
/* harmony export */   cssPartial: () => (/* binding */ cssPartial)
/* harmony export */ });
/* harmony import */ var _css_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/styles/css-directive.js");
/* harmony import */ var _element_styles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./element-styles.js */ "./node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js");


function collectStyles(strings, values) {
    const styles = [];
    let cssString = "";
    const behaviors = [];
    for (let i = 0, ii = strings.length - 1; i < ii; ++i) {
        cssString += strings[i];
        let value = values[i];
        if (value instanceof _css_directive_js__WEBPACK_IMPORTED_MODULE_0__.CSSDirective) {
            const behavior = value.createBehavior();
            value = value.createCSS();
            if (behavior) {
                behaviors.push(behavior);
            }
        }
        if (value instanceof _element_styles_js__WEBPACK_IMPORTED_MODULE_1__.ElementStyles || value instanceof CSSStyleSheet) {
            if (cssString.trim() !== "") {
                styles.push(cssString);
                cssString = "";
            }
            styles.push(value);
        }
        else {
            cssString += value;
        }
    }
    cssString += strings[strings.length - 1];
    if (cssString.trim() !== "") {
        styles.push(cssString);
    }
    return {
        styles,
        behaviors,
    };
}
/**
 * Transforms a template literal string into styles.
 * @param strings - The string fragments that are interpolated with the values.
 * @param values - The values that are interpolated with the string fragments.
 * @remarks
 * The css helper supports interpolation of strings and ElementStyle instances.
 * @public
 */
function css(strings, ...values) {
    const { styles, behaviors } = collectStyles(strings, values);
    const elementStyles = _element_styles_js__WEBPACK_IMPORTED_MODULE_1__.ElementStyles.create(styles);
    if (behaviors.length) {
        elementStyles.withBehaviors(...behaviors);
    }
    return elementStyles;
}
class CSSPartial extends _css_directive_js__WEBPACK_IMPORTED_MODULE_0__.CSSDirective {
    constructor(styles, behaviors) {
        super();
        this.behaviors = behaviors;
        this.css = "";
        const stylesheets = styles.reduce((accumulated, current) => {
            if (typeof current === "string") {
                this.css += current;
            }
            else {
                accumulated.push(current);
            }
            return accumulated;
        }, []);
        if (stylesheets.length) {
            this.styles = _element_styles_js__WEBPACK_IMPORTED_MODULE_1__.ElementStyles.create(stylesheets);
        }
    }
    createBehavior() {
        return this;
    }
    createCSS() {
        return this.css;
    }
    bind(el) {
        if (this.styles) {
            el.$fastController.addStyles(this.styles);
        }
        if (this.behaviors.length) {
            el.$fastController.addBehaviors(this.behaviors);
        }
    }
    unbind(el) {
        if (this.styles) {
            el.$fastController.removeStyles(this.styles);
        }
        if (this.behaviors.length) {
            el.$fastController.removeBehaviors(this.behaviors);
        }
    }
}
/**
 * Transforms a template literal string into partial CSS.
 * @param strings - The string fragments that are interpolated with the values.
 * @param values - The values that are interpolated with the string fragments.
 * @public
 */
function cssPartial(strings, ...values) {
    const { styles, behaviors } = collectStyles(strings, values);
    return new CSSPartial(styles, behaviors);
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/styles/element-styles.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdoptedStyleSheetsStyles: () => (/* binding */ AdoptedStyleSheetsStyles),
/* harmony export */   ElementStyles: () => (/* binding */ ElementStyles),
/* harmony export */   StyleElementStyles: () => (/* binding */ StyleElementStyles)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");

/**
 * Represents styles that can be applied to a custom element.
 * @public
 */
class ElementStyles {
    constructor() {
        this.targets = new WeakSet();
    }
    /** @internal */
    addStylesTo(target) {
        this.targets.add(target);
    }
    /** @internal */
    removeStylesFrom(target) {
        this.targets.delete(target);
    }
    /** @internal */
    isAttachedTo(target) {
        return this.targets.has(target);
    }
    /**
     * Associates behaviors with this set of styles.
     * @param behaviors - The behaviors to associate.
     */
    withBehaviors(...behaviors) {
        this.behaviors =
            this.behaviors === null ? behaviors : this.behaviors.concat(behaviors);
        return this;
    }
}
/**
 * Create ElementStyles from ComposableStyles.
 */
ElementStyles.create = (() => {
    if (_dom_js__WEBPACK_IMPORTED_MODULE_0__.DOM.supportsAdoptedStyleSheets) {
        const styleSheetCache = new Map();
        return (styles) => 
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        new AdoptedStyleSheetsStyles(styles, styleSheetCache);
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return (styles) => new StyleElementStyles(styles);
})();
function reduceStyles(styles) {
    return styles
        .map((x) => x instanceof ElementStyles ? reduceStyles(x.styles) : [x])
        .reduce((prev, curr) => prev.concat(curr), []);
}
function reduceBehaviors(styles) {
    return styles
        .map((x) => (x instanceof ElementStyles ? x.behaviors : null))
        .reduce((prev, curr) => {
        if (curr === null) {
            return prev;
        }
        if (prev === null) {
            prev = [];
        }
        return prev.concat(curr);
    }, null);
}
let addAdoptedStyleSheets = (target, sheets) => {
    target.adoptedStyleSheets = [...target.adoptedStyleSheets, ...sheets];
};
let removeAdoptedStyleSheets = (target, sheets) => {
    target.adoptedStyleSheets = target.adoptedStyleSheets.filter((x) => sheets.indexOf(x) === -1);
};
if (_dom_js__WEBPACK_IMPORTED_MODULE_0__.DOM.supportsAdoptedStyleSheets) {
    try {
        // Test if browser implementation uses FrozenArray.
        // If not, use push / splice to alter the stylesheets
        // in place. This circumvents a bug in Safari 16.4 where
        // periodically, assigning the array would previously
        // cause sheets to be removed.
        document.adoptedStyleSheets.push();
        document.adoptedStyleSheets.splice();
        addAdoptedStyleSheets = (target, sheets) => {
            target.adoptedStyleSheets.push(...sheets);
        };
        removeAdoptedStyleSheets = (target, sheets) => {
            for (const sheet of sheets) {
                const index = target.adoptedStyleSheets.indexOf(sheet);
                if (index !== -1) {
                    target.adoptedStyleSheets.splice(index, 1);
                }
            }
        };
    }
    catch (e) {
        // Do nothing if an error is thrown, the default
        // case handles FrozenArray.
    }
}
/**
 * https://wicg.github.io/construct-stylesheets/
 * https://developers.google.com/web/updates/2019/02/constructable-stylesheets
 *
 * @internal
 */
class AdoptedStyleSheetsStyles extends ElementStyles {
    constructor(styles, styleSheetCache) {
        super();
        this.styles = styles;
        this.styleSheetCache = styleSheetCache;
        this._styleSheets = void 0;
        this.behaviors = reduceBehaviors(styles);
    }
    get styleSheets() {
        if (this._styleSheets === void 0) {
            const styles = this.styles;
            const styleSheetCache = this.styleSheetCache;
            this._styleSheets = reduceStyles(styles).map((x) => {
                if (x instanceof CSSStyleSheet) {
                    return x;
                }
                let sheet = styleSheetCache.get(x);
                if (sheet === void 0) {
                    sheet = new CSSStyleSheet();
                    sheet.replaceSync(x);
                    styleSheetCache.set(x, sheet);
                }
                return sheet;
            });
        }
        return this._styleSheets;
    }
    addStylesTo(target) {
        addAdoptedStyleSheets(target, this.styleSheets);
        super.addStylesTo(target);
    }
    removeStylesFrom(target) {
        removeAdoptedStyleSheets(target, this.styleSheets);
        super.removeStylesFrom(target);
    }
}
let styleClassId = 0;
function getNextStyleClass() {
    return `fast-style-class-${++styleClassId}`;
}
/**
 * @internal
 */
class StyleElementStyles extends ElementStyles {
    constructor(styles) {
        super();
        this.styles = styles;
        this.behaviors = null;
        this.behaviors = reduceBehaviors(styles);
        this.styleSheets = reduceStyles(styles);
        this.styleClass = getNextStyleClass();
    }
    addStylesTo(target) {
        const styleSheets = this.styleSheets;
        const styleClass = this.styleClass;
        target = this.normalizeTarget(target);
        for (let i = 0; i < styleSheets.length; i++) {
            const element = document.createElement("style");
            element.innerHTML = styleSheets[i];
            element.className = styleClass;
            target.append(element);
        }
        super.addStylesTo(target);
    }
    removeStylesFrom(target) {
        target = this.normalizeTarget(target);
        const styles = target.querySelectorAll(`.${this.styleClass}`);
        for (let i = 0, ii = styles.length; i < ii; ++i) {
            target.removeChild(styles[i]);
        }
        super.removeStylesFrom(target);
    }
    isAttachedTo(target) {
        return super.isAttachedTo(this.normalizeTarget(target));
    }
    normalizeTarget(target) {
        return target === document ? document.body : target;
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/binding.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/binding.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingBehavior: () => (/* binding */ BindingBehavior),
/* harmony export */   HTMLBindingDirective: () => (/* binding */ HTMLBindingDirective)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _html_directive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");



function normalBind(source, context) {
    this.source = source;
    this.context = context;
    if (this.bindingObserver === null) {
        this.bindingObserver = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.binding(this.binding, this, this.isBindingVolatile);
    }
    this.updateTarget(this.bindingObserver.observe(source, context));
}
function triggerBind(source, context) {
    this.source = source;
    this.context = context;
    this.target.addEventListener(this.targetName, this);
}
function normalUnbind() {
    this.bindingObserver.disconnect();
    this.source = null;
    this.context = null;
}
function contentUnbind() {
    this.bindingObserver.disconnect();
    this.source = null;
    this.context = null;
    const view = this.target.$fastView;
    if (view !== void 0 && view.isComposed) {
        view.unbind();
        view.needsBindOnly = true;
    }
}
function triggerUnbind() {
    this.target.removeEventListener(this.targetName, this);
    this.source = null;
    this.context = null;
}
function updateAttributeTarget(value) {
    _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.setAttribute(this.target, this.targetName, value);
}
function updateBooleanAttributeTarget(value) {
    _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.setBooleanAttribute(this.target, this.targetName, value);
}
function updateContentTarget(value) {
    // If there's no actual value, then this equates to the
    // empty string for the purposes of content bindings.
    if (value === null || value === undefined) {
        value = "";
    }
    // If the value has a "create" method, then it's a template-like.
    if (value.create) {
        this.target.textContent = "";
        let view = this.target.$fastView;
        // If there's no previous view that we might be able to
        // reuse then create a new view from the template.
        if (view === void 0) {
            view = value.create();
        }
        else {
            // If there is a previous view, but it wasn't created
            // from the same template as the new value, then we
            // need to remove the old view if it's still in the DOM
            // and create a new view from the template.
            if (this.target.$fastTemplate !== value) {
                if (view.isComposed) {
                    view.remove();
                    view.unbind();
                }
                view = value.create();
            }
        }
        // It's possible that the value is the same as the previous template
        // and that there's actually no need to compose it.
        if (!view.isComposed) {
            view.isComposed = true;
            view.bind(this.source, this.context);
            view.insertBefore(this.target);
            this.target.$fastView = view;
            this.target.$fastTemplate = value;
        }
        else if (view.needsBindOnly) {
            view.needsBindOnly = false;
            view.bind(this.source, this.context);
        }
    }
    else {
        const view = this.target.$fastView;
        // If there is a view and it's currently composed into
        // the DOM, then we need to remove it.
        if (view !== void 0 && view.isComposed) {
            view.isComposed = false;
            view.remove();
            if (view.needsBindOnly) {
                view.needsBindOnly = false;
            }
            else {
                view.unbind();
            }
        }
        this.target.textContent = value;
    }
}
function updatePropertyTarget(value) {
    this.target[this.targetName] = value;
}
function updateClassTarget(value) {
    const classVersions = this.classVersions || Object.create(null);
    const target = this.target;
    let version = this.version || 0;
    // Add the classes, tracking the version at which they were added.
    if (value !== null && value !== undefined && value.length) {
        const names = value.split(/\s+/);
        for (let i = 0, ii = names.length; i < ii; ++i) {
            const currentName = names[i];
            if (currentName === "") {
                continue;
            }
            classVersions[currentName] = version;
            target.classList.add(currentName);
        }
    }
    this.classVersions = classVersions;
    this.version = version + 1;
    // If this is the first call to add classes, there's no need to remove old ones.
    if (version === 0) {
        return;
    }
    // Remove classes from the previous version.
    version -= 1;
    for (const name in classVersions) {
        if (classVersions[name] === version) {
            target.classList.remove(name);
        }
    }
}
/**
 * A directive that configures data binding to element content and attributes.
 * @public
 */
class HTMLBindingDirective extends _html_directive_js__WEBPACK_IMPORTED_MODULE_2__.TargetedHTMLDirective {
    /**
     * Creates an instance of BindingDirective.
     * @param binding - A binding that returns the data used to update the DOM.
     */
    constructor(binding) {
        super();
        this.binding = binding;
        this.bind = normalBind;
        this.unbind = normalUnbind;
        this.updateTarget = updateAttributeTarget;
        this.isBindingVolatile = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.isVolatileBinding(this.binding);
    }
    /**
     * Gets/sets the name of the attribute or property that this
     * binding is targeting.
     */
    get targetName() {
        return this.originalTargetName;
    }
    set targetName(value) {
        this.originalTargetName = value;
        if (value === void 0) {
            return;
        }
        switch (value[0]) {
            case ":":
                this.cleanedTargetName = value.substr(1);
                this.updateTarget = updatePropertyTarget;
                if (this.cleanedTargetName === "innerHTML") {
                    const binding = this.binding;
                    this.binding = (s, c) => _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.createHTML(binding(s, c));
                }
                break;
            case "?":
                this.cleanedTargetName = value.substr(1);
                this.updateTarget = updateBooleanAttributeTarget;
                break;
            case "@":
                this.cleanedTargetName = value.substr(1);
                this.bind = triggerBind;
                this.unbind = triggerUnbind;
                break;
            default:
                this.cleanedTargetName = value;
                if (value === "class") {
                    this.updateTarget = updateClassTarget;
                }
                break;
        }
    }
    /**
     * Makes this binding target the content of an element rather than
     * a particular attribute or property.
     */
    targetAtContent() {
        this.updateTarget = updateContentTarget;
        this.unbind = contentUnbind;
    }
    /**
     * Creates the runtime BindingBehavior instance based on the configuration
     * information stored in the BindingDirective.
     * @param target - The target node that the binding behavior should attach to.
     */
    createBehavior(target) {
        /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
        return new BindingBehavior(target, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);
    }
}
/**
 * A behavior that updates content and attributes based on a configured
 * BindingDirective.
 * @public
 */
class BindingBehavior {
    /**
     * Creates an instance of BindingBehavior.
     * @param target - The target of the data updates.
     * @param binding - The binding that returns the latest value for an update.
     * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.
     * @param bind - The operation to perform during binding.
     * @param unbind - The operation to perform during unbinding.
     * @param updateTarget - The operation to perform when updating.
     * @param targetName - The name of the target attribute or property to update.
     */
    constructor(target, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {
        /** @internal */
        this.source = null;
        /** @internal */
        this.context = null;
        /** @internal */
        this.bindingObserver = null;
        this.target = target;
        this.binding = binding;
        this.isBindingVolatile = isBindingVolatile;
        this.bind = bind;
        this.unbind = unbind;
        this.updateTarget = updateTarget;
        this.targetName = targetName;
    }
    /** @internal */
    handleChange() {
        this.updateTarget(this.bindingObserver.observe(this.source, this.context));
    }
    /** @internal */
    handleEvent(event) {
        _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.ExecutionContext.setEvent(event);
        const result = this.binding(this.source, this.context);
        _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.ExecutionContext.setEvent(null);
        if (result !== true) {
            event.preventDefault();
        }
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/children.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/children.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChildrenBehavior: () => (/* binding */ ChildrenBehavior),
/* harmony export */   children: () => (/* binding */ children)
/* harmony export */ });
/* harmony import */ var _html_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");
/* harmony import */ var _node_observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node-observation.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js");


/**
 * The runtime behavior for child node observation.
 * @public
 */
class ChildrenBehavior extends _node_observation_js__WEBPACK_IMPORTED_MODULE_0__.NodeObservationBehavior {
    /**
     * Creates an instance of ChildrenBehavior.
     * @param target - The element target to observe children on.
     * @param options - The options to use when observing the element children.
     */
    constructor(target, options) {
        super(target, options);
        this.observer = null;
        options.childList = true;
    }
    /**
     * Begins observation of the nodes.
     */
    observe() {
        if (this.observer === null) {
            this.observer = new MutationObserver(this.handleEvent.bind(this));
        }
        this.observer.observe(this.target, this.options);
    }
    /**
     * Disconnects observation of the nodes.
     */
    disconnect() {
        this.observer.disconnect();
    }
    /**
     * Retrieves the nodes that should be assigned to the target.
     */
    getNodes() {
        if ("subtree" in this.options) {
            return Array.from(this.target.querySelectorAll(this.options.selector));
        }
        return Array.from(this.target.childNodes);
    }
}
/**
 * A directive that observes the `childNodes` of an element and updates a property
 * whenever they change.
 * @param propertyOrOptions - The options used to configure child node observation.
 * @public
 */
function children(propertyOrOptions) {
    if (typeof propertyOrOptions === "string") {
        propertyOrOptions = {
            property: propertyOrOptions,
        };
    }
    return new _html_directive_js__WEBPACK_IMPORTED_MODULE_1__.AttachedBehaviorHTMLDirective("fast-children", ChildrenBehavior, propertyOrOptions);
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileTemplate: () => (/* binding */ compileTemplate)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _binding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/binding.js");


let sharedContext = null;
class CompilationContext {
    addFactory(factory) {
        factory.targetIndex = this.targetIndex;
        this.behaviorFactories.push(factory);
    }
    captureContentBinding(directive) {
        directive.targetAtContent();
        this.addFactory(directive);
    }
    reset() {
        this.behaviorFactories = [];
        this.targetIndex = -1;
    }
    release() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        sharedContext = this;
    }
    static borrow(directives) {
        const shareable = sharedContext || new CompilationContext();
        shareable.directives = directives;
        shareable.reset();
        sharedContext = null;
        return shareable;
    }
}
function createAggregateBinding(parts) {
    if (parts.length === 1) {
        return parts[0];
    }
    let targetName;
    const partCount = parts.length;
    const finalParts = parts.map((x) => {
        if (typeof x === "string") {
            return () => x;
        }
        targetName = x.targetName || targetName;
        return x.binding;
    });
    const binding = (scope, context) => {
        let output = "";
        for (let i = 0; i < partCount; ++i) {
            output += finalParts[i](scope, context);
        }
        return output;
    };
    const directive = new _binding_js__WEBPACK_IMPORTED_MODULE_0__.HTMLBindingDirective(binding);
    directive.targetName = targetName;
    return directive;
}
const interpolationEndLength = _dom_js__WEBPACK_IMPORTED_MODULE_1__._interpolationEnd.length;
function parseContent(context, value) {
    const valueParts = value.split(_dom_js__WEBPACK_IMPORTED_MODULE_1__._interpolationStart);
    if (valueParts.length === 1) {
        return null;
    }
    const bindingParts = [];
    for (let i = 0, ii = valueParts.length; i < ii; ++i) {
        const current = valueParts[i];
        const index = current.indexOf(_dom_js__WEBPACK_IMPORTED_MODULE_1__._interpolationEnd);
        let literal;
        if (index === -1) {
            literal = current;
        }
        else {
            const directiveIndex = parseInt(current.substring(0, index));
            bindingParts.push(context.directives[directiveIndex]);
            literal = current.substring(index + interpolationEndLength);
        }
        if (literal !== "") {
            bindingParts.push(literal);
        }
    }
    return bindingParts;
}
function compileAttributes(context, node, includeBasicValues = false) {
    const attributes = node.attributes;
    for (let i = 0, ii = attributes.length; i < ii; ++i) {
        const attr = attributes[i];
        const attrValue = attr.value;
        const parseResult = parseContent(context, attrValue);
        let result = null;
        if (parseResult === null) {
            if (includeBasicValues) {
                result = new _binding_js__WEBPACK_IMPORTED_MODULE_0__.HTMLBindingDirective(() => attrValue);
                result.targetName = attr.name;
            }
        }
        else {
            result = createAggregateBinding(parseResult);
        }
        if (result !== null) {
            node.removeAttributeNode(attr);
            i--;
            ii--;
            context.addFactory(result);
        }
    }
}
function compileContent(context, node, walker) {
    const parseResult = parseContent(context, node.textContent);
    if (parseResult !== null) {
        let lastNode = node;
        for (let i = 0, ii = parseResult.length; i < ii; ++i) {
            const currentPart = parseResult[i];
            const currentNode = i === 0
                ? node
                : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
            if (typeof currentPart === "string") {
                currentNode.textContent = currentPart;
            }
            else {
                currentNode.textContent = " ";
                context.captureContentBinding(currentPart);
            }
            lastNode = currentNode;
            context.targetIndex++;
            if (currentNode !== node) {
                walker.nextNode();
            }
        }
        context.targetIndex--;
    }
}
/**
 * Compiles a template and associated directives into a raw compilation
 * result which include a cloneable DocumentFragment and factories capable
 * of attaching runtime behavior to nodes within the fragment.
 * @param template - The template to compile.
 * @param directives - The directives referenced by the template.
 * @remarks
 * The template that is provided for compilation is altered in-place
 * and cannot be compiled again. If the original template must be preserved,
 * it is recommended that you clone the original and pass the clone to this API.
 * @public
 */
function compileTemplate(template, directives) {
    const fragment = template.content;
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1111864
    document.adoptNode(fragment);
    const context = CompilationContext.borrow(directives);
    compileAttributes(context, template, true);
    const hostBehaviorFactories = context.behaviorFactories;
    context.reset();
    const walker = _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.createTemplateWalker(fragment);
    let node;
    while ((node = walker.nextNode())) {
        context.targetIndex++;
        switch (node.nodeType) {
            case 1: // element node
                compileAttributes(context, node);
                break;
            case 3: // text node
                compileContent(context, node, walker);
                break;
            case 8: // comment
                if (_dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.isMarker(node)) {
                    context.addFactory(directives[_dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.extractDirectiveIndexFromMarker(node)]);
                }
        }
    }
    let targetOffset = 0;
    if (
    // If the first node in a fragment is a marker, that means it's an unstable first node,
    // because something like a when, repeat, etc. could add nodes before the marker.
    // To mitigate this, we insert a stable first node. However, if we insert a node,
    // that will alter the result of the TreeWalker. So, we also need to offset the target index.
    _dom_js__WEBPACK_IMPORTED_MODULE_1__.DOM.isMarker(fragment.firstChild) ||
        // Or if there is only one node and a directive, it means the template's content
        // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by
        // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.
        (fragment.childNodes.length === 1 && directives.length)) {
        fragment.insertBefore(document.createComment(""), fragment.firstChild);
        targetOffset = -1;
    }
    const viewBehaviorFactories = context.behaviorFactories;
    context.release();
    return {
        fragment,
        viewBehaviorFactories,
        hostBehaviorFactories,
        targetOffset,
    };
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttachedBehaviorHTMLDirective: () => (/* binding */ AttachedBehaviorHTMLDirective),
/* harmony export */   HTMLDirective: () => (/* binding */ HTMLDirective),
/* harmony export */   TargetedHTMLDirective: () => (/* binding */ TargetedHTMLDirective)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");

/**
 * Instructs the template engine to apply behavior to a node.
 * @public
 */
class HTMLDirective {
    constructor() {
        /**
         * The index of the DOM node to which the created behavior will apply.
         */
        this.targetIndex = 0;
    }
}
/**
 * A {@link HTMLDirective} that targets a named attribute or property on a node.
 * @public
 */
class TargetedHTMLDirective extends HTMLDirective {
    constructor() {
        super(...arguments);
        /**
         * Creates a placeholder string based on the directive's index within the template.
         * @param index - The index of the directive within the template.
         */
        this.createPlaceholder = _dom_js__WEBPACK_IMPORTED_MODULE_0__.DOM.createInterpolationPlaceholder;
    }
}
/**
 * A directive that attaches special behavior to an element via a custom attribute.
 * @public
 */
class AttachedBehaviorHTMLDirective extends HTMLDirective {
    /**
     *
     * @param name - The name of the behavior; used as a custom attribute on the element.
     * @param behavior - The behavior to instantiate and attach to the element.
     * @param options - Options to pass to the behavior during creation.
     */
    constructor(name, behavior, options) {
        super();
        this.name = name;
        this.behavior = behavior;
        this.options = options;
    }
    /**
     * Creates a placeholder string based on the directive's index within the template.
     * @param index - The index of the directive within the template.
     * @remarks
     * Creates a custom attribute placeholder.
     */
    createPlaceholder(index) {
        return _dom_js__WEBPACK_IMPORTED_MODULE_0__.DOM.createCustomAttributePlaceholder(this.name, index);
    }
    /**
     * Creates a behavior for the provided target node.
     * @param target - The node instance to create the behavior for.
     * @remarks
     * Creates an instance of the `behavior` type this directive was constructed with
     * and passes the target and options to that `behavior`'s constructor.
     */
    createBehavior(target) {
        return new this.behavior(target, this.options);
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeObservationBehavior: () => (/* binding */ NodeObservationBehavior),
/* harmony export */   elements: () => (/* binding */ elements)
/* harmony export */ });
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");


/**
 * Creates a function that can be used to filter a Node array, selecting only elements.
 * @param selector - An optional selector to restrict the filter to.
 * @public
 */
function elements(selector) {
    if (selector) {
        return function (value, index, array) {
            return value.nodeType === 1 && value.matches(selector);
        };
    }
    return function (value, index, array) {
        return value.nodeType === 1;
    };
}
/**
 * A base class for node observation.
 * @internal
 */
class NodeObservationBehavior {
    /**
     * Creates an instance of NodeObservationBehavior.
     * @param target - The target to assign the nodes property on.
     * @param options - The options to use in configuring node observation.
     */
    constructor(target, options) {
        this.target = target;
        this.options = options;
        this.source = null;
    }
    /**
     * Bind this behavior to the source.
     * @param source - The source to bind to.
     * @param context - The execution context that the binding is operating within.
     */
    bind(source) {
        const name = this.options.property;
        this.shouldUpdate = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.getAccessors(source).some((x) => x.name === name);
        this.source = source;
        this.updateTarget(this.computeNodes());
        if (this.shouldUpdate) {
            this.observe();
        }
    }
    /**
     * Unbinds this behavior from the source.
     * @param source - The source to unbind from.
     */
    unbind() {
        this.updateTarget(_platform_js__WEBPACK_IMPORTED_MODULE_1__.emptyArray);
        this.source = null;
        if (this.shouldUpdate) {
            this.disconnect();
        }
    }
    /** @internal */
    handleEvent() {
        this.updateTarget(this.computeNodes());
    }
    computeNodes() {
        let nodes = this.getNodes();
        if (this.options.filter !== void 0) {
            nodes = nodes.filter(this.options.filter);
        }
        return nodes;
    }
    updateTarget(value) {
        this.source[this.options.property] = value;
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/ref.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/ref.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RefBehavior: () => (/* binding */ RefBehavior),
/* harmony export */   ref: () => (/* binding */ ref)
/* harmony export */ });
/* harmony import */ var _html_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");

/**
 * The runtime behavior for template references.
 * @public
 */
class RefBehavior {
    /**
     * Creates an instance of RefBehavior.
     * @param target - The element to reference.
     * @param propertyName - The name of the property to assign the reference to.
     */
    constructor(target, propertyName) {
        this.target = target;
        this.propertyName = propertyName;
    }
    /**
     * Bind this behavior to the source.
     * @param source - The source to bind to.
     * @param context - The execution context that the binding is operating within.
     */
    bind(source) {
        source[this.propertyName] = this.target;
    }
    /**
     * Unbinds this behavior from the source.
     * @param source - The source to unbind from.
     */
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    unbind() { }
}
/**
 * A directive that observes the updates a property with a reference to the element.
 * @param propertyName - The name of the property to assign the reference to.
 * @public
 */
function ref(propertyName) {
    return new _html_directive_js__WEBPACK_IMPORTED_MODULE_0__.AttachedBehaviorHTMLDirective("fast-ref", RefBehavior, propertyName);
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/repeat.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RepeatBehavior: () => (/* binding */ RepeatBehavior),
/* harmony export */   RepeatDirective: () => (/* binding */ RepeatDirective),
/* harmony export */   repeat: () => (/* binding */ repeat)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../observation/array-observer.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/array-observer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@microsoft/fast-element/dist/esm/platform.js");
/* harmony import */ var _html_directive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");
/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/view.js");






const defaultRepeatOptions = Object.freeze({
    positioning: false,
    recycle: true,
});
function bindWithoutPositioning(view, items, index, context) {
    view.bind(items[index], context);
}
function bindWithPositioning(view, items, index, context) {
    const childContext = Object.create(context);
    childContext.index = index;
    childContext.length = items.length;
    view.bind(items[index], childContext);
}
/**
 * A behavior that renders a template for each item in an array.
 * @public
 */
class RepeatBehavior {
    /**
     * Creates an instance of RepeatBehavior.
     * @param location - The location in the DOM to render the repeat.
     * @param itemsBinding - The array to render.
     * @param isItemsBindingVolatile - Indicates whether the items binding has volatile dependencies.
     * @param templateBinding - The template to render for each item.
     * @param isTemplateBindingVolatile - Indicates whether the template binding has volatile dependencies.
     * @param options - Options used to turn on special repeat features.
     */
    constructor(location, itemsBinding, isItemsBindingVolatile, templateBinding, isTemplateBindingVolatile, options) {
        this.location = location;
        this.itemsBinding = itemsBinding;
        this.templateBinding = templateBinding;
        this.options = options;
        this.source = null;
        this.views = [];
        this.items = null;
        this.itemsObserver = null;
        this.originalContext = void 0;
        this.childContext = void 0;
        this.bindView = bindWithoutPositioning;
        this.itemsBindingObserver = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.binding(itemsBinding, this, isItemsBindingVolatile);
        this.templateBindingObserver = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.binding(templateBinding, this, isTemplateBindingVolatile);
        if (options.positioning) {
            this.bindView = bindWithPositioning;
        }
    }
    /**
     * Bind this behavior to the source.
     * @param source - The source to bind to.
     * @param context - The execution context that the binding is operating within.
     */
    bind(source, context) {
        this.source = source;
        this.originalContext = context;
        this.childContext = Object.create(context);
        this.childContext.parent = source;
        this.childContext.parentContext = this.originalContext;
        this.items = this.itemsBindingObserver.observe(source, this.originalContext);
        this.template = this.templateBindingObserver.observe(source, this.originalContext);
        this.observeItems(true);
        this.refreshAllViews();
    }
    /**
     * Unbinds this behavior from the source.
     * @param source - The source to unbind from.
     */
    unbind() {
        this.source = null;
        this.items = null;
        if (this.itemsObserver !== null) {
            this.itemsObserver.unsubscribe(this);
        }
        this.unbindAllViews();
        this.itemsBindingObserver.disconnect();
        this.templateBindingObserver.disconnect();
    }
    /** @internal */
    handleChange(source, args) {
        if (source === this.itemsBinding) {
            this.items = this.itemsBindingObserver.observe(this.source, this.originalContext);
            this.observeItems();
            this.refreshAllViews();
        }
        else if (source === this.templateBinding) {
            this.template = this.templateBindingObserver.observe(this.source, this.originalContext);
            this.refreshAllViews(true);
        }
        else {
            this.updateViews(args);
        }
    }
    observeItems(force = false) {
        if (!this.items) {
            this.items = _platform_js__WEBPACK_IMPORTED_MODULE_1__.emptyArray;
            return;
        }
        const oldObserver = this.itemsObserver;
        const newObserver = (this.itemsObserver = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.getNotifier(this.items));
        const hasNewObserver = oldObserver !== newObserver;
        if (hasNewObserver && oldObserver !== null) {
            oldObserver.unsubscribe(this);
        }
        if (hasNewObserver || force) {
            newObserver.subscribe(this);
        }
    }
    updateViews(splices) {
        const childContext = this.childContext;
        const views = this.views;
        const bindView = this.bindView;
        const items = this.items;
        const template = this.template;
        const recycle = this.options.recycle;
        const leftoverViews = [];
        let leftoverIndex = 0;
        let availableViews = 0;
        for (let i = 0, ii = splices.length; i < ii; ++i) {
            const splice = splices[i];
            const removed = splice.removed;
            let removeIndex = 0;
            let addIndex = splice.index;
            const end = addIndex + splice.addedCount;
            const removedViews = views.splice(splice.index, removed.length);
            const totalAvailableViews = (availableViews =
                leftoverViews.length + removedViews.length);
            for (; addIndex < end; ++addIndex) {
                const neighbor = views[addIndex];
                const location = neighbor ? neighbor.firstChild : this.location;
                let view;
                if (recycle && availableViews > 0) {
                    if (removeIndex <= totalAvailableViews && removedViews.length > 0) {
                        view = removedViews[removeIndex];
                        removeIndex++;
                    }
                    else {
                        view = leftoverViews[leftoverIndex];
                        leftoverIndex++;
                    }
                    availableViews--;
                }
                else {
                    view = template.create();
                }
                views.splice(addIndex, 0, view);
                bindView(view, items, addIndex, childContext);
                view.insertBefore(location);
            }
            if (removedViews[removeIndex]) {
                leftoverViews.push(...removedViews.slice(removeIndex));
            }
        }
        for (let i = leftoverIndex, ii = leftoverViews.length; i < ii; ++i) {
            leftoverViews[i].dispose();
        }
        if (this.options.positioning) {
            for (let i = 0, ii = views.length; i < ii; ++i) {
                const currentContext = views[i].context;
                currentContext.length = ii;
                currentContext.index = i;
            }
        }
    }
    refreshAllViews(templateChanged = false) {
        const items = this.items;
        const childContext = this.childContext;
        const template = this.template;
        const location = this.location;
        const bindView = this.bindView;
        let itemsLength = items.length;
        let views = this.views;
        let viewsLength = views.length;
        if (itemsLength === 0 || templateChanged || !this.options.recycle) {
            // all views need to be removed
            _view_js__WEBPACK_IMPORTED_MODULE_2__.HTMLView.disposeContiguousBatch(views);
            viewsLength = 0;
        }
        if (viewsLength === 0) {
            // all views need to be created
            this.views = views = new Array(itemsLength);
            for (let i = 0; i < itemsLength; ++i) {
                const view = template.create();
                bindView(view, items, i, childContext);
                views[i] = view;
                view.insertBefore(location);
            }
        }
        else {
            // attempt to reuse existing views with new data
            let i = 0;
            for (; i < itemsLength; ++i) {
                if (i < viewsLength) {
                    const view = views[i];
                    bindView(view, items, i, childContext);
                }
                else {
                    const view = template.create();
                    bindView(view, items, i, childContext);
                    views.push(view);
                    view.insertBefore(location);
                }
            }
            const removed = views.splice(i, viewsLength - i);
            for (i = 0, itemsLength = removed.length; i < itemsLength; ++i) {
                removed[i].dispose();
            }
        }
    }
    unbindAllViews() {
        const views = this.views;
        for (let i = 0, ii = views.length; i < ii; ++i) {
            views[i].unbind();
        }
    }
}
/**
 * A directive that configures list rendering.
 * @public
 */
class RepeatDirective extends _html_directive_js__WEBPACK_IMPORTED_MODULE_3__.HTMLDirective {
    /**
     * Creates an instance of RepeatDirective.
     * @param itemsBinding - The binding that provides the array to render.
     * @param templateBinding - The template binding used to obtain a template to render for each item in the array.
     * @param options - Options used to turn on special repeat features.
     */
    constructor(itemsBinding, templateBinding, options) {
        super();
        this.itemsBinding = itemsBinding;
        this.templateBinding = templateBinding;
        this.options = options;
        /**
         * Creates a placeholder string based on the directive's index within the template.
         * @param index - The index of the directive within the template.
         */
        this.createPlaceholder = _dom_js__WEBPACK_IMPORTED_MODULE_4__.DOM.createBlockPlaceholder;
        (0,_observation_array_observer_js__WEBPACK_IMPORTED_MODULE_5__.enableArrayObservation)();
        this.isItemsBindingVolatile = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.isVolatileBinding(itemsBinding);
        this.isTemplateBindingVolatile = _observation_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable.isVolatileBinding(templateBinding);
    }
    /**
     * Creates a behavior for the provided target node.
     * @param target - The node instance to create the behavior for.
     */
    createBehavior(target) {
        return new RepeatBehavior(target, this.itemsBinding, this.isItemsBindingVolatile, this.templateBinding, this.isTemplateBindingVolatile, this.options);
    }
}
/**
 * A directive that enables list rendering.
 * @param itemsBinding - The array to render.
 * @param templateOrTemplateBinding - The template or a template binding used obtain a template
 * to render for each item in the array.
 * @param options - Options used to turn on special repeat features.
 * @public
 */
function repeat(itemsBinding, templateOrTemplateBinding, options = defaultRepeatOptions) {
    const templateBinding = typeof templateOrTemplateBinding === "function"
        ? templateOrTemplateBinding
        : () => templateOrTemplateBinding;
    return new RepeatDirective(itemsBinding, templateBinding, Object.assign(Object.assign({}, defaultRepeatOptions), options));
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/slotted.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SlottedBehavior: () => (/* binding */ SlottedBehavior),
/* harmony export */   slotted: () => (/* binding */ slotted)
/* harmony export */ });
/* harmony import */ var _html_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");
/* harmony import */ var _node_observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node-observation.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/node-observation.js");


/**
 * The runtime behavior for slotted node observation.
 * @public
 */
class SlottedBehavior extends _node_observation_js__WEBPACK_IMPORTED_MODULE_0__.NodeObservationBehavior {
    /**
     * Creates an instance of SlottedBehavior.
     * @param target - The slot element target to observe.
     * @param options - The options to use when observing the slot.
     */
    constructor(target, options) {
        super(target, options);
    }
    /**
     * Begins observation of the nodes.
     */
    observe() {
        this.target.addEventListener("slotchange", this);
    }
    /**
     * Disconnects observation of the nodes.
     */
    disconnect() {
        this.target.removeEventListener("slotchange", this);
    }
    /**
     * Retrieves the nodes that should be assigned to the target.
     */
    getNodes() {
        return this.target.assignedNodes(this.options);
    }
}
/**
 * A directive that observes the `assignedNodes()` of a slot and updates a property
 * whenever they change.
 * @param propertyOrOptions - The options used to configure slotted node observation.
 * @public
 */
function slotted(propertyOrOptions) {
    if (typeof propertyOrOptions === "string") {
        propertyOrOptions = { property: propertyOrOptions };
    }
    return new _html_directive_js__WEBPACK_IMPORTED_MODULE_1__.AttachedBehaviorHTMLDirective("fast-slotted", SlottedBehavior, propertyOrOptions);
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/template.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/template.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViewTemplate: () => (/* binding */ ViewTemplate),
/* harmony export */   html: () => (/* binding */ html)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@microsoft/fast-element/dist/esm/dom.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observation/observable.js */ "./node_modules/@microsoft/fast-element/dist/esm/observation/observable.js");
/* harmony import */ var _compiler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/compiler.js");
/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/view.js");
/* harmony import */ var _html_directive_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./html-directive.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/html-directive.js");
/* harmony import */ var _binding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binding.js */ "./node_modules/@microsoft/fast-element/dist/esm/templating/binding.js");






/**
 * A template capable of creating HTMLView instances or rendering directly to DOM.
 * @public
 */
/* eslint-disable-next-line @typescript-eslint/no-unused-vars */
class ViewTemplate {
    /**
     * Creates an instance of ViewTemplate.
     * @param html - The html representing what this template will instantiate, including placeholders for directives.
     * @param directives - The directives that will be connected to placeholders in the html.
     */
    constructor(html, directives) {
        this.behaviorCount = 0;
        this.hasHostBehaviors = false;
        this.fragment = null;
        this.targetOffset = 0;
        this.viewBehaviorFactories = null;
        this.hostBehaviorFactories = null;
        this.html = html;
        this.directives = directives;
    }
    /**
     * Creates an HTMLView instance based on this template definition.
     * @param hostBindingTarget - The element that host behaviors will be bound to.
     */
    create(hostBindingTarget) {
        if (this.fragment === null) {
            let template;
            const html = this.html;
            if (typeof html === "string") {
                template = document.createElement("template");
                template.innerHTML = _dom_js__WEBPACK_IMPORTED_MODULE_0__.DOM.createHTML(html);
                const fec = template.content.firstElementChild;
                if (fec !== null && fec.tagName === "TEMPLATE") {
                    template = fec;
                }
            }
            else {
                template = html;
            }
            const result = (0,_compiler_js__WEBPACK_IMPORTED_MODULE_1__.compileTemplate)(template, this.directives);
            this.fragment = result.fragment;
            this.viewBehaviorFactories = result.viewBehaviorFactories;
            this.hostBehaviorFactories = result.hostBehaviorFactories;
            this.targetOffset = result.targetOffset;
            this.behaviorCount =
                this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;
            this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;
        }
        const fragment = this.fragment.cloneNode(true);
        const viewFactories = this.viewBehaviorFactories;
        const behaviors = new Array(this.behaviorCount);
        const walker = _dom_js__WEBPACK_IMPORTED_MODULE_0__.DOM.createTemplateWalker(fragment);
        let behaviorIndex = 0;
        let targetIndex = this.targetOffset;
        let node = walker.nextNode();
        for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {
            const factory = viewFactories[behaviorIndex];
            const factoryIndex = factory.targetIndex;
            while (node !== null) {
                if (targetIndex === factoryIndex) {
                    behaviors[behaviorIndex] = factory.createBehavior(node);
                    break;
                }
                else {
                    node = walker.nextNode();
                    targetIndex++;
                }
            }
        }
        if (this.hasHostBehaviors) {
            const hostFactories = this.hostBehaviorFactories;
            for (let i = 0, ii = hostFactories.length; i < ii; ++i, ++behaviorIndex) {
                behaviors[behaviorIndex] = hostFactories[i].createBehavior(hostBindingTarget);
            }
        }
        return new _view_js__WEBPACK_IMPORTED_MODULE_2__.HTMLView(fragment, behaviors);
    }
    /**
     * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.
     * @param source - The data source to bind the template to.
     * @param host - The Element where the template will be rendered.
     * @param hostBindingTarget - An HTML element to target the host bindings at if different from the
     * host that the template is being attached to.
     */
    render(source, host, hostBindingTarget) {
        if (typeof host === "string") {
            host = document.getElementById(host);
        }
        if (hostBindingTarget === void 0) {
            hostBindingTarget = host;
        }
        const view = this.create(hostBindingTarget);
        view.bind(source, _observation_observable_js__WEBPACK_IMPORTED_MODULE_3__.defaultExecutionContext);
        view.appendTo(host);
        return view;
    }
}
// Much thanks to LitHTML for working this out!
const lastAttributeNameRegex = 
/* eslint-disable-next-line no-control-regex */
/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
/**
 * Transforms a template literal string into a renderable ViewTemplate.
 * @param strings - The string fragments that are interpolated with the values.
 * @param values - The values that are interpolated with the string fragments.
 * @remarks
 * The html helper supports interpolation of strings, numbers, binding expressions,
 * other template instances, and Directive instances.
 * @public
 */
function html(strings, ...values) {
    const directives = [];
    let html = "";
    for (let i = 0, ii = strings.length - 1; i < ii; ++i) {
        const currentString = strings[i];
        let value = values[i];
        html += currentString;
        if (value instanceof ViewTemplate) {
            const template = value;
            value = () => template;
        }
        if (typeof value === "function") {
            value = new _binding_js__WEBPACK_IMPORTED_MODULE_4__.HTMLBindingDirective(value);
        }
        if (value instanceof _html_directive_js__WEBPACK_IMPORTED_MODULE_5__.TargetedHTMLDirective) {
            const match = lastAttributeNameRegex.exec(currentString);
            if (match !== null) {
                value.targetName = match[2];
            }
        }
        if (value instanceof _html_directive_js__WEBPACK_IMPORTED_MODULE_5__.HTMLDirective) {
            // Since not all values are directives, we can't use i
            // as the index for the placeholder. Instead, we need to
            // use directives.length to get the next index.
            html += value.createPlaceholder(directives.length);
            directives.push(value);
        }
        else {
            html += value;
        }
    }
    html += strings[strings.length - 1];
    return new ViewTemplate(html, directives);
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/view.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/view.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTMLView: () => (/* binding */ HTMLView)
/* harmony export */ });
// A singleton Range instance used to efficiently remove ranges of DOM nodes.
// See the implementation of HTMLView below for further details.
const range = document.createRange();
/**
 * The standard View implementation, which also implements ElementView and SyntheticView.
 * @public
 */
class HTMLView {
    /**
     * Constructs an instance of HTMLView.
     * @param fragment - The html fragment that contains the nodes for this view.
     * @param behaviors - The behaviors to be applied to this view.
     */
    constructor(fragment, behaviors) {
        this.fragment = fragment;
        this.behaviors = behaviors;
        /**
         * The data that the view is bound to.
         */
        this.source = null;
        /**
         * The execution context the view is running within.
         */
        this.context = null;
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
    }
    /**
     * Appends the view's DOM nodes to the referenced node.
     * @param node - The parent node to append the view's DOM nodes to.
     */
    appendTo(node) {
        node.appendChild(this.fragment);
    }
    /**
     * Inserts the view's DOM nodes before the referenced node.
     * @param node - The node to insert the view's DOM before.
     */
    insertBefore(node) {
        if (this.fragment.hasChildNodes()) {
            node.parentNode.insertBefore(this.fragment, node);
        }
        else {
            const end = this.lastChild;
            if (node.previousSibling === end)
                return;
            const parentNode = node.parentNode;
            let current = this.firstChild;
            let next;
            while (current !== end) {
                next = current.nextSibling;
                parentNode.insertBefore(current, node);
                current = next;
            }
            parentNode.insertBefore(end, node);
        }
    }
    /**
     * Removes the view's DOM nodes.
     * The nodes are not disposed and the view can later be re-inserted.
     */
    remove() {
        const fragment = this.fragment;
        const end = this.lastChild;
        let current = this.firstChild;
        let next;
        while (current !== end) {
            next = current.nextSibling;
            fragment.appendChild(current);
            current = next;
        }
        fragment.appendChild(end);
    }
    /**
     * Removes the view and unbinds its behaviors, disposing of DOM nodes afterward.
     * Once a view has been disposed, it cannot be inserted or bound again.
     */
    dispose() {
        const parent = this.firstChild.parentNode;
        const end = this.lastChild;
        let current = this.firstChild;
        let next;
        while (current !== end) {
            next = current.nextSibling;
            parent.removeChild(current);
            current = next;
        }
        parent.removeChild(end);
        const behaviors = this.behaviors;
        const oldSource = this.source;
        for (let i = 0, ii = behaviors.length; i < ii; ++i) {
            behaviors[i].unbind(oldSource);
        }
    }
    /**
     * Binds a view's behaviors to its binding source.
     * @param source - The binding source for the view's binding behaviors.
     * @param context - The execution context to run the behaviors within.
     */
    bind(source, context) {
        const behaviors = this.behaviors;
        if (this.source === source) {
            return;
        }
        else if (this.source !== null) {
            const oldSource = this.source;
            this.source = source;
            this.context = context;
            for (let i = 0, ii = behaviors.length; i < ii; ++i) {
                const current = behaviors[i];
                current.unbind(oldSource);
                current.bind(source, context);
            }
        }
        else {
            this.source = source;
            this.context = context;
            for (let i = 0, ii = behaviors.length; i < ii; ++i) {
                behaviors[i].bind(source, context);
            }
        }
    }
    /**
     * Unbinds a view's behaviors from its binding source.
     */
    unbind() {
        if (this.source === null) {
            return;
        }
        const behaviors = this.behaviors;
        const oldSource = this.source;
        for (let i = 0, ii = behaviors.length; i < ii; ++i) {
            behaviors[i].unbind(oldSource);
        }
        this.source = null;
    }
    /**
     * Efficiently disposes of a contiguous range of synthetic view instances.
     * @param views - A contiguous range of views to be disposed.
     */
    static disposeContiguousBatch(views) {
        if (views.length === 0) {
            return;
        }
        range.setStartBefore(views[0].firstChild);
        range.setEndAfter(views[views.length - 1].lastChild);
        range.deleteContents();
        for (let i = 0, ii = views.length; i < ii; ++i) {
            const view = views[i];
            const behaviors = view.behaviors;
            const oldSource = view.source;
            for (let j = 0, jj = behaviors.length; j < jj; ++j) {
                behaviors[j].unbind(oldSource);
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@microsoft/fast-element/dist/esm/templating/when.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@microsoft/fast-element/dist/esm/templating/when.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   when: () => (/* binding */ when)
/* harmony export */ });
/* harmony import */ var _interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interfaces.js */ "./node_modules/@microsoft/fast-element/dist/esm/interfaces.js");

const noTemplate = () => null;
function normalizeBinding(value) {
    return value === undefined ? noTemplate : (0,_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value) ? value : () => value;
}
/**
 * A directive that enables basic conditional rendering in a template.
 * @param binding - The condition to test for rendering.
 * @param templateOrTemplateBinding - The template or a binding that gets
 * the template to render when the condition is true.
 * @param elseTemplateOrTemplateBinding - Optional template or binding that that
 * gets the template to render when the conditional is false.
 * @public
 */
function when(binding, templateOrTemplateBinding, elseTemplateOrTemplateBinding) {
    const dataBinding = (0,_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(binding) ? binding : () => binding;
    const templateBinding = normalizeBinding(templateOrTemplateBinding);
    const elseBinding = normalizeBinding(elseTemplateOrTemplateBinding);
    return (source, context) => dataBinding(source, context)
        ? templateBinding(source, context)
        : elseBinding(source, context);
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWljcm9zb2Z0X2Zhc3QtZWxlbWVudF9kaXN0X2VzbV9pbmRleF9qcy4zYWJjZjgyMDM0YTk4MTk3ZGViOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMxQjtBQUN1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBcUI7QUFDakMsQ0FBQztBQUNEO0FBQ0EsTUFBTSxzQkFBc0I7QUFDNUI7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNLHNCQUFzQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0VBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLG9DQUFvQyxtRUFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtRUFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoTEE7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVKOEM7QUFDOUM7QUFDQTtBQUNBLDhDQUE4QywwREFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCLDBEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS9jb21wb25lbnRzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvZmFzdC1lbGVtZW50L2Rpc3QvZXNtL2NvbXBvbmVudHMvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vY29tcG9uZW50cy9mYXN0LWRlZmluaXRpb25zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS9jb21wb25lbnRzL2Zhc3QtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vZG9tLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vaW50ZXJmYWNlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vb2JzZXJ2YXRpb24vYXJyYXktY2hhbmdlLXJlY29yZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvZmFzdC1lbGVtZW50L2Rpc3QvZXNtL29ic2VydmF0aW9uL2FycmF5LW9ic2VydmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS9vYnNlcnZhdGlvbi9ub3RpZmllci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vb2JzZXJ2YXRpb24vb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvZmFzdC1lbGVtZW50L2Rpc3QvZXNtL3N0eWxlcy9jc3MtZGlyZWN0aXZlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS9zdHlsZXMvY3NzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS9zdHlsZXMvZWxlbWVudC1zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvZmFzdC1lbGVtZW50L2Rpc3QvZXNtL3RlbXBsYXRpbmcvYmluZGluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy9jaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy9jb21waWxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy9odG1sLWRpcmVjdGl2ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy9ub2RlLW9ic2VydmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS90ZW1wbGF0aW5nL3JlZi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvZmFzdC1lbGVtZW50L2Rpc3QvZXNtL3RlbXBsYXRpbmcvc2xvdHRlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9mYXN0LWVsZW1lbnQvZGlzdC9lc20vdGVtcGxhdGluZy92aWV3LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2Zhc3QtZWxlbWVudC9kaXN0L2VzbS90ZW1wbGF0aW5nL3doZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9vYnNlcnZhdGlvbi9vYnNlcnZhYmxlLmpzXCI7XG5pbXBvcnQgeyBET00gfSBmcm9tIFwiLi4vZG9tLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVNZXRhZGF0YUxvY2F0b3IgfSBmcm9tIFwiLi4vcGxhdGZvcm0uanNcIjtcbi8qKlxuICogTWV0YWRhdGEgdXNlZCB0byBjb25maWd1cmUgYSBjdXN0b20gYXR0cmlidXRlJ3MgYmVoYXZpb3IuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBBdHRyaWJ1dGVDb25maWd1cmF0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogTG9jYXRlcyBhbGwgYXR0cmlidXRlIGNvbmZpZ3VyYXRpb25zIGFzc29jaWF0ZWQgd2l0aCBhIHR5cGUuXG4gICAgICovXG4gICAgbG9jYXRlOiBjcmVhdGVNZXRhZGF0YUxvY2F0b3IoKSxcbn0pO1xuLyoqXG4gKiBBIHtAbGluayBWYWx1ZUNvbnZlcnRlcn0gdGhhdCBjb252ZXJ0cyB0byBhbmQgZnJvbSBgYm9vbGVhbmAgdmFsdWVzLlxuICogQHJlbWFya3NcbiAqIFVzZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBgYm9vbGVhbmAge0BsaW5rIEF0dHJpYnV0ZU1vZGV9IGlzIHNlbGVjdGVkLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbkNvbnZlcnRlciA9IHtcbiAgICB0b1ZpZXcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgfSxcbiAgICBmcm9tVmlldyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSB2b2lkIDAgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSBcImZhbHNlXCIgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbi8qKlxuICogQSB7QGxpbmsgVmFsdWVDb252ZXJ0ZXJ9IHRoYXQgY29udmVydHMgdG8gYW5kIGZyb20gYG51bWJlcmAgdmFsdWVzLlxuICogQHJlbWFya3NcbiAqIFRoaXMgY29udmVydGVyIGFsbG93cyBmb3IgbnVsbGFibGUgbnVtYmVycywgcmV0dXJuaW5nIGBudWxsYCBpZiB0aGVcbiAqIGlucHV0IHdhcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvciBgTmFOYC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG51bGxhYmxlTnVtYmVyQ29udmVydGVyID0ge1xuICAgIHRvVmlldyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtYmVyID0gdmFsdWUgKiAxO1xuICAgICAgICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IG51bGwgOiBudW1iZXIudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGZyb21WaWV3KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1iZXIgPSB2YWx1ZSAqIDE7XG4gICAgICAgIHJldHVybiBpc05hTihudW1iZXIpID8gbnVsbCA6IG51bWJlcjtcbiAgICB9LFxufTtcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEFjY2Vzc29yfSB0aGF0IHN1cHBvcnRzIHJlYWN0aXZpdHksXG4gKiBjaGFuZ2UgY2FsbGJhY2tzLCBhdHRyaWJ1dGUgcmVmbGVjdGlvbiwgYW5kIHR5cGUgY29udmVyc2lvbiBmb3JcbiAqIGN1c3RvbSBlbGVtZW50cy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZURlZmluaXRpb24ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQXR0cmlidXRlRGVmaW5pdGlvbi5cbiAgICAgKiBAcGFyYW0gT3duZXIgLSBUaGUgY2xhc3MgY29uc3RydWN0b3IgdGhhdCBvd25zIHRoaXMgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIEhUTUwuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUge0BsaW5rIEF0dHJpYnV0ZU1vZGV9IHRoYXQgZGVzY3JpYmVzIHRoZSBiZWhhdmlvciBvZiB0aGlzIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gY29udmVydGVyIC0gQSB7QGxpbmsgVmFsdWVDb252ZXJ0ZXJ9IHRoYXQgaW50ZWdyYXRlcyB3aXRoIHRoZSBwcm9wZXJ0eSBnZXR0ZXIvc2V0dGVyXG4gICAgICogdG8gY29udmVydCB2YWx1ZXMgdG8gYW5kIGZyb20gYSBET00gc3RyaW5nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKE93bmVyLCBuYW1lLCBhdHRyaWJ1dGUgPSBuYW1lLnRvTG93ZXJDYXNlKCksIG1vZGUgPSBcInJlZmxlY3RcIiwgY29udmVydGVyKSB7XG4gICAgICAgIHRoaXMuZ3VhcmRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLk93bmVyID0gT3duZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5maWVsZE5hbWUgPSBgXyR7bmFtZX1gO1xuICAgICAgICB0aGlzLmNhbGxiYWNrTmFtZSA9IGAke25hbWV9Q2hhbmdlZGA7XG4gICAgICAgIHRoaXMuaGFzQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTmFtZSBpbiBPd25lci5wcm90b3R5cGU7XG4gICAgICAgIGlmIChtb2RlID09PSBcImJvb2xlYW5cIiAmJiBjb252ZXJ0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBib29sZWFuQ29udmVydGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUvcHJvcGVydHkgb24gdGhlIHNvdXJjZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIGVsZW1lbnQgdG8gYWNjZXNzLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZS9wcm9wZXJ0eSB0by5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZShzb3VyY2UsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc291cmNlW3RoaXMuZmllbGROYW1lXTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gdGhpcy5jb252ZXJ0ZXI7XG4gICAgICAgIGlmIChjb252ZXJ0ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb252ZXJ0ZXIuZnJvbVZpZXcobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHNvdXJjZVt0aGlzLmZpZWxkTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJ5UmVmbGVjdFRvQXR0cmlidXRlKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNvdXJjZVt0aGlzLmNhbGxiYWNrTmFtZV0ob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZS4kZmFzdENvbnRyb2xsZXIubm90aWZ5KHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS9wcm9wZXJ0eSBvbiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2UgZWxlbWVudCB0byBhY2Nlc3MuXG4gICAgICovXG4gICAgZ2V0VmFsdWUoc291cmNlKSB7XG4gICAgICAgIE9ic2VydmFibGUudHJhY2soc291cmNlLCB0aGlzLm5hbWUpO1xuICAgICAgICByZXR1cm4gc291cmNlW3RoaXMuZmllbGROYW1lXTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uQXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmd1YXJkcy5hZGQoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUoZWxlbWVudCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmd1YXJkcy5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICAgIHRyeVJlZmxlY3RUb0F0dHJpYnV0ZShlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIGNvbnN0IGd1YXJkcyA9IHRoaXMuZ3VhcmRzO1xuICAgICAgICBpZiAoZ3VhcmRzLmhhcyhlbGVtZW50KSB8fCBtb2RlID09PSBcImZyb21WaWV3XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBET00ucXVldWVVcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgZ3VhcmRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdFZhbHVlID0gZWxlbWVudFt0aGlzLmZpZWxkTmFtZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVmbGVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSB0aGlzLmNvbnZlcnRlcjtcbiAgICAgICAgICAgICAgICAgICAgRE9NLnNldEF0dHJpYnV0ZShlbGVtZW50LCB0aGlzLmF0dHJpYnV0ZSwgY29udmVydGVyICE9PSB2b2lkIDAgPyBjb252ZXJ0ZXIudG9WaWV3KGxhdGVzdFZhbHVlKSA6IGxhdGVzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgRE9NLnNldEJvb2xlYW5BdHRyaWJ1dGUoZWxlbWVudCwgdGhpcy5hdHRyaWJ1dGUsIGxhdGVzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBndWFyZHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGVjdHMgYWxsIGF0dHJpYnV0ZSBkZWZpbml0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIG93bmVyLlxuICAgICAqIEBwYXJhbSBPd25lciAtIFRoZSBjbGFzcyBjb25zdHJ1Y3RvciB0byBjb2xsZWN0IGF0dHJpYnV0ZSBmb3IuXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZUxpc3RzIC0gQW55IGV4aXN0aW5nIGF0dHJpYnV0ZXMgdG8gY29sbGVjdCBhbmQgbWVyZ2Ugd2l0aCB0aG9zZSBhc3NvY2lhdGVkIHdpdGggdGhlIG93bmVyLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBjb2xsZWN0KE93bmVyLCAuLi5hdHRyaWJ1dGVMaXN0cykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGF0dHJpYnV0ZUxpc3RzLnB1c2goQXR0cmlidXRlQ29uZmlndXJhdGlvbi5sb2NhdGUoT3duZXIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXR0cmlidXRlTGlzdHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IGF0dHJpYnV0ZUxpc3RzW2ldO1xuICAgICAgICAgICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gbGlzdC5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbGlzdFtqXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZURlZmluaXRpb24oT3duZXIsIGNvbmZpZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGVEZWZpbml0aW9uKE93bmVyLCBjb25maWcucHJvcGVydHksIGNvbmZpZy5hdHRyaWJ1dGUsIGNvbmZpZy5tb2RlLCBjb25maWcuY29udmVydGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKGNvbmZpZ09yVGFyZ2V0LCBwcm9wKSB7XG4gICAgbGV0IGNvbmZpZztcbiAgICBmdW5jdGlvbiBkZWNvcmF0b3IoJHRhcmdldCwgJHByb3ApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBOb24gaW52b2NhdGlvbjpcbiAgICAgICAgICAgIC8vIC0gQGF0dHJcbiAgICAgICAgICAgIC8vIEludm9jYXRpb24gd2l0aCBvciB3L28gb3B0czpcbiAgICAgICAgICAgIC8vIC0gQGF0dHIoKVxuICAgICAgICAgICAgLy8gLSBAYXR0cih7Li4ub3B0c30pXG4gICAgICAgICAgICBjb25maWcucHJvcGVydHkgPSAkcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBBdHRyaWJ1dGVDb25maWd1cmF0aW9uLmxvY2F0ZSgkdGFyZ2V0LmNvbnN0cnVjdG9yKS5wdXNoKGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBOb24gaW52b2NhdGlvbjpcbiAgICAgICAgLy8gLSBAYXR0clxuICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgZGVjb3JhdG9yKGNvbmZpZ09yVGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJbnZvY2F0aW9uIHdpdGggb3Igdy9vIG9wdHM6XG4gICAgLy8gLSBAYXR0cigpXG4gICAgLy8gLSBAYXR0cih7Li4ub3B0c30pXG4gICAgY29uZmlnID0gY29uZmlnT3JUYXJnZXQgPT09IHZvaWQgMCA/IHt9IDogY29uZmlnT3JUYXJnZXQ7XG4gICAgcmV0dXJuIGRlY29yYXRvcjtcbn1cbiIsImltcG9ydCB7IERPTSB9IGZyb20gXCIuLi9kb20uanNcIjtcbmltcG9ydCB7IFByb3BlcnR5Q2hhbmdlTm90aWZpZXIgfSBmcm9tIFwiLi4vb2JzZXJ2YXRpb24vbm90aWZpZXIuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRFeGVjdXRpb25Db250ZXh0LCBPYnNlcnZhYmxlIH0gZnJvbSBcIi4uL29ic2VydmF0aW9uL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IEZBU1RFbGVtZW50RGVmaW5pdGlvbiB9IGZyb20gXCIuL2Zhc3QtZGVmaW5pdGlvbnMuanNcIjtcbmNvbnN0IHNoYWRvd1Jvb3RzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGRlZmF1bHRFdmVudE9wdGlvbnMgPSB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGdldFNoYWRvd1Jvb3QoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnNoYWRvd1Jvb3QgfHwgc2hhZG93Um9vdHMuZ2V0KGVsZW1lbnQpIHx8IG51bGw7XG59XG4vKipcbiAqIENvbnRyb2xzIHRoZSBsaWZlY3ljbGUgYW5kIHJlbmRlcmluZyBvZiBhIGBGQVNURWxlbWVudGAuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgUHJvcGVydHlDaGFuZ2VOb3RpZmllciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbnRyb2xsZXIgdG8gY29udHJvbCB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBiZSBjb250cm9sbGVkIGJ5IHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gZGVmaW5pdGlvbiAtIFRoZSBlbGVtZW50IGRlZmluaXRpb24gbWV0YWRhdGEgdGhhdCBpbnN0cnVjdHMgdGhpc1xuICAgICAqIGNvbnRyb2xsZXIgaW4gaG93IHRvIGhhbmRsZSByZW5kZXJpbmcgYW5kIG90aGVyIHBsYXRmb3JtIGludGVncmF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBkZWZpbml0aW9uKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLmJvdW5kT2JzZXJ2YWJsZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmJlaGF2aW9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMubmVlZHNJbml0aWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3R5bGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgYWxsb3dzIE9ic2VydmFibGUuZ2V0Tm90aWZpZXIoLi4uKSB0byByZXR1cm4gdGhlIENvbnRyb2xsZXJcbiAgICAgICAgICogd2hlbiB0aGUgbm90aWZpZXIgZm9yIHRoZSBDb250cm9sbGVyIGl0c2VsZiBpcyBiZWluZyByZXF1ZXN0ZWQuIFRoZVxuICAgICAgICAgKiByZXN1bHQgaXMgdGhhdCB0aGUgT2JzZXJ2YWJsZSBzeXN0ZW0gZG9lcyBub3QgbmVlZCB0byBjcmVhdGUgYSBzZXBhcmF0ZVxuICAgICAgICAgKiBpbnN0YW5jZSBvZiBOb3RpZmllciBmb3Igb2JzZXJ2YWJsZXMgb24gdGhlIENvbnRyb2xsZXIuIFRoZSBjb21wb25lbnQgYW5kXG4gICAgICAgICAqIHRoZSBjb250cm9sbGVyIHdpbGwgbm93IHNoYXJlIHRoZSBzYW1lIG5vdGlmaWVyLCByZW1vdmluZyBvbmUtb2JqZWN0IGNvbnN0cnVjdFxuICAgICAgICAgKiBwZXIgd2ViIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGZhc3RDb250cm9sbGVyID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2aWV3IGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VzdG9tIGVsZW1lbnQuXG4gICAgICAgICAqIEByZW1hcmtzXG4gICAgICAgICAqIElmIGBudWxsYCB0aGVuIHRoZSBlbGVtZW50IGlzIG1hbmFnaW5nIGl0cyBvd24gcmVuZGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgY29uc3Qgc2hhZG93T3B0aW9ucyA9IGRlZmluaXRpb24uc2hhZG93T3B0aW9ucztcbiAgICAgICAgaWYgKHNoYWRvd09wdGlvbnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuYXR0YWNoU2hhZG93KHNoYWRvd09wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd09wdGlvbnMubW9kZSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3RzLnNldChlbGVtZW50LCBzaGFkb3dSb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYXB0dXJlIGFueSBvYnNlcnZhYmxlIHZhbHVlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBiaW5kaW5nIGVuZ2luZSBiZWZvcmVcbiAgICAgICAgLy8gdGhlIGJyb3dzZXIgdXBncmFkZWQgdGhlIGVsZW1lbnQuIFRoZW4gZGVsZXRlIHRoZSBwcm9wZXJ0eSBzaW5jZSBpdCB3aWxsXG4gICAgICAgIC8vIHNoYWRvdyB0aGUgZ2V0dGVyL3NldHRlciB0aGF0IGlzIHJlcXVpcmVkIHRvIG1ha2UgdGhlIG9ic2VydmFibGUgb3BlcmF0ZS5cbiAgICAgICAgLy8gTGF0ZXIsIGluIHRoZSBjb25uZWN0IGNhbGxiYWNrLCB3ZSdsbCByZS1hcHBseSB0aGUgdmFsdWVzLlxuICAgICAgICBjb25zdCBhY2Nlc3NvcnMgPSBPYnNlcnZhYmxlLmdldEFjY2Vzc29ycyhlbGVtZW50KTtcbiAgICAgICAgaWYgKGFjY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBib3VuZE9ic2VydmFibGVzID0gKHRoaXMuYm91bmRPYnNlcnZhYmxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYWNjZXNzb3JzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBhY2Nlc3NvcnNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBib3VuZE9ic2VydmFibGVzW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXN0b20gZWxlbWVudCBoYXMgYmVlblxuICAgICAqIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgICAgICBPYnNlcnZhYmxlLnRyYWNrKHRoaXMsIFwiaXNDb25uZWN0ZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Nvbm5lY3RlZDtcbiAgICB9XG4gICAgc2V0SXNDb25uZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faXNDb25uZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgT2JzZXJ2YWJsZS5ub3RpZnkodGhpcywgXCJpc0Nvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cy9zZXRzIHRoZSB0ZW1wbGF0ZSB1c2VkIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyB2YWx1ZSBjYW4gb25seSBiZSBhY2N1cmF0ZWx5IHJlYWQgYWZ0ZXIgY29ubmVjdCBidXQgY2FuIGJlIHNldCBhdCBhbnkgdGltZS5cbiAgICAgKi9cbiAgICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG4gICAgc2V0IHRlbXBsYXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMubmVlZHNJbml0aWFsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUZW1wbGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cy9zZXRzIHRoZSBwcmltYXJ5IHN0eWxlcyB1c2VkIGZvciB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyB2YWx1ZSBjYW4gb25seSBiZSBhY2N1cmF0ZWx5IHJlYWQgYWZ0ZXIgY29ubmVjdCBidXQgY2FuIGJlIHNldCBhdCBhbnkgdGltZS5cbiAgICAgKi9cbiAgICBnZXQgc3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVzO1xuICAgIH1cbiAgICBzZXQgc3R5bGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZXMgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdHlsZXModGhpcy5fc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdHlsZXMgPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm5lZWRzSW5pdGlhbGl6YXRpb24gJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3R5bGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHN0eWxlcyB0byB0aGlzIGVsZW1lbnQuIFByb3ZpZGluZyBhbiBIVE1MU3R5bGVFbGVtZW50IHdpbGwgYXR0YWNoIHRoZSBlbGVtZW50IGluc3RhbmNlIHRvIHRoZSBzaGFkb3dSb290LlxuICAgICAqIEBwYXJhbSBzdHlsZXMgLSBUaGUgc3R5bGVzIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFNoYWRvd1Jvb3QodGhpcy5lbGVtZW50KSB8fFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIGlmIChzdHlsZXMgaW5zdGFuY2VvZiBIVE1MU3R5bGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0YXJnZXQuYXBwZW5kKHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXN0eWxlcy5pc0F0dGFjaGVkVG8odGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQmVoYXZpb3JzID0gc3R5bGVzLmJlaGF2aW9ycztcbiAgICAgICAgICAgIHN0eWxlcy5hZGRTdHlsZXNUbyh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUJlaGF2aW9ycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmVoYXZpb3JzKHNvdXJjZUJlaGF2aW9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBzdHlsZXMgZnJvbSB0aGlzIGVsZW1lbnQuIFByb3ZpZGluZyBhbiBIVE1MU3R5bGVFbGVtZW50IHdpbGwgZGV0YWNoIHRoZSBlbGVtZW50IGluc3RhbmNlIGZyb20gdGhlIHNoYWRvd1Jvb3QuXG4gICAgICogQHBhcmFtIHN0eWxlcyAtIHRoZSBzdHlsZXMgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0U2hhZG93Um9vdCh0aGlzLmVsZW1lbnQpIHx8XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgaWYgKHN0eWxlcyBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZChzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlcy5pc0F0dGFjaGVkVG8odGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQmVoYXZpb3JzID0gc3R5bGVzLmJlaGF2aW9ycztcbiAgICAgICAgICAgIHN0eWxlcy5yZW1vdmVTdHlsZXNGcm9tKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoc291cmNlQmVoYXZpb3JzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCZWhhdmlvcnMoc291cmNlQmVoYXZpb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGJlaGF2aW9ycyB0byB0aGlzIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGJlaGF2aW9ycyAtIFRoZSBiZWhhdmlvcnMgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZEJlaGF2aW9ycyhiZWhhdmlvcnMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0QmVoYXZpb3JzID0gdGhpcy5iZWhhdmlvcnMgfHwgKHRoaXMuYmVoYXZpb3JzID0gbmV3IE1hcCgpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYmVoYXZpb3JzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmVoYXZpb3JzVG9CaW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGJlaGF2aW9yID0gYmVoYXZpb3JzW2ldO1xuICAgICAgICAgICAgaWYgKHRhcmdldEJlaGF2aW9ycy5oYXMoYmVoYXZpb3IpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QmVoYXZpb3JzLnNldChiZWhhdmlvciwgdGFyZ2V0QmVoYXZpb3JzLmdldChiZWhhdmlvcikgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldEJlaGF2aW9ycy5zZXQoYmVoYXZpb3IsIDEpO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yc1RvQmluZC5wdXNoKGJlaGF2aW9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJlaGF2aW9yc1RvQmluZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yc1RvQmluZFtpXS5iaW5kKGVsZW1lbnQsIGRlZmF1bHRFeGVjdXRpb25Db250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGJlaGF2aW9ycyBmcm9tIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gYmVoYXZpb3JzIC0gVGhlIGJlaGF2aW9ycyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIGZvcmNlIC0gRm9yY2VzIHVuYmluZGluZyBvZiBiZWhhdmlvcnMuXG4gICAgICovXG4gICAgcmVtb3ZlQmVoYXZpb3JzKGJlaGF2aW9ycywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRCZWhhdmlvcnMgPSB0aGlzLmJlaGF2aW9ycztcbiAgICAgICAgaWYgKHRhcmdldEJlaGF2aW9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGJlaGF2aW9ycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJlaGF2aW9yc1RvVW5iaW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGJlaGF2aW9yID0gYmVoYXZpb3JzW2ldO1xuICAgICAgICAgICAgaWYgKHRhcmdldEJlaGF2aW9ycy5oYXMoYmVoYXZpb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB0YXJnZXRCZWhhdmlvcnMuZ2V0KGJlaGF2aW9yKSAtIDE7XG4gICAgICAgICAgICAgICAgY291bnQgPT09IDAgfHwgZm9yY2VcbiAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXRCZWhhdmlvcnMuZGVsZXRlKGJlaGF2aW9yKSAmJiBiZWhhdmlvcnNUb1VuYmluZC5wdXNoKGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICA6IHRhcmdldEJlaGF2aW9ycy5zZXQoYmVoYXZpb3IsIGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJlaGF2aW9yc1RvVW5iaW5kLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3JzVG9VbmJpbmRbaV0udW5iaW5kKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgY29ubmVjdGVkIGxpZmVjeWNsZSBiZWhhdmlvciBvbiB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIG9uQ29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzSW5pdGlhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoSW5pdGlhbGl6YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5iaW5kKGVsZW1lbnQsIGRlZmF1bHRFeGVjdXRpb25Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiZWhhdmlvcnMgPSB0aGlzLmJlaGF2aW9ycztcbiAgICAgICAgaWYgKGJlaGF2aW9ycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmVoYXZpb3JdIG9mIGJlaGF2aW9ycykge1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmJpbmQoZWxlbWVudCwgZGVmYXVsdEV4ZWN1dGlvbkNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SXNDb25uZWN0ZWQodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgZGlzY29ubmVjdGVkIGxpZmVjeWNsZSBiZWhhdmlvciBvbiB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldElzQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXcudW5iaW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmVoYXZpb3JzID0gdGhpcy5iZWhhdmlvcnM7XG4gICAgICAgIGlmIChiZWhhdmlvcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiZWhhdmlvcl0gb2YgYmVoYXZpb3JzKSB7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3IudW5iaW5kKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGF0dHJpYnV0ZSBjaGFuZ2VkIGNhbGxiYWNrIGZvciB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIG9sZFZhbHVlIC0gVGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIG9uQXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBjb25zdCBhdHRyRGVmID0gdGhpcy5kZWZpbml0aW9uLmF0dHJpYnV0ZUxvb2t1cFtuYW1lXTtcbiAgICAgICAgaWYgKGF0dHJEZWYgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYXR0ckRlZi5vbkF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLmVsZW1lbnQsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIGN1c3RvbSBIVE1MIGV2ZW50LlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIGRldGFpbCAtIFRoZSBldmVudCBkZXRhaWwgb2JqZWN0IHRvIHNlbmQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZXZlbnQgb3B0aW9ucy4gQnkgZGVmYXVsdCBidWJibGVzIGFuZCBjb21wb3NlZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIE9ubHkgZW1pdHMgZXZlbnRzIGlmIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBlbWl0KHR5cGUsIGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5faXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGV0YWlsIH0sIGRlZmF1bHRFdmVudE9wdGlvbnMpLCBvcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmluaXNoSW5pdGlhbGl6YXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGJvdW5kT2JzZXJ2YWJsZXMgPSB0aGlzLmJvdW5kT2JzZXJ2YWJsZXM7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW55IG9ic2VydmFibGVzIHRoYXQgd2VyZSBib3VuZCwgcmUtYXBwbHkgdGhlaXIgdmFsdWVzLlxuICAgICAgICBpZiAoYm91bmRPYnNlcnZhYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKGJvdW5kT2JzZXJ2YWJsZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBlbGVtZW50W3Byb3BlcnR5TmFtZV0gPSBib3VuZE9ic2VydmFibGVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJvdW5kT2JzZXJ2YWJsZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmRlZmluaXRpb247XG4gICAgICAgIC8vIDEuIFRlbXBsYXRlIG92ZXJyaWRlcyB0YWtlIHRvcCBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQucmVzb2x2ZVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gMi4gQWxsb3cgZm9yIGVsZW1lbnQgaW5zdGFuY2Ugb3ZlcnJpZGVzIG5leHQuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0aGlzLmVsZW1lbnQucmVzb2x2ZVRlbXBsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZpbml0aW9uLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gMy4gRGVmYXVsdCB0byB0aGUgc3RhdGljIGRlZmluaXRpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBkZWZpbml0aW9uLnRlbXBsYXRlIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRlbXBsYXRlIGFmdGVyIHRoZSBhYm92ZSBwcm9jZXNzLCByZW5kZXIgaXQuXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gdGVtcGxhdGUsIHRoZW4gdGhlIGVsZW1lbnQgYXV0aG9yIGhhcyBvcHRlZCBpbnRvXG4gICAgICAgIC8vIGN1c3RvbSByZW5kZXJpbmcgYW5kIHRoZXkgd2lsbCBtYW5hZ2VkIHRoZSBzaGFkb3cgcm9vdCdzIGNvbnRlbnQgdGhlbXNlbHZlcy5cbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAxLiBTdHlsZXMgb3ZlcnJpZGVzIHRha2UgdG9wIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICh0aGlzLl9zdHlsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQucmVzb2x2ZVN0eWxlcykge1xuICAgICAgICAgICAgICAgIC8vIDIuIEFsbG93IGZvciBlbGVtZW50IGluc3RhbmNlIG92ZXJyaWRlcyBuZXh0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IHRoaXMuZWxlbWVudC5yZXNvbHZlU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZpbml0aW9uLnN0eWxlcykge1xuICAgICAgICAgICAgICAgIC8vIDMuIERlZmF1bHQgdG8gdGhlIHN0YXRpYyBkZWZpbml0aW9uLlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IGRlZmluaXRpb24uc3R5bGVzIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBzdHlsZXMgYWZ0ZXIgdGhlIGFib3ZlIHByb2Nlc3MsIGFkZCB0aGVtLlxuICAgICAgICBpZiAodGhpcy5fc3R5bGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFN0eWxlcyh0aGlzLl9zdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmVlZHNJbml0aWFsaXphdGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICAvLyBXaGVuIGdldHRpbmcgdGhlIGhvc3QgdG8gcmVuZGVyIHRvLCB3ZSBzdGFydCBieSBsb29raW5nXG4gICAgICAgIC8vIHVwIHRoZSBzaGFkb3cgcm9vdC4gSWYgdGhlcmUgaXNuJ3Qgb25lLCB0aGVuIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gd2UncmUgZG9pbmcgYSBMaWdodCBET00gcmVuZGVyIHRvIHRoZSBlbGVtZW50J3MgZGlyZWN0IGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBob3N0ID0gZ2V0U2hhZG93Um9vdChlbGVtZW50KSB8fCBlbGVtZW50O1xuICAgICAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgYSB2aWV3LCB3ZSBuZWVkIHRvIHVuYmluZCBhbmQgcmVtb3ZlIHRocm91Z2ggZGlzcG9zZS5cbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLm5lZWRzSW5pdGlhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBwcmV2aW91cyBjdXN0b20gcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGNsZWFyIG91dCB0aGUgaG9zdC5cbiAgICAgICAgICAgIERPTS5yZW1vdmVDaGlsZE5vZGVzKGhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gSWYgYSBuZXcgdGVtcGxhdGUgd2FzIHByb3ZpZGVkLCByZW5kZXIgaXQuXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB0ZW1wbGF0ZS5yZW5kZXIoZWxlbWVudCwgaG9zdCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9jYXRlcyBvciBjcmVhdGVzIGEgY29udHJvbGxlciBmb3IgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gcmV0dXJuIHRoZSBjb250cm9sbGVyIGZvci5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBzcGVjaWZpZWQgZWxlbWVudCBtdXN0IGhhdmUgYSB7QGxpbmsgRkFTVEVsZW1lbnREZWZpbml0aW9ufVxuICAgICAqIHJlZ2lzdGVyZWQgZWl0aGVyIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUge0BsaW5rIGN1c3RvbUVsZW1lbnR9XG4gICAgICogZGVjb3JhdG9yIG9yIGEgY2FsbCB0byBgRkFTVEVsZW1lbnQuZGVmaW5lYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yQ3VzdG9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBlbGVtZW50LiRmYXN0Q29udHJvbGxlcjtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEZBU1RFbGVtZW50RGVmaW5pdGlvbi5mb3JUeXBlKGVsZW1lbnQuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEZBU1RFbGVtZW50IGRlZmluaXRpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZWxlbWVudC4kZmFzdENvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihlbGVtZW50LCBkZWZpbml0aW9uKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRkFTVCB9IGZyb20gXCIuLi9wbGF0Zm9ybS5qc1wiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9vYnNlcnZhdGlvbi9vYnNlcnZhYmxlLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50U3R5bGVzIH0gZnJvbSBcIi4uL3N0eWxlcy9lbGVtZW50LXN0eWxlcy5qc1wiO1xuaW1wb3J0IHsgQXR0cmlidXRlRGVmaW5pdGlvbiB9IGZyb20gXCIuL2F0dHJpYnV0ZXMuanNcIjtcbmNvbnN0IGRlZmF1bHRTaGFkb3dPcHRpb25zID0geyBtb2RlOiBcIm9wZW5cIiB9O1xuY29uc3QgZGVmYXVsdEVsZW1lbnRPcHRpb25zID0ge307XG5jb25zdCBmYXN0UmVnaXN0cnkgPSBGQVNULmdldEJ5SWQoNCAvKiBlbGVtZW50UmVnaXN0cnkgKi8sICgpID0+IHtcbiAgICBjb25zdCB0eXBlVG9EZWZpbml0aW9uID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcmVnaXN0ZXIoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVUb0RlZmluaXRpb24uaGFzKGRlZmluaXRpb24udHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlVG9EZWZpbml0aW9uLnNldChkZWZpbml0aW9uLnR5cGUsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEJ5VHlwZShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlVG9EZWZpbml0aW9uLmdldChrZXkpO1xuICAgICAgICB9LFxuICAgIH0pO1xufSk7XG4vKipcbiAqIERlZmluZXMgbWV0YWRhdGEgZm9yIGEgRkFTVEVsZW1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBGQVNURWxlbWVudERlZmluaXRpb24ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRkFTVEVsZW1lbnREZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdGhpcyBkZWZpbml0aW9uIGlzIGJlaW5nIGNyZWF0ZWQgZm9yLlxuICAgICAqIEBwYXJhbSBuYW1lT3JDb25maWcgLSBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudCB0byBkZWZpbmUgb3IgYSBjb25maWcgb2JqZWN0XG4gICAgICogdGhhdCBkZXNjcmliZXMgdGhlIGVsZW1lbnQgdG8gZGVmaW5lLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hbWVPckNvbmZpZyA9IHR5cGUuZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVPckNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbmFtZU9yQ29uZmlnID0geyBuYW1lOiBuYW1lT3JDb25maWcgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lT3JDb25maWcubmFtZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IG5hbWVPckNvbmZpZy50ZW1wbGF0ZTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IEF0dHJpYnV0ZURlZmluaXRpb24uY29sbGVjdCh0eXBlLCBuYW1lT3JDb25maWcuYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVkQXR0cmlidXRlcyA9IG5ldyBBcnJheShhdHRyaWJ1dGVzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TG9va3VwID0ge307XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUxvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzW2ldID0gY3VycmVudC5hdHRyaWJ1dGU7XG4gICAgICAgICAgICBwcm9wZXJ0eUxvb2t1cFtjdXJyZW50Lm5hbWVdID0gY3VycmVudDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZUxvb2t1cFtjdXJyZW50LmF0dHJpYnV0ZV0gPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLnByb3BlcnR5TG9va3VwID0gcHJvcGVydHlMb29rdXA7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTG9va3VwID0gYXR0cmlidXRlTG9va3VwO1xuICAgICAgICB0aGlzLnNoYWRvd09wdGlvbnMgPVxuICAgICAgICAgICAgbmFtZU9yQ29uZmlnLnNoYWRvd09wdGlvbnMgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFNoYWRvd09wdGlvbnNcbiAgICAgICAgICAgICAgICA6IG5hbWVPckNvbmZpZy5zaGFkb3dPcHRpb25zID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U2hhZG93T3B0aW9ucyksIG5hbWVPckNvbmZpZy5zaGFkb3dPcHRpb25zKTtcbiAgICAgICAgdGhpcy5lbGVtZW50T3B0aW9ucyA9XG4gICAgICAgICAgICBuYW1lT3JDb25maWcuZWxlbWVudE9wdGlvbnMgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gZGVmYXVsdEVsZW1lbnRPcHRpb25zXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRFbGVtZW50T3B0aW9ucyksIG5hbWVPckNvbmZpZy5lbGVtZW50T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3R5bGVzID1cbiAgICAgICAgICAgIG5hbWVPckNvbmZpZy5zdHlsZXMgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KG5hbWVPckNvbmZpZy5zdHlsZXMpXG4gICAgICAgICAgICAgICAgICAgID8gRWxlbWVudFN0eWxlcy5jcmVhdGUobmFtZU9yQ29uZmlnLnN0eWxlcylcbiAgICAgICAgICAgICAgICAgICAgOiBuYW1lT3JDb25maWcuc3R5bGVzIGluc3RhbmNlb2YgRWxlbWVudFN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBuYW1lT3JDb25maWcuc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEVsZW1lbnRTdHlsZXMuY3JlYXRlKFtuYW1lT3JDb25maWcuc3R5bGVzXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGlzIGVsZW1lbnQgaGFzIGJlZW4gZGVmaW5lZCBpbiBhdCBsZWFzdCBvbmUgcmVnaXN0cnkuXG4gICAgICovXG4gICAgZ2V0IGlzRGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuICEhZmFzdFJlZ2lzdHJ5LmdldEJ5VHlwZSh0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgY3VzdG9tIGVsZW1lbnQgYmFzZWQgb24gdGhpcyBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSByZWdpc3RyeSAtIFRoZSBlbGVtZW50IHJlZ2lzdHJ5IHRvIGRlZmluZSB0aGUgZWxlbWVudCBpbi5cbiAgICAgKi9cbiAgICBkZWZpbmUocmVnaXN0cnkgPSBjdXN0b21FbGVtZW50cykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBpZiAoZmFzdFJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIE9ic2VydmFibGUuZGVmaW5lUHJvcGVydHkocHJvdG8sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIm9ic2VydmVkQXR0cmlidXRlc1wiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMub2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZ2lzdHJ5LmdldCh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICByZWdpc3RyeS5kZWZpbmUodGhpcy5uYW1lLCB0eXBlLCB0aGlzLmVsZW1lbnRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGVsZW1lbnQgZGVmaW5pdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgY3VzdG9tIGVsZW1lbnQgdHlwZSB0byByZXRyaWV2ZSB0aGUgZGVmaW5pdGlvbiBmb3IuXG4gKi9cbkZBU1RFbGVtZW50RGVmaW5pdGlvbi5mb3JUeXBlID0gZmFzdFJlZ2lzdHJ5LmdldEJ5VHlwZTtcbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tIFwiLi9jb250cm9sbGVyLmpzXCI7XG5pbXBvcnQgeyBGQVNURWxlbWVudERlZmluaXRpb24sIH0gZnJvbSBcIi4vZmFzdC1kZWZpbml0aW9ucy5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZSAqL1xuZnVuY3Rpb24gY3JlYXRlRkFTVEVsZW1lbnQoQmFzZVR5cGUpIHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBCYXNlVHlwZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovXG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgQ29udHJvbGxlci5mb3JDdXN0b21FbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICRlbWl0KHR5cGUsIGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZhc3RDb250cm9sbGVyLmVtaXQodHlwZSwgZGV0YWlsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHRoaXMuJGZhc3RDb250cm9sbGVyLm9uQ29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHRoaXMuJGZhc3RDb250cm9sbGVyLm9uRGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRmYXN0Q29udHJvbGxlci5vbkF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQSBtaW5pbWFsIGJhc2UgY2xhc3MgZm9yIEZBU1RFbGVtZW50cyB0aGF0IGFsc28gcHJvdmlkZXNcbiAqIHN0YXRpYyBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggRkFTVEVsZW1lbnRzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgRkFTVEVsZW1lbnQgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUZBU1RFbGVtZW50KEhUTUxFbGVtZW50KSwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRkFTVEVsZW1lbnQgYmFzZSBjbGFzcyBpbmhlcml0ZWQgZnJvbSB0aGVcbiAgICAgKiBwcm92aWRlZCBiYXNlIHR5cGUuXG4gICAgICogQHBhcmFtIEJhc2VUeXBlIC0gVGhlIGJhc2UgZWxlbWVudCB0eXBlIHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKi9cbiAgICBmcm9tKEJhc2VUeXBlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGQVNURWxlbWVudChCYXNlVHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgcGxhdGZvcm0gY3VzdG9tIGVsZW1lbnQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHR5cGUgYW5kIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgY3VzdG9tIGVsZW1lbnQgdHlwZSB0byBkZWZpbmUuXG4gICAgICogQHBhcmFtIG5hbWVPckRlZiAtIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IHRvIGRlZmluZSBvciBhIGRlZmluaXRpb24gb2JqZWN0XG4gICAgICogdGhhdCBkZXNjcmliZXMgdGhlIGVsZW1lbnQgdG8gZGVmaW5lLlxuICAgICAqL1xuICAgIGRlZmluZSh0eXBlLCBuYW1lT3JEZWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGQVNURWxlbWVudERlZmluaXRpb24odHlwZSwgbmFtZU9yRGVmKS5kZWZpbmUoKS50eXBlO1xuICAgIH0sXG59KTtcbi8qKlxuICogRGVjb3JhdG9yOiBEZWZpbmVzIGEgcGxhdGZvcm0gY3VzdG9tIGVsZW1lbnQgYmFzZWQgb24gYEZBU1RFbGVtZW50YC5cbiAqIEBwYXJhbSBuYW1lT3JEZWYgLSBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudCB0byBkZWZpbmUgb3IgYSBkZWZpbml0aW9uIG9iamVjdFxuICogdGhhdCBkZXNjcmliZXMgdGhlIGVsZW1lbnQgdG8gZGVmaW5lLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRWxlbWVudChuYW1lT3JEZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIG5ldyBGQVNURWxlbWVudERlZmluaXRpb24odHlwZSwgbmFtZU9yRGVmKS5kZWZpbmUoKTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgJGdsb2JhbCB9IGZyb20gXCIuL3BsYXRmb3JtLmpzXCI7XG5jb25zdCB1cGRhdGVRdWV1ZSA9ICRnbG9iYWwuRkFTVC5nZXRCeUlkKDEgLyogdXBkYXRlUXVldWUgKi8sICgpID0+IHtcbiAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdFcnJvcnMgPSBbXTtcbiAgICBmdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgICAgIGlmIChwZW5kaW5nRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgcGVuZGluZ0Vycm9ycy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyeVJ1blRhc2sodGFzaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzay5jYWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBwZW5kaW5nRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgc2V0VGltZW91dCh0aHJvd0ZpcnN0RXJyb3IsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgIGNvbnN0IGNhcGFjaXR5ID0gMTAyNDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cnlSdW5UYXNrKHRhc2tzW2luZGV4XSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBET00ucXVldWVVcGRhdGVgLlxuICAgICAgICAgICAgLy8gSWYgd2UgY2FsbCBgRE9NLnF1ZXVlVXBkYXRlYCB3aXRoaW4gYSB0YXNrIHNjaGVkdWxlZCBieSBgRE9NLnF1ZXVlVXBkYXRlYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHRhc2tzLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3Nbc2Nhbl0gPSB0YXNrc1tzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXNrcy5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2tzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWUoY2FsbGFibGUpIHtcbiAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICRnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRhc2tzLnB1c2goY2FsbGFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGVucXVldWUsXG4gICAgICAgIHByb2Nlc3MsXG4gICAgfSk7XG59KTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBmYXN0SFRNTFBvbGljeSA9ICRnbG9iYWwudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcImZhc3QtaHRtbFwiLCB7XG4gICAgY3JlYXRlSFRNTDogaHRtbCA9PiBodG1sLFxufSk7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5sZXQgaHRtbFBvbGljeSA9IGZhc3RIVE1MUG9saWN5O1xuY29uc3QgbWFya2VyID0gYGZhc3QtJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCl9YDtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBfaW50ZXJwb2xhdGlvblN0YXJ0ID0gYCR7bWFya2VyfXtgO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IF9pbnRlcnBvbGF0aW9uRW5kID0gYH0ke21hcmtlcn1gO1xuLyoqXG4gKiBDb21tb24gRE9NIEFQSXMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBET00gPSBPYmplY3QuZnJlZXplKHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRE9NIHN1cHBvcnRzIHRoZSBhZG9wdGVkU3R5bGVTaGVldHMgZmVhdHVyZS5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0Fkb3B0ZWRTdHlsZVNoZWV0czogQXJyYXkuaXNBcnJheShkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMpICYmXG4gICAgICAgIFwicmVwbGFjZVwiIGluIENTU1N0eWxlU2hlZXQucHJvdG90eXBlLFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEhUTUwgdHJ1c3RlZCB0eXBlcyBwb2xpY3kgdXNlZCBieSB0aGUgdGVtcGxhdGluZyBlbmdpbmUuXG4gICAgICogQHBhcmFtIHBvbGljeSAtIFRoZSBwb2xpY3kgdG8gc2V0IGZvciBIVE1MLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBBUEkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UsIGZvciBzZWN1cml0eSByZWFzb25zLiBJdCBzaG91bGQgYmVcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciBhdCB0aGUgc3RhcnQgb2YgdGhlaXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzZXRIVE1MUG9saWN5KHBvbGljeSkge1xuICAgICAgICBpZiAoaHRtbFBvbGljeSAhPT0gZmFzdEhUTUxQb2xpY3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBIVE1MIHBvbGljeSBjYW4gb25seSBiZSBzZXQgb25jZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbFBvbGljeSA9IHBvbGljeTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFR1cm5zIGEgc3RyaW5nIGludG8gdHJ1c3RlZCBIVE1MIHVzaW5nIHRoZSBjb25maWd1cmVkIHRydXN0ZWQgdHlwZXMgcG9saWN5LlxuICAgICAqIEBwYXJhbSBodG1sIC0gVGhlIHN0cmluZyB0byB0dXJuIGludG8gdHJ1c3RlZCBIVE1MLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSB0ZW1wbGF0ZSBlbmdpbmUgd2hlbiBjcmVhdGluZyB0ZW1wbGF0ZXNcbiAgICAgKiBhbmQgc2V0dGluZyBpbm5lckhUTUwuXG4gICAgICovXG4gICAgY3JlYXRlSFRNTChodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sUG9saWN5LmNyZWF0ZUhUTUwoaHRtbCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIGEgdGVtcGxhdGUgbWFya2VyIHVzZWQgYnkgdGhlIHJ1bnRpbWUuXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byB0ZXN0LlxuICAgICAqL1xuICAgIGlzTWFya2VyKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLmRhdGEuc3RhcnRzV2l0aChtYXJrZXIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBtYXJrZXIgbm9kZSwgZXh0cmFjdCB0aGUge0BsaW5rIEhUTUxEaXJlY3RpdmV9IGluZGV4IGZyb20gdGhlIHBsYWNlaG9sZGVyLlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG1hcmtlciBub2RlIHRvIGV4dHJhY3QgdGhlIGluZGV4IGZyb20uXG4gICAgICovXG4gICAgZXh0cmFjdERpcmVjdGl2ZUluZGV4RnJvbU1hcmtlcihub2RlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChub2RlLmRhdGEucmVwbGFjZShgJHttYXJrZXJ9OmAsIFwiXCIpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFjZWhvbGRlciBzdHJpbmcgc3VpdGFibGUgZm9yIG1hcmtpbmcgb3V0IGEgbG9jYXRpb24gKndpdGhpbipcbiAgICAgKiBhbiBhdHRyaWJ1dGUgdmFsdWUgb3IgSFRNTCBjb250ZW50LlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBkaXJlY3RpdmUgaW5kZXggdG8gY3JlYXRlIHRoZSBwbGFjZWhvbGRlciBmb3IuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBVc2VkIGludGVybmFsbHkgYnkgYmluZGluZyBkaXJlY3RpdmVzLlxuICAgICAqL1xuICAgIGNyZWF0ZUludGVycG9sYXRpb25QbGFjZWhvbGRlcihpbmRleCkge1xuICAgICAgICByZXR1cm4gYCR7X2ludGVycG9sYXRpb25TdGFydH0ke2luZGV4fSR7X2ludGVycG9sYXRpb25FbmR9YDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFjZWhvbGRlciB0aGF0IG1hbmlmZXN0cyBpdHNlbGYgYXMgYW4gYXR0cmlidXRlIG9uIGFuXG4gICAgICogZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBkaXJlY3RpdmUgaW5kZXggdG8gY3JlYXRlIHRoZSBwbGFjZWhvbGRlciBmb3IuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBVc2VkIGludGVybmFsbHkgYnkgYXR0cmlidXRlIGRpcmVjdGl2ZXMgc3VjaCBhcyBgcmVmYCwgYHNsb3R0ZWRgLCBhbmQgYGNoaWxkcmVuYC5cbiAgICAgKi9cbiAgICBjcmVhdGVDdXN0b21BdHRyaWJ1dGVQbGFjZWhvbGRlcihhdHRyaWJ1dGVOYW1lLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gYCR7YXR0cmlidXRlTmFtZX09XCIke3RoaXMuY3JlYXRlSW50ZXJwb2xhdGlvblBsYWNlaG9sZGVyKGluZGV4KX1cImA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhY2Vob2xkZXIgdGhhdCBtYW5pZmVzdHMgaXRzZWxmIGFzIGEgbWFya2VyIHdpdGhpbiB0aGUgRE9NIHN0cnVjdHVyZS5cbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgZGlyZWN0aXZlIGluZGV4IHRvIGNyZWF0ZSB0aGUgcGxhY2Vob2xkZXIgZm9yLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IGJ5IHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBzdWNoIGFzIGByZXBlYXRgLlxuICAgICAqL1xuICAgIGNyZWF0ZUJsb2NrUGxhY2Vob2xkZXIoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGA8IS0tJHttYXJrZXJ9OiR7aW5kZXh9LS0+YDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBET00gdXBkYXRlIHdvcmsgaW4gdGhlIG5leHQgYXN5bmMgYmF0Y2guXG4gICAgICogQHBhcmFtIGNhbGxhYmxlIC0gVGhlIGNhbGxhYmxlIGZ1bmN0aW9uIG9yIG9iamVjdCB0byBxdWV1ZS5cbiAgICAgKi9cbiAgICBxdWV1ZVVwZGF0ZTogdXBkYXRlUXVldWUuZW5xdWV1ZSxcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBwcm9jZXNzZXMgYWxsIHdvcmsgcHJldmlvdXNseSBzY2hlZHVsZWRcbiAgICAgKiB0aHJvdWdoIHF1ZXVlVXBkYXRlLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBhbHNvIGZvcmNlcyBuZXh0VXBkYXRlIHByb21pc2VzXG4gICAgICogdG8gcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBwcm9jZXNzVXBkYXRlczogdXBkYXRlUXVldWUucHJvY2VzcyxcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB3aXRoIHRoZSBuZXh0IERPTSB1cGRhdGUuXG4gICAgICovXG4gICAgbmV4dFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHVwZGF0ZVF1ZXVlLmVucXVldWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBhdHRyaWJ1dGUgdmFsdWUgb24gYW4gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlIG9uLlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgYXR0cmlidXRlIGlzIHJlbW92ZWQsIG90aGVyd2lzZVxuICAgICAqIGl0IGlzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWUgdXNpbmcgdGhlIHN0YW5kYXJkIGBzZXRBdHRyaWJ1dGVgIEFQSS5cbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGJvb2xlYW4gYXR0cmlidXRlIHZhbHVlIG9uLlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgdHJ1ZSwgdGhlIGF0dHJpYnV0ZSBpcyBhZGRlZDsgb3RoZXJ3aXNlIGl0IGlzIHJlbW92ZWQuXG4gICAgICovXG4gICAgc2V0Qm9vbGVhbkF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgPyBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBcIlwiKVxuICAgICAgICAgICAgOiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgcHJvdmlkZWQgcGFyZW50IG5vZGUuXG4gICAgICogQHBhcmFtIHBhcmVudCAtIFRoZSBub2RlIHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gZnJvbS5cbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZE5vZGVzKHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZCAhPT0gbnVsbDsgY2hpbGQgPSBwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRyZWVXYWxrZXIgY29uZmlndXJlZCB0byB3YWxrIGEgdGVtcGxhdGUgZnJhZ21lbnQuXG4gICAgICogQHBhcmFtIGZyYWdtZW50IC0gVGhlIGZyYWdtZW50IHRvIHdhbGsuXG4gICAgICovXG4gICAgY3JlYXRlVGVtcGxhdGVXYWxrZXIoZnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZnJhZ21lbnQsIDEzMywgLy8gZWxlbWVudCwgdGV4dCwgY29tbWVudFxuICAgICAgICBudWxsLCBmYWxzZSk7XG4gICAgfSxcbn0pO1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vcGxhdGZvcm0uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RlbXBsYXRpbmcvdGVtcGxhdGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbXBvbmVudHMvZmFzdC1lbGVtZW50LmpzXCI7XG5leHBvcnQgeyBGQVNURWxlbWVudERlZmluaXRpb24sIH0gZnJvbSBcIi4vY29tcG9uZW50cy9mYXN0LWRlZmluaXRpb25zLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb21wb25lbnRzL2F0dHJpYnV0ZXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbXBvbmVudHMvY29udHJvbGxlci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdGVtcGxhdGluZy9jb21waWxlci5qc1wiO1xuZXhwb3J0IHsgRWxlbWVudFN0eWxlcywgfSBmcm9tIFwiLi9zdHlsZXMvZWxlbWVudC1zdHlsZXMuanNcIjtcbmV4cG9ydCB7IGNzcywgY3NzUGFydGlhbCB9IGZyb20gXCIuL3N0eWxlcy9jc3MuanNcIjtcbmV4cG9ydCB7IENTU0RpcmVjdGl2ZSB9IGZyb20gXCIuL3N0eWxlcy9jc3MtZGlyZWN0aXZlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90ZW1wbGF0aW5nL3ZpZXcuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL29ic2VydmF0aW9uL29ic2VydmFibGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL29ic2VydmF0aW9uL25vdGlmaWVyLmpzXCI7XG5leHBvcnQge30gZnJvbSBcIi4vb2JzZXJ2YXRpb24vYXJyYXktY2hhbmdlLXJlY29yZHMuanNcIjtcbmV4cG9ydCB7IGVuYWJsZUFycmF5T2JzZXJ2YXRpb24gfSBmcm9tIFwiLi9vYnNlcnZhdGlvbi9hcnJheS1vYnNlcnZlci5qc1wiO1xuZXhwb3J0IHsgRE9NIH0gZnJvbSBcIi4vZG9tLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90ZW1wbGF0aW5nL2JpbmRpbmcuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RlbXBsYXRpbmcvaHRtbC1kaXJlY3RpdmUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RlbXBsYXRpbmcvcmVmLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90ZW1wbGF0aW5nL3doZW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RlbXBsYXRpbmcvcmVwZWF0LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90ZW1wbGF0aW5nL3Nsb3R0ZWQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RlbXBsYXRpbmcvY2hpbGRyZW4uanNcIjtcbmV4cG9ydCB7IGVsZW1lbnRzLCB9IGZyb20gXCIuL3RlbXBsYXRpbmcvbm9kZS1vYnNlcnZhdGlvbi5qc1wiO1xuIiwiLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBhIGZ1bmN0aW9uLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9IChvYmplY3QpID0+IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIjtcbiIsImltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tIFwiLi4vcGxhdGZvcm0uanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnQsXG4gICAgfTtcbn1cbmNvbnN0IEVESVRfTEVBVkUgPSAwO1xuY29uc3QgRURJVF9VUERBVEUgPSAxO1xuY29uc3QgRURJVF9BREQgPSAyO1xuY29uc3QgRURJVF9ERUxFVEUgPSAzO1xuLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbi8vIFwiZWRpdFwiIGRpc3RhbmNlLiBUaGUgb25lIGNoYW5nZSBpcyB0aGF0IFwidXBkYXRlc1wiIGFyZSB0cmVhdGVkIGFzIHR3b1xuLy8gZWRpdHMgLSBub3Qgb25lLiBXaXRoIEFycmF5IHNwbGljZXMsIGFuIHVwZGF0ZSBpcyByZWFsbHkgYSBkZWxldGVcbi8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbi8vIG1heGltdW0gYXJyYXkgaXRlbXMgaW4gdGhlIG9yaWdpbmFsIGFycmF5LiBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbi8vXG4vLyBXaXRoIDEtZWRpdCB1cGRhdGVzLCB0aGUgc2hvcnRlc3QgcGF0aCB3b3VsZCBiZSBqdXN0IHRvIHVwZGF0ZSBhbGwgc2V2ZW5cbi8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbi8vIGxlYXZlcyB0aGUgc3Vic3RyaW5nICcxMjMnIGludGFjdC5cbmZ1bmN0aW9uIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCwgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gICAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcbiAgICBjb25zdCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgICBjb25zdCBjb2x1bW5Db3VudCA9IGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgKyAxO1xuICAgIGNvbnN0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgbGV0IG5vcnRoO1xuICAgIGxldCB3ZXN0O1xuICAgIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7ICsraSkge1xuICAgICAgICBkaXN0YW5jZXNbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICAgICAgICBkaXN0YW5jZXNbaV1bMF0gPSBpO1xuICAgIH1cbiAgICAvLyBJbml0aWFsaXplIG51bGwgcm93XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgKytqKSB7XG4gICAgICAgIGRpc3RhbmNlc1swXVtqXSA9IGo7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Q291bnQ7ICsraSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGNvbHVtbkNvdW50OyArK2opIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSA9PT0gb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3J0aCA9IGRpc3RhbmNlc1tpIC0gMV1bal0gKyAxO1xuICAgICAgICAgICAgICAgIHdlc3QgPSBkaXN0YW5jZXNbaV1baiAtIDFdICsgMTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBub3J0aCA8IHdlc3QgPyBub3J0aCA6IHdlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpc3RhbmNlcztcbn1cbi8vIFRoaXMgc3RhcnRzIGF0IHRoZSBmaW5hbCB3ZWlnaHQsIGFuZCB3YWxrcyBcImJhY2t3YXJkXCIgYnkgZmluZGluZ1xuLy8gdGhlIG1pbmltdW0gcHJldmlvdXMgd2VpZ2h0IHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBvcmlnaW4gb2YgdGhlIHdlaWdodFxuLy8gbWF0cml4LlxuZnVuY3Rpb24gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGRpc3RhbmNlcykge1xuICAgIGxldCBpID0gZGlzdGFuY2VzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGogPSBkaXN0YW5jZXNbMF0ubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudCA9IGRpc3RhbmNlc1tpXVtqXTtcbiAgICBjb25zdCBlZGl0cyA9IFtdO1xuICAgIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3J0aFdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgY29uc3Qgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgICAgIGNvbnN0IG5vcnRoID0gZGlzdGFuY2VzW2ldW2ogLSAxXTtcbiAgICAgICAgbGV0IG1pbjtcbiAgICAgICAgaWYgKHdlc3QgPCBub3J0aCkge1xuICAgICAgICAgICAgbWluID0gd2VzdCA8IG5vcnRoV2VzdCA/IHdlc3QgOiBub3J0aFdlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSBub3J0aCA8IG5vcnRoV2VzdCA/IG5vcnRoIDogbm9ydGhXZXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT09IG5vcnRoV2VzdCkge1xuICAgICAgICAgICAgaWYgKG5vcnRoV2VzdCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbm9ydGhXZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pbiA9PT0gd2VzdCkge1xuICAgICAgICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgY3VycmVudCA9IG5vcnRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVkaXRzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gZWRpdHM7XG59XG5mdW5jdGlvbiBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaExlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChjdXJyZW50W2ldICE9PSBvbGRbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWFyY2hMZW5ndGg7XG59XG5mdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgICBsZXQgaW5kZXgxID0gY3VycmVudC5sZW5ndGg7XG4gICAgbGV0IGluZGV4MiA9IG9sZC5sZW5ndGg7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB3aGlsZSAoY291bnQgPCBzZWFyY2hMZW5ndGggJiYgY3VycmVudFstLWluZGV4MV0gPT09IG9sZFstLWluZGV4Ml0pIHtcbiAgICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0KHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7XG4gICAgLy8gRGlzam9pbnRcbiAgICBpZiAoZW5kMSA8IHN0YXJ0MiB8fCBlbmQyIDwgc3RhcnQxKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gQWRqYWNlbnRcbiAgICBpZiAoZW5kMSA9PT0gc3RhcnQyIHx8IGVuZDIgPT09IHN0YXJ0MSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gTm9uLXplcm8gaW50ZXJzZWN0LCBzcGFuMSBmaXJzdFxuICAgIGlmIChzdGFydDEgPCBzdGFydDIpIHtcbiAgICAgICAgaWYgKGVuZDEgPCBlbmQyKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kMSAtIHN0YXJ0MjsgLy8gT3ZlcmxhcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQyIC0gc3RhcnQyOyAvLyBDb250YWluZWRcbiAgICB9XG4gICAgLy8gTm9uLXplcm8gaW50ZXJzZWN0LCBzcGFuMiBmaXJzdFxuICAgIGlmIChlbmQyIDwgZW5kMSkge1xuICAgICAgICByZXR1cm4gZW5kMiAtIHN0YXJ0MTsgLy8gT3ZlcmxhcFxuICAgIH1cbiAgICByZXR1cm4gZW5kMSAtIHN0YXJ0MTsgLy8gQ29udGFpbmVkXG59XG4vKipcbiAqIFNwbGljZSBQcm9qZWN0aW9uIGZ1bmN0aW9uczpcbiAqXG4gKiBBIHNwbGljZSBtYXAgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBob3cgYSBwcmV2aW91cyBhcnJheSBvZiBpdGVtc1xuICogd2FzIHRyYW5zZm9ybWVkIGludG8gYSBuZXcgYXJyYXkgb2YgaXRlbXMuIENvbmNlcHR1YWxseSBpdCBpcyBhIGxpc3Qgb2ZcbiAqIHR1cGxlcyBvZlxuICpcbiAqICAgPGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50PlxuICpcbiAqIHdoaWNoIGFyZSBrZXB0IGluIGFzY2VuZGluZyBpbmRleCBvcmRlciBvZi4gVGhlIHR1cGxlIHJlcHJlc2VudHMgdGhhdCBhdFxuICogdGhlIHxpbmRleHwsIHxyZW1vdmVkfCBzZXF1ZW5jZSBvZiBpdGVtcyB3ZXJlIHJlbW92ZWQsIGFuZCBjb3VudGluZyBmb3J3YXJkXG4gKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHJlbWFya3NcbiAqIExhY2tpbmcgaW5kaXZpZHVhbCBzcGxpY2UgbXV0YXRpb24gaW5mb3JtYXRpb24sIHRoZSBtaW5pbWFsIHNldCBvZlxuICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuICogY2hvb3NlIHRoZSBzaG9ydGVzdCBwYXRoIHRocm91Z2ggaXQuXG4gKlxuICogQ29tcGxleGl0eTogTyhsICogcClcbiAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGNTcGxpY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCwgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gICAgbGV0IHByZWZpeENvdW50ID0gMDtcbiAgICBsZXQgc3VmZml4Q291bnQgPSAwO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IE1hdGgubWluKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQsIG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICBpZiAoY3VycmVudFN0YXJ0ID09PSAwICYmIG9sZFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRFbmQgPT09IGN1cnJlbnQubGVuZ3RoICYmIG9sZEVuZCA9PT0gb2xkLmxlbmd0aCkge1xuICAgICAgICBzdWZmaXhDb3VudCA9IHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcbiAgICB9XG4gICAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgIGN1cnJlbnRFbmQgLT0gc3VmZml4Q291bnQ7XG4gICAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuICAgIGlmIChjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ID09PSAwICYmIG9sZEVuZCAtIG9sZFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgIH1cbiAgICBpZiAoY3VycmVudFN0YXJ0ID09PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIGNvbnN0IHNwbGljZSA9IG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCAwKTtcbiAgICAgICAgd2hpbGUgKG9sZFN0YXJ0IDwgb2xkRW5kKSB7XG4gICAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRTdGFydCsrXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzcGxpY2VdO1xuICAgIH1cbiAgICBlbHNlIGlmIChvbGRTdGFydCA9PT0gb2xkRW5kKSB7XG4gICAgICAgIHJldHVybiBbbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQpXTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCwgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSk7XG4gICAgY29uc3Qgc3BsaWNlcyA9IFtdO1xuICAgIGxldCBzcGxpY2UgPSB2b2lkIDA7XG4gICAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICAgIGxldCBvbGRJbmRleCA9IG9sZFN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3aXRjaCAob3BzW2ldKSB7XG4gICAgICAgICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgICAgICAgICAgaWYgKHNwbGljZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgICAgICAgICAgaWYgKHNwbGljZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFRElUX0FERDpcbiAgICAgICAgICAgICAgICBpZiAoc3BsaWNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgICAgICAgICAgaWYgKHNwbGljZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBubyBkZWZhdWx0XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwbGljZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaWNlcztcbn1cbmNvbnN0ICRwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5mdW5jdGlvbiBtZXJnZVNwbGljZShzcGxpY2VzLCBpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCkge1xuICAgIGNvbnN0IHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCk7XG4gICAgbGV0IGluc2VydGVkID0gZmFsc2U7XG4gICAgbGV0IGluc2VydGlvbk9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzcGxpY2VzW2ldO1xuICAgICAgICBjdXJyZW50LmluZGV4ICs9IGluc2VydGlvbk9mZnNldDtcbiAgICAgICAgaWYgKGluc2VydGVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcnNlY3RDb3VudCA9IGludGVyc2VjdChzcGxpY2UuaW5kZXgsIHNwbGljZS5pbmRleCArIHNwbGljZS5yZW1vdmVkLmxlbmd0aCwgY3VycmVudC5pbmRleCwgY3VycmVudC5pbmRleCArIGN1cnJlbnQuYWRkZWRDb3VudCk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RDb3VudCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB0aGUgdHdvIHNwbGljZXNcbiAgICAgICAgICAgIHNwbGljZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgaW5zZXJ0aW9uT2Zmc2V0IC09IGN1cnJlbnQuYWRkZWRDb3VudCAtIGN1cnJlbnQucmVtb3ZlZC5sZW5ndGg7XG4gICAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCArPSBjdXJyZW50LmFkZGVkQ291bnQgLSBpbnRlcnNlY3RDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUNvdW50ID0gc3BsaWNlLnJlbW92ZWQubGVuZ3RoICsgY3VycmVudC5yZW1vdmVkLmxlbmd0aCAtIGludGVyc2VjdENvdW50O1xuICAgICAgICAgICAgaWYgKCFzcGxpY2UuYWRkZWRDb3VudCAmJiAhZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyBtZXJnZWQgc3BsaWNlIGlzIGEgbm9vcC4gZGlzY2FyZC5cbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFJlbW92ZWQgPSBjdXJyZW50LnJlbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGljZS5pbmRleCA8IGN1cnJlbnQuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBwcmVmaXggb2Ygc3BsaWNlLnJlbW92ZWQgaXMgcHJlcGVuZGVkIHRvIGN1cnJlbnQucmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlcGVuZCA9IHNwbGljZS5yZW1vdmVkLnNsaWNlKDAsIGN1cnJlbnQuaW5kZXggLSBzcGxpY2UuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAkcHVzaC5hcHBseShwcmVwZW5kLCBjdXJyZW50UmVtb3ZlZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZW1vdmVkID0gcHJlcGVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwbGljZS5pbmRleCArIHNwbGljZS5yZW1vdmVkLmxlbmd0aCA+XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuaW5kZXggKyBjdXJyZW50LmFkZGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBzdWZmaXggb2Ygc3BsaWNlLnJlbW92ZWQgaXMgYXBwZW5kZWQgdG8gY3VycmVudC5yZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHBlbmQgPSBzcGxpY2UucmVtb3ZlZC5zbGljZShjdXJyZW50LmluZGV4ICsgY3VycmVudC5hZGRlZENvdW50IC0gc3BsaWNlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgJHB1c2guYXBwbHkoY3VycmVudFJlbW92ZWQsIGFwcGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGljZS5yZW1vdmVkID0gY3VycmVudFJlbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuaW5kZXggPCBzcGxpY2UuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BsaWNlLmluZGV4IDwgY3VycmVudC5pbmRleCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHNwbGljZSBoZXJlLlxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3BsaWNlcy5zcGxpY2UoaSwgMCwgc3BsaWNlKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHNwbGljZS5hZGRlZENvdW50IC0gc3BsaWNlLnJlbW92ZWQubGVuZ3RoO1xuICAgICAgICAgICAgY3VycmVudC5pbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBpbnNlcnRpb25PZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0ZWQpIHtcbiAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFNwbGljZXMoY2hhbmdlUmVjb3Jkcykge1xuICAgIGNvbnN0IHNwbGljZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGFuZ2VSZWNvcmRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gY2hhbmdlUmVjb3Jkc1tpXTtcbiAgICAgICAgbWVyZ2VTcGxpY2Uoc3BsaWNlcywgcmVjb3JkLmluZGV4LCByZWNvcmQucmVtb3ZlZCwgcmVjb3JkLmFkZGVkQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaWNlcztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0QXJyYXlTcGxpY2VzKGFycmF5LCBjaGFuZ2VSZWNvcmRzKSB7XG4gICAgbGV0IHNwbGljZXMgPSBbXTtcbiAgICBjb25zdCBpbml0aWFsU3BsaWNlcyA9IGNyZWF0ZUluaXRpYWxTcGxpY2VzKGNoYW5nZVJlY29yZHMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGluaXRpYWxTcGxpY2VzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc3BsaWNlID0gaW5pdGlhbFNwbGljZXNbaV07XG4gICAgICAgIGlmIChzcGxpY2UuYWRkZWRDb3VudCA9PT0gMSAmJiBzcGxpY2UucmVtb3ZlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChzcGxpY2UucmVtb3ZlZFswXSAhPT0gYXJyYXlbc3BsaWNlLmluZGV4XSkge1xuICAgICAgICAgICAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaWNlcyA9IHNwbGljZXMuY29uY2F0KGNhbGNTcGxpY2VzKGFycmF5LCBzcGxpY2UuaW5kZXgsIHNwbGljZS5pbmRleCArIHNwbGljZS5hZGRlZENvdW50LCBzcGxpY2UucmVtb3ZlZCwgMCwgc3BsaWNlLnJlbW92ZWQubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpY2VzO1xufVxuIiwiaW1wb3J0IHsgRE9NIH0gZnJvbSBcIi4uL2RvbS5qc1wiO1xuaW1wb3J0IHsgY2FsY1NwbGljZXMsIG5ld1NwbGljZSwgcHJvamVjdEFycmF5U3BsaWNlcyB9IGZyb20gXCIuL2FycmF5LWNoYW5nZS1yZWNvcmRzLmpzXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyU2V0IH0gZnJvbSBcIi4vbm90aWZpZXIuanNcIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiLi9vYnNlcnZhYmxlLmpzXCI7XG5sZXQgYXJyYXlPYnNlcnZhdGlvbkVuYWJsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGFkanVzdEluZGV4KGNoYW5nZVJlY29yZCwgYXJyYXkpIHtcbiAgICBsZXQgaW5kZXggPSBjaGFuZ2VSZWNvcmQuaW5kZXg7XG4gICAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID4gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSBhcnJheUxlbmd0aCAtIGNoYW5nZVJlY29yZC5hZGRlZENvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPVxuICAgICAgICAgICAgYXJyYXlMZW5ndGggKyBjaGFuZ2VSZWNvcmQucmVtb3ZlZC5sZW5ndGggKyBpbmRleCAtIGNoYW5nZVJlY29yZC5hZGRlZENvdW50O1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gICAgY2hhbmdlUmVjb3JkLmluZGV4ID0gaW5kZXg7XG4gICAgcmV0dXJuIGNoYW5nZVJlY29yZDtcbn1cbmNsYXNzIEFycmF5T2JzZXJ2ZXIgZXh0ZW5kcyBTdWJzY3JpYmVyU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgdGhpcy5vbGRDb2xsZWN0aW9uID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnNwbGljZXMgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubmVlZHNRdWV1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbCA9IHRoaXMuZmx1c2g7XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoc291cmNlLCBcIiRmYXN0Q29udHJvbGxlclwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcyxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICBzdXBlci5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfVxuICAgIGFkZFNwbGljZShzcGxpY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BsaWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZXMgPSBbc3BsaWNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmVlZHNRdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5uZWVkc1F1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICBET00ucXVldWVVcGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQob2xkQ29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLm9sZENvbGxlY3Rpb24gPSBvbGRDb2xsZWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5uZWVkc1F1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUXVldWUgPSBmYWxzZTtcbiAgICAgICAgICAgIERPTS5xdWV1ZVVwZGF0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgY29uc3Qgc3BsaWNlcyA9IHRoaXMuc3BsaWNlcztcbiAgICAgICAgY29uc3Qgb2xkQ29sbGVjdGlvbiA9IHRoaXMub2xkQ29sbGVjdGlvbjtcbiAgICAgICAgaWYgKHNwbGljZXMgPT09IHZvaWQgMCAmJiBvbGRDb2xsZWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5lZWRzUXVldWUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNwbGljZXMgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2xkQ29sbGVjdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmluYWxTcGxpY2VzID0gb2xkQ29sbGVjdGlvbiA9PT0gdm9pZCAwXG4gICAgICAgICAgICA/IHByb2plY3RBcnJheVNwbGljZXModGhpcy5zb3VyY2UsIHNwbGljZXMpXG4gICAgICAgICAgICA6IGNhbGNTcGxpY2VzKHRoaXMuc291cmNlLCAwLCB0aGlzLnNvdXJjZS5sZW5ndGgsIG9sZENvbGxlY3Rpb24sIDAsIG9sZENvbGxlY3Rpb24ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoZmluYWxTcGxpY2VzKTtcbiAgICB9XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZSAqL1xuLyoqXG4gKiBFbmFibGVzIHRoZSBhcnJheSBvYnNlcnZhdGlvbiBtZWNoYW5pc20uXG4gKiBAcmVtYXJrc1xuICogQXJyYXkgb2JzZXJ2YXRpb24gaXMgZW5hYmxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdXNpbmcgdGhlXG4gKiB7QGxpbmsgUmVwZWF0RGlyZWN0aXZlfSwgc28gY2FsbGluZyB0aGlzIEFQSSBtYW51YWxseSBpc1xuICogbm90IHR5cGljYWxseSBuZWNlc3NhcnkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVBcnJheU9ic2VydmF0aW9uKCkge1xuICAgIGlmIChhcnJheU9ic2VydmF0aW9uRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFycmF5T2JzZXJ2YXRpb25FbmFibGVkID0gdHJ1ZTtcbiAgICBPYnNlcnZhYmxlLnNldEFycmF5T2JzZXJ2ZXJGYWN0b3J5KChjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZlcihjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICAvLyBEb24ndCBwYXRjaCBBcnJheSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHBhdGNoZWRcbiAgICAvLyBieSBhbm90aGVyIGNvcHkgb2YgZmFzdC1lbGVtZW50LlxuICAgIGlmIChwcm90by4kZmFzdFBhdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCIkZmFzdFBhdGNoXCIsIHtcbiAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHBvcCA9IHByb3RvLnBvcDtcbiAgICBjb25zdCBwdXNoID0gcHJvdG8ucHVzaDtcbiAgICBjb25zdCByZXZlcnNlID0gcHJvdG8ucmV2ZXJzZTtcbiAgICBjb25zdCBzaGlmdCA9IHByb3RvLnNoaWZ0O1xuICAgIGNvbnN0IHNvcnQgPSBwcm90by5zb3J0O1xuICAgIGNvbnN0IHNwbGljZSA9IHByb3RvLnNwbGljZTtcbiAgICBjb25zdCB1bnNoaWZ0ID0gcHJvdG8udW5zaGlmdDtcbiAgICBwcm90by5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vdEVtcHR5ID0gdGhpcy5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBtZXRob2RDYWxsUmVzdWx0ID0gcG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRmYXN0Q29udHJvbGxlcjtcbiAgICAgICAgaWYgKG8gIT09IHZvaWQgMCAmJiBub3RFbXB0eSkge1xuICAgICAgICAgICAgby5hZGRTcGxpY2UobmV3U3BsaWNlKHRoaXMubGVuZ3RoLCBbbWV0aG9kQ2FsbFJlc3VsdF0sIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kQ2FsbFJlc3VsdDtcbiAgICB9O1xuICAgIHByb3RvLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZENhbGxSZXN1bHQgPSBwdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRmYXN0Q29udHJvbGxlcjtcbiAgICAgICAgaWYgKG8gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgby5hZGRTcGxpY2UoYWRqdXN0SW5kZXgobmV3U3BsaWNlKHRoaXMubGVuZ3RoIC0gYXJndW1lbnRzLmxlbmd0aCwgW10sIGFyZ3VtZW50cy5sZW5ndGgpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZENhbGxSZXN1bHQ7XG4gICAgfTtcbiAgICBwcm90by5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgb2xkQXJyYXk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRmYXN0Q29udHJvbGxlcjtcbiAgICAgICAgaWYgKG8gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgby5mbHVzaCgpO1xuICAgICAgICAgICAgb2xkQXJyYXkgPSB0aGlzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kQ2FsbFJlc3VsdCA9IHJldmVyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG8gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgby5yZXNldChvbGRBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZENhbGxSZXN1bHQ7XG4gICAgfTtcbiAgICBwcm90by5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm90RW1wdHkgPSB0aGlzLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IG1ldGhvZENhbGxSZXN1bHQgPSBzaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kZmFzdENvbnRyb2xsZXI7XG4gICAgICAgIGlmIChvICE9PSB2b2lkIDAgJiYgbm90RW1wdHkpIHtcbiAgICAgICAgICAgIG8uYWRkU3BsaWNlKG5ld1NwbGljZSgwLCBbbWV0aG9kQ2FsbFJlc3VsdF0sIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kQ2FsbFJlc3VsdDtcbiAgICB9O1xuICAgIHByb3RvLnNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBvbGRBcnJheTtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuJGZhc3RDb250cm9sbGVyO1xuICAgICAgICBpZiAobyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvLmZsdXNoKCk7XG4gICAgICAgICAgICBvbGRBcnJheSA9IHRoaXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2RDYWxsUmVzdWx0ID0gc29ydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAobyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvLnJlc2V0KG9sZEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kQ2FsbFJlc3VsdDtcbiAgICB9O1xuICAgIHByb3RvLnNwbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kQ2FsbFJlc3VsdCA9IHNwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kZmFzdENvbnRyb2xsZXI7XG4gICAgICAgIGlmIChvICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG8uYWRkU3BsaWNlKGFkanVzdEluZGV4KG5ld1NwbGljZSgrYXJndW1lbnRzWzBdLCBtZXRob2RDYWxsUmVzdWx0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50cy5sZW5ndGggLSAyIDogMCksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kQ2FsbFJlc3VsdDtcbiAgICB9O1xuICAgIHByb3RvLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZENhbGxSZXN1bHQgPSB1bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRmYXN0Q29udHJvbGxlcjtcbiAgICAgICAgaWYgKG8gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgby5hZGRTcGxpY2UoYWRqdXN0SW5kZXgobmV3U3BsaWNlKDAsIFtdLCBhcmd1bWVudHMubGVuZ3RoKSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2RDYWxsUmVzdWx0O1xuICAgIH07XG59XG4vKiBlc2xpbnQtZW5hYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtZnVuY3Rpb24tcmV0dXJuLXR5cGUgKi9cbiIsIi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIE5vdGlmaWVyfSB0aGF0IGVmZmljaWVudGx5IGtlZXBzIHRyYWNrIG9mXG4gKiBzdWJzY3JpYmVycyBpbnRlcmVzdGVkIGluIGEgc3BlY2lmaWMgY2hhbmdlIG5vdGlmaWNhdGlvbiBvbiBhblxuICogb2JzZXJ2YWJsZSBzb3VyY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgc2V0IGlzIG9wdGltaXplZCBmb3IgdGhlIG1vc3QgY29tbW9uIHNjZW5hcmlvIG9mIDEgb3IgMiBzdWJzY3JpYmVycy5cbiAqIFdpdGggdGhpcyBpbiBtaW5kLCBpdCBjYW4gc3RvcmUgYSBzdWJzY3JpYmVyIGluIGFuIGludGVybmFsIGZpZWxkLCBhbGxvd2luZyBpdCB0byBhdm9pZCBBcnJheSNwdXNoIG9wZXJhdGlvbnMuXG4gKiBJZiB0aGUgc2V0IGV2ZXIgZXhjZWVkcyB0d28gc3Vic2NyaWJlcnMsIGl0IHVwZ3JhZGVzIHRvIGFuIGFycmF5IGF1dG9tYXRpY2FsbHkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVyU2V0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN1YnNjcmliZXJTZXQgZm9yIHRoZSBzcGVjaWZpZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgb2JqZWN0IHNvdXJjZSB0aGF0IHN1YnNjcmliZXJzIHdpbGwgcmVjZWl2ZSBub3RpZmljYXRpb25zIGZyb20uXG4gICAgICogQHBhcmFtIGluaXRpYWxTdWJzY3JpYmVyIC0gQW4gaW5pdGlhbCBzdWJzY3JpYmVyIHRvIGNoYW5nZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBpbml0aWFsU3Vic2NyaWJlcikge1xuICAgICAgICB0aGlzLnN1YjEgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc3ViMiA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5zcGlsbG92ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YjEgPSBpbml0aWFsU3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN1YnNjcmliZXIgaGFzIGJlZW4gYWRkZWQgdG8gdGhpcyBzZXQuXG4gICAgICogQHBhcmFtIHN1YnNjcmliZXIgLSBUaGUgc3Vic2NyaWJlciB0byB0ZXN0IGZvciBpbmNsdXNpb24gaW4gdGhpcyBzZXQuXG4gICAgICovXG4gICAgaGFzKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BpbGxvdmVyID09PSB2b2lkIDBcbiAgICAgICAgICAgID8gdGhpcy5zdWIxID09PSBzdWJzY3JpYmVyIHx8IHRoaXMuc3ViMiA9PT0gc3Vic2NyaWJlclxuICAgICAgICAgICAgOiB0aGlzLnNwaWxsb3Zlci5pbmRleE9mKHN1YnNjcmliZXIpICE9PSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBub3RpZmljYXRpb24gb2YgY2hhbmdlcyBpbiBhbiBvYmplY3QncyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIFRoZSBvYmplY3QgdGhhdCBpcyBzdWJzY3JpYmluZyBmb3IgY2hhbmdlIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBjb25zdCBzcGlsbG92ZXIgPSB0aGlzLnNwaWxsb3ZlcjtcbiAgICAgICAgaWYgKHNwaWxsb3ZlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoc3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdWIxID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YjEgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN1YjIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViMiA9IHN1YnNjcmliZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcGlsbG92ZXIgPSBbdGhpcy5zdWIxLCB0aGlzLnN1YjIsIHN1YnNjcmliZXJdO1xuICAgICAgICAgICAgdGhpcy5zdWIxID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5zdWIyID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzcGlsbG92ZXIuaW5kZXhPZihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzcGlsbG92ZXIucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBub3RpZmljYXRpb24gb2YgY2hhbmdlcyBpbiBhbiBvYmplY3QncyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIFRoZSBvYmplY3QgdGhhdCBpcyB1bnN1YnNjcmliaW5nIGZyb20gY2hhbmdlIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGNvbnN0IHNwaWxsb3ZlciA9IHRoaXMuc3BpbGxvdmVyO1xuICAgICAgICBpZiAoc3BpbGxvdmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YjEgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YjEgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN1YjIgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YjIgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNwaWxsb3Zlci5pbmRleE9mKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNwaWxsb3Zlci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVycy5cbiAgICAgKiBAcGFyYW0gYXJncyAtIERhdGEgcGFzc2VkIGFsb25nIHRvIHN1YnNjcmliZXJzIGR1cmluZyBub3RpZmljYXRpb24uXG4gICAgICovXG4gICAgbm90aWZ5KGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3BpbGxvdmVyID0gdGhpcy5zcGlsbG92ZXI7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc3BpbGxvdmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YjEgPSB0aGlzLnN1YjE7XG4gICAgICAgICAgICBjb25zdCBzdWIyID0gdGhpcy5zdWIyO1xuICAgICAgICAgICAgaWYgKHN1YjEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHN1YjEuaGFuZGxlQ2hhbmdlKHNvdXJjZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3ViMiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgc3ViMi5oYW5kbGVDaGFuZ2Uoc291cmNlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNwaWxsb3Zlci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3BpbGxvdmVyW2ldLmhhbmRsZUNoYW5nZShzb3VyY2UsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBOb3RpZmllciB0aGF0IGFsbG93cyBzdWJzY3JpYmVycyB0byBiZSBub3RpZmllZFxuICogb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBjaGFuZ2VzIG9uIGFuIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFByb3BlcnR5Q2hhbmdlTm90aWZpZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUHJvcGVydHlDaGFuZ2VOb3RpZmllciBmb3IgdGhlIHNwZWNpZmllZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBvYmplY3Qgc291cmNlIHRoYXQgc3Vic2NyaWJlcnMgd2lsbCByZWNlaXZlIG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICAgICAgICB0aGlzLnNvdXJjZVN1YnNjcmliZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVycywgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUsIHBhc3NlZCBhbG9uZyB0byBzdWJzY3JpYmVycyBkdXJpbmcgbm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIG5vdGlmeShwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuc3Vic2NyaWJlcnNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLm5vdGlmeShwcm9wZXJ0eU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuc291cmNlU3Vic2NyaWJlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub3RpZnkocHJvcGVydHlOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBub3RpZmljYXRpb24gb2YgY2hhbmdlcyBpbiBhbiBvYmplY3QncyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIFRoZSBvYmplY3QgdGhhdCBpcyBzdWJzY3JpYmluZyBmb3IgY2hhbmdlIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gcHJvcGVydHlUb1dhdGNoIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgdGhlIHN1YnNjcmliZXIgaXMgaW50ZXJlc3RlZCBpbiB3YXRjaGluZyBmb3IgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlciwgcHJvcGVydHlUb1dhdGNoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHByb3BlcnR5VG9XYXRjaCkge1xuICAgICAgICAgICAgbGV0IHN1YnNjcmliZXJzID0gdGhpcy5zdWJzY3JpYmVyc1twcm9wZXJ0eVRvV2F0Y2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzW3Byb3BlcnR5VG9XYXRjaF0gPSBzdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpYmVyU2V0KHRoaXMuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXJzLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3Vic2NyaWJlcnMgPVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuc291cmNlU3Vic2NyaWJlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTdWJzY3JpYmVyU2V0KHRoaXMuc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3Vic2NyaWJlcnMuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIG5vdGlmaWNhdGlvbiBvZiBjaGFuZ2VzIGluIGFuIG9iamVjdCdzIHN0YXRlLlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyIC0gVGhlIG9iamVjdCB0aGF0IGlzIHVuc3Vic2NyaWJpbmcgZnJvbSBjaGFuZ2Ugbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eVRvVW53YXRjaCAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZSBzdWJzY3JpYmVyIGlzIG5vIGxvbmdlciBpbnRlcmVzdGVkIGluIHdhdGNoaW5nLlxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIsIHByb3BlcnR5VG9VbndhdGNoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHByb3BlcnR5VG9VbndhdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuc3Vic2NyaWJlcnNbcHJvcGVydHlUb1Vud2F0Y2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc291cmNlU3Vic2NyaWJlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IERPTSB9IGZyb20gXCIuLi9kb20uanNcIjtcbmltcG9ydCB7IGNyZWF0ZU1ldGFkYXRhTG9jYXRvciwgRkFTVCB9IGZyb20gXCIuLi9wbGF0Zm9ybS5qc1wiO1xuaW1wb3J0IHsgUHJvcGVydHlDaGFuZ2VOb3RpZmllciwgU3Vic2NyaWJlclNldCB9IGZyb20gXCIuL25vdGlmaWVyLmpzXCI7XG4vKipcbiAqIENvbW1vbiBPYnNlcnZhYmxlIEFQSXMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBPYnNlcnZhYmxlID0gRkFTVC5nZXRCeUlkKDIgLyogb2JzZXJ2YWJsZSAqLywgKCkgPT4ge1xuICAgIGNvbnN0IHZvbGF0aWxlUmVnZXggPSAvKDp8JiZ8XFx8XFx8fGlmKS87XG4gICAgY29uc3Qgbm90aWZpZXJMb29rdXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHF1ZXVlVXBkYXRlID0gRE9NLnF1ZXVlVXBkYXRlO1xuICAgIGxldCB3YXRjaGVyID0gdm9pZCAwO1xuICAgIGxldCBjcmVhdGVBcnJheU9ic2VydmVyID0gKGFycmF5KSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgY2FsbCBlbmFibGVBcnJheU9ic2VydmF0aW9uIGJlZm9yZSBvYnNlcnZpbmcgYXJyYXlzLlwiKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldE5vdGlmaWVyKHNvdXJjZSkge1xuICAgICAgICBsZXQgZm91bmQgPSBzb3VyY2UuJGZhc3RDb250cm9sbGVyIHx8IG5vdGlmaWVyTG9va3VwLmdldChzb3VyY2UpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gY3JlYXRlQXJyYXlPYnNlcnZlcihzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90aWZpZXJMb29rdXAuc2V0KHNvdXJjZSwgKGZvdW5kID0gbmV3IFByb3BlcnR5Q2hhbmdlTm90aWZpZXIoc291cmNlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgY29uc3QgZ2V0QWNjZXNzb3JzID0gY3JlYXRlTWV0YWRhdGFMb2NhdG9yKCk7XG4gICAgY2xhc3MgRGVmYXVsdE9ic2VydmFibGVBY2Nlc3NvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gYF8ke25hbWV9YDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBgJHtuYW1lfUNoYW5nZWRgO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHdhdGNoZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHdhdGNoZXIud2F0Y2goc291cmNlLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVt0aGlzLmZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZShzb3VyY2UsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHNvdXJjZVtmaWVsZF07XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc291cmNlW2ZpZWxkXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gc291cmNlW3RoaXMuY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNvdXJjZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0Tm90aWZpZXIoc291cmNlKS5ub3RpZnkodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBCaW5kaW5nT2JzZXJ2ZXJJbXBsZW1lbnRhdGlvbiBleHRlbmRzIFN1YnNjcmliZXJTZXQge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaW5kaW5nLCBpbml0aWFsU3Vic2NyaWJlciwgaXNWb2xhdGlsZUJpbmRpbmcgPSBmYWxzZSkge1xuICAgICAgICAgICAgc3VwZXIoYmluZGluZywgaW5pdGlhbFN1YnNjcmliZXIpO1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICAgICAgICAgIHRoaXMuaXNWb2xhdGlsZUJpbmRpbmcgPSBpc1ZvbGF0aWxlQmluZGluZztcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNRdWV1ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5U291cmNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWVyID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmUoc291cmNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2ggJiYgdGhpcy5sYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1dhdGNoZXIgPSB3YXRjaGVyO1xuICAgICAgICAgICAgd2F0Y2hlciA9IHRoaXMubmVlZHNSZWZyZXNoID8gdGhpcyA6IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWZyZXNoID0gdGhpcy5pc1ZvbGF0aWxlQmluZGluZztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYmluZGluZyhzb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgd2F0Y2hlciA9IHByZXZpb3VzV2F0Y2hlcjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZmlyc3Q7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5vdGlmaWVyLnVuc3Vic2NyaWJlKHRoaXMsIGN1cnJlbnQucHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVmcmVzaCA9IHRoaXMubmVlZHNRdWV1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2F0Y2gocHJvcGVydHlTb3VyY2UsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMubGFzdDtcbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWVyID0gZ2V0Tm90aWZpZXIocHJvcGVydHlTb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHByZXYgPT09IG51bGwgPyB0aGlzLmZpcnN0IDoge307XG4gICAgICAgICAgICBjdXJyZW50LnByb3BlcnR5U291cmNlID0gcHJvcGVydHlTb3VyY2U7XG4gICAgICAgICAgICBjdXJyZW50LnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgICAgIGN1cnJlbnQubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgICAgIG5vdGlmaWVyLnN1YnNjcmliZSh0aGlzLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlY2xhcmluZyB0aGUgdmFyaWFibGUgcHJpb3IgdG8gYXNzaWdubWVudCBiZWxvdyBjaXJjdW12ZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBhIGJ1ZyBpbiBBbmd1bGFyJ3Mgb3B0aW1pemF0aW9uIHByb2Nlc3MgY2F1c2luZyBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyB3YXRjaCgpIG1ldGhvZC4gRGV0YWlscyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L2Zhc3QvaXNzdWVzLzQ5NjlcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovXG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZSA9IHByZXYucHJvcGVydHlTb3VyY2VbcHJldi5wcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMgKi9cbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNvdXJjZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNRdWV1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHF1ZXVlVXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1F1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzKCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmZpcnN0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yeSAtIFRoZSBmYWN0b3J5IHVzZWQgdG8gY3JlYXRlIGFycmF5IG9ic2VydmVycy5cbiAgICAgICAgICovXG4gICAgICAgIHNldEFycmF5T2JzZXJ2ZXJGYWN0b3J5KGZhY3RvcnkpIHtcbiAgICAgICAgICAgIGNyZWF0ZUFycmF5T2JzZXJ2ZXIgPSBmYWN0b3J5O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIG5vdGlmaWVyIGZvciBhbiBvYmplY3Qgb3IgQXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgb2JqZWN0IG9yIEFycmF5IHRvIGdldCB0aGUgbm90aWZpZXIgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Tm90aWZpZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvcmRzIGEgcHJvcGVydHkgY2hhbmdlIGZvciBhIHNvdXJjZSBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIHJlY29yZCB0aGUgY2hhbmdlIGFnYWluc3QuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgLSBUaGUgcHJvcGVydHkgdG8gdHJhY2sgYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRyYWNrKHNvdXJjZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBpZiAod2F0Y2hlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hlci53YXRjaChzb3VyY2UsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RpZmllcyB3YXRjaGVycyB0aGF0IHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByb3BlcnR5IGdldHRlciBvciBmdW5jdGlvbiBpcyB2b2xhdGlsZVxuICAgICAgICAgKiB3aXRoIHJlc3BlY3QgdG8gaXRzIG9ic2VydmFibGUgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhY2tWb2xhdGlsZSgpIHtcbiAgICAgICAgICAgIGlmICh3YXRjaGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB3YXRjaGVyLm5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RpZmllcyBzdWJzY3JpYmVycyBvZiBhIHNvdXJjZSBvYmplY3Qgb2YgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHNvdXJjZSAtIHRoZSBvYmplY3QgdG8gbm90aWZ5IG9mIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGNoYW5nZSBhcmdzIHRvIHBhc3MgdG8gc3Vic2NyaWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBub3RpZnkoc291cmNlLCBhcmdzKSB7XG4gICAgICAgICAgICBnZXROb3RpZmllcihzb3VyY2UpLm5vdGlmeShhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgYW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSBvbiBhbiBvYmplY3Qgb3IgcHJvdG90eXBlLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gZGVmaW5lIHRoZSBvYnNlcnZhYmxlIG9uLlxuICAgICAgICAgKiBAcGFyYW0gbmFtZU9yQWNjZXNzb3IgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZGVmaW5lIGFzIG9ic2VydmFibGU7XG4gICAgICAgICAqIG9yIGEgY3VzdG9tIGFjY2Vzc29yIHRoYXQgc3BlY2lmaWVzIHRoZSBwcm9wZXJ0eSBuYW1lIGFuZCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZU9yQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZU9yQWNjZXNzb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lT3JBY2Nlc3NvciA9IG5ldyBEZWZhdWx0T2JzZXJ2YWJsZUFjY2Vzc29yKG5hbWVPckFjY2Vzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEFjY2Vzc29ycyh0YXJnZXQpLnB1c2gobmFtZU9yQWNjZXNzb3IpO1xuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWVPckFjY2Vzc29yLm5hbWUsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZU9yQWNjZXNzb3IuZ2V0VmFsdWUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lT3JBY2Nlc3Nvci5zZXRWYWx1ZSh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgYWxsIHRoZSBvYnNlcnZhYmxlIGFjY2Vzc29ycyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQsXG4gICAgICAgICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gc2VhcmNoIGZvciBhY2Nlc3NvciBvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldEFjY2Vzc29ycyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgQmluZGluZ09ic2VydmVyfSB0aGF0IGNhbiB3YXRjaCB0aGVcbiAgICAgICAgICogcHJvdmlkZWQge0BsaW5rIEJpbmRpbmd9IGZvciBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0gYmluZGluZyAtIFRoZSBiaW5kaW5nIHRvIG9ic2VydmUuXG4gICAgICAgICAqIEBwYXJhbSBpbml0aWFsU3Vic2NyaWJlciAtIEFuIGluaXRpYWwgc3Vic2NyaWJlciB0byBjaGFuZ2VzIGluIHRoZSBiaW5kaW5nIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0gaXNWb2xhdGlsZUJpbmRpbmcgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYmluZGluZydzIGRlcGVuZGVuY3kgbGlzdCBtdXN0IGJlIHJlLWV2YWx1YXRlZCBvbiBldmVyeSB2YWx1ZSBldmFsdWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYmluZGluZyhiaW5kaW5nLCBpbml0aWFsU3Vic2NyaWJlciwgaXNWb2xhdGlsZUJpbmRpbmcgPSB0aGlzLmlzVm9sYXRpbGVCaW5kaW5nKGJpbmRpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPYnNlcnZlckltcGxlbWVudGF0aW9uKGJpbmRpbmcsIGluaXRpYWxTdWJzY3JpYmVyLCBpc1ZvbGF0aWxlQmluZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBiaW5kaW5nIGV4cHJlc3Npb24gaXMgdm9sYXRpbGUgYW5kIG5lZWRzIHRvIGhhdmUgaXRzIGRlcGVuZGVuY3kgbGlzdCByZS1ldmFsdWF0ZWRcbiAgICAgICAgICogb24gZXZlcnkgZXZhbHVhdGlvbiBvZiB0aGUgdmFsdWUuXG4gICAgICAgICAqIEBwYXJhbSBiaW5kaW5nIC0gVGhlIGJpbmRpbmcgdG8gaW5zcGVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGlzVm9sYXRpbGVCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2xhdGlsZVJlZ2V4LnRlc3QoYmluZGluZy50b1N0cmluZygpKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn0pO1xuLyoqXG4gKiBEZWNvcmF0b3I6IERlZmluZXMgYW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgdG8gZGVmaW5lIHRoZSBvYnNlcnZhYmxlIG9uLlxuICogQHBhcmFtIG5hbWVPckFjY2Vzc29yIC0gVGhlIHByb3BlcnR5IG5hbWUgb3IgYWNjZXNzb3IgdG8gZGVmaW5lIHRoZSBvYnNlcnZhYmxlIGFzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2YWJsZSh0YXJnZXQsIG5hbWVPckFjY2Vzc29yKSB7XG4gICAgT2JzZXJ2YWJsZS5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWVPckFjY2Vzc29yKTtcbn1cbi8qKlxuICogRGVjb3JhdG9yOiBNYXJrcyBhIHByb3BlcnR5IGdldHRlciBhcyBoYXZpbmcgdm9sYXRpbGUgb2JzZXJ2YWJsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0aGF0IHRoZSBwcm9wZXJ0eSBpcyBkZWZpbmVkIG9uLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIGV4aXN0aW5nIGRlc2NyaXB0b3IuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2b2xhdGlsZSh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvciwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9ic2VydmFibGUudHJhY2tWb2xhdGlsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuY29uc3QgY29udGV4dEV2ZW50ID0gRkFTVC5nZXRCeUlkKDMgLyogY29udGV4dEV2ZW50ICovLCAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQoZXZlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBldmVudDtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG4vKipcbiAqIFByb3ZpZGVzIGFkZGl0aW9uYWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhdmFpbGFibGUgdG8gYmVoYXZpb3JzIGFuZCBleHByZXNzaW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGl0ZW0gd2l0aGluIGEgcmVwZWF0IGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiB3aXRoaW4gYSByZXBlYXQgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJlbnQgZGF0YSBvYmplY3Qgd2l0aGluIGEgcmVwZWF0IGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyZW50IGV4ZWN1dGlvbiBjb250ZXh0IHdoZW4gaW4gbmVzdGVkIGNvbnRleHQgc2NlbmFyaW9zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZXZlbnQgd2l0aGluIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY29udGV4dEV2ZW50LmdldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBpdGVtIHdpdGhpbiBhIHJlcGVhdCBjb250ZXh0XG4gICAgICogaGFzIGFuIGV2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0IGlzRXZlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggJSAyID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBpdGVtIHdpdGhpbiBhIHJlcGVhdCBjb250ZXh0XG4gICAgICogaGFzIGFuIG9kZCBpbmRleC5cbiAgICAgKi9cbiAgICBnZXQgaXNPZGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ICUgMiAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgaXRlbSB3aXRoaW4gYSByZXBlYXQgY29udGV4dFxuICAgICAqIGlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBpc0ZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgaXRlbSB3aXRoaW4gYSByZXBlYXQgY29udGV4dFxuICAgICAqIGlzIHNvbWV3aGVyZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBpc0luTWlkZGxlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNGaXJzdCAmJiAhdGhpcy5pc0xhc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjdXJyZW50IGl0ZW0gd2l0aGluIGEgcmVwZWF0IGNvbnRleHRcbiAgICAgKiBpcyB0aGUgbGFzdCBpdGVtIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBpc0xhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV2ZW50IGZvciB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gc2V0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRFdmVudChldmVudCkge1xuICAgICAgICBjb250ZXh0RXZlbnQuc2V0KGV2ZW50KTtcbiAgICB9XG59XG5PYnNlcnZhYmxlLmRlZmluZVByb3BlcnR5KEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLCBcImluZGV4XCIpO1xuT2JzZXJ2YWJsZS5kZWZpbmVQcm9wZXJ0eShFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZSwgXCJsZW5ndGhcIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGV4ZWN1dGlvbiBjb250ZXh0IHVzZWQgaW4gYmluZGluZyBleHByZXNzaW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRFeGVjdXRpb25Db250ZXh0ID0gT2JqZWN0LnNlYWwobmV3IEV4ZWN1dGlvbkNvbnRleHQoKSk7XG4iLCIvKipcbiAqIEEgcmVmZXJlbmNlIHRvIGdsb2JhbFRoaXMsIHdpdGggc3VwcG9ydFxuICogZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3QgeWV0IHN1cHBvcnQgdGhlIHNwZWMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCAkZ2xvYmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiBhIG1vZGVybiBlbnZpcm9ubWVudC5cbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gTm9kZUpTXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBXZSdyZSBydW5uaW5nIGluIGEgd29ya2VyLlxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgYnJvd3NlcidzIG1haW4gdGhyZWFkLlxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBIb3BlZnVsbHkgd2UgbmV2ZXIgZ2V0IGhlcmUuLi5cbiAgICAgICAgLy8gTm90IGFsbCBlbnZpcm9ubWVudHMgYWxsb3cgZXZhbCBhbmQgRnVuY3Rpb24uIFVzZSBvbmx5IGFzIGEgbGFzdCByZXNvcnQ6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIC8vIElmIGFsbCBmYWlscywgZ2l2ZSB1cCBhbmQgY3JlYXRlIGFuIG9iamVjdC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufSkoKTtcbi8vIEFQSS1vbmx5IFBvbHlmaWxsIGZvciB0cnVzdGVkVHlwZXNcbmlmICgkZ2xvYmFsLnRydXN0ZWRUeXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgJGdsb2JhbC50cnVzdGVkVHlwZXMgPSB7IGNyZWF0ZVBvbGljeTogKG4sIHIpID0+IHIgfTtcbn1cbmNvbnN0IHByb3BDb25maWcgPSB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG59O1xuaWYgKCRnbG9iYWwuRkFTVCA9PT0gdm9pZCAwKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSgkZ2xvYmFsLCBcIkZBU1RcIiwgT2JqZWN0LmFzc2lnbih7IHZhbHVlOiBPYmplY3QuY3JlYXRlKG51bGwpIH0sIHByb3BDb25maWcpKTtcbn1cbi8qKlxuICogVGhlIEZBU1QgZ2xvYmFsLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBGQVNUID0gJGdsb2JhbC5GQVNUO1xuaWYgKEZBU1QuZ2V0QnlJZCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShGQVNULCBcImdldEJ5SWRcIiwgT2JqZWN0LmFzc2lnbih7IHZhbHVlKGlkLCBpbml0aWFsaXplKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBzdG9yYWdlW2lkXTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBpbml0aWFsaXplID8gKHN0b3JhZ2VbaWRdID0gaW5pdGlhbGl6ZSgpKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH0gfSwgcHJvcENvbmZpZykpO1xufVxuLyoqXG4gKiBBIHJlYWRvbmx5LCBlbXB0eSBhcnJheS5cbiAqIEByZW1hcmtzXG4gKiBUeXBpY2FsbHkgcmV0dXJuZWQgYnkgQVBJcyB0aGF0IHJldHVybiBhcnJheXMgd2hlbiB0aGVyZSBhcmVcbiAqIG5vIGFjdHVhbCBpdGVtcyB0byByZXR1cm4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplKFtdKTtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGNhcGFibGUgb2YgbG9jYXRpbmcgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgdHlwZS5cbiAqIEByZXR1cm5zIEEgbWV0YWRhdGEgbG9jYXRvciBmdW5jdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGFMb2NhdG9yKCkge1xuICAgIGNvbnN0IG1ldGFkYXRhTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBsZXQgbWV0YWRhdGEgPSBtZXRhZGF0YUxvb2t1cC5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKG1ldGFkYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1ldGFkYXRhID09PSB2b2lkIDAgJiYgY3VycmVudFRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFMb29rdXAuZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YSA9PT0gdm9pZCAwID8gW10gOiBtZXRhZGF0YS5zbGljZSgwKTtcbiAgICAgICAgICAgIG1ldGFkYXRhTG9va3VwLnNldCh0YXJnZXQsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfTtcbn1cbiIsIi8qKlxuICogRGlyZWN0aXZlIGZvciB1c2UgaW4ge0BsaW5rIGNzc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ1NTRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQ1NTIGZyYWdtZW50IHRvIGludGVycG9sYXRlIGludG8gdGhlIENTUyBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyAtIHRoZSBzdHJpbmcgdG8gaW50ZXJwb2xhdGUgaW50byBDU1NcbiAgICAgKi9cbiAgICBjcmVhdGVDU1MoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmVoYXZpb3IgdG8gYmluZCB0byB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIC0gdGhlIGJlaGF2aW9yIHRvIGJpbmQgdG8gdGhlIGhvc3QgZWxlbWVudCwgb3IgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGNyZWF0ZUJlaGF2aW9yKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENTU0RpcmVjdGl2ZSB9IGZyb20gXCIuL2Nzcy1kaXJlY3RpdmUuanNcIjtcbmltcG9ydCB7IEVsZW1lbnRTdHlsZXMgfSBmcm9tIFwiLi9lbGVtZW50LXN0eWxlcy5qc1wiO1xuZnVuY3Rpb24gY29sbGVjdFN0eWxlcyhzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICBsZXQgY3NzU3RyaW5nID0gXCJcIjtcbiAgICBjb25zdCBiZWhhdmlvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHJpbmdzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNzc1N0cmluZyArPSBzdHJpbmdzW2ldO1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENTU0RpcmVjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgYmVoYXZpb3IgPSB2YWx1ZS5jcmVhdGVCZWhhdmlvcigpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jcmVhdGVDU1MoKTtcbiAgICAgICAgICAgIGlmIChiZWhhdmlvcikge1xuICAgICAgICAgICAgICAgIGJlaGF2aW9ycy5wdXNoKGJlaGF2aW9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50U3R5bGVzIHx8IHZhbHVlIGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldCkge1xuICAgICAgICAgICAgaWYgKGNzc1N0cmluZy50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChjc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGNzc1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjc3NTdHJpbmcgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3NzU3RyaW5nICs9IHN0cmluZ3Nbc3RyaW5ncy5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3NzU3RyaW5nLnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICBzdHlsZXMucHVzaChjc3NTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZXMsXG4gICAgICAgIGJlaGF2aW9ycyxcbiAgICB9O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgdGVtcGxhdGUgbGl0ZXJhbCBzdHJpbmcgaW50byBzdHlsZXMuXG4gKiBAcGFyYW0gc3RyaW5ncyAtIFRoZSBzdHJpbmcgZnJhZ21lbnRzIHRoYXQgYXJlIGludGVycG9sYXRlZCB3aXRoIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgd2l0aCB0aGUgc3RyaW5nIGZyYWdtZW50cy5cbiAqIEByZW1hcmtzXG4gKiBUaGUgY3NzIGhlbHBlciBzdXBwb3J0cyBpbnRlcnBvbGF0aW9uIG9mIHN0cmluZ3MgYW5kIEVsZW1lbnRTdHlsZSBpbnN0YW5jZXMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjc3Moc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gICAgY29uc3QgeyBzdHlsZXMsIGJlaGF2aW9ycyB9ID0gY29sbGVjdFN0eWxlcyhzdHJpbmdzLCB2YWx1ZXMpO1xuICAgIGNvbnN0IGVsZW1lbnRTdHlsZXMgPSBFbGVtZW50U3R5bGVzLmNyZWF0ZShzdHlsZXMpO1xuICAgIGlmIChiZWhhdmlvcnMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnRTdHlsZXMud2l0aEJlaGF2aW9ycyguLi5iZWhhdmlvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudFN0eWxlcztcbn1cbmNsYXNzIENTU1BhcnRpYWwgZXh0ZW5kcyBDU1NEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHN0eWxlcywgYmVoYXZpb3JzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID0gYmVoYXZpb3JzO1xuICAgICAgICB0aGlzLmNzcyA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHN0eWxlc2hlZXRzID0gc3R5bGVzLnJlZHVjZSgoYWNjdW11bGF0ZWQsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3NzICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGlmIChzdHlsZXNoZWV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gRWxlbWVudFN0eWxlcy5jcmVhdGUoc3R5bGVzaGVldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUJlaGF2aW9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY3JlYXRlQ1NTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgfVxuICAgIGJpbmQoZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzKSB7XG4gICAgICAgICAgICBlbC4kZmFzdENvbnRyb2xsZXIuYWRkU3R5bGVzKHRoaXMuc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iZWhhdmlvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbC4kZmFzdENvbnRyb2xsZXIuYWRkQmVoYXZpb3JzKHRoaXMuYmVoYXZpb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmQoZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzKSB7XG4gICAgICAgICAgICBlbC4kZmFzdENvbnRyb2xsZXIucmVtb3ZlU3R5bGVzKHRoaXMuc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iZWhhdmlvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbC4kZmFzdENvbnRyb2xsZXIucmVtb3ZlQmVoYXZpb3JzKHRoaXMuYmVoYXZpb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhIHRlbXBsYXRlIGxpdGVyYWwgc3RyaW5nIGludG8gcGFydGlhbCBDU1MuXG4gKiBAcGFyYW0gc3RyaW5ncyAtIFRoZSBzdHJpbmcgZnJhZ21lbnRzIHRoYXQgYXJlIGludGVycG9sYXRlZCB3aXRoIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgd2l0aCB0aGUgc3RyaW5nIGZyYWdtZW50cy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNzc1BhcnRpYWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gICAgY29uc3QgeyBzdHlsZXMsIGJlaGF2aW9ycyB9ID0gY29sbGVjdFN0eWxlcyhzdHJpbmdzLCB2YWx1ZXMpO1xuICAgIHJldHVybiBuZXcgQ1NTUGFydGlhbChzdHlsZXMsIGJlaGF2aW9ycyk7XG59XG4iLCJpbXBvcnQgeyBET00gfSBmcm9tIFwiLi4vZG9tLmpzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgc3R5bGVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSBjdXN0b20gZWxlbWVudC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVsZW1lbnRTdHlsZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBuZXcgV2Vha1NldCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYWRkU3R5bGVzVG8odGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5hZGQodGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHJlbW92ZVN0eWxlc0Zyb20odGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5kZWxldGUodGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGlzQXR0YWNoZWRUbyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cy5oYXModGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlcyBiZWhhdmlvcnMgd2l0aCB0aGlzIHNldCBvZiBzdHlsZXMuXG4gICAgICogQHBhcmFtIGJlaGF2aW9ycyAtIFRoZSBiZWhhdmlvcnMgdG8gYXNzb2NpYXRlLlxuICAgICAqL1xuICAgIHdpdGhCZWhhdmlvcnMoLi4uYmVoYXZpb3JzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID1cbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JzID09PSBudWxsID8gYmVoYXZpb3JzIDogdGhpcy5iZWhhdmlvcnMuY29uY2F0KGJlaGF2aW9ycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIEVsZW1lbnRTdHlsZXMgZnJvbSBDb21wb3NhYmxlU3R5bGVzLlxuICovXG5FbGVtZW50U3R5bGVzLmNyZWF0ZSA9ICgoKSA9PiB7XG4gICAgaWYgKERPTS5zdXBwb3J0c0Fkb3B0ZWRTdHlsZVNoZWV0cykge1xuICAgICAgICBjb25zdCBzdHlsZVNoZWV0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiAoc3R5bGVzKSA9PiBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgQWRvcHRlZFN0eWxlU2hlZXRzU3R5bGVzKHN0eWxlcywgc3R5bGVTaGVldENhY2hlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIHJldHVybiAoc3R5bGVzKSA9PiBuZXcgU3R5bGVFbGVtZW50U3R5bGVzKHN0eWxlcyk7XG59KSgpO1xuZnVuY3Rpb24gcmVkdWNlU3R5bGVzKHN0eWxlcykge1xuICAgIHJldHVybiBzdHlsZXNcbiAgICAgICAgLm1hcCgoeCkgPT4geCBpbnN0YW5jZW9mIEVsZW1lbnRTdHlsZXMgPyByZWR1Y2VTdHlsZXMoeC5zdHlsZXMpIDogW3hdKVxuICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2LmNvbmNhdChjdXJyKSwgW10pO1xufVxuZnVuY3Rpb24gcmVkdWNlQmVoYXZpb3JzKHN0eWxlcykge1xuICAgIHJldHVybiBzdHlsZXNcbiAgICAgICAgLm1hcCgoeCkgPT4gKHggaW5zdGFuY2VvZiBFbGVtZW50U3R5bGVzID8geC5iZWhhdmlvcnMgOiBudWxsKSlcbiAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXYgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldi5jb25jYXQoY3Vycik7XG4gICAgfSwgbnVsbCk7XG59XG5sZXQgYWRkQWRvcHRlZFN0eWxlU2hlZXRzID0gKHRhcmdldCwgc2hlZXRzKSA9PiB7XG4gICAgdGFyZ2V0LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFsuLi50YXJnZXQuYWRvcHRlZFN0eWxlU2hlZXRzLCAuLi5zaGVldHNdO1xufTtcbmxldCByZW1vdmVBZG9wdGVkU3R5bGVTaGVldHMgPSAodGFyZ2V0LCBzaGVldHMpID0+IHtcbiAgICB0YXJnZXQuYWRvcHRlZFN0eWxlU2hlZXRzID0gdGFyZ2V0LmFkb3B0ZWRTdHlsZVNoZWV0cy5maWx0ZXIoKHgpID0+IHNoZWV0cy5pbmRleE9mKHgpID09PSAtMSk7XG59O1xuaWYgKERPTS5zdXBwb3J0c0Fkb3B0ZWRTdHlsZVNoZWV0cykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRlc3QgaWYgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiB1c2VzIEZyb3plbkFycmF5LlxuICAgICAgICAvLyBJZiBub3QsIHVzZSBwdXNoIC8gc3BsaWNlIHRvIGFsdGVyIHRoZSBzdHlsZXNoZWV0c1xuICAgICAgICAvLyBpbiBwbGFjZS4gVGhpcyBjaXJjdW12ZW50cyBhIGJ1ZyBpbiBTYWZhcmkgMTYuNCB3aGVyZVxuICAgICAgICAvLyBwZXJpb2RpY2FsbHksIGFzc2lnbmluZyB0aGUgYXJyYXkgd291bGQgcHJldmlvdXNseVxuICAgICAgICAvLyBjYXVzZSBzaGVldHMgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLnB1c2goKTtcbiAgICAgICAgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLnNwbGljZSgpO1xuICAgICAgICBhZGRBZG9wdGVkU3R5bGVTaGVldHMgPSAodGFyZ2V0LCBzaGVldHMpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5hZG9wdGVkU3R5bGVTaGVldHMucHVzaCguLi5zaGVldHMpO1xuICAgICAgICB9O1xuICAgICAgICByZW1vdmVBZG9wdGVkU3R5bGVTaGVldHMgPSAodGFyZ2V0LCBzaGVldHMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2hlZXQgb2Ygc2hlZXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0YXJnZXQuYWRvcHRlZFN0eWxlU2hlZXRzLmluZGV4T2Yoc2hlZXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFkb3B0ZWRTdHlsZVNoZWV0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBhbiBlcnJvciBpcyB0aHJvd24sIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGNhc2UgaGFuZGxlcyBGcm96ZW5BcnJheS5cbiAgICB9XG59XG4vKipcbiAqIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29uc3RydWN0LXN0eWxlc2hlZXRzL1xuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxOS8wMi9jb25zdHJ1Y3RhYmxlLXN0eWxlc2hlZXRzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXMgZXh0ZW5kcyBFbGVtZW50U3R5bGVzIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZXMsIHN0eWxlU2hlZXRDYWNoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5zdHlsZVNoZWV0Q2FjaGUgPSBzdHlsZVNoZWV0Q2FjaGU7XG4gICAgICAgIHRoaXMuX3N0eWxlU2hlZXRzID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmJlaGF2aW9ycyA9IHJlZHVjZUJlaGF2aW9ycyhzdHlsZXMpO1xuICAgIH1cbiAgICBnZXQgc3R5bGVTaGVldHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZVNoZWV0cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcztcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlU2hlZXRDYWNoZSA9IHRoaXMuc3R5bGVTaGVldENhY2hlO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVTaGVldHMgPSByZWR1Y2VTdHlsZXMoc3R5bGVzKS5tYXAoKHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzaGVldCA9IHN0eWxlU2hlZXRDYWNoZS5nZXQoeCk7XG4gICAgICAgICAgICAgICAgaWYgKHNoZWV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgICAgICAgICBzaGVldC5yZXBsYWNlU3luYyh4KTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldENhY2hlLnNldCh4LCBzaGVldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzaGVldDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZVNoZWV0cztcbiAgICB9XG4gICAgYWRkU3R5bGVzVG8odGFyZ2V0KSB7XG4gICAgICAgIGFkZEFkb3B0ZWRTdHlsZVNoZWV0cyh0YXJnZXQsIHRoaXMuc3R5bGVTaGVldHMpO1xuICAgICAgICBzdXBlci5hZGRTdHlsZXNUbyh0YXJnZXQpO1xuICAgIH1cbiAgICByZW1vdmVTdHlsZXNGcm9tKHRhcmdldCkge1xuICAgICAgICByZW1vdmVBZG9wdGVkU3R5bGVTaGVldHModGFyZ2V0LCB0aGlzLnN0eWxlU2hlZXRzKTtcbiAgICAgICAgc3VwZXIucmVtb3ZlU3R5bGVzRnJvbSh0YXJnZXQpO1xuICAgIH1cbn1cbmxldCBzdHlsZUNsYXNzSWQgPSAwO1xuZnVuY3Rpb24gZ2V0TmV4dFN0eWxlQ2xhc3MoKSB7XG4gICAgcmV0dXJuIGBmYXN0LXN0eWxlLWNsYXNzLSR7KytzdHlsZUNsYXNzSWR9YDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHlsZUVsZW1lbnRTdHlsZXMgZXh0ZW5kcyBFbGVtZW50U3R5bGVzIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5iZWhhdmlvcnMgPSByZWR1Y2VCZWhhdmlvcnMoc3R5bGVzKTtcbiAgICAgICAgdGhpcy5zdHlsZVNoZWV0cyA9IHJlZHVjZVN0eWxlcyhzdHlsZXMpO1xuICAgICAgICB0aGlzLnN0eWxlQ2xhc3MgPSBnZXROZXh0U3R5bGVDbGFzcygpO1xuICAgIH1cbiAgICBhZGRTdHlsZXNUbyh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVTaGVldHMgPSB0aGlzLnN0eWxlU2hlZXRzO1xuICAgICAgICBjb25zdCBzdHlsZUNsYXNzID0gdGhpcy5zdHlsZUNsYXNzO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZVNoZWV0c1tpXTtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gc3R5bGVDbGFzcztcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYWRkU3R5bGVzVG8odGFyZ2V0KTtcbiAgICB9XG4gICAgcmVtb3ZlU3R5bGVzRnJvbSh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5ub3JtYWxpemVUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3RoaXMuc3R5bGVDbGFzc31gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3R5bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZChzdHlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlbW92ZVN0eWxlc0Zyb20odGFyZ2V0KTtcbiAgICB9XG4gICAgaXNBdHRhY2hlZFRvKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuaXNBdHRhY2hlZFRvKHRoaXMubm9ybWFsaXplVGFyZ2V0KHRhcmdldCkpO1xuICAgIH1cbiAgICBub3JtYWxpemVUYXJnZXQodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuYm9keSA6IHRhcmdldDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBET00gfSBmcm9tIFwiLi4vZG9tLmpzXCI7XG5pbXBvcnQgeyBFeGVjdXRpb25Db250ZXh0LCBPYnNlcnZhYmxlLCB9IGZyb20gXCIuLi9vYnNlcnZhdGlvbi9vYnNlcnZhYmxlLmpzXCI7XG5pbXBvcnQgeyBUYXJnZXRlZEhUTUxEaXJlY3RpdmUgfSBmcm9tIFwiLi9odG1sLWRpcmVjdGl2ZS5qc1wiO1xuZnVuY3Rpb24gbm9ybWFsQmluZChzb3VyY2UsIGNvbnRleHQpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmICh0aGlzLmJpbmRpbmdPYnNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdPYnNlcnZlciA9IE9ic2VydmFibGUuYmluZGluZyh0aGlzLmJpbmRpbmcsIHRoaXMsIHRoaXMuaXNCaW5kaW5nVm9sYXRpbGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRhcmdldCh0aGlzLmJpbmRpbmdPYnNlcnZlci5vYnNlcnZlKHNvdXJjZSwgY29udGV4dCkpO1xufVxuZnVuY3Rpb24gdHJpZ2dlckJpbmQoc291cmNlLCBjb250ZXh0KSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRoaXMudGFyZ2V0TmFtZSwgdGhpcyk7XG59XG5mdW5jdGlvbiBub3JtYWxVbmJpbmQoKSB7XG4gICAgdGhpcy5iaW5kaW5nT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xufVxuZnVuY3Rpb24gY29udGVudFVuYmluZCgpIHtcbiAgICB0aGlzLmJpbmRpbmdPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgY29uc3QgdmlldyA9IHRoaXMudGFyZ2V0LiRmYXN0VmlldztcbiAgICBpZiAodmlldyAhPT0gdm9pZCAwICYmIHZpZXcuaXNDb21wb3NlZCkge1xuICAgICAgICB2aWV3LnVuYmluZCgpO1xuICAgICAgICB2aWV3Lm5lZWRzQmluZE9ubHkgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJVbmJpbmQoKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLnRhcmdldE5hbWUsIHRoaXMpO1xuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlVGFyZ2V0KHZhbHVlKSB7XG4gICAgRE9NLnNldEF0dHJpYnV0ZSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXROYW1lLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVCb29sZWFuQXR0cmlidXRlVGFyZ2V0KHZhbHVlKSB7XG4gICAgRE9NLnNldEJvb2xlYW5BdHRyaWJ1dGUodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0TmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGVudFRhcmdldCh2YWx1ZSkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gYWN0dWFsIHZhbHVlLCB0aGVuIHRoaXMgZXF1YXRlcyB0byB0aGVcbiAgICAvLyBlbXB0eSBzdHJpbmcgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb250ZW50IGJpbmRpbmdzLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIFwiY3JlYXRlXCIgbWV0aG9kLCB0aGVuIGl0J3MgYSB0ZW1wbGF0ZS1saWtlLlxuICAgIGlmICh2YWx1ZS5jcmVhdGUpIHtcbiAgICAgICAgdGhpcy50YXJnZXQudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMudGFyZ2V0LiRmYXN0VmlldztcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwcmV2aW91cyB2aWV3IHRoYXQgd2UgbWlnaHQgYmUgYWJsZSB0b1xuICAgICAgICAvLyByZXVzZSB0aGVuIGNyZWF0ZSBhIG5ldyB2aWV3IGZyb20gdGhlIHRlbXBsYXRlLlxuICAgICAgICBpZiAodmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2aWV3ID0gdmFsdWUuY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHByZXZpb3VzIHZpZXcsIGJ1dCBpdCB3YXNuJ3QgY3JlYXRlZFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgc2FtZSB0ZW1wbGF0ZSBhcyB0aGUgbmV3IHZhbHVlLCB0aGVuIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlbW92ZSB0aGUgb2xkIHZpZXcgaWYgaXQncyBzdGlsbCBpbiB0aGUgRE9NXG4gICAgICAgICAgICAvLyBhbmQgY3JlYXRlIGEgbmV3IHZpZXcgZnJvbSB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXQuJGZhc3RUZW1wbGF0ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5pc0NvbXBvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXcgPSB2YWx1ZS5jcmVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyB0ZW1wbGF0ZVxuICAgICAgICAvLyBhbmQgdGhhdCB0aGVyZSdzIGFjdHVhbGx5IG5vIG5lZWQgdG8gY29tcG9zZSBpdC5cbiAgICAgICAgaWYgKCF2aWV3LmlzQ29tcG9zZWQpIHtcbiAgICAgICAgICAgIHZpZXcuaXNDb21wb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmJpbmQodGhpcy5zb3VyY2UsIHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICB2aWV3Lmluc2VydEJlZm9yZSh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC4kZmFzdFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuJGZhc3RUZW1wbGF0ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcubmVlZHNCaW5kT25seSkge1xuICAgICAgICAgICAgdmlldy5uZWVkc0JpbmRPbmx5ID0gZmFsc2U7XG4gICAgICAgICAgICB2aWV3LmJpbmQodGhpcy5zb3VyY2UsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnRhcmdldC4kZmFzdFZpZXc7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmlldyBhbmQgaXQncyBjdXJyZW50bHkgY29tcG9zZWQgaW50b1xuICAgICAgICAvLyB0aGUgRE9NLCB0aGVuIHdlIG5lZWQgdG8gcmVtb3ZlIGl0LlxuICAgICAgICBpZiAodmlldyAhPT0gdm9pZCAwICYmIHZpZXcuaXNDb21wb3NlZCkge1xuICAgICAgICAgICAgdmlldy5pc0NvbXBvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKHZpZXcubmVlZHNCaW5kT25seSkge1xuICAgICAgICAgICAgICAgIHZpZXcubmVlZHNCaW5kT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlldy51bmJpbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnR5VGFyZ2V0KHZhbHVlKSB7XG4gICAgdGhpcy50YXJnZXRbdGhpcy50YXJnZXROYW1lXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NUYXJnZXQodmFsdWUpIHtcbiAgICBjb25zdCBjbGFzc1ZlcnNpb25zID0gdGhpcy5jbGFzc1ZlcnNpb25zIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IHZlcnNpb24gPSB0aGlzLnZlcnNpb24gfHwgMDtcbiAgICAvLyBBZGQgdGhlIGNsYXNzZXMsIHRyYWNraW5nIHRoZSB2ZXJzaW9uIGF0IHdoaWNoIHRoZXkgd2VyZSBhZGRlZC5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc1ZlcnNpb25zW2N1cnJlbnROYW1lXSA9IHZlcnNpb247XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChjdXJyZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGFzc1ZlcnNpb25zID0gY2xhc3NWZXJzaW9ucztcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uICsgMTtcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGFkZCBjbGFzc2VzLCB0aGVyZSdzIG5vIG5lZWQgdG8gcmVtb3ZlIG9sZCBvbmVzLlxuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNsYXNzZXMgZnJvbSB0aGUgcHJldmlvdXMgdmVyc2lvbi5cbiAgICB2ZXJzaW9uIC09IDE7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGNsYXNzVmVyc2lvbnMpIHtcbiAgICAgICAgaWYgKGNsYXNzVmVyc2lvbnNbbmFtZV0gPT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbmZpZ3VyZXMgZGF0YSBiaW5kaW5nIHRvIGVsZW1lbnQgY29udGVudCBhbmQgYXR0cmlidXRlcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEhUTUxCaW5kaW5nRGlyZWN0aXZlIGV4dGVuZHMgVGFyZ2V0ZWRIVE1MRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmRpbmdEaXJlY3RpdmUuXG4gICAgICogQHBhcmFtIGJpbmRpbmcgLSBBIGJpbmRpbmcgdGhhdCByZXR1cm5zIHRoZSBkYXRhIHVzZWQgdG8gdXBkYXRlIHRoZSBET00uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmluZGluZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuICAgICAgICB0aGlzLmJpbmQgPSBub3JtYWxCaW5kO1xuICAgICAgICB0aGlzLnVuYmluZCA9IG5vcm1hbFVuYmluZDtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQgPSB1cGRhdGVBdHRyaWJ1dGVUYXJnZXQ7XG4gICAgICAgIHRoaXMuaXNCaW5kaW5nVm9sYXRpbGUgPSBPYnNlcnZhYmxlLmlzVm9sYXRpbGVCaW5kaW5nKHRoaXMuYmluZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMvc2V0cyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIG9yIHByb3BlcnR5IHRoYXQgdGhpc1xuICAgICAqIGJpbmRpbmcgaXMgdGFyZ2V0aW5nLlxuICAgICAqL1xuICAgIGdldCB0YXJnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFRhcmdldE5hbWU7XG4gICAgfVxuICAgIHNldCB0YXJnZXROYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxUYXJnZXROYW1lID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZVswXSkge1xuICAgICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFuZWRUYXJnZXROYW1lID0gdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0ID0gdXBkYXRlUHJvcGVydHlUYXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW5lZFRhcmdldE5hbWUgPT09IFwiaW5uZXJIVE1MXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nID0gKHMsIGMpID0+IERPTS5jcmVhdGVIVE1MKGJpbmRpbmcocywgYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbmVkVGFyZ2V0TmFtZSA9IHZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldCA9IHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGVUYXJnZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5lZFRhcmdldE5hbWUgPSB2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kID0gdHJpZ2dlckJpbmQ7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJpbmQgPSB0cmlnZ2VyVW5iaW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFuZWRUYXJnZXROYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQgPSB1cGRhdGVDbGFzc1RhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhpcyBiaW5kaW5nIHRhcmdldCB0aGUgY29udGVudCBvZiBhbiBlbGVtZW50IHJhdGhlciB0aGFuXG4gICAgICogYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSBvciBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0YXJnZXRBdENvbnRlbnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0ID0gdXBkYXRlQ29udGVudFRhcmdldDtcbiAgICAgICAgdGhpcy51bmJpbmQgPSBjb250ZW50VW5iaW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBydW50aW1lIEJpbmRpbmdCZWhhdmlvciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvblxuICAgICAqIGluZm9ybWF0aW9uIHN0b3JlZCBpbiB0aGUgQmluZGluZ0RpcmVjdGl2ZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBub2RlIHRoYXQgdGhlIGJpbmRpbmcgYmVoYXZpb3Igc2hvdWxkIGF0dGFjaCB0by5cbiAgICAgKi9cbiAgICBjcmVhdGVCZWhhdmlvcih0YXJnZXQpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdCZWhhdmlvcih0YXJnZXQsIHRoaXMuYmluZGluZywgdGhpcy5pc0JpbmRpbmdWb2xhdGlsZSwgdGhpcy5iaW5kLCB0aGlzLnVuYmluZCwgdGhpcy51cGRhdGVUYXJnZXQsIHRoaXMuY2xlYW5lZFRhcmdldE5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogQSBiZWhhdmlvciB0aGF0IHVwZGF0ZXMgY29udGVudCBhbmQgYXR0cmlidXRlcyBiYXNlZCBvbiBhIGNvbmZpZ3VyZWRcbiAqIEJpbmRpbmdEaXJlY3RpdmUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5kaW5nQmVoYXZpb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZGluZ0JlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9mIHRoZSBkYXRhIHVwZGF0ZXMuXG4gICAgICogQHBhcmFtIGJpbmRpbmcgLSBUaGUgYmluZGluZyB0aGF0IHJldHVybnMgdGhlIGxhdGVzdCB2YWx1ZSBmb3IgYW4gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBpc0JpbmRpbmdWb2xhdGlsZSAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBiaW5kaW5nIGhhcyB2b2xhdGlsZSBkZXBlbmRlbmNpZXMuXG4gICAgICogQHBhcmFtIGJpbmQgLSBUaGUgb3BlcmF0aW9uIHRvIHBlcmZvcm0gZHVyaW5nIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIHVuYmluZCAtIFRoZSBvcGVyYXRpb24gdG8gcGVyZm9ybSBkdXJpbmcgdW5iaW5kaW5nLlxuICAgICAqIEBwYXJhbSB1cGRhdGVUYXJnZXQgLSBUaGUgb3BlcmF0aW9uIHRvIHBlcmZvcm0gd2hlbiB1cGRhdGluZy5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgYXR0cmlidXRlIG9yIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGJpbmRpbmcsIGlzQmluZGluZ1ZvbGF0aWxlLCBiaW5kLCB1bmJpbmQsIHVwZGF0ZVRhcmdldCwgdGFyZ2V0TmFtZSkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuYmluZGluZ09ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gICAgICAgIHRoaXMuaXNCaW5kaW5nVm9sYXRpbGUgPSBpc0JpbmRpbmdWb2xhdGlsZTtcbiAgICAgICAgdGhpcy5iaW5kID0gYmluZDtcbiAgICAgICAgdGhpcy51bmJpbmQgPSB1bmJpbmQ7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0ID0gdXBkYXRlVGFyZ2V0O1xuICAgICAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldCh0aGlzLmJpbmRpbmdPYnNlcnZlci5vYnNlcnZlKHRoaXMuc291cmNlLCB0aGlzLmNvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIEV4ZWN1dGlvbkNvbnRleHQuc2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJpbmRpbmcodGhpcy5zb3VyY2UsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIEV4ZWN1dGlvbkNvbnRleHQuc2V0RXZlbnQobnVsbCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBdHRhY2hlZEJlaGF2aW9ySFRNTERpcmVjdGl2ZSB9IGZyb20gXCIuL2h0bWwtZGlyZWN0aXZlLmpzXCI7XG5pbXBvcnQgeyBOb2RlT2JzZXJ2YXRpb25CZWhhdmlvciB9IGZyb20gXCIuL25vZGUtb2JzZXJ2YXRpb24uanNcIjtcbi8qKlxuICogVGhlIHJ1bnRpbWUgYmVoYXZpb3IgZm9yIGNoaWxkIG5vZGUgb2JzZXJ2YXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGlsZHJlbkJlaGF2aW9yIGV4dGVuZHMgTm9kZU9ic2VydmF0aW9uQmVoYXZpb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2hpbGRyZW5CZWhhdmlvci5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdGFyZ2V0IHRvIG9ic2VydmUgY2hpbGRyZW4gb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBvYnNlcnZpbmcgdGhlIGVsZW1lbnQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICBvcHRpb25zLmNoaWxkTGlzdCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2lucyBvYnNlcnZhdGlvbiBvZiB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgb2JzZXJ2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnRhcmdldCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgb2JzZXJ2YXRpb24gb2YgdGhlIG5vZGVzLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHRoZSB0YXJnZXQuXG4gICAgICovXG4gICAgZ2V0Tm9kZXMoKSB7XG4gICAgICAgIGlmIChcInN1YnRyZWVcIiBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy50YXJnZXQuY2hpbGROb2Rlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IG9ic2VydmVzIHRoZSBgY2hpbGROb2Rlc2Agb2YgYW4gZWxlbWVudCBhbmQgdXBkYXRlcyBhIHByb3BlcnR5XG4gKiB3aGVuZXZlciB0aGV5IGNoYW5nZS5cbiAqIEBwYXJhbSBwcm9wZXJ0eU9yT3B0aW9ucyAtIFRoZSBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIGNoaWxkIG5vZGUgb2JzZXJ2YXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbihwcm9wZXJ0eU9yT3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHlPck9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJvcGVydHlPck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlPck9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXR0YWNoZWRCZWhhdmlvckhUTUxEaXJlY3RpdmUoXCJmYXN0LWNoaWxkcmVuXCIsIENoaWxkcmVuQmVoYXZpb3IsIHByb3BlcnR5T3JPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7IF9pbnRlcnBvbGF0aW9uRW5kLCBfaW50ZXJwb2xhdGlvblN0YXJ0LCBET00gfSBmcm9tIFwiLi4vZG9tLmpzXCI7XG5pbXBvcnQgeyBIVE1MQmluZGluZ0RpcmVjdGl2ZSB9IGZyb20gXCIuL2JpbmRpbmcuanNcIjtcbmxldCBzaGFyZWRDb250ZXh0ID0gbnVsbDtcbmNsYXNzIENvbXBpbGF0aW9uQ29udGV4dCB7XG4gICAgYWRkRmFjdG9yeShmYWN0b3J5KSB7XG4gICAgICAgIGZhY3RvcnkudGFyZ2V0SW5kZXggPSB0aGlzLnRhcmdldEluZGV4O1xuICAgICAgICB0aGlzLmJlaGF2aW9yRmFjdG9yaWVzLnB1c2goZmFjdG9yeSk7XG4gICAgfVxuICAgIGNhcHR1cmVDb250ZW50QmluZGluZyhkaXJlY3RpdmUpIHtcbiAgICAgICAgZGlyZWN0aXZlLnRhcmdldEF0Q29udGVudCgpO1xuICAgICAgICB0aGlzLmFkZEZhY3RvcnkoZGlyZWN0aXZlKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgdGhpcy50YXJnZXRJbmRleCA9IC0xO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMgKi9cbiAgICAgICAgc2hhcmVkQ29udGV4dCA9IHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBib3Jyb3coZGlyZWN0aXZlcykge1xuICAgICAgICBjb25zdCBzaGFyZWFibGUgPSBzaGFyZWRDb250ZXh0IHx8IG5ldyBDb21waWxhdGlvbkNvbnRleHQoKTtcbiAgICAgICAgc2hhcmVhYmxlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICBzaGFyZWFibGUucmVzZXQoKTtcbiAgICAgICAgc2hhcmVkQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHJldHVybiBzaGFyZWFibGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRlQmluZGluZyhwYXJ0cykge1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0TmFtZTtcbiAgICBjb25zdCBwYXJ0Q291bnQgPSBwYXJ0cy5sZW5ndGg7XG4gICAgY29uc3QgZmluYWxQYXJ0cyA9IHBhcnRzLm1hcCgoeCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB4O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldE5hbWUgPSB4LnRhcmdldE5hbWUgfHwgdGFyZ2V0TmFtZTtcbiAgICAgICAgcmV0dXJuIHguYmluZGluZztcbiAgICB9KTtcbiAgICBjb25zdCBiaW5kaW5nID0gKHNjb3BlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gZmluYWxQYXJ0c1tpXShzY29wZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIGNvbnN0IGRpcmVjdGl2ZSA9IG5ldyBIVE1MQmluZGluZ0RpcmVjdGl2ZShiaW5kaW5nKTtcbiAgICBkaXJlY3RpdmUudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgcmV0dXJuIGRpcmVjdGl2ZTtcbn1cbmNvbnN0IGludGVycG9sYXRpb25FbmRMZW5ndGggPSBfaW50ZXJwb2xhdGlvbkVuZC5sZW5ndGg7XG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQoY29udGV4dCwgdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZVBhcnRzID0gdmFsdWUuc3BsaXQoX2ludGVycG9sYXRpb25TdGFydCk7XG4gICAgaWYgKHZhbHVlUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nUGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2YWx1ZVBhcnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHZhbHVlUGFydHNbaV07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudC5pbmRleE9mKF9pbnRlcnBvbGF0aW9uRW5kKTtcbiAgICAgICAgbGV0IGxpdGVyYWw7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxpdGVyYWwgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlSW5kZXggPSBwYXJzZUludChjdXJyZW50LnN1YnN0cmluZygwLCBpbmRleCkpO1xuICAgICAgICAgICAgYmluZGluZ1BhcnRzLnB1c2goY29udGV4dC5kaXJlY3RpdmVzW2RpcmVjdGl2ZUluZGV4XSk7XG4gICAgICAgICAgICBsaXRlcmFsID0gY3VycmVudC5zdWJzdHJpbmcoaW5kZXggKyBpbnRlcnBvbGF0aW9uRW5kTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGl0ZXJhbCAhPT0gXCJcIikge1xuICAgICAgICAgICAgYmluZGluZ1BhcnRzLnB1c2gobGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdQYXJ0cztcbn1cbmZ1bmN0aW9uIGNvbXBpbGVBdHRyaWJ1dGVzKGNvbnRleHQsIG5vZGUsIGluY2x1ZGVCYXNpY1ZhbHVlcyA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VDb250ZW50KGNvbnRleHQsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAocGFyc2VSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQmFzaWNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgSFRNTEJpbmRpbmdEaXJlY3RpdmUoKCkgPT4gYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudGFyZ2V0TmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUFnZ3JlZ2F0ZUJpbmRpbmcocGFyc2VSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShhdHRyKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGlpLS07XG4gICAgICAgICAgICBjb250ZXh0LmFkZEZhY3RvcnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVDb250ZW50KGNvbnRleHQsIG5vZGUsIHdhbGtlcikge1xuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VDb250ZW50KGNvbnRleHQsIG5vZGUudGV4dENvbnRlbnQpO1xuICAgIGlmIChwYXJzZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJzZVJlc3VsdC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IHBhcnNlUmVzdWx0W2ldO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBpID09PSAwXG4gICAgICAgICAgICAgICAgPyBub2RlXG4gICAgICAgICAgICAgICAgOiBsYXN0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSwgbGFzdE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY3VycmVudFBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FwdHVyZUNvbnRlbnRCaW5kaW5nKGN1cnJlbnRQYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3ROb2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICBjb250ZXh0LnRhcmdldEluZGV4Kys7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnRhcmdldEluZGV4LS07XG4gICAgfVxufVxuLyoqXG4gKiBDb21waWxlcyBhIHRlbXBsYXRlIGFuZCBhc3NvY2lhdGVkIGRpcmVjdGl2ZXMgaW50byBhIHJhdyBjb21waWxhdGlvblxuICogcmVzdWx0IHdoaWNoIGluY2x1ZGUgYSBjbG9uZWFibGUgRG9jdW1lbnRGcmFnbWVudCBhbmQgZmFjdG9yaWVzIGNhcGFibGVcbiAqIG9mIGF0dGFjaGluZyBydW50aW1lIGJlaGF2aW9yIHRvIG5vZGVzIHdpdGhpbiB0aGUgZnJhZ21lbnQuXG4gKiBAcGFyYW0gdGVtcGxhdGUgLSBUaGUgdGVtcGxhdGUgdG8gY29tcGlsZS5cbiAqIEBwYXJhbSBkaXJlY3RpdmVzIC0gVGhlIGRpcmVjdGl2ZXMgcmVmZXJlbmNlZCBieSB0aGUgdGVtcGxhdGUuXG4gKiBAcmVtYXJrc1xuICogVGhlIHRlbXBsYXRlIHRoYXQgaXMgcHJvdmlkZWQgZm9yIGNvbXBpbGF0aW9uIGlzIGFsdGVyZWQgaW4tcGxhY2VcbiAqIGFuZCBjYW5ub3QgYmUgY29tcGlsZWQgYWdhaW4uIElmIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBtdXN0IGJlIHByZXNlcnZlZCxcbiAqIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IGNsb25lIHRoZSBvcmlnaW5hbCBhbmQgcGFzcyB0aGUgY2xvbmUgdG8gdGhpcyBBUEkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlVGVtcGxhdGUodGVtcGxhdGUsIGRpcmVjdGl2ZXMpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTExMTg2NFxuICAgIGRvY3VtZW50LmFkb3B0Tm9kZShmcmFnbWVudCk7XG4gICAgY29uc3QgY29udGV4dCA9IENvbXBpbGF0aW9uQ29udGV4dC5ib3Jyb3coZGlyZWN0aXZlcyk7XG4gICAgY29tcGlsZUF0dHJpYnV0ZXMoY29udGV4dCwgdGVtcGxhdGUsIHRydWUpO1xuICAgIGNvbnN0IGhvc3RCZWhhdmlvckZhY3RvcmllcyA9IGNvbnRleHQuYmVoYXZpb3JGYWN0b3JpZXM7XG4gICAgY29udGV4dC5yZXNldCgpO1xuICAgIGNvbnN0IHdhbGtlciA9IERPTS5jcmVhdGVUZW1wbGF0ZVdhbGtlcihmcmFnbWVudCk7XG4gICAgbGV0IG5vZGU7XG4gICAgd2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgICAgIGNvbnRleHQudGFyZ2V0SW5kZXgrKztcbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIGVsZW1lbnQgbm9kZVxuICAgICAgICAgICAgICAgIGNvbXBpbGVBdHRyaWJ1dGVzKGNvbnRleHQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOiAvLyB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICBjb21waWxlQ29udGVudChjb250ZXh0LCBub2RlLCB3YWxrZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKERPTS5pc01hcmtlcihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFkZEZhY3RvcnkoZGlyZWN0aXZlc1tET00uZXh0cmFjdERpcmVjdGl2ZUluZGV4RnJvbU1hcmtlcihub2RlKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gMDtcbiAgICBpZiAoXG4gICAgLy8gSWYgdGhlIGZpcnN0IG5vZGUgaW4gYSBmcmFnbWVudCBpcyBhIG1hcmtlciwgdGhhdCBtZWFucyBpdCdzIGFuIHVuc3RhYmxlIGZpcnN0IG5vZGUsXG4gICAgLy8gYmVjYXVzZSBzb21ldGhpbmcgbGlrZSBhIHdoZW4sIHJlcGVhdCwgZXRjLiBjb3VsZCBhZGQgbm9kZXMgYmVmb3JlIHRoZSBtYXJrZXIuXG4gICAgLy8gVG8gbWl0aWdhdGUgdGhpcywgd2UgaW5zZXJ0IGEgc3RhYmxlIGZpcnN0IG5vZGUuIEhvd2V2ZXIsIGlmIHdlIGluc2VydCBhIG5vZGUsXG4gICAgLy8gdGhhdCB3aWxsIGFsdGVyIHRoZSByZXN1bHQgb2YgdGhlIFRyZWVXYWxrZXIuIFNvLCB3ZSBhbHNvIG5lZWQgdG8gb2Zmc2V0IHRoZSB0YXJnZXQgaW5kZXguXG4gICAgRE9NLmlzTWFya2VyKGZyYWdtZW50LmZpcnN0Q2hpbGQpIHx8XG4gICAgICAgIC8vIE9yIGlmIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUgYW5kIGEgZGlyZWN0aXZlLCBpdCBtZWFucyB0aGUgdGVtcGxhdGUncyBjb250ZW50XG4gICAgICAgIC8vIGlzICpvbmx5KiB0aGUgZGlyZWN0aXZlLiBJbiB0aGF0IGNhc2UsIEhUTUxWaWV3LmRpc3Bvc2UoKSBtaXNzZXMgYW55IG5vZGVzIGluc2VydGVkIGJ5XG4gICAgICAgIC8vIHRoZSBkaXJlY3RpdmUuIEluc2VydGluZyBhIG5ldyBub2RlIGVuc3VyZXMgcHJvcGVyIGRpc3Bvc2FsIG9mIG5vZGVzIGFkZGVkIGJ5IHRoZSBkaXJlY3RpdmUuXG4gICAgICAgIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBkaXJlY3RpdmVzLmxlbmd0aCkpIHtcbiAgICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIiksIGZyYWdtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB0YXJnZXRPZmZzZXQgPSAtMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld0JlaGF2aW9yRmFjdG9yaWVzID0gY29udGV4dC5iZWhhdmlvckZhY3RvcmllcztcbiAgICBjb250ZXh0LnJlbGVhc2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgdmlld0JlaGF2aW9yRmFjdG9yaWVzLFxuICAgICAgICBob3N0QmVoYXZpb3JGYWN0b3JpZXMsXG4gICAgICAgIHRhcmdldE9mZnNldCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgRE9NIH0gZnJvbSBcIi4uL2RvbS5qc1wiO1xuLyoqXG4gKiBJbnN0cnVjdHMgdGhlIHRlbXBsYXRlIGVuZ2luZSB0byBhcHBseSBiZWhhdmlvciB0byBhIG5vZGUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBIVE1MRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgRE9NIG5vZGUgdG8gd2hpY2ggdGhlIGNyZWF0ZWQgYmVoYXZpb3Igd2lsbCBhcHBseS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0SW5kZXggPSAwO1xuICAgIH1cbn1cbi8qKlxuICogQSB7QGxpbmsgSFRNTERpcmVjdGl2ZX0gdGhhdCB0YXJnZXRzIGEgbmFtZWQgYXR0cmlidXRlIG9yIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRhcmdldGVkSFRNTERpcmVjdGl2ZSBleHRlbmRzIEhUTUxEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWNlaG9sZGVyIHN0cmluZyBiYXNlZCBvbiB0aGUgZGlyZWN0aXZlJ3MgaW5kZXggd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBkaXJlY3RpdmUgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUGxhY2Vob2xkZXIgPSBET00uY3JlYXRlSW50ZXJwb2xhdGlvblBsYWNlaG9sZGVyO1xuICAgIH1cbn1cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhdHRhY2hlcyBzcGVjaWFsIGJlaGF2aW9yIHRvIGFuIGVsZW1lbnQgdmlhIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEF0dGFjaGVkQmVoYXZpb3JIVE1MRGlyZWN0aXZlIGV4dGVuZHMgSFRNTERpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiZWhhdmlvcjsgdXNlZCBhcyBhIGN1c3RvbSBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGJlaGF2aW9yIC0gVGhlIGJlaGF2aW9yIHRvIGluc3RhbnRpYXRlIGFuZCBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGJlaGF2aW9yIGR1cmluZyBjcmVhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBiZWhhdmlvciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmJlaGF2aW9yID0gYmVoYXZpb3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFjZWhvbGRlciBzdHJpbmcgYmFzZWQgb24gdGhlIGRpcmVjdGl2ZSdzIGluZGV4IHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBkaXJlY3RpdmUgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENyZWF0ZXMgYSBjdXN0b20gYXR0cmlidXRlIHBsYWNlaG9sZGVyLlxuICAgICAqL1xuICAgIGNyZWF0ZVBsYWNlaG9sZGVyKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBET00uY3JlYXRlQ3VzdG9tQXR0cmlidXRlUGxhY2Vob2xkZXIodGhpcy5uYW1lLCBpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiZWhhdmlvciBmb3IgdGhlIHByb3ZpZGVkIHRhcmdldCBub2RlLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgbm9kZSBpbnN0YW5jZSB0byBjcmVhdGUgdGhlIGJlaGF2aW9yIGZvci5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGBiZWhhdmlvcmAgdHlwZSB0aGlzIGRpcmVjdGl2ZSB3YXMgY29uc3RydWN0ZWQgd2l0aFxuICAgICAqIGFuZCBwYXNzZXMgdGhlIHRhcmdldCBhbmQgb3B0aW9ucyB0byB0aGF0IGBiZWhhdmlvcmAncyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjcmVhdGVCZWhhdmlvcih0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmJlaGF2aW9yKHRhcmdldCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcIi4uL29ic2VydmF0aW9uL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tIFwiLi4vcGxhdGZvcm0uanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGEgTm9kZSBhcnJheSwgc2VsZWN0aW5nIG9ubHkgZWxlbWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBBbiBvcHRpb25hbCBzZWxlY3RvciB0byByZXN0cmljdCB0aGUgZmlsdGVyIHRvLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgdmFsdWUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubm9kZVR5cGUgPT09IDE7XG4gICAgfTtcbn1cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBub2RlIG9ic2VydmF0aW9uLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlT2JzZXJ2YXRpb25CZWhhdmlvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBOb2RlT2JzZXJ2YXRpb25CZWhhdmlvci5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBhc3NpZ24gdGhlIG5vZGVzIHByb3BlcnR5IG9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlIGluIGNvbmZpZ3VyaW5nIG5vZGUgb2JzZXJ2YXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhpcyBiZWhhdmlvciB0byB0aGUgc291cmNlLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIHRvIGJpbmQgdG8uXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgZXhlY3V0aW9uIGNvbnRleHQgdGhhdCB0aGUgYmluZGluZyBpcyBvcGVyYXRpbmcgd2l0aGluLlxuICAgICAqL1xuICAgIGJpbmQoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm9wdGlvbnMucHJvcGVydHk7XG4gICAgICAgIHRoaXMuc2hvdWxkVXBkYXRlID0gT2JzZXJ2YWJsZS5nZXRBY2Nlc3NvcnMoc291cmNlKS5zb21lKCh4KSA9PiB4Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQodGhpcy5jb21wdXRlTm9kZXMoKSk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5iaW5kcyB0aGlzIGJlaGF2aW9yIGZyb20gdGhlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gc291cmNlIC0gVGhlIHNvdXJjZSB0byB1bmJpbmQgZnJvbS5cbiAgICAgKi9cbiAgICB1bmJpbmQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KGVtcHR5QXJyYXkpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGhhbmRsZUV2ZW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldCh0aGlzLmNvbXB1dGVOb2RlcygpKTtcbiAgICB9XG4gICAgY29tcHV0ZU5vZGVzKCkge1xuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKHRoaXMub3B0aW9ucy5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlW3RoaXMub3B0aW9ucy5wcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBdHRhY2hlZEJlaGF2aW9ySFRNTERpcmVjdGl2ZSB9IGZyb20gXCIuL2h0bWwtZGlyZWN0aXZlLmpzXCI7XG4vKipcbiAqIFRoZSBydW50aW1lIGJlaGF2aW9yIGZvciB0ZW1wbGF0ZSByZWZlcmVuY2VzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVmQmVoYXZpb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVmQmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBlbGVtZW50IHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbiB0aGUgcmVmZXJlbmNlIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCB0aGlzIGJlaGF2aW9yIHRvIHRoZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2UgdG8gYmluZCB0by5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBleGVjdXRpb24gY29udGV4dCB0aGF0IHRoZSBiaW5kaW5nIGlzIG9wZXJhdGluZyB3aXRoaW4uXG4gICAgICovXG4gICAgYmluZChzb3VyY2UpIHtcbiAgICAgICAgc291cmNlW3RoaXMucHJvcGVydHlOYW1lXSA9IHRoaXMudGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIHRoaXMgYmVoYXZpb3IgZnJvbSB0aGUgc291cmNlLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIHRvIHVuYmluZCBmcm9tLlxuICAgICAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbiAgICB1bmJpbmQoKSB7IH1cbn1cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBvYnNlcnZlcyB0aGUgdXBkYXRlcyBhIHByb3BlcnR5IHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0gcHJvcGVydHlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbiB0aGUgcmVmZXJlbmNlIHRvLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmKHByb3BlcnR5TmFtZSkge1xuICAgIHJldHVybiBuZXcgQXR0YWNoZWRCZWhhdmlvckhUTUxEaXJlY3RpdmUoXCJmYXN0LXJlZlwiLCBSZWZCZWhhdmlvciwgcHJvcGVydHlOYW1lKTtcbn1cbiIsImltcG9ydCB7IERPTSB9IGZyb20gXCIuLi9kb20uanNcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIH0gZnJvbSBcIi4uL29ic2VydmF0aW9uL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IGVuYWJsZUFycmF5T2JzZXJ2YXRpb24gfSBmcm9tIFwiLi4vb2JzZXJ2YXRpb24vYXJyYXktb2JzZXJ2ZXIuanNcIjtcbmltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tIFwiLi4vcGxhdGZvcm0uanNcIjtcbmltcG9ydCB7IEhUTUxEaXJlY3RpdmUgfSBmcm9tIFwiLi9odG1sLWRpcmVjdGl2ZS5qc1wiO1xuaW1wb3J0IHsgSFRNTFZpZXcgfSBmcm9tIFwiLi92aWV3LmpzXCI7XG5jb25zdCBkZWZhdWx0UmVwZWF0T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgICByZWN5Y2xlOiB0cnVlLFxufSk7XG5mdW5jdGlvbiBiaW5kV2l0aG91dFBvc2l0aW9uaW5nKHZpZXcsIGl0ZW1zLCBpbmRleCwgY29udGV4dCkge1xuICAgIHZpZXcuYmluZChpdGVtc1tpbmRleF0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYmluZFdpdGhQb3NpdGlvbmluZyh2aWV3LCBpdGVtcywgaW5kZXgsIGNvbnRleHQpIHtcbiAgICBjb25zdCBjaGlsZENvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICAgIGNoaWxkQ29udGV4dC5pbmRleCA9IGluZGV4O1xuICAgIGNoaWxkQ29udGV4dC5sZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgdmlldy5iaW5kKGl0ZW1zW2luZGV4XSwgY2hpbGRDb250ZXh0KTtcbn1cbi8qKlxuICogQSBiZWhhdmlvciB0aGF0IHJlbmRlcnMgYSB0ZW1wbGF0ZSBmb3IgZWFjaCBpdGVtIGluIGFuIGFycmF5LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVwZWF0QmVoYXZpb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVwZWF0QmVoYXZpb3IuXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIGluIHRoZSBET00gdG8gcmVuZGVyIHRoZSByZXBlYXQuXG4gICAgICogQHBhcmFtIGl0ZW1zQmluZGluZyAtIFRoZSBhcnJheSB0byByZW5kZXIuXG4gICAgICogQHBhcmFtIGlzSXRlbXNCaW5kaW5nVm9sYXRpbGUgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgaXRlbXMgYmluZGluZyBoYXMgdm9sYXRpbGUgZGVwZW5kZW5jaWVzLlxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUJpbmRpbmcgLSBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyIGZvciBlYWNoIGl0ZW0uXG4gICAgICogQHBhcmFtIGlzVGVtcGxhdGVCaW5kaW5nVm9sYXRpbGUgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGVtcGxhdGUgYmluZGluZyBoYXMgdm9sYXRpbGUgZGVwZW5kZW5jaWVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB1c2VkIHRvIHR1cm4gb24gc3BlY2lhbCByZXBlYXQgZmVhdHVyZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYXRpb24sIGl0ZW1zQmluZGluZywgaXNJdGVtc0JpbmRpbmdWb2xhdGlsZSwgdGVtcGxhdGVCaW5kaW5nLCBpc1RlbXBsYXRlQmluZGluZ1ZvbGF0aWxlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5pdGVtc0JpbmRpbmcgPSBpdGVtc0JpbmRpbmc7XG4gICAgICAgIHRoaXMudGVtcGxhdGVCaW5kaW5nID0gdGVtcGxhdGVCaW5kaW5nO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXRlbXNPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb250ZXh0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5iaW5kVmlldyA9IGJpbmRXaXRob3V0UG9zaXRpb25pbmc7XG4gICAgICAgIHRoaXMuaXRlbXNCaW5kaW5nT2JzZXJ2ZXIgPSBPYnNlcnZhYmxlLmJpbmRpbmcoaXRlbXNCaW5kaW5nLCB0aGlzLCBpc0l0ZW1zQmluZGluZ1ZvbGF0aWxlKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdPYnNlcnZlciA9IE9ic2VydmFibGUuYmluZGluZyh0ZW1wbGF0ZUJpbmRpbmcsIHRoaXMsIGlzVGVtcGxhdGVCaW5kaW5nVm9sYXRpbGUpO1xuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbmluZykge1xuICAgICAgICAgICAgdGhpcy5iaW5kVmlldyA9IGJpbmRXaXRoUG9zaXRpb25pbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCB0aGlzIGJlaGF2aW9yIHRvIHRoZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2UgdG8gYmluZCB0by5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBleGVjdXRpb24gY29udGV4dCB0aGF0IHRoZSBiaW5kaW5nIGlzIG9wZXJhdGluZyB3aXRoaW4uXG4gICAgICovXG4gICAgYmluZChzb3VyY2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jaGlsZENvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICAgICAgICB0aGlzLmNoaWxkQ29udGV4dC5wYXJlbnQgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuY2hpbGRDb250ZXh0LnBhcmVudENvbnRleHQgPSB0aGlzLm9yaWdpbmFsQ29udGV4dDtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNCaW5kaW5nT2JzZXJ2ZXIub2JzZXJ2ZShzb3VyY2UsIHRoaXMub3JpZ2luYWxDb250ZXh0KTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVCaW5kaW5nT2JzZXJ2ZXIub2JzZXJ2ZShzb3VyY2UsIHRoaXMub3JpZ2luYWxDb250ZXh0KTtcbiAgICAgICAgdGhpcy5vYnNlcnZlSXRlbXModHJ1ZSk7XG4gICAgICAgIHRoaXMucmVmcmVzaEFsbFZpZXdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgdGhpcyBiZWhhdmlvciBmcm9tIHRoZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2UgdG8gdW5iaW5kIGZyb20uXG4gICAgICovXG4gICAgdW5iaW5kKCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pdGVtc09ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zT2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmJpbmRBbGxWaWV3cygpO1xuICAgICAgICB0aGlzLml0ZW1zQmluZGluZ09ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBoYW5kbGVDaGFuZ2Uoc291cmNlLCBhcmdzKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT09IHRoaXMuaXRlbXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc0JpbmRpbmdPYnNlcnZlci5vYnNlcnZlKHRoaXMuc291cmNlLCB0aGlzLm9yaWdpbmFsQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJdGVtcygpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQWxsVmlld3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2UgPT09IHRoaXMudGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZUJpbmRpbmdPYnNlcnZlci5vYnNlcnZlKHRoaXMuc291cmNlLCB0aGlzLm9yaWdpbmFsQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hBbGxWaWV3cyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3MoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUl0ZW1zKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gZW1wdHlBcnJheTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRPYnNlcnZlciA9IHRoaXMuaXRlbXNPYnNlcnZlcjtcbiAgICAgICAgY29uc3QgbmV3T2JzZXJ2ZXIgPSAodGhpcy5pdGVtc09ic2VydmVyID0gT2JzZXJ2YWJsZS5nZXROb3RpZmllcih0aGlzLml0ZW1zKSk7XG4gICAgICAgIGNvbnN0IGhhc05ld09ic2VydmVyID0gb2xkT2JzZXJ2ZXIgIT09IG5ld09ic2VydmVyO1xuICAgICAgICBpZiAoaGFzTmV3T2JzZXJ2ZXIgJiYgb2xkT2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZE9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNOZXdPYnNlcnZlciB8fCBmb3JjZSkge1xuICAgICAgICAgICAgbmV3T2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdzKHNwbGljZXMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gdGhpcy5jaGlsZENvbnRleHQ7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gdGhpcy52aWV3cztcbiAgICAgICAgY29uc3QgYmluZFZpZXcgPSB0aGlzLmJpbmRWaWV3O1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICAgICAgY29uc3QgcmVjeWNsZSA9IHRoaXMub3B0aW9ucy5yZWN5Y2xlO1xuICAgICAgICBjb25zdCBsZWZ0b3ZlclZpZXdzID0gW107XG4gICAgICAgIGxldCBsZWZ0b3ZlckluZGV4ID0gMDtcbiAgICAgICAgbGV0IGF2YWlsYWJsZVZpZXdzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3BsaWNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpY2UgPSBzcGxpY2VzW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHNwbGljZS5yZW1vdmVkO1xuICAgICAgICAgICAgbGV0IHJlbW92ZUluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBhZGRJbmRleCA9IHNwbGljZS5pbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGFkZEluZGV4ICsgc3BsaWNlLmFkZGVkQ291bnQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkVmlld3MgPSB2aWV3cy5zcGxpY2Uoc3BsaWNlLmluZGV4LCByZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEF2YWlsYWJsZVZpZXdzID0gKGF2YWlsYWJsZVZpZXdzID1cbiAgICAgICAgICAgICAgICBsZWZ0b3ZlclZpZXdzLmxlbmd0aCArIHJlbW92ZWRWaWV3cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICg7IGFkZEluZGV4IDwgZW5kOyArK2FkZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVpZ2hib3IgPSB2aWV3c1thZGRJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBuZWlnaGJvciA/IG5laWdoYm9yLmZpcnN0Q2hpbGQgOiB0aGlzLmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIGxldCB2aWV3O1xuICAgICAgICAgICAgICAgIGlmIChyZWN5Y2xlICYmIGF2YWlsYWJsZVZpZXdzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlSW5kZXggPD0gdG90YWxBdmFpbGFibGVWaWV3cyAmJiByZW1vdmVkVmlld3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldyA9IHJlbW92ZWRWaWV3c1tyZW1vdmVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldyA9IGxlZnRvdmVyVmlld3NbbGVmdG92ZXJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlVmlld3MtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSB0ZW1wbGF0ZS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld3Muc3BsaWNlKGFkZEluZGV4LCAwLCB2aWV3KTtcbiAgICAgICAgICAgICAgICBiaW5kVmlldyh2aWV3LCBpdGVtcywgYWRkSW5kZXgsIGNoaWxkQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmlldy5pbnNlcnRCZWZvcmUobG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbW92ZWRWaWV3c1tyZW1vdmVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBsZWZ0b3ZlclZpZXdzLnB1c2goLi4ucmVtb3ZlZFZpZXdzLnNsaWNlKHJlbW92ZUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGxlZnRvdmVySW5kZXgsIGlpID0gbGVmdG92ZXJWaWV3cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBsZWZ0b3ZlclZpZXdzW2ldLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBvc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2aWV3cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSB2aWV3c1tpXS5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0Lmxlbmd0aCA9IGlpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LmluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoQWxsVmlld3ModGVtcGxhdGVDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSB0aGlzLmNoaWxkQ29udGV4dDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIGNvbnN0IGJpbmRWaWV3ID0gdGhpcy5iaW5kVmlldztcbiAgICAgICAgbGV0IGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICBsZXQgdmlld3MgPSB0aGlzLnZpZXdzO1xuICAgICAgICBsZXQgdmlld3NMZW5ndGggPSB2aWV3cy5sZW5ndGg7XG4gICAgICAgIGlmIChpdGVtc0xlbmd0aCA9PT0gMCB8fCB0ZW1wbGF0ZUNoYW5nZWQgfHwgIXRoaXMub3B0aW9ucy5yZWN5Y2xlKSB7XG4gICAgICAgICAgICAvLyBhbGwgdmlld3MgbmVlZCB0byBiZSByZW1vdmVkXG4gICAgICAgICAgICBIVE1MVmlldy5kaXNwb3NlQ29udGlndW91c0JhdGNoKHZpZXdzKTtcbiAgICAgICAgICAgIHZpZXdzTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld3NMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGFsbCB2aWV3cyBuZWVkIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgIHRoaXMudmlld3MgPSB2aWV3cyA9IG5ldyBBcnJheShpdGVtc0xlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGVtcGxhdGUuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgYmluZFZpZXcodmlldywgaXRlbXMsIGksIGNoaWxkQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmlld3NbaV0gPSB2aWV3O1xuICAgICAgICAgICAgICAgIHZpZXcuaW5zZXJ0QmVmb3JlKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcmV1c2UgZXhpc3Rpbmcgdmlld3Mgd2l0aCBuZXcgZGF0YVxuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBpdGVtc0xlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB2aWV3c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGJpbmRWaWV3KHZpZXcsIGl0ZW1zLCBpLCBjaGlsZENvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IHRlbXBsYXRlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBiaW5kVmlldyh2aWV3LCBpdGVtcywgaSwgY2hpbGRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5pbnNlcnRCZWZvcmUobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSB2aWV3cy5zcGxpY2UoaSwgdmlld3NMZW5ndGggLSBpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl0ZW1zTGVuZ3RoID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBpdGVtc0xlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFtpXS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5iaW5kQWxsVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gdGhpcy52aWV3cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmlld3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgdmlld3NbaV0udW5iaW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgY29uZmlndXJlcyBsaXN0IHJlbmRlcmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlcGVhdERpcmVjdGl2ZSBleHRlbmRzIEhUTUxEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVwZWF0RGlyZWN0aXZlLlxuICAgICAqIEBwYXJhbSBpdGVtc0JpbmRpbmcgLSBUaGUgYmluZGluZyB0aGF0IHByb3ZpZGVzIHRoZSBhcnJheSB0byByZW5kZXIuXG4gICAgICogQHBhcmFtIHRlbXBsYXRlQmluZGluZyAtIFRoZSB0ZW1wbGF0ZSBiaW5kaW5nIHVzZWQgdG8gb2J0YWluIGEgdGVtcGxhdGUgdG8gcmVuZGVyIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB1c2VkIHRvIHR1cm4gb24gc3BlY2lhbCByZXBlYXQgZmVhdHVyZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaXRlbXNCaW5kaW5nLCB0ZW1wbGF0ZUJpbmRpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVtc0JpbmRpbmcgPSBpdGVtc0JpbmRpbmc7XG4gICAgICAgIHRoaXMudGVtcGxhdGVCaW5kaW5nID0gdGVtcGxhdGVCaW5kaW5nO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWNlaG9sZGVyIHN0cmluZyBiYXNlZCBvbiB0aGUgZGlyZWN0aXZlJ3MgaW5kZXggd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBkaXJlY3RpdmUgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUGxhY2Vob2xkZXIgPSBET00uY3JlYXRlQmxvY2tQbGFjZWhvbGRlcjtcbiAgICAgICAgZW5hYmxlQXJyYXlPYnNlcnZhdGlvbigpO1xuICAgICAgICB0aGlzLmlzSXRlbXNCaW5kaW5nVm9sYXRpbGUgPSBPYnNlcnZhYmxlLmlzVm9sYXRpbGVCaW5kaW5nKGl0ZW1zQmluZGluZyk7XG4gICAgICAgIHRoaXMuaXNUZW1wbGF0ZUJpbmRpbmdWb2xhdGlsZSA9IE9ic2VydmFibGUuaXNWb2xhdGlsZUJpbmRpbmcodGVtcGxhdGVCaW5kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJlaGF2aW9yIGZvciB0aGUgcHJvdmlkZWQgdGFyZ2V0IG5vZGUuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBub2RlIGluc3RhbmNlIHRvIGNyZWF0ZSB0aGUgYmVoYXZpb3IgZm9yLlxuICAgICAqL1xuICAgIGNyZWF0ZUJlaGF2aW9yKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGVhdEJlaGF2aW9yKHRhcmdldCwgdGhpcy5pdGVtc0JpbmRpbmcsIHRoaXMuaXNJdGVtc0JpbmRpbmdWb2xhdGlsZSwgdGhpcy50ZW1wbGF0ZUJpbmRpbmcsIHRoaXMuaXNUZW1wbGF0ZUJpbmRpbmdWb2xhdGlsZSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgZW5hYmxlcyBsaXN0IHJlbmRlcmluZy5cbiAqIEBwYXJhbSBpdGVtc0JpbmRpbmcgLSBUaGUgYXJyYXkgdG8gcmVuZGVyLlxuICogQHBhcmFtIHRlbXBsYXRlT3JUZW1wbGF0ZUJpbmRpbmcgLSBUaGUgdGVtcGxhdGUgb3IgYSB0ZW1wbGF0ZSBiaW5kaW5nIHVzZWQgb2J0YWluIGEgdGVtcGxhdGVcbiAqIHRvIHJlbmRlciBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB1c2VkIHRvIHR1cm4gb24gc3BlY2lhbCByZXBlYXQgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXQoaXRlbXNCaW5kaW5nLCB0ZW1wbGF0ZU9yVGVtcGxhdGVCaW5kaW5nLCBvcHRpb25zID0gZGVmYXVsdFJlcGVhdE9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZUJpbmRpbmcgPSB0eXBlb2YgdGVtcGxhdGVPclRlbXBsYXRlQmluZGluZyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gdGVtcGxhdGVPclRlbXBsYXRlQmluZGluZ1xuICAgICAgICA6ICgpID0+IHRlbXBsYXRlT3JUZW1wbGF0ZUJpbmRpbmc7XG4gICAgcmV0dXJuIG5ldyBSZXBlYXREaXJlY3RpdmUoaXRlbXNCaW5kaW5nLCB0ZW1wbGF0ZUJpbmRpbmcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFJlcGVhdE9wdGlvbnMpLCBvcHRpb25zKSk7XG59XG4iLCJpbXBvcnQgeyBBdHRhY2hlZEJlaGF2aW9ySFRNTERpcmVjdGl2ZSB9IGZyb20gXCIuL2h0bWwtZGlyZWN0aXZlLmpzXCI7XG5pbXBvcnQgeyBOb2RlT2JzZXJ2YXRpb25CZWhhdmlvciB9IGZyb20gXCIuL25vZGUtb2JzZXJ2YXRpb24uanNcIjtcbi8qKlxuICogVGhlIHJ1bnRpbWUgYmVoYXZpb3IgZm9yIHNsb3R0ZWQgbm9kZSBvYnNlcnZhdGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFNsb3R0ZWRCZWhhdmlvciBleHRlbmRzIE5vZGVPYnNlcnZhdGlvbkJlaGF2aW9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNsb3R0ZWRCZWhhdmlvci5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHNsb3QgZWxlbWVudCB0YXJnZXQgdG8gb2JzZXJ2ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIG9ic2VydmluZyB0aGUgc2xvdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW5zIG9ic2VydmF0aW9uIG9mIHRoZSBub2Rlcy5cbiAgICAgKi9cbiAgICBvYnNlcnZlKCkge1xuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwic2xvdGNoYW5nZVwiLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgb2JzZXJ2YXRpb24gb2YgdGhlIG5vZGVzLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzbG90Y2hhbmdlXCIsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHRoZSB0YXJnZXQuXG4gICAgICovXG4gICAgZ2V0Tm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldC5hc3NpZ25lZE5vZGVzKHRoaXMub3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IG9ic2VydmVzIHRoZSBgYXNzaWduZWROb2RlcygpYCBvZiBhIHNsb3QgYW5kIHVwZGF0ZXMgYSBwcm9wZXJ0eVxuICogd2hlbmV2ZXIgdGhleSBjaGFuZ2UuXG4gKiBAcGFyYW0gcHJvcGVydHlPck9wdGlvbnMgLSBUaGUgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSBzbG90dGVkIG5vZGUgb2JzZXJ2YXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbG90dGVkKHByb3BlcnR5T3JPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcm9wZXJ0eU9yT3B0aW9ucyA9IHsgcHJvcGVydHk6IHByb3BlcnR5T3JPcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXR0YWNoZWRCZWhhdmlvckhUTUxEaXJlY3RpdmUoXCJmYXN0LXNsb3R0ZWRcIiwgU2xvdHRlZEJlaGF2aW9yLCBwcm9wZXJ0eU9yT3B0aW9ucyk7XG59XG4iLCJpbXBvcnQgeyBET00gfSBmcm9tIFwiLi4vZG9tLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0RXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuLi9vYnNlcnZhdGlvbi9vYnNlcnZhYmxlLmpzXCI7XG5pbXBvcnQgeyBjb21waWxlVGVtcGxhdGUgfSBmcm9tIFwiLi9jb21waWxlci5qc1wiO1xuaW1wb3J0IHsgSFRNTFZpZXcgfSBmcm9tIFwiLi92aWV3LmpzXCI7XG5pbXBvcnQgeyBIVE1MRGlyZWN0aXZlLCBUYXJnZXRlZEhUTUxEaXJlY3RpdmUsIH0gZnJvbSBcIi4vaHRtbC1kaXJlY3RpdmUuanNcIjtcbmltcG9ydCB7IEhUTUxCaW5kaW5nRGlyZWN0aXZlIH0gZnJvbSBcIi4vYmluZGluZy5qc1wiO1xuLyoqXG4gKiBBIHRlbXBsYXRlIGNhcGFibGUgb2YgY3JlYXRpbmcgSFRNTFZpZXcgaW5zdGFuY2VzIG9yIHJlbmRlcmluZyBkaXJlY3RseSB0byBET00uXG4gKiBAcHVibGljXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbmV4cG9ydCBjbGFzcyBWaWV3VGVtcGxhdGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVmlld1RlbXBsYXRlLlxuICAgICAqIEBwYXJhbSBodG1sIC0gVGhlIGh0bWwgcmVwcmVzZW50aW5nIHdoYXQgdGhpcyB0ZW1wbGF0ZSB3aWxsIGluc3RhbnRpYXRlLCBpbmNsdWRpbmcgcGxhY2Vob2xkZXJzIGZvciBkaXJlY3RpdmVzLlxuICAgICAqIEBwYXJhbSBkaXJlY3RpdmVzIC0gVGhlIGRpcmVjdGl2ZXMgdGhhdCB3aWxsIGJlIGNvbm5lY3RlZCB0byBwbGFjZWhvbGRlcnMgaW4gdGhlIGh0bWwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaHRtbCwgZGlyZWN0aXZlcykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmhhc0hvc3RCZWhhdmlvcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0T2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy52aWV3QmVoYXZpb3JGYWN0b3JpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmhvc3RCZWhhdmlvckZhY3RvcmllcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaHRtbCA9IGh0bWw7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSFRNTFZpZXcgaW5zdGFuY2UgYmFzZWQgb24gdGhpcyB0ZW1wbGF0ZSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSBob3N0QmluZGluZ1RhcmdldCAtIFRoZSBlbGVtZW50IHRoYXQgaG9zdCBiZWhhdmlvcnMgd2lsbCBiZSBib3VuZCB0by5cbiAgICAgKi9cbiAgICBjcmVhdGUoaG9zdEJpbmRpbmdUYXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSB0aGlzLmh0bWw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGh0bWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBET00uY3JlYXRlSFRNTChodG1sKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmZWMgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChmZWMgIT09IG51bGwgJiYgZmVjLnRhZ05hbWUgPT09IFwiVEVNUExBVEVcIikge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21waWxlVGVtcGxhdGUodGVtcGxhdGUsIHRoaXMuZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gcmVzdWx0LmZyYWdtZW50O1xuICAgICAgICAgICAgdGhpcy52aWV3QmVoYXZpb3JGYWN0b3JpZXMgPSByZXN1bHQudmlld0JlaGF2aW9yRmFjdG9yaWVzO1xuICAgICAgICAgICAgdGhpcy5ob3N0QmVoYXZpb3JGYWN0b3JpZXMgPSByZXN1bHQuaG9zdEJlaGF2aW9yRmFjdG9yaWVzO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRPZmZzZXQgPSByZXN1bHQudGFyZ2V0T2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvckNvdW50ID1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdCZWhhdmlvckZhY3Rvcmllcy5sZW5ndGggKyB0aGlzLmhvc3RCZWhhdmlvckZhY3Rvcmllcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmhhc0hvc3RCZWhhdmlvcnMgPSB0aGlzLmhvc3RCZWhhdmlvckZhY3Rvcmllcy5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHZpZXdGYWN0b3JpZXMgPSB0aGlzLnZpZXdCZWhhdmlvckZhY3RvcmllcztcbiAgICAgICAgY29uc3QgYmVoYXZpb3JzID0gbmV3IEFycmF5KHRoaXMuYmVoYXZpb3JDb3VudCk7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IERPTS5jcmVhdGVUZW1wbGF0ZVdhbGtlcihmcmFnbWVudCk7XG4gICAgICAgIGxldCBiZWhhdmlvckluZGV4ID0gMDtcbiAgICAgICAgbGV0IHRhcmdldEluZGV4ID0gdGhpcy50YXJnZXRPZmZzZXQ7XG4gICAgICAgIGxldCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgIGZvciAobGV0IGlpID0gdmlld0ZhY3Rvcmllcy5sZW5ndGg7IGJlaGF2aW9ySW5kZXggPCBpaTsgKytiZWhhdmlvckluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gdmlld0ZhY3Rvcmllc1tiZWhhdmlvckluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnlJbmRleCA9IGZhY3RvcnkudGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA9PT0gZmFjdG9yeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yc1tiZWhhdmlvckluZGV4XSA9IGZhY3RvcnkuY3JlYXRlQmVoYXZpb3Iobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNIb3N0QmVoYXZpb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBob3N0RmFjdG9yaWVzID0gdGhpcy5ob3N0QmVoYXZpb3JGYWN0b3JpZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBob3N0RmFjdG9yaWVzLmxlbmd0aDsgaSA8IGlpOyArK2ksICsrYmVoYXZpb3JJbmRleCkge1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yc1tiZWhhdmlvckluZGV4XSA9IGhvc3RGYWN0b3JpZXNbaV0uY3JlYXRlQmVoYXZpb3IoaG9zdEJpbmRpbmdUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSFRNTFZpZXcoZnJhZ21lbnQsIGJlaGF2aW9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSFRNTFZpZXcgZnJvbSB0aGlzIHRlbXBsYXRlLCBiaW5kcyBpdCB0byB0aGUgc291cmNlLCBhbmQgdGhlbiBhcHBlbmRzIGl0IHRvIHRoZSBob3N0LlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgZGF0YSBzb3VyY2UgdG8gYmluZCB0aGUgdGVtcGxhdGUgdG8uXG4gICAgICogQHBhcmFtIGhvc3QgLSBUaGUgRWxlbWVudCB3aGVyZSB0aGUgdGVtcGxhdGUgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0gaG9zdEJpbmRpbmdUYXJnZXQgLSBBbiBIVE1MIGVsZW1lbnQgdG8gdGFyZ2V0IHRoZSBob3N0IGJpbmRpbmdzIGF0IGlmIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgICAqIGhvc3QgdGhhdCB0aGUgdGVtcGxhdGUgaXMgYmVpbmcgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgcmVuZGVyKHNvdXJjZSwgaG9zdCwgaG9zdEJpbmRpbmdUYXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBob3N0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBob3N0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RCaW5kaW5nVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhvc3RCaW5kaW5nVGFyZ2V0ID0gaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5jcmVhdGUoaG9zdEJpbmRpbmdUYXJnZXQpO1xuICAgICAgICB2aWV3LmJpbmQoc291cmNlLCBkZWZhdWx0RXhlY3V0aW9uQ29udGV4dCk7XG4gICAgICAgIHZpZXcuYXBwZW5kVG8oaG9zdCk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbn1cbi8vIE11Y2ggdGhhbmtzIHRvIExpdEhUTUwgZm9yIHdvcmtpbmcgdGhpcyBvdXQhXG5jb25zdCBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4ID0gXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleCAqL1xuLyhbIFxceDA5XFx4MGFcXHgwY1xceDBkXSkoW15cXDAtXFx4MUZcXHg3Ri1cXHg5RiBcIic+PS9dKykoWyBcXHgwOVxceDBhXFx4MGNcXHgwZF0qPVsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKig/OlteIFxceDA5XFx4MGFcXHgwY1xceDBkXCInYDw+PV0qfFwiW15cIl0qfCdbXiddKikpJC87XG4vKipcbiAqIFRyYW5zZm9ybXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHN0cmluZyBpbnRvIGEgcmVuZGVyYWJsZSBWaWV3VGVtcGxhdGUuXG4gKiBAcGFyYW0gc3RyaW5ncyAtIFRoZSBzdHJpbmcgZnJhZ21lbnRzIHRoYXQgYXJlIGludGVycG9sYXRlZCB3aXRoIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgd2l0aCB0aGUgc3RyaW5nIGZyYWdtZW50cy5cbiAqIEByZW1hcmtzXG4gKiBUaGUgaHRtbCBoZWxwZXIgc3VwcG9ydHMgaW50ZXJwb2xhdGlvbiBvZiBzdHJpbmdzLCBudW1iZXJzLCBiaW5kaW5nIGV4cHJlc3Npb25zLFxuICogb3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VzLCBhbmQgRGlyZWN0aXZlIGluc3RhbmNlcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IFtdO1xuICAgIGxldCBodG1sID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHJpbmdzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHJpbmcgPSBzdHJpbmdzW2ldO1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGh0bWwgKz0gY3VycmVudFN0cmluZztcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVmlld1RlbXBsYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSAoKSA9PiB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEhUTUxCaW5kaW5nRGlyZWN0aXZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUYXJnZXRlZEhUTUxEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKGN1cnJlbnRTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudGFyZ2V0TmFtZSA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIG5vdCBhbGwgdmFsdWVzIGFyZSBkaXJlY3RpdmVzLCB3ZSBjYW4ndCB1c2UgaVxuICAgICAgICAgICAgLy8gYXMgdGhlIGluZGV4IGZvciB0aGUgcGxhY2Vob2xkZXIuIEluc3RlYWQsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHVzZSBkaXJlY3RpdmVzLmxlbmd0aCB0byBnZXQgdGhlIG5leHQgaW5kZXguXG4gICAgICAgICAgICBodG1sICs9IHZhbHVlLmNyZWF0ZVBsYWNlaG9sZGVyKGRpcmVjdGl2ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodG1sICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwgKz0gc3RyaW5nc1tzdHJpbmdzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBuZXcgVmlld1RlbXBsYXRlKGh0bWwsIGRpcmVjdGl2ZXMpO1xufVxuIiwiLy8gQSBzaW5nbGV0b24gUmFuZ2UgaW5zdGFuY2UgdXNlZCB0byBlZmZpY2llbnRseSByZW1vdmUgcmFuZ2VzIG9mIERPTSBub2Rlcy5cbi8vIFNlZSB0aGUgaW1wbGVtZW50YXRpb24gb2YgSFRNTFZpZXcgYmVsb3cgZm9yIGZ1cnRoZXIgZGV0YWlscy5cbmNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbi8qKlxuICogVGhlIHN0YW5kYXJkIFZpZXcgaW1wbGVtZW50YXRpb24sIHdoaWNoIGFsc28gaW1wbGVtZW50cyBFbGVtZW50VmlldyBhbmQgU3ludGhldGljVmlldy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEhUTUxWaWV3IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEhUTUxWaWV3LlxuICAgICAqIEBwYXJhbSBmcmFnbWVudCAtIFRoZSBodG1sIGZyYWdtZW50IHRoYXQgY29udGFpbnMgdGhlIG5vZGVzIGZvciB0aGlzIHZpZXcuXG4gICAgICogQHBhcmFtIGJlaGF2aW9ycyAtIFRoZSBiZWhhdmlvcnMgdG8gYmUgYXBwbGllZCB0byB0aGlzIHZpZXcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIGJlaGF2aW9ycykge1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID0gYmVoYXZpb3JzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEgdGhhdCB0aGUgdmlldyBpcyBib3VuZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleGVjdXRpb24gY29udGV4dCB0aGUgdmlldyBpcyBydW5uaW5nIHdpdGhpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMubGFzdENoaWxkID0gZnJhZ21lbnQubGFzdENoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoZSB2aWV3J3MgRE9NIG5vZGVzIHRvIHRoZSByZWZlcmVuY2VkIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgcGFyZW50IG5vZGUgdG8gYXBwZW5kIHRoZSB2aWV3J3MgRE9NIG5vZGVzIHRvLlxuICAgICAqL1xuICAgIGFwcGVuZFRvKG5vZGUpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgdmlldydzIERPTSBub2RlcyBiZWZvcmUgdGhlIHJlZmVyZW5jZWQgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGluc2VydCB0aGUgdmlldydzIERPTSBiZWZvcmUuXG4gICAgICovXG4gICAgaW5zZXJ0QmVmb3JlKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjdXJyZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVuZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgdmlldydzIERPTSBub2Rlcy5cbiAgICAgKiBUaGUgbm9kZXMgYXJlIG5vdCBkaXNwb3NlZCBhbmQgdGhlIHZpZXcgY2FuIGxhdGVyIGJlIHJlLWluc2VydGVkLlxuICAgICAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gZW5kKSB7XG4gICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgdmlldyBhbmQgdW5iaW5kcyBpdHMgYmVoYXZpb3JzLCBkaXNwb3Npbmcgb2YgRE9NIG5vZGVzIGFmdGVyd2FyZC5cbiAgICAgKiBPbmNlIGEgdmlldyBoYXMgYmVlbiBkaXNwb3NlZCwgaXQgY2Fubm90IGJlIGluc2VydGVkIG9yIGJvdW5kIGFnYWluLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmlyc3RDaGlsZC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gZW5kKSB7XG4gICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbmQpO1xuICAgICAgICBjb25zdCBiZWhhdmlvcnMgPSB0aGlzLmJlaGF2aW9ycztcbiAgICAgICAgY29uc3Qgb2xkU291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJlaGF2aW9ycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBiZWhhdmlvcnNbaV0udW5iaW5kKG9sZFNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgYSB2aWV3J3MgYmVoYXZpb3JzIHRvIGl0cyBiaW5kaW5nIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gc291cmNlIC0gVGhlIGJpbmRpbmcgc291cmNlIGZvciB0aGUgdmlldydzIGJpbmRpbmcgYmVoYXZpb3JzLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGV4ZWN1dGlvbiBjb250ZXh0IHRvIHJ1biB0aGUgYmVoYXZpb3JzIHdpdGhpbi5cbiAgICAgKi9cbiAgICBiaW5kKHNvdXJjZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBiZWhhdmlvcnMgPSB0aGlzLmJlaGF2aW9ycztcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkU291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBiZWhhdmlvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBiZWhhdmlvcnNbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudC51bmJpbmQob2xkU291cmNlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmJpbmQoc291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJlaGF2aW9ycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3JzW2ldLmJpbmQoc291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIGEgdmlldydzIGJlaGF2aW9ycyBmcm9tIGl0cyBiaW5kaW5nIHNvdXJjZS5cbiAgICAgKi9cbiAgICB1bmJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJlaGF2aW9ycyA9IHRoaXMuYmVoYXZpb3JzO1xuICAgICAgICBjb25zdCBvbGRTb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYmVoYXZpb3JzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGJlaGF2aW9yc1tpXS51bmJpbmQob2xkU291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IGRpc3Bvc2VzIG9mIGEgY29udGlndW91cyByYW5nZSBvZiBzeW50aGV0aWMgdmlldyBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHZpZXdzIC0gQSBjb250aWd1b3VzIHJhbmdlIG9mIHZpZXdzIHRvIGJlIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIHN0YXRpYyBkaXNwb3NlQ29udGlndW91c0JhdGNoKHZpZXdzKSB7XG4gICAgICAgIGlmICh2aWV3cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZSh2aWV3c1swXS5maXJzdENoaWxkKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIodmlld3Nbdmlld3MubGVuZ3RoIC0gMV0ubGFzdENoaWxkKTtcbiAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmlld3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgICAgICAgY29uc3QgYmVoYXZpb3JzID0gdmlldy5iZWhhdmlvcnM7XG4gICAgICAgICAgICBjb25zdCBvbGRTb3VyY2UgPSB2aWV3LnNvdXJjZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGJlaGF2aW9ycy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3JzW2pdLnVuYmluZChvbGRTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gXCIuLi9pbnRlcmZhY2VzLmpzXCI7XG5jb25zdCBub1RlbXBsYXRlID0gKCkgPT4gbnVsbDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJpbmRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG5vVGVtcGxhdGUgOiBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogKCkgPT4gdmFsdWU7XG59XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgZW5hYmxlcyBiYXNpYyBjb25kaXRpb25hbCByZW5kZXJpbmcgaW4gYSB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSBiaW5kaW5nIC0gVGhlIGNvbmRpdGlvbiB0byB0ZXN0IGZvciByZW5kZXJpbmcuXG4gKiBAcGFyYW0gdGVtcGxhdGVPclRlbXBsYXRlQmluZGluZyAtIFRoZSB0ZW1wbGF0ZSBvciBhIGJpbmRpbmcgdGhhdCBnZXRzXG4gKiB0aGUgdGVtcGxhdGUgdG8gcmVuZGVyIHdoZW4gdGhlIGNvbmRpdGlvbiBpcyB0cnVlLlxuICogQHBhcmFtIGVsc2VUZW1wbGF0ZU9yVGVtcGxhdGVCaW5kaW5nIC0gT3B0aW9uYWwgdGVtcGxhdGUgb3IgYmluZGluZyB0aGF0IHRoYXRcbiAqIGdldHMgdGhlIHRlbXBsYXRlIHRvIHJlbmRlciB3aGVuIHRoZSBjb25kaXRpb25hbCBpcyBmYWxzZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdoZW4oYmluZGluZywgdGVtcGxhdGVPclRlbXBsYXRlQmluZGluZywgZWxzZVRlbXBsYXRlT3JUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICBjb25zdCBkYXRhQmluZGluZyA9IGlzRnVuY3Rpb24oYmluZGluZykgPyBiaW5kaW5nIDogKCkgPT4gYmluZGluZztcbiAgICBjb25zdCB0ZW1wbGF0ZUJpbmRpbmcgPSBub3JtYWxpemVCaW5kaW5nKHRlbXBsYXRlT3JUZW1wbGF0ZUJpbmRpbmcpO1xuICAgIGNvbnN0IGVsc2VCaW5kaW5nID0gbm9ybWFsaXplQmluZGluZyhlbHNlVGVtcGxhdGVPclRlbXBsYXRlQmluZGluZyk7XG4gICAgcmV0dXJuIChzb3VyY2UsIGNvbnRleHQpID0+IGRhdGFCaW5kaW5nKHNvdXJjZSwgY29udGV4dClcbiAgICAgICAgPyB0ZW1wbGF0ZUJpbmRpbmcoc291cmNlLCBjb250ZXh0KVxuICAgICAgICA6IGVsc2VCaW5kaW5nKHNvdXJjZSwgY29udGV4dCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=