"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_input_tex_require_RequireConfiguration_js"],{

/***/ "./node_modules/mathjax-full/js/components/global.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/components/global.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathJax = exports.combineWithMathJax = exports.combineDefaults = exports.combineConfig = exports.isObject = void 0;
var version_js_1 = __webpack_require__(/*! ./version.js */ "./node_modules/mathjax-full/js/components/version.js");
function isObject(x) {
    return typeof x === 'object' && x !== null;
}
exports.isObject = isObject;
function combineConfig(dst, src) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            if (id === '__esModule')
                continue;
            if (isObject(dst[id]) && isObject(src[id]) &&
                !(src[id] instanceof Promise)) {
                combineConfig(dst[id], src[id]);
            }
            else if (src[id] !== null && src[id] !== undefined) {
                dst[id] = src[id];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return dst;
}
exports.combineConfig = combineConfig;
function combineDefaults(dst, name, src) {
    var e_2, _a;
    if (!dst[name]) {
        dst[name] = {};
    }
    dst = dst[name];
    try {
        for (var _b = __values(Object.keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            if (isObject(dst[id]) && isObject(src[id])) {
                combineDefaults(dst, id, src[id]);
            }
            else if (dst[id] == null && src[id] != null) {
                dst[id] = src[id];
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return dst;
}
exports.combineDefaults = combineDefaults;
function combineWithMathJax(config) {
    return combineConfig(exports.MathJax, config);
}
exports.combineWithMathJax = combineWithMathJax;
if (typeof __webpack_require__.g.MathJax === 'undefined') {
    __webpack_require__.g.MathJax = {};
}
if (!__webpack_require__.g.MathJax.version) {
    __webpack_require__.g.MathJax = {
        version: version_js_1.VERSION,
        _: {},
        config: __webpack_require__.g.MathJax
    };
}
exports.MathJax = __webpack_require__.g.MathJax;
//# sourceMappingURL=global.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/components/loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/components/loader.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var __dirname = "/";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var e_1, _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CONFIG = exports.MathJax = exports.Loader = exports.PathFilters = exports.PackageError = exports.Package = void 0;
var global_js_1 = __webpack_require__(/*! ./global.js */ "./node_modules/mathjax-full/js/components/global.js");
var package_js_1 = __webpack_require__(/*! ./package.js */ "./node_modules/mathjax-full/js/components/package.js");
var package_js_2 = __webpack_require__(/*! ./package.js */ "./node_modules/mathjax-full/js/components/package.js");
Object.defineProperty(exports, "Package", ({ enumerable: true, get: function () { return package_js_2.Package; } }));
Object.defineProperty(exports, "PackageError", ({ enumerable: true, get: function () { return package_js_2.PackageError; } }));
var FunctionList_js_1 = __webpack_require__(/*! ../util/FunctionList.js */ "./node_modules/mathjax-full/js/util/FunctionList.js");
exports.PathFilters = {
    source: function (data) {
        if (exports.CONFIG.source.hasOwnProperty(data.name)) {
            data.name = exports.CONFIG.source[data.name];
        }
        return true;
    },
    normalize: function (data) {
        var name = data.name;
        if (!name.match(/^(?:[a-z]+:\/)?\/|[a-z]:\\|\[/i)) {
            data.name = '[mathjax]/' + name.replace(/^\.\//, '');
        }
        if (data.addExtension && !name.match(/\.[^\/]+$/)) {
            data.name += '.js';
        }
        return true;
    },
    prefix: function (data) {
        var match;
        while ((match = data.name.match(/^\[([^\]]*)\]/))) {
            if (!exports.CONFIG.paths.hasOwnProperty(match[1]))
                break;
            data.name = exports.CONFIG.paths[match[1]] + data.name.substr(match[0].length);
        }
        return true;
    }
};
var Loader;
(function (Loader) {
    var VERSION = global_js_1.MathJax.version;
    Loader.versions = new Map();
    function ready() {
        var e_2, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        if (names.length === 0) {
            names = Array.from(package_js_1.Package.packages.keys());
        }
        var promises = [];
        try {
            for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                var name_1 = names_1_1.value;
                var extension = package_js_1.Package.packages.get(name_1) || new package_js_1.Package(name_1, true);
                promises.push(extension.promise);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return Promise.all(promises);
    }
    Loader.ready = ready;
    function load() {
        var e_3, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        if (names.length === 0) {
            return Promise.resolve();
        }
        var promises = [];
        var _loop_1 = function (name_2) {
            var extension = package_js_1.Package.packages.get(name_2);
            if (!extension) {
                extension = new package_js_1.Package(name_2);
                extension.provides(exports.CONFIG.provides[name_2]);
            }
            extension.checkNoLoad();
            promises.push(extension.promise.then(function () {
                if (!exports.CONFIG.versionWarnings)
                    return;
                if (extension.isLoaded && !Loader.versions.has(package_js_1.Package.resolvePath(name_2))) {
                    console.warn("No version information available for component ".concat(name_2));
                }
            }));
        };
        try {
            for (var names_2 = __values(names), names_2_1 = names_2.next(); !names_2_1.done; names_2_1 = names_2.next()) {
                var name_2 = names_2_1.value;
                _loop_1(name_2);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (names_2_1 && !names_2_1.done && (_a = names_2.return)) _a.call(names_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        package_js_1.Package.loadAll();
        return Promise.all(promises);
    }
    Loader.load = load;
    function preLoad() {
        var e_4, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        try {
            for (var names_3 = __values(names), names_3_1 = names_3.next(); !names_3_1.done; names_3_1 = names_3.next()) {
                var name_3 = names_3_1.value;
                var extension = package_js_1.Package.packages.get(name_3);
                if (!extension) {
                    extension = new package_js_1.Package(name_3, true);
                    extension.provides(exports.CONFIG.provides[name_3]);
                }
                extension.loaded();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (names_3_1 && !names_3_1.done && (_a = names_3.return)) _a.call(names_3);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    Loader.preLoad = preLoad;
    function defaultReady() {
        if (typeof exports.MathJax.startup !== 'undefined') {
            exports.MathJax.config.startup.ready();
        }
    }
    Loader.defaultReady = defaultReady;
    function getRoot() {
        var root = __dirname + '/../../es5';
        if (typeof document !== 'undefined') {
            var script = document.currentScript || document.getElementById('MathJax-script');
            if (script) {
                root = script.src.replace(/\/[^\/]*$/, '');
            }
        }
        return root;
    }
    Loader.getRoot = getRoot;
    function checkVersion(name, version, _type) {
        Loader.versions.set(package_js_1.Package.resolvePath(name), VERSION);
        if (exports.CONFIG.versionWarnings && version !== VERSION) {
            console.warn("Component ".concat(name, " uses ").concat(version, " of MathJax; version in use is ").concat(VERSION));
            return true;
        }
        return false;
    }
    Loader.checkVersion = checkVersion;
    Loader.pathFilters = new FunctionList_js_1.FunctionList();
    Loader.pathFilters.add(exports.PathFilters.source, 0);
    Loader.pathFilters.add(exports.PathFilters.normalize, 10);
    Loader.pathFilters.add(exports.PathFilters.prefix, 20);
})(Loader = exports.Loader || (exports.Loader = {}));
exports.MathJax = global_js_1.MathJax;
if (typeof exports.MathJax.loader === 'undefined') {
    (0, global_js_1.combineDefaults)(exports.MathJax.config, 'loader', {
        paths: {
            mathjax: Loader.getRoot()
        },
        source: {},
        dependencies: {},
        provides: {},
        load: [],
        ready: Loader.defaultReady.bind(Loader),
        failed: function (error) { return console.log("MathJax(".concat(error.package || '?', "): ").concat(error.message)); },
        require: null,
        pathFilters: [],
        versionWarnings: true
    });
    (0, global_js_1.combineWithMathJax)({
        loader: Loader
    });
    try {
        for (var _b = __values(exports.MathJax.config.loader.pathFilters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var filter = _c.value;
            if (Array.isArray(filter)) {
                Loader.pathFilters.add(filter[0], filter[1]);
            }
            else {
                Loader.pathFilters.add(filter);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.CONFIG = exports.MathJax.config.loader;
//# sourceMappingURL=loader.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/components/package.js":
/*!************************************************************!*\
  !*** ./node_modules/mathjax-full/js/components/package.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Package = exports.PackageError = void 0;
var loader_js_1 = __webpack_require__(/*! ./loader.js */ "./node_modules/mathjax-full/js/components/loader.js");
var PackageError = (function (_super) {
    __extends(PackageError, _super);
    function PackageError(message, name) {
        var _this = _super.call(this, message) || this;
        _this.package = name;
        return _this;
    }
    return PackageError;
}(Error));
exports.PackageError = PackageError;
var Package = (function () {
    function Package(name, noLoad) {
        if (noLoad === void 0) { noLoad = false; }
        this.isLoaded = false;
        this.isLoading = false;
        this.hasFailed = false;
        this.dependents = [];
        this.dependencies = [];
        this.dependencyCount = 0;
        this.provided = [];
        this.name = name;
        this.noLoad = noLoad;
        Package.packages.set(name, this);
        this.promise = this.makePromise(this.makeDependencies());
    }
    Object.defineProperty(Package.prototype, "canLoad", {
        get: function () {
            return this.dependencyCount === 0 && !this.noLoad && !this.isLoading && !this.hasFailed;
        },
        enumerable: false,
        configurable: true
    });
    Package.resolvePath = function (name, addExtension) {
        if (addExtension === void 0) { addExtension = true; }
        var data = { name: name, original: name, addExtension: addExtension };
        loader_js_1.Loader.pathFilters.execute(data);
        return data.name;
    };
    Package.loadAll = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.packages.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var extension = _c.value;
                if (extension.canLoad) {
                    extension.load();
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Package.prototype.makeDependencies = function () {
        var e_2, _a;
        var promises = [];
        var map = Package.packages;
        var noLoad = this.noLoad;
        var name = this.name;
        var dependencies = [];
        if (loader_js_1.CONFIG.dependencies.hasOwnProperty(name)) {
            dependencies.push.apply(dependencies, __spreadArray([], __read(loader_js_1.CONFIG.dependencies[name]), false));
        }
        else if (name !== 'core') {
            dependencies.push('core');
        }
        try {
            for (var dependencies_1 = __values(dependencies), dependencies_1_1 = dependencies_1.next(); !dependencies_1_1.done; dependencies_1_1 = dependencies_1.next()) {
                var dependent = dependencies_1_1.value;
                var extension = map.get(dependent) || new Package(dependent, noLoad);
                if (this.dependencies.indexOf(extension) < 0) {
                    extension.addDependent(this, noLoad);
                    this.dependencies.push(extension);
                    if (!extension.isLoaded) {
                        this.dependencyCount++;
                        promises.push(extension.promise);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (dependencies_1_1 && !dependencies_1_1.done && (_a = dependencies_1.return)) _a.call(dependencies_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return promises;
    };
    Package.prototype.makePromise = function (promises) {
        var _this = this;
        var promise = new Promise((function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        }));
        var config = (loader_js_1.CONFIG[this.name] || {});
        if (config.ready) {
            promise = promise.then(function (_name) { return config.ready(_this.name); });
        }
        if (promises.length) {
            promises.push(promise);
            promise = Promise.all(promises).then(function (names) { return names.join(', '); });
        }
        if (config.failed) {
            promise.catch(function (message) { return config.failed(new PackageError(message, _this.name)); });
        }
        return promise;
    };
    Package.prototype.load = function () {
        if (!this.isLoaded && !this.isLoading && !this.noLoad) {
            this.isLoading = true;
            var url = Package.resolvePath(this.name);
            if (loader_js_1.CONFIG.require) {
                this.loadCustom(url);
            }
            else {
                this.loadScript(url);
            }
        }
    };
    Package.prototype.loadCustom = function (url) {
        var _this = this;
        try {
            var result = loader_js_1.CONFIG.require(url);
            if (result instanceof Promise) {
                result.then(function () { return _this.checkLoad(); })
                    .catch(function (err) { return _this.failed('Can\'t load "' + url + '"\n' + err.message.trim()); });
            }
            else {
                this.checkLoad();
            }
        }
        catch (err) {
            this.failed(err.message);
        }
    };
    Package.prototype.loadScript = function (url) {
        var _this = this;
        var script = document.createElement('script');
        script.src = url;
        script.charset = 'UTF-8';
        script.onload = function (_event) { return _this.checkLoad(); };
        script.onerror = function (_event) { return _this.failed('Can\'t load "' + url + '"'); };
        document.head.appendChild(script);
    };
    Package.prototype.loaded = function () {
        var e_3, _a, e_4, _b;
        this.isLoaded = true;
        this.isLoading = false;
        try {
            for (var _c = __values(this.dependents), _d = _c.next(); !_d.done; _d = _c.next()) {
                var dependent = _d.value;
                dependent.requirementSatisfied();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var _e = __values(this.provided), _f = _e.next(); !_f.done; _f = _e.next()) {
                var provided = _f.value;
                provided.loaded();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.resolve(this.name);
    };
    Package.prototype.failed = function (message) {
        this.hasFailed = true;
        this.isLoading = false;
        this.reject(new PackageError(message, this.name));
    };
    Package.prototype.checkLoad = function () {
        var _this = this;
        var config = (loader_js_1.CONFIG[this.name] || {});
        var checkReady = config.checkReady || (function () { return Promise.resolve(); });
        checkReady().then(function () { return _this.loaded(); })
            .catch(function (message) { return _this.failed(message); });
    };
    Package.prototype.requirementSatisfied = function () {
        if (this.dependencyCount) {
            this.dependencyCount--;
            if (this.canLoad) {
                this.load();
            }
        }
    };
    Package.prototype.provides = function (names) {
        var e_5, _a;
        if (names === void 0) { names = []; }
        try {
            for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                var name_1 = names_1_1.value;
                var provided = Package.packages.get(name_1);
                if (!provided) {
                    if (!loader_js_1.CONFIG.dependencies[name_1]) {
                        loader_js_1.CONFIG.dependencies[name_1] = [];
                    }
                    loader_js_1.CONFIG.dependencies[name_1].push(name_1);
                    provided = new Package(name_1, true);
                    provided.isLoading = true;
                }
                this.provided.push(provided);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    Package.prototype.addDependent = function (extension, noLoad) {
        this.dependents.push(extension);
        if (!noLoad) {
            this.checkNoLoad();
        }
    };
    Package.prototype.checkNoLoad = function () {
        var e_6, _a;
        if (this.noLoad) {
            this.noLoad = false;
            try {
                for (var _b = __values(this.dependencies), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var dependency = _c.value;
                    dependency.checkNoLoad();
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
    };
    Package.packages = new Map();
    return Package;
}());
exports.Package = Package;
//# sourceMappingURL=package.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/require/RequireConfiguration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/require/RequireConfiguration.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequireConfiguration = exports.options = exports.RequireMethods = exports.RequireLoad = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "./node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var global_js_1 = __webpack_require__(/*! ../../../components/global.js */ "./node_modules/mathjax-full/js/components/global.js");
var package_js_1 = __webpack_require__(/*! ../../../components/package.js */ "./node_modules/mathjax-full/js/components/package.js");
var loader_js_1 = __webpack_require__(/*! ../../../components/loader.js */ "./node_modules/mathjax-full/js/components/loader.js");
var mathjax_js_1 = __webpack_require__(/*! ../../../mathjax.js */ "./node_modules/mathjax-full/js/mathjax.js");
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var MJCONFIG = global_js_1.MathJax.config;
function RegisterExtension(jax, name) {
    var _a;
    var require = jax.parseOptions.options.require;
    var required = jax.parseOptions.packageData.get('require').required;
    var extension = name.substr(require.prefix.length);
    if (required.indexOf(extension) < 0) {
        required.push(extension);
        RegisterDependencies(jax, loader_js_1.CONFIG.dependencies[name]);
        var handler = Configuration_js_1.ConfigurationHandler.get(extension);
        if (handler) {
            var options_1 = MJCONFIG[name] || {};
            if (handler.options && Object.keys(handler.options).length === 1 && handler.options[extension]) {
                options_1 = (_a = {}, _a[extension] = options_1, _a);
            }
            jax.configuration.add(extension, jax, options_1);
            var configured = jax.parseOptions.packageData.get('require').configured;
            if (handler.preprocessors.length && !configured.has(extension)) {
                configured.set(extension, true);
                mathjax_js_1.mathjax.retryAfter(Promise.resolve());
            }
        }
    }
}
function RegisterDependencies(jax, names) {
    var e_1, _a;
    if (names === void 0) { names = []; }
    var prefix = jax.parseOptions.options.require.prefix;
    try {
        for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
            var name_1 = names_1_1.value;
            if (name_1.substr(0, prefix.length) === prefix) {
                RegisterExtension(jax, name_1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function RequireLoad(parser, name) {
    var options = parser.options.require;
    var allow = options.allow;
    var extension = (name.substr(0, 1) === '[' ? '' : options.prefix) + name;
    var allowed = (allow.hasOwnProperty(extension) ? allow[extension] :
        allow.hasOwnProperty(name) ? allow[name] : options.defaultAllow);
    if (!allowed) {
        throw new TexError_js_1.default('BadRequire', 'Extension "%1" is not allowed to be loaded', extension);
    }
    if (package_js_1.Package.packages.has(extension)) {
        RegisterExtension(parser.configuration.packageData.get('require').jax, extension);
    }
    else {
        mathjax_js_1.mathjax.retryAfter(loader_js_1.Loader.load(extension));
    }
}
exports.RequireLoad = RequireLoad;
function config(_config, jax) {
    jax.parseOptions.packageData.set('require', {
        jax: jax,
        required: __spreadArray([], __read(jax.options.packages), false),
        configured: new Map()
    });
    var options = jax.parseOptions.options.require;
    var prefix = options.prefix;
    if (prefix.match(/[^_a-zA-Z0-9]/)) {
        throw Error('Illegal characters used in \\require prefix');
    }
    if (!loader_js_1.CONFIG.paths[prefix]) {
        loader_js_1.CONFIG.paths[prefix] = '[mathjax]/input/tex/extensions';
    }
    options.prefix = '[' + prefix + ']/';
}
exports.RequireMethods = {
    Require: function (parser, name) {
        var required = parser.GetArgument(name);
        if (required.match(/[^_a-zA-Z0-9]/) || required === '') {
            throw new TexError_js_1.default('BadPackageName', 'Argument for %1 is not a valid package name', name);
        }
        RequireLoad(parser, required);
    }
};
exports.options = {
    require: {
        allow: (0, Options_js_1.expandable)({
            base: false,
            'all-packages': false,
            autoload: false,
            configmacros: false,
            tagformat: false,
            setoptions: false
        }),
        defaultAllow: true,
        prefix: 'tex'
    }
};
new SymbolMap_js_1.CommandMap('require', { require: 'Require' }, exports.RequireMethods);
exports.RequireConfiguration = Configuration_js_1.Configuration.create('require', { handler: { macro: ['require'] }, config: config, options: exports.options });
//# sourceMappingURL=RequireConfiguration.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2lucHV0X3RleF9yZXF1aXJlX1JlcXVpcmVDb25maWd1cmF0aW9uX2pzLjE1MTM1ZDUyZWJjZjg0NWJiZjVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDakgsbUJBQW1CLG1CQUFPLENBQUMsMEVBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsV0FBVyxxQkFBTTtBQUNqQixJQUFJLHFCQUFNO0FBQ1Y7QUFDQSxLQUFLLHFCQUFNO0FBQ1gsSUFBSSxxQkFBTTtBQUNWO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQixxQkFBTTtBQUN0QjtBQUNBO0FBQ0EsZUFBZSxHQUFHLHFCQUFNO0FBQ3hCOzs7Ozs7Ozs7OztBQ3ZGYTtBQUNiO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRCw0QkFBNEIsd0RBQXdELFdBQVcsb0JBQW9CLDRDQUE0QztBQUMvSiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29tcG9uZW50cy9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9jb21wb25lbnRzL2xvYWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvbXBvbmVudHMvcGFja2FnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9yZXF1aXJlL1JlcXVpcmVDb25maWd1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXRoSmF4ID0gZXhwb3J0cy5jb21iaW5lV2l0aE1hdGhKYXggPSBleHBvcnRzLmNvbWJpbmVEZWZhdWx0cyA9IGV4cG9ydHMuY29tYmluZUNvbmZpZyA9IGV4cG9ydHMuaXNPYmplY3QgPSB2b2lkIDA7XG52YXIgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKTtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5mdW5jdGlvbiBjb21iaW5lQ29uZmlnKGRzdCwgc3JjKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzcmMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2MudmFsdWU7XG4gICAgICAgICAgICBpZiAoaWQgPT09ICdfX2VzTW9kdWxlJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChkc3RbaWRdKSAmJiBpc09iamVjdChzcmNbaWRdKSAmJlxuICAgICAgICAgICAgICAgICEoc3JjW2lkXSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZUNvbmZpZyhkc3RbaWRdLCBzcmNbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNyY1tpZF0gIT09IG51bGwgJiYgc3JjW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZHN0W2lkXSA9IHNyY1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59XG5leHBvcnRzLmNvbWJpbmVDb25maWcgPSBjb21iaW5lQ29uZmlnO1xuZnVuY3Rpb24gY29tYmluZURlZmF1bHRzKGRzdCwgbmFtZSwgc3JjKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgaWYgKCFkc3RbbmFtZV0pIHtcbiAgICAgICAgZHN0W25hbWVdID0ge307XG4gICAgfVxuICAgIGRzdCA9IGRzdFtuYW1lXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKHNyYykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChkc3RbaWRdKSAmJiBpc09iamVjdChzcmNbaWRdKSkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVEZWZhdWx0cyhkc3QsIGlkLCBzcmNbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRzdFtpZF0gPT0gbnVsbCAmJiBzcmNbaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkc3RbaWRdID0gc3JjW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbmV4cG9ydHMuY29tYmluZURlZmF1bHRzID0gY29tYmluZURlZmF1bHRzO1xuZnVuY3Rpb24gY29tYmluZVdpdGhNYXRoSmF4KGNvbmZpZykge1xuICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGV4cG9ydHMuTWF0aEpheCwgY29uZmlnKTtcbn1cbmV4cG9ydHMuY29tYmluZVdpdGhNYXRoSmF4ID0gY29tYmluZVdpdGhNYXRoSmF4O1xuaWYgKHR5cGVvZiBnbG9iYWwuTWF0aEpheCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWwuTWF0aEpheCA9IHt9O1xufVxuaWYgKCFnbG9iYWwuTWF0aEpheC52ZXJzaW9uKSB7XG4gICAgZ2xvYmFsLk1hdGhKYXggPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb25fanNfMS5WRVJTSU9OLFxuICAgICAgICBfOiB7fSxcbiAgICAgICAgY29uZmlnOiBnbG9iYWwuTWF0aEpheFxuICAgIH07XG59XG5leHBvcnRzLk1hdGhKYXggPSBnbG9iYWwuTWF0aEpheDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBlXzEsIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DT05GSUcgPSBleHBvcnRzLk1hdGhKYXggPSBleHBvcnRzLkxvYWRlciA9IGV4cG9ydHMuUGF0aEZpbHRlcnMgPSBleHBvcnRzLlBhY2thZ2VFcnJvciA9IGV4cG9ydHMuUGFja2FnZSA9IHZvaWQgMDtcbnZhciBnbG9iYWxfanNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbC5qc1wiKTtcbnZhciBwYWNrYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9wYWNrYWdlLmpzXCIpO1xudmFyIHBhY2thZ2VfanNfMiA9IHJlcXVpcmUoXCIuL3BhY2thZ2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYWNrYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYWNrYWdlX2pzXzIuUGFja2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhY2thZ2VFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFja2FnZV9qc18yLlBhY2thZ2VFcnJvcjsgfSB9KTtcbnZhciBGdW5jdGlvbkxpc3RfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0Z1bmN0aW9uTGlzdC5qc1wiKTtcbmV4cG9ydHMuUGF0aEZpbHRlcnMgPSB7XG4gICAgc291cmNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5DT05GSUcuc291cmNlLmhhc093blByb3BlcnR5KGRhdGEubmFtZSkpIHtcbiAgICAgICAgICAgIGRhdGEubmFtZSA9IGV4cG9ydHMuQ09ORklHLnNvdXJjZVtkYXRhLm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgaWYgKCFuYW1lLm1hdGNoKC9eKD86W2Etel0rOlxcLyk/XFwvfFthLXpdOlxcXFx8XFxbL2kpKSB7XG4gICAgICAgICAgICBkYXRhLm5hbWUgPSAnW21hdGhqYXhdLycgKyBuYW1lLnJlcGxhY2UoL15cXC5cXC8vLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYWRkRXh0ZW5zaW9uICYmICFuYW1lLm1hdGNoKC9cXC5bXlxcL10rJC8pKSB7XG4gICAgICAgICAgICBkYXRhLm5hbWUgKz0gJy5qcyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcmVmaXg6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGRhdGEubmFtZS5tYXRjaCgvXlxcWyhbXlxcXV0qKVxcXS8pKSkge1xuICAgICAgICAgICAgaWYgKCFleHBvcnRzLkNPTkZJRy5wYXRocy5oYXNPd25Qcm9wZXJ0eShtYXRjaFsxXSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkYXRhLm5hbWUgPSBleHBvcnRzLkNPTkZJRy5wYXRoc1ttYXRjaFsxXV0gKyBkYXRhLm5hbWUuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbnZhciBMb2FkZXI7XG4oZnVuY3Rpb24gKExvYWRlcikge1xuICAgIHZhciBWRVJTSU9OID0gZ2xvYmFsX2pzXzEuTWF0aEpheC52ZXJzaW9uO1xuICAgIExvYWRlci52ZXJzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuYW1lcyA9IEFycmF5LmZyb20ocGFja2FnZV9qc18xLlBhY2thZ2UucGFja2FnZXMua2V5cygpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVzXzEgPSBfX3ZhbHVlcyhuYW1lcyksIG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpOyAhbmFtZXNfMV8xLmRvbmU7IG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gcGFja2FnZV9qc18xLlBhY2thZ2UucGFja2FnZXMuZ2V0KG5hbWVfMSkgfHwgbmV3IHBhY2thZ2VfanNfMS5QYWNrYWdlKG5hbWVfMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChleHRlbnNpb24ucHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc18xXzEgJiYgIW5hbWVzXzFfMS5kb25lICYmIChfYSA9IG5hbWVzXzEucmV0dXJuKSkgX2EuY2FsbChuYW1lc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBMb2FkZXIucmVhZHkgPSByZWFkeTtcbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobmFtZV8yKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gcGFja2FnZV9qc18xLlBhY2thZ2UucGFja2FnZXMuZ2V0KG5hbWVfMik7XG4gICAgICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBwYWNrYWdlX2pzXzEuUGFja2FnZShuYW1lXzIpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5wcm92aWRlcyhleHBvcnRzLkNPTkZJRy5wcm92aWRlc1tuYW1lXzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuc2lvbi5jaGVja05vTG9hZCgpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChleHRlbnNpb24ucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cG9ydHMuQ09ORklHLnZlcnNpb25XYXJuaW5ncylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24uaXNMb2FkZWQgJiYgIUxvYWRlci52ZXJzaW9ucy5oYXMocGFja2FnZV9qc18xLlBhY2thZ2UucmVzb2x2ZVBhdGgobmFtZV8yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gdmVyc2lvbiBpbmZvcm1hdGlvbiBhdmFpbGFibGUgZm9yIGNvbXBvbmVudCBcIi5jb25jYXQobmFtZV8yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXNfMiA9IF9fdmFsdWVzKG5hbWVzKSwgbmFtZXNfMl8xID0gbmFtZXNfMi5uZXh0KCk7ICFuYW1lc18yXzEuZG9uZTsgbmFtZXNfMl8xID0gbmFtZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gbmFtZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9sb29wXzEobmFtZV8yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzXzJfMSAmJiAhbmFtZXNfMl8xLmRvbmUgJiYgKF9hID0gbmFtZXNfMi5yZXR1cm4pKSBfYS5jYWxsKG5hbWVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHBhY2thZ2VfanNfMS5QYWNrYWdlLmxvYWRBbGwoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgTG9hZGVyLmxvYWQgPSBsb2FkO1xuICAgIGZ1bmN0aW9uIHByZUxvYWQoKSB7XG4gICAgICAgIHZhciBlXzQsIF9hO1xuICAgICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVzXzMgPSBfX3ZhbHVlcyhuYW1lcyksIG5hbWVzXzNfMSA9IG5hbWVzXzMubmV4dCgpOyAhbmFtZXNfM18xLmRvbmU7IG5hbWVzXzNfMSA9IG5hbWVzXzMubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMyA9IG5hbWVzXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gcGFja2FnZV9qc18xLlBhY2thZ2UucGFja2FnZXMuZ2V0KG5hbWVfMyk7XG4gICAgICAgICAgICAgICAgaWYgKCFleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IHBhY2thZ2VfanNfMS5QYWNrYWdlKG5hbWVfMywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5wcm92aWRlcyhleHBvcnRzLkNPTkZJRy5wcm92aWRlc1tuYW1lXzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmxvYWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNfM18xICYmICFuYW1lc18zXzEuZG9uZSAmJiAoX2EgPSBuYW1lc18zLnJldHVybikpIF9hLmNhbGwobmFtZXNfMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgTG9hZGVyLnByZUxvYWQgPSBwcmVMb2FkO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkeSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBvcnRzLk1hdGhKYXguc3RhcnR1cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTWF0aEpheC5jb25maWcuc3RhcnR1cC5yZWFkeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvYWRlci5kZWZhdWx0UmVhZHkgPSBkZWZhdWx0UmVhZHk7XG4gICAgZnVuY3Rpb24gZ2V0Um9vdCgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfX2Rpcm5hbWUgKyAnLy4uLy4uL2VzNSc7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdCB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnTWF0aEpheC1zY3JpcHQnKTtcbiAgICAgICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICByb290ID0gc2NyaXB0LnNyYy5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgTG9hZGVyLmdldFJvb3QgPSBnZXRSb290O1xuICAgIGZ1bmN0aW9uIGNoZWNrVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCBfdHlwZSkge1xuICAgICAgICBMb2FkZXIudmVyc2lvbnMuc2V0KHBhY2thZ2VfanNfMS5QYWNrYWdlLnJlc29sdmVQYXRoKG5hbWUpLCBWRVJTSU9OKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuQ09ORklHLnZlcnNpb25XYXJuaW5ncyAmJiB2ZXJzaW9uICE9PSBWRVJTSU9OKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb21wb25lbnQgXCIuY29uY2F0KG5hbWUsIFwiIHVzZXMgXCIpLmNvbmNhdCh2ZXJzaW9uLCBcIiBvZiBNYXRoSmF4OyB2ZXJzaW9uIGluIHVzZSBpcyBcIikuY29uY2F0KFZFUlNJT04pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgTG9hZGVyLmNoZWNrVmVyc2lvbiA9IGNoZWNrVmVyc2lvbjtcbiAgICBMb2FkZXIucGF0aEZpbHRlcnMgPSBuZXcgRnVuY3Rpb25MaXN0X2pzXzEuRnVuY3Rpb25MaXN0KCk7XG4gICAgTG9hZGVyLnBhdGhGaWx0ZXJzLmFkZChleHBvcnRzLlBhdGhGaWx0ZXJzLnNvdXJjZSwgMCk7XG4gICAgTG9hZGVyLnBhdGhGaWx0ZXJzLmFkZChleHBvcnRzLlBhdGhGaWx0ZXJzLm5vcm1hbGl6ZSwgMTApO1xuICAgIExvYWRlci5wYXRoRmlsdGVycy5hZGQoZXhwb3J0cy5QYXRoRmlsdGVycy5wcmVmaXgsIDIwKTtcbn0pKExvYWRlciA9IGV4cG9ydHMuTG9hZGVyIHx8IChleHBvcnRzLkxvYWRlciA9IHt9KSk7XG5leHBvcnRzLk1hdGhKYXggPSBnbG9iYWxfanNfMS5NYXRoSmF4O1xuaWYgKHR5cGVvZiBleHBvcnRzLk1hdGhKYXgubG9hZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICgwLCBnbG9iYWxfanNfMS5jb21iaW5lRGVmYXVsdHMpKGV4cG9ydHMuTWF0aEpheC5jb25maWcsICdsb2FkZXInLCB7XG4gICAgICAgIHBhdGhzOiB7XG4gICAgICAgICAgICBtYXRoamF4OiBMb2FkZXIuZ2V0Um9vdCgpXG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZToge30sXG4gICAgICAgIGRlcGVuZGVuY2llczoge30sXG4gICAgICAgIHByb3ZpZGVzOiB7fSxcbiAgICAgICAgbG9hZDogW10sXG4gICAgICAgIHJlYWR5OiBMb2FkZXIuZGVmYXVsdFJlYWR5LmJpbmQoTG9hZGVyKSxcbiAgICAgICAgZmFpbGVkOiBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGNvbnNvbGUubG9nKFwiTWF0aEpheChcIi5jb25jYXQoZXJyb3IucGFja2FnZSB8fCAnPycsIFwiKTogXCIpLmNvbmNhdChlcnJvci5tZXNzYWdlKSk7IH0sXG4gICAgICAgIHJlcXVpcmU6IG51bGwsXG4gICAgICAgIHBhdGhGaWx0ZXJzOiBbXSxcbiAgICAgICAgdmVyc2lvbldhcm5pbmdzOiB0cnVlXG4gICAgfSk7XG4gICAgKDAsIGdsb2JhbF9qc18xLmNvbWJpbmVXaXRoTWF0aEpheCkoe1xuICAgICAgICBsb2FkZXI6IExvYWRlclxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoZXhwb3J0cy5NYXRoSmF4LmNvbmZpZy5sb2FkZXIucGF0aEZpbHRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gX2MudmFsdWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgTG9hZGVyLnBhdGhGaWx0ZXJzLmFkZChmaWx0ZXJbMF0sIGZpbHRlclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2FkZXIucGF0aEZpbHRlcnMuYWRkKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxufVxuZXhwb3J0cy5DT05GSUcgPSBleHBvcnRzLk1hdGhKYXguY29uZmlnLmxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhY2thZ2UgPSBleHBvcnRzLlBhY2thZ2VFcnJvciA9IHZvaWQgMDtcbnZhciBsb2FkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2xvYWRlci5qc1wiKTtcbnZhciBQYWNrYWdlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYWNrYWdlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFja2FnZUVycm9yKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFja2FnZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhY2thZ2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUGFja2FnZUVycm9yID0gUGFja2FnZUVycm9yO1xudmFyIFBhY2thZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhY2thZ2UobmFtZSwgbm9Mb2FkKSB7XG4gICAgICAgIGlmIChub0xvYWQgPT09IHZvaWQgMCkgeyBub0xvYWQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVwZW5kZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJvdmlkZWQgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ub0xvYWQgPSBub0xvYWQ7XG4gICAgICAgIFBhY2thZ2UucGFja2FnZXMuc2V0KG5hbWUsIHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLm1ha2VQcm9taXNlKHRoaXMubWFrZURlcGVuZGVuY2llcygpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhY2thZ2UucHJvdG90eXBlLCBcImNhbkxvYWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lDb3VudCA9PT0gMCAmJiAhdGhpcy5ub0xvYWQgJiYgIXRoaXMuaXNMb2FkaW5nICYmICF0aGlzLmhhc0ZhaWxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFBhY2thZ2UucmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAobmFtZSwgYWRkRXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChhZGRFeHRlbnNpb24gPT09IHZvaWQgMCkgeyBhZGRFeHRlbnNpb24gPSB0cnVlOyB9XG4gICAgICAgIHZhciBkYXRhID0geyBuYW1lOiBuYW1lLCBvcmlnaW5hbDogbmFtZSwgYWRkRXh0ZW5zaW9uOiBhZGRFeHRlbnNpb24gfTtcbiAgICAgICAgbG9hZGVyX2pzXzEuTG9hZGVyLnBhdGhGaWx0ZXJzLmV4ZWN1dGUoZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgfTtcbiAgICBQYWNrYWdlLmxvYWRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnBhY2thZ2VzLnZhbHVlcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmNhbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUubWFrZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICB2YXIgbWFwID0gUGFja2FnZS5wYWNrYWdlcztcbiAgICAgICAgdmFyIG5vTG9hZCA9IHRoaXMubm9Mb2FkO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBpZiAobG9hZGVyX2pzXzEuQ09ORklHLmRlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2guYXBwbHkoZGVwZW5kZW5jaWVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobG9hZGVyX2pzXzEuQ09ORklHLmRlcGVuZGVuY2llc1tuYW1lXSksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2NvcmUnKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCgnY29yZScpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkZXBlbmRlbmNpZXNfMSA9IF9fdmFsdWVzKGRlcGVuZGVuY2llcyksIGRlcGVuZGVuY2llc18xXzEgPSBkZXBlbmRlbmNpZXNfMS5uZXh0KCk7ICFkZXBlbmRlbmNpZXNfMV8xLmRvbmU7IGRlcGVuZGVuY2llc18xXzEgPSBkZXBlbmRlbmNpZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW50ID0gZGVwZW5kZW5jaWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gbWFwLmdldChkZXBlbmRlbnQpIHx8IG5ldyBQYWNrYWdlKGRlcGVuZGVudCwgbm9Mb2FkKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmNpZXMuaW5kZXhPZihleHRlbnNpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24uYWRkRGVwZW5kZW50KHRoaXMsIG5vTG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2goZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHRlbnNpb24uaXNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGV4dGVuc2lvbi5wcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY2llc18xXzEgJiYgIWRlcGVuZGVuY2llc18xXzEuZG9uZSAmJiAoX2EgPSBkZXBlbmRlbmNpZXNfMS5yZXR1cm4pKSBfYS5jYWxsKGRlcGVuZGVuY2llc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5tYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgY29uZmlnID0gKGxvYWRlcl9qc18xLkNPTkZJR1t0aGlzLm5hbWVdIHx8IHt9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZWFkeSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoX25hbWUpIHsgcmV0dXJuIGNvbmZpZy5yZWFkeShfdGhpcy5uYW1lKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAobmFtZXMpIHsgcmV0dXJuIG5hbWVzLmpvaW4oJywgJyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuZmFpbGVkKSB7XG4gICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBjb25maWcuZmFpbGVkKG5ldyBQYWNrYWdlRXJyb3IobWVzc2FnZSwgX3RoaXMubmFtZSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIFBhY2thZ2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0xvYWRlZCAmJiAhdGhpcy5pc0xvYWRpbmcgJiYgIXRoaXMubm9Mb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdXJsID0gUGFja2FnZS5yZXNvbHZlUGF0aCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvYWRlcl9qc18xLkNPTkZJRy5yZXF1aXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQ3VzdG9tKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRTY3JpcHQodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUubG9hZEN1c3RvbSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBsb2FkZXJfanNfMS5DT05GSUcucmVxdWlyZSh1cmwpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jaGVja0xvYWQoKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIF90aGlzLmZhaWxlZCgnQ2FuXFwndCBsb2FkIFwiJyArIHVybCArICdcIlxcbicgKyBlcnIubWVzc2FnZS50cmltKCkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5sb2FkU2NyaXB0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uIChfZXZlbnQpIHsgcmV0dXJuIF90aGlzLmNoZWNrTG9hZCgpOyB9O1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChfZXZlbnQpIHsgcmV0dXJuIF90aGlzLmZhaWxlZCgnQ2FuXFwndCBsb2FkIFwiJyArIHVybCArICdcIicpOyB9O1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzMsIF9hLCBlXzQsIF9iO1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5kZXBlbmRlbnRzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbnQgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbnQucmVxdWlyZW1lbnRTYXRpc2ZpZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKHRoaXMucHJvdmlkZWQpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVkID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWQubG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmUodGhpcy5uYW1lKTtcbiAgICB9O1xuICAgIFBhY2thZ2UucHJvdG90eXBlLmZhaWxlZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaGFzRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWplY3QobmV3IFBhY2thZ2VFcnJvcihtZXNzYWdlLCB0aGlzLm5hbWUpKTtcbiAgICB9O1xuICAgIFBhY2thZ2UucHJvdG90eXBlLmNoZWNrTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpZyA9IChsb2FkZXJfanNfMS5DT05GSUdbdGhpcy5uYW1lXSB8fCB7fSk7XG4gICAgICAgIHZhciBjaGVja1JlYWR5ID0gY29uZmlnLmNoZWNrUmVhZHkgfHwgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9KTtcbiAgICAgICAgY2hlY2tSZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubG9hZGVkKCk7IH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLmZhaWxlZChtZXNzYWdlKTsgfSk7XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5yZXF1aXJlbWVudFNhdGlzZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuTG9hZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5wcm92aWRlcyA9IGZ1bmN0aW9uIChuYW1lcykge1xuICAgICAgICB2YXIgZV81LCBfYTtcbiAgICAgICAgaWYgKG5hbWVzID09PSB2b2lkIDApIHsgbmFtZXMgPSBbXTsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXNfMSA9IF9fdmFsdWVzKG5hbWVzKSwgbmFtZXNfMV8xID0gbmFtZXNfMS5uZXh0KCk7ICFuYW1lc18xXzEuZG9uZTsgbmFtZXNfMV8xID0gbmFtZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gbmFtZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlZCA9IFBhY2thZ2UucGFja2FnZXMuZ2V0KG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlcl9qc18xLkNPTkZJRy5kZXBlbmRlbmNpZXNbbmFtZV8xXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyX2pzXzEuQ09ORklHLmRlcGVuZGVuY2llc1tuYW1lXzFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyX2pzXzEuQ09ORklHLmRlcGVuZGVuY2llc1tuYW1lXzFdLnB1c2gobmFtZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgPSBuZXcgUGFja2FnZShuYW1lXzEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZC5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVkLnB1c2gocHJvdmlkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNfMV8xICYmICFuYW1lc18xXzEuZG9uZSAmJiAoX2EgPSBuYW1lc18xLnJldHVybikpIF9hLmNhbGwobmFtZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhY2thZ2UucHJvdG90eXBlLmFkZERlcGVuZGVudCA9IGZ1bmN0aW9uIChleHRlbnNpb24sIG5vTG9hZCkge1xuICAgICAgICB0aGlzLmRlcGVuZGVudHMucHVzaChleHRlbnNpb24pO1xuICAgICAgICBpZiAoIW5vTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja05vTG9hZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5jaGVja05vTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfNiwgX2E7XG4gICAgICAgIGlmICh0aGlzLm5vTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5ub0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmRlcGVuZGVuY2llcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5jaGVja05vTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFja2FnZS5wYWNrYWdlcyA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gUGFja2FnZTtcbn0oKSk7XG5leHBvcnRzLlBhY2thZ2UgPSBQYWNrYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFja2FnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVxdWlyZUNvbmZpZ3VyYXRpb24gPSBleHBvcnRzLm9wdGlvbnMgPSBleHBvcnRzLlJlcXVpcmVNZXRob2RzID0gZXhwb3J0cy5SZXF1aXJlTG9hZCA9IHZvaWQgMDtcbnZhciBDb25maWd1cmF0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vQ29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBTeW1ib2xNYXBfanNfMSA9IHJlcXVpcmUoXCIuLi9TeW1ib2xNYXAuanNcIik7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vVGV4RXJyb3IuanNcIikpO1xudmFyIGdsb2JhbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbXBvbmVudHMvZ2xvYmFsLmpzXCIpO1xudmFyIHBhY2thZ2VfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21wb25lbnRzL3BhY2thZ2UuanNcIik7XG52YXIgbG9hZGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tcG9uZW50cy9sb2FkZXIuanNcIik7XG52YXIgbWF0aGpheF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL21hdGhqYXguanNcIik7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBNSkNPTkZJRyA9IGdsb2JhbF9qc18xLk1hdGhKYXguY29uZmlnO1xuZnVuY3Rpb24gUmVnaXN0ZXJFeHRlbnNpb24oamF4LCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciByZXF1aXJlID0gamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLnJlcXVpcmU7XG4gICAgdmFyIHJlcXVpcmVkID0gamF4LnBhcnNlT3B0aW9ucy5wYWNrYWdlRGF0YS5nZXQoJ3JlcXVpcmUnKS5yZXF1aXJlZDtcbiAgICB2YXIgZXh0ZW5zaW9uID0gbmFtZS5zdWJzdHIocmVxdWlyZS5wcmVmaXgubGVuZ3RoKTtcbiAgICBpZiAocmVxdWlyZWQuaW5kZXhPZihleHRlbnNpb24pIDwgMCkge1xuICAgICAgICByZXF1aXJlZC5wdXNoKGV4dGVuc2lvbik7XG4gICAgICAgIFJlZ2lzdGVyRGVwZW5kZW5jaWVzKGpheCwgbG9hZGVyX2pzXzEuQ09ORklHLmRlcGVuZGVuY2llc1tuYW1lXSk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb25IYW5kbGVyLmdldChleHRlbnNpb24pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnNfMSA9IE1KQ09ORklHW25hbWVdIHx8IHt9O1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIub3B0aW9ucyAmJiBPYmplY3Qua2V5cyhoYW5kbGVyLm9wdGlvbnMpLmxlbmd0aCA9PT0gMSAmJiBoYW5kbGVyLm9wdGlvbnNbZXh0ZW5zaW9uXSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNfMSA9IChfYSA9IHt9LCBfYVtleHRlbnNpb25dID0gb3B0aW9uc18xLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqYXguY29uZmlndXJhdGlvbi5hZGQoZXh0ZW5zaW9uLCBqYXgsIG9wdGlvbnNfMSk7XG4gICAgICAgICAgICB2YXIgY29uZmlndXJlZCA9IGpheC5wYXJzZU9wdGlvbnMucGFja2FnZURhdGEuZ2V0KCdyZXF1aXJlJykuY29uZmlndXJlZDtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLnByZXByb2Nlc3NvcnMubGVuZ3RoICYmICFjb25maWd1cmVkLmhhcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJlZC5zZXQoZXh0ZW5zaW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtYXRoamF4X2pzXzEubWF0aGpheC5yZXRyeUFmdGVyKFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIFJlZ2lzdGVyRGVwZW5kZW5jaWVzKGpheCwgbmFtZXMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICBpZiAobmFtZXMgPT09IHZvaWQgMCkgeyBuYW1lcyA9IFtdOyB9XG4gICAgdmFyIHByZWZpeCA9IGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy5yZXF1aXJlLnByZWZpeDtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBuYW1lc18xID0gX192YWx1ZXMobmFtZXMpLCBuYW1lc18xXzEgPSBuYW1lc18xLm5leHQoKTsgIW5hbWVzXzFfMS5kb25lOyBuYW1lc18xXzEgPSBuYW1lc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lXzEuc3Vic3RyKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBSZWdpc3RlckV4dGVuc2lvbihqYXgsIG5hbWVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChuYW1lc18xXzEgJiYgIW5hbWVzXzFfMS5kb25lICYmIChfYSA9IG5hbWVzXzEucmV0dXJuKSkgX2EuY2FsbChuYW1lc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxufVxuZnVuY3Rpb24gUmVxdWlyZUxvYWQocGFyc2VyLCBuYW1lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIub3B0aW9ucy5yZXF1aXJlO1xuICAgIHZhciBhbGxvdyA9IG9wdGlvbnMuYWxsb3c7XG4gICAgdmFyIGV4dGVuc2lvbiA9IChuYW1lLnN1YnN0cigwLCAxKSA9PT0gJ1snID8gJycgOiBvcHRpb25zLnByZWZpeCkgKyBuYW1lO1xuICAgIHZhciBhbGxvd2VkID0gKGFsbG93Lmhhc093blByb3BlcnR5KGV4dGVuc2lvbikgPyBhbGxvd1tleHRlbnNpb25dIDpcbiAgICAgICAgYWxsb3cuaGFzT3duUHJvcGVydHkobmFtZSkgPyBhbGxvd1tuYW1lXSA6IG9wdGlvbnMuZGVmYXVsdEFsbG93KTtcbiAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnQmFkUmVxdWlyZScsICdFeHRlbnNpb24gXCIlMVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGxvYWRlZCcsIGV4dGVuc2lvbik7XG4gICAgfVxuICAgIGlmIChwYWNrYWdlX2pzXzEuUGFja2FnZS5wYWNrYWdlcy5oYXMoZXh0ZW5zaW9uKSkge1xuICAgICAgICBSZWdpc3RlckV4dGVuc2lvbihwYXJzZXIuY29uZmlndXJhdGlvbi5wYWNrYWdlRGF0YS5nZXQoJ3JlcXVpcmUnKS5qYXgsIGV4dGVuc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXRoamF4X2pzXzEubWF0aGpheC5yZXRyeUFmdGVyKGxvYWRlcl9qc18xLkxvYWRlci5sb2FkKGV4dGVuc2lvbikpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWlyZUxvYWQgPSBSZXF1aXJlTG9hZDtcbmZ1bmN0aW9uIGNvbmZpZyhfY29uZmlnLCBqYXgpIHtcbiAgICBqYXgucGFyc2VPcHRpb25zLnBhY2thZ2VEYXRhLnNldCgncmVxdWlyZScsIHtcbiAgICAgICAgamF4OiBqYXgsXG4gICAgICAgIHJlcXVpcmVkOiBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoamF4Lm9wdGlvbnMucGFja2FnZXMpLCBmYWxzZSksXG4gICAgICAgIGNvbmZpZ3VyZWQ6IG5ldyBNYXAoKVxuICAgIH0pO1xuICAgIHZhciBvcHRpb25zID0gamF4LnBhcnNlT3B0aW9ucy5vcHRpb25zLnJlcXVpcmU7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMucHJlZml4O1xuICAgIGlmIChwcmVmaXgubWF0Y2goL1teX2EtekEtWjAtOV0vKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXJzIHVzZWQgaW4gXFxcXHJlcXVpcmUgcHJlZml4Jyk7XG4gICAgfVxuICAgIGlmICghbG9hZGVyX2pzXzEuQ09ORklHLnBhdGhzW3ByZWZpeF0pIHtcbiAgICAgICAgbG9hZGVyX2pzXzEuQ09ORklHLnBhdGhzW3ByZWZpeF0gPSAnW21hdGhqYXhdL2lucHV0L3RleC9leHRlbnNpb25zJztcbiAgICB9XG4gICAgb3B0aW9ucy5wcmVmaXggPSAnWycgKyBwcmVmaXggKyAnXS8nO1xufVxuZXhwb3J0cy5SZXF1aXJlTWV0aG9kcyA9IHtcbiAgICBSZXF1aXJlOiBmdW5jdGlvbiAocGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHZhciByZXF1aXJlZCA9IHBhcnNlci5HZXRBcmd1bWVudChuYW1lKTtcbiAgICAgICAgaWYgKHJlcXVpcmVkLm1hdGNoKC9bXl9hLXpBLVowLTldLykgfHwgcmVxdWlyZWQgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdCYWRQYWNrYWdlTmFtZScsICdBcmd1bWVudCBmb3IgJTEgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgUmVxdWlyZUxvYWQocGFyc2VyLCByZXF1aXJlZCk7XG4gICAgfVxufTtcbmV4cG9ydHMub3B0aW9ucyA9IHtcbiAgICByZXF1aXJlOiB7XG4gICAgICAgIGFsbG93OiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHtcbiAgICAgICAgICAgIGJhc2U6IGZhbHNlLFxuICAgICAgICAgICAgJ2FsbC1wYWNrYWdlcyc6IGZhbHNlLFxuICAgICAgICAgICAgYXV0b2xvYWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlnbWFjcm9zOiBmYWxzZSxcbiAgICAgICAgICAgIHRhZ2Zvcm1hdDogZmFsc2UsXG4gICAgICAgICAgICBzZXRvcHRpb25zOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgZGVmYXVsdEFsbG93OiB0cnVlLFxuICAgICAgICBwcmVmaXg6ICd0ZXgnXG4gICAgfVxufTtcbm5ldyBTeW1ib2xNYXBfanNfMS5Db21tYW5kTWFwKCdyZXF1aXJlJywgeyByZXF1aXJlOiAnUmVxdWlyZScgfSwgZXhwb3J0cy5SZXF1aXJlTWV0aG9kcyk7XG5leHBvcnRzLlJlcXVpcmVDb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbl9qc18xLkNvbmZpZ3VyYXRpb24uY3JlYXRlKCdyZXF1aXJlJywgeyBoYW5kbGVyOiB7IG1hY3JvOiBbJ3JlcXVpcmUnXSB9LCBjb25maWc6IGNvbmZpZywgb3B0aW9uczogZXhwb3J0cy5vcHRpb25zIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVxdWlyZUNvbmZpZ3VyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9