(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega-embed_build_vega-embed_module_js"],{

/***/ "./node_modules/fast-json-patch/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/fast-json-patch/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonPatchError: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.PatchError),
/* harmony export */   _areEquals: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__._areEquals),
/* harmony export */   applyOperation: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyOperation),
/* harmony export */   applyPatch: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyPatch),
/* harmony export */   applyReducer: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyReducer),
/* harmony export */   compare: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.compare),
/* harmony export */   deepClone: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__._deepClone),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   escapePathComponent: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),
/* harmony export */   generate: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.generate),
/* harmony export */   getValueByPointer: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),
/* harmony export */   observe: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.observe),
/* harmony export */   unescapePathComponent: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),
/* harmony export */   unobserve: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.unobserve),
/* harmony export */   validate: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.validate),
/* harmony export */   validator: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.validator)
/* harmony export */ });
/* harmony import */ var _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module/core.mjs */ "./node_modules/fast-json-patch/module/core.mjs");
/* harmony import */ var _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./module/duplex.mjs */ "./node_modules/fast-json-patch/module/duplex.mjs");
/* harmony import */ var _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./module/helpers.mjs */ "./node_modules/fast-json-patch/module/helpers.mjs");





/**
 * Default export for backwards compat
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Object.assign({}, _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__, _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__, {
    JsonPatchError: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.PatchError,
    deepClone: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__._deepClone,
    escapePathComponent: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,
    unescapePathComponent: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent
}));

/***/ }),

/***/ "./node_modules/fast-json-patch/module/core.mjs":
/*!******************************************************!*\
  !*** ./node_modules/fast-json-patch/module/core.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonPatchError: () => (/* binding */ JsonPatchError),
/* harmony export */   _areEquals: () => (/* binding */ _areEquals),
/* harmony export */   applyOperation: () => (/* binding */ applyOperation),
/* harmony export */   applyPatch: () => (/* binding */ applyPatch),
/* harmony export */   applyReducer: () => (/* binding */ applyReducer),
/* harmony export */   deepClone: () => (/* binding */ deepClone),
/* harmony export */   getValueByPointer: () => (/* binding */ getValueByPointer),
/* harmony export */   validate: () => (/* binding */ validate),
/* harmony export */   validator: () => (/* binding */ validator)
/* harmony export */ });
/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "./node_modules/fast-json-patch/module/helpers.mjs");

var JsonPatchError = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PatchError;
var deepClone = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: _areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = _areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (key && key.indexOf('~') != -1) {
                key = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);
            }
            if (banPrototypeModifications &&
                (key == '__proto__' ||
                    (key == 'prototype' && t > 0 && keys[t - 1] == 'constructor'))) {
                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !(0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
                        throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
            // If we have more keys in the path, but the next value isn't a non-null object,
            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.
            if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
                throw new JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
// based on https://github.com/epoberezkin/fast-deep-equal
// MIT License
// Copyright (c) 2017 Evgeny Poberezkin
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
function _areEquals(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length)
                return false;
            for (i = length; i-- !== 0;)
                if (!_areEquals(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA != arrB)
            return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
            return false;
        for (i = length; i-- !== 0;)
            if (!b.hasOwnProperty(keys[i]))
                return false;
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!_areEquals(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
;


/***/ }),

/***/ "./node_modules/fast-json-patch/module/duplex.mjs":
/*!********************************************************!*\
  !*** ./node_modules/fast-json-patch/module/duplex.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   generate: () => (/* binding */ generate),
/* harmony export */   observe: () => (/* binding */ observe),
/* harmony export */   unobserve: () => (/* binding */ unobserve)
/* harmony export */ });
/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "./node_modules/fast-json-patch/module/helpers.mjs");
/* harmony import */ var _core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.mjs */ "./node_modules/fast-json-patch/module/core.mjs");
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */


var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        (0,_core_mjs__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);
    var oldKeys = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
                _generate(oldVal, newVal, patches, path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!(0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}


/***/ }),

/***/ "./node_modules/fast-json-patch/module/helpers.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/fast-json-patch/module/helpers.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PatchError: () => (/* binding */ PatchError),
/* harmony export */   _deepClone: () => (/* binding */ _deepClone),
/* harmony export */   _getPathRecursive: () => (/* binding */ _getPathRecursive),
/* harmony export */   _objectKeys: () => (/* binding */ _objectKeys),
/* harmony export */   escapePathComponent: () => (/* binding */ escapePathComponent),
/* harmony export */   getPath: () => (/* binding */ getPath),
/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),
/* harmony export */   hasUndefined: () => (/* binding */ hasUndefined),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   unescapePathComponent: () => (/* binding */ unescapePathComponent)
/* harmony export */ });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys_1 = new Array(obj.length);
        for (var k = 0; k < keys_1.length; k++) {
            keys_1[k] = "" + k;
        }
        return keys_1;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return "/" + path;
}
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
                if (hasUndefined(obj[i_1])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));



/***/ }),

/***/ "./node_modules/json-stringify-pretty-compact/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/json-stringify-pretty-compact/index.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


// Note: This regex matches even invalid JSON strings, but since we’re
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we don’t care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

module.exports = function stringify(passedObj, options) {
  var indent, maxLength, replacer;

  options = options || {};
  indent = JSON.stringify(
    [1],
    undefined,
    options.indent === undefined ? 2 : options.indent
  ).slice(2, -3);
  maxLength =
    indent === ""
      ? Infinity
      : options.maxLength === undefined
      ? 80
      : options.maxLength;
  replacer = options.replacer;

  return (function _stringify(obj, currentIndent, reserved) {
    // prettier-ignore
    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

    if (obj && typeof obj.toJSON === "function") {
      obj = obj.toJSON();
    }

    string = JSON.stringify(obj, replacer);

    if (string === undefined) {
      return string;
    }

    length = maxLength - currentIndent.length - reserved;

    if (string.length <= length) {
      prettified = string.replace(
        stringOrChar,
        function (match, stringLiteral) {
          return stringLiteral || match + " ";
        }
      );
      if (prettified.length <= length) {
        return prettified;
      }
    }

    if (replacer != null) {
      obj = JSON.parse(string);
      replacer = undefined;
    }

    if (typeof obj === "object" && obj !== null) {
      nextIndent = currentIndent + indent;
      items = [];
      index = 0;

      if (Array.isArray(obj)) {
        start = "[";
        end = "]";
        length = obj.length;
        for (; index < length; index++) {
          items.push(
            _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) ||
              "null"
          );
        }
      } else {
        start = "{";
        end = "}";
        keys = Object.keys(obj);
        length = keys.length;
        for (; index < length; index++) {
          key = keys[index];
          keyPart = JSON.stringify(key) + ": ";
          value = _stringify(
            obj[key],
            nextIndent,
            keyPart.length + (index === length - 1 ? 0 : 1)
          );
          if (value !== undefined) {
            items.push(keyPart + value);
          }
        }
      }

      if (items.length > 0) {
        return [start, indent + items.join(",\n" + nextIndent), end].join(
          "\n" + currentIndent
        );
      }
    }

    return string;
  })(passedObj, "", 0);
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/vega-embed/build/vega-embed.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-embed/build/vega-embed.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_ACTIONS: () => (/* binding */ DEFAULT_ACTIONS),
/* harmony export */   "default": () => (/* binding */ embed),
/* harmony export */   guessMode: () => (/* binding */ guessMode),
/* harmony export */   vega: () => (/* binding */ vega),
/* harmony export */   vegaLite: () => (/* binding */ _vegaLite),
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var fast_json_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-json-patch */ "./node_modules/fast-json-patch/index.mjs");
/* harmony import */ var json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stringify-pretty-compact */ "./node_modules/json-stringify-pretty-compact/index.js");
/* harmony import */ var json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vega__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega */ "webpack/sharing/consume/default/vega/vega");
/* harmony import */ var vega__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vega__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vega_interpreter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-interpreter */ "./node_modules/vega-interpreter/build/vega-interpreter.module.js");
/* harmony import */ var vega_lite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-lite */ "webpack/sharing/consume/default/vega-lite/vega-lite");
/* harmony import */ var vega_lite__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vega_lite__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var vega_schema_url_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-schema-url-parser */ "./node_modules/vega-schema-url-parser/dist/parser.module.js");
/* harmony import */ var vega_themes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-themes */ "./node_modules/vega-themes/build/vega-themes.module.js");
/* harmony import */ var vega_tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-tooltip */ "./node_modules/vega-tooltip/build/vega-tooltip.module.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");










function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var undefined$1; // More compressible than void 0.
var $Symbol = typeof Symbol === "function" ? Symbol : {};
var iteratorSymbol = $Symbol.iterator || "@@iterator";
var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
function wrap(innerFn, outerFn, self, tryLocsList) {
  // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context = new Context(tryLocsList || []);

  // The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.
  generator._invoke = makeInvokeMethod(innerFn, self, context);
  return generator;
}

// Try/catch helper to minimize deoptimizations. Returns a completion
// record like context.tryEntries[i].completion. This interface could
// have been (and was previously) designed to take a closure to be
// invoked without arguments, but in all the cases we care about we
// already have an existing method we want to call, so there's no need
// to create a new function object. We can even get away with assuming
// the method takes exactly one argument, since that happens to be true
// in every case, so we don't have to touch the arguments object. The
// only additional allocation required is the completion record, which
// has a stable shape and so hopefully should be cheap to allocate.
function tryCatch(fn, obj, arg) {
  try {
    return {
      type: "normal",
      arg: fn.call(obj, arg)
    };
  } catch (err) {
    return {
      type: "throw",
      arg: err
    };
  }
}
var GenStateSuspendedStart = "suspendedStart";
var GenStateSuspendedYield = "suspendedYield";
var GenStateExecuting = "executing";
var GenStateCompleted = "completed";

// Returning this object from the innerFn has the same effect as
// breaking out of the dispatch switch statement.
var ContinueSentinel = {};

// Dummy constructor functions that we use as the .constructor and
// .constructor.prototype properties for functions that return Generator
// objects. For full spec compliance, you may wish to configure your
// minifier not to mangle the names of these two functions.
function Generator() {}
function GeneratorFunction() {}
function GeneratorFunctionPrototype() {}

// This is a polyfill for %IteratorPrototype% for environments that
// don't natively support it.
var IteratorPrototype = {};
IteratorPrototype[iteratorSymbol] = function () {
  return this;
};
var getProto = Object.getPrototypeOf;
var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
  // This environment has a native %IteratorPrototype%; use it instead
  // of the polyfill.
  IteratorPrototype = NativeIteratorPrototype;
}
var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
GeneratorFunctionPrototype.constructor = GeneratorFunction;
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

// Helper for defining the .next, .throw, and .return methods of the
// Iterator interface in terms of a single ._invoke method.
function defineIteratorMethods(prototype) {
  ["next", "throw", "return"].forEach(function (method) {
    prototype[method] = function (arg) {
      return this._invoke(method, arg);
    };
  });
}
function isGeneratorFunction(genFun) {
  var ctor = typeof genFun === "function" && genFun.constructor;
  return ctor ? ctor === GeneratorFunction ||
  // For the native GeneratorFunction constructor, the best we can
  // do is to check its .name property.
  (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
}
function mark(genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = "GeneratorFunction";
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
}

// Within the body of any async function, `await x` is transformed to
// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
// `hasOwn.call(value, "__await")` to determine if the yielded value is
// meant to be awaited.
function awrap(arg) {
  return {
    __await: arg
  };
}
function AsyncIterator(generator, PromiseImpl) {
  function invoke(method, arg, resolve, reject) {
    var record = tryCatch(generator[method], generator, arg);
    if (record.type === "throw") {
      reject(record.arg);
    } else {
      var result = record.arg;
      var value = result.value;
      if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
        return PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        });
      }
      return PromiseImpl.resolve(value).then(function (unwrapped) {
        // When a yielded Promise is resolved, its final value becomes
        // the .value of the Promise<{value,done}> result for the
        // current iteration.
        result.value = unwrapped;
        resolve(result);
      }, function (error) {
        // If a rejected Promise was yielded, throw the rejection back
        // into the async generator function so it can be handled there.
        return invoke("throw", error, resolve, reject);
      });
    }
  }
  var previousPromise;
  function enqueue(method, arg) {
    function callInvokeWithMethodAndArg() {
      return new PromiseImpl(function (resolve, reject) {
        invoke(method, arg, resolve, reject);
      });
    }
    return previousPromise =
    // If enqueue has been called before, then we want to wait until
    // all previous Promises have been resolved before calling invoke,
    // so that results are always delivered in the correct order. If
    // enqueue has not been called before, then it is important to
    // call invoke immediately, without waiting on a callback to fire,
    // so that the async generator function has the opportunity to do
    // any necessary setup in a predictable way. This predictability
    // is why the Promise constructor synchronously invokes its
    // executor callback, and why async functions synchronously
    // execute code before the first await. Since we implement simple
    // async functions in terms of async generators, it is especially
    // important to get this right, even though it requires care.
    previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
    // Avoid propagating failures to Promises returned by later
    // invocations of the iterator.
    callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
  }

  // Define the unified helper method that is used to implement .next,
  // .throw, and .return (see defineIteratorMethods).
  this._invoke = enqueue;
}
defineIteratorMethods(AsyncIterator.prototype);
AsyncIterator.prototype[asyncIteratorSymbol] = function () {
  return this;
};

// Note that simple async functions are implemented on top of
// AsyncIterator objects; they just return a Promise for the value of
// the final result produced by the iterator.
function async(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
  if (PromiseImpl === void 0) PromiseImpl = Promise;
  var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
  return isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
  : iter.next().then(function (result) {
    return result.done ? result.value : iter.next();
  });
}
function makeInvokeMethod(innerFn, self, context) {
  var state = GenStateSuspendedStart;
  return function invoke(method, arg) {
    if (state === GenStateExecuting) {
      throw new Error("Generator is already running");
    }
    if (state === GenStateCompleted) {
      if (method === "throw") {
        throw arg;
      }

      // Be forgiving, per 25.3.3.3.3 of the spec:
      // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
      return doneResult();
    }
    context.method = method;
    context.arg = arg;
    while (true) {
      var delegate = context.delegate;
      if (delegate) {
        var delegateResult = maybeInvokeDelegate(delegate, context);
        if (delegateResult) {
          if (delegateResult === ContinueSentinel) continue;
          return delegateResult;
        }
      }
      if (context.method === "next") {
        // Setting context._sent for legacy support of Babel's
        // function.sent implementation.
        context.sent = context._sent = context.arg;
      } else if (context.method === "throw") {
        if (state === GenStateSuspendedStart) {
          state = GenStateCompleted;
          throw context.arg;
        }
        context.dispatchException(context.arg);
      } else if (context.method === "return") {
        context.abrupt("return", context.arg);
      }
      state = GenStateExecuting;
      var record = tryCatch(innerFn, self, context);
      if (record.type === "normal") {
        // If an exception is thrown from innerFn, we leave state ===
        // GenStateExecuting and loop back for another invocation.
        state = context.done ? GenStateCompleted : GenStateSuspendedYield;
        if (record.arg === ContinueSentinel) {
          continue;
        }
        return {
          value: record.arg,
          done: context.done
        };
      } else if (record.type === "throw") {
        state = GenStateCompleted;
        // Dispatch the exception by looping back around to the
        // context.dispatchException(context.arg) call above.
        context.method = "throw";
        context.arg = record.arg;
      }
    }
  };
}

// Call delegate.iterator[context.method](context.arg) and handle the
// result, either by returning a { value, done } result from the
// delegate iterator, or by modifying context.method and context.arg,
// setting context.delegate to null, and returning the ContinueSentinel.
function maybeInvokeDelegate(delegate, context) {
  var method = delegate.iterator[context.method];
  if (method === undefined$1) {
    // A .throw or .return when the delegate iterator has no .throw
    // method always terminates the yield* loop.
    context.delegate = null;
    if (context.method === "throw") {
      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined$1;
        maybeInvokeDelegate(delegate, context);
        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }
      context.method = "throw";
      context.arg = new TypeError("The iterator does not provide a 'throw' method");
    }
    return ContinueSentinel;
  }
  var record = tryCatch(method, delegate.iterator, context.arg);
  if (record.type === "throw") {
    context.method = "throw";
    context.arg = record.arg;
    context.delegate = null;
    return ContinueSentinel;
  }
  var info = record.arg;
  if (!info) {
    context.method = "throw";
    context.arg = new TypeError("iterator result is not an object");
    context.delegate = null;
    return ContinueSentinel;
  }
  if (info.done) {
    // Assign the result of the finished delegate to the temporary
    // variable specified by delegate.resultName (see delegateYield).
    context[delegate.resultName] = info.value;

    // Resume execution at the desired location (see delegateYield).
    context.next = delegate.nextLoc;

    // If context.method was "throw" but the delegate handled the
    // exception, let the outer generator proceed normally. If
    // context.method was "next", forget context.arg since it has been
    // "consumed" by the delegate iterator. If context.method was
    // "return", allow the original .return call to continue in the
    // outer generator.
    if (context.method !== "return") {
      context.method = "next";
      context.arg = undefined$1;
    }
  } else {
    // Re-yield the result returned by the delegate method.
    return info;
  }

  // The delegate iterator is finished, so forget it and continue with
  // the outer generator.
  context.delegate = null;
  return ContinueSentinel;
}

// Define Generator.prototype.{next,throw,return} in terms of the
// unified ._invoke helper method.
defineIteratorMethods(Gp);
Gp[toStringTagSymbol] = "Generator";

// A Generator should always return itself as the iterator object when the
// @@iterator function is called on it. Some browsers' implementations of the
// iterator prototype chain incorrectly implement this, causing the Generator
// object to not be returned from this call. This ensures that doesn't happen.
// See https://github.com/facebook/regenerator/issues/274 for more details.
Gp[iteratorSymbol] = function () {
  return this;
};
Gp.toString = function () {
  return "[object Generator]";
};
function pushTryEntry(locs) {
  var entry = {
    tryLoc: locs[0]
  };
  if (1 in locs) {
    entry.catchLoc = locs[1];
  }
  if (2 in locs) {
    entry.finallyLoc = locs[2];
    entry.afterLoc = locs[3];
  }
  this.tryEntries.push(entry);
}
function resetTryEntry(entry) {
  var record = entry.completion || {};
  record.type = "normal";
  delete record.arg;
  entry.completion = record;
}
function Context(tryLocsList) {
  // The root entry object (effectively a try statement without a catch
  // or a finally block) gives us a place to store values thrown from
  // locations where there is no enclosing try statement.
  this.tryEntries = [{
    tryLoc: "root"
  }];
  tryLocsList.forEach(pushTryEntry, this);
  this.reset(true);
}
function keys(object) {
  var keys = [];
  for (var key in object) {
    keys.push(key);
  }
  keys.reverse();

  // Rather than returning an object with a next method, we keep
  // things simple and return the next function itself.
  return function next() {
    while (keys.length) {
      var key = keys.pop();
      if (key in object) {
        next.value = key;
        next.done = false;
        return next;
      }
    }

    // To avoid creating an additional object, we just hang the .value
    // and .done properties off the next function object itself. This
    // also ensures that the minifier will not anonymize the function.
    next.done = true;
    return next;
  };
}
function values(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];
    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }
    if (typeof iterable.next === "function") {
      return iterable;
    }
    if (!isNaN(iterable.length)) {
      var i = -1,
        next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }
          next.value = undefined$1;
          next.done = true;
          return next;
        };
      return next.next = next;
    }
  }

  // Return an iterator with no values.
  return {
    next: doneResult
  };
}
function doneResult() {
  return {
    value: undefined$1,
    done: true
  };
}
Context.prototype = {
  constructor: Context,
  reset: function reset(skipTempReset) {
    this.prev = 0;
    this.next = 0;
    // Resetting context._sent for legacy support of Babel's
    // function.sent implementation.
    this.sent = this._sent = undefined$1;
    this.done = false;
    this.delegate = null;
    this.method = "next";
    this.arg = undefined$1;
    this.tryEntries.forEach(resetTryEntry);
    if (!skipTempReset) {
      for (var name in this) {
        // Not sure about the optimal order of these conditions:
        if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
          this[name] = undefined$1;
        }
      }
    }
  },
  stop: function stop() {
    this.done = true;
    var rootEntry = this.tryEntries[0];
    var rootRecord = rootEntry.completion;
    if (rootRecord.type === "throw") {
      throw rootRecord.arg;
    }
    return this.rval;
  },
  dispatchException: function dispatchException(exception) {
    if (this.done) {
      throw exception;
    }
    var context = this;
    function handle(loc, caught) {
      record.type = "throw";
      record.arg = exception;
      context.next = loc;
      if (caught) {
        // If the dispatched exception was caught by a catch block,
        // then let that catch block handle the exception normally.
        context.method = "next";
        context.arg = undefined$1;
      }
      return !!caught;
    }
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      var record = entry.completion;
      if (entry.tryLoc === "root") {
        // Exception thrown outside of any try block that could handle
        // it, so set the completion value of the entire function to
        // throw the exception.
        return handle("end");
      }
      if (entry.tryLoc <= this.prev) {
        var hasCatch = hasOwn.call(entry, "catchLoc");
        var hasFinally = hasOwn.call(entry, "finallyLoc");
        if (hasCatch && hasFinally) {
          if (this.prev < entry.catchLoc) {
            return handle(entry.catchLoc, true);
          } else if (this.prev < entry.finallyLoc) {
            return handle(entry.finallyLoc);
          }
        } else if (hasCatch) {
          if (this.prev < entry.catchLoc) {
            return handle(entry.catchLoc, true);
          }
        } else if (hasFinally) {
          if (this.prev < entry.finallyLoc) {
            return handle(entry.finallyLoc);
          }
        } else {
          throw new Error("try statement without catch or finally");
        }
      }
    }
  },
  abrupt: function abrupt(type, arg) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
        var finallyEntry = entry;
        break;
      }
    }
    if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
      // Ignore the finally entry if control is not jumping to a
      // location outside the try/catch block.
      finallyEntry = null;
    }
    var record = finallyEntry ? finallyEntry.completion : {};
    record.type = type;
    record.arg = arg;
    if (finallyEntry) {
      this.method = "next";
      this.next = finallyEntry.finallyLoc;
      return ContinueSentinel;
    }
    return this.complete(record);
  },
  complete: function complete(record, afterLoc) {
    if (record.type === "throw") {
      throw record.arg;
    }
    if (record.type === "break" || record.type === "continue") {
      this.next = record.arg;
    } else if (record.type === "return") {
      this.rval = this.arg = record.arg;
      this.method = "return";
      this.next = "end";
    } else if (record.type === "normal" && afterLoc) {
      this.next = afterLoc;
    }
    return ContinueSentinel;
  },
  finish: function finish(finallyLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      if (entry.finallyLoc === finallyLoc) {
        this.complete(entry.completion, entry.afterLoc);
        resetTryEntry(entry);
        return ContinueSentinel;
      }
    }
  },
  "catch": function _catch(tryLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      if (entry.tryLoc === tryLoc) {
        var record = entry.completion;
        if (record.type === "throw") {
          var thrown = record.arg;
          resetTryEntry(entry);
        }
        return thrown;
      }
    }

    // The context.catch method must only be called with a location
    // argument that corresponds to a known catch block.
    throw new Error("illegal catch attempt");
  },
  delegateYield: function delegateYield(iterable, resultName, nextLoc) {
    this.delegate = {
      iterator: values(iterable),
      resultName: resultName,
      nextLoc: nextLoc
    };
    if (this.method === "next") {
      // Deliberately forget the last sent value so that we don't
      // accidentally pass it on to the delegate.
      this.arg = undefined$1;
    }
    return ContinueSentinel;
  }
};

// Export a default namespace that plays well with Rollup
var _regeneratorRuntime = {
  wrap,
  isGeneratorFunction,
  AsyncIterator,
  mark,
  awrap,
  async,
  keys,
  values
};

var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  iterator = function iterator(Yallist) {
    Yallist.prototype[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var walker;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;
          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }
            _context.next = 4;
            return walker.value;
          case 4:
            walker = walker.next;
            _context.next = 1;
            break;
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    });
  };
  return iterator;
}

var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self = this;
  if (!(self instanceof Yallist$1)) {
    self = new Yallist$1();
  }
  self.tail = null;
  self.head = null;
  self.length = 0;
  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }
  return self;
}
Yallist$1.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function (from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function (start, deleteCount) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
    walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
  if (inserted.next === null) {
    self.tail = inserted;
  }
  if (inserted.prev === null) {
    self.head = inserted;
  }
  self.length++;
  return inserted;
}
function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);
  if (!self.head) {
    self.head = self.tail;
  }
  self.length++;
}
function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);
  if (!self.tail) {
    self.tail = self.head;
  }
  self.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  // add if support for Symbol.iterator is present
  requireIterator()(Yallist$1);
} catch (er) {}

// A linked list to keep track of recently-used-ness
var Yallist = yallist;
var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');
var naiveLength = () => 1;

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor(options) {
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
    // Kind of weird to have a default max of Infinity, but oh well.
    this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }

  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== 'function') lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].tail; walker !== null;) {
      var prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this[LRU_LIST].head; walker !== null;) {
      var next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map(k => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map(k => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = new Map(); // hash of items by key
    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
    this[LENGTH] = 0; // length of items in the list
  }

  dump() {
    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter(h => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
    var now = maxAge ? Date.now() : 0;
    var len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      var node = this[CACHE].get(key);
      var item = node.value;

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    var hit = new Entry(key, value, len, now, maxAge);

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE]) this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key)) return false;
    var hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    var node = this[LRU_LIST].tail;
    if (!node) return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    // reset the cache
    this.reset();
    var now = Date.now();
    // A previous serialized cache has the most recent items first
    for (var l = arr.length - 1; l >= 0; l--) {
      var hit = arr[l];
      var expiresAt = hit.e || 0;
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v);else {
        var maxAge = expiresAt - now;
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
var get = (self, key, doUse) => {
  var node = self[CACHE].get(key);
  if (node) {
    var hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
var isStale = (self, hit) => {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
var trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
  }
};
var del = (self, node) => {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
var forEachStep = (self, fn, node, thisp) => {
  var hit = node.value;
  if (isStale(self, hit)) {
    del(self, node);
    if (!self[ALLOW_STALE]) hit = undefined;
  }
  if (hit) fn.call(thisp, hit.value, hit.key, self);
};
var lruCache = LRUCache;

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
var opts = ['includePrerelease', 'loose', 'rtl'];
var parseOptions$1 = options => !options ? {} : typeof options !== 'object' ? {
  loose: true
} : opts.filter(k => options[k]).reduce((o, k) => {
  o[k] = true;
  return o;
}, {});
var parseOptions_1 = parseOptions$1;

var reExports = {};
var re$1 = {
  get exports(){ return reExports; },
  set exports(v){ reExports = v; },
};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
var SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};

var debug$1 = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return console.error('SEMVER', ...args);
} : () => {};
var debug_1 = debug$1;

(function (module, exports) {
  var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;
  var debug = debug_1;
  exports = module.exports = {};

  // The actual regexps go on exports.re
  var re = exports.re = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var createToken = (name, value, isGlobal) => {
    var index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
  };

  // The following Regular Expressions can be used for tokenizing,
  // validating, and parsing SemVer version strings.

  // ## Numeric Identifier
  // A single `0`, or a non-zero digit followed by zero or more digits.

  createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');

  // ## Non-numeric Identifier
  // Zero or more digits, followed by a letter or hyphen, and then zero or
  // more letters, digits, or hyphens.

  createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');

  // ## Main Version
  // Three dot-separated numeric identifiers.

  createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
  createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")"));

  // ## Pre-release Version Identifier
  // A numeric identifier, or a non-numeric identifier.

  createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
  createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));

  // ## Pre-release Version
  // Hyphen, followed by one or more dot-separated pre-release version
  // identifiers.

  createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
  createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))"));

  // ## Build Metadata Identifier
  // Any combination of digits, letters, or hyphens.

  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');

  // ## Build Metadata
  // Plus sign, followed by one or more period-separated build metadata
  // identifiers.

  createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))"));

  // ## Full Version String
  // A main version, followed optionally by a pre-release version and
  // build metadata.

  // Note that the only major, minor, patch, and pre-release sections of
  // the version string are capturing groups.  The build metadata is not a
  // capturing group, because it should not ever be used in version
  // comparison.

  createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
  createToken('FULL', "^".concat(src[t.FULLPLAIN], "$"));

  // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
  // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
  // common in the npm registry.
  createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
  createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
  createToken('GTLT', '((?:<|>)?=?)');

  // Something like "2.*" or "1.2.x".
  // Note that "x.x" is a valid xRange identifer, meaning "any version"
  // Only the first item is strictly required.
  createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
  createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
  createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
  createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
  createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
  createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$"));

  // Coercion.
  // Extract anything that could conceivably be a part of a valid semver
  createToken('COERCE', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:$|[^\\d])");
  createToken('COERCERTL', src[t.COERCE], true);

  // Tilde ranges.
  // Meaning is "reasonably at or greater than"
  createToken('LONETILDE', '(?:~>?)');
  createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
  exports.tildeTrimReplace = '$1~';
  createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
  createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$"));

  // Caret ranges.
  // Meaning is "at least and backwards compatible with"
  createToken('LONECARET', '(?:\\^)');
  createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
  exports.caretTrimReplace = '$1^';
  createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
  createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$"));

  // A simple gt/lt/eq thing, or just "" to indicate "any version"
  createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
  createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$"));

  // An expression to strip any whitespace between the gtlt and the thing
  // it modifies, so that `> 1.2.3` ==> `>1.2.3`
  createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
  exports.comparatorTrimReplace = '$1$2$3';

  // Something like `1.2.3 - 1.2.4`
  // Note that these all use the loose form, because they'll be
  // checked against either the strict or loose comparator form
  // later.
  createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
  createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$");

  // Star ranges basically just allow anything at all.
  createToken('STAR', '(<|>)?=?\\s*\\*');
  // >=0.0.0 is like a star
  createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
  createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
})(re$1, reExports);

var numeric = /^[0-9]+$/;
var compareIdentifiers$1 = (a, b) => {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
var rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};

var debug = debug_1;
var MAX_LENGTH = constants.MAX_LENGTH,
  MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
var re = reExports.re,
  t = reExports.t;
var parseOptions = parseOptions_1;
var compareIdentifiers = identifiers.compareIdentifiers;
let SemVer$1 = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError("Invalid Version: ".concat(version));
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than ".concat(MAX_LENGTH, " characters"));
    }
    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: ".concat(version));
    }
    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(id => {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }
  format() {
    this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    if (this.prerelease.length) {
      this.version += "-".concat(this.prerelease.join('.'));
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i = 0;
    do {
      var a = this.prerelease[i];
      var b = other.prerelease[i];
      debug('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i = 0;
    do {
      var a = this.build[i];
      var b = other.build[i];
      debug('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }
        this.inc('pre', identifier);
        break;
      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: ".concat(release));
    }
    this.format();
    this.raw = this.version;
    return this;
  }
};
var semver = SemVer$1;

var SemVer = semver;
var compare$6 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
var compare_1 = compare$6;

var compare$5 = compare_1;
var eq$1 = (a, b, loose) => compare$5(a, b, loose) === 0;
var eq_1 = eq$1;

var compare$4 = compare_1;
var neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;

var compare$3 = compare_1;
var gt$1 = (a, b, loose) => compare$3(a, b, loose) > 0;
var gt_1 = gt$1;

var compare$2 = compare_1;
var gte$1 = (a, b, loose) => compare$2(a, b, loose) >= 0;
var gte_1 = gte$1;

var compare$1 = compare_1;
var lt$1 = (a, b, loose) => compare$1(a, b, loose) < 0;
var lt_1 = lt$1;

var compare = compare_1;
var lte$1 = (a, b, loose) => compare(a, b, loose) <= 0;
var lte_1 = lte$1;

var eq = eq_1;
var neq = neq_1;
var gt = gt_1;
var gte = gte_1;
var lt = lt_1;
var lte = lte_1;
var cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version;
      }
      if (typeof b === 'object') {
        b = b.version;
      }
      return a === b;
    case '!==':
      if (typeof a === 'object') {
        a = a.version;
      }
      if (typeof b === 'object') {
        b = b.version;
      }
      return a !== b;
    case '':
    case '=':
    case '==':
      return eq(a, b, loose);
    case '!=':
      return neq(a, b, loose);
    case '>':
      return gt(a, b, loose);
    case '>=':
      return gte(a, b, loose);
    case '<':
      return lt(a, b, loose);
    case '<=':
      return lte(a, b, loose);
    default:
      throw new TypeError("Invalid operator: ".concat(op));
  }
};
var cmp_1 = cmp;

var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  var ANY = Symbol('SemVer ANY');
  // hoisted class for cyclic dependency
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug('comp', this);
    }
    parse(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: ".concat(comp));
      }
      this.operator = m[1] !== undefined ? m[1] : '';
      if (this.operator === '=') {
        this.operator = '';
      }

      // if it literally is just '>' or '' then allow anything.
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug('Comparator.test', version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }
  comparator = Comparator;
  var parseOptions = parseOptions_1;
  var re = reExports.re,
    t = reExports.t;
  var cmp = cmp_1;
  var debug = debug_1;
  var SemVer = semver;
  var Range = requireRange();
  return comparator;
}

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  // hoisted class for cyclic dependency
  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        // just put it in the set and return
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;

      // First, split based on boolean or ||
      this.raw = range;
      this.set = range.split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length);
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: ".concat(range));
      }

      // if we have any that are not the null set, throw out null sets.
      if (this.set.length > 1) {
        // keep the first one, in case they're all null sets
        var first = this.set[0];
        this.set = this.set.filter(c => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          // if we have any that are *, then the range is just *
          var _iterator = _createForOfIteratorHelper$1(this.set),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var c = _step.value;
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map(comps => {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      range = range.trim();

      // memoize range parsing for performance.
      // this is a very hot path, and fully deterministic.
      var memoOpts = Object.keys(this.options).join(',');
      var memoKey = "parseRange:".concat(memoOpts, ":").concat(range);
      var cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      var loose = this.options.loose;
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug('hyphen replace', range);
      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range);

      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);

      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);

      // normalize spaces
      range = range.split(/\s+/).join(' ');

      // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      var rangeList = range.split(' ').map(comp => parseComparator(comp, this.options)).join(' ').split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options));
      if (loose) {
        // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter(comp => {
          debug('loose invalid filter', comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug('range list', rangeList);

      // if any comparators are the null set, then replace with JUST null set
      // if more than one comparator, remove any * comparators
      // also, don't include the same comparator more than once
      var rangeMap = new Map();
      var comparators = rangeList.map(comp => new Comparator(comp, this.options));
      var _iterator2 = _createForOfIteratorHelper$1(comparators),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var comp = _step2.value;
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (rangeMap.size > 1 && rangeMap.has('')) {
        rangeMap.delete('');
      }
      var result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }
      return this.set.some(thisComparators => {
        return isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => {
            return rangeComparators.every(rangeComparator => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }

    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  var LRU = lruCache;
  var cache = new LRU({
    max: 1000
  });
  var parseOptions = parseOptions_1;
  var Comparator = requireComparator();
  var debug = debug_1;
  var SemVer = semver;
  var re = reExports.re,
    t = reExports.t,
    comparatorTrimReplace = reExports.comparatorTrimReplace,
    tildeTrimReplace = reExports.tildeTrimReplace,
    caretTrimReplace = reExports.caretTrimReplace;
  var isNullSet = c => c.value === '<0.0.0-0';
  var isAny = c => c.value === '';

  // take a set of comparators and determine whether there
  // exists a version which can satisfy it
  var isSatisfiable = (comparators, options) => {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(otherComparator => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };

  // comprised of xranges, tildes, stars, and gtlt's at this point.
  // already replaced the hyphen ranges
  // turn into a set of JUST comparators.
  var parseComparator = (comp, options) => {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  };
  var isX = id => !id || id.toLowerCase() === 'x' || id === '*';

  // ~, ~> --> * (any, kinda silly)
  // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
  // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
  // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
  // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
  // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
  // ~0.0.1 --> >=0.0.1 <0.1.0-0
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map(c => {
    return replaceTilde(c, options);
  }).join(' ');
  var replaceTilde = (comp, options) => {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug('tilde', comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = ">=".concat(M, ".0.0 <").concat(+M + 1, ".0.0-0");
      } else if (isX(p)) {
        // ~1.2 == >=1.2.0 <1.3.0-0
        ret = ">=".concat(M, ".").concat(m, ".0 <").concat(M, ".").concat(+m + 1, ".0-0");
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
      } else {
        // ~1.2.3 == >=1.2.3 <1.3.0-0
        ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(M, ".").concat(+m + 1, ".0-0");
      }
      debug('tilde return', ret);
      return ret;
    });
  };

  // ^ --> * (any, kinda silly)
  // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
  // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
  // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
  // ^1.2.3 --> >=1.2.3 <2.0.0-0
  // ^1.2.0 --> >=1.2.0 <2.0.0-0
  // ^0.0.1 --> >=0.0.1 <0.0.2-0
  // ^0.1.0 --> >=0.1.0 <0.2.0-0
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map(c => {
    return replaceCaret(c, options);
  }).join(' ');
  var replaceCaret = (comp, options) => {
    debug('caret', comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    var z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, (_, M, m, p, pr) => {
      debug('caret', comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = ">=".concat(M, ".0.0").concat(z, " <").concat(+M + 1, ".0.0-0");
      } else if (isX(p)) {
        if (M === '0') {
          ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
        } else {
          ret = ">=".concat(M, ".").concat(m, ".0").concat(z, " <").concat(+M + 1, ".0.0-0");
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);
        if (M === '0') {
          if (m === '0') {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, "-").concat(pr, " <").concat(+M + 1, ".0.0-0");
        }
      } else {
        debug('no pr');
        if (M === '0') {
          if (m === '0') {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(m, ".").concat(+p + 1, "-0");
          } else {
            ret = ">=".concat(M, ".").concat(m, ".").concat(p).concat(z, " <").concat(M, ".").concat(+m + 1, ".0-0");
          }
        } else {
          ret = ">=".concat(M, ".").concat(m, ".").concat(p, " <").concat(+M + 1, ".0.0-0");
        }
      }
      debug('caret return', ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(c => {
      return replaceXRange(c, options);
    }).join(' ');
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      // if we're including prereleases in the match, then we need
      // to fix this to -0, the lowest possible prerelease value
      pr = options.includePrerelease ? '-0' : '';
      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          // nothing is allowed
          ret = '<0.0.0-0';
        } else {
          // nothing is forbidden
          ret = '*';
        }
      } else if (gtlt && anyX) {
        // we know patch is an x, because we have any x at all.
        // replace X with 0
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === '>') {
          // >1 => >=2.0.0
          // >1.2 => >=1.3.0
          gtlt = '>=';
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          // <=0.7.x is actually <0.8.0, since any 0.7.x should
          // pass.  Similarly, <=7.x is actually <8.0.0, etc.
          gtlt = '<';
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === '<') {
          pr = '-0';
        }
        ret = "".concat(gtlt + M, ".").concat(m, ".").concat(p).concat(pr);
      } else if (xm) {
        ret = ">=".concat(M, ".0.0").concat(pr, " <").concat(+M + 1, ".0.0-0");
      } else if (xp) {
        ret = ">=".concat(M, ".").concat(m, ".0").concat(pr, " <").concat(M, ".").concat(+m + 1, ".0-0");
      }
      debug('xRange return', ret);
      return ret;
    });
  };

  // Because * is AND-ed with everything else in the comparator,
  // and '' means "any version", just remove the *s entirely.
  var replaceStars = (comp, options) => {
    debug('replaceStars', comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '');
  };
  var replaceGTE0 = (comp, options) => {
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
  };

  // This function is passed to string.replace(re[t.HYPHENRANGE])
  // M, m, patch, prerelease, build
  // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
  // 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
  // 1.2 - 3.4 => >=1.2.0 <3.5.0-0
  var hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = ">=".concat(fM, ".0.0").concat(incPr ? '-0' : '');
    } else if (isX(fp)) {
      from = ">=".concat(fM, ".").concat(fm, ".0").concat(incPr ? '-0' : '');
    } else if (fpr) {
      from = ">=".concat(from);
    } else {
      from = ">=".concat(from).concat(incPr ? '-0' : '');
    }
    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = "<".concat(+tM + 1, ".0.0-0");
    } else if (isX(tp)) {
      to = "<".concat(tM, ".").concat(+tm + 1, ".0-0");
    } else if (tpr) {
      to = "<=".concat(tM, ".").concat(tm, ".").concat(tp, "-").concat(tpr);
    } else if (incPr) {
      to = "<".concat(tM, ".").concat(tm, ".").concat(+tp + 1, "-0");
    } else {
      to = "<=".concat(to);
    }
    return "".concat(from, " ").concat(to).trim();
  };
  var testSet = (set, version, options) => {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      // Find the set of versions that are allowed to have prereleases
      // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
      // That should allow `1.2.3-pr.2` to pass.
      // However, `1.2.4-alpha.notready` should NOT be allowed,
      // even though it's within the range set by the comparators.
      for (var _i = 0; _i < set.length; _i++) {
        debug(set[_i].semver);
        if (set[_i].semver === Comparator.ANY) {
          continue;
        }
        if (set[_i].semver.prerelease.length > 0) {
          var allowed = set[_i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      // Version has a -pre, but it's not one of the ones we like.
      return false;
    }
    return true;
  };
  return range;
}

var Range = requireRange();
var satisfies = (version, range, options) => {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }
  return range.test(version);
};
var satisfies_1 = satisfies;

/**
 * Open editor url in a new window, and pass a message.
 */
function post (window, url, data) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var editor = window.open(url);
  var wait = 10000;
  var step = 250;
  var _URL = new URL(url),
    origin = _URL.origin;
  // eslint-disable-next-line no-bitwise
  var count = ~~(wait / step);
  function listen(evt) {
    if (evt.source === editor) {
      count = 0;
      window.removeEventListener('message', listen, false);
    }
  }
  window.addEventListener('message', listen, false);

  // send message
  // periodically resend until ack received or timeout
  function send() {
    if (count <= 0) {
      return;
    }
    editor.postMessage(data, origin);
    setTimeout(send, step);
    count -= 1;
  }
  setTimeout(send, step);
}

// generated with build-style.sh
var embedStyle = ".vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: \"\";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n";

// polyfill for IE
if (!String.prototype.startsWith) {
  // eslint-disable-next-line no-extend-native,func-names
  String.prototype.startsWith = function (search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
function mergeDeep(dest) {
  for (var _len = arguments.length, src = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    src[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _src = src; _i < _src.length; _i++) {
    var s = _src[_i];
    deepMerge_(dest, s);
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (var _i2 = 0, _Object$keys = Object.keys(src); _i2 < _Object$keys.length; _i2++) {
    var property = _Object$keys[_i2];
    (0,vega__WEBPACK_IMPORTED_MODULE_2__.writeConfig)(dest, property, src[property], true);
  }
}

var name = "vega-embed";
var version$1 = "6.21.3";
var description = "Publish Vega visualizations as embedded web components.";
var keywords = ["vega", "data", "visualization", "component", "embed"];
var repository = {
  type: "git",
  url: "http://github.com/vega/vega-embed.git"
};
var author = {
  name: "UW Interactive Data Lab",
  url: "http://idl.cs.washington.edu"
};
var contributors = [{
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}];
var bugs = {
  url: "https://github.com/vega/vega-embed/issues"
};
var homepage = "https://github.com/vega/vega-embed#readme";
var license = "BSD-3-Clause";
var main = "build/vega-embed.js";
var module = "build/vega-embed.module.js";
var unpkg = "build/vega-embed.min.js";
var jsdelivr = "build/vega-embed.min.js";
var types = "build/vega-embed.module.d.ts";
var files = ["src", "build", "build-es5", "patches"];
var devDependencies = {
  "@babel/plugin-transform-runtime": "^7.19.6",
  "@release-it/conventional-changelog": "^5.1.1",
  "@rollup/plugin-commonjs": "24.0.1",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.0.1",
  "@rollup/plugin-terser": "^0.4.0",
  "@types/semver": "^7.3.13",
  "browser-sync": "^2.27.11",
  concurrently: "^7.6.0",
  "del-cli": "^5.0.0",
  "jest-canvas-mock": "^2.4.0",
  "jest-environment-jsdom": "^29.4.3",
  "patch-package": "^6.5.1",
  "postinstall-postinstall": "^2.1.0",
  "release-it": "^15.6.0",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-ts": "^3.2.0",
  rollup: "3.15.0",
  sass: "^1.58.1",
  typescript: "^4.9.5",
  "vega-lite-dev-config": "^0.21.0",
  "vega-lite": "^5.2.0",
  vega: "^5.22.1"
};
var peerDependencies = {
  vega: "^5.21.0",
  "vega-lite": "*"
};
var dependencies = {
  "fast-json-patch": "^3.1.1",
  "json-stringify-pretty-compact": "^3.0.0",
  semver: "^7.3.8",
  tslib: "^2.5.0",
  "vega-interpreter": "^1.0.4",
  "vega-schema-url-parser": "^2.2.0",
  "vega-themes": "^2.12.1",
  "vega-tooltip": "^0.30.1"
};
var bundledDependencies = ["yallist"];
var scripts = {
  prebuild: "yarn clean && yarn build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "del-cli build build-es5 src/style.ts",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint && yarn test",
  serve: "browser-sync start --directory -s -f build *.html",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  pretest: "yarn build:style",
  test: "beemo jest --stdio stream",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prepare: "beemo create-config && npx patch-package",
  prettierbase: "beemo prettier '*.{css,scss,html}'",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  release: "release-it"
};
var pkg = {
  name: name,
  version: version$1,
  description: description,
  keywords: keywords,
  repository: repository,
  author: author,
  contributors: contributors,
  bugs: bugs,
  homepage: homepage,
  license: license,
  main: main,
  module: module,
  unpkg: unpkg,
  jsdelivr: jsdelivr,
  types: types,
  files: files,
  devDependencies: devDependencies,
  peerDependencies: peerDependencies,
  dependencies: dependencies,
  bundledDependencies: bundledDependencies,
  scripts: scripts
};

var _w$vl;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var version = pkg.version;
var vega = vega__WEBPACK_IMPORTED_MODULE_2__;
var _vegaLite = vega_lite__WEBPACK_IMPORTED_MODULE_4__;
var w = typeof window !== 'undefined' ? window : undefined;
if (_vegaLite === undefined && w !== null && w !== void 0 && (_w$vl = w.vl) !== null && _w$vl !== void 0 && _w$vl.compile) {
  _vegaLite = w.vl;
}
var DEFAULT_ACTIONS = {
  export: {
    svg: true,
    png: true
  },
  source: true,
  compiled: true,
  editor: true
};
var I18N = {
  CLICK_TO_VIEW_ACTIONS: 'Click to view actions',
  COMPILED_ACTION: 'View Compiled Vega',
  EDITOR_ACTION: 'Open in Vega Editor',
  PNG_ACTION: 'Save as PNG',
  SOURCE_ACTION: 'View Source',
  SVG_ACTION: 'Save as SVG'
};
var NAMES = {
  vega: 'Vega',
  'vega-lite': 'Vega-Lite'
};
var VERSION = {
  vega: vega.version,
  'vega-lite': _vegaLite ? _vegaLite.version : 'not available'
};
var PREPROCESSOR = {
  vega: vgSpec => vgSpec,
  'vega-lite': (vlSpec, config) => _vegaLite.compile(vlSpec, {
    config: config
  }).spec
};
var SVG_CIRCLES = "\n<svg viewBox=\"0 0 16 16\" fill=\"currentColor\" stroke=\"none\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <circle r=\"2\" cy=\"8\" cx=\"2\"></circle>\n  <circle r=\"2\" cy=\"8\" cx=\"8\"></circle>\n  <circle r=\"2\" cy=\"8\" cx=\"14\"></circle>\n</svg>";
var CHART_WRAPPER_CLASS = 'chart-wrapper';
function isTooltipHandler(h) {
  return typeof h === 'function';
}
function viewSource(source, sourceHeader, sourceFooter, mode) {
  var header = "<html><head>".concat(sourceHeader, "</head><body><pre><code class=\"json\">");
  var footer = "</code></pre>".concat(sourceFooter, "</body></html>");
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var win = window.open('');
  win.document.write(header + source + footer);
  win.document.title = "".concat(NAMES[mode], " JSON Source");
}

/**
 * Try to guess the type of spec.
 *
 * @param spec Vega or Vega-Lite spec.
 */
function guessMode(spec, providedMode) {
  // Decide mode
  if (spec.$schema) {
    var parsed = (0,vega_schema_url_parser__WEBPACK_IMPORTED_MODULE_5__["default"])(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      var _NAMES$providedMode;
      console.warn("The given visualization spec is written in ".concat(NAMES[parsed.library], ", but mode argument sets ").concat((_NAMES$providedMode = NAMES[providedMode]) !== null && _NAMES$providedMode !== void 0 ? _NAMES$providedMode : providedMode, "."));
    }
    var mode = parsed.library;
    if (!satisfies_1(VERSION[mode], "^".concat(parsed.version.slice(1)))) {
      console.warn("The input spec uses ".concat(NAMES[mode], " ").concat(parsed.version, ", but the current version of ").concat(NAMES[mode], " is v").concat(VERSION[mode], "."));
    }
    return mode;
  }

  // try to guess from the provided spec
  if ('mark' in spec || 'encoding' in spec || 'layer' in spec || 'hconcat' in spec || 'vconcat' in spec || 'facet' in spec || 'repeat' in spec) {
    return 'vega-lite';
  }
  if ('marks' in spec || 'signals' in spec || 'scales' in spec || 'axes' in spec) {
    return 'vega';
  }
  return providedMode !== null && providedMode !== void 0 ? providedMode : 'vega';
}
function isLoader(o) {
  return !!(o && 'load' in o);
}
function createLoader(opts) {
  return isLoader(opts) ? opts : vega.loader(opts);
}
function embedOptionsFromUsermeta(parsedSpec) {
  var _embedOptions, _parsedSpec$usermeta;
  var opts = (_embedOptions = (_parsedSpec$usermeta = parsedSpec.usermeta) === null || _parsedSpec$usermeta === void 0 ? void 0 : _parsedSpec$usermeta.embedOptions) !== null && _embedOptions !== void 0 ? _embedOptions : {};
  if ((0,vega__WEBPACK_IMPORTED_MODULE_2__.isString)(opts.defaultStyle)) {
    // we don't allow styles set via usermeta since it would allow injection of logic (we set the style via innerHTML)
    opts.defaultStyle = false;
  }
  return opts;
}

/**
 * Embed a Vega visualization component in a web page. This function returns a promise.
 *
 * @param el        DOM element in which to place component (DOM node or CSS selector).
 * @param spec      String : A URL string from which to load the Vega specification.
 *                  Object : The Vega/Vega-Lite specification as a parsed JSON object.
 * @param opts       A JavaScript object containing options for embedding.
 */
function embed(_x, _x2) {
  return _embed2.apply(this, arguments);
}
function _embed2() {
  _embed2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(el, spec) {
    var _parsedOpts$config, _usermetaOpts$config;
    var opts,
      parsedSpec,
      loader,
      loadedEmbedOptions,
      usermetaLoader,
      _opts$loader,
      usermetaOpts,
      parsedOpts,
      mergedOpts,
      _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
          if (!(0,vega__WEBPACK_IMPORTED_MODULE_2__.isString)(spec)) {
            _context.next = 10;
            break;
          }
          loader = createLoader(opts.loader);
          _context.t0 = JSON;
          _context.next = 6;
          return loader.load(spec);
        case 6:
          _context.t1 = _context.sent;
          parsedSpec = _context.t0.parse.call(_context.t0, _context.t1);
          _context.next = 11;
          break;
        case 10:
          parsedSpec = spec;
        case 11:
          loadedEmbedOptions = embedOptionsFromUsermeta(parsedSpec);
          usermetaLoader = loadedEmbedOptions.loader; // either create the loader for the first time or create a new loader if the spec has new loader options
          if (!loader || usermetaLoader) {
            loader = createLoader((_opts$loader = opts.loader) !== null && _opts$loader !== void 0 ? _opts$loader : usermetaLoader);
          }
          _context.next = 16;
          return loadOpts(loadedEmbedOptions, loader);
        case 16:
          usermetaOpts = _context.sent;
          _context.next = 19;
          return loadOpts(opts, loader);
        case 19:
          parsedOpts = _context.sent;
          mergedOpts = _objectSpread(_objectSpread({}, mergeDeep(parsedOpts, usermetaOpts)), {}, {
            config: (0,vega__WEBPACK_IMPORTED_MODULE_2__.mergeConfig)((_parsedOpts$config = parsedOpts.config) !== null && _parsedOpts$config !== void 0 ? _parsedOpts$config : {}, (_usermetaOpts$config = usermetaOpts.config) !== null && _usermetaOpts$config !== void 0 ? _usermetaOpts$config : {})
          });
          _context.next = 23;
          return _embed(el, parsedSpec, mergedOpts, loader);
        case 23:
          return _context.abrupt("return", _context.sent);
        case 24:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _embed2.apply(this, arguments);
}
function loadOpts(_x3, _x4) {
  return _loadOpts.apply(this, arguments);
}
function _loadOpts() {
  _loadOpts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(opt, loader) {
    var _opt$config;
    var config, patch;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(0,vega__WEBPACK_IMPORTED_MODULE_2__.isString)(opt.config)) {
            _context2.next = 8;
            break;
          }
          _context2.t1 = JSON;
          _context2.next = 4;
          return loader.load(opt.config);
        case 4:
          _context2.t2 = _context2.sent;
          _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
          _context2.next = 9;
          break;
        case 8:
          _context2.t0 = (_opt$config = opt.config) !== null && _opt$config !== void 0 ? _opt$config : {};
        case 9:
          config = _context2.t0;
          if (!(0,vega__WEBPACK_IMPORTED_MODULE_2__.isString)(opt.patch)) {
            _context2.next = 18;
            break;
          }
          _context2.t4 = JSON;
          _context2.next = 14;
          return loader.load(opt.patch);
        case 14:
          _context2.t5 = _context2.sent;
          _context2.t3 = _context2.t4.parse.call(_context2.t4, _context2.t5);
          _context2.next = 19;
          break;
        case 18:
          _context2.t3 = opt.patch;
        case 19:
          patch = _context2.t3;
          return _context2.abrupt("return", _objectSpread(_objectSpread(_objectSpread({}, opt), patch ? {
            patch
          } : {}), config ? {
            config
          } : {}));
        case 21:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _loadOpts.apply(this, arguments);
}
function getRoot(el) {
  var _document$head;
  var possibleRoot = el.getRootNode ? el.getRootNode() : document;
  return possibleRoot instanceof ShadowRoot ? {
    root: possibleRoot,
    rootContainer: possibleRoot
  } : {
    root: document,
    rootContainer: (_document$head = document.head) !== null && _document$head !== void 0 ? _document$head : document.body
  };
}
function _embed(_x5, _x6) {
  return _embed3.apply(this, arguments);
}
function _embed3() {
  _embed3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(el, spec) {
    var _opts$config, _opts$actions, _opts$renderer, _opts$logLevel, _opts$downloadFileNam, _ref, _expressionInterprete;
    var opts,
      loader,
      config,
      actions,
      i18n,
      renderer,
      logLevel,
      downloadFileName,
      element,
      ID,
      _getRoot,
      root,
      rootContainer,
      style,
      mode,
      vgSpec,
      parsed,
      container,
      chartWrapper,
      patch,
      name,
      expressionFunction,
      ast,
      runtime,
      view,
      handler,
      hover,
      _ref2,
      hoverSet,
      updateSet,
      documentClickHandler,
      wrapper,
      details,
      summary,
      ctrl,
      _iterator,
      _step,
      _loop,
      viewSourceLink,
      compileLink,
      _opts$editorUrl,
      editorUrl,
      editorLink,
      finalize,
      _args5 = arguments;
    return _regeneratorRuntime.wrap(function _callee4$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          finalize = function _finalize() {
            if (documentClickHandler) {
              document.removeEventListener('click', documentClickHandler);
            }
            view.finalize();
          };
          opts = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
          loader = _args5.length > 3 ? _args5[3] : undefined;
          config = opts.theme ? (0,vega__WEBPACK_IMPORTED_MODULE_2__.mergeConfig)(vega_themes__WEBPACK_IMPORTED_MODULE_6__[opts.theme], (_opts$config = opts.config) !== null && _opts$config !== void 0 ? _opts$config : {}) : opts.config;
          actions = (0,vega__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(opts.actions) ? opts.actions : mergeDeep({}, DEFAULT_ACTIONS, (_opts$actions = opts.actions) !== null && _opts$actions !== void 0 ? _opts$actions : {});
          i18n = _objectSpread(_objectSpread({}, I18N), opts.i18n);
          renderer = (_opts$renderer = opts.renderer) !== null && _opts$renderer !== void 0 ? _opts$renderer : 'canvas';
          logLevel = (_opts$logLevel = opts.logLevel) !== null && _opts$logLevel !== void 0 ? _opts$logLevel : vega.Warn;
          downloadFileName = (_opts$downloadFileNam = opts.downloadFileName) !== null && _opts$downloadFileNam !== void 0 ? _opts$downloadFileNam : 'visualization';
          element = typeof el === 'string' ? document.querySelector(el) : el;
          if (element) {
            _context5.next = 12;
            break;
          }
          throw new Error("".concat(el, " does not exist"));
        case 12:
          if (opts.defaultStyle !== false) {
            ID = 'vega-embed-style';
            _getRoot = getRoot(element), root = _getRoot.root, rootContainer = _getRoot.rootContainer;
            if (!root.getElementById(ID)) {
              style = document.createElement('style');
              style.id = ID;
              style.innerHTML = opts.defaultStyle === undefined || opts.defaultStyle === true ? (embedStyle ).toString() : opts.defaultStyle;
              rootContainer.appendChild(style);
            }
          }
          mode = guessMode(spec, opts.mode);
          vgSpec = PREPROCESSOR[mode](spec, config);
          if (mode === 'vega-lite') {
            if (vgSpec.$schema) {
              parsed = (0,vega_schema_url_parser__WEBPACK_IMPORTED_MODULE_5__["default"])(vgSpec.$schema);
              if (!satisfies_1(VERSION.vega, "^".concat(parsed.version.slice(1)))) {
                console.warn("The compiled spec uses Vega ".concat(parsed.version, ", but current version is v").concat(VERSION.vega, "."));
              }
            }
          }
          element.classList.add('vega-embed');
          if (actions) {
            element.classList.add('has-actions');
          }
          element.innerHTML = ''; // clear container
          container = element;
          if (actions) {
            chartWrapper = document.createElement('div');
            chartWrapper.classList.add(CHART_WRAPPER_CLASS);
            element.appendChild(chartWrapper);
            container = chartWrapper;
          }
          patch = opts.patch;
          if (patch) {
            vgSpec = patch instanceof Function ? patch(vgSpec) : (0,fast_json_patch__WEBPACK_IMPORTED_MODULE_0__.applyPatch)(vgSpec, patch, true, false).newDocument;
          }

          // Set locale. Note that this is a global setting.
          if (opts.formatLocale) {
            vega.formatLocale(opts.formatLocale);
          }
          if (opts.timeFormatLocale) {
            vega.timeFormatLocale(opts.timeFormatLocale);
          }

          // Set custom expression functions
          if (opts.expressionFunctions) {
            for (name in opts.expressionFunctions) {
              expressionFunction = opts.expressionFunctions[name];
              if ('fn' in expressionFunction) {
                vega.expressionFunction(name, expressionFunction.fn, expressionFunction['visitor']);
              } else if (expressionFunction instanceof Function) {
                vega.expressionFunction(name, expressionFunction);
              }
            }
          }
          ast = opts.ast; // Do not apply the config to Vega when we have already applied it to Vega-Lite.
          // This call may throw an Error if parsing fails.
          runtime = vega.parse(vgSpec, mode === 'vega-lite' ? {} : config, {
            ast
          });
          view = new (opts.viewClass || vega.View)(runtime, _objectSpread({
            loader,
            logLevel,
            renderer
          }, ast ? {
            expr: (_ref = (_expressionInterprete = vega.expressionInterpreter) !== null && _expressionInterprete !== void 0 ? _expressionInterprete : opts.expr) !== null && _ref !== void 0 ? _ref : vega_interpreter__WEBPACK_IMPORTED_MODULE_3__.expressionInterpreter
          } : {}));
          view.addSignalListener('autosize', (_, autosize) => {
            var type = autosize.type;
            if (type == 'fit-x') {
              container.classList.add('fit-x');
              container.classList.remove('fit-y');
            } else if (type == 'fit-y') {
              container.classList.remove('fit-x');
              container.classList.add('fit-y');
            } else if (type == 'fit') {
              container.classList.add('fit-x', 'fit-y');
            } else {
              container.classList.remove('fit-x', 'fit-y');
            }
          });
          if (opts.tooltip !== false) {
            handler = isTooltipHandler(opts.tooltip) ? opts.tooltip :
            // user provided boolean true or tooltip options
            new vega_tooltip__WEBPACK_IMPORTED_MODULE_7__.Handler(opts.tooltip === true ? {} : opts.tooltip).call;
            view.tooltip(handler);
          }
          hover = opts.hover;
          if (hover === undefined) {
            hover = mode === 'vega';
          }
          if (hover) {
            _ref2 = typeof hover === 'boolean' ? {} : hover, hoverSet = _ref2.hoverSet, updateSet = _ref2.updateSet;
            view.hover(hoverSet, updateSet);
          }
          if (opts) {
            if (opts.width != null) {
              view.width(opts.width);
            }
            if (opts.height != null) {
              view.height(opts.height);
            }
            if (opts.padding != null) {
              view.padding(opts.padding);
            }
          }
          _context5.next = 37;
          return view.initialize(container, opts.bind).runAsync();
        case 37:
          if (!(actions !== false)) {
            _context5.next = 63;
            break;
          }
          wrapper = element;
          if (opts.defaultStyle !== false) {
            details = document.createElement('details');
            details.title = i18n.CLICK_TO_VIEW_ACTIONS;
            element.append(details);
            wrapper = details;
            summary = document.createElement('summary');
            summary.innerHTML = SVG_CIRCLES;
            details.append(summary);
            documentClickHandler = ev => {
              if (!details.contains(ev.target)) {
                details.removeAttribute('open');
              }
            };
            document.addEventListener('click', documentClickHandler);
          }
          ctrl = document.createElement('div');
          wrapper.append(ctrl);
          ctrl.classList.add('vega-actions');

          // add 'Export' action
          if (!(actions === true || actions.export !== false)) {
            _context5.next = 60;
            break;
          }
          _iterator = _createForOfIteratorHelper(['svg', 'png']);
          _context5.prev = 45;
          _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
            var ext, i18nExportAction, exportLink, scaleFactor;
            return _regeneratorRuntime.wrap(function _loop$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  ext = _step.value;
                  if (actions === true || actions.export === true || actions.export[ext]) {
                    i18nExportAction = i18n["".concat(ext.toUpperCase(), "_ACTION")];
                    exportLink = document.createElement('a');
                    scaleFactor = (0,vega__WEBPACK_IMPORTED_MODULE_2__.isObject)(opts.scaleFactor) ? opts.scaleFactor[ext] : opts.scaleFactor;
                    exportLink.text = i18nExportAction;
                    exportLink.href = '#';
                    exportLink.target = '_blank';
                    exportLink.download = "".concat(downloadFileName, ".").concat(ext);
                    // add link on mousedown so that it's correct when the click happens
                    exportLink.addEventListener('mousedown', /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(e) {
                        var url;
                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) switch (_context3.prev = _context3.next) {
                            case 0:
                              e.preventDefault();
                              _context3.next = 3;
                              return view.toImageURL(ext, scaleFactor);
                            case 3:
                              url = _context3.sent;
                              this.href = url;
                            case 5:
                            case "end":
                              return _context3.stop();
                          }
                        }, _callee3, this);
                      }));
                      return function (_x7) {
                        return _ref3.apply(this, arguments);
                      };
                    }());
                    ctrl.append(exportLink);
                  }
                case 2:
                case "end":
                  return _context4.stop();
              }
            }, _loop);
          });
          _iterator.s();
        case 48:
          if ((_step = _iterator.n()).done) {
            _context5.next = 52;
            break;
          }
          return _context5.delegateYield(_loop(), "t0", 50);
        case 50:
          _context5.next = 48;
          break;
        case 52:
          _context5.next = 57;
          break;
        case 54:
          _context5.prev = 54;
          _context5.t1 = _context5["catch"](45);
          _iterator.e(_context5.t1);
        case 57:
          _context5.prev = 57;
          _iterator.f();
          return _context5.finish(57);
        case 60:
          // add 'View Source' action
          if (actions === true || actions.source !== false) {
            viewSourceLink = document.createElement('a');
            viewSourceLink.text = i18n.SOURCE_ACTION;
            viewSourceLink.href = '#';
            viewSourceLink.addEventListener('click', function (e) {
              var _opts$sourceHeader, _opts$sourceFooter;
              viewSource(json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default()(spec), (_opts$sourceHeader = opts.sourceHeader) !== null && _opts$sourceHeader !== void 0 ? _opts$sourceHeader : '', (_opts$sourceFooter = opts.sourceFooter) !== null && _opts$sourceFooter !== void 0 ? _opts$sourceFooter : '', mode);
              e.preventDefault();
            });
            ctrl.append(viewSourceLink);
          }

          // add 'View Compiled' action
          if (mode === 'vega-lite' && (actions === true || actions.compiled !== false)) {
            compileLink = document.createElement('a');
            compileLink.text = i18n.COMPILED_ACTION;
            compileLink.href = '#';
            compileLink.addEventListener('click', function (e) {
              var _opts$sourceHeader2, _opts$sourceFooter2;
              viewSource(json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default()(vgSpec), (_opts$sourceHeader2 = opts.sourceHeader) !== null && _opts$sourceHeader2 !== void 0 ? _opts$sourceHeader2 : '', (_opts$sourceFooter2 = opts.sourceFooter) !== null && _opts$sourceFooter2 !== void 0 ? _opts$sourceFooter2 : '', 'vega');
              e.preventDefault();
            });
            ctrl.append(compileLink);
          }

          // add 'Open in Vega Editor' action
          if (actions === true || actions.editor !== false) {
            editorUrl = (_opts$editorUrl = opts.editorUrl) !== null && _opts$editorUrl !== void 0 ? _opts$editorUrl : 'https://vega.github.io/editor/';
            editorLink = document.createElement('a');
            editorLink.text = i18n.EDITOR_ACTION;
            editorLink.href = '#';
            editorLink.addEventListener('click', function (e) {
              post(window, editorUrl, {
                config: config,
                mode,
                renderer,
                spec: json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default()(spec)
              });
              e.preventDefault();
            });
            ctrl.append(editorLink);
          }
        case 63:
          return _context5.abrupt("return", {
            view,
            spec,
            vgSpec,
            finalize,
            embedOptions: opts
          });
        case 64:
        case "end":
          return _context5.stop();
      }
    }, _callee4, null, [[45, 54, 57, 60]]);
  }));
  return _embed3.apply(this, arguments);
}


//# sourceMappingURL=vega-embed.module.js.map


/***/ }),

/***/ "./node_modules/vega-interpreter/build/vega-interpreter.module.js":
/*!************************************************************************!*\
  !*** ./node_modules/vega-interpreter/build/vega-interpreter.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   expressionInterpreter: () => (/* binding */ expression)
/* harmony export */ });
function adjustSpatial (item, encode, swap) {
  let t;
  if (encode.x2) {
    if (encode.x) {
      if (swap && item.x > item.x2) {
        t = item.x;
        item.x = item.x2;
        item.x2 = t;
      }
      item.width = item.x2 - item.x;
    } else {
      item.x = item.x2 - (item.width || 0);
    }
  }
  if (encode.xc) {
    item.x = item.xc - (item.width || 0) / 2;
  }
  if (encode.y2) {
    if (encode.y) {
      if (swap && item.y > item.y2) {
        t = item.y;
        item.y = item.y2;
        item.y2 = t;
      }
      item.height = item.y2 - item.y;
    } else {
      item.y = item.y2 - (item.height || 0);
    }
  }
  if (encode.yc) {
    item.y = item.yc - (item.height || 0) / 2;
  }
}

var Constants = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
};

var Ops = {
  '*': (a, b) => a * b,
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '/': (a, b) => a / b,
  '%': (a, b) => a % b,
  '>': (a, b) => a > b,
  '<': (a, b) => a < b,
  '<=': (a, b) => a <= b,
  '>=': (a, b) => a >= b,
  '==': (a, b) => a == b,
  '!=': (a, b) => a != b,
  '===': (a, b) => a === b,
  '!==': (a, b) => a !== b,
  '&': (a, b) => a & b,
  '|': (a, b) => a | b,
  '^': (a, b) => a ^ b,
  '<<': (a, b) => a << b,
  '>>': (a, b) => a >> b,
  '>>>': (a, b) => a >>> b
};

var Unary = {
  '+': a => +a,
  '-': a => -a,
  '~': a => ~a,
  '!': a => !a
};

const slice = Array.prototype.slice;
const apply = (m, args, cast) => {
  const obj = cast ? cast(args[0]) : args[0];
  return obj[m].apply(obj, slice.call(args, 1));
};
const datetime = (y, m, d, H, M, S, ms) => new Date(y, m || 0, d != null ? d : 1, H || 0, M || 0, S || 0, ms || 0);
var Functions = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (a, b, c) => Math.max(b, Math.min(c, a)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime: datetime,
  date: d => new Date(d).getDate(),
  day: d => new Date(d).getDay(),
  year: d => new Date(d).getFullYear(),
  month: d => new Date(d).getMonth(),
  hours: d => new Date(d).getHours(),
  minutes: d => new Date(d).getMinutes(),
  seconds: d => new Date(d).getSeconds(),
  milliseconds: d => new Date(d).getMilliseconds(),
  time: d => new Date(d).getTime(),
  timezoneoffset: d => new Date(d).getTimezoneOffset(),
  utcdate: d => new Date(d).getUTCDate(),
  utcday: d => new Date(d).getUTCDay(),
  utcyear: d => new Date(d).getUTCFullYear(),
  utcmonth: d => new Date(d).getUTCMonth(),
  utchours: d => new Date(d).getUTCHours(),
  utcminutes: d => new Date(d).getUTCMinutes(),
  utcseconds: d => new Date(d).getUTCSeconds(),
  utcmilliseconds: d => new Date(d).getUTCMilliseconds(),
  // sequence functions
  length: x => x.length,
  join: function () {
    return apply('join', arguments);
  },
  indexof: function () {
    return apply('indexOf', arguments);
  },
  lastindexof: function () {
    return apply('lastIndexOf', arguments);
  },
  slice: function () {
    return apply('slice', arguments);
  },
  reverse: x => x.slice().reverse(),
  // string functions
  parseFloat: parseFloat,
  parseInt: parseInt,
  upper: x => String(x).toUpperCase(),
  lower: x => String(x).toLowerCase(),
  substring: function () {
    return apply('substring', arguments, String);
  },
  split: function () {
    return apply('split', arguments, String);
  },
  replace: function () {
    return apply('replace', arguments, String);
  },
  trim: x => String(x).trim(),
  // regexp functions
  regexp: RegExp,
  test: (r, t) => RegExp(r).test(t)
};

const EventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'];
const DisallowedMethods = new Set([Function, eval, setTimeout, setInterval]);
if (typeof setImmediate === 'function') DisallowedMethods.add(setImmediate);
const Visitors = {
  Literal: ($, n) => n.value,
  Identifier: ($, n) => {
    const id = n.name;
    return $.memberDepth > 0 ? id : id === 'datum' ? $.datum : id === 'event' ? $.event : id === 'item' ? $.item : Constants[id] || $.params['$' + id];
  },
  MemberExpression: ($, n) => {
    const d = !n.computed,
      o = $(n.object);
    if (d) $.memberDepth += 1;
    const p = $(n.property);
    if (d) $.memberDepth -= 1;
    if (DisallowedMethods.has(o[p])) {
      // eslint-disable-next-line no-console
      console.error(`Prevented interpretation of member "${p}" which could lead to insecure code execution`);
      return;
    }
    return o[p];
  },
  CallExpression: ($, n) => {
    const args = n.arguments;
    let name = n.callee.name;

    // handle special internal functions used by encoders
    // re-route to corresponding standard function
    if (name.startsWith('_')) {
      name = name.slice(1);
    }

    // special case "if" due to conditional evaluation of branches
    return name === 'if' ? $(args[0]) ? $(args[1]) : $(args[2]) : ($.fn[name] || Functions[name]).apply($.fn, args.map($));
  },
  ArrayExpression: ($, n) => n.elements.map($),
  BinaryExpression: ($, n) => Ops[n.operator]($(n.left), $(n.right)),
  UnaryExpression: ($, n) => Unary[n.operator]($(n.argument)),
  ConditionalExpression: ($, n) => $(n.test) ? $(n.consequent) : $(n.alternate),
  LogicalExpression: ($, n) => n.operator === '&&' ? $(n.left) && $(n.right) : $(n.left) || $(n.right),
  ObjectExpression: ($, n) => n.properties.reduce((o, p) => {
    $.memberDepth += 1;
    const k = $(p.key);
    $.memberDepth -= 1;
    if (DisallowedMethods.has($(p.value))) {
      // eslint-disable-next-line no-console
      console.error(`Prevented interpretation of property "${k}" which could lead to insecure code execution`);
    } else {
      o[k] = $(p.value);
    }
    return o;
  }, {})
};
function interpret (ast, fn, params, datum, event, item) {
  const $ = n => Visitors[n.type]($, n);
  $.memberDepth = 0;
  $.fn = Object.create(fn);
  $.params = params;
  $.datum = datum;
  $.event = event;
  $.item = item;

  // route event functions to annotated vega event context
  EventFunctions.forEach(f => $.fn[f] = function () {
    return event.vega[f](...arguments);
  });
  return $(ast);
}

var expression = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(ctx, expr) {
    const ast = expr.ast,
      fn = ctx.functions;
    return _ => interpret(ast, fn, _);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(ctx, expr) {
    const ast = expr.ast,
      fn = ctx.functions;
    return (datum, _) => interpret(ast, fn, _, datum);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(ctx, expr) {
    const ast = expr.ast,
      fn = ctx.functions;
    return event => interpret(ast, fn, undefined, undefined, event);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(ctx, expr) {
    const ast = expr.ast,
      fn = ctx.functions;
    return (_, event) => {
      const datum = event.item && event.item.datum;
      return interpret(ast, fn, _, datum, event);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(ctx, encode) {
    const {
        marktype,
        channels
      } = encode,
      fn = ctx.functions,
      swap = marktype === 'group' || marktype === 'image' || marktype === 'rect';
    return (item, _) => {
      const datum = item.datum;
      let m = 0,
        v;
      for (const name in channels) {
        v = interpret(channels[name].ast, fn, _, datum, undefined, item);
        if (item[name] !== v) {
          item[name] = v;
          m = 1;
        }
      }
      if (marktype !== 'rule') {
        adjustSpatial(item, channels, swap);
      }
      return m;
    };
  }
};




/***/ }),

/***/ "./node_modules/vega-schema-url-parser/dist/parser.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vega-schema-url-parser/dist/parser.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function e(e){const[n,r]=/schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1,3);return{library:n,version:r}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (e);
//# sourceMappingURL=parser.module.js.map


/***/ }),

/***/ "./node_modules/vega-themes/build/vega-themes.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-themes/build/vega-themes.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dark: () => (/* binding */ darkTheme),
/* harmony export */   excel: () => (/* binding */ excelTheme),
/* harmony export */   fivethirtyeight: () => (/* binding */ fiveThirtyEightTheme),
/* harmony export */   ggplot2: () => (/* binding */ ggplot2Theme),
/* harmony export */   googlecharts: () => (/* binding */ googlechartsTheme),
/* harmony export */   latimes: () => (/* binding */ latimesTheme),
/* harmony export */   powerbi: () => (/* binding */ powerbiTheme),
/* harmony export */   quartz: () => (/* binding */ quartzTheme),
/* harmony export */   urbaninstitute: () => (/* binding */ urbanInstituteTheme),
/* harmony export */   version: () => (/* binding */ version),
/* harmony export */   vox: () => (/* binding */ voxTheme)
/* harmony export */ });
var name = "vega-themes";
var version$1 = "2.12.1";
var description = "Themes for stylized Vega and Vega-Lite visualizations.";
var keywords = [
	"vega",
	"vega-lite",
	"themes",
	"style"
];
var license = "BSD-3-Clause";
var author = {
	name: "UW Interactive Data Lab",
	url: "https://idl.cs.washington.edu"
};
var contributors = [
	{
		name: "Emily Gu",
		url: "https://github.com/emilygu"
	},
	{
		name: "Arvind Satyanarayan",
		url: "http://arvindsatya.com"
	},
	{
		name: "Jeffrey Heer",
		url: "https://idl.cs.washington.edu"
	},
	{
		name: "Dominik Moritz",
		url: "https://www.domoritz.de"
	}
];
var main = "build/vega-themes.js";
var module = "build/vega-themes.module.js";
var unpkg = "build/vega-themes.min.js";
var jsdelivr = "build/vega-themes.min.js";
var types = "build/vega-themes.module.d.ts";
var repository = {
	type: "git",
	url: "https://github.com/vega/vega-themes.git"
};
var files = [
	"src",
	"build"
];
var scripts = {
	prebuild: "yarn clean",
	build: "rollup -c",
	clean: "rimraf build && rimraf examples/build",
	"copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
	"copy:build": "rsync -r build/* examples/build",
	"deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
	preversion: "yarn lint",
	serve: "browser-sync start -s -f build examples --serveStatic examples",
	start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
	prepare: "beemo create-config",
	eslintbase: "beemo eslint .",
	format: "yarn eslintbase --fix",
	lint: "yarn eslintbase",
	release: "release-it"
};
var devDependencies = {
	"@release-it/conventional-changelog": "^5.1.1",
	"@rollup/plugin-json": "^6.0.0",
	"@rollup/plugin-node-resolve": "^15.0.1",
	"@rollup/plugin-terser": "^0.4.0",
	"browser-sync": "^2.27.10",
	concurrently: "^7.3.0",
	"gh-pages": "^5.0.0",
	"release-it": "^15.6.0",
	"rollup-plugin-bundle-size": "^1.0.3",
	"rollup-plugin-ts": "^3.0.2",
	rollup: "^3.15.0",
	typescript: "^4.7.4",
	"vega-lite-dev-config": "^0.21.0",
	"vega-lite": "^5.0.0",
	vega: "^5.19.1"
};
var peerDependencies = {
	vega: "*",
	"vega-lite": "*"
};
var dependencies = {
};
var pkg = {
	name: name,
	version: version$1,
	description: description,
	keywords: keywords,
	license: license,
	author: author,
	contributors: contributors,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	repository: repository,
	files: files,
	scripts: scripts,
	devDependencies: devDependencies,
	peerDependencies: peerDependencies,
	dependencies: dependencies
};

const lightColor = '#fff';
const medColor = '#888';
const darkTheme = {
    background: '#333',
    view: {
        stroke: medColor,
    },
    title: {
        color: lightColor,
        subtitleColor: lightColor,
    },
    style: {
        'guide-label': {
            fill: lightColor,
        },
        'guide-title': {
            fill: lightColor,
        },
    },
    axis: {
        domainColor: lightColor,
        gridColor: medColor,
        tickColor: lightColor,
    },
};

const markColor$7 = '#4572a7';
const excelTheme = {
    background: '#fff',
    arc: { fill: markColor$7 },
    area: { fill: markColor$7 },
    line: { stroke: markColor$7, strokeWidth: 2 },
    path: { stroke: markColor$7 },
    rect: { fill: markColor$7 },
    shape: { stroke: markColor$7 },
    symbol: { fill: markColor$7, strokeWidth: 1.5, size: 50 },
    axis: {
        bandPosition: 0.5,
        grid: true,
        gridColor: '#000000',
        gridOpacity: 1,
        gridWidth: 0.5,
        labelPadding: 10,
        tickSize: 5,
        tickWidth: 0.5,
    },
    axisBand: {
        grid: false,
        tickExtra: true,
    },
    legend: {
        labelBaseline: 'middle',
        labelFontSize: 11,
        symbolSize: 50,
        symbolType: 'square',
    },
    range: {
        category: [
            '#4572a7',
            '#aa4643',
            '#8aa453',
            '#71598e',
            '#4598ae',
            '#d98445',
            '#94aace',
            '#d09393',
            '#b9cc98',
            '#a99cbc',
        ],
    },
};

const markColor$6 = '#30a2da';
const axisColor$2 = '#cbcbcb';
const guideLabelColor = '#999';
const guideTitleColor = '#333';
const backgroundColor$2 = '#f0f0f0';
const blackTitle = '#333';
const fiveThirtyEightTheme = {
    arc: { fill: markColor$6 },
    area: { fill: markColor$6 },
    axis: {
        domainColor: axisColor$2,
        grid: true,
        gridColor: axisColor$2,
        gridWidth: 1,
        labelColor: guideLabelColor,
        labelFontSize: 10,
        titleColor: guideTitleColor,
        tickColor: axisColor$2,
        tickSize: 10,
        titleFontSize: 14,
        titlePadding: 10,
        labelPadding: 4,
    },
    axisBand: {
        grid: false,
    },
    background: backgroundColor$2,
    group: {
        fill: backgroundColor$2,
    },
    legend: {
        labelColor: blackTitle,
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: 'square',
        titleColor: blackTitle,
        titleFontSize: 14,
        titlePadding: 10,
    },
    line: {
        stroke: markColor$6,
        strokeWidth: 2,
    },
    path: { stroke: markColor$6, strokeWidth: 0.5 },
    rect: { fill: markColor$6 },
    range: {
        category: [
            '#30a2da',
            '#fc4f30',
            '#e5ae38',
            '#6d904f',
            '#8b8b8b',
            '#b96db8',
            '#ff9e27',
            '#56cc60',
            '#52d2ca',
            '#52689e',
            '#545454',
            '#9fe4f8',
        ],
        diverging: ['#cc0020', '#e77866', '#f6e7e1', '#d6e8ed', '#91bfd9', '#1d78b5'],
        heatmap: ['#d6e8ed', '#cee0e5', '#91bfd9', '#549cc6', '#1d78b5'],
    },
    point: {
        filled: true,
        shape: 'circle',
    },
    shape: { stroke: markColor$6 },
    bar: {
        binSpacing: 2,
        fill: markColor$6,
        stroke: null,
    },
    title: {
        anchor: 'start',
        fontSize: 24,
        fontWeight: 600,
        offset: 20,
    },
};

const markColor$5 = '#000';
const ggplot2Theme = {
    group: {
        fill: '#e5e5e5',
    },
    arc: { fill: markColor$5 },
    area: { fill: markColor$5 },
    line: { stroke: markColor$5 },
    path: { stroke: markColor$5 },
    rect: { fill: markColor$5 },
    shape: { stroke: markColor$5 },
    symbol: { fill: markColor$5, size: 40 },
    axis: {
        domain: false,
        grid: true,
        gridColor: '#FFFFFF',
        gridOpacity: 1,
        labelColor: '#7F7F7F',
        labelPadding: 4,
        tickColor: '#7F7F7F',
        tickSize: 5.67,
        titleFontSize: 16,
        titleFontWeight: 'normal',
    },
    legend: {
        labelBaseline: 'middle',
        labelFontSize: 11,
        symbolSize: 40,
    },
    range: {
        category: [
            '#000000',
            '#7F7F7F',
            '#1A1A1A',
            '#999999',
            '#333333',
            '#B0B0B0',
            '#4D4D4D',
            '#C9C9C9',
            '#666666',
            '#DCDCDC',
        ],
    },
};

const headlineFontSize = 22;
const headlineFontWeight = 'normal';
const labelFont$1 = 'Benton Gothic, sans-serif';
const labelFontSize = 11.5;
const labelFontWeight = 'normal';
const markColor$4 = '#82c6df';
// const markHighlight = '#006d8f';
// const markDemocrat = '#5789b8';
// const markRepublican = '#d94f54';
const titleFont = 'Benton Gothic Bold, sans-serif';
const titleFontWeight = 'normal';
const titleFontSize$1 = 13;
const colorSchemes$1 = {
    'category-6': ['#ec8431', '#829eb1', '#c89d29', '#3580b1', '#adc839', '#ab7fb4'],
    'fire-7': ['#fbf2c7', '#f9e39c', '#f8d36e', '#f4bb6a', '#e68a4f', '#d15a40', '#ab4232'],
    'fireandice-6': ['#e68a4f', '#f4bb6a', '#f9e39c', '#dadfe2', '#a6b7c6', '#849eae'],
    'ice-7': ['#edefee', '#dadfe2', '#c4ccd2', '#a6b7c6', '#849eae', '#607785', '#47525d'],
};
const latimesTheme = {
    background: '#ffffff',
    title: {
        anchor: 'start',
        color: '#000000',
        font: titleFont,
        fontSize: headlineFontSize,
        fontWeight: headlineFontWeight,
    },
    arc: { fill: markColor$4 },
    area: { fill: markColor$4 },
    line: { stroke: markColor$4, strokeWidth: 2 },
    path: { stroke: markColor$4 },
    rect: { fill: markColor$4 },
    shape: { stroke: markColor$4 },
    symbol: { fill: markColor$4, size: 30 },
    axis: {
        labelFont: labelFont$1,
        labelFontSize,
        labelFontWeight,
        titleFont,
        titleFontSize: titleFontSize$1,
        titleFontWeight,
    },
    axisX: {
        labelAngle: 0,
        labelPadding: 4,
        tickSize: 3,
    },
    axisY: {
        labelBaseline: 'middle',
        maxExtent: 45,
        minExtent: 45,
        tickSize: 2,
        titleAlign: 'left',
        titleAngle: 0,
        titleX: -45,
        titleY: -11,
    },
    legend: {
        labelFont: labelFont$1,
        labelFontSize,
        symbolType: 'square',
        titleFont,
        titleFontSize: titleFontSize$1,
        titleFontWeight,
    },
    range: {
        category: colorSchemes$1['category-6'],
        diverging: colorSchemes$1['fireandice-6'],
        heatmap: colorSchemes$1['fire-7'],
        ordinal: colorSchemes$1['fire-7'],
        ramp: colorSchemes$1['fire-7'],
    },
};

const markColor$3 = '#ab5787';
const axisColor$1 = '#979797';
const quartzTheme = {
    background: '#f9f9f9',
    arc: { fill: markColor$3 },
    area: { fill: markColor$3 },
    line: { stroke: markColor$3 },
    path: { stroke: markColor$3 },
    rect: { fill: markColor$3 },
    shape: { stroke: markColor$3 },
    symbol: { fill: markColor$3, size: 30 },
    axis: {
        domainColor: axisColor$1,
        domainWidth: 0.5,
        gridWidth: 0.2,
        labelColor: axisColor$1,
        tickColor: axisColor$1,
        tickWidth: 0.2,
        titleColor: axisColor$1,
    },
    axisBand: {
        grid: false,
    },
    axisX: {
        grid: true,
        tickSize: 10,
    },
    axisY: {
        domain: false,
        grid: true,
        tickSize: 0,
    },
    legend: {
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: 'square',
    },
    range: {
        category: [
            '#ab5787',
            '#51b2e5',
            '#703c5c',
            '#168dd9',
            '#d190b6',
            '#00609f',
            '#d365ba',
            '#154866',
            '#666666',
            '#c4c4c4',
        ],
    },
};

const markColor$2 = '#3e5c69';
const voxTheme = {
    background: '#fff',
    arc: { fill: markColor$2 },
    area: { fill: markColor$2 },
    line: { stroke: markColor$2 },
    path: { stroke: markColor$2 },
    rect: { fill: markColor$2 },
    shape: { stroke: markColor$2 },
    symbol: { fill: markColor$2 },
    axis: {
        domainWidth: 0.5,
        grid: true,
        labelPadding: 2,
        tickSize: 5,
        tickWidth: 0.5,
        titleFontWeight: 'normal',
    },
    axisBand: {
        grid: false,
    },
    axisX: {
        gridWidth: 0.2,
    },
    axisY: {
        gridDash: [3],
        gridWidth: 0.4,
    },
    legend: {
        labelFontSize: 11,
        padding: 1,
        symbolType: 'square',
    },
    range: {
        category: ['#3e5c69', '#6793a6', '#182429', '#0570b0', '#3690c0', '#74a9cf', '#a6bddb', '#e2ddf2'],
    },
};

const markColor$1 = '#1696d2';
const axisColor = '#000000';
const backgroundColor$1 = '#FFFFFF';
const font = 'Lato';
const labelFont = 'Lato';
const sourceFont = 'Lato';
const gridColor$1 = '#DEDDDD';
const titleFontSize = 18;
const colorSchemes = {
    'main-colors': ['#1696d2', '#d2d2d2', '#000000', '#fdbf11', '#ec008b', '#55b748', '#5c5859', '#db2b27'],
    'shades-blue': ['#CFE8F3', '#A2D4EC', '#73BFE2', '#46ABDB', '#1696D2', '#12719E', '#0A4C6A', '#062635'],
    'shades-gray': ['#F5F5F5', '#ECECEC', '#E3E3E3', '#DCDBDB', '#D2D2D2', '#9D9D9D', '#696969', '#353535'],
    'shades-yellow': ['#FFF2CF', '#FCE39E', '#FDD870', '#FCCB41', '#FDBF11', '#E88E2D', '#CA5800', '#843215'],
    'shades-magenta': ['#F5CBDF', '#EB99C2', '#E46AA7', '#E54096', '#EC008B', '#AF1F6B', '#761548', '#351123'],
    'shades-green': ['#DCEDD9', '#BCDEB4', '#98CF90', '#78C26D', '#55B748', '#408941', '#2C5C2D', '#1A2E19'],
    'shades-black': ['#D5D5D4', '#ADABAC', '#848081', '#5C5859', '#332D2F', '#262223', '#1A1717', '#0E0C0D'],
    'shades-red': ['#F8D5D4', '#F1AAA9', '#E9807D', '#E25552', '#DB2B27', '#A4201D', '#6E1614', '#370B0A'],
    'one-group': ['#1696d2', '#000000'],
    'two-groups-cat-1': ['#1696d2', '#000000'],
    'two-groups-cat-2': ['#1696d2', '#fdbf11'],
    'two-groups-cat-3': ['#1696d2', '#db2b27'],
    'two-groups-seq': ['#a2d4ec', '#1696d2'],
    'three-groups-cat': ['#1696d2', '#fdbf11', '#000000'],
    'three-groups-seq': ['#a2d4ec', '#1696d2', '#0a4c6a'],
    'four-groups-cat-1': ['#000000', '#d2d2d2', '#fdbf11', '#1696d2'],
    'four-groups-cat-2': ['#1696d2', '#ec0008b', '#fdbf11', '#5c5859'],
    'four-groups-seq': ['#cfe8f3', '#73bf42', '#1696d2', '#0a4c6a'],
    'five-groups-cat-1': ['#1696d2', '#fdbf11', '#d2d2d2', '#ec008b', '#000000'],
    'five-groups-cat-2': ['#1696d2', '#0a4c6a', '#d2d2d2', '#fdbf11', '#332d2f'],
    'five-groups-seq': ['#cfe8f3', '#73bf42', '#1696d2', '#0a4c6a', '#000000'],
    'six-groups-cat-1': ['#1696d2', '#ec008b', '#fdbf11', '#000000', '#d2d2d2', '#55b748'],
    'six-groups-cat-2': ['#1696d2', '#d2d2d2', '#ec008b', '#fdbf11', '#332d2f', '#0a4c6a'],
    'six-groups-seq': ['#cfe8f3', '#a2d4ec', '#73bfe2', '#46abdb', '#1696d2', '#12719e'],
    'diverging-colors': ['#ca5800', '#fdbf11', '#fdd870', '#fff2cf', '#cfe8f3', '#73bfe2', '#1696d2', '#0a4c6a'],
};
const urbanInstituteTheme = {
    background: backgroundColor$1,
    title: {
        anchor: 'start',
        fontSize: titleFontSize,
        font: font,
    },
    axisX: {
        domain: true,
        domainColor: axisColor,
        domainWidth: 1,
        grid: false,
        labelFontSize: 12,
        labelFont: labelFont,
        labelAngle: 0,
        tickColor: axisColor,
        tickSize: 5,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
    },
    axisY: {
        domain: false,
        domainWidth: 1,
        grid: true,
        gridColor: gridColor$1,
        gridWidth: 1,
        labelFontSize: 12,
        labelFont: labelFont,
        labelPadding: 8,
        ticks: false,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
        titleAngle: 0,
        titleY: -10,
        titleX: 18,
    },
    legend: {
        labelFontSize: 12,
        labelFont: labelFont,
        symbolSize: 100,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
        orient: 'right',
        offset: 10,
    },
    view: {
        stroke: 'transparent',
    },
    range: {
        category: colorSchemes['six-groups-cat-1'],
        diverging: colorSchemes['diverging-colors'],
        heatmap: colorSchemes['diverging-colors'],
        ordinal: colorSchemes['six-groups-seq'],
        ramp: colorSchemes['shades-blue'],
    },
    area: {
        fill: markColor$1,
    },
    rect: {
        fill: markColor$1,
    },
    line: {
        color: markColor$1,
        stroke: markColor$1,
        strokeWidth: 5,
    },
    trail: {
        color: markColor$1,
        stroke: markColor$1,
        strokeWidth: 0,
        size: 1,
    },
    path: {
        stroke: markColor$1,
        strokeWidth: 0.5,
    },
    point: {
        filled: true,
    },
    text: {
        font: sourceFont,
        color: markColor$1,
        fontSize: 11,
        align: 'center',
        fontWeight: 400,
        size: 11,
    },
    style: {
        bar: {
            fill: markColor$1,
            stroke: null,
        },
    },
    arc: { fill: markColor$1 },
    shape: { stroke: markColor$1 },
    symbol: { fill: markColor$1, size: 30 },
};

/**
 * Copyright 2020 Google LLC.
 *
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file or at
 * https://developers.google.com/open-source/licenses/bsd
 */
const markColor = '#3366CC';
const gridColor = '#ccc';
const defaultFont = 'Arial, sans-serif';
const googlechartsTheme = {
    arc: { fill: markColor },
    area: { fill: markColor },
    path: { stroke: markColor },
    rect: { fill: markColor },
    shape: { stroke: markColor },
    symbol: { stroke: markColor },
    circle: { fill: markColor },
    background: '#fff',
    padding: {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10,
    },
    style: {
        'guide-label': {
            font: defaultFont,
            fontSize: 12,
        },
        'guide-title': {
            font: defaultFont,
            fontSize: 12,
        },
        'group-title': {
            font: defaultFont,
            fontSize: 12,
        },
    },
    title: {
        font: defaultFont,
        fontSize: 14,
        fontWeight: 'bold',
        dy: -3,
        anchor: 'start',
    },
    axis: {
        gridColor: gridColor,
        tickColor: gridColor,
        domain: false,
        grid: true,
    },
    range: {
        category: [
            '#4285F4',
            '#DB4437',
            '#F4B400',
            '#0F9D58',
            '#AB47BC',
            '#00ACC1',
            '#FF7043',
            '#9E9D24',
            '#5C6BC0',
            '#F06292',
            '#00796B',
            '#C2185B',
        ],
        heatmap: ['#c6dafc', '#5e97f6', '#2a56c6'],
    },
};

const ptToPx = (value) => value * (1 / 3 + 1);
const fontSmallPx = ptToPx(9);
const legendFontPx = ptToPx(10);
const fontLargePx = ptToPx(12);
const fontStandard = 'Segoe UI';
const fontTitle = 'wf_standard-font, helvetica, arial, sans-serif';
const firstLevelElementColor = '#252423';
const secondLevelElementColor = '#605E5C';
const backgroundColor = 'transparent';
const backgroundSecondaryColor = '#C8C6C4';
const paletteColor1 = '#118DFF';
const paletteColor2 = '#12239E';
const paletteColor3 = '#E66C37';
const paletteColor4 = '#6B007B';
const paletteColor5 = '#E044A7';
const paletteColor6 = '#744EC2';
const paletteColor7 = '#D9B300';
const paletteColor8 = '#D64550';
const divergentColorMax = paletteColor1;
const divergentColorMin = '#DEEFFF';
const divergentPalette = [divergentColorMin, divergentColorMax];
const ordinalPalette = [
    divergentColorMin,
    '#c7e4ff',
    '#b0d9ff',
    '#9aceff',
    '#83c3ff',
    '#6cb9ff',
    '#55aeff',
    '#3fa3ff',
    '#2898ff',
    divergentColorMax,
];
const powerbiTheme = {
    view: { stroke: backgroundColor },
    background: backgroundColor,
    font: fontStandard,
    header: {
        titleFont: fontTitle,
        titleFontSize: fontLargePx,
        titleColor: firstLevelElementColor,
        labelFont: fontStandard,
        labelFontSize: legendFontPx,
        labelColor: secondLevelElementColor,
    },
    axis: {
        ticks: false,
        grid: false,
        domain: false,
        labelColor: secondLevelElementColor,
        labelFontSize: fontSmallPx,
        titleFont: fontTitle,
        titleColor: firstLevelElementColor,
        titleFontSize: fontLargePx,
        titleFontWeight: 'normal',
    },
    axisQuantitative: {
        tickCount: 3,
        grid: true,
        gridColor: backgroundSecondaryColor,
        gridDash: [1, 5],
        labelFlush: false,
    },
    axisBand: { tickExtra: true },
    axisX: { labelPadding: 5 },
    axisY: { labelPadding: 10 },
    bar: { fill: paletteColor1 },
    line: {
        stroke: paletteColor1,
        strokeWidth: 3,
        strokeCap: 'round',
        strokeJoin: 'round',
    },
    text: { font: fontStandard, fontSize: fontSmallPx, fill: secondLevelElementColor },
    arc: { fill: paletteColor1 },
    area: { fill: paletteColor1, line: true, opacity: 0.6 },
    path: { stroke: paletteColor1 },
    rect: { fill: paletteColor1 },
    point: { fill: paletteColor1, filled: true, size: 75 },
    shape: { stroke: paletteColor1 },
    symbol: { fill: paletteColor1, strokeWidth: 1.5, size: 50 },
    legend: {
        titleFont: fontStandard,
        titleFontWeight: 'bold',
        titleColor: secondLevelElementColor,
        labelFont: fontStandard,
        labelFontSize: legendFontPx,
        labelColor: secondLevelElementColor,
        symbolType: 'circle',
        symbolSize: 75,
    },
    range: {
        category: [
            paletteColor1,
            paletteColor2,
            paletteColor3,
            paletteColor4,
            paletteColor5,
            paletteColor6,
            paletteColor7,
            paletteColor8,
        ],
        diverging: divergentPalette,
        heatmap: divergentPalette,
        ordinal: ordinalPalette,
    },
};

const version = pkg.version;




/***/ }),

/***/ "./node_modules/vega-tooltip/build/vega-tooltip.module.js":
/*!****************************************************************!*\
  !*** ./node_modules/vega-tooltip/build/vega-tooltip.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_OPTIONS: () => (/* binding */ DEFAULT_OPTIONS),
/* harmony export */   Handler: () => (/* binding */ Handler),
/* harmony export */   calculatePosition: () => (/* binding */ calculatePosition),
/* harmony export */   createDefaultStyle: () => (/* binding */ createDefaultStyle),
/* harmony export */   "default": () => (/* binding */ index),
/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),
/* harmony export */   formatValue: () => (/* binding */ formatValue),
/* harmony export */   replacer: () => (/* binding */ replacer),
/* harmony export */   stringify: () => (/* binding */ stringify),
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");


var name = "vega-tooltip";
var version$1 = "0.30.1";
var description = "A tooltip plugin for Vega-Lite and Vega visualizations.";
var keywords = [
	"vega-lite",
	"vega",
	"tooltip"
];
var repository = {
	type: "git",
	url: "https://github.com/vega/vega-tooltip.git"
};
var author = {
	name: "UW Interactive Data Lab",
	url: "https://idl.cs.washington.edu"
};
var collaborators = [
	"Dominik Moritz",
	"Sira Horradarn",
	"Zening Qu",
	"Kanit Wongsuphasawat",
	"Yuri Astrakhan",
	"Jeffrey Heer"
];
var license = "BSD-3-Clause";
var bugs = {
	url: "https://github.com/vega/vega-tooltip/issues"
};
var homepage = "https://github.com/vega/vega-tooltip#readme";
var main = "build/vega-tooltip.js";
var module = "build/vega-tooltip.module.js";
var unpkg = "build/vega-tooltip.min.js";
var jsdelivr = "build/vega-tooltip.min.js";
var types = "build/vega-tooltip.module.d.ts";
var files = [
	"src",
	"build",
	"types"
];
var scripts = {
	prebuild: "yarn clean && yarn build:style",
	build: "rollup -c",
	"build:style": "./build-style.sh",
	clean: "rimraf build && rimraf src/style.ts",
	"copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
	"copy:build": "rsync -r build/* examples/build",
	"deploy:gh": "yarn build && yarn copy:build && gh-pages -d examples && yarn clean",
	prepublishOnly: "yarn clean && yarn build",
	preversion: "yarn lint && yarn test",
	serve: "browser-sync start -s -f build examples --serveStatic examples",
	start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
	pretest: "yarn build:style",
	test: "beemo jest",
	"test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
	prepare: "beemo create-config && yarn copy:data",
	prettierbase: "beemo prettier '*.{css,scss,html}'",
	eslintbase: "beemo eslint .",
	format: "yarn eslintbase --fix && yarn prettierbase --write",
	lint: "yarn eslintbase && yarn prettierbase --check",
	release: "release-it"
};
var devDependencies = {
	"@release-it/conventional-changelog": "^5.1.1",
	"@rollup/plugin-json": "^6.0.0",
	"@rollup/plugin-node-resolve": "^15.0.1",
	"release-it": "^15.6.0",
	"browser-sync": "^2.27.11",
	concurrently: "^7.6.0",
	"gh-pages": "^5.0.0",
	"jest-environment-jsdom": "^29.4.2",
	path: "^0.12.7",
	rollup: "^3.15.0",
	"rollup-plugin-bundle-size": "^1.0.3",
	"@rollup/plugin-terser": "^0.4.0",
	"rollup-plugin-ts": "^3.2.0",
	sass: "^1.58.0",
	typescript: "~4.9.5",
	"vega-datasets": "^2.5.4",
	"vega-lite-dev-config": "^0.21.0",
	"vega-typings": "^0.22.3"
};
var dependencies = {
	"vega-util": "^1.17.0"
};
var pkg = {
	name: name,
	version: version$1,
	description: description,
	keywords: keywords,
	repository: repository,
	author: author,
	collaborators: collaborators,
	license: license,
	bugs: bugs,
	homepage: homepage,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	files: files,
	scripts: scripts,
	devDependencies: devDependencies,
	dependencies: dependencies
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Format the value to be shown in the tooltip.
 *
 * @param value The value to show in the tooltip.
 * @param valueToHtml Function to convert a single cell value to an HTML string
 */
function formatValue(value, valueToHtml, maxDepth) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        return `[${value.map((v) => valueToHtml((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(v) ? v : stringify(v, maxDepth))).join(', ')}]`;
    }
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
        let content = '';
        const _a = value, { title, image } = _a, rest = __rest(_a, ["title", "image"]);
        if (title) {
            content += `<h2>${valueToHtml(title)}</h2>`;
        }
        if (image) {
            content += `<img src="${valueToHtml(image)}">`;
        }
        const keys = Object.keys(rest);
        if (keys.length > 0) {
            content += '<table>';
            for (const key of keys) {
                let val = rest[key];
                // ignore undefined properties
                if (val === undefined) {
                    continue;
                }
                if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {
                    val = stringify(val, maxDepth);
                }
                content += `<tr><td class="key">${valueToHtml(key)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
            }
            content += `</table>`;
        }
        return content || '{}'; // show empty object if there are no properties
    }
    return valueToHtml(value);
}
function replacer(maxDepth) {
    const stack = [];
    return function (key, value) {
        if (typeof value !== 'object' || value === null) {
            return value;
        }
        const pos = stack.indexOf(this) + 1;
        stack.length = pos;
        if (stack.length > maxDepth) {
            return '[Object]';
        }
        if (stack.indexOf(value) >= 0) {
            return '[Circular]';
        }
        stack.push(value);
        return value;
    };
}
/**
 * Stringify any JS object to valid JSON
 */
function stringify(obj, maxDepth) {
    return JSON.stringify(obj, replacer(maxDepth));
}

// generated with build-style.sh
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element img {
  max-width: 200px;
  max-height: 200px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;

const EL_ID = 'vg-tooltip-element';
const DEFAULT_OPTIONS = {
    /**
     * X offset.
     */
    offsetX: 10,
    /**
     * Y offset.
     */
    offsetY: 10,
    /**
     * ID of the tooltip element.
     */
    id: EL_ID,
    /**
     * ID of the tooltip CSS style.
     */
    styleId: 'vega-tooltip-style',
    /**
     * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
     *
     * There are two predefined themes: "light" (default) and "dark".
     */
    theme: 'light',
    /**
     * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
     */
    disableDefaultStyle: false,
    /**
     * HTML sanitizer function that removes dangerous HTML to prevent XSS.
     *
     * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
     */
    sanitize: escapeHTML,
    /**
     * The maximum recursion depth when printing objects in the tooltip.
     */
    maxDepth: 2,
    /**
     * A function to customize the rendered HTML of the tooltip.
     * @param value A value string, or object of value strings keyed by field
     * @param sanitize The `sanitize` function from `options.sanitize`
     * @returns {string} The returned string will become the `innerHTML` of the tooltip element
     */
    formatTooltip: formatValue,
};
/**
 * Escape special HTML characters.
 *
 * @param value A value to convert to string and HTML-escape.
 */
function escapeHTML(value) {
    return String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
function createDefaultStyle(id) {
    // Just in case this id comes from a user, ensure these is no security issues
    if (!/^[A-Za-z]+[-:.\w]*$/.test(id)) {
        throw new Error('Invalid HTML ID');
    }
    return defaultStyle.toString().replace(EL_ID, id);
}

/**
 * Position the tooltip
 *
 * @param event The mouse event.
 * @param tooltipBox
 * @param offsetX Horizontal offset.
 * @param offsetY Vertical offset.
 */
function calculatePosition(event, tooltipBox, offsetX, offsetY) {
    let x = event.clientX + offsetX;
    if (x + tooltipBox.width > window.innerWidth) {
        x = +event.clientX - offsetX - tooltipBox.width;
    }
    let y = event.clientY + offsetY;
    if (y + tooltipBox.height > window.innerHeight) {
        y = +event.clientY - offsetY - tooltipBox.height;
    }
    return { x, y };
}

/**
 * The tooltip handler class.
 */
class Handler {
    /**
     * Create the tooltip handler and initialize the element and style.
     *
     * @param options Tooltip Options
     */
    constructor(options) {
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        const elementId = this.options.id;
        this.el = null;
        // bind this to call
        this.call = this.tooltipHandler.bind(this);
        // prepend a default stylesheet for tooltips to the head
        if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
            const style = document.createElement('style');
            style.setAttribute('id', this.options.styleId);
            style.innerHTML = createDefaultStyle(elementId);
            const head = document.head;
            if (head.childNodes.length > 0) {
                head.insertBefore(style, head.childNodes[0]);
            }
            else {
                head.appendChild(style);
            }
        }
    }
    /**
     * The tooltip handler function.
     */
    tooltipHandler(handler, event, item, value) {
        // console.log(handler, event, item, value);
        var _a;
        // append a div element that we use as a tooltip unless it already exists
        this.el = document.getElementById(this.options.id);
        if (!this.el) {
            this.el = document.createElement('div');
            this.el.setAttribute('id', this.options.id);
            this.el.classList.add('vg-tooltip');
            const tooltipContainer = (_a = document.fullscreenElement) !== null && _a !== void 0 ? _a : document.body;
            tooltipContainer.appendChild(this.el);
        }
        // hide tooltip for null, undefined, or empty string values
        if (value == null || value === '') {
            this.el.classList.remove('visible', `${this.options.theme}-theme`);
            return;
        }
        // set the tooltip content
        this.el.innerHTML = this.options.formatTooltip(value, this.options.sanitize, this.options.maxDepth);
        // make the tooltip visible
        this.el.classList.add('visible', `${this.options.theme}-theme`);
        const { x, y } = calculatePosition(event, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
        this.el.style.top = `${y}px`;
        this.el.style.left = `${x}px`;
    }
}

const version = pkg.version;
/**
 * Create a tooltip handler and register it with the provided view.
 *
 * @param view The Vega view.
 * @param opt Tooltip options.
 */
function index (view, opt) {
    const handler = new Handler(opt);
    view.tooltip(handler.call).run();
    return handler;
}


//# sourceMappingURL=vega-tooltip.module.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYS1lbWJlZF9idWlsZF92ZWdhLWVtYmVkX21vZHVsZV9qcy44MDcwYmU2M2NjMDJjYmMzN2NmZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0U7QUFNTjs7O0FBRzlCO0FBQ0E7QUFDQTs7QUFFMEM7QUFDSTtBQU1oQjs7QUFFOUIsaUVBQWUsZ0JBQWdCLEVBQUUsNkNBQUksRUFBRSwrQ0FBTTtBQUM3QyxrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QnFHO0FBQ2hHLHFCQUFxQixvREFBVTtBQUMvQixnQkFBZ0Isb0RBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQVU7QUFDaEM7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGLG1DQUFtQyxrREFBa0Q7QUFDckYsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DLHdEQUFVLGVBQWU7QUFDL0YsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBUztBQUNyQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELGlGQUFpRixXQUFXLDBIQUEwSCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0sMkRBQTJELFVBQVU7QUFDMzhCLG9EQUFvRCxnQkFBZ0Isa0VBQWtFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQ2pULHlDQUF5Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFOEY7QUFDOUY7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5cEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRTtBQUMvRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Uy9DLGNBQWMsc0VBQXNFLE9BQU8scUJBQXFCLGlFQUFlLENBQUMsRUFBQztBQUNqSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVkscUNBQXFDO0FBQ2pELFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksbUJBQW1CO0FBQy9CLGFBQWEscUJBQXFCO0FBQ2xDLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSx1Q0FBdUM7QUFDbkQsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLG1CQUFtQjtBQUM5QixZQUFZLG1CQUFtQjtBQUMvQixZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLG1CQUFtQjtBQUMvQixhQUFhLHFCQUFxQjtBQUNsQyxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSxtQkFBbUI7QUFDL0IsYUFBYSxxQkFBcUI7QUFDbEMsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksbUJBQW1CO0FBQy9CLGFBQWEscUJBQXFCO0FBQ2xDLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixZQUFZLG1CQUFtQjtBQUMvQixZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLG1CQUFtQjtBQUMvQixhQUFhLHFCQUFxQjtBQUNsQyxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1CQUFtQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRCxnQkFBZ0IsT0FBTztBQUN2QiwrQkFBK0IsRUFBRTtBQUNqQyxnQ0FBZ0MsRUFBRTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0o7QUFDcEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL21vZHVsZS9jb3JlLm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL21vZHVsZS9kdXBsZXgubWpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvbW9kdWxlL2hlbHBlcnMubWpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qc29uLXN0cmluZ2lmeS1wcmV0dHktY29tcGFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWVtYmVkL2J1aWxkL3ZlZ2EtZW1iZWQubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWludGVycHJldGVyL2J1aWxkL3ZlZ2EtaW50ZXJwcmV0ZXIubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXNjaGVtYS11cmwtcGFyc2VyL2Rpc3QvcGFyc2VyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS10aGVtZXMvYnVpbGQvdmVnYS10aGVtZXMubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXRvb2x0aXAvYnVpbGQvdmVnYS10b29sdGlwLm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL21vZHVsZS9jb3JlLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL21vZHVsZS9kdXBsZXgubWpzJztcbmV4cG9ydCB7XG4gICAgUGF0Y2hFcnJvciBhcyBKc29uUGF0Y2hFcnJvcixcbiAgICBfZGVlcENsb25lIGFzIGRlZXBDbG9uZSxcbiAgICBlc2NhcGVQYXRoQ29tcG9uZW50LFxuICAgIHVuZXNjYXBlUGF0aENvbXBvbmVudFxufSBmcm9tICcuL21vZHVsZS9oZWxwZXJzLm1qcyc7XG5cblxuLyoqXG4gKiBEZWZhdWx0IGV4cG9ydCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi9tb2R1bGUvY29yZS5tanMnO1xuaW1wb3J0ICogYXMgZHVwbGV4IGZyb20gJy4vbW9kdWxlL2R1cGxleC5tanMnO1xuaW1wb3J0IHtcbiAgICBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLFxuICAgIF9kZWVwQ2xvbmUgYXMgZGVlcENsb25lLFxuICAgIGVzY2FwZVBhdGhDb21wb25lbnQsXG4gICAgdW5lc2NhcGVQYXRoQ29tcG9uZW50XG59IGZyb20gJy4vbW9kdWxlL2hlbHBlcnMubWpzJztcblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmFzc2lnbih7fSwgY29yZSwgZHVwbGV4LCB7XG4gICAgSnNvblBhdGNoRXJyb3IsXG4gICAgZGVlcENsb25lLFxuICAgIGVzY2FwZVBhdGhDb21wb25lbnQsXG4gICAgdW5lc2NhcGVQYXRoQ29tcG9uZW50XG59KTsiLCJpbXBvcnQgeyBQYXRjaEVycm9yLCBfZGVlcENsb25lLCBpc0ludGVnZXIsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgaGFzVW5kZWZpbmVkIH0gZnJvbSAnLi9oZWxwZXJzLm1qcyc7XG5leHBvcnQgdmFyIEpzb25QYXRjaEVycm9yID0gUGF0Y2hFcnJvcjtcbmV4cG9ydCB2YXIgZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xudmFyIG9iak9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICAvKiBpbiBjYXNlIG1vdmUgdGFyZ2V0IG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgdmFsdWUsXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLnBhdGgpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IF9kZWVwQ2xvbmUocmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJyZW1vdmVcIiwgcGF0aDogdGhpcy5mcm9tIH0pLnJlbW92ZWQ7XG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcImFkZFwiLCBwYXRoOiB0aGlzLnBhdGgsIHZhbHVlOiBvcmlnaW5hbFZhbHVlIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIGNvcHk6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHZhbHVlVG9Db3B5ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMuZnJvbSk7XG4gICAgICAgIC8vIGVuZm9yY2UgY29weSBieSB2YWx1ZSBzbyBmdXJ0aGVyIG9wZXJhdGlvbnMgZG9uJ3QgYWZmZWN0IHNvdXJjZSAoc2VlIGlzc3VlICMxNzcpXG4gICAgICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcImFkZFwiLCBwYXRoOiB0aGlzLnBhdGgsIHZhbHVlOiBfZGVlcENsb25lKHZhbHVlVG9Db3B5KSB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogX2FyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9XG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNJbnRlZ2VyKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBhcnJheSBwcm9wc1xuICAgICAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIG1heSBiZSBuZWVkZWQgd2hlbiB1c2luZyAnLScgaW4gYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCBpbmRleDogaSB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZExpc3QgPSBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWRMaXN0WzBdIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGFycltpXTtcbiAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBvYmpPcHMubW92ZSxcbiAgICBjb3B5OiBvYmpPcHMuY29weSxcbiAgICB0ZXN0OiBvYmpPcHMudGVzdCxcbiAgICBfZ2V0OiBvYmpPcHMuX2dldFxufTtcbi8qKlxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxuICogQHBhcmFtIHBvaW50ZXIgYW4gZXNjYXBlZCBKU09OIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHBvaW50ZXIpIHtcbiAgICBpZiAocG9pbnRlciA9PSAnJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcbiAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbik7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgb3BlcmF0aW9uLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShvcGVyYXRpb24pKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMsIGluZGV4KSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uID09PSB2b2lkIDApIHsgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZTsgfVxuICAgIGlmIChtdXRhdGVEb2N1bWVudCA9PT0gdm9pZCAwKSB7IG11dGF0ZURvY3VtZW50ID0gdHJ1ZTsgfVxuICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID09PSB2b2lkIDApIHsgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWU7IH1cbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHsgLy8gaXQncyBhIG1vdmUgb3IgY29weSB0byByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBvcGVyYXRpb24uZnJvbSk7IC8vIGdldCB0aGUgdmFsdWUgYnkganNvbi1wb2ludGVyIGluIGBmcm9tYCBmaWVsZFxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnKSB7IC8vIHJlcG9ydCByZW1vdmVkIGl0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAndGVzdCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnRlc3QgPSBfYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScpIHsgLy8gYSByZW1vdmUgb24gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ19nZXQnKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24udmFsdWUgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLyogYmFkIG9wZXJhdGlvbiAqL1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IF9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gb3BlcmF0aW9uLnBhdGggfHwgXCJcIjtcbiAgICAgICAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIHZhciBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgdmFyIHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHZhbGlkYXRlRnVuY3Rpb24gPSB2b2lkIDA7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRlT3BlcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbiA9IHZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAga2V5ID0ga2V5c1t0XTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYga2V5LmluZGV4T2YoJ34nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHVuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgJiZcbiAgICAgICAgICAgICAgICAoa2V5ID09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gJ3Byb3RvdHlwZScgJiYgdCA+IDAgJiYga2V5c1t0IC0gMV0gPT0gJ2NvbnN0cnVjdG9yJykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSlNPTi1QYXRjaDogbW9kaWZ5aW5nIGBfX3Byb3RvX19gIG9yIGBjb25zdHJ1Y3Rvci9wcm90b3R5cGVgIHByb3AgaXMgYmFubmVkIGZvciBzZWN1cml0eSByZWFzb25zLCBpZiB0aGlzIHdhcyBvbiBwdXJwb3NlLCBwbGVhc2Ugc2V0IGBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zYCBmbGFnIGZhbHNlIGFuZCBwYXNzIGl0IHRvIHRoaXMgZnVuY3Rpb24uIE1vcmUgaW5mbyBpbiBmYXN0LWpzb24tcGF0Y2ggUkVBRE1FJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gb3BlcmF0aW9uLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmICFpc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUaGUgc3BlY2lmaWVkIGluZGV4IE1VU1QgTk9UIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVwiLCBcIk9QRVJBVElPTl9WQUxVRV9PVVRfT0ZfQk9VTkRTXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG9iak9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIGF0IHRoZSBkZXNpcmVkIHBhdGgnLCAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBcHBseSBhIGZ1bGwgSlNPTiBQYXRjaCBhcnJheSBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIHBhdGNoLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgb2JqZWN0IGFuZCBgcGF0Y2hgIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseVBhdGNoKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShwYXRjaCkpYC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gcGF0Y2ggVGhlIHBhdGNoIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBBbiBhcnJheSBvZiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgcGF0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2goZG9jdW1lbnQsIHBhdGNoLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMpIHtcbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cbiAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9PT0gdm9pZCAwKSB7IGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlOyB9XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgfVxuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBhdGNoLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbXV0YXRlRG9jdW1lbnQgYXJndW1lbnQgYmVjYXVzZSBpZiBpdCB3YXMgdHJ1ZSwgd2UgYWxyZWFkeSBkZWVwIGNsb25lZCB0aGUgb2JqZWN0LCB3ZSdsbCBqdXN0IHBhc3MgYHRydWVgXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uLCB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpKTtcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXG4gICAgfVxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbi8qKlxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBkb2N1bWVudC5cbiAqIFN1aXRhYmxlIGFzIGEgcmVkdWNlci5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcbiAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVkdWNlcihkb2N1bWVudCwgb3BlcmF0aW9uLCBpbmRleCkge1xuICAgIHZhciBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7IC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBzaW5nbGUgb3BlcmF0aW9uLiBDYWxsZWQgZnJvbSBganNvbnBhdGNoLnZhbGlkYXRlYC4gVGhyb3dzIGBKc29uUGF0Y2hFcnJvcmAgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb24gLSBvcGVyYXRpb24gb2JqZWN0IChwYXRjaClcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIG9wZXJhdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZG9jdW1lbnRdIC0gb2JqZWN0IHdoZXJlIHRoZSBvcGVyYXRpb24gaXMgc3VwcG9zZWQgdG8gYmUgYXBwbGllZFxuICogQHBhcmFtIHtzdHJpbmd9IFtleGlzdGluZ1BhdGhGcmFnbWVudF0gLSBjb21lcyBhbG9uZyB3aXRoIGBkb2N1bWVudGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRvcihvcGVyYXRpb24sIGluZGV4LCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiAhPT0gJ29iamVjdCcgfHwgb3BlcmF0aW9uID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0JywgJ09QRVJBVElPTl9OT1RfQU5fT0JKRUNUJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgaXMgbm90IGEgc3RyaW5nJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHBhdGhzIHRoYXQgYXJlbid0IGVtcHR5IHN0cmluZyBzaG91bGQgc3RhcnQgd2l0aCBcIi9cIlxuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgJiYgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgZnJvbWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYG1vdmVgIGFuZCBgY29weWAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX0ZST01fUkVRVUlSRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdhZGQnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSAmJiBvcGVyYXRpb24udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfUkVRVUlSRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdhZGQnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSAmJiBoYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudCkge1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGVuID0gb3BlcmF0aW9uLnBhdGguc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1BhdGhMZW4gPSBleGlzdGluZ1BhdGhGcmFnbWVudC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbiArIDEgJiYgcGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSBhbiBgYWRkYCBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aCcsICdPUEVSQVRJT05fUEFUSF9DQU5OT1RfQUREJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gYXQgYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3QnLCAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBvcGVyYXRpb24uZnJvbSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgdmFyIGVycm9yID0gdmFsaWRhdGUoW2V4aXN0aW5nVmFsdWVdLCBkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ09QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fRlJPTV9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxuICogQHBhcmFtIHNlcXVlbmNlXG4gKiBAcGFyYW0gZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShzZXF1ZW5jZSwgZG9jdW1lbnQsIGV4dGVybmFsVmFsaWRhdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKCdQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5JywgJ1NFUVVFTkNFX05PVF9BTl9BUlJBWScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy9jbG9uZSBkb2N1bWVudCBhbmQgc2VxdWVuY2Ugc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHRyeSBhcHBseWluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICBhcHBseVBhdGNoKF9kZWVwQ2xvbmUoZG9jdW1lbnQpLCBfZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5leHBvcnQgZnVuY3Rpb24gX2FyZUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGFyckEgPSBBcnJheS5pc0FycmF5KGEpLCBhcnJCID0gQXJyYXkuaXNBcnJheShiKSwgaSwgbGVuZ3RoLCBrZXk7XG4gICAgICAgIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyQSAhPSBhcnJCKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIV9hcmVFcXVhbHMoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cbjtcbiIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTctMjAyMSBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX2RlZXBDbG9uZSwgX29iamVjdEtleXMsIGVzY2FwZVBhdGhDb21wb25lbnQsIGhhc093blByb3BlcnR5IH0gZnJvbSAnLi9oZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnLi9jb3JlLm1qcyc7XG52YXIgYmVmb3JlRGljdCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTWlycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1pcnJvcihvYmopIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gTWlycm9yO1xufSgpKTtcbnZhciBPYnNlcnZlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE9ic2VydmVySW5mbztcbn0oKSk7XG5mdW5jdGlvbiBnZXRNaXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIGJlZm9yZURpY3QuZ2V0KG9iaik7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtaXJyb3Iub2JzZXJ2ZXJzLmdldChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcikge1xuICAgIG1pcnJvci5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyLmNhbGxiYWNrKTtcbn1cbi8qKlxuICogRGV0YWNoIGFuIG9ic2VydmVyIGZyb20gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbi8qKlxuICogT2JzZXJ2ZXMgY2hhbmdlcyBtYWRlIHRvIGFuIG9iamVjdCwgd2hpY2ggY2FuIHRoZW4gYmUgcmV0cmlldmVkIHVzaW5nIGdlbmVyYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yKG9iaik7XG4gICAgaWYgKCFtaXJyb3IpIHtcbiAgICAgICAgbWlycm9yID0gbmV3IE1pcnJvcihvYmopO1xuICAgICAgICBiZWZvcmVEaWN0LnNldChvYmosIG1pcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb2JzZXJ2ZXJJbmZvID0gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spO1xuICAgICAgICBvYnNlcnZlciA9IG9ic2VydmVySW5mbyAmJiBvYnNlcnZlckluZm8ub2JzZXJ2ZXI7XG4gICAgfVxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIG9ic2VydmVyID0ge307XG4gICAgbWlycm9yLnZhbHVlID0gX2RlZXBDbG9uZShvYmopO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBvYnNlcnZlci5uZXh0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpcnR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYXN0Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gc2V0VGltZW91dChkaXJ0eUNoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vbm90IE5vZGVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xuICAgIG9ic2VydmVyLm9iamVjdCA9IG9iajtcbiAgICBvYnNlcnZlci51bm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1pcnJvci5vYnNlcnZlcnMuc2V0KGNhbGxiYWNrLCBuZXcgT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlciwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChpbnZlcnRpYmxlID09PSB2b2lkIDApIHsgaW52ZXJ0aWJsZSA9IGZhbHNlOyB9XG4gICAgdmFyIG1pcnJvciA9IGJlZm9yZURpY3QuZ2V0KG9ic2VydmVyLm9iamVjdCk7XG4gICAgX2dlbmVyYXRlKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIub2JqZWN0LCBvYnNlcnZlci5wYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICBpZiAob2JzZXJ2ZXIucGF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xuICAgIH1cbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG59XG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgsIGludmVydGlibGUpIHtcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHZhciBuZXdLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICB2YXIgb2xkS2V5cyA9IF9vYmplY3RLZXlzKG1pcnJvcik7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xuICAgIC8vaWYgZXZlciBcIm1vdmVcIiBvcGVyYXRpb24gaXMgaW1wbGVtZW50ZWQgaGVyZSwgbWFrZSBzdXJlIHRoaXMgdGVzdCBydW5zIE9LOiBcInNob3VsZCBub3QgZ2VuZXJhdGUgdGhlIHNhbWUgcGF0Y2ggdHdpY2UgKG1vdmUpXCJcbiAgICBmb3IgKHZhciB0ID0gb2xkS2V5cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2xkS2V5c1t0XTtcbiAgICAgICAgdmFyIG9sZFZhbCA9IG1pcnJvcltrZXldO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJiBvbGRWYWwgIT0gbnVsbCAmJiB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiYgbmV3VmFsICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShvbGRWYWwpID09PSBBcnJheS5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgaW52ZXJ0aWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IF9kZWVwQ2xvbmUob2xkVmFsKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IF9kZWVwQ2xvbmUobmV3VmFsKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBfZGVlcENsb25lKG9sZFZhbCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZW1vdmVcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJhZGRcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogX2RlZXBDbG9uZShvYmpba2V5XSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gdGhlIGRpZmZlcmVuY2VzIGluIHR3byBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKHRyZWUxLCB0cmVlMiwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChpbnZlcnRpYmxlID09PSB2b2lkIDApIHsgaW52ZXJ0aWJsZSA9IGZhbHNlOyB9XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICBfZ2VuZXJhdGUodHJlZTEsIHRyZWUyLCBwYXRjaGVzLCAnJywgaW52ZXJ0aWJsZSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG59XG4iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGFyY291bnRlci1KYWNrL0pTT04tUGF0Y2hcbiAqIChjKSAyMDE3LTIwMjIgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlZFxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfb2JqZWN0S2V5cyhvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHZhciBrZXlzXzEgPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5c18xLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBrZXlzXzFba10gPSBcIlwiICsgaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5c18xO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgaSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbjtcbi8qKlxuKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cbiogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcbiogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXG4gICAgfVxufVxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgY2hhckNvZGU7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4qIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuKiBAcGFyYW0gcGF0aCBUaGUgcmF3IHBvaW50ZXJcbiogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKCd+JykgPT09IC0xKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbi8qKlxuICogVW5lc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHVuZXNjYXBlZCBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgZm9yICh2YXIga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm9vdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nICsgZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoKHJvb3QsIG9iaikge1xuICAgIGlmIChyb290ID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9XG4gICAgdmFyIHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xuICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3Qgbm90IGZvdW5kIGluIHJvb3RcIik7XG4gICAgfVxuICAgIHJldHVybiBcIi9cIiArIHBhdGg7XG59XG4vKipcbiogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1VuZGVmaW5lZChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaV8xIDwgbGVuOyBpXzErKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW2lfMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgb2JqS2V5cyA9IF9vYmplY3RLZXlzKG9iaik7XG4gICAgICAgICAgICB2YXIgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICB2YXIgbWVzc2FnZVBhcnRzID0gW21lc3NhZ2VdO1xuICAgIGZvciAodmFyIGtleSBpbiBhcmdzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKSA6IGFyZ3Nba2V5XTsgLy8gcHJldHR5IHByaW50XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChrZXkgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VQYXJ0cy5qb2luKCdcXG4nKTtcbn1cbnZhciBQYXRjaEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXRjaEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhdGNoRXJyb3IobWVzc2FnZSwgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBvcGVyYXRpb246IG9wZXJhdGlvbiwgdHJlZTogdHJlZSB9KSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIF90aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgX3RoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpOyAvLyByZXN0b3JlIHByb3RvdHlwZSBjaGFpbiwgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODM0MjM1OVxuICAgICAgICBfdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lOiBuYW1lLCBpbmRleDogaW5kZXgsIG9wZXJhdGlvbjogb3BlcmF0aW9uLCB0cmVlOiB0cmVlIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXRjaEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0IHsgUGF0Y2hFcnJvciB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZVxuLy8gd29ya2luZyBvbiB0aGUgb3V0cHV0IG9mIGBKU09OLnN0cmluZ2lmeWAgd2Uga25vdyB0aGF0IG9ubHkgdmFsaWQgc3RyaW5nc1xuLy8gYXJlIHByZXNlbnQgKHVubGVzcyB0aGUgdXNlciBzdXBwbGllZCBhIHdlaXJkIGBvcHRpb25zLmluZGVudGAgYnV0IGluXG4vLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLlxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixdL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KHBhc3NlZE9iaiwgb3B0aW9ucykge1xuICB2YXIgaW5kZW50LCBtYXhMZW5ndGgsIHJlcGxhY2VyO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShcbiAgICBbMV0sXG4gICAgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnMuaW5kZW50ID09PSB1bmRlZmluZWQgPyAyIDogb3B0aW9ucy5pbmRlbnRcbiAgKS5zbGljZSgyLCAtMyk7XG4gIG1heExlbmd0aCA9XG4gICAgaW5kZW50ID09PSBcIlwiXG4gICAgICA/IEluZmluaXR5XG4gICAgICA6IG9wdGlvbnMubWF4TGVuZ3RoID09PSB1bmRlZmluZWRcbiAgICAgID8gODBcbiAgICAgIDogb3B0aW9ucy5tYXhMZW5ndGg7XG4gIHJlcGxhY2VyID0gb3B0aW9ucy5yZXBsYWNlcjtcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkob2JqLCBjdXJyZW50SW5kZW50LCByZXNlcnZlZCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHZhciBlbmQsIGluZGV4LCBpdGVtcywga2V5LCBrZXlQYXJ0LCBrZXlzLCBsZW5ndGgsIG5leHRJbmRlbnQsIHByZXR0aWZpZWQsIHN0YXJ0LCBzdHJpbmcsIHZhbHVlO1xuXG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuXG4gICAgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlcik7XG5cbiAgICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoIC0gY3VycmVudEluZGVudC5sZW5ndGggLSByZXNlcnZlZDtcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgcHJldHRpZmllZCA9IHN0cmluZy5yZXBsYWNlKFxuICAgICAgICBzdHJpbmdPckNoYXIsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCwgc3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdMaXRlcmFsIHx8IG1hdGNoICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocHJldHRpZmllZC5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmV0dGlmaWVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBKU09OLnBhcnNlKHN0cmluZyk7XG4gICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgIG5leHRJbmRlbnQgPSBjdXJyZW50SW5kZW50ICsgaW5kZW50O1xuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGluZGV4ID0gMDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBzdGFydCA9IFwiW1wiO1xuICAgICAgICBlbmQgPSBcIl1cIjtcbiAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChcbiAgICAgICAgICAgIF9zdHJpbmdpZnkob2JqW2luZGV4XSwgbmV4dEluZGVudCwgaW5kZXggPT09IGxlbmd0aCAtIDEgPyAwIDogMSkgfHxcbiAgICAgICAgICAgICAgXCJudWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IFwie1wiO1xuICAgICAgICBlbmQgPSBcIn1cIjtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgICBrZXlQYXJ0ID0gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOiBcIjtcbiAgICAgICAgICB2YWx1ZSA9IF9zdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIG5leHRJbmRlbnQsXG4gICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIChpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgaW5kZW50ICsgaXRlbXMuam9pbihcIixcXG5cIiArIG5leHRJbmRlbnQpLCBlbmRdLmpvaW4oXG4gICAgICAgICAgXCJcXG5cIiArIGN1cnJlbnRJbmRlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9KShwYXNzZWRPYmosIFwiXCIsIDApO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJpbXBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnZmFzdC1qc29uLXBhdGNoJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QnO1xuaW1wb3J0ICogYXMgdmVnYUltcG9ydCBmcm9tICd2ZWdhJztcbmltcG9ydCB7IHdyaXRlQ29uZmlnLCBtZXJnZUNvbmZpZywgaXNTdHJpbmcsIGlzQm9vbGVhbiwgaXNPYmplY3QgfSBmcm9tICd2ZWdhJztcbmltcG9ydCB7IGV4cHJlc3Npb25JbnRlcnByZXRlciB9IGZyb20gJ3ZlZ2EtaW50ZXJwcmV0ZXInO1xuaW1wb3J0ICogYXMgdmVnYUxpdGVJbXBvcnQgZnJvbSAndmVnYS1saXRlJztcbmltcG9ydCBzY2hlbWFQYXJzZXIgZnJvbSAndmVnYS1zY2hlbWEtdXJsLXBhcnNlcic7XG5pbXBvcnQgKiBhcyB0aGVtZXMgZnJvbSAndmVnYS10aGVtZXMnO1xuaW1wb3J0IHsgSGFuZGxlciB9IGZyb20gJ3ZlZ2EtdG9vbHRpcCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xudmFyIHVuZGVmaW5lZCQxOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbnZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG52YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xudmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbnZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5mdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cblxuLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4vLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbi8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbi8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgIGFyZzogZXJyXG4gICAgfTtcbiAgfVxufVxudmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG52YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbnZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG52YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4vLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4vLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG52YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4vLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbi8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbi8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG5mdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4vLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4vLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5JdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbmlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG59XG52YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5HZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4vLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbmZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGdlbkZ1bikge1xuICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gbWFyayhnZW5GdW4pIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgfSBlbHNlIHtcbiAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICB9XG4gIH1cbiAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICByZXR1cm4gZ2VuRnVuO1xufVxuXG4vLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbi8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4vLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4vLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuZnVuY3Rpb24gYXdyYXAoYXJnKSB7XG4gIHJldHVybiB7XG4gICAgX19hd2FpdDogYXJnXG4gIH07XG59XG5mdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHZhciBwcmV2aW91c1Byb21pc2U7XG4gIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbn1cbmRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5Bc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4vLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2Zcbi8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuZnVuY3Rpb24gYXN5bmMoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgcmV0dXJuIGlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBhcmc7XG4gICAgICB9XG5cbiAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgIH1cbiAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICBjb250ZXh0LmFyZyA9IGFyZztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4vLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbmZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkJDEpIHtcbiAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cbiAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cbiAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICBpZiAoIWluZm8pIHtcbiAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG59XG5cbi8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4vLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG5kZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbi8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4vLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbkdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xufTtcbmZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gIHZhciBlbnRyeSA9IHtcbiAgICB0cnlMb2M6IGxvY3NbMF1cbiAgfTtcbiAgaWYgKDEgaW4gbG9jcykge1xuICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgfVxuICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICB9XG4gIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgZGVsZXRlIHJlY29yZC5hcmc7XG4gIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG59XG5mdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICB0cnlMb2M6IFwicm9vdFwiXG4gIH1dO1xuICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gIHRoaXMucmVzZXQodHJ1ZSk7XG59XG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAga2V5cy5yZXZlcnNlKCk7XG5cbiAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG59XG5mdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgIHZhciBpID0gLTEsXG4gICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICByZXR1cm4ge1xuICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCQxLFxuICAgIGRvbmU6IHRydWVcbiAgfTtcbn1cbkNvbnRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICB0aGlzLnByZXYgPSAwO1xuICAgIHRoaXMubmV4dCA9IDA7XG4gICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQkMTtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG4gICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gIH0sXG4gIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG4gICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgIHJlY29yZC5hcmcgPSBhcmc7XG4gICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgfVxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICB9XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH0sXG4gIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgfSxcbiAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgfTtcbiAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cbn07XG5cbi8vIEV4cG9ydCBhIGRlZmF1bHQgbmFtZXNwYWNlIHRoYXQgcGxheXMgd2VsbCB3aXRoIFJvbGx1cFxudmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSB7XG4gIHdyYXAsXG4gIGlzR2VuZXJhdG9yRnVuY3Rpb24sXG4gIEFzeW5jSXRlcmF0b3IsXG4gIG1hcmssXG4gIGF3cmFwLFxuICBhc3luYyxcbiAga2V5cyxcbiAgdmFsdWVzXG59O1xuXG52YXIgaXRlcmF0b3I7XG52YXIgaGFzUmVxdWlyZWRJdGVyYXRvcjtcbmZ1bmN0aW9uIHJlcXVpcmVJdGVyYXRvcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSXRlcmF0b3IpIHJldHVybiBpdGVyYXRvcjtcbiAgaGFzUmVxdWlyZWRJdGVyYXRvciA9IDE7XG4gIGl0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IoWWFsbGlzdCkge1xuICAgIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgd2Fsa2VyO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHdhbGtlciA9IHRoaXMuaGVhZDtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoIXdhbGtlcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG52YXIgeWFsbGlzdCA9IFlhbGxpc3QkMTtcbllhbGxpc3QkMS5Ob2RlID0gTm9kZTtcbllhbGxpc3QkMS5jcmVhdGUgPSBZYWxsaXN0JDE7XG5mdW5jdGlvbiBZYWxsaXN0JDEobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0JDEpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0JDEoKTtcbiAgfVxuICBzZWxmLnRhaWwgPSBudWxsO1xuICBzZWxmLmhlYWQgPSBudWxsO1xuICBzZWxmLmxlbmd0aCA9IDA7XG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufVxuWWFsbGlzdCQxLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0Jyk7XG4gIH1cbiAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2O1xuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH1cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICB9XG4gIG5vZGUubGlzdC5sZW5ndGgtLTtcbiAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgbm9kZS5saXN0ID0gbnVsbDtcbiAgcmV0dXJuIG5leHQ7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICBub2RlLmxpc3QgPSB0aGlzO1xuICBub2RlLm5leHQgPSBoZWFkO1xuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGU7XG4gIH1cbiAgdGhpcy5oZWFkID0gbm9kZTtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlO1xuICB9XG4gIHRoaXMubGVuZ3RoKys7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG4gIHZhciB0YWlsID0gdGhpcy50YWlsO1xuICBub2RlLmxpc3QgPSB0aGlzO1xuICBub2RlLnByZXYgPSB0YWlsO1xuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gIH1cbiAgdGhpcy50YWlsID0gbm9kZTtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlO1xuICB9XG4gIHRoaXMubGVuZ3RoKys7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcbllhbGxpc3QkMS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5ZYWxsaXN0JDEucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWU7XG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gIH1cbiAgdGhpcy5sZW5ndGgtLTtcbiAgcmV0dXJuIHJlcztcbn07XG5ZYWxsaXN0JDEucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZTtcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgfVxuICB0aGlzLmxlbmd0aC0tO1xuICByZXR1cm4gcmVzO1xufTtcbllhbGxpc3QkMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcyk7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cbn07XG5ZYWxsaXN0JDEucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gIH1cbn07XG5ZYWxsaXN0JDEucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gIH1cbn07XG5ZYWxsaXN0JDEucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QkMSgpO1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbllhbGxpc3QkMS5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QkMSgpO1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbllhbGxpc3QkMS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2M7XG4gIHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWw7XG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgYWNjID0gdGhpcy5oZWFkLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuICByZXR1cm4gYWNjO1xufTtcbllhbGxpc3QkMS5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjO1xuICB2YXIgd2Fsa2VyID0gdGhpcy50YWlsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsO1xuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2O1xuICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgfVxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuICByZXR1cm4gYWNjO1xufTtcbllhbGxpc3QkMS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlO1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlO1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoO1xuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGg7XG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMDtcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aDtcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QkMSgpO1xuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDA7XG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aDtcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoO1xuICB9XG4gIGZyb20gPSBmcm9tIHx8IDA7XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGg7XG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0JDEoKTtcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwO1xuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5ZYWxsaXN0JDEucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSk7XG4gICAgd2Fsa2VyID0gdGhpcy5yZW1vdmVOb2RlKHdhbGtlcik7XG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbDtcbiAgfVxuICBpZiAod2Fsa2VyICE9PSB0aGlzLmhlYWQgJiYgd2Fsa2VyICE9PSB0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyAwIDogYXJndW1lbnRzLmxlbmd0aCAtIDIpOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBpICsgMiA8IDIgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMl0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuWWFsbGlzdCQxLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZDtcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWw7XG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2O1xuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHQ7XG4gICAgd2Fsa2VyLm5leHQgPSBwO1xuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWw7XG4gIHRoaXMudGFpbCA9IGhlYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIGluc2VydChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgPyBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZikgOiBuZXcgTm9kZSh2YWx1ZSwgbm9kZSwgbm9kZS5uZXh0LCBzZWxmKTtcbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZDtcbiAgfVxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkO1xuICB9XG4gIHNlbGYubGVuZ3RoKys7XG4gIHJldHVybiBpbnNlcnRlZDtcbn1cbmZ1bmN0aW9uIHB1c2goc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpO1xuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbDtcbiAgfVxuICBzZWxmLmxlbmd0aCsrO1xufVxuZnVuY3Rpb24gdW5zaGlmdChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZik7XG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkO1xuICB9XG4gIHNlbGYubGVuZ3RoKys7XG59XG5mdW5jdGlvbiBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCk7XG4gIH1cbiAgdGhpcy5saXN0ID0gbGlzdDtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXM7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICB9XG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpcztcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cbn1cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICByZXF1aXJlSXRlcmF0b3IoKShZYWxsaXN0JDEpO1xufSBjYXRjaCAoZXIpIHt9XG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbnZhciBZYWxsaXN0ID0geWFsbGlzdDtcbnZhciBNQVggPSBTeW1ib2woJ21heCcpO1xudmFyIExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJyk7XG52YXIgTEVOR1RIX0NBTENVTEFUT1IgPSBTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKTtcbnZhciBBTExPV19TVEFMRSA9IFN5bWJvbCgnYWxsb3dTdGFsZScpO1xudmFyIE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpO1xudmFyIERJU1BPU0UgPSBTeW1ib2woJ2Rpc3Bvc2UnKTtcbnZhciBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKTtcbnZhciBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpO1xudmFyIENBQ0hFID0gU3ltYm9sKCdjYWNoZScpO1xudmFyIFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKCd1cGRhdGVBZ2VPbkdldCcpO1xudmFyIG5haXZlTGVuZ3RoID0gKCkgPT4gMTtcblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSBvcHRpb25zID0ge1xuICAgICAgbWF4OiBvcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5O1xuICAgIHZhciBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoO1xuICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gdHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nID8gbmFpdmVMZW5ndGggOiBsYztcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDA7XG4gICAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZTtcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2U7XG4gICAgdGhpc1tVUERBVEVfQUdFX09OX0dFVF0gPSBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0IHx8IGZhbHNlO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXgobUwpIHtcbiAgICBpZiAodHlwZW9mIG1MICE9PSAnbnVtYmVyJyB8fCBtTCA8IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5O1xuICAgIHRyaW0odGhpcyk7XG4gIH1cbiAgZ2V0IG1heCgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdO1xuICB9XG4gIHNldCBhbGxvd1N0YWxlKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZTtcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV07XG4gIH1cbiAgc2V0IG1heEFnZShtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICB0aGlzW01BWF9BR0VdID0gbUE7XG4gICAgdHJpbSh0aGlzKTtcbiAgfVxuICBnZXQgbWF4QWdlKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdO1xuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJykgbEMgPSBuYWl2ZUxlbmd0aDtcbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDO1xuICAgICAgdGhpc1tMRU5HVEhdID0gMDtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSk7XG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRyaW0odGhpcyk7XG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXNbTEVOR1RIXTtcbiAgfVxuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGg7XG4gIH1cbiAgcmZvckVhY2goZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICAgIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXY7XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcCk7XG4gICAgICB3YWxrZXIgPSBwcmV2O1xuICAgIH1cbiAgfVxuICBmb3JFYWNoKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICB2YXIgbmV4dCA9IHdhbGtlci5uZXh0O1xuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApO1xuICAgICAgd2Fsa2VyID0gbmV4dDtcbiAgICB9XG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsua2V5KTtcbiAgfVxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSAmJiB0aGlzW0xSVV9MSVNUXSAmJiB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSk7XG4gICAgfVxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpOyAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKTsgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICAgIHRoaXNbTEVOR1RIXSA9IDA7IC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGhpdCA9PiBpc1N0YWxlKHRoaXMsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgIGs6IGhpdC5rZXksXG4gICAgICB2OiBoaXQudmFsdWUsXG4gICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICB9KS50b0FycmF5KCkuZmlsdGVyKGggPT4gaCk7XG4gIH1cbiAgZHVtcExydSgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF07XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdO1xuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgdmFyIG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwO1xuICAgIHZhciBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KTtcbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KTtcbiAgICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZTtcblxuICAgICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0ubm93ID0gbm93O1xuICAgICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2U7XG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGg7XG4gICAgICBpdGVtLmxlbmd0aCA9IGxlbjtcbiAgICAgIHRoaXMuZ2V0KGtleSk7XG4gICAgICB0cmltKHRoaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSk7XG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSkgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGg7XG4gICAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpO1xuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpO1xuICAgIHRyaW0odGhpcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWU7XG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdCk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKTtcbiAgfVxuICBwZWVrKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSk7XG4gIH1cbiAgcG9wKCkge1xuICAgIHZhciBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbDtcbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgIGRlbCh0aGlzLCBub2RlKTtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfVxuICBkZWwoa2V5KSB7XG4gICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcbiAgfVxuICBsb2FkKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICAgIGZvciAodmFyIGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgIHZhciBoaXQgPSBhcnJbbF07XG4gICAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMDtcbiAgICAgIGlmIChleHBpcmVzQXQgPT09IDApXG4gICAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudik7ZWxzZSB7XG4gICAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3c7XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcnVuZSgpIHtcbiAgICB0aGlzW0NBQ0hFXS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBnZXQodGhpcywga2V5LCBmYWxzZSkpO1xuICB9XG59XG52YXIgZ2V0ID0gKHNlbGYsIGtleSwgZG9Vc2UpID0+IHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KTtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZTtcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSk7XG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKSBub2RlLnZhbHVlLm5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGl0LnZhbHVlO1xuICB9XG59O1xudmFyIGlzU3RhbGUgPSAoc2VsZiwgaGl0KSA9PiB7XG4gIGlmICghaGl0IHx8ICFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSByZXR1cm4gZmFsc2U7XG4gIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3c7XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2UgOiBzZWxmW01BWF9BR0VdICYmIGRpZmYgPiBzZWxmW01BWF9BR0VdO1xufTtcbnZhciB0cmltID0gc2VsZiA9PiB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKHZhciB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsOyBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2O1xuICAgICAgZGVsKHNlbGYsIHdhbGtlcik7XG4gICAgICB3YWxrZXIgPSBwcmV2O1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWwgPSAoc2VsZiwgbm9kZSkgPT4ge1xuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlO1xuICAgIGlmIChzZWxmW0RJU1BPU0VdKSBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSk7XG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGg7XG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpO1xuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSk7XG4gIH1cbn07XG5jbGFzcyBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5ub3cgPSBub3c7XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMDtcbiAgfVxufVxudmFyIGZvckVhY2hTdGVwID0gKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkgPT4ge1xuICB2YXIgaGl0ID0gbm9kZS52YWx1ZTtcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKTtcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSBoaXQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGhpdCkgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKTtcbn07XG52YXIgbHJ1Q2FjaGUgPSBMUlVDYWNoZTtcblxuLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dCBzbyB3ZSBhbHdheXMgZ2V0IGEgY29uc2lzdGVudFxuLy8gb2JqIHdpdGgga2V5cyBpbiBhIGNvbnNpc3RlbnQgb3JkZXIuXG52YXIgb3B0cyA9IFsnaW5jbHVkZVByZXJlbGVhc2UnLCAnbG9vc2UnLCAncnRsJ107XG52YXIgcGFyc2VPcHRpb25zJDEgPSBvcHRpb25zID0+ICFvcHRpb25zID8ge30gOiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7XG4gIGxvb3NlOiB0cnVlXG59IDogb3B0cy5maWx0ZXIoayA9PiBvcHRpb25zW2tdKS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgb1trXSA9IHRydWU7XG4gIHJldHVybiBvO1xufSwge30pO1xudmFyIHBhcnNlT3B0aW9uc18xID0gcGFyc2VPcHRpb25zJDE7XG5cbnZhciByZUV4cG9ydHMgPSB7fTtcbnZhciByZSQxID0ge1xuICBnZXQgZXhwb3J0cygpeyByZXR1cm4gcmVFeHBvcnRzOyB9LFxuICBzZXQgZXhwb3J0cyh2KXsgcmVFeHBvcnRzID0gdjsgfSxcbn07XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbnZhciBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJztcbnZhciBNQVhfTEVOR1RIJDEgPSAyNTY7XG52YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi85MDA3MTk5MjU0NzQwOTkxO1xuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG52YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2O1xudmFyIGNvbnN0YW50cyA9IHtcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgTUFYX0xFTkdUSDogTUFYX0xFTkdUSCQxLFxuICBNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSJDEsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhcbn07XG5cbnZhciBkZWJ1ZyQxID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykgPyBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpO1xufSA6ICgpID0+IHt9O1xudmFyIGRlYnVnXzEgPSBkZWJ1ZyQxO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICB2YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IGNvbnN0YW50cy5NQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIO1xuICB2YXIgZGVidWcgPSBkZWJ1Z18xO1xuICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuICAvLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuICB2YXIgcmUgPSBleHBvcnRzLnJlID0gW107XG4gIHZhciBzcmMgPSBleHBvcnRzLnNyYyA9IFtdO1xuICB2YXIgdCA9IGV4cG9ydHMudCA9IHt9O1xuICB2YXIgUiA9IDA7XG4gIHZhciBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgICB2YXIgaW5kZXggPSBSKys7XG4gICAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKTtcbiAgICB0W25hbWVdID0gaW5kZXg7XG4gICAgc3JjW2luZGV4XSA9IHZhbHVlO1xuICAgIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKTtcbiAgfTtcblxuICAvLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4gIC8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbiAgLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4gIC8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG4gIGNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJyk7XG4gIGNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpO1xuXG4gIC8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbiAgLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4gIC8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG4gIGNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJyk7XG5cbiAgLy8gIyMgTWFpbiBWZXJzaW9uXG4gIC8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuICBjcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBcIihcIi5jb25jYXQoc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdLCBcIilcXFxcLlwiKSArIFwiKFwiLmNvbmNhdChzcmNbdC5OVU1FUklDSURFTlRJRklFUl0sIFwiKVxcXFwuXCIpICsgXCIoXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSwgXCIpXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBcIihcIi5jb25jYXQoc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0sIFwiKVxcXFwuXCIpICsgXCIoXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdLCBcIilcXFxcLlwiKSArIFwiKFwiLmNvbmNhdChzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSwgXCIpXCIpKTtcblxuICAvLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbiAgLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxuICBjcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBcIig/OlwiLmNvbmNhdChzcmNbdC5OVU1FUklDSURFTlRJRklFUl0sIFwifFwiKS5jb25jYXQoc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdLCBcIilcIikpO1xuICBjcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIFwiKD86XCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdLCBcInxcIikuY29uY2F0KHNyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXSwgXCIpXCIpKTtcblxuICAvLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4gIC8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4gIC8vIGlkZW50aWZpZXJzLlxuXG4gIGNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgXCIoPzotKFwiLmNvbmNhdChzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0sIFwiKD86XFxcXC5cIikuY29uY2F0KHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXSwgXCIpKikpXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIFwiKD86LT8oXCIuY29uY2F0KHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdLCBcIig/OlxcXFwuXCIpLmNvbmNhdChzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSwgXCIpKikpXCIpKTtcblxuICAvLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4gIC8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbiAgY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsICdbMC05QS1aYS16LV0rJyk7XG5cbiAgLy8gIyMgQnVpbGQgTWV0YWRhdGFcbiAgLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4gIC8vIGlkZW50aWZpZXJzLlxuXG4gIGNyZWF0ZVRva2VuKCdCVUlMRCcsIFwiKD86XFxcXCsoXCIuY29uY2F0KHNyY1t0LkJVSUxESURFTlRJRklFUl0sIFwiKD86XFxcXC5cIikuY29uY2F0KHNyY1t0LkJVSUxESURFTlRJRklFUl0sIFwiKSopKVwiKSk7XG5cbiAgLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuICAvLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4gIC8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4gIC8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2ZcbiAgLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4gIC8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4gIC8vIGNvbXBhcmlzb24uXG5cbiAgY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIFwidj9cIi5jb25jYXQoc3JjW3QuTUFJTlZFUlNJT05dKS5jb25jYXQoc3JjW3QuUFJFUkVMRUFTRV0sIFwiP1wiKS5jb25jYXQoc3JjW3QuQlVJTERdLCBcIj9cIikpO1xuICBjcmVhdGVUb2tlbignRlVMTCcsIFwiXlwiLmNvbmNhdChzcmNbdC5GVUxMUExBSU5dLCBcIiRcIikpO1xuXG4gIC8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbiAgLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbiAgLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG4gIGNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgXCJbdj1cXFxcc10qXCIuY29uY2F0KHNyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdKS5jb25jYXQoc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSwgXCI/XCIpLmNvbmNhdChzcmNbdC5CVUlMRF0sIFwiP1wiKSk7XG4gIGNyZWF0ZVRva2VuKCdMT09TRScsIFwiXlwiLmNvbmNhdChzcmNbdC5MT09TRVBMQUlOXSwgXCIkXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJyk7XG5cbiAgLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4gIC8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbiAgLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbiAgY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIFwiXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdLCBcInx4fFh8XFxcXCpcIikpO1xuICBjcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIFwiXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSwgXCJ8eHxYfFxcXFwqXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgXCJbdj1cXFxcc10qKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VJREVOVElGSUVSXSwgXCIpXCIpICsgXCIoPzpcXFxcLihcIi5jb25jYXQoc3JjW3QuWFJBTkdFSURFTlRJRklFUl0sIFwiKVwiKSArIFwiKD86XFxcXC4oXCIuY29uY2F0KHNyY1t0LlhSQU5HRUlERU5USUZJRVJdLCBcIilcIikgKyBcIig/OlwiLmNvbmNhdChzcmNbdC5QUkVSRUxFQVNFXSwgXCIpP1wiKS5jb25jYXQoc3JjW3QuQlVJTERdLCBcIj9cIikgKyBcIik/KT9cIik7XG4gIGNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgXCJbdj1cXFxcc10qKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdLCBcIilcIikgKyBcIig/OlxcXFwuKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdLCBcIilcIikgKyBcIig/OlxcXFwuKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdLCBcIilcIikgKyBcIig/OlwiLmNvbmNhdChzcmNbdC5QUkVSRUxFQVNFTE9PU0VdLCBcIik/XCIpLmNvbmNhdChzcmNbdC5CVUlMRF0sIFwiP1wiKSArIFwiKT8pP1wiKTtcbiAgY3JlYXRlVG9rZW4oJ1hSQU5HRScsIFwiXlwiLmNvbmNhdChzcmNbdC5HVExUXSwgXCJcXFxccypcIikuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOXSwgXCIkXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgXCJeXCIuY29uY2F0KHNyY1t0LkdUTFRdLCBcIlxcXFxzKlwiKS5jb25jYXQoc3JjW3QuWFJBTkdFUExBSU5MT09TRV0sIFwiJFwiKSk7XG5cbiAgLy8gQ29lcmNpb24uXG4gIC8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbiAgY3JlYXRlVG9rZW4oJ0NPRVJDRScsIFwiXCIuY29uY2F0KCcoXnxbXlxcXFxkXSknICsgJyhcXFxcZHsxLCcpLmNvbmNhdChNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILCBcIn0pXCIpICsgXCIoPzpcXFxcLihcXFxcZHsxLFwiLmNvbmNhdChNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILCBcIn0pKT9cIikgKyBcIig/OlxcXFwuKFxcXFxkezEsXCIuY29uY2F0KE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsIFwifSkpP1wiKSArIFwiKD86JHxbXlxcXFxkXSlcIik7XG4gIGNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKTtcblxuICAvLyBUaWxkZSByYW5nZXMuXG4gIC8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG4gIGNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpO1xuICBjcmVhdGVUb2tlbignVElMREVUUklNJywgXCIoXFxcXHMqKVwiLmNvbmNhdChzcmNbdC5MT05FVElMREVdLCBcIlxcXFxzK1wiKSwgdHJ1ZSk7XG4gIGV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nO1xuICBjcmVhdGVUb2tlbignVElMREUnLCBcIl5cIi5jb25jYXQoc3JjW3QuTE9ORVRJTERFXSkuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOXSwgXCIkXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBcIl5cIi5jb25jYXQoc3JjW3QuTE9ORVRJTERFXSkuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdLCBcIiRcIikpO1xuXG4gIC8vIENhcmV0IHJhbmdlcy5cbiAgLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbiAgY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKTtcbiAgY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIFwiKFxcXFxzKilcIi5jb25jYXQoc3JjW3QuTE9ORUNBUkVUXSwgXCJcXFxccytcIiksIHRydWUpO1xuICBleHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJztcbiAgY3JlYXRlVG9rZW4oJ0NBUkVUJywgXCJeXCIuY29uY2F0KHNyY1t0LkxPTkVDQVJFVF0pLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTl0sIFwiJFwiKSk7XG4gIGNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgXCJeXCIuY29uY2F0KHNyY1t0LkxPTkVDQVJFVF0pLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSwgXCIkXCIpKTtcblxuICAvLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuICBjcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgXCJeXCIuY29uY2F0KHNyY1t0LkdUTFRdLCBcIlxcXFxzKihcIikuY29uY2F0KHNyY1t0LkxPT1NFUExBSU5dLCBcIikkfF4kXCIpKTtcbiAgY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBcIl5cIi5jb25jYXQoc3JjW3QuR1RMVF0sIFwiXFxcXHMqKFwiKS5jb25jYXQoc3JjW3QuRlVMTFBMQUlOXSwgXCIpJHxeJFwiKSk7XG5cbiAgLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbiAgLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuICBjcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBcIihcXFxccyopXCIuY29uY2F0KHNyY1t0LkdUTFRdLCBcIlxcXFxzKihcIikuY29uY2F0KHNyY1t0LkxPT1NFUExBSU5dLCBcInxcIikuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOXSwgXCIpXCIpLCB0cnVlKTtcbiAgZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJztcblxuICAvLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbiAgLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuICAvLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4gIC8vIGxhdGVyLlxuICBjcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBcIl5cXFxccyooXCIuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOXSwgXCIpXCIpICsgXCJcXFxccystXFxcXHMrXCIgKyBcIihcIi5jb25jYXQoc3JjW3QuWFJBTkdFUExBSU5dLCBcIilcIikgKyBcIlxcXFxzKiRcIik7XG4gIGNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgXCJeXFxcXHMqKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSwgXCIpXCIpICsgXCJcXFxccystXFxcXHMrXCIgKyBcIihcIi5jb25jYXQoc3JjW3QuWFJBTkdFUExBSU5MT09TRV0sIFwiKVwiKSArIFwiXFxcXHMqJFwiKTtcblxuICAvLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG4gIGNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKTtcbiAgLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuICBjcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wXFxcXHMqJCcpO1xuICBjcmVhdGVUb2tlbignR1RFMFBSRScsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wLTBcXFxccyokJyk7XG59KShyZSQxLCByZUV4cG9ydHMpO1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG52YXIgY29tcGFyZUlkZW50aWZpZXJzJDEgPSAoYSwgYikgPT4ge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKTtcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYik7XG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2E7XG4gICAgYiA9ICtiO1xuICB9XG4gIHJldHVybiBhID09PSBiID8gMCA6IGFudW0gJiYgIWJudW0gPyAtMSA6IGJudW0gJiYgIWFudW0gPyAxIDogYSA8IGIgPyAtMSA6IDE7XG59O1xudmFyIHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzJDEoYiwgYSk7XG52YXIgaWRlbnRpZmllcnMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVyczogY29tcGFyZUlkZW50aWZpZXJzJDEsXG4gIHJjb21wYXJlSWRlbnRpZmllcnNcbn07XG5cbnZhciBkZWJ1ZyA9IGRlYnVnXzE7XG52YXIgTUFYX0xFTkdUSCA9IGNvbnN0YW50cy5NQVhfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSID0gY29uc3RhbnRzLk1BWF9TQUZFX0lOVEVHRVI7XG52YXIgcmUgPSByZUV4cG9ydHMucmUsXG4gIHQgPSByZUV4cG9ydHMudDtcbnZhciBwYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnNfMTtcbnZhciBjb21wYXJlSWRlbnRpZmllcnMgPSBpZGVudGlmaWVycy5jb21wYXJlSWRlbnRpZmllcnM7XG5sZXQgU2VtVmVyJDEgPSBjbGFzcyBTZW1WZXIge1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJiB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBWZXJzaW9uOiBcIi5jb25jYXQodmVyc2lvbikpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmVyc2lvbiBpcyBsb25nZXIgdGhhbiBcIi5jb25jYXQoTUFYX0xFTkdUSCwgXCIgY2hhcmFjdGVyc1wiKSk7XG4gICAgfVxuICAgIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG4gICAgLy8gdGhpcyBpc24ndCBhY3R1YWxseSByZWxldmFudCBmb3IgdmVyc2lvbnMsIGJ1dCBrZWVwIGl0IHNvIHRoYXQgd2VcbiAgICAvLyBkb24ndCBydW4gaW50byB0cm91YmxlIHBhc3NpbmcgdGhpcy5vcHRpb25zIGFyb3VuZC5cbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlO1xuICAgIHZhciBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gob3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXSk7XG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBWZXJzaW9uOiBcIi5jb25jYXQodmVyc2lvbikpO1xuICAgIH1cbiAgICB0aGlzLnJhdyA9IHZlcnNpb247XG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXTtcbiAgICB0aGlzLm1pbm9yID0gK21bMl07XG4gICAgdGhpcy5wYXRjaCA9ICttWzNdO1xuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJyk7XG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChpZCA9PiB7XG4gICAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgICAgdmFyIG51bSA9ICtpZDtcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gICAgdGhpcy5mb3JtYXQoKTtcbiAgfVxuICBmb3JtYXQoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gXCJcIi5jb25jYXQodGhpcy5tYWpvciwgXCIuXCIpLmNvbmNhdCh0aGlzLm1pbm9yLCBcIi5cIikuY29uY2F0KHRoaXMucGF0Y2gpO1xuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gXCItXCIuY29uY2F0KHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gIH1cbiAgY29tcGFyZShvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcik7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcik7XG4gIH1cbiAgY29tcGFyZU1haW4ob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHwgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fCBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpO1xuICB9XG4gIGNvbXBhcmVQcmUob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICBkbyB7XG4gICAgICB2YXIgYSA9IHRoaXMucHJlcmVsZWFzZVtpXTtcbiAgICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSk7XG4gIH1cbiAgY29tcGFyZUJ1aWxkKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICBkbyB7XG4gICAgICB2YXIgYSA9IHRoaXMuYnVpbGRbaV07XG4gICAgICB2YXIgYiA9IG90aGVyLmJ1aWxkW2ldO1xuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKTtcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgICB0aGlzLm1ham9yKys7XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHwgdGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rKztcbiAgICAgICAgICAgICAgaSA9IC0yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBpZiAoY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucHJlcmVsZWFzZVswXSwgaWRlbnRpZmllcikgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBcIi5jb25jYXQocmVsZWFzZSkpO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpO1xuICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIHNlbXZlciA9IFNlbVZlciQxO1xuXG52YXIgU2VtVmVyID0gc2VtdmVyO1xudmFyIGNvbXBhcmUkNiA9IChhLCBiLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSk7XG52YXIgY29tcGFyZV8xID0gY29tcGFyZSQ2O1xuXG52YXIgY29tcGFyZSQ1ID0gY29tcGFyZV8xO1xudmFyIGVxJDEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUkNShhLCBiLCBsb29zZSkgPT09IDA7XG52YXIgZXFfMSA9IGVxJDE7XG5cbnZhciBjb21wYXJlJDQgPSBjb21wYXJlXzE7XG52YXIgbmVxJDEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUkNChhLCBiLCBsb29zZSkgIT09IDA7XG52YXIgbmVxXzEgPSBuZXEkMTtcblxudmFyIGNvbXBhcmUkMyA9IGNvbXBhcmVfMTtcbnZhciBndCQxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlJDMoYSwgYiwgbG9vc2UpID4gMDtcbnZhciBndF8xID0gZ3QkMTtcblxudmFyIGNvbXBhcmUkMiA9IGNvbXBhcmVfMTtcbnZhciBndGUkMSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZSQyKGEsIGIsIGxvb3NlKSA+PSAwO1xudmFyIGd0ZV8xID0gZ3RlJDE7XG5cbnZhciBjb21wYXJlJDEgPSBjb21wYXJlXzE7XG52YXIgbHQkMSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZSQxKGEsIGIsIGxvb3NlKSA8IDA7XG52YXIgbHRfMSA9IGx0JDE7XG5cbnZhciBjb21wYXJlID0gY29tcGFyZV8xO1xudmFyIGx0ZSQxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwO1xudmFyIGx0ZV8xID0gbHRlJDE7XG5cbnZhciBlcSA9IGVxXzE7XG52YXIgbmVxID0gbmVxXzE7XG52YXIgZ3QgPSBndF8xO1xudmFyIGd0ZSA9IGd0ZV8xO1xudmFyIGx0ID0gbHRfMTtcbnZhciBsdGUgPSBsdGVfMTtcbnZhciBjbXAgPSAoYSwgb3AsIGIsIGxvb3NlKSA9PiB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhICE9PSBiO1xuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKTtcbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKTtcbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSk7XG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSk7XG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpO1xuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBvcGVyYXRvcjogXCIuY29uY2F0KG9wKSk7XG4gIH1cbn07XG52YXIgY21wXzEgPSBjbXA7XG5cbnZhciBjb21wYXJhdG9yO1xudmFyIGhhc1JlcXVpcmVkQ29tcGFyYXRvcjtcbmZ1bmN0aW9uIHJlcXVpcmVDb21wYXJhdG9yKCkge1xuICBpZiAoaGFzUmVxdWlyZWRDb21wYXJhdG9yKSByZXR1cm4gY29tcGFyYXRvcjtcbiAgaGFzUmVxdWlyZWRDb21wYXJhdG9yID0gMTtcbiAgdmFyIEFOWSA9IFN5bWJvbCgnU2VtVmVyIEFOWScpO1xuICAvLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuICBjbGFzcyBDb21wYXJhdG9yIHtcbiAgICBzdGF0aWMgZ2V0IEFOWSgpIHtcbiAgICAgIHJldHVybiBBTlk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbXAsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG4gICAgICB0aGlzLnBhcnNlKGNvbXApO1xuICAgICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uO1xuICAgICAgfVxuICAgICAgZGVidWcoJ2NvbXAnLCB0aGlzKTtcbiAgICB9XG4gICAgcGFyc2UoY29tcCkge1xuICAgICAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdO1xuICAgICAgdmFyIG0gPSBjb21wLm1hdGNoKHIpO1xuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGNvbXBhcmF0b3I6IFwiLmNvbmNhdChjb21wKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgICAgaWYgKCFtWzJdKSB7XG4gICAgICAgIHRoaXMuc2VtdmVyID0gQU5ZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRlc3QodmVyc2lvbikge1xuICAgICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSk7XG4gICAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGludGVyc2VjdHMoY29tcCwgb3B0aW9ucykge1xuICAgICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpO1xuICAgICAgfVxuICAgICAgdmFyIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID0gKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJiAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICAgICAgdmFyIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID0gKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJiAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICAgICAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uO1xuICAgICAgdmFyIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPSAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJiAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKTtcbiAgICAgIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9IGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiYgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJiAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICAgICAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID0gY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJiAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+Jyk7XG4gICAgICByZXR1cm4gc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHwgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHwgc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuO1xuICAgIH1cbiAgfVxuICBjb21wYXJhdG9yID0gQ29tcGFyYXRvcjtcbiAgdmFyIHBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9uc18xO1xuICB2YXIgcmUgPSByZUV4cG9ydHMucmUsXG4gICAgdCA9IHJlRXhwb3J0cy50O1xuICB2YXIgY21wID0gY21wXzE7XG4gIHZhciBkZWJ1ZyA9IGRlYnVnXzE7XG4gIHZhciBTZW1WZXIgPSBzZW12ZXI7XG4gIHZhciBSYW5nZSA9IHJlcXVpcmVSYW5nZSgpO1xuICByZXR1cm4gY29tcGFyYXRvcjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciByYW5nZTtcbnZhciBoYXNSZXF1aXJlZFJhbmdlO1xuZnVuY3Rpb24gcmVxdWlyZVJhbmdlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRSYW5nZSkgcmV0dXJuIHJhbmdlO1xuICBoYXNSZXF1aXJlZFJhbmdlID0gMTtcbiAgLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbiAgY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiYgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWU7XG4gICAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dO1xuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICAgICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZTtcblxuICAgICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICAgIHRoaXMucmF3ID0gcmFuZ2U7XG4gICAgICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KCd8fCcpXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAociA9PiB0aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpO1xuICAgICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgU2VtVmVyIFJhbmdlOiBcIi5jb25jYXQocmFuZ2UpKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5zZXRbMF07XG4gICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSk7XG4gICAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKHRoaXMuc2V0KSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgYyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IFtjXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuICAgIGZvcm1hdCgpIHtcbiAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoY29tcHMgPT4ge1xuICAgICAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKTtcbiAgICAgIH0pLmpvaW4oJ3x8JykudHJpbSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2U7XG4gICAgfVxuICAgIHBhcnNlUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHJhbmdlID0gcmFuZ2UudHJpbSgpO1xuXG4gICAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgICAgdmFyIG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJyk7XG4gICAgICB2YXIgbWVtb0tleSA9IFwicGFyc2VSYW5nZTpcIi5jb25jYXQobWVtb09wdHMsIFwiOlwiKS5jb25jYXQocmFuZ2UpO1xuICAgICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgIH1cbiAgICAgIHZhciBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZTtcbiAgICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgICAgdmFyIGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV07XG4gICAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSk7XG4gICAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSk7XG4gICAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSk7XG5cbiAgICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG5cbiAgICAgIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICAgICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSk7XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG5cbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgICB2YXIgcmFuZ2VMaXN0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSkuam9pbignICcpLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSk7XG4gICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgICAgcmFuZ2VMaXN0ID0gcmFuZ2VMaXN0LmZpbHRlcihjb21wID0+IHtcbiAgICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWJ1ZygncmFuZ2UgbGlzdCcsIHJhbmdlTGlzdCk7XG5cbiAgICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgICB2YXIgcmFuZ2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZUxpc3QubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSk7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoY29tcGFyYXRvcnMpLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjb21wID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGlmIChpc051bGxTZXQoY29tcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29tcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSkge1xuICAgICAgICByYW5nZU1hcC5kZWxldGUoJycpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV07XG4gICAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGludGVyc2VjdHMocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNldC5zb21lKHRoaXNDb21wYXJhdG9ycyA9PiB7XG4gICAgICAgIHJldHVybiBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiYgcmFuZ2Uuc2V0LnNvbWUocmFuZ2VDb21wYXJhdG9ycyA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiYgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KHRoaXNDb21wYXJhdG9yID0+IHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KHJhbmdlQ29tcGFyYXRvciA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gICAgdGVzdCh2ZXJzaW9uKSB7XG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmFuZ2UgPSBSYW5nZTtcbiAgdmFyIExSVSA9IGxydUNhY2hlO1xuICB2YXIgY2FjaGUgPSBuZXcgTFJVKHtcbiAgICBtYXg6IDEwMDBcbiAgfSk7XG4gIHZhciBwYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnNfMTtcbiAgdmFyIENvbXBhcmF0b3IgPSByZXF1aXJlQ29tcGFyYXRvcigpO1xuICB2YXIgZGVidWcgPSBkZWJ1Z18xO1xuICB2YXIgU2VtVmVyID0gc2VtdmVyO1xuICB2YXIgcmUgPSByZUV4cG9ydHMucmUsXG4gICAgdCA9IHJlRXhwb3J0cy50LFxuICAgIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9IHJlRXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gICAgdGlsZGVUcmltUmVwbGFjZSA9IHJlRXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlLFxuICAgIGNhcmV0VHJpbVJlcGxhY2UgPSByZUV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZTtcbiAgdmFyIGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJztcbiAgdmFyIGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJztcblxuICAvLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuICAvLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG4gIHZhciBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgdmFyIHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKTtcbiAgICB2YXIgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKTtcbiAgICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkob3RoZXJDb21wYXJhdG9yID0+IHtcbiAgICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuICAvLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4gIC8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuICB2YXIgcGFyc2VDb21wYXJhdG9yID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpO1xuICAgIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpO1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXApO1xuICAgIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpO1xuICAgIGRlYnVnKCd0aWxkZXMnLCBjb21wKTtcbiAgICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucyk7XG4gICAgZGVidWcoJ3hyYW5nZScsIGNvbXApO1xuICAgIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucyk7XG4gICAgZGVidWcoJ3N0YXJzJywgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG4gIH07XG4gIHZhciBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKic7XG5cbiAgLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4gIC8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuICAvLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4gIC8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbiAgLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMC0wXG4gIC8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuICAvLyB+MC4wLjEgLS0+ID49MC4wLjEgPDAuMS4wLTBcbiAgdmFyIHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoYyA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xuICB2YXIgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV07XG4gICAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICAgIHZhciByZXQ7XG4gICAgICBpZiAoaXNYKE0pKSB7XG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi4wLjAgPFwiKS5jb25jYXQoK00gKyAxLCBcIi4wLjAtMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgICByZXQgPSBcIj49XCIuY29uY2F0KE0sIFwiLlwiKS5jb25jYXQobSwgXCIuMCA8XCIpLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KCttICsgMSwgXCIuMC0wXCIpO1xuICAgICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgICByZXQgPSBcIj49XCIuY29uY2F0KE0sIFwiLlwiKS5jb25jYXQobSwgXCIuXCIpLmNvbmNhdChwLCBcIi1cIikuY29uY2F0KHByLCBcIiA8XCIpLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KCttICsgMSwgXCIuMC0wXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KG0sIFwiLlwiKS5jb25jYXQocCwgXCIgPFwiKS5jb25jYXQoTSwgXCIuXCIpLmNvbmNhdCgrbSArIDEsIFwiLjAtMFwiKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuICAvLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4gIC8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuICAvLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbiAgLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMC0wXG4gIC8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuICAvLyBeMC4wLjEgLS0+ID49MC4wLjEgPDAuMC4yLTBcbiAgLy8gXjAuMS4wIC0tPiA+PTAuMS4wIDwwLjIuMC0wXG4gIHZhciByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+IGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGMgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJyAnKTtcbiAgdmFyIHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucyk7XG4gICAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdO1xuICAgIHZhciB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJztcbiAgICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgICAgdmFyIHJldDtcbiAgICAgIGlmIChpc1goTSkpIHtcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgICByZXQgPSBcIj49XCIuY29uY2F0KE0sIFwiLjAuMFwiKS5jb25jYXQoeiwgXCIgPFwiKS5jb25jYXQoK00gKyAxLCBcIi4wLjAtMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBcIj49XCIuY29uY2F0KE0sIFwiLlwiKS5jb25jYXQobSwgXCIuMFwiKS5jb25jYXQoeiwgXCIgPFwiKS5jb25jYXQoTSwgXCIuXCIpLmNvbmNhdCgrbSArIDEsIFwiLjAtMFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBcIj49XCIuY29uY2F0KE0sIFwiLlwiKS5jb25jYXQobSwgXCIuMFwiKS5jb25jYXQoeiwgXCIgPFwiKS5jb25jYXQoK00gKyAxLCBcIi4wLjAtMFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpO1xuICAgICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KG0sIFwiLlwiKS5jb25jYXQocCwgXCItXCIpLmNvbmNhdChwciwgXCIgPFwiKS5jb25jYXQoTSwgXCIuXCIpLmNvbmNhdChtLCBcIi5cIikuY29uY2F0KCtwICsgMSwgXCItMFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KG0sIFwiLlwiKS5jb25jYXQocCwgXCItXCIpLmNvbmNhdChwciwgXCIgPFwiKS5jb25jYXQoTSwgXCIuXCIpLmNvbmNhdCgrbSArIDEsIFwiLjAtMFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KG0sIFwiLlwiKS5jb25jYXQocCwgXCItXCIpLmNvbmNhdChwciwgXCIgPFwiKS5jb25jYXQoK00gKyAxLCBcIi4wLjAtMFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ25vIHByJyk7XG4gICAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXQgPSBcIj49XCIuY29uY2F0KE0sIFwiLlwiKS5jb25jYXQobSwgXCIuXCIpLmNvbmNhdChwKS5jb25jYXQoeiwgXCIgPFwiKS5jb25jYXQoTSwgXCIuXCIpLmNvbmNhdChtLCBcIi5cIikuY29uY2F0KCtwICsgMSwgXCItMFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KG0sIFwiLlwiKS5jb25jYXQocCkuY29uY2F0KHosIFwiIDxcIikuY29uY2F0KE0sIFwiLlwiKS5jb25jYXQoK20gKyAxLCBcIi4wLTBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IFwiPj1cIi5jb25jYXQoTSwgXCIuXCIpLmNvbmNhdChtLCBcIi5cIikuY29uY2F0KHAsIFwiIDxcIikuY29uY2F0KCtNICsgMSwgXCIuMC4wLTBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChjID0+IHtcbiAgICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfTtcbiAgdmFyIHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbXAgPSBjb21wLnRyaW0oKTtcbiAgICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXTtcbiAgICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcik7XG4gICAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgICB2YXIgeG0gPSB4TSB8fCBpc1gobSk7XG4gICAgICB2YXIgeHAgPSB4bSB8fCBpc1gocCk7XG4gICAgICB2YXIgYW55WCA9IHhwO1xuICAgICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICAgIGd0bHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJyc7XG4gICAgICBpZiAoeE0pIHtcbiAgICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgICByZXQgPSAnPDAuMC4wLTAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgICAgcmV0ID0gJyonO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IDA7XG4gICAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgICBwID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgICBndGx0ID0gJzwnO1xuICAgICAgICAgIGlmICh4bSkge1xuICAgICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICAgIHByID0gJy0wJztcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBcIlwiLmNvbmNhdChndGx0ICsgTSwgXCIuXCIpLmNvbmNhdChtLCBcIi5cIikuY29uY2F0KHApLmNvbmNhdChwcik7XG4gICAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICAgIHJldCA9IFwiPj1cIi5jb25jYXQoTSwgXCIuMC4wXCIpLmNvbmNhdChwciwgXCIgPFwiKS5jb25jYXQoK00gKyAxLCBcIi4wLjAtMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgICAgcmV0ID0gXCI+PVwiLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KG0sIFwiLjBcIikuY29uY2F0KHByLCBcIiA8XCIpLmNvbmNhdChNLCBcIi5cIikuY29uY2F0KCttICsgMSwgXCIuMC0wXCIpO1xuICAgICAgfVxuICAgICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuICAvLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG4gIHZhciByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICAgIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKTtcbiAgICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVt0LlNUQVJdLCAnJyk7XG4gIH07XG4gIHZhciByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gICAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKTtcbiAgfTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbiAgLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4gIC8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuICAvLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4gIC8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG4gIHZhciBoeXBoZW5SZXBsYWNlID0gaW5jUHIgPT4gKCQwLCBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLCB0bywgdE0sIHRtLCB0cCwgdHByLCB0YikgPT4ge1xuICAgIGlmIChpc1goZk0pKSB7XG4gICAgICBmcm9tID0gJyc7XG4gICAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgICBmcm9tID0gXCI+PVwiLmNvbmNhdChmTSwgXCIuMC4wXCIpLmNvbmNhdChpbmNQciA/ICctMCcgOiAnJyk7XG4gICAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgICBmcm9tID0gXCI+PVwiLmNvbmNhdChmTSwgXCIuXCIpLmNvbmNhdChmbSwgXCIuMFwiKS5jb25jYXQoaW5jUHIgPyAnLTAnIDogJycpO1xuICAgIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgICBmcm9tID0gXCI+PVwiLmNvbmNhdChmcm9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbSA9IFwiPj1cIi5jb25jYXQoZnJvbSkuY29uY2F0KGluY1ByID8gJy0wJyA6ICcnKTtcbiAgICB9XG4gICAgaWYgKGlzWCh0TSkpIHtcbiAgICAgIHRvID0gJyc7XG4gICAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgICB0byA9IFwiPFwiLmNvbmNhdCgrdE0gKyAxLCBcIi4wLjAtMFwiKTtcbiAgICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICAgIHRvID0gXCI8XCIuY29uY2F0KHRNLCBcIi5cIikuY29uY2F0KCt0bSArIDEsIFwiLjAtMFwiKTtcbiAgICB9IGVsc2UgaWYgKHRwcikge1xuICAgICAgdG8gPSBcIjw9XCIuY29uY2F0KHRNLCBcIi5cIikuY29uY2F0KHRtLCBcIi5cIikuY29uY2F0KHRwLCBcIi1cIikuY29uY2F0KHRwcik7XG4gICAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgICAgdG8gPSBcIjxcIi5jb25jYXQodE0sIFwiLlwiKS5jb25jYXQodG0sIFwiLlwiKS5jb25jYXQoK3RwICsgMSwgXCItMFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG8gPSBcIjw9XCIuY29uY2F0KHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGZyb20sIFwiIFwiKS5jb25jYXQodG8pLnRyaW0oKTtcbiAgfTtcbiAgdmFyIHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZXQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGRlYnVnKHNldFtfaV0uc2VtdmVyKTtcbiAgICAgICAgaWYgKHNldFtfaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRbX2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtfaV0uc2VtdmVyO1xuICAgICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiYgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIHJhbmdlO1xufVxuXG52YXIgUmFuZ2UgPSByZXF1aXJlUmFuZ2UoKTtcbnZhciBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xufTtcbnZhciBzYXRpc2ZpZXNfMSA9IHNhdGlzZmllcztcblxuLyoqXG4gKiBPcGVuIGVkaXRvciB1cmwgaW4gYSBuZXcgd2luZG93LCBhbmQgcGFzcyBhIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHBvc3QgKHdpbmRvdywgdXJsLCBkYXRhKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gIHZhciBlZGl0b3IgPSB3aW5kb3cub3Blbih1cmwpO1xuICB2YXIgd2FpdCA9IDEwMDAwO1xuICB2YXIgc3RlcCA9IDI1MDtcbiAgdmFyIF9VUkwgPSBuZXcgVVJMKHVybCksXG4gICAgb3JpZ2luID0gX1VSTC5vcmlnaW47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIHZhciBjb3VudCA9IH5+KHdhaXQgLyBzdGVwKTtcbiAgZnVuY3Rpb24gbGlzdGVuKGV2dCkge1xuICAgIGlmIChldnQuc291cmNlID09PSBlZGl0b3IpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuLCBmYWxzZSk7XG5cbiAgLy8gc2VuZCBtZXNzYWdlXG4gIC8vIHBlcmlvZGljYWxseSByZXNlbmQgdW50aWwgYWNrIHJlY2VpdmVkIG9yIHRpbWVvdXRcbiAgZnVuY3Rpb24gc2VuZCgpIHtcbiAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucG9zdE1lc3NhZ2UoZGF0YSwgb3JpZ2luKTtcbiAgICBzZXRUaW1lb3V0KHNlbmQsIHN0ZXApO1xuICAgIGNvdW50IC09IDE7XG4gIH1cbiAgc2V0VGltZW91dChzZW5kLCBzdGVwKTtcbn1cblxuLy8gZ2VuZXJhdGVkIHdpdGggYnVpbGQtc3R5bGUuc2hcbnZhciBlbWJlZFN0eWxlID0gXCIudmVnYS1lbWJlZCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4udmVnYS1lbWJlZC5oYXMtYWN0aW9ucyB7XFxuICBwYWRkaW5nLXJpZ2h0OiAzOHB4O1xcbn1cXG4udmVnYS1lbWJlZCBkZXRhaWxzOm5vdChbb3Blbl0pID4gOm5vdChzdW1tYXJ5KSB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxufVxcbi52ZWdhLWVtYmVkIHN1bW1hcnkge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgcGFkZGluZzogNnB4O1xcbiAgei1pbmRleDogMTAwMDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgY29sb3I6ICMxYjFlMjM7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYWFhO1xcbiAgYm9yZGVyLXJhZGl1czogOTk5cHg7XFxuICBvcGFjaXR5OiAwLjI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNHMgZWFzZS1pbjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAwcHg7XFxufVxcbi52ZWdhLWVtYmVkIHN1bW1hcnk6Oi13ZWJraXQtZGV0YWlscy1tYXJrZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLnZlZ2EtZW1iZWQgc3VtbWFyeTphY3RpdmUge1xcbiAgYm94LXNoYWRvdzogI2FhYSAwcHggMHB4IDBweCAxcHggaW5zZXQ7XFxufVxcbi52ZWdhLWVtYmVkIHN1bW1hcnkgc3ZnIHtcXG4gIHdpZHRoOiAxNHB4O1xcbiAgaGVpZ2h0OiAxNHB4O1xcbn1cXG4udmVnYS1lbWJlZCBkZXRhaWxzW29wZW5dIHN1bW1hcnkge1xcbiAgb3BhY2l0eTogMC43O1xcbn1cXG4udmVnYS1lbWJlZDpob3ZlciBzdW1tYXJ5LCAudmVnYS1lbWJlZDpmb2N1cy13aXRoaW4gc3VtbWFyeSB7XFxuICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZTtcXG59XFxuLnZlZ2EtZW1iZWQgLnZlZ2EtYWN0aW9ucyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMDAxO1xcbiAgdG9wOiAzNXB4O1xcbiAgcmlnaHQ6IC05cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICBwYWRkaW5nLXRvcDogOHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYm94LXNoYWRvdzogMCAycHggOHB4IDAgcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2Q5ZDlkOTtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjE1cztcXG4gIGFuaW1hdGlvbi1uYW1lOiBzY2FsZS1pbjtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIsIDAsIDAuMTMsIDEuNSk7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG4udmVnYS1lbWJlZCAudmVnYS1hY3Rpb25zIGEge1xcbiAgcGFkZGluZzogOHB4IDE2cHg7XFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgY29sb3I6ICM0MzRhNTY7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcbi52ZWdhLWVtYmVkIC52ZWdhLWFjdGlvbnMgYTpob3ZlciwgLnZlZ2EtZW1iZWQgLnZlZ2EtYWN0aW9ucyBhOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjk7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcbi52ZWdhLWVtYmVkIC52ZWdhLWFjdGlvbnM6OmJlZm9yZSwgLnZlZ2EtZW1iZWQgLnZlZ2EtYWN0aW9uczo6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi52ZWdhLWVtYmVkIC52ZWdhLWFjdGlvbnM6OmJlZm9yZSB7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IDE0cHg7XFxuICB0b3A6IC0xNnB4O1xcbiAgYm9yZGVyOiA4cHggc29saWQgcmdiYSgwLCAwLCAwLCAwKTtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNkOWQ5ZDk7XFxufVxcbi52ZWdhLWVtYmVkIC52ZWdhLWFjdGlvbnM6OmFmdGVyIHtcXG4gIGxlZnQ6IGF1dG87XFxuICByaWdodDogMTVweDtcXG4gIHRvcDogLTE0cHg7XFxuICBib3JkZXI6IDdweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDApO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2ZmZjtcXG59XFxuLnZlZ2EtZW1iZWQgLmNoYXJ0LXdyYXBwZXIuZml0LXgge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi52ZWdhLWVtYmVkIC5jaGFydC13cmFwcGVyLmZpdC15IHtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnZlZ2EtZW1iZWQtd3JhcHBlciB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIHBhZGRpbmctcmlnaHQ6IDE0cHg7XFxufVxcblxcbkBrZXlmcmFtZXMgc2NhbGUtaW4ge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC42KTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG59XFxuXCI7XG5cbi8vIHBvbHlmaWxsIGZvciBJRVxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUsZnVuYy1uYW1lc1xuICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoLCBwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZURlZXAoZGVzdCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGZvciAodmFyIF9pID0gMCwgX3NyYyA9IHNyYzsgX2kgPCBfc3JjLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBzID0gX3NyY1tfaV07XG4gICAgZGVlcE1lcmdlXyhkZXN0LCBzKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZV8oZGVzdCwgc3JjKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7IF9pMiA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gX09iamVjdCRrZXlzW19pMl07XG4gICAgd3JpdGVDb25maWcoZGVzdCwgcHJvcGVydHksIHNyY1twcm9wZXJ0eV0sIHRydWUpO1xuICB9XG59XG5cbnZhciBuYW1lID0gXCJ2ZWdhLWVtYmVkXCI7XG52YXIgdmVyc2lvbiQxID0gXCI2LjIxLjNcIjtcbnZhciBkZXNjcmlwdGlvbiA9IFwiUHVibGlzaCBWZWdhIHZpc3VhbGl6YXRpb25zIGFzIGVtYmVkZGVkIHdlYiBjb21wb25lbnRzLlwiO1xudmFyIGtleXdvcmRzID0gW1widmVnYVwiLCBcImRhdGFcIiwgXCJ2aXN1YWxpemF0aW9uXCIsIFwiY29tcG9uZW50XCIsIFwiZW1iZWRcIl07XG52YXIgcmVwb3NpdG9yeSA9IHtcbiAgdHlwZTogXCJnaXRcIixcbiAgdXJsOiBcImh0dHA6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1lbWJlZC5naXRcIlxufTtcbnZhciBhdXRob3IgPSB7XG4gIG5hbWU6IFwiVVcgSW50ZXJhY3RpdmUgRGF0YSBMYWJcIixcbiAgdXJsOiBcImh0dHA6Ly9pZGwuY3Mud2FzaGluZ3Rvbi5lZHVcIlxufTtcbnZhciBjb250cmlidXRvcnMgPSBbe1xuICBuYW1lOiBcIkRvbWluaWsgTW9yaXR6XCIsXG4gIHVybDogXCJodHRwczovL3d3dy5kb21vcml0ei5kZVwiXG59XTtcbnZhciBidWdzID0ge1xuICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1lbWJlZC9pc3N1ZXNcIlxufTtcbnZhciBob21lcGFnZSA9IFwiaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1lbWJlZCNyZWFkbWVcIjtcbnZhciBsaWNlbnNlID0gXCJCU0QtMy1DbGF1c2VcIjtcbnZhciBtYWluID0gXCJidWlsZC92ZWdhLWVtYmVkLmpzXCI7XG52YXIgbW9kdWxlID0gXCJidWlsZC92ZWdhLWVtYmVkLm1vZHVsZS5qc1wiO1xudmFyIHVucGtnID0gXCJidWlsZC92ZWdhLWVtYmVkLm1pbi5qc1wiO1xudmFyIGpzZGVsaXZyID0gXCJidWlsZC92ZWdhLWVtYmVkLm1pbi5qc1wiO1xudmFyIHR5cGVzID0gXCJidWlsZC92ZWdhLWVtYmVkLm1vZHVsZS5kLnRzXCI7XG52YXIgZmlsZXMgPSBbXCJzcmNcIiwgXCJidWlsZFwiLCBcImJ1aWxkLWVzNVwiLCBcInBhdGNoZXNcIl07XG52YXIgZGV2RGVwZW5kZW5jaWVzID0ge1xuICBcIkBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXJ1bnRpbWVcIjogXCJeNy4xOS42XCIsXG4gIFwiQHJlbGVhc2UtaXQvY29udmVudGlvbmFsLWNoYW5nZWxvZ1wiOiBcIl41LjEuMVwiLFxuICBcIkByb2xsdXAvcGx1Z2luLWNvbW1vbmpzXCI6IFwiMjQuMC4xXCIsXG4gIFwiQHJvbGx1cC9wbHVnaW4tanNvblwiOiBcIl42LjAuMFwiLFxuICBcIkByb2xsdXAvcGx1Z2luLW5vZGUtcmVzb2x2ZVwiOiBcIl4xNS4wLjFcIixcbiAgXCJAcm9sbHVwL3BsdWdpbi10ZXJzZXJcIjogXCJeMC40LjBcIixcbiAgXCJAdHlwZXMvc2VtdmVyXCI6IFwiXjcuMy4xM1wiLFxuICBcImJyb3dzZXItc3luY1wiOiBcIl4yLjI3LjExXCIsXG4gIGNvbmN1cnJlbnRseTogXCJeNy42LjBcIixcbiAgXCJkZWwtY2xpXCI6IFwiXjUuMC4wXCIsXG4gIFwiamVzdC1jYW52YXMtbW9ja1wiOiBcIl4yLjQuMFwiLFxuICBcImplc3QtZW52aXJvbm1lbnQtanNkb21cIjogXCJeMjkuNC4zXCIsXG4gIFwicGF0Y2gtcGFja2FnZVwiOiBcIl42LjUuMVwiLFxuICBcInBvc3RpbnN0YWxsLXBvc3RpbnN0YWxsXCI6IFwiXjIuMS4wXCIsXG4gIFwicmVsZWFzZS1pdFwiOiBcIl4xNS42LjBcIixcbiAgXCJyb2xsdXAtcGx1Z2luLWJ1bmRsZS1zaXplXCI6IFwiXjEuMC4zXCIsXG4gIFwicm9sbHVwLXBsdWdpbi10c1wiOiBcIl4zLjIuMFwiLFxuICByb2xsdXA6IFwiMy4xNS4wXCIsXG4gIHNhc3M6IFwiXjEuNTguMVwiLFxuICB0eXBlc2NyaXB0OiBcIl40LjkuNVwiLFxuICBcInZlZ2EtbGl0ZS1kZXYtY29uZmlnXCI6IFwiXjAuMjEuMFwiLFxuICBcInZlZ2EtbGl0ZVwiOiBcIl41LjIuMFwiLFxuICB2ZWdhOiBcIl41LjIyLjFcIlxufTtcbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuICB2ZWdhOiBcIl41LjIxLjBcIixcbiAgXCJ2ZWdhLWxpdGVcIjogXCIqXCJcbn07XG52YXIgZGVwZW5kZW5jaWVzID0ge1xuICBcImZhc3QtanNvbi1wYXRjaFwiOiBcIl4zLjEuMVwiLFxuICBcImpzb24tc3RyaW5naWZ5LXByZXR0eS1jb21wYWN0XCI6IFwiXjMuMC4wXCIsXG4gIHNlbXZlcjogXCJeNy4zLjhcIixcbiAgdHNsaWI6IFwiXjIuNS4wXCIsXG4gIFwidmVnYS1pbnRlcnByZXRlclwiOiBcIl4xLjAuNFwiLFxuICBcInZlZ2Etc2NoZW1hLXVybC1wYXJzZXJcIjogXCJeMi4yLjBcIixcbiAgXCJ2ZWdhLXRoZW1lc1wiOiBcIl4yLjEyLjFcIixcbiAgXCJ2ZWdhLXRvb2x0aXBcIjogXCJeMC4zMC4xXCJcbn07XG52YXIgYnVuZGxlZERlcGVuZGVuY2llcyA9IFtcInlhbGxpc3RcIl07XG52YXIgc2NyaXB0cyA9IHtcbiAgcHJlYnVpbGQ6IFwieWFybiBjbGVhbiAmJiB5YXJuIGJ1aWxkOnN0eWxlXCIsXG4gIGJ1aWxkOiBcInJvbGx1cCAtY1wiLFxuICBcImJ1aWxkOnN0eWxlXCI6IFwiLi9idWlsZC1zdHlsZS5zaFwiLFxuICBjbGVhbjogXCJkZWwtY2xpIGJ1aWxkIGJ1aWxkLWVzNSBzcmMvc3R5bGUudHNcIixcbiAgcHJlcHVibGlzaE9ubHk6IFwieWFybiBjbGVhbiAmJiB5YXJuIGJ1aWxkXCIsXG4gIHByZXZlcnNpb246IFwieWFybiBsaW50ICYmIHlhcm4gdGVzdFwiLFxuICBzZXJ2ZTogXCJicm93c2VyLXN5bmMgc3RhcnQgLS1kaXJlY3RvcnkgLXMgLWYgYnVpbGQgKi5odG1sXCIsXG4gIHN0YXJ0OiBcInlhcm4gYnVpbGQgJiYgY29uY3VycmVudGx5IC0ta2lsbC1vdGhlcnMgLW4gU2VydmVyLFJvbGx1cCAneWFybiBzZXJ2ZScgJ3JvbGx1cCAtYyAtdydcIixcbiAgcHJldGVzdDogXCJ5YXJuIGJ1aWxkOnN0eWxlXCIsXG4gIHRlc3Q6IFwiYmVlbW8gamVzdCAtLXN0ZGlvIHN0cmVhbVwiLFxuICBcInRlc3Q6aW5zcGVjdFwiOiBcIm5vZGUgLS1pbnNwZWN0LWJyayAuL25vZGVfbW9kdWxlcy8uYmluL2plc3QgLS1ydW5JbkJhbmRcIixcbiAgcHJlcGFyZTogXCJiZWVtbyBjcmVhdGUtY29uZmlnICYmIG5weCBwYXRjaC1wYWNrYWdlXCIsXG4gIHByZXR0aWVyYmFzZTogXCJiZWVtbyBwcmV0dGllciAnKi57Y3NzLHNjc3MsaHRtbH0nXCIsXG4gIGVzbGludGJhc2U6IFwiYmVlbW8gZXNsaW50IC5cIixcbiAgZm9ybWF0OiBcInlhcm4gZXNsaW50YmFzZSAtLWZpeCAmJiB5YXJuIHByZXR0aWVyYmFzZSAtLXdyaXRlXCIsXG4gIGxpbnQ6IFwieWFybiBlc2xpbnRiYXNlICYmIHlhcm4gcHJldHRpZXJiYXNlIC0tY2hlY2tcIixcbiAgcmVsZWFzZTogXCJyZWxlYXNlLWl0XCJcbn07XG52YXIgcGtnID0ge1xuICBuYW1lOiBuYW1lLFxuICB2ZXJzaW9uOiB2ZXJzaW9uJDEsXG4gIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAga2V5d29yZHM6IGtleXdvcmRzLFxuICByZXBvc2l0b3J5OiByZXBvc2l0b3J5LFxuICBhdXRob3I6IGF1dGhvcixcbiAgY29udHJpYnV0b3JzOiBjb250cmlidXRvcnMsXG4gIGJ1Z3M6IGJ1Z3MsXG4gIGhvbWVwYWdlOiBob21lcGFnZSxcbiAgbGljZW5zZTogbGljZW5zZSxcbiAgbWFpbjogbWFpbixcbiAgbW9kdWxlOiBtb2R1bGUsXG4gIHVucGtnOiB1bnBrZyxcbiAganNkZWxpdnI6IGpzZGVsaXZyLFxuICB0eXBlczogdHlwZXMsXG4gIGZpbGVzOiBmaWxlcyxcbiAgZGV2RGVwZW5kZW5jaWVzOiBkZXZEZXBlbmRlbmNpZXMsXG4gIHBlZXJEZXBlbmRlbmNpZXM6IHBlZXJEZXBlbmRlbmNpZXMsXG4gIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuICBidW5kbGVkRGVwZW5kZW5jaWVzOiBidW5kbGVkRGVwZW5kZW5jaWVzLFxuICBzY3JpcHRzOiBzY3JpcHRzXG59O1xuXG52YXIgX3ckdmw7XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgdmVyc2lvbiA9IHBrZy52ZXJzaW9uO1xudmFyIHZlZ2EgPSB2ZWdhSW1wb3J0O1xudmFyIF92ZWdhTGl0ZSA9IHZlZ2FMaXRlSW1wb3J0O1xudmFyIHcgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbmlmIChfdmVnYUxpdGUgPT09IHVuZGVmaW5lZCAmJiB3ICE9PSBudWxsICYmIHcgIT09IHZvaWQgMCAmJiAoX3ckdmwgPSB3LnZsKSAhPT0gbnVsbCAmJiBfdyR2bCAhPT0gdm9pZCAwICYmIF93JHZsLmNvbXBpbGUpIHtcbiAgX3ZlZ2FMaXRlID0gdy52bDtcbn1cbnZhciBERUZBVUxUX0FDVElPTlMgPSB7XG4gIGV4cG9ydDoge1xuICAgIHN2ZzogdHJ1ZSxcbiAgICBwbmc6IHRydWVcbiAgfSxcbiAgc291cmNlOiB0cnVlLFxuICBjb21waWxlZDogdHJ1ZSxcbiAgZWRpdG9yOiB0cnVlXG59O1xudmFyIEkxOE4gPSB7XG4gIENMSUNLX1RPX1ZJRVdfQUNUSU9OUzogJ0NsaWNrIHRvIHZpZXcgYWN0aW9ucycsXG4gIENPTVBJTEVEX0FDVElPTjogJ1ZpZXcgQ29tcGlsZWQgVmVnYScsXG4gIEVESVRPUl9BQ1RJT046ICdPcGVuIGluIFZlZ2EgRWRpdG9yJyxcbiAgUE5HX0FDVElPTjogJ1NhdmUgYXMgUE5HJyxcbiAgU09VUkNFX0FDVElPTjogJ1ZpZXcgU291cmNlJyxcbiAgU1ZHX0FDVElPTjogJ1NhdmUgYXMgU1ZHJ1xufTtcbnZhciBOQU1FUyA9IHtcbiAgdmVnYTogJ1ZlZ2EnLFxuICAndmVnYS1saXRlJzogJ1ZlZ2EtTGl0ZSdcbn07XG52YXIgVkVSU0lPTiA9IHtcbiAgdmVnYTogdmVnYS52ZXJzaW9uLFxuICAndmVnYS1saXRlJzogX3ZlZ2FMaXRlID8gX3ZlZ2FMaXRlLnZlcnNpb24gOiAnbm90IGF2YWlsYWJsZSdcbn07XG52YXIgUFJFUFJPQ0VTU09SID0ge1xuICB2ZWdhOiB2Z1NwZWMgPT4gdmdTcGVjLFxuICAndmVnYS1saXRlJzogKHZsU3BlYywgY29uZmlnKSA9PiBfdmVnYUxpdGUuY29tcGlsZSh2bFNwZWMsIHtcbiAgICBjb25maWc6IGNvbmZpZ1xuICB9KS5zcGVjXG59O1xudmFyIFNWR19DSVJDTEVTID0gXCJcXG48c3ZnIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCIgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBzdHJva2U9XFxcIm5vbmVcXFwiIHN0cm9rZS13aWR0aD1cXFwiMVxcXCIgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIiBzdHJva2UtbGluZWpvaW49XFxcInJvdW5kXFxcIj5cXG4gIDxjaXJjbGUgcj1cXFwiMlxcXCIgY3k9XFxcIjhcXFwiIGN4PVxcXCIyXFxcIj48L2NpcmNsZT5cXG4gIDxjaXJjbGUgcj1cXFwiMlxcXCIgY3k9XFxcIjhcXFwiIGN4PVxcXCI4XFxcIj48L2NpcmNsZT5cXG4gIDxjaXJjbGUgcj1cXFwiMlxcXCIgY3k9XFxcIjhcXFwiIGN4PVxcXCIxNFxcXCI+PC9jaXJjbGU+XFxuPC9zdmc+XCI7XG52YXIgQ0hBUlRfV1JBUFBFUl9DTEFTUyA9ICdjaGFydC13cmFwcGVyJztcbmZ1bmN0aW9uIGlzVG9vbHRpcEhhbmRsZXIoaCkge1xuICByZXR1cm4gdHlwZW9mIGggPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiB2aWV3U291cmNlKHNvdXJjZSwgc291cmNlSGVhZGVyLCBzb3VyY2VGb290ZXIsIG1vZGUpIHtcbiAgdmFyIGhlYWRlciA9IFwiPGh0bWw+PGhlYWQ+XCIuY29uY2F0KHNvdXJjZUhlYWRlciwgXCI8L2hlYWQ+PGJvZHk+PHByZT48Y29kZSBjbGFzcz1cXFwianNvblxcXCI+XCIpO1xuICB2YXIgZm9vdGVyID0gXCI8L2NvZGU+PC9wcmU+XCIuY29uY2F0KHNvdXJjZUZvb3RlciwgXCI8L2JvZHk+PC9odG1sPlwiKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKCcnKTtcbiAgd2luLmRvY3VtZW50LndyaXRlKGhlYWRlciArIHNvdXJjZSArIGZvb3Rlcik7XG4gIHdpbi5kb2N1bWVudC50aXRsZSA9IFwiXCIuY29uY2F0KE5BTUVTW21vZGVdLCBcIiBKU09OIFNvdXJjZVwiKTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZ3Vlc3MgdGhlIHR5cGUgb2Ygc3BlYy5cbiAqXG4gKiBAcGFyYW0gc3BlYyBWZWdhIG9yIFZlZ2EtTGl0ZSBzcGVjLlxuICovXG5mdW5jdGlvbiBndWVzc01vZGUoc3BlYywgcHJvdmlkZWRNb2RlKSB7XG4gIC8vIERlY2lkZSBtb2RlXG4gIGlmIChzcGVjLiRzY2hlbWEpIHtcbiAgICB2YXIgcGFyc2VkID0gc2NoZW1hUGFyc2VyKHNwZWMuJHNjaGVtYSk7XG4gICAgaWYgKHByb3ZpZGVkTW9kZSAmJiBwcm92aWRlZE1vZGUgIT09IHBhcnNlZC5saWJyYXJ5KSB7XG4gICAgICB2YXIgX05BTUVTJHByb3ZpZGVkTW9kZTtcbiAgICAgIGNvbnNvbGUud2FybihcIlRoZSBnaXZlbiB2aXN1YWxpemF0aW9uIHNwZWMgaXMgd3JpdHRlbiBpbiBcIi5jb25jYXQoTkFNRVNbcGFyc2VkLmxpYnJhcnldLCBcIiwgYnV0IG1vZGUgYXJndW1lbnQgc2V0cyBcIikuY29uY2F0KChfTkFNRVMkcHJvdmlkZWRNb2RlID0gTkFNRVNbcHJvdmlkZWRNb2RlXSkgIT09IG51bGwgJiYgX05BTUVTJHByb3ZpZGVkTW9kZSAhPT0gdm9pZCAwID8gX05BTUVTJHByb3ZpZGVkTW9kZSA6IHByb3ZpZGVkTW9kZSwgXCIuXCIpKTtcbiAgICB9XG4gICAgdmFyIG1vZGUgPSBwYXJzZWQubGlicmFyeTtcbiAgICBpZiAoIXNhdGlzZmllc18xKFZFUlNJT05bbW9kZV0sIFwiXlwiLmNvbmNhdChwYXJzZWQudmVyc2lvbi5zbGljZSgxKSkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUaGUgaW5wdXQgc3BlYyB1c2VzIFwiLmNvbmNhdChOQU1FU1ttb2RlXSwgXCIgXCIpLmNvbmNhdChwYXJzZWQudmVyc2lvbiwgXCIsIGJ1dCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFwiKS5jb25jYXQoTkFNRVNbbW9kZV0sIFwiIGlzIHZcIikuY29uY2F0KFZFUlNJT05bbW9kZV0sIFwiLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGd1ZXNzIGZyb20gdGhlIHByb3ZpZGVkIHNwZWNcbiAgaWYgKCdtYXJrJyBpbiBzcGVjIHx8ICdlbmNvZGluZycgaW4gc3BlYyB8fCAnbGF5ZXInIGluIHNwZWMgfHwgJ2hjb25jYXQnIGluIHNwZWMgfHwgJ3Zjb25jYXQnIGluIHNwZWMgfHwgJ2ZhY2V0JyBpbiBzcGVjIHx8ICdyZXBlYXQnIGluIHNwZWMpIHtcbiAgICByZXR1cm4gJ3ZlZ2EtbGl0ZSc7XG4gIH1cbiAgaWYgKCdtYXJrcycgaW4gc3BlYyB8fCAnc2lnbmFscycgaW4gc3BlYyB8fCAnc2NhbGVzJyBpbiBzcGVjIHx8ICdheGVzJyBpbiBzcGVjKSB7XG4gICAgcmV0dXJuICd2ZWdhJztcbiAgfVxuICByZXR1cm4gcHJvdmlkZWRNb2RlICE9PSBudWxsICYmIHByb3ZpZGVkTW9kZSAhPT0gdm9pZCAwID8gcHJvdmlkZWRNb2RlIDogJ3ZlZ2EnO1xufVxuZnVuY3Rpb24gaXNMb2FkZXIobykge1xuICByZXR1cm4gISEobyAmJiAnbG9hZCcgaW4gbyk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2FkZXIob3B0cykge1xuICByZXR1cm4gaXNMb2FkZXIob3B0cykgPyBvcHRzIDogdmVnYS5sb2FkZXIob3B0cyk7XG59XG5mdW5jdGlvbiBlbWJlZE9wdGlvbnNGcm9tVXNlcm1ldGEocGFyc2VkU3BlYykge1xuICB2YXIgX2VtYmVkT3B0aW9ucywgX3BhcnNlZFNwZWMkdXNlcm1ldGE7XG4gIHZhciBvcHRzID0gKF9lbWJlZE9wdGlvbnMgPSAoX3BhcnNlZFNwZWMkdXNlcm1ldGEgPSBwYXJzZWRTcGVjLnVzZXJtZXRhKSA9PT0gbnVsbCB8fCBfcGFyc2VkU3BlYyR1c2VybWV0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhcnNlZFNwZWMkdXNlcm1ldGEuZW1iZWRPcHRpb25zKSAhPT0gbnVsbCAmJiBfZW1iZWRPcHRpb25zICE9PSB2b2lkIDAgPyBfZW1iZWRPcHRpb25zIDoge307XG4gIGlmIChpc1N0cmluZyhvcHRzLmRlZmF1bHRTdHlsZSkpIHtcbiAgICAvLyB3ZSBkb24ndCBhbGxvdyBzdHlsZXMgc2V0IHZpYSB1c2VybWV0YSBzaW5jZSBpdCB3b3VsZCBhbGxvdyBpbmplY3Rpb24gb2YgbG9naWMgKHdlIHNldCB0aGUgc3R5bGUgdmlhIGlubmVySFRNTClcbiAgICBvcHRzLmRlZmF1bHRTdHlsZSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuXG4vKipcbiAqIEVtYmVkIGEgVmVnYSB2aXN1YWxpemF0aW9uIGNvbXBvbmVudCBpbiBhIHdlYiBwYWdlLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSBlbCAgICAgICAgRE9NIGVsZW1lbnQgaW4gd2hpY2ggdG8gcGxhY2UgY29tcG9uZW50IChET00gbm9kZSBvciBDU1Mgc2VsZWN0b3IpLlxuICogQHBhcmFtIHNwZWMgICAgICBTdHJpbmcgOiBBIFVSTCBzdHJpbmcgZnJvbSB3aGljaCB0byBsb2FkIHRoZSBWZWdhIHNwZWNpZmljYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgIE9iamVjdCA6IFRoZSBWZWdhL1ZlZ2EtTGl0ZSBzcGVjaWZpY2F0aW9uIGFzIGEgcGFyc2VkIEpTT04gb2JqZWN0LlxuICogQHBhcmFtIG9wdHMgICAgICAgQSBKYXZhU2NyaXB0IG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIGVtYmVkZGluZy5cbiAqL1xuZnVuY3Rpb24gZW1iZWQoX3gsIF94Mikge1xuICByZXR1cm4gX2VtYmVkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2VtYmVkMigpIHtcbiAgX2VtYmVkMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZWwsIHNwZWMpIHtcbiAgICB2YXIgX3BhcnNlZE9wdHMkY29uZmlnLCBfdXNlcm1ldGFPcHRzJGNvbmZpZztcbiAgICB2YXIgb3B0cyxcbiAgICAgIHBhcnNlZFNwZWMsXG4gICAgICBsb2FkZXIsXG4gICAgICBsb2FkZWRFbWJlZE9wdGlvbnMsXG4gICAgICB1c2VybWV0YUxvYWRlcixcbiAgICAgIF9vcHRzJGxvYWRlcixcbiAgICAgIHVzZXJtZXRhT3B0cyxcbiAgICAgIHBhcnNlZE9wdHMsXG4gICAgICBtZXJnZWRPcHRzLFxuICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG9wdHMgPSBfYXJncy5sZW5ndGggPiAyICYmIF9hcmdzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJnc1syXSA6IHt9O1xuICAgICAgICAgIGlmICghaXNTdHJpbmcoc3BlYykpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkZXIgPSBjcmVhdGVMb2FkZXIob3B0cy5sb2FkZXIpO1xuICAgICAgICAgIF9jb250ZXh0LnQwID0gSlNPTjtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQoc3BlYyk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgcGFyc2VkU3BlYyA9IF9jb250ZXh0LnQwLnBhcnNlLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxKTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcGFyc2VkU3BlYyA9IHNwZWM7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgbG9hZGVkRW1iZWRPcHRpb25zID0gZW1iZWRPcHRpb25zRnJvbVVzZXJtZXRhKHBhcnNlZFNwZWMpO1xuICAgICAgICAgIHVzZXJtZXRhTG9hZGVyID0gbG9hZGVkRW1iZWRPcHRpb25zLmxvYWRlcjsgLy8gZWl0aGVyIGNyZWF0ZSB0aGUgbG9hZGVyIGZvciB0aGUgZmlyc3QgdGltZSBvciBjcmVhdGUgYSBuZXcgbG9hZGVyIGlmIHRoZSBzcGVjIGhhcyBuZXcgbG9hZGVyIG9wdGlvbnNcbiAgICAgICAgICBpZiAoIWxvYWRlciB8fCB1c2VybWV0YUxvYWRlcikge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlTG9hZGVyKChfb3B0cyRsb2FkZXIgPSBvcHRzLmxvYWRlcikgIT09IG51bGwgJiYgX29wdHMkbG9hZGVyICE9PSB2b2lkIDAgPyBfb3B0cyRsb2FkZXIgOiB1c2VybWV0YUxvYWRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICByZXR1cm4gbG9hZE9wdHMobG9hZGVkRW1iZWRPcHRpb25zLCBsb2FkZXIpO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHVzZXJtZXRhT3B0cyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgIHJldHVybiBsb2FkT3B0cyhvcHRzLCBsb2FkZXIpO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBhcnNlZE9wdHMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgIG1lcmdlZE9wdHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1lcmdlRGVlcChwYXJzZWRPcHRzLCB1c2VybWV0YU9wdHMpKSwge30sIHtcbiAgICAgICAgICAgIGNvbmZpZzogbWVyZ2VDb25maWcoKF9wYXJzZWRPcHRzJGNvbmZpZyA9IHBhcnNlZE9wdHMuY29uZmlnKSAhPT0gbnVsbCAmJiBfcGFyc2VkT3B0cyRjb25maWcgIT09IHZvaWQgMCA/IF9wYXJzZWRPcHRzJGNvbmZpZyA6IHt9LCAoX3VzZXJtZXRhT3B0cyRjb25maWcgPSB1c2VybWV0YU9wdHMuY29uZmlnKSAhPT0gbnVsbCAmJiBfdXNlcm1ldGFPcHRzJGNvbmZpZyAhPT0gdm9pZCAwID8gX3VzZXJtZXRhT3B0cyRjb25maWcgOiB7fSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgcmV0dXJuIF9lbWJlZChlbCwgcGFyc2VkU3BlYywgbWVyZ2VkT3B0cywgbG9hZGVyKTtcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2VtYmVkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gbG9hZE9wdHMoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9sb2FkT3B0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2xvYWRPcHRzKCkge1xuICBfbG9hZE9wdHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihvcHQsIGxvYWRlcikge1xuICAgIHZhciBfb3B0JGNvbmZpZztcbiAgICB2YXIgY29uZmlnLCBwYXRjaDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlmICghaXNTdHJpbmcob3B0LmNvbmZpZykpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY29udGV4dDIudDEgPSBKU09OO1xuICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQob3B0LmNvbmZpZyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBfY29udGV4dDIudDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDIudDEucGFyc2UuY2FsbChfY29udGV4dDIudDEsIF9jb250ZXh0Mi50Mik7XG4gICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgX2NvbnRleHQyLnQwID0gKF9vcHQkY29uZmlnID0gb3B0LmNvbmZpZykgIT09IG51bGwgJiYgX29wdCRjb25maWcgIT09IHZvaWQgMCA/IF9vcHQkY29uZmlnIDoge307XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjb25maWcgPSBfY29udGV4dDIudDA7XG4gICAgICAgICAgaWYgKCFpc1N0cmluZyhvcHQucGF0Y2gpKSB7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jb250ZXh0Mi50NCA9IEpTT047XG4gICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQob3B0LnBhdGNoKTtcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBfY29udGV4dDIudDUgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICBfY29udGV4dDIudDMgPSBfY29udGV4dDIudDQucGFyc2UuY2FsbChfY29udGV4dDIudDQsIF9jb250ZXh0Mi50NSk7XG4gICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBfY29udGV4dDIudDMgPSBvcHQucGF0Y2g7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcGF0Y2ggPSBfY29udGV4dDIudDM7XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdCksIHBhdGNoID8ge1xuICAgICAgICAgICAgcGF0Y2hcbiAgICAgICAgICB9IDoge30pLCBjb25maWcgPyB7XG4gICAgICAgICAgICBjb25maWdcbiAgICAgICAgICB9IDoge30pKTtcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX2xvYWRPcHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBnZXRSb290KGVsKSB7XG4gIHZhciBfZG9jdW1lbnQkaGVhZDtcbiAgdmFyIHBvc3NpYmxlUm9vdCA9IGVsLmdldFJvb3ROb2RlID8gZWwuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xuICByZXR1cm4gcG9zc2libGVSb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHtcbiAgICByb290OiBwb3NzaWJsZVJvb3QsXG4gICAgcm9vdENvbnRhaW5lcjogcG9zc2libGVSb290XG4gIH0gOiB7XG4gICAgcm9vdDogZG9jdW1lbnQsXG4gICAgcm9vdENvbnRhaW5lcjogKF9kb2N1bWVudCRoZWFkID0gZG9jdW1lbnQuaGVhZCkgIT09IG51bGwgJiYgX2RvY3VtZW50JGhlYWQgIT09IHZvaWQgMCA/IF9kb2N1bWVudCRoZWFkIDogZG9jdW1lbnQuYm9keVxuICB9O1xufVxuZnVuY3Rpb24gX2VtYmVkKF94NSwgX3g2KSB7XG4gIHJldHVybiBfZW1iZWQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZW1iZWQzKCkge1xuICBfZW1iZWQzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoZWwsIHNwZWMpIHtcbiAgICB2YXIgX29wdHMkY29uZmlnLCBfb3B0cyRhY3Rpb25zLCBfb3B0cyRyZW5kZXJlciwgX29wdHMkbG9nTGV2ZWwsIF9vcHRzJGRvd25sb2FkRmlsZU5hbSwgX3JlZiwgX2V4cHJlc3Npb25JbnRlcnByZXRlO1xuICAgIHZhciBvcHRzLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29uZmlnLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGkxOG4sXG4gICAgICByZW5kZXJlcixcbiAgICAgIGxvZ0xldmVsLFxuICAgICAgZG93bmxvYWRGaWxlTmFtZSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBJRCxcbiAgICAgIF9nZXRSb290LFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RDb250YWluZXIsXG4gICAgICBzdHlsZSxcbiAgICAgIG1vZGUsXG4gICAgICB2Z1NwZWMsXG4gICAgICBwYXJzZWQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBjaGFydFdyYXBwZXIsXG4gICAgICBwYXRjaCxcbiAgICAgIG5hbWUsXG4gICAgICBleHByZXNzaW9uRnVuY3Rpb24sXG4gICAgICBhc3QsXG4gICAgICBydW50aW1lLFxuICAgICAgdmlldyxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBob3ZlcixcbiAgICAgIF9yZWYyLFxuICAgICAgaG92ZXJTZXQsXG4gICAgICB1cGRhdGVTZXQsXG4gICAgICBkb2N1bWVudENsaWNrSGFuZGxlcixcbiAgICAgIHdyYXBwZXIsXG4gICAgICBkZXRhaWxzLFxuICAgICAgc3VtbWFyeSxcbiAgICAgIGN0cmwsXG4gICAgICBfaXRlcmF0b3IsXG4gICAgICBfc3RlcCxcbiAgICAgIF9sb29wLFxuICAgICAgdmlld1NvdXJjZUxpbmssXG4gICAgICBjb21waWxlTGluayxcbiAgICAgIF9vcHRzJGVkaXRvclVybCxcbiAgICAgIGVkaXRvclVybCxcbiAgICAgIGVkaXRvckxpbmssXG4gICAgICBmaW5hbGl6ZSxcbiAgICAgIF9hcmdzNSA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGZpbmFsaXplID0gZnVuY3Rpb24gX2ZpbmFsaXplKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50Q2xpY2tIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5maW5hbGl6ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgb3B0cyA9IF9hcmdzNS5sZW5ndGggPiAyICYmIF9hcmdzNVsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M1WzJdIDoge307XG4gICAgICAgICAgbG9hZGVyID0gX2FyZ3M1Lmxlbmd0aCA+IDMgPyBfYXJnczVbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uZmlnID0gb3B0cy50aGVtZSA/IG1lcmdlQ29uZmlnKHRoZW1lc1tvcHRzLnRoZW1lXSwgKF9vcHRzJGNvbmZpZyA9IG9wdHMuY29uZmlnKSAhPT0gbnVsbCAmJiBfb3B0cyRjb25maWcgIT09IHZvaWQgMCA/IF9vcHRzJGNvbmZpZyA6IHt9KSA6IG9wdHMuY29uZmlnO1xuICAgICAgICAgIGFjdGlvbnMgPSBpc0Jvb2xlYW4ob3B0cy5hY3Rpb25zKSA/IG9wdHMuYWN0aW9ucyA6IG1lcmdlRGVlcCh7fSwgREVGQVVMVF9BQ1RJT05TLCAoX29wdHMkYWN0aW9ucyA9IG9wdHMuYWN0aW9ucykgIT09IG51bGwgJiYgX29wdHMkYWN0aW9ucyAhPT0gdm9pZCAwID8gX29wdHMkYWN0aW9ucyA6IHt9KTtcbiAgICAgICAgICBpMThuID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBJMThOKSwgb3B0cy5pMThuKTtcbiAgICAgICAgICByZW5kZXJlciA9IChfb3B0cyRyZW5kZXJlciA9IG9wdHMucmVuZGVyZXIpICE9PSBudWxsICYmIF9vcHRzJHJlbmRlcmVyICE9PSB2b2lkIDAgPyBfb3B0cyRyZW5kZXJlciA6ICdjYW52YXMnO1xuICAgICAgICAgIGxvZ0xldmVsID0gKF9vcHRzJGxvZ0xldmVsID0gb3B0cy5sb2dMZXZlbCkgIT09IG51bGwgJiYgX29wdHMkbG9nTGV2ZWwgIT09IHZvaWQgMCA/IF9vcHRzJGxvZ0xldmVsIDogdmVnYS5XYXJuO1xuICAgICAgICAgIGRvd25sb2FkRmlsZU5hbWUgPSAoX29wdHMkZG93bmxvYWRGaWxlTmFtID0gb3B0cy5kb3dubG9hZEZpbGVOYW1lKSAhPT0gbnVsbCAmJiBfb3B0cyRkb3dubG9hZEZpbGVOYW0gIT09IHZvaWQgMCA/IF9vcHRzJGRvd25sb2FkRmlsZU5hbSA6ICd2aXN1YWxpemF0aW9uJztcbiAgICAgICAgICBlbGVtZW50ID0gdHlwZW9mIGVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpIDogZWw7XG4gICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGVsLCBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKG9wdHMuZGVmYXVsdFN0eWxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgSUQgPSAndmVnYS1lbWJlZC1zdHlsZSc7XG4gICAgICAgICAgICBfZ2V0Um9vdCA9IGdldFJvb3QoZWxlbWVudCksIHJvb3QgPSBfZ2V0Um9vdC5yb290LCByb290Q29udGFpbmVyID0gX2dldFJvb3Qucm9vdENvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmICghcm9vdC5nZXRFbGVtZW50QnlJZChJRCkpIHtcbiAgICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICBzdHlsZS5pZCA9IElEO1xuICAgICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBvcHRzLmRlZmF1bHRTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuZGVmYXVsdFN0eWxlID09PSB0cnVlID8gKGVtYmVkU3R5bGUgKS50b1N0cmluZygpIDogb3B0cy5kZWZhdWx0U3R5bGU7XG4gICAgICAgICAgICAgIHJvb3RDb250YWluZXIuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlID0gZ3Vlc3NNb2RlKHNwZWMsIG9wdHMubW9kZSk7XG4gICAgICAgICAgdmdTcGVjID0gUFJFUFJPQ0VTU09SW21vZGVdKHNwZWMsIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKG1vZGUgPT09ICd2ZWdhLWxpdGUnKSB7XG4gICAgICAgICAgICBpZiAodmdTcGVjLiRzY2hlbWEpIHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gc2NoZW1hUGFyc2VyKHZnU3BlYy4kc2NoZW1hKTtcbiAgICAgICAgICAgICAgaWYgKCFzYXRpc2ZpZXNfMShWRVJTSU9OLnZlZ2EsIFwiXlwiLmNvbmNhdChwYXJzZWQudmVyc2lvbi5zbGljZSgxKSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGNvbXBpbGVkIHNwZWMgdXNlcyBWZWdhIFwiLmNvbmNhdChwYXJzZWQudmVyc2lvbiwgXCIsIGJ1dCBjdXJyZW50IHZlcnNpb24gaXMgdlwiKS5jb25jYXQoVkVSU0lPTi52ZWdhLCBcIi5cIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndmVnYS1lbWJlZCcpO1xuICAgICAgICAgIGlmIChhY3Rpb25zKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2hhcy1hY3Rpb25zJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7IC8vIGNsZWFyIGNvbnRhaW5lclxuICAgICAgICAgIGNvbnRhaW5lciA9IGVsZW1lbnQ7XG4gICAgICAgICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGNoYXJ0V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY2hhcnRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoQ0hBUlRfV1JBUFBFUl9DTEFTUyk7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoYXJ0V3JhcHBlcik7XG4gICAgICAgICAgICBjb250YWluZXIgPSBjaGFydFdyYXBwZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoID0gb3B0cy5wYXRjaDtcbiAgICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIHZnU3BlYyA9IHBhdGNoIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBwYXRjaCh2Z1NwZWMpIDogYXBwbHlQYXRjaCh2Z1NwZWMsIHBhdGNoLCB0cnVlLCBmYWxzZSkubmV3RG9jdW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IGxvY2FsZS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBnbG9iYWwgc2V0dGluZy5cbiAgICAgICAgICBpZiAob3B0cy5mb3JtYXRMb2NhbGUpIHtcbiAgICAgICAgICAgIHZlZ2EuZm9ybWF0TG9jYWxlKG9wdHMuZm9ybWF0TG9jYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMudGltZUZvcm1hdExvY2FsZSkge1xuICAgICAgICAgICAgdmVnYS50aW1lRm9ybWF0TG9jYWxlKG9wdHMudGltZUZvcm1hdExvY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IGN1c3RvbSBleHByZXNzaW9uIGZ1bmN0aW9uc1xuICAgICAgICAgIGlmIChvcHRzLmV4cHJlc3Npb25GdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRzLmV4cHJlc3Npb25GdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbkZ1bmN0aW9uID0gb3B0cy5leHByZXNzaW9uRnVuY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgICBpZiAoJ2ZuJyBpbiBleHByZXNzaW9uRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2ZWdhLmV4cHJlc3Npb25GdW5jdGlvbihuYW1lLCBleHByZXNzaW9uRnVuY3Rpb24uZm4sIGV4cHJlc3Npb25GdW5jdGlvblsndmlzaXRvciddKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uRnVuY3Rpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHZlZ2EuZXhwcmVzc2lvbkZ1bmN0aW9uKG5hbWUsIGV4cHJlc3Npb25GdW5jdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXN0ID0gb3B0cy5hc3Q7IC8vIERvIG5vdCBhcHBseSB0aGUgY29uZmlnIHRvIFZlZ2Egd2hlbiB3ZSBoYXZlIGFscmVhZHkgYXBwbGllZCBpdCB0byBWZWdhLUxpdGUuXG4gICAgICAgICAgLy8gVGhpcyBjYWxsIG1heSB0aHJvdyBhbiBFcnJvciBpZiBwYXJzaW5nIGZhaWxzLlxuICAgICAgICAgIHJ1bnRpbWUgPSB2ZWdhLnBhcnNlKHZnU3BlYywgbW9kZSA9PT0gJ3ZlZ2EtbGl0ZScgPyB7fSA6IGNvbmZpZywge1xuICAgICAgICAgICAgYXN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlldyA9IG5ldyAob3B0cy52aWV3Q2xhc3MgfHwgdmVnYS5WaWV3KShydW50aW1lLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIGxvYWRlcixcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgcmVuZGVyZXJcbiAgICAgICAgICB9LCBhc3QgPyB7XG4gICAgICAgICAgICBleHByOiAoX3JlZiA9IChfZXhwcmVzc2lvbkludGVycHJldGUgPSB2ZWdhLmV4cHJlc3Npb25JbnRlcnByZXRlcikgIT09IG51bGwgJiYgX2V4cHJlc3Npb25JbnRlcnByZXRlICE9PSB2b2lkIDAgPyBfZXhwcmVzc2lvbkludGVycHJldGUgOiBvcHRzLmV4cHIpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBleHByZXNzaW9uSW50ZXJwcmV0ZXJcbiAgICAgICAgICB9IDoge30pKTtcbiAgICAgICAgICB2aWV3LmFkZFNpZ25hbExpc3RlbmVyKCdhdXRvc2l6ZScsIChfLCBhdXRvc2l6ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBhdXRvc2l6ZS50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2ZpdC14Jykge1xuICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZml0LXgnKTtcbiAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2ZpdC15Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2ZpdC15Jykge1xuICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnZml0LXgnKTtcbiAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZpdC15Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2ZpdCcpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZpdC14JywgJ2ZpdC15Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnZml0LXgnLCAnZml0LXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3B0cy50b29sdGlwICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IGlzVG9vbHRpcEhhbmRsZXIob3B0cy50b29sdGlwKSA/IG9wdHMudG9vbHRpcCA6XG4gICAgICAgICAgICAvLyB1c2VyIHByb3ZpZGVkIGJvb2xlYW4gdHJ1ZSBvciB0b29sdGlwIG9wdGlvbnNcbiAgICAgICAgICAgIG5ldyBIYW5kbGVyKG9wdHMudG9vbHRpcCA9PT0gdHJ1ZSA/IHt9IDogb3B0cy50b29sdGlwKS5jYWxsO1xuICAgICAgICAgICAgdmlldy50b29sdGlwKGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBob3ZlciA9IG9wdHMuaG92ZXI7XG4gICAgICAgICAgaWYgKGhvdmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhvdmVyID0gbW9kZSA9PT0gJ3ZlZ2EnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaG92ZXIpIHtcbiAgICAgICAgICAgIF9yZWYyID0gdHlwZW9mIGhvdmVyID09PSAnYm9vbGVhbicgPyB7fSA6IGhvdmVyLCBob3ZlclNldCA9IF9yZWYyLmhvdmVyU2V0LCB1cGRhdGVTZXQgPSBfcmVmMi51cGRhdGVTZXQ7XG4gICAgICAgICAgICB2aWV3LmhvdmVyKGhvdmVyU2V0LCB1cGRhdGVTZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2aWV3LndpZHRoKG9wdHMud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmlldy5oZWlnaHQob3B0cy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMucGFkZGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZpZXcucGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM3O1xuICAgICAgICAgIHJldHVybiB2aWV3LmluaXRpYWxpemUoY29udGFpbmVyLCBvcHRzLmJpbmQpLnJ1bkFzeW5jKCk7XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgaWYgKCEoYWN0aW9ucyAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDYzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyYXBwZXIgPSBlbGVtZW50O1xuICAgICAgICAgIGlmIChvcHRzLmRlZmF1bHRTdHlsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRldGFpbHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkZXRhaWxzJyk7XG4gICAgICAgICAgICBkZXRhaWxzLnRpdGxlID0gaTE4bi5DTElDS19UT19WSUVXX0FDVElPTlM7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZChkZXRhaWxzKTtcbiAgICAgICAgICAgIHdyYXBwZXIgPSBkZXRhaWxzO1xuICAgICAgICAgICAgc3VtbWFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N1bW1hcnknKTtcbiAgICAgICAgICAgIHN1bW1hcnkuaW5uZXJIVE1MID0gU1ZHX0NJUkNMRVM7XG4gICAgICAgICAgICBkZXRhaWxzLmFwcGVuZChzdW1tYXJ5KTtcbiAgICAgICAgICAgIGRvY3VtZW50Q2xpY2tIYW5kbGVyID0gZXYgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWRldGFpbHMuY29udGFpbnMoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucmVtb3ZlQXR0cmlidXRlKCdvcGVuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3RybCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHdyYXBwZXIuYXBwZW5kKGN0cmwpO1xuICAgICAgICAgIGN0cmwuY2xhc3NMaXN0LmFkZCgndmVnYS1hY3Rpb25zJyk7XG5cbiAgICAgICAgICAvLyBhZGQgJ0V4cG9ydCcgYWN0aW9uXG4gICAgICAgICAgaWYgKCEoYWN0aW9ucyA9PT0gdHJ1ZSB8fCBhY3Rpb25zLmV4cG9ydCAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDYwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFsnc3ZnJywgJ3BuZyddKTtcbiAgICAgICAgICBfY29udGV4dDUucHJldiA9IDQ1O1xuICAgICAgICAgIF9sb29wID0gLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciBleHQsIGkxOG5FeHBvcnRBY3Rpb24sIGV4cG9ydExpbmssIHNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfbG9vcCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBleHQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25zID09PSB0cnVlIHx8IGFjdGlvbnMuZXhwb3J0ID09PSB0cnVlIHx8IGFjdGlvbnMuZXhwb3J0W2V4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaTE4bkV4cG9ydEFjdGlvbiA9IGkxOG5bXCJcIi5jb25jYXQoZXh0LnRvVXBwZXJDYXNlKCksIFwiX0FDVElPTlwiKV07XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9yID0gaXNPYmplY3Qob3B0cy5zY2FsZUZhY3RvcikgPyBvcHRzLnNjYWxlRmFjdG9yW2V4dF0gOiBvcHRzLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRMaW5rLnRleHQgPSBpMThuRXhwb3J0QWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRMaW5rLmhyZWYgPSAnIyc7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExpbmsuZG93bmxvYWQgPSBcIlwiLmNvbmNhdChkb3dubG9hZEZpbGVOYW1lLCBcIi5cIikuY29uY2F0KGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBsaW5rIG9uIG1vdXNlZG93biBzbyB0aGF0IGl0J3MgY29ycmVjdCB3aGVuIHRoZSBjbGljayBoYXBwZW5zXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExpbmsuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy50b0ltYWdlVVJMKGV4dCwgc2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hcHBlbmQoZXhwb3J0TGluayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfbG9vcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX2l0ZXJhdG9yLnMoKTtcbiAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmRlbGVnYXRlWWllbGQoX2xvb3AoKSwgXCJ0MFwiLCA1MCk7XG4gICAgICAgIGNhc2UgNTA6XG4gICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0ODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1MjpcbiAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU0OlxuICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gNTQ7XG4gICAgICAgICAgX2NvbnRleHQ1LnQxID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oNDUpO1xuICAgICAgICAgIF9pdGVyYXRvci5lKF9jb250ZXh0NS50MSk7XG4gICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA1NztcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIHJldHVybiBfY29udGV4dDUuZmluaXNoKDU3KTtcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAvLyBhZGQgJ1ZpZXcgU291cmNlJyBhY3Rpb25cbiAgICAgICAgICBpZiAoYWN0aW9ucyA9PT0gdHJ1ZSB8fCBhY3Rpb25zLnNvdXJjZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZpZXdTb3VyY2VMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgdmlld1NvdXJjZUxpbmsudGV4dCA9IGkxOG4uU09VUkNFX0FDVElPTjtcbiAgICAgICAgICAgIHZpZXdTb3VyY2VMaW5rLmhyZWYgPSAnIyc7XG4gICAgICAgICAgICB2aWV3U291cmNlTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHZhciBfb3B0cyRzb3VyY2VIZWFkZXIsIF9vcHRzJHNvdXJjZUZvb3RlcjtcbiAgICAgICAgICAgICAgdmlld1NvdXJjZShzdHJpbmdpZnkoc3BlYyksIChfb3B0cyRzb3VyY2VIZWFkZXIgPSBvcHRzLnNvdXJjZUhlYWRlcikgIT09IG51bGwgJiYgX29wdHMkc291cmNlSGVhZGVyICE9PSB2b2lkIDAgPyBfb3B0cyRzb3VyY2VIZWFkZXIgOiAnJywgKF9vcHRzJHNvdXJjZUZvb3RlciA9IG9wdHMuc291cmNlRm9vdGVyKSAhPT0gbnVsbCAmJiBfb3B0cyRzb3VyY2VGb290ZXIgIT09IHZvaWQgMCA/IF9vcHRzJHNvdXJjZUZvb3RlciA6ICcnLCBtb2RlKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdHJsLmFwcGVuZCh2aWV3U291cmNlTGluayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkICdWaWV3IENvbXBpbGVkJyBhY3Rpb25cbiAgICAgICAgICBpZiAobW9kZSA9PT0gJ3ZlZ2EtbGl0ZScgJiYgKGFjdGlvbnMgPT09IHRydWUgfHwgYWN0aW9ucy5jb21waWxlZCAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICBjb21waWxlTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGNvbXBpbGVMaW5rLnRleHQgPSBpMThuLkNPTVBJTEVEX0FDVElPTjtcbiAgICAgICAgICAgIGNvbXBpbGVMaW5rLmhyZWYgPSAnIyc7XG4gICAgICAgICAgICBjb21waWxlTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHZhciBfb3B0cyRzb3VyY2VIZWFkZXIyLCBfb3B0cyRzb3VyY2VGb290ZXIyO1xuICAgICAgICAgICAgICB2aWV3U291cmNlKHN0cmluZ2lmeSh2Z1NwZWMpLCAoX29wdHMkc291cmNlSGVhZGVyMiA9IG9wdHMuc291cmNlSGVhZGVyKSAhPT0gbnVsbCAmJiBfb3B0cyRzb3VyY2VIZWFkZXIyICE9PSB2b2lkIDAgPyBfb3B0cyRzb3VyY2VIZWFkZXIyIDogJycsIChfb3B0cyRzb3VyY2VGb290ZXIyID0gb3B0cy5zb3VyY2VGb290ZXIpICE9PSBudWxsICYmIF9vcHRzJHNvdXJjZUZvb3RlcjIgIT09IHZvaWQgMCA/IF9vcHRzJHNvdXJjZUZvb3RlcjIgOiAnJywgJ3ZlZ2EnKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdHJsLmFwcGVuZChjb21waWxlTGluayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkICdPcGVuIGluIFZlZ2EgRWRpdG9yJyBhY3Rpb25cbiAgICAgICAgICBpZiAoYWN0aW9ucyA9PT0gdHJ1ZSB8fCBhY3Rpb25zLmVkaXRvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGVkaXRvclVybCA9IChfb3B0cyRlZGl0b3JVcmwgPSBvcHRzLmVkaXRvclVybCkgIT09IG51bGwgJiYgX29wdHMkZWRpdG9yVXJsICE9PSB2b2lkIDAgPyBfb3B0cyRlZGl0b3JVcmwgOiAnaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby9lZGl0b3IvJztcbiAgICAgICAgICAgIGVkaXRvckxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBlZGl0b3JMaW5rLnRleHQgPSBpMThuLkVESVRPUl9BQ1RJT047XG4gICAgICAgICAgICBlZGl0b3JMaW5rLmhyZWYgPSAnIyc7XG4gICAgICAgICAgICBlZGl0b3JMaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcG9zdCh3aW5kb3csIGVkaXRvclVybCwge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgICAgc3BlYzogc3RyaW5naWZ5KHNwZWMpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN0cmwuYXBwZW5kKGVkaXRvckxpbmspO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgc3BlYyxcbiAgICAgICAgICAgIHZnU3BlYyxcbiAgICAgICAgICAgIGZpbmFsaXplLFxuICAgICAgICAgICAgZW1iZWRPcHRpb25zOiBvcHRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgbnVsbCwgW1s0NSwgNTQsIDU3LCA2MF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2VtYmVkMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX0FDVElPTlMsIGVtYmVkIGFzIGRlZmF1bHQsIGd1ZXNzTW9kZSwgdmVnYSwgX3ZlZ2FMaXRlIGFzIHZlZ2FMaXRlLCB2ZXJzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWdhLWVtYmVkLm1vZHVsZS5qcy5tYXBcbiIsImZ1bmN0aW9uIGFkanVzdFNwYXRpYWwgKGl0ZW0sIGVuY29kZSwgc3dhcCkge1xuICBsZXQgdDtcbiAgaWYgKGVuY29kZS54Mikge1xuICAgIGlmIChlbmNvZGUueCkge1xuICAgICAgaWYgKHN3YXAgJiYgaXRlbS54ID4gaXRlbS54Mikge1xuICAgICAgICB0ID0gaXRlbS54O1xuICAgICAgICBpdGVtLnggPSBpdGVtLngyO1xuICAgICAgICBpdGVtLngyID0gdDtcbiAgICAgIH1cbiAgICAgIGl0ZW0ud2lkdGggPSBpdGVtLngyIC0gaXRlbS54O1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtLnggPSBpdGVtLngyIC0gKGl0ZW0ud2lkdGggfHwgMCk7XG4gICAgfVxuICB9XG4gIGlmIChlbmNvZGUueGMpIHtcbiAgICBpdGVtLnggPSBpdGVtLnhjIC0gKGl0ZW0ud2lkdGggfHwgMCkgLyAyO1xuICB9XG4gIGlmIChlbmNvZGUueTIpIHtcbiAgICBpZiAoZW5jb2RlLnkpIHtcbiAgICAgIGlmIChzd2FwICYmIGl0ZW0ueSA+IGl0ZW0ueTIpIHtcbiAgICAgICAgdCA9IGl0ZW0ueTtcbiAgICAgICAgaXRlbS55ID0gaXRlbS55MjtcbiAgICAgICAgaXRlbS55MiA9IHQ7XG4gICAgICB9XG4gICAgICBpdGVtLmhlaWdodCA9IGl0ZW0ueTIgLSBpdGVtLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0ueSA9IGl0ZW0ueTIgLSAoaXRlbS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuICB9XG4gIGlmIChlbmNvZGUueWMpIHtcbiAgICBpdGVtLnkgPSBpdGVtLnljIC0gKGl0ZW0uaGVpZ2h0IHx8IDApIC8gMjtcbiAgfVxufVxuXG52YXIgQ29uc3RhbnRzID0ge1xuICBOYU46IE5hTixcbiAgRTogTWF0aC5FLFxuICBMTjI6IE1hdGguTE4yLFxuICBMTjEwOiBNYXRoLkxOMTAsXG4gIExPRzJFOiBNYXRoLkxPRzJFLFxuICBMT0cxMEU6IE1hdGguTE9HMTBFLFxuICBQSTogTWF0aC5QSSxcbiAgU1FSVDFfMjogTWF0aC5TUVJUMV8yLFxuICBTUVJUMjogTWF0aC5TUVJUMixcbiAgTUlOX1ZBTFVFOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICBNQVhfVkFMVUU6IE51bWJlci5NQVhfVkFMVUVcbn07XG5cbnZhciBPcHMgPSB7XG4gICcqJzogKGEsIGIpID0+IGEgKiBiLFxuICAnKyc6IChhLCBiKSA9PiBhICsgYixcbiAgJy0nOiAoYSwgYikgPT4gYSAtIGIsXG4gICcvJzogKGEsIGIpID0+IGEgLyBiLFxuICAnJSc6IChhLCBiKSA9PiBhICUgYixcbiAgJz4nOiAoYSwgYikgPT4gYSA+IGIsXG4gICc8JzogKGEsIGIpID0+IGEgPCBiLFxuICAnPD0nOiAoYSwgYikgPT4gYSA8PSBiLFxuICAnPj0nOiAoYSwgYikgPT4gYSA+PSBiLFxuICAnPT0nOiAoYSwgYikgPT4gYSA9PSBiLFxuICAnIT0nOiAoYSwgYikgPT4gYSAhPSBiLFxuICAnPT09JzogKGEsIGIpID0+IGEgPT09IGIsXG4gICchPT0nOiAoYSwgYikgPT4gYSAhPT0gYixcbiAgJyYnOiAoYSwgYikgPT4gYSAmIGIsXG4gICd8JzogKGEsIGIpID0+IGEgfCBiLFxuICAnXic6IChhLCBiKSA9PiBhIF4gYixcbiAgJzw8JzogKGEsIGIpID0+IGEgPDwgYixcbiAgJz4+JzogKGEsIGIpID0+IGEgPj4gYixcbiAgJz4+Pic6IChhLCBiKSA9PiBhID4+PiBiXG59O1xuXG52YXIgVW5hcnkgPSB7XG4gICcrJzogYSA9PiArYSxcbiAgJy0nOiBhID0+IC1hLFxuICAnfic6IGEgPT4gfmEsXG4gICchJzogYSA9PiAhYVxufTtcblxuY29uc3Qgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5jb25zdCBhcHBseSA9IChtLCBhcmdzLCBjYXN0KSA9PiB7XG4gIGNvbnN0IG9iaiA9IGNhc3QgPyBjYXN0KGFyZ3NbMF0pIDogYXJnc1swXTtcbiAgcmV0dXJuIG9ialttXS5hcHBseShvYmosIHNsaWNlLmNhbGwoYXJncywgMSkpO1xufTtcbmNvbnN0IGRhdGV0aW1lID0gKHksIG0sIGQsIEgsIE0sIFMsIG1zKSA9PiBuZXcgRGF0ZSh5LCBtIHx8IDAsIGQgIT0gbnVsbCA/IGQgOiAxLCBIIHx8IDAsIE0gfHwgMCwgUyB8fCAwLCBtcyB8fCAwKTtcbnZhciBGdW5jdGlvbnMgPSB7XG4gIC8vIG1hdGggZnVuY3Rpb25zXG4gIGlzTmFOOiBOdW1iZXIuaXNOYU4sXG4gIGlzRmluaXRlOiBOdW1iZXIuaXNGaW5pdGUsXG4gIGFiczogTWF0aC5hYnMsXG4gIGFjb3M6IE1hdGguYWNvcyxcbiAgYXNpbjogTWF0aC5hc2luLFxuICBhdGFuOiBNYXRoLmF0YW4sXG4gIGF0YW4yOiBNYXRoLmF0YW4yLFxuICBjZWlsOiBNYXRoLmNlaWwsXG4gIGNvczogTWF0aC5jb3MsXG4gIGV4cDogTWF0aC5leHAsXG4gIGZsb29yOiBNYXRoLmZsb29yLFxuICBsb2c6IE1hdGgubG9nLFxuICBtYXg6IE1hdGgubWF4LFxuICBtaW46IE1hdGgubWluLFxuICBwb3c6IE1hdGgucG93LFxuICByYW5kb206IE1hdGgucmFuZG9tLFxuICByb3VuZDogTWF0aC5yb3VuZCxcbiAgc2luOiBNYXRoLnNpbixcbiAgc3FydDogTWF0aC5zcXJ0LFxuICB0YW46IE1hdGgudGFuLFxuICBjbGFtcDogKGEsIGIsIGMpID0+IE1hdGgubWF4KGIsIE1hdGgubWluKGMsIGEpKSxcbiAgLy8gZGF0ZSBmdW5jdGlvbnNcbiAgbm93OiBEYXRlLm5vdyxcbiAgdXRjOiBEYXRlLlVUQyxcbiAgZGF0ZXRpbWU6IGRhdGV0aW1lLFxuICBkYXRlOiBkID0+IG5ldyBEYXRlKGQpLmdldERhdGUoKSxcbiAgZGF5OiBkID0+IG5ldyBEYXRlKGQpLmdldERheSgpLFxuICB5ZWFyOiBkID0+IG5ldyBEYXRlKGQpLmdldEZ1bGxZZWFyKCksXG4gIG1vbnRoOiBkID0+IG5ldyBEYXRlKGQpLmdldE1vbnRoKCksXG4gIGhvdXJzOiBkID0+IG5ldyBEYXRlKGQpLmdldEhvdXJzKCksXG4gIG1pbnV0ZXM6IGQgPT4gbmV3IERhdGUoZCkuZ2V0TWludXRlcygpLFxuICBzZWNvbmRzOiBkID0+IG5ldyBEYXRlKGQpLmdldFNlY29uZHMoKSxcbiAgbWlsbGlzZWNvbmRzOiBkID0+IG5ldyBEYXRlKGQpLmdldE1pbGxpc2Vjb25kcygpLFxuICB0aW1lOiBkID0+IG5ldyBEYXRlKGQpLmdldFRpbWUoKSxcbiAgdGltZXpvbmVvZmZzZXQ6IGQgPT4gbmV3IERhdGUoZCkuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgdXRjZGF0ZTogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENEYXRlKCksXG4gIHV0Y2RheTogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENEYXkoKSxcbiAgdXRjeWVhcjogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENGdWxsWWVhcigpLFxuICB1dGNtb250aDogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENNb250aCgpLFxuICB1dGNob3VyczogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENIb3VycygpLFxuICB1dGNtaW51dGVzOiBkID0+IG5ldyBEYXRlKGQpLmdldFVUQ01pbnV0ZXMoKSxcbiAgdXRjc2Vjb25kczogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENTZWNvbmRzKCksXG4gIHV0Y21pbGxpc2Vjb25kczogZCA9PiBuZXcgRGF0ZShkKS5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgLy8gc2VxdWVuY2UgZnVuY3Rpb25zXG4gIGxlbmd0aDogeCA9PiB4Lmxlbmd0aCxcbiAgam9pbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcHBseSgnam9pbicsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGluZGV4b2Y6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXBwbHkoJ2luZGV4T2YnLCBhcmd1bWVudHMpO1xuICB9LFxuICBsYXN0aW5kZXhvZjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcHBseSgnbGFzdEluZGV4T2YnLCBhcmd1bWVudHMpO1xuICB9LFxuICBzbGljZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcHBseSgnc2xpY2UnLCBhcmd1bWVudHMpO1xuICB9LFxuICByZXZlcnNlOiB4ID0+IHguc2xpY2UoKS5yZXZlcnNlKCksXG4gIC8vIHN0cmluZyBmdW5jdGlvbnNcbiAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdCxcbiAgcGFyc2VJbnQ6IHBhcnNlSW50LFxuICB1cHBlcjogeCA9PiBTdHJpbmcoeCkudG9VcHBlckNhc2UoKSxcbiAgbG93ZXI6IHggPT4gU3RyaW5nKHgpLnRvTG93ZXJDYXNlKCksXG4gIHN1YnN0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcHBseSgnc3Vic3RyaW5nJywgYXJndW1lbnRzLCBTdHJpbmcpO1xuICB9LFxuICBzcGxpdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcHBseSgnc3BsaXQnLCBhcmd1bWVudHMsIFN0cmluZyk7XG4gIH0sXG4gIHJlcGxhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXBwbHkoJ3JlcGxhY2UnLCBhcmd1bWVudHMsIFN0cmluZyk7XG4gIH0sXG4gIHRyaW06IHggPT4gU3RyaW5nKHgpLnRyaW0oKSxcbiAgLy8gcmVnZXhwIGZ1bmN0aW9uc1xuICByZWdleHA6IFJlZ0V4cCxcbiAgdGVzdDogKHIsIHQpID0+IFJlZ0V4cChyKS50ZXN0KHQpXG59O1xuXG5jb25zdCBFdmVudEZ1bmN0aW9ucyA9IFsndmlldycsICdpdGVtJywgJ2dyb3VwJywgJ3h5JywgJ3gnLCAneSddO1xuY29uc3QgRGlzYWxsb3dlZE1ldGhvZHMgPSBuZXcgU2V0KFtGdW5jdGlvbiwgZXZhbCwgc2V0VGltZW91dCwgc2V0SW50ZXJ2YWxdKTtcbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSBEaXNhbGxvd2VkTWV0aG9kcy5hZGQoc2V0SW1tZWRpYXRlKTtcbmNvbnN0IFZpc2l0b3JzID0ge1xuICBMaXRlcmFsOiAoJCwgbikgPT4gbi52YWx1ZSxcbiAgSWRlbnRpZmllcjogKCQsIG4pID0+IHtcbiAgICBjb25zdCBpZCA9IG4ubmFtZTtcbiAgICByZXR1cm4gJC5tZW1iZXJEZXB0aCA+IDAgPyBpZCA6IGlkID09PSAnZGF0dW0nID8gJC5kYXR1bSA6IGlkID09PSAnZXZlbnQnID8gJC5ldmVudCA6IGlkID09PSAnaXRlbScgPyAkLml0ZW0gOiBDb25zdGFudHNbaWRdIHx8ICQucGFyYW1zWyckJyArIGlkXTtcbiAgfSxcbiAgTWVtYmVyRXhwcmVzc2lvbjogKCQsIG4pID0+IHtcbiAgICBjb25zdCBkID0gIW4uY29tcHV0ZWQsXG4gICAgICBvID0gJChuLm9iamVjdCk7XG4gICAgaWYgKGQpICQubWVtYmVyRGVwdGggKz0gMTtcbiAgICBjb25zdCBwID0gJChuLnByb3BlcnR5KTtcbiAgICBpZiAoZCkgJC5tZW1iZXJEZXB0aCAtPSAxO1xuICAgIGlmIChEaXNhbGxvd2VkTWV0aG9kcy5oYXMob1twXSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKGBQcmV2ZW50ZWQgaW50ZXJwcmV0YXRpb24gb2YgbWVtYmVyIFwiJHtwfVwiIHdoaWNoIGNvdWxkIGxlYWQgdG8gaW5zZWN1cmUgY29kZSBleGVjdXRpb25gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG9bcF07XG4gIH0sXG4gIENhbGxFeHByZXNzaW9uOiAoJCwgbikgPT4ge1xuICAgIGNvbnN0IGFyZ3MgPSBuLmFyZ3VtZW50cztcbiAgICBsZXQgbmFtZSA9IG4uY2FsbGVlLm5hbWU7XG5cbiAgICAvLyBoYW5kbGUgc3BlY2lhbCBpbnRlcm5hbCBmdW5jdGlvbnMgdXNlZCBieSBlbmNvZGVyc1xuICAgIC8vIHJlLXJvdXRlIHRvIGNvcnJlc3BvbmRpbmcgc3RhbmRhcmQgZnVuY3Rpb25cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfJykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIC8vIHNwZWNpYWwgY2FzZSBcImlmXCIgZHVlIHRvIGNvbmRpdGlvbmFsIGV2YWx1YXRpb24gb2YgYnJhbmNoZXNcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2lmJyA/ICQoYXJnc1swXSkgPyAkKGFyZ3NbMV0pIDogJChhcmdzWzJdKSA6ICgkLmZuW25hbWVdIHx8IEZ1bmN0aW9uc1tuYW1lXSkuYXBwbHkoJC5mbiwgYXJncy5tYXAoJCkpO1xuICB9LFxuICBBcnJheUV4cHJlc3Npb246ICgkLCBuKSA9PiBuLmVsZW1lbnRzLm1hcCgkKSxcbiAgQmluYXJ5RXhwcmVzc2lvbjogKCQsIG4pID0+IE9wc1tuLm9wZXJhdG9yXSgkKG4ubGVmdCksICQobi5yaWdodCkpLFxuICBVbmFyeUV4cHJlc3Npb246ICgkLCBuKSA9PiBVbmFyeVtuLm9wZXJhdG9yXSgkKG4uYXJndW1lbnQpKSxcbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAoJCwgbikgPT4gJChuLnRlc3QpID8gJChuLmNvbnNlcXVlbnQpIDogJChuLmFsdGVybmF0ZSksXG4gIExvZ2ljYWxFeHByZXNzaW9uOiAoJCwgbikgPT4gbi5vcGVyYXRvciA9PT0gJyYmJyA/ICQobi5sZWZ0KSAmJiAkKG4ucmlnaHQpIDogJChuLmxlZnQpIHx8ICQobi5yaWdodCksXG4gIE9iamVjdEV4cHJlc3Npb246ICgkLCBuKSA9PiBuLnByb3BlcnRpZXMucmVkdWNlKChvLCBwKSA9PiB7XG4gICAgJC5tZW1iZXJEZXB0aCArPSAxO1xuICAgIGNvbnN0IGsgPSAkKHAua2V5KTtcbiAgICAkLm1lbWJlckRlcHRoIC09IDE7XG4gICAgaWYgKERpc2FsbG93ZWRNZXRob2RzLmhhcygkKHAudmFsdWUpKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFByZXZlbnRlZCBpbnRlcnByZXRhdGlvbiBvZiBwcm9wZXJ0eSBcIiR7a31cIiB3aGljaCBjb3VsZCBsZWFkIHRvIGluc2VjdXJlIGNvZGUgZXhlY3V0aW9uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ba10gPSAkKHAudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfSwge30pXG59O1xuZnVuY3Rpb24gaW50ZXJwcmV0IChhc3QsIGZuLCBwYXJhbXMsIGRhdHVtLCBldmVudCwgaXRlbSkge1xuICBjb25zdCAkID0gbiA9PiBWaXNpdG9yc1tuLnR5cGVdKCQsIG4pO1xuICAkLm1lbWJlckRlcHRoID0gMDtcbiAgJC5mbiA9IE9iamVjdC5jcmVhdGUoZm4pO1xuICAkLnBhcmFtcyA9IHBhcmFtcztcbiAgJC5kYXR1bSA9IGRhdHVtO1xuICAkLmV2ZW50ID0gZXZlbnQ7XG4gICQuaXRlbSA9IGl0ZW07XG5cbiAgLy8gcm91dGUgZXZlbnQgZnVuY3Rpb25zIHRvIGFubm90YXRlZCB2ZWdhIGV2ZW50IGNvbnRleHRcbiAgRXZlbnRGdW5jdGlvbnMuZm9yRWFjaChmID0+ICQuZm5bZl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV2ZW50LnZlZ2FbZl0oLi4uYXJndW1lbnRzKTtcbiAgfSk7XG4gIHJldHVybiAkKGFzdCk7XG59XG5cbnZhciBleHByZXNzaW9uID0ge1xuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiB1c2VkIHRvIHVwZGF0ZSBhbiBvcGVyYXRvciB2YWx1ZS5cbiAgICovXG4gIG9wZXJhdG9yKGN0eCwgZXhwcikge1xuICAgIGNvbnN0IGFzdCA9IGV4cHIuYXN0LFxuICAgICAgZm4gPSBjdHguZnVuY3Rpb25zO1xuICAgIHJldHVybiBfID0+IGludGVycHJldChhc3QsIGZuLCBfKTtcbiAgfSxcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gcHJvdmlkZWQgYXMgYW4gb3BlcmF0b3IgcGFyYW1ldGVyIHZhbHVlLlxuICAgKi9cbiAgcGFyYW1ldGVyKGN0eCwgZXhwcikge1xuICAgIGNvbnN0IGFzdCA9IGV4cHIuYXN0LFxuICAgICAgZm4gPSBjdHguZnVuY3Rpb25zO1xuICAgIHJldHVybiAoZGF0dW0sIF8pID0+IGludGVycHJldChhc3QsIGZuLCBfLCBkYXR1bSk7XG4gIH0sXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIGFwcGxpZWQgdG8gYW4gZXZlbnQgc3RyZWFtLlxuICAgKi9cbiAgZXZlbnQoY3R4LCBleHByKSB7XG4gICAgY29uc3QgYXN0ID0gZXhwci5hc3QsXG4gICAgICBmbiA9IGN0eC5mdW5jdGlvbnM7XG4gICAgcmV0dXJuIGV2ZW50ID0+IGludGVycHJldChhc3QsIGZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICB9LFxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiB1c2VkIHRvIGhhbmRsZSBhbiBldmVudC1kcml2ZW4gb3BlcmF0b3IgdXBkYXRlLlxuICAgKi9cbiAgaGFuZGxlcihjdHgsIGV4cHIpIHtcbiAgICBjb25zdCBhc3QgPSBleHByLmFzdCxcbiAgICAgIGZuID0gY3R4LmZ1bmN0aW9ucztcbiAgICByZXR1cm4gKF8sIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYXR1bSA9IGV2ZW50Lml0ZW0gJiYgZXZlbnQuaXRlbS5kYXR1bTtcbiAgICAgIHJldHVybiBpbnRlcnByZXQoYXN0LCBmbiwgXywgZGF0dW0sIGV2ZW50KTtcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiB0aGF0IHBlcmZvcm1zIHZpc3VhbCBlbmNvZGluZy5cbiAgICovXG4gIGVuY29kZShjdHgsIGVuY29kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFya3R5cGUsXG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9ID0gZW5jb2RlLFxuICAgICAgZm4gPSBjdHguZnVuY3Rpb25zLFxuICAgICAgc3dhcCA9IG1hcmt0eXBlID09PSAnZ3JvdXAnIHx8IG1hcmt0eXBlID09PSAnaW1hZ2UnIHx8IG1hcmt0eXBlID09PSAncmVjdCc7XG4gICAgcmV0dXJuIChpdGVtLCBfKSA9PiB7XG4gICAgICBjb25zdCBkYXR1bSA9IGl0ZW0uZGF0dW07XG4gICAgICBsZXQgbSA9IDAsXG4gICAgICAgIHY7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hhbm5lbHMpIHtcbiAgICAgICAgdiA9IGludGVycHJldChjaGFubmVsc1tuYW1lXS5hc3QsIGZuLCBfLCBkYXR1bSwgdW5kZWZpbmVkLCBpdGVtKTtcbiAgICAgICAgaWYgKGl0ZW1bbmFtZV0gIT09IHYpIHtcbiAgICAgICAgICBpdGVtW25hbWVdID0gdjtcbiAgICAgICAgICBtID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcmt0eXBlICE9PSAncnVsZScpIHtcbiAgICAgICAgYWRqdXN0U3BhdGlhbChpdGVtLCBjaGFubmVscywgc3dhcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9O1xuICB9XG59O1xuXG5leHBvcnQgeyBleHByZXNzaW9uIGFzIGV4cHJlc3Npb25JbnRlcnByZXRlciB9O1xuIiwiZnVuY3Rpb24gZShlKXtjb25zdFtuLHJdPS9zY2hlbWFcXC8oW1xcdy1dKylcXC8oW1xcd1xcLlxcLV0rKVxcLmpzb24kL2cuZXhlYyhlKS5zbGljZSgxLDMpO3JldHVybntsaWJyYXJ5Om4sdmVyc2lvbjpyfX1leHBvcnQgZGVmYXVsdCBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLm1vZHVsZS5qcy5tYXBcbiIsInZhciBuYW1lID0gXCJ2ZWdhLXRoZW1lc1wiO1xudmFyIHZlcnNpb24kMSA9IFwiMi4xMi4xXCI7XG52YXIgZGVzY3JpcHRpb24gPSBcIlRoZW1lcyBmb3Igc3R5bGl6ZWQgVmVnYSBhbmQgVmVnYS1MaXRlIHZpc3VhbGl6YXRpb25zLlwiO1xudmFyIGtleXdvcmRzID0gW1xuXHRcInZlZ2FcIixcblx0XCJ2ZWdhLWxpdGVcIixcblx0XCJ0aGVtZXNcIixcblx0XCJzdHlsZVwiXG5dO1xudmFyIGxpY2Vuc2UgPSBcIkJTRC0zLUNsYXVzZVwiO1xudmFyIGF1dGhvciA9IHtcblx0bmFtZTogXCJVVyBJbnRlcmFjdGl2ZSBEYXRhIExhYlwiLFxuXHR1cmw6IFwiaHR0cHM6Ly9pZGwuY3Mud2FzaGluZ3Rvbi5lZHVcIlxufTtcbnZhciBjb250cmlidXRvcnMgPSBbXG5cdHtcblx0XHRuYW1lOiBcIkVtaWx5IEd1XCIsXG5cdFx0dXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lbWlseWd1XCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiQXJ2aW5kIFNhdHlhbmFyYXlhblwiLFxuXHRcdHVybDogXCJodHRwOi8vYXJ2aW5kc2F0eWEuY29tXCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiSmVmZnJleSBIZWVyXCIsXG5cdFx0dXJsOiBcImh0dHBzOi8vaWRsLmNzLndhc2hpbmd0b24uZWR1XCJcblx0fSxcblx0e1xuXHRcdG5hbWU6IFwiRG9taW5payBNb3JpdHpcIixcblx0XHR1cmw6IFwiaHR0cHM6Ly93d3cuZG9tb3JpdHouZGVcIlxuXHR9XG5dO1xudmFyIG1haW4gPSBcImJ1aWxkL3ZlZ2EtdGhlbWVzLmpzXCI7XG52YXIgbW9kdWxlID0gXCJidWlsZC92ZWdhLXRoZW1lcy5tb2R1bGUuanNcIjtcbnZhciB1bnBrZyA9IFwiYnVpbGQvdmVnYS10aGVtZXMubWluLmpzXCI7XG52YXIganNkZWxpdnIgPSBcImJ1aWxkL3ZlZ2EtdGhlbWVzLm1pbi5qc1wiO1xudmFyIHR5cGVzID0gXCJidWlsZC92ZWdhLXRoZW1lcy5tb2R1bGUuZC50c1wiO1xudmFyIHJlcG9zaXRvcnkgPSB7XG5cdHR5cGU6IFwiZ2l0XCIsXG5cdHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLXRoZW1lcy5naXRcIlxufTtcbnZhciBmaWxlcyA9IFtcblx0XCJzcmNcIixcblx0XCJidWlsZFwiXG5dO1xudmFyIHNjcmlwdHMgPSB7XG5cdHByZWJ1aWxkOiBcInlhcm4gY2xlYW5cIixcblx0YnVpbGQ6IFwicm9sbHVwIC1jXCIsXG5cdGNsZWFuOiBcInJpbXJhZiBidWlsZCAmJiByaW1yYWYgZXhhbXBsZXMvYnVpbGRcIixcblx0XCJjb3B5OmRhdGFcIjogXCJyc3luYyAtciBub2RlX21vZHVsZXMvdmVnYS1kYXRhc2V0cy9kYXRhLyogZXhhbXBsZXMvZGF0YVwiLFxuXHRcImNvcHk6YnVpbGRcIjogXCJyc3luYyAtciBidWlsZC8qIGV4YW1wbGVzL2J1aWxkXCIsXG5cdFwiZGVwbG95OmdoXCI6IFwieWFybiBidWlsZCAmJiBta2RpciAtcCBleGFtcGxlcy9idWlsZCAmJiByc3luYyAtciBidWlsZC8qIGV4YW1wbGVzL2J1aWxkICYmIGdoLXBhZ2VzIC1kIGV4YW1wbGVzXCIsXG5cdHByZXZlcnNpb246IFwieWFybiBsaW50XCIsXG5cdHNlcnZlOiBcImJyb3dzZXItc3luYyBzdGFydCAtcyAtZiBidWlsZCBleGFtcGxlcyAtLXNlcnZlU3RhdGljIGV4YW1wbGVzXCIsXG5cdHN0YXJ0OiBcInlhcm4gYnVpbGQgJiYgY29uY3VycmVudGx5IC0ta2lsbC1vdGhlcnMgLW4gU2VydmVyLFJvbGx1cCAneWFybiBzZXJ2ZScgJ3JvbGx1cCAtYyAtdydcIixcblx0cHJlcGFyZTogXCJiZWVtbyBjcmVhdGUtY29uZmlnXCIsXG5cdGVzbGludGJhc2U6IFwiYmVlbW8gZXNsaW50IC5cIixcblx0Zm9ybWF0OiBcInlhcm4gZXNsaW50YmFzZSAtLWZpeFwiLFxuXHRsaW50OiBcInlhcm4gZXNsaW50YmFzZVwiLFxuXHRyZWxlYXNlOiBcInJlbGVhc2UtaXRcIlxufTtcbnZhciBkZXZEZXBlbmRlbmNpZXMgPSB7XG5cdFwiQHJlbGVhc2UtaXQvY29udmVudGlvbmFsLWNoYW5nZWxvZ1wiOiBcIl41LjEuMVwiLFxuXHRcIkByb2xsdXAvcGx1Z2luLWpzb25cIjogXCJeNi4wLjBcIixcblx0XCJAcm9sbHVwL3BsdWdpbi1ub2RlLXJlc29sdmVcIjogXCJeMTUuMC4xXCIsXG5cdFwiQHJvbGx1cC9wbHVnaW4tdGVyc2VyXCI6IFwiXjAuNC4wXCIsXG5cdFwiYnJvd3Nlci1zeW5jXCI6IFwiXjIuMjcuMTBcIixcblx0Y29uY3VycmVudGx5OiBcIl43LjMuMFwiLFxuXHRcImdoLXBhZ2VzXCI6IFwiXjUuMC4wXCIsXG5cdFwicmVsZWFzZS1pdFwiOiBcIl4xNS42LjBcIixcblx0XCJyb2xsdXAtcGx1Z2luLWJ1bmRsZS1zaXplXCI6IFwiXjEuMC4zXCIsXG5cdFwicm9sbHVwLXBsdWdpbi10c1wiOiBcIl4zLjAuMlwiLFxuXHRyb2xsdXA6IFwiXjMuMTUuMFwiLFxuXHR0eXBlc2NyaXB0OiBcIl40LjcuNFwiLFxuXHRcInZlZ2EtbGl0ZS1kZXYtY29uZmlnXCI6IFwiXjAuMjEuMFwiLFxuXHRcInZlZ2EtbGl0ZVwiOiBcIl41LjAuMFwiLFxuXHR2ZWdhOiBcIl41LjE5LjFcIlxufTtcbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHR2ZWdhOiBcIipcIixcblx0XCJ2ZWdhLWxpdGVcIjogXCIqXCJcbn07XG52YXIgZGVwZW5kZW5jaWVzID0ge1xufTtcbnZhciBwa2cgPSB7XG5cdG5hbWU6IG5hbWUsXG5cdHZlcnNpb246IHZlcnNpb24kMSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRrZXl3b3Jkczoga2V5d29yZHMsXG5cdGxpY2Vuc2U6IGxpY2Vuc2UsXG5cdGF1dGhvcjogYXV0aG9yLFxuXHRjb250cmlidXRvcnM6IGNvbnRyaWJ1dG9ycyxcblx0bWFpbjogbWFpbixcblx0bW9kdWxlOiBtb2R1bGUsXG5cdHVucGtnOiB1bnBrZyxcblx0anNkZWxpdnI6IGpzZGVsaXZyLFxuXHR0eXBlczogdHlwZXMsXG5cdHJlcG9zaXRvcnk6IHJlcG9zaXRvcnksXG5cdGZpbGVzOiBmaWxlcyxcblx0c2NyaXB0czogc2NyaXB0cyxcblx0ZGV2RGVwZW5kZW5jaWVzOiBkZXZEZXBlbmRlbmNpZXMsXG5cdHBlZXJEZXBlbmRlbmNpZXM6IHBlZXJEZXBlbmRlbmNpZXMsXG5cdGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzXG59O1xuXG5jb25zdCBsaWdodENvbG9yID0gJyNmZmYnO1xuY29uc3QgbWVkQ29sb3IgPSAnIzg4OCc7XG5jb25zdCBkYXJrVGhlbWUgPSB7XG4gICAgYmFja2dyb3VuZDogJyMzMzMnLFxuICAgIHZpZXc6IHtcbiAgICAgICAgc3Ryb2tlOiBtZWRDb2xvcixcbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGNvbG9yOiBsaWdodENvbG9yLFxuICAgICAgICBzdWJ0aXRsZUNvbG9yOiBsaWdodENvbG9yLFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgICAgJ2d1aWRlLWxhYmVsJzoge1xuICAgICAgICAgICAgZmlsbDogbGlnaHRDb2xvcixcbiAgICAgICAgfSxcbiAgICAgICAgJ2d1aWRlLXRpdGxlJzoge1xuICAgICAgICAgICAgZmlsbDogbGlnaHRDb2xvcixcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgZG9tYWluQ29sb3I6IGxpZ2h0Q29sb3IsXG4gICAgICAgIGdyaWRDb2xvcjogbWVkQ29sb3IsXG4gICAgICAgIHRpY2tDb2xvcjogbGlnaHRDb2xvcixcbiAgICB9LFxufTtcblxuY29uc3QgbWFya0NvbG9yJDcgPSAnIzQ1NzJhNyc7XG5jb25zdCBleGNlbFRoZW1lID0ge1xuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBhcmM6IHsgZmlsbDogbWFya0NvbG9yJDcgfSxcbiAgICBhcmVhOiB7IGZpbGw6IG1hcmtDb2xvciQ3IH0sXG4gICAgbGluZTogeyBzdHJva2U6IG1hcmtDb2xvciQ3LCBzdHJva2VXaWR0aDogMiB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNyB9LFxuICAgIHJlY3Q6IHsgZmlsbDogbWFya0NvbG9yJDcgfSxcbiAgICBzaGFwZTogeyBzdHJva2U6IG1hcmtDb2xvciQ3IH0sXG4gICAgc3ltYm9sOiB7IGZpbGw6IG1hcmtDb2xvciQ3LCBzdHJva2VXaWR0aDogMS41LCBzaXplOiA1MCB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgYmFuZFBvc2l0aW9uOiAwLjUsXG4gICAgICAgIGdyaWQ6IHRydWUsXG4gICAgICAgIGdyaWRDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICBncmlkT3BhY2l0eTogMSxcbiAgICAgICAgZ3JpZFdpZHRoOiAwLjUsXG4gICAgICAgIGxhYmVsUGFkZGluZzogMTAsXG4gICAgICAgIHRpY2tTaXplOiA1LFxuICAgICAgICB0aWNrV2lkdGg6IDAuNSxcbiAgICB9LFxuICAgIGF4aXNCYW5kOiB7XG4gICAgICAgIGdyaWQ6IGZhbHNlLFxuICAgICAgICB0aWNrRXh0cmE6IHRydWUsXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IDExLFxuICAgICAgICBzeW1ib2xTaXplOiA1MCxcbiAgICAgICAgc3ltYm9sVHlwZTogJ3NxdWFyZScsXG4gICAgfSxcbiAgICByYW5nZToge1xuICAgICAgICBjYXRlZ29yeTogW1xuICAgICAgICAgICAgJyM0NTcyYTcnLFxuICAgICAgICAgICAgJyNhYTQ2NDMnLFxuICAgICAgICAgICAgJyM4YWE0NTMnLFxuICAgICAgICAgICAgJyM3MTU5OGUnLFxuICAgICAgICAgICAgJyM0NTk4YWUnLFxuICAgICAgICAgICAgJyNkOTg0NDUnLFxuICAgICAgICAgICAgJyM5NGFhY2UnLFxuICAgICAgICAgICAgJyNkMDkzOTMnLFxuICAgICAgICAgICAgJyNiOWNjOTgnLFxuICAgICAgICAgICAgJyNhOTljYmMnLFxuICAgICAgICBdLFxuICAgIH0sXG59O1xuXG5jb25zdCBtYXJrQ29sb3IkNiA9ICcjMzBhMmRhJztcbmNvbnN0IGF4aXNDb2xvciQyID0gJyNjYmNiY2InO1xuY29uc3QgZ3VpZGVMYWJlbENvbG9yID0gJyM5OTknO1xuY29uc3QgZ3VpZGVUaXRsZUNvbG9yID0gJyMzMzMnO1xuY29uc3QgYmFja2dyb3VuZENvbG9yJDIgPSAnI2YwZjBmMCc7XG5jb25zdCBibGFja1RpdGxlID0gJyMzMzMnO1xuY29uc3QgZml2ZVRoaXJ0eUVpZ2h0VGhlbWUgPSB7XG4gICAgYXJjOiB7IGZpbGw6IG1hcmtDb2xvciQ2IH0sXG4gICAgYXJlYTogeyBmaWxsOiBtYXJrQ29sb3IkNiB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgZG9tYWluQ29sb3I6IGF4aXNDb2xvciQyLFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICBncmlkQ29sb3I6IGF4aXNDb2xvciQyLFxuICAgICAgICBncmlkV2lkdGg6IDEsXG4gICAgICAgIGxhYmVsQ29sb3I6IGd1aWRlTGFiZWxDb2xvcixcbiAgICAgICAgbGFiZWxGb250U2l6ZTogMTAsXG4gICAgICAgIHRpdGxlQ29sb3I6IGd1aWRlVGl0bGVDb2xvcixcbiAgICAgICAgdGlja0NvbG9yOiBheGlzQ29sb3IkMixcbiAgICAgICAgdGlja1NpemU6IDEwLFxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxNCxcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAxMCxcbiAgICAgICAgbGFiZWxQYWRkaW5nOiA0LFxuICAgIH0sXG4gICAgYXhpc0JhbmQ6IHtcbiAgICAgICAgZ3JpZDogZmFsc2UsXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kQ29sb3IkMixcbiAgICBncm91cDoge1xuICAgICAgICBmaWxsOiBiYWNrZ3JvdW5kQ29sb3IkMixcbiAgICB9LFxuICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbENvbG9yOiBibGFja1RpdGxlLFxuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMSxcbiAgICAgICAgcGFkZGluZzogMSxcbiAgICAgICAgc3ltYm9sU2l6ZTogMzAsXG4gICAgICAgIHN5bWJvbFR5cGU6ICdzcXVhcmUnLFxuICAgICAgICB0aXRsZUNvbG9yOiBibGFja1RpdGxlLFxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxNCxcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAxMCxcbiAgICB9LFxuICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiBtYXJrQ29sb3IkNixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgfSxcbiAgICBwYXRoOiB7IHN0cm9rZTogbWFya0NvbG9yJDYsIHN0cm9rZVdpZHRoOiAwLjUgfSxcbiAgICByZWN0OiB7IGZpbGw6IG1hcmtDb2xvciQ2IH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IFtcbiAgICAgICAgICAgICcjMzBhMmRhJyxcbiAgICAgICAgICAgICcjZmM0ZjMwJyxcbiAgICAgICAgICAgICcjZTVhZTM4JyxcbiAgICAgICAgICAgICcjNmQ5MDRmJyxcbiAgICAgICAgICAgICcjOGI4YjhiJyxcbiAgICAgICAgICAgICcjYjk2ZGI4JyxcbiAgICAgICAgICAgICcjZmY5ZTI3JyxcbiAgICAgICAgICAgICcjNTZjYzYwJyxcbiAgICAgICAgICAgICcjNTJkMmNhJyxcbiAgICAgICAgICAgICcjNTI2ODllJyxcbiAgICAgICAgICAgICcjNTQ1NDU0JyxcbiAgICAgICAgICAgICcjOWZlNGY4JyxcbiAgICAgICAgXSxcbiAgICAgICAgZGl2ZXJnaW5nOiBbJyNjYzAwMjAnLCAnI2U3Nzg2NicsICcjZjZlN2UxJywgJyNkNmU4ZWQnLCAnIzkxYmZkOScsICcjMWQ3OGI1J10sXG4gICAgICAgIGhlYXRtYXA6IFsnI2Q2ZThlZCcsICcjY2VlMGU1JywgJyM5MWJmZDknLCAnIzU0OWNjNicsICcjMWQ3OGI1J10sXG4gICAgfSxcbiAgICBwb2ludDoge1xuICAgICAgICBmaWxsZWQ6IHRydWUsXG4gICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yJDYgfSxcbiAgICBiYXI6IHtcbiAgICAgICAgYmluU3BhY2luZzogMixcbiAgICAgICAgZmlsbDogbWFya0NvbG9yJDYsXG4gICAgICAgIHN0cm9rZTogbnVsbCxcbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgZm9udFNpemU6IDI0LFxuICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgIG9mZnNldDogMjAsXG4gICAgfSxcbn07XG5cbmNvbnN0IG1hcmtDb2xvciQ1ID0gJyMwMDAnO1xuY29uc3QgZ2dwbG90MlRoZW1lID0ge1xuICAgIGdyb3VwOiB7XG4gICAgICAgIGZpbGw6ICcjZTVlNWU1JyxcbiAgICB9LFxuICAgIGFyYzogeyBmaWxsOiBtYXJrQ29sb3IkNSB9LFxuICAgIGFyZWE6IHsgZmlsbDogbWFya0NvbG9yJDUgfSxcbiAgICBsaW5lOiB7IHN0cm9rZTogbWFya0NvbG9yJDUgfSxcbiAgICBwYXRoOiB7IHN0cm9rZTogbWFya0NvbG9yJDUgfSxcbiAgICByZWN0OiB7IGZpbGw6IG1hcmtDb2xvciQ1IH0sXG4gICAgc2hhcGU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNSB9LFxuICAgIHN5bWJvbDogeyBmaWxsOiBtYXJrQ29sb3IkNSwgc2l6ZTogNDAgfSxcbiAgICBheGlzOiB7XG4gICAgICAgIGRvbWFpbjogZmFsc2UsXG4gICAgICAgIGdyaWQ6IHRydWUsXG4gICAgICAgIGdyaWRDb2xvcjogJyNGRkZGRkYnLFxuICAgICAgICBncmlkT3BhY2l0eTogMSxcbiAgICAgICAgbGFiZWxDb2xvcjogJyM3RjdGN0YnLFxuICAgICAgICBsYWJlbFBhZGRpbmc6IDQsXG4gICAgICAgIHRpY2tDb2xvcjogJyM3RjdGN0YnLFxuICAgICAgICB0aWNrU2l6ZTogNS42NyxcbiAgICAgICAgdGl0bGVGb250U2l6ZTogMTYsXG4gICAgICAgIHRpdGxlRm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IDExLFxuICAgICAgICBzeW1ib2xTaXplOiA0MCxcbiAgICB9LFxuICAgIHJhbmdlOiB7XG4gICAgICAgIGNhdGVnb3J5OiBbXG4gICAgICAgICAgICAnIzAwMDAwMCcsXG4gICAgICAgICAgICAnIzdGN0Y3RicsXG4gICAgICAgICAgICAnIzFBMUExQScsXG4gICAgICAgICAgICAnIzk5OTk5OScsXG4gICAgICAgICAgICAnIzMzMzMzMycsXG4gICAgICAgICAgICAnI0IwQjBCMCcsXG4gICAgICAgICAgICAnIzRENEQ0RCcsXG4gICAgICAgICAgICAnI0M5QzlDOScsXG4gICAgICAgICAgICAnIzY2NjY2NicsXG4gICAgICAgICAgICAnI0RDRENEQycsXG4gICAgICAgIF0sXG4gICAgfSxcbn07XG5cbmNvbnN0IGhlYWRsaW5lRm9udFNpemUgPSAyMjtcbmNvbnN0IGhlYWRsaW5lRm9udFdlaWdodCA9ICdub3JtYWwnO1xuY29uc3QgbGFiZWxGb250JDEgPSAnQmVudG9uIEdvdGhpYywgc2Fucy1zZXJpZic7XG5jb25zdCBsYWJlbEZvbnRTaXplID0gMTEuNTtcbmNvbnN0IGxhYmVsRm9udFdlaWdodCA9ICdub3JtYWwnO1xuY29uc3QgbWFya0NvbG9yJDQgPSAnIzgyYzZkZic7XG4vLyBjb25zdCBtYXJrSGlnaGxpZ2h0ID0gJyMwMDZkOGYnO1xuLy8gY29uc3QgbWFya0RlbW9jcmF0ID0gJyM1Nzg5YjgnO1xuLy8gY29uc3QgbWFya1JlcHVibGljYW4gPSAnI2Q5NGY1NCc7XG5jb25zdCB0aXRsZUZvbnQgPSAnQmVudG9uIEdvdGhpYyBCb2xkLCBzYW5zLXNlcmlmJztcbmNvbnN0IHRpdGxlRm9udFdlaWdodCA9ICdub3JtYWwnO1xuY29uc3QgdGl0bGVGb250U2l6ZSQxID0gMTM7XG5jb25zdCBjb2xvclNjaGVtZXMkMSA9IHtcbiAgICAnY2F0ZWdvcnktNic6IFsnI2VjODQzMScsICcjODI5ZWIxJywgJyNjODlkMjknLCAnIzM1ODBiMScsICcjYWRjODM5JywgJyNhYjdmYjQnXSxcbiAgICAnZmlyZS03JzogWycjZmJmMmM3JywgJyNmOWUzOWMnLCAnI2Y4ZDM2ZScsICcjZjRiYjZhJywgJyNlNjhhNGYnLCAnI2QxNWE0MCcsICcjYWI0MjMyJ10sXG4gICAgJ2ZpcmVhbmRpY2UtNic6IFsnI2U2OGE0ZicsICcjZjRiYjZhJywgJyNmOWUzOWMnLCAnI2RhZGZlMicsICcjYTZiN2M2JywgJyM4NDllYWUnXSxcbiAgICAnaWNlLTcnOiBbJyNlZGVmZWUnLCAnI2RhZGZlMicsICcjYzRjY2QyJywgJyNhNmI3YzYnLCAnIzg0OWVhZScsICcjNjA3Nzg1JywgJyM0NzUyNWQnXSxcbn07XG5jb25zdCBsYXRpbWVzVGhlbWUgPSB7XG4gICAgYmFja2dyb3VuZDogJyNmZmZmZmYnLFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgZm9udDogdGl0bGVGb250LFxuICAgICAgICBmb250U2l6ZTogaGVhZGxpbmVGb250U2l6ZSxcbiAgICAgICAgZm9udFdlaWdodDogaGVhZGxpbmVGb250V2VpZ2h0LFxuICAgIH0sXG4gICAgYXJjOiB7IGZpbGw6IG1hcmtDb2xvciQ0IH0sXG4gICAgYXJlYTogeyBmaWxsOiBtYXJrQ29sb3IkNCB9LFxuICAgIGxpbmU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNCwgc3Ryb2tlV2lkdGg6IDIgfSxcbiAgICBwYXRoOiB7IHN0cm9rZTogbWFya0NvbG9yJDQgfSxcbiAgICByZWN0OiB7IGZpbGw6IG1hcmtDb2xvciQ0IH0sXG4gICAgc2hhcGU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNCB9LFxuICAgIHN5bWJvbDogeyBmaWxsOiBtYXJrQ29sb3IkNCwgc2l6ZTogMzAgfSxcbiAgICBheGlzOiB7XG4gICAgICAgIGxhYmVsRm9udDogbGFiZWxGb250JDEsXG4gICAgICAgIGxhYmVsRm9udFNpemUsXG4gICAgICAgIGxhYmVsRm9udFdlaWdodCxcbiAgICAgICAgdGl0bGVGb250LFxuICAgICAgICB0aXRsZUZvbnRTaXplOiB0aXRsZUZvbnRTaXplJDEsXG4gICAgICAgIHRpdGxlRm9udFdlaWdodCxcbiAgICB9LFxuICAgIGF4aXNYOiB7XG4gICAgICAgIGxhYmVsQW5nbGU6IDAsXG4gICAgICAgIGxhYmVsUGFkZGluZzogNCxcbiAgICAgICAgdGlja1NpemU6IDMsXG4gICAgfSxcbiAgICBheGlzWToge1xuICAgICAgICBsYWJlbEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgbWF4RXh0ZW50OiA0NSxcbiAgICAgICAgbWluRXh0ZW50OiA0NSxcbiAgICAgICAgdGlja1NpemU6IDIsXG4gICAgICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICAgICAgdGl0bGVBbmdsZTogMCxcbiAgICAgICAgdGl0bGVYOiAtNDUsXG4gICAgICAgIHRpdGxlWTogLTExLFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsRm9udDogbGFiZWxGb250JDEsXG4gICAgICAgIGxhYmVsRm9udFNpemUsXG4gICAgICAgIHN5bWJvbFR5cGU6ICdzcXVhcmUnLFxuICAgICAgICB0aXRsZUZvbnQsXG4gICAgICAgIHRpdGxlRm9udFNpemU6IHRpdGxlRm9udFNpemUkMSxcbiAgICAgICAgdGl0bGVGb250V2VpZ2h0LFxuICAgIH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvbG9yU2NoZW1lcyQxWydjYXRlZ29yeS02J10sXG4gICAgICAgIGRpdmVyZ2luZzogY29sb3JTY2hlbWVzJDFbJ2ZpcmVhbmRpY2UtNiddLFxuICAgICAgICBoZWF0bWFwOiBjb2xvclNjaGVtZXMkMVsnZmlyZS03J10sXG4gICAgICAgIG9yZGluYWw6IGNvbG9yU2NoZW1lcyQxWydmaXJlLTcnXSxcbiAgICAgICAgcmFtcDogY29sb3JTY2hlbWVzJDFbJ2ZpcmUtNyddLFxuICAgIH0sXG59O1xuXG5jb25zdCBtYXJrQ29sb3IkMyA9ICcjYWI1Nzg3JztcbmNvbnN0IGF4aXNDb2xvciQxID0gJyM5Nzk3OTcnO1xuY29uc3QgcXVhcnR6VGhlbWUgPSB7XG4gICAgYmFja2dyb3VuZDogJyNmOWY5ZjknLFxuICAgIGFyYzogeyBmaWxsOiBtYXJrQ29sb3IkMyB9LFxuICAgIGFyZWE6IHsgZmlsbDogbWFya0NvbG9yJDMgfSxcbiAgICBsaW5lOiB7IHN0cm9rZTogbWFya0NvbG9yJDMgfSxcbiAgICBwYXRoOiB7IHN0cm9rZTogbWFya0NvbG9yJDMgfSxcbiAgICByZWN0OiB7IGZpbGw6IG1hcmtDb2xvciQzIH0sXG4gICAgc2hhcGU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkMyB9LFxuICAgIHN5bWJvbDogeyBmaWxsOiBtYXJrQ29sb3IkMywgc2l6ZTogMzAgfSxcbiAgICBheGlzOiB7XG4gICAgICAgIGRvbWFpbkNvbG9yOiBheGlzQ29sb3IkMSxcbiAgICAgICAgZG9tYWluV2lkdGg6IDAuNSxcbiAgICAgICAgZ3JpZFdpZHRoOiAwLjIsXG4gICAgICAgIGxhYmVsQ29sb3I6IGF4aXNDb2xvciQxLFxuICAgICAgICB0aWNrQ29sb3I6IGF4aXNDb2xvciQxLFxuICAgICAgICB0aWNrV2lkdGg6IDAuMixcbiAgICAgICAgdGl0bGVDb2xvcjogYXhpc0NvbG9yJDEsXG4gICAgfSxcbiAgICBheGlzQmFuZDoge1xuICAgICAgICBncmlkOiBmYWxzZSxcbiAgICB9LFxuICAgIGF4aXNYOiB7XG4gICAgICAgIGdyaWQ6IHRydWUsXG4gICAgICAgIHRpY2tTaXplOiAxMCxcbiAgICB9LFxuICAgIGF4aXNZOiB7XG4gICAgICAgIGRvbWFpbjogZmFsc2UsXG4gICAgICAgIGdyaWQ6IHRydWUsXG4gICAgICAgIHRpY2tTaXplOiAwLFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsRm9udFNpemU6IDExLFxuICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICBzeW1ib2xTaXplOiAzMCxcbiAgICAgICAgc3ltYm9sVHlwZTogJ3NxdWFyZScsXG4gICAgfSxcbiAgICByYW5nZToge1xuICAgICAgICBjYXRlZ29yeTogW1xuICAgICAgICAgICAgJyNhYjU3ODcnLFxuICAgICAgICAgICAgJyM1MWIyZTUnLFxuICAgICAgICAgICAgJyM3MDNjNWMnLFxuICAgICAgICAgICAgJyMxNjhkZDknLFxuICAgICAgICAgICAgJyNkMTkwYjYnLFxuICAgICAgICAgICAgJyMwMDYwOWYnLFxuICAgICAgICAgICAgJyNkMzY1YmEnLFxuICAgICAgICAgICAgJyMxNTQ4NjYnLFxuICAgICAgICAgICAgJyM2NjY2NjYnLFxuICAgICAgICAgICAgJyNjNGM0YzQnLFxuICAgICAgICBdLFxuICAgIH0sXG59O1xuXG5jb25zdCBtYXJrQ29sb3IkMiA9ICcjM2U1YzY5JztcbmNvbnN0IHZveFRoZW1lID0ge1xuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBhcmM6IHsgZmlsbDogbWFya0NvbG9yJDIgfSxcbiAgICBhcmVhOiB7IGZpbGw6IG1hcmtDb2xvciQyIH0sXG4gICAgbGluZTogeyBzdHJva2U6IG1hcmtDb2xvciQyIH0sXG4gICAgcGF0aDogeyBzdHJva2U6IG1hcmtDb2xvciQyIH0sXG4gICAgcmVjdDogeyBmaWxsOiBtYXJrQ29sb3IkMiB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yJDIgfSxcbiAgICBzeW1ib2w6IHsgZmlsbDogbWFya0NvbG9yJDIgfSxcbiAgICBheGlzOiB7XG4gICAgICAgIGRvbWFpbldpZHRoOiAwLjUsXG4gICAgICAgIGdyaWQ6IHRydWUsXG4gICAgICAgIGxhYmVsUGFkZGluZzogMixcbiAgICAgICAgdGlja1NpemU6IDUsXG4gICAgICAgIHRpY2tXaWR0aDogMC41LFxuICAgICAgICB0aXRsZUZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgYXhpc0JhbmQ6IHtcbiAgICAgICAgZ3JpZDogZmFsc2UsXG4gICAgfSxcbiAgICBheGlzWDoge1xuICAgICAgICBncmlkV2lkdGg6IDAuMixcbiAgICB9LFxuICAgIGF4aXNZOiB7XG4gICAgICAgIGdyaWREYXNoOiBbM10sXG4gICAgICAgIGdyaWRXaWR0aDogMC40LFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsRm9udFNpemU6IDExLFxuICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICBzeW1ib2xUeXBlOiAnc3F1YXJlJyxcbiAgICB9LFxuICAgIHJhbmdlOiB7XG4gICAgICAgIGNhdGVnb3J5OiBbJyMzZTVjNjknLCAnIzY3OTNhNicsICcjMTgyNDI5JywgJyMwNTcwYjAnLCAnIzM2OTBjMCcsICcjNzRhOWNmJywgJyNhNmJkZGInLCAnI2UyZGRmMiddLFxuICAgIH0sXG59O1xuXG5jb25zdCBtYXJrQ29sb3IkMSA9ICcjMTY5NmQyJztcbmNvbnN0IGF4aXNDb2xvciA9ICcjMDAwMDAwJztcbmNvbnN0IGJhY2tncm91bmRDb2xvciQxID0gJyNGRkZGRkYnO1xuY29uc3QgZm9udCA9ICdMYXRvJztcbmNvbnN0IGxhYmVsRm9udCA9ICdMYXRvJztcbmNvbnN0IHNvdXJjZUZvbnQgPSAnTGF0byc7XG5jb25zdCBncmlkQ29sb3IkMSA9ICcjREVEREREJztcbmNvbnN0IHRpdGxlRm9udFNpemUgPSAxODtcbmNvbnN0IGNvbG9yU2NoZW1lcyA9IHtcbiAgICAnbWFpbi1jb2xvcnMnOiBbJyMxNjk2ZDInLCAnI2QyZDJkMicsICcjMDAwMDAwJywgJyNmZGJmMTEnLCAnI2VjMDA4YicsICcjNTViNzQ4JywgJyM1YzU4NTknLCAnI2RiMmIyNyddLFxuICAgICdzaGFkZXMtYmx1ZSc6IFsnI0NGRThGMycsICcjQTJENEVDJywgJyM3M0JGRTInLCAnIzQ2QUJEQicsICcjMTY5NkQyJywgJyMxMjcxOUUnLCAnIzBBNEM2QScsICcjMDYyNjM1J10sXG4gICAgJ3NoYWRlcy1ncmF5JzogWycjRjVGNUY1JywgJyNFQ0VDRUMnLCAnI0UzRTNFMycsICcjRENEQkRCJywgJyNEMkQyRDInLCAnIzlEOUQ5RCcsICcjNjk2OTY5JywgJyMzNTM1MzUnXSxcbiAgICAnc2hhZGVzLXllbGxvdyc6IFsnI0ZGRjJDRicsICcjRkNFMzlFJywgJyNGREQ4NzAnLCAnI0ZDQ0I0MScsICcjRkRCRjExJywgJyNFODhFMkQnLCAnI0NBNTgwMCcsICcjODQzMjE1J10sXG4gICAgJ3NoYWRlcy1tYWdlbnRhJzogWycjRjVDQkRGJywgJyNFQjk5QzInLCAnI0U0NkFBNycsICcjRTU0MDk2JywgJyNFQzAwOEInLCAnI0FGMUY2QicsICcjNzYxNTQ4JywgJyMzNTExMjMnXSxcbiAgICAnc2hhZGVzLWdyZWVuJzogWycjRENFREQ5JywgJyNCQ0RFQjQnLCAnIzk4Q0Y5MCcsICcjNzhDMjZEJywgJyM1NUI3NDgnLCAnIzQwODk0MScsICcjMkM1QzJEJywgJyMxQTJFMTknXSxcbiAgICAnc2hhZGVzLWJsYWNrJzogWycjRDVENUQ0JywgJyNBREFCQUMnLCAnIzg0ODA4MScsICcjNUM1ODU5JywgJyMzMzJEMkYnLCAnIzI2MjIyMycsICcjMUExNzE3JywgJyMwRTBDMEQnXSxcbiAgICAnc2hhZGVzLXJlZCc6IFsnI0Y4RDVENCcsICcjRjFBQUE5JywgJyNFOTgwN0QnLCAnI0UyNTU1MicsICcjREIyQjI3JywgJyNBNDIwMUQnLCAnIzZFMTYxNCcsICcjMzcwQjBBJ10sXG4gICAgJ29uZS1ncm91cCc6IFsnIzE2OTZkMicsICcjMDAwMDAwJ10sXG4gICAgJ3R3by1ncm91cHMtY2F0LTEnOiBbJyMxNjk2ZDInLCAnIzAwMDAwMCddLFxuICAgICd0d28tZ3JvdXBzLWNhdC0yJzogWycjMTY5NmQyJywgJyNmZGJmMTEnXSxcbiAgICAndHdvLWdyb3Vwcy1jYXQtMyc6IFsnIzE2OTZkMicsICcjZGIyYjI3J10sXG4gICAgJ3R3by1ncm91cHMtc2VxJzogWycjYTJkNGVjJywgJyMxNjk2ZDInXSxcbiAgICAndGhyZWUtZ3JvdXBzLWNhdCc6IFsnIzE2OTZkMicsICcjZmRiZjExJywgJyMwMDAwMDAnXSxcbiAgICAndGhyZWUtZ3JvdXBzLXNlcSc6IFsnI2EyZDRlYycsICcjMTY5NmQyJywgJyMwYTRjNmEnXSxcbiAgICAnZm91ci1ncm91cHMtY2F0LTEnOiBbJyMwMDAwMDAnLCAnI2QyZDJkMicsICcjZmRiZjExJywgJyMxNjk2ZDInXSxcbiAgICAnZm91ci1ncm91cHMtY2F0LTInOiBbJyMxNjk2ZDInLCAnI2VjMDAwOGInLCAnI2ZkYmYxMScsICcjNWM1ODU5J10sXG4gICAgJ2ZvdXItZ3JvdXBzLXNlcSc6IFsnI2NmZThmMycsICcjNzNiZjQyJywgJyMxNjk2ZDInLCAnIzBhNGM2YSddLFxuICAgICdmaXZlLWdyb3Vwcy1jYXQtMSc6IFsnIzE2OTZkMicsICcjZmRiZjExJywgJyNkMmQyZDInLCAnI2VjMDA4YicsICcjMDAwMDAwJ10sXG4gICAgJ2ZpdmUtZ3JvdXBzLWNhdC0yJzogWycjMTY5NmQyJywgJyMwYTRjNmEnLCAnI2QyZDJkMicsICcjZmRiZjExJywgJyMzMzJkMmYnXSxcbiAgICAnZml2ZS1ncm91cHMtc2VxJzogWycjY2ZlOGYzJywgJyM3M2JmNDInLCAnIzE2OTZkMicsICcjMGE0YzZhJywgJyMwMDAwMDAnXSxcbiAgICAnc2l4LWdyb3Vwcy1jYXQtMSc6IFsnIzE2OTZkMicsICcjZWMwMDhiJywgJyNmZGJmMTEnLCAnIzAwMDAwMCcsICcjZDJkMmQyJywgJyM1NWI3NDgnXSxcbiAgICAnc2l4LWdyb3Vwcy1jYXQtMic6IFsnIzE2OTZkMicsICcjZDJkMmQyJywgJyNlYzAwOGInLCAnI2ZkYmYxMScsICcjMzMyZDJmJywgJyMwYTRjNmEnXSxcbiAgICAnc2l4LWdyb3Vwcy1zZXEnOiBbJyNjZmU4ZjMnLCAnI2EyZDRlYycsICcjNzNiZmUyJywgJyM0NmFiZGInLCAnIzE2OTZkMicsICcjMTI3MTllJ10sXG4gICAgJ2RpdmVyZ2luZy1jb2xvcnMnOiBbJyNjYTU4MDAnLCAnI2ZkYmYxMScsICcjZmRkODcwJywgJyNmZmYyY2YnLCAnI2NmZThmMycsICcjNzNiZmUyJywgJyMxNjk2ZDInLCAnIzBhNGM2YSddLFxufTtcbmNvbnN0IHVyYmFuSW5zdGl0dXRlVGhlbWUgPSB7XG4gICAgYmFja2dyb3VuZDogYmFja2dyb3VuZENvbG9yJDEsXG4gICAgdGl0bGU6IHtcbiAgICAgICAgYW5jaG9yOiAnc3RhcnQnLFxuICAgICAgICBmb250U2l6ZTogdGl0bGVGb250U2l6ZSxcbiAgICAgICAgZm9udDogZm9udCxcbiAgICB9LFxuICAgIGF4aXNYOiB7XG4gICAgICAgIGRvbWFpbjogdHJ1ZSxcbiAgICAgICAgZG9tYWluQ29sb3I6IGF4aXNDb2xvcixcbiAgICAgICAgZG9tYWluV2lkdGg6IDEsXG4gICAgICAgIGdyaWQ6IGZhbHNlLFxuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMixcbiAgICAgICAgbGFiZWxGb250OiBsYWJlbEZvbnQsXG4gICAgICAgIGxhYmVsQW5nbGU6IDAsXG4gICAgICAgIHRpY2tDb2xvcjogYXhpc0NvbG9yLFxuICAgICAgICB0aWNrU2l6ZTogNSxcbiAgICAgICAgdGl0bGVGb250U2l6ZTogMTIsXG4gICAgICAgIHRpdGxlUGFkZGluZzogMTAsXG4gICAgICAgIHRpdGxlRm9udDogZm9udCxcbiAgICB9LFxuICAgIGF4aXNZOiB7XG4gICAgICAgIGRvbWFpbjogZmFsc2UsXG4gICAgICAgIGRvbWFpbldpZHRoOiAxLFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICBncmlkQ29sb3I6IGdyaWRDb2xvciQxLFxuICAgICAgICBncmlkV2lkdGg6IDEsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IDEyLFxuICAgICAgICBsYWJlbEZvbnQ6IGxhYmVsRm9udCxcbiAgICAgICAgbGFiZWxQYWRkaW5nOiA4LFxuICAgICAgICB0aWNrczogZmFsc2UsXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxuICAgICAgICB0aXRsZVBhZGRpbmc6IDEwLFxuICAgICAgICB0aXRsZUZvbnQ6IGZvbnQsXG4gICAgICAgIHRpdGxlQW5nbGU6IDAsXG4gICAgICAgIHRpdGxlWTogLTEwLFxuICAgICAgICB0aXRsZVg6IDE4LFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsRm9udFNpemU6IDEyLFxuICAgICAgICBsYWJlbEZvbnQ6IGxhYmVsRm9udCxcbiAgICAgICAgc3ltYm9sU2l6ZTogMTAwLFxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxMixcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAxMCxcbiAgICAgICAgdGl0bGVGb250OiBmb250LFxuICAgICAgICBvcmllbnQ6ICdyaWdodCcsXG4gICAgICAgIG9mZnNldDogMTAsXG4gICAgfSxcbiAgICB2aWV3OiB7XG4gICAgICAgIHN0cm9rZTogJ3RyYW5zcGFyZW50JyxcbiAgICB9LFxuICAgIHJhbmdlOiB7XG4gICAgICAgIGNhdGVnb3J5OiBjb2xvclNjaGVtZXNbJ3NpeC1ncm91cHMtY2F0LTEnXSxcbiAgICAgICAgZGl2ZXJnaW5nOiBjb2xvclNjaGVtZXNbJ2RpdmVyZ2luZy1jb2xvcnMnXSxcbiAgICAgICAgaGVhdG1hcDogY29sb3JTY2hlbWVzWydkaXZlcmdpbmctY29sb3JzJ10sXG4gICAgICAgIG9yZGluYWw6IGNvbG9yU2NoZW1lc1snc2l4LWdyb3Vwcy1zZXEnXSxcbiAgICAgICAgcmFtcDogY29sb3JTY2hlbWVzWydzaGFkZXMtYmx1ZSddLFxuICAgIH0sXG4gICAgYXJlYToge1xuICAgICAgICBmaWxsOiBtYXJrQ29sb3IkMSxcbiAgICB9LFxuICAgIHJlY3Q6IHtcbiAgICAgICAgZmlsbDogbWFya0NvbG9yJDEsXG4gICAgfSxcbiAgICBsaW5lOiB7XG4gICAgICAgIGNvbG9yOiBtYXJrQ29sb3IkMSxcbiAgICAgICAgc3Ryb2tlOiBtYXJrQ29sb3IkMSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDUsXG4gICAgfSxcbiAgICB0cmFpbDoge1xuICAgICAgICBjb2xvcjogbWFya0NvbG9yJDEsXG4gICAgICAgIHN0cm9rZTogbWFya0NvbG9yJDEsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICBzaXplOiAxLFxuICAgIH0sXG4gICAgcGF0aDoge1xuICAgICAgICBzdHJva2U6IG1hcmtDb2xvciQxLFxuICAgICAgICBzdHJva2VXaWR0aDogMC41LFxuICAgIH0sXG4gICAgcG9pbnQ6IHtcbiAgICAgICAgZmlsbGVkOiB0cnVlLFxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgICBmb250OiBzb3VyY2VGb250LFxuICAgICAgICBjb2xvcjogbWFya0NvbG9yJDEsXG4gICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICBmb250V2VpZ2h0OiA0MDAsXG4gICAgICAgIHNpemU6IDExLFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICBmaWxsOiBtYXJrQ29sb3IkMSxcbiAgICAgICAgICAgIHN0cm9rZTogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGFyYzogeyBmaWxsOiBtYXJrQ29sb3IkMSB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yJDEgfSxcbiAgICBzeW1ib2w6IHsgZmlsbDogbWFya0NvbG9yJDEsIHNpemU6IDMwIH0sXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vb3Blbi1zb3VyY2UvbGljZW5zZXMvYnNkXG4gKi9cbmNvbnN0IG1hcmtDb2xvciA9ICcjMzM2NkNDJztcbmNvbnN0IGdyaWRDb2xvciA9ICcjY2NjJztcbmNvbnN0IGRlZmF1bHRGb250ID0gJ0FyaWFsLCBzYW5zLXNlcmlmJztcbmNvbnN0IGdvb2dsZWNoYXJ0c1RoZW1lID0ge1xuICAgIGFyYzogeyBmaWxsOiBtYXJrQ29sb3IgfSxcbiAgICBhcmVhOiB7IGZpbGw6IG1hcmtDb2xvciB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IgfSxcbiAgICByZWN0OiB7IGZpbGw6IG1hcmtDb2xvciB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yIH0sXG4gICAgc3ltYm9sOiB7IHN0cm9rZTogbWFya0NvbG9yIH0sXG4gICAgY2lyY2xlOiB7IGZpbGw6IG1hcmtDb2xvciB9LFxuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogMTAsXG4gICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgYm90dG9tOiAxMCxcbiAgICAgICAgbGVmdDogMTAsXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgICAnZ3VpZGUtbGFiZWwnOiB7XG4gICAgICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgfSxcbiAgICAgICAgJ2d1aWRlLXRpdGxlJzoge1xuICAgICAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIH0sXG4gICAgICAgICdncm91cC10aXRsZSc6IHtcbiAgICAgICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICBkeTogLTMsXG4gICAgICAgIGFuY2hvcjogJ3N0YXJ0JyxcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgZ3JpZENvbG9yOiBncmlkQ29sb3IsXG4gICAgICAgIHRpY2tDb2xvcjogZ3JpZENvbG9yLFxuICAgICAgICBkb21haW46IGZhbHNlLFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgIH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IFtcbiAgICAgICAgICAgICcjNDI4NUY0JyxcbiAgICAgICAgICAgICcjREI0NDM3JyxcbiAgICAgICAgICAgICcjRjRCNDAwJyxcbiAgICAgICAgICAgICcjMEY5RDU4JyxcbiAgICAgICAgICAgICcjQUI0N0JDJyxcbiAgICAgICAgICAgICcjMDBBQ0MxJyxcbiAgICAgICAgICAgICcjRkY3MDQzJyxcbiAgICAgICAgICAgICcjOUU5RDI0JyxcbiAgICAgICAgICAgICcjNUM2QkMwJyxcbiAgICAgICAgICAgICcjRjA2MjkyJyxcbiAgICAgICAgICAgICcjMDA3OTZCJyxcbiAgICAgICAgICAgICcjQzIxODVCJyxcbiAgICAgICAgXSxcbiAgICAgICAgaGVhdG1hcDogWycjYzZkYWZjJywgJyM1ZTk3ZjYnLCAnIzJhNTZjNiddLFxuICAgIH0sXG59O1xuXG5jb25zdCBwdFRvUHggPSAodmFsdWUpID0+IHZhbHVlICogKDEgLyAzICsgMSk7XG5jb25zdCBmb250U21hbGxQeCA9IHB0VG9QeCg5KTtcbmNvbnN0IGxlZ2VuZEZvbnRQeCA9IHB0VG9QeCgxMCk7XG5jb25zdCBmb250TGFyZ2VQeCA9IHB0VG9QeCgxMik7XG5jb25zdCBmb250U3RhbmRhcmQgPSAnU2Vnb2UgVUknO1xuY29uc3QgZm9udFRpdGxlID0gJ3dmX3N0YW5kYXJkLWZvbnQsIGhlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWYnO1xuY29uc3QgZmlyc3RMZXZlbEVsZW1lbnRDb2xvciA9ICcjMjUyNDIzJztcbmNvbnN0IHNlY29uZExldmVsRWxlbWVudENvbG9yID0gJyM2MDVFNUMnO1xuY29uc3QgYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGJhY2tncm91bmRTZWNvbmRhcnlDb2xvciA9ICcjQzhDNkM0JztcbmNvbnN0IHBhbGV0dGVDb2xvcjEgPSAnIzExOERGRic7XG5jb25zdCBwYWxldHRlQ29sb3IyID0gJyMxMjIzOUUnO1xuY29uc3QgcGFsZXR0ZUNvbG9yMyA9ICcjRTY2QzM3JztcbmNvbnN0IHBhbGV0dGVDb2xvcjQgPSAnIzZCMDA3Qic7XG5jb25zdCBwYWxldHRlQ29sb3I1ID0gJyNFMDQ0QTcnO1xuY29uc3QgcGFsZXR0ZUNvbG9yNiA9ICcjNzQ0RUMyJztcbmNvbnN0IHBhbGV0dGVDb2xvcjcgPSAnI0Q5QjMwMCc7XG5jb25zdCBwYWxldHRlQ29sb3I4ID0gJyNENjQ1NTAnO1xuY29uc3QgZGl2ZXJnZW50Q29sb3JNYXggPSBwYWxldHRlQ29sb3IxO1xuY29uc3QgZGl2ZXJnZW50Q29sb3JNaW4gPSAnI0RFRUZGRic7XG5jb25zdCBkaXZlcmdlbnRQYWxldHRlID0gW2RpdmVyZ2VudENvbG9yTWluLCBkaXZlcmdlbnRDb2xvck1heF07XG5jb25zdCBvcmRpbmFsUGFsZXR0ZSA9IFtcbiAgICBkaXZlcmdlbnRDb2xvck1pbixcbiAgICAnI2M3ZTRmZicsXG4gICAgJyNiMGQ5ZmYnLFxuICAgICcjOWFjZWZmJyxcbiAgICAnIzgzYzNmZicsXG4gICAgJyM2Y2I5ZmYnLFxuICAgICcjNTVhZWZmJyxcbiAgICAnIzNmYTNmZicsXG4gICAgJyMyODk4ZmYnLFxuICAgIGRpdmVyZ2VudENvbG9yTWF4LFxuXTtcbmNvbnN0IHBvd2VyYmlUaGVtZSA9IHtcbiAgICB2aWV3OiB7IHN0cm9rZTogYmFja2dyb3VuZENvbG9yIH0sXG4gICAgYmFja2dyb3VuZDogYmFja2dyb3VuZENvbG9yLFxuICAgIGZvbnQ6IGZvbnRTdGFuZGFyZCxcbiAgICBoZWFkZXI6IHtcbiAgICAgICAgdGl0bGVGb250OiBmb250VGl0bGUsXG4gICAgICAgIHRpdGxlRm9udFNpemU6IGZvbnRMYXJnZVB4LFxuICAgICAgICB0aXRsZUNvbG9yOiBmaXJzdExldmVsRWxlbWVudENvbG9yLFxuICAgICAgICBsYWJlbEZvbnQ6IGZvbnRTdGFuZGFyZCxcbiAgICAgICAgbGFiZWxGb250U2l6ZTogbGVnZW5kRm9udFB4LFxuICAgICAgICBsYWJlbENvbG9yOiBzZWNvbmRMZXZlbEVsZW1lbnRDb2xvcixcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgdGlja3M6IGZhbHNlLFxuICAgICAgICBncmlkOiBmYWxzZSxcbiAgICAgICAgZG9tYWluOiBmYWxzZSxcbiAgICAgICAgbGFiZWxDb2xvcjogc2Vjb25kTGV2ZWxFbGVtZW50Q29sb3IsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IGZvbnRTbWFsbFB4LFxuICAgICAgICB0aXRsZUZvbnQ6IGZvbnRUaXRsZSxcbiAgICAgICAgdGl0bGVDb2xvcjogZmlyc3RMZXZlbEVsZW1lbnRDb2xvcixcbiAgICAgICAgdGl0bGVGb250U2l6ZTogZm9udExhcmdlUHgsXG4gICAgICAgIHRpdGxlRm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBheGlzUXVhbnRpdGF0aXZlOiB7XG4gICAgICAgIHRpY2tDb3VudDogMyxcbiAgICAgICAgZ3JpZDogdHJ1ZSxcbiAgICAgICAgZ3JpZENvbG9yOiBiYWNrZ3JvdW5kU2Vjb25kYXJ5Q29sb3IsXG4gICAgICAgIGdyaWREYXNoOiBbMSwgNV0sXG4gICAgICAgIGxhYmVsRmx1c2g6IGZhbHNlLFxuICAgIH0sXG4gICAgYXhpc0JhbmQ6IHsgdGlja0V4dHJhOiB0cnVlIH0sXG4gICAgYXhpc1g6IHsgbGFiZWxQYWRkaW5nOiA1IH0sXG4gICAgYXhpc1k6IHsgbGFiZWxQYWRkaW5nOiAxMCB9LFxuICAgIGJhcjogeyBmaWxsOiBwYWxldHRlQ29sb3IxIH0sXG4gICAgbGluZToge1xuICAgICAgICBzdHJva2U6IHBhbGV0dGVDb2xvcjEsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAzLFxuICAgICAgICBzdHJva2VDYXA6ICdyb3VuZCcsXG4gICAgICAgIHN0cm9rZUpvaW46ICdyb3VuZCcsXG4gICAgfSxcbiAgICB0ZXh0OiB7IGZvbnQ6IGZvbnRTdGFuZGFyZCwgZm9udFNpemU6IGZvbnRTbWFsbFB4LCBmaWxsOiBzZWNvbmRMZXZlbEVsZW1lbnRDb2xvciB9LFxuICAgIGFyYzogeyBmaWxsOiBwYWxldHRlQ29sb3IxIH0sXG4gICAgYXJlYTogeyBmaWxsOiBwYWxldHRlQ29sb3IxLCBsaW5lOiB0cnVlLCBvcGFjaXR5OiAwLjYgfSxcbiAgICBwYXRoOiB7IHN0cm9rZTogcGFsZXR0ZUNvbG9yMSB9LFxuICAgIHJlY3Q6IHsgZmlsbDogcGFsZXR0ZUNvbG9yMSB9LFxuICAgIHBvaW50OiB7IGZpbGw6IHBhbGV0dGVDb2xvcjEsIGZpbGxlZDogdHJ1ZSwgc2l6ZTogNzUgfSxcbiAgICBzaGFwZTogeyBzdHJva2U6IHBhbGV0dGVDb2xvcjEgfSxcbiAgICBzeW1ib2w6IHsgZmlsbDogcGFsZXR0ZUNvbG9yMSwgc3Ryb2tlV2lkdGg6IDEuNSwgc2l6ZTogNTAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgdGl0bGVGb250OiBmb250U3RhbmRhcmQsXG4gICAgICAgIHRpdGxlRm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICB0aXRsZUNvbG9yOiBzZWNvbmRMZXZlbEVsZW1lbnRDb2xvcixcbiAgICAgICAgbGFiZWxGb250OiBmb250U3RhbmRhcmQsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IGxlZ2VuZEZvbnRQeCxcbiAgICAgICAgbGFiZWxDb2xvcjogc2Vjb25kTGV2ZWxFbGVtZW50Q29sb3IsXG4gICAgICAgIHN5bWJvbFR5cGU6ICdjaXJjbGUnLFxuICAgICAgICBzeW1ib2xTaXplOiA3NSxcbiAgICB9LFxuICAgIHJhbmdlOiB7XG4gICAgICAgIGNhdGVnb3J5OiBbXG4gICAgICAgICAgICBwYWxldHRlQ29sb3IxLFxuICAgICAgICAgICAgcGFsZXR0ZUNvbG9yMixcbiAgICAgICAgICAgIHBhbGV0dGVDb2xvcjMsXG4gICAgICAgICAgICBwYWxldHRlQ29sb3I0LFxuICAgICAgICAgICAgcGFsZXR0ZUNvbG9yNSxcbiAgICAgICAgICAgIHBhbGV0dGVDb2xvcjYsXG4gICAgICAgICAgICBwYWxldHRlQ29sb3I3LFxuICAgICAgICAgICAgcGFsZXR0ZUNvbG9yOCxcbiAgICAgICAgXSxcbiAgICAgICAgZGl2ZXJnaW5nOiBkaXZlcmdlbnRQYWxldHRlLFxuICAgICAgICBoZWF0bWFwOiBkaXZlcmdlbnRQYWxldHRlLFxuICAgICAgICBvcmRpbmFsOiBvcmRpbmFsUGFsZXR0ZSxcbiAgICB9LFxufTtcblxuY29uc3QgdmVyc2lvbiA9IHBrZy52ZXJzaW9uO1xuXG5leHBvcnQgeyBkYXJrVGhlbWUgYXMgZGFyaywgZXhjZWxUaGVtZSBhcyBleGNlbCwgZml2ZVRoaXJ0eUVpZ2h0VGhlbWUgYXMgZml2ZXRoaXJ0eWVpZ2h0LCBnZ3Bsb3QyVGhlbWUgYXMgZ2dwbG90MiwgZ29vZ2xlY2hhcnRzVGhlbWUgYXMgZ29vZ2xlY2hhcnRzLCBsYXRpbWVzVGhlbWUgYXMgbGF0aW1lcywgcG93ZXJiaVRoZW1lIGFzIHBvd2VyYmksIHF1YXJ0elRoZW1lIGFzIHF1YXJ0eiwgdXJiYW5JbnN0aXR1dGVUaGVtZSBhcyB1cmJhbmluc3RpdHV0ZSwgdmVyc2lvbiwgdm94VGhlbWUgYXMgdm94IH07XG4iLCJpbXBvcnQgeyBpc0FycmF5LCBpc1N0cmluZywgaXNPYmplY3QgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG52YXIgbmFtZSA9IFwidmVnYS10b29sdGlwXCI7XG52YXIgdmVyc2lvbiQxID0gXCIwLjMwLjFcIjtcbnZhciBkZXNjcmlwdGlvbiA9IFwiQSB0b29sdGlwIHBsdWdpbiBmb3IgVmVnYS1MaXRlIGFuZCBWZWdhIHZpc3VhbGl6YXRpb25zLlwiO1xudmFyIGtleXdvcmRzID0gW1xuXHRcInZlZ2EtbGl0ZVwiLFxuXHRcInZlZ2FcIixcblx0XCJ0b29sdGlwXCJcbl07XG52YXIgcmVwb3NpdG9yeSA9IHtcblx0dHlwZTogXCJnaXRcIixcblx0dXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtdG9vbHRpcC5naXRcIlxufTtcbnZhciBhdXRob3IgPSB7XG5cdG5hbWU6IFwiVVcgSW50ZXJhY3RpdmUgRGF0YSBMYWJcIixcblx0dXJsOiBcImh0dHBzOi8vaWRsLmNzLndhc2hpbmd0b24uZWR1XCJcbn07XG52YXIgY29sbGFib3JhdG9ycyA9IFtcblx0XCJEb21pbmlrIE1vcml0elwiLFxuXHRcIlNpcmEgSG9ycmFkYXJuXCIsXG5cdFwiWmVuaW5nIFF1XCIsXG5cdFwiS2FuaXQgV29uZ3N1cGhhc2F3YXRcIixcblx0XCJZdXJpIEFzdHJha2hhblwiLFxuXHRcIkplZmZyZXkgSGVlclwiXG5dO1xudmFyIGxpY2Vuc2UgPSBcIkJTRC0zLUNsYXVzZVwiO1xudmFyIGJ1Z3MgPSB7XG5cdHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLXRvb2x0aXAvaXNzdWVzXCJcbn07XG52YXIgaG9tZXBhZ2UgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtdG9vbHRpcCNyZWFkbWVcIjtcbnZhciBtYWluID0gXCJidWlsZC92ZWdhLXRvb2x0aXAuanNcIjtcbnZhciBtb2R1bGUgPSBcImJ1aWxkL3ZlZ2EtdG9vbHRpcC5tb2R1bGUuanNcIjtcbnZhciB1bnBrZyA9IFwiYnVpbGQvdmVnYS10b29sdGlwLm1pbi5qc1wiO1xudmFyIGpzZGVsaXZyID0gXCJidWlsZC92ZWdhLXRvb2x0aXAubWluLmpzXCI7XG52YXIgdHlwZXMgPSBcImJ1aWxkL3ZlZ2EtdG9vbHRpcC5tb2R1bGUuZC50c1wiO1xudmFyIGZpbGVzID0gW1xuXHRcInNyY1wiLFxuXHRcImJ1aWxkXCIsXG5cdFwidHlwZXNcIlxuXTtcbnZhciBzY3JpcHRzID0ge1xuXHRwcmVidWlsZDogXCJ5YXJuIGNsZWFuICYmIHlhcm4gYnVpbGQ6c3R5bGVcIixcblx0YnVpbGQ6IFwicm9sbHVwIC1jXCIsXG5cdFwiYnVpbGQ6c3R5bGVcIjogXCIuL2J1aWxkLXN0eWxlLnNoXCIsXG5cdGNsZWFuOiBcInJpbXJhZiBidWlsZCAmJiByaW1yYWYgc3JjL3N0eWxlLnRzXCIsXG5cdFwiY29weTpkYXRhXCI6IFwicnN5bmMgLXIgbm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YXNldHMvZGF0YS8qIGV4YW1wbGVzL2RhdGFcIixcblx0XCJjb3B5OmJ1aWxkXCI6IFwicnN5bmMgLXIgYnVpbGQvKiBleGFtcGxlcy9idWlsZFwiLFxuXHRcImRlcGxveTpnaFwiOiBcInlhcm4gYnVpbGQgJiYgeWFybiBjb3B5OmJ1aWxkICYmIGdoLXBhZ2VzIC1kIGV4YW1wbGVzICYmIHlhcm4gY2xlYW5cIixcblx0cHJlcHVibGlzaE9ubHk6IFwieWFybiBjbGVhbiAmJiB5YXJuIGJ1aWxkXCIsXG5cdHByZXZlcnNpb246IFwieWFybiBsaW50ICYmIHlhcm4gdGVzdFwiLFxuXHRzZXJ2ZTogXCJicm93c2VyLXN5bmMgc3RhcnQgLXMgLWYgYnVpbGQgZXhhbXBsZXMgLS1zZXJ2ZVN0YXRpYyBleGFtcGxlc1wiLFxuXHRzdGFydDogXCJ5YXJuIGJ1aWxkICYmIGNvbmN1cnJlbnRseSAtLWtpbGwtb3RoZXJzIC1uIFNlcnZlcixSb2xsdXAgJ3lhcm4gc2VydmUnICdyb2xsdXAgLWMgLXcnXCIsXG5cdHByZXRlc3Q6IFwieWFybiBidWlsZDpzdHlsZVwiLFxuXHR0ZXN0OiBcImJlZW1vIGplc3RcIixcblx0XCJ0ZXN0Omluc3BlY3RcIjogXCJub2RlIC0taW5zcGVjdC1icmsgLi9ub2RlX21vZHVsZXMvLmJpbi9qZXN0IC0tcnVuSW5CYW5kXCIsXG5cdHByZXBhcmU6IFwiYmVlbW8gY3JlYXRlLWNvbmZpZyAmJiB5YXJuIGNvcHk6ZGF0YVwiLFxuXHRwcmV0dGllcmJhc2U6IFwiYmVlbW8gcHJldHRpZXIgJyoue2NzcyxzY3NzLGh0bWx9J1wiLFxuXHRlc2xpbnRiYXNlOiBcImJlZW1vIGVzbGludCAuXCIsXG5cdGZvcm1hdDogXCJ5YXJuIGVzbGludGJhc2UgLS1maXggJiYgeWFybiBwcmV0dGllcmJhc2UgLS13cml0ZVwiLFxuXHRsaW50OiBcInlhcm4gZXNsaW50YmFzZSAmJiB5YXJuIHByZXR0aWVyYmFzZSAtLWNoZWNrXCIsXG5cdHJlbGVhc2U6IFwicmVsZWFzZS1pdFwiXG59O1xudmFyIGRldkRlcGVuZGVuY2llcyA9IHtcblx0XCJAcmVsZWFzZS1pdC9jb252ZW50aW9uYWwtY2hhbmdlbG9nXCI6IFwiXjUuMS4xXCIsXG5cdFwiQHJvbGx1cC9wbHVnaW4tanNvblwiOiBcIl42LjAuMFwiLFxuXHRcIkByb2xsdXAvcGx1Z2luLW5vZGUtcmVzb2x2ZVwiOiBcIl4xNS4wLjFcIixcblx0XCJyZWxlYXNlLWl0XCI6IFwiXjE1LjYuMFwiLFxuXHRcImJyb3dzZXItc3luY1wiOiBcIl4yLjI3LjExXCIsXG5cdGNvbmN1cnJlbnRseTogXCJeNy42LjBcIixcblx0XCJnaC1wYWdlc1wiOiBcIl41LjAuMFwiLFxuXHRcImplc3QtZW52aXJvbm1lbnQtanNkb21cIjogXCJeMjkuNC4yXCIsXG5cdHBhdGg6IFwiXjAuMTIuN1wiLFxuXHRyb2xsdXA6IFwiXjMuMTUuMFwiLFxuXHRcInJvbGx1cC1wbHVnaW4tYnVuZGxlLXNpemVcIjogXCJeMS4wLjNcIixcblx0XCJAcm9sbHVwL3BsdWdpbi10ZXJzZXJcIjogXCJeMC40LjBcIixcblx0XCJyb2xsdXAtcGx1Z2luLXRzXCI6IFwiXjMuMi4wXCIsXG5cdHNhc3M6IFwiXjEuNTguMFwiLFxuXHR0eXBlc2NyaXB0OiBcIn40LjkuNVwiLFxuXHRcInZlZ2EtZGF0YXNldHNcIjogXCJeMi41LjRcIixcblx0XCJ2ZWdhLWxpdGUtZGV2LWNvbmZpZ1wiOiBcIl4wLjIxLjBcIixcblx0XCJ2ZWdhLXR5cGluZ3NcIjogXCJeMC4yMi4zXCJcbn07XG52YXIgZGVwZW5kZW5jaWVzID0ge1xuXHRcInZlZ2EtdXRpbFwiOiBcIl4xLjE3LjBcIlxufTtcbnZhciBwa2cgPSB7XG5cdG5hbWU6IG5hbWUsXG5cdHZlcnNpb246IHZlcnNpb24kMSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRrZXl3b3Jkczoga2V5d29yZHMsXG5cdHJlcG9zaXRvcnk6IHJlcG9zaXRvcnksXG5cdGF1dGhvcjogYXV0aG9yLFxuXHRjb2xsYWJvcmF0b3JzOiBjb2xsYWJvcmF0b3JzLFxuXHRsaWNlbnNlOiBsaWNlbnNlLFxuXHRidWdzOiBidWdzLFxuXHRob21lcGFnZTogaG9tZXBhZ2UsXG5cdG1haW46IG1haW4sXG5cdG1vZHVsZTogbW9kdWxlLFxuXHR1bnBrZzogdW5wa2csXG5cdGpzZGVsaXZyOiBqc2RlbGl2cixcblx0dHlwZXM6IHR5cGVzLFxuXHRmaWxlczogZmlsZXMsXG5cdHNjcmlwdHM6IHNjcmlwdHMsXG5cdGRldkRlcGVuZGVuY2llczogZGV2RGVwZW5kZW5jaWVzLFxuXHRkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llc1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxuLyoqXG4gKiBGb3JtYXQgdGhlIHZhbHVlIHRvIGJlIHNob3duIGluIHRoZSB0b29sdGlwLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2hvdyBpbiB0aGUgdG9vbHRpcC5cbiAqIEBwYXJhbSB2YWx1ZVRvSHRtbCBGdW5jdGlvbiB0byBjb252ZXJ0IGEgc2luZ2xlIGNlbGwgdmFsdWUgdG8gYW4gSFRNTCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHZhbHVlVG9IdG1sLCBtYXhEZXB0aCkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYFske3ZhbHVlLm1hcCgodikgPT4gdmFsdWVUb0h0bWwoaXNTdHJpbmcodikgPyB2IDogc3RyaW5naWZ5KHYsIG1heERlcHRoKSkpLmpvaW4oJywgJyl9XWA7XG4gICAgfVxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgICAgY29uc3QgX2EgPSB2YWx1ZSwgeyB0aXRsZSwgaW1hZ2UgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0aXRsZVwiLCBcImltYWdlXCJdKTtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGA8aDI+JHt2YWx1ZVRvSHRtbCh0aXRsZSl9PC9oMj5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgY29udGVudCArPSBgPGltZyBzcmM9XCIke3ZhbHVlVG9IdG1sKGltYWdlKX1cIj5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZXN0KTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udGVudCArPSAnPHRhYmxlPic7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IHJlc3Rba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdW5kZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHN0cmluZ2lmeSh2YWwsIG1heERlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBgPHRyPjx0ZCBjbGFzcz1cImtleVwiPiR7dmFsdWVUb0h0bWwoa2V5KX06PC90ZD48dGQgY2xhc3M9XCJ2YWx1ZVwiPiR7dmFsdWVUb0h0bWwodmFsKX08L3RkPjwvdHI+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYDwvdGFibGU+YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudCB8fCAne30nOyAvLyBzaG93IGVtcHR5IG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gcHJvcGVydGllc1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVUb0h0bWwodmFsdWUpO1xufVxuZnVuY3Rpb24gcmVwbGFjZXIobWF4RGVwdGgpIHtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcyA9IHN0YWNrLmluZGV4T2YodGhpcykgKyAxO1xuICAgICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiBtYXhEZXB0aCkge1xuICAgICAgICAgICAgcmV0dXJuICdbT2JqZWN0XSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBTdHJpbmdpZnkgYW55IEpTIG9iamVjdCB0byB2YWxpZCBKU09OXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIobWF4RGVwdGgpKTtcbn1cblxuLy8gZ2VuZXJhdGVkIHdpdGggYnVpbGQtc3R5bGUuc2hcbnZhciBkZWZhdWx0U3R5bGUgPSBgI3ZnLXRvb2x0aXAtZWxlbWVudCB7XG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgcGFkZGluZzogOHB4O1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHotaW5kZXg6IDEwMDA7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBmb250LXNpemU6IDExcHg7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgYm94LXNoYWRvdzogMnB4IDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAvKiBUaGUgZGVmYXVsdCB0aGVtZSBpcyB0aGUgbGlnaHQgdGhlbWUuICovXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSk7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNkOWQ5ZDk7XG4gIGNvbG9yOiBibGFjaztcbn1cbiN2Zy10b29sdGlwLWVsZW1lbnQudmlzaWJsZSB7XG4gIHZpc2liaWxpdHk6IHZpc2libGU7XG59XG4jdmctdG9vbHRpcC1lbGVtZW50IGgyIHtcbiAgbWFyZ2luLXRvcDogMDtcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgZm9udC1zaXplOiAxM3B4O1xufVxuI3ZnLXRvb2x0aXAtZWxlbWVudCBpbWcge1xuICBtYXgtd2lkdGg6IDIwMHB4O1xuICBtYXgtaGVpZ2h0OiAyMDBweDtcbn1cbiN2Zy10b29sdGlwLWVsZW1lbnQgdGFibGUge1xuICBib3JkZXItc3BhY2luZzogMDtcbn1cbiN2Zy10b29sdGlwLWVsZW1lbnQgdGFibGUgdHIge1xuICBib3JkZXI6IG5vbmU7XG59XG4jdmctdG9vbHRpcC1lbGVtZW50IHRhYmxlIHRyIHRkIHtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gIHBhZGRpbmctdG9wOiAycHg7XG4gIHBhZGRpbmctYm90dG9tOiAycHg7XG59XG4jdmctdG9vbHRpcC1lbGVtZW50IHRhYmxlIHRyIHRkLmtleSB7XG4gIGNvbG9yOiAjODA4MDgwO1xuICBtYXgtd2lkdGg6IDE1MHB4O1xuICB0ZXh0LWFsaWduOiByaWdodDtcbiAgcGFkZGluZy1yaWdodDogNHB4O1xufVxuI3ZnLXRvb2x0aXAtZWxlbWVudCB0YWJsZSB0ciB0ZC52YWx1ZSB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtYXgtd2lkdGg6IDMwMHB4O1xuICBtYXgtaGVpZ2h0OiA3ZW07XG4gIHRleHQtYWxpZ246IGxlZnQ7XG59XG4jdmctdG9vbHRpcC1lbGVtZW50LmRhcmstdGhlbWUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDMyLCAzMiwgMzIsIDAuOSk7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNmNWY1ZjU7XG4gIGNvbG9yOiB3aGl0ZTtcbn1cbiN2Zy10b29sdGlwLWVsZW1lbnQuZGFyay10aGVtZSB0ZC5rZXkge1xuICBjb2xvcjogI2JmYmZiZjtcbn1cbmA7XG5cbmNvbnN0IEVMX0lEID0gJ3ZnLXRvb2x0aXAtZWxlbWVudCc7XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLyoqXG4gICAgICogWCBvZmZzZXQuXG4gICAgICovXG4gICAgb2Zmc2V0WDogMTAsXG4gICAgLyoqXG4gICAgICogWSBvZmZzZXQuXG4gICAgICovXG4gICAgb2Zmc2V0WTogMTAsXG4gICAgLyoqXG4gICAgICogSUQgb2YgdGhlIHRvb2x0aXAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBpZDogRUxfSUQsXG4gICAgLyoqXG4gICAgICogSUQgb2YgdGhlIHRvb2x0aXAgQ1NTIHN0eWxlLlxuICAgICAqL1xuICAgIHN0eWxlSWQ6ICd2ZWdhLXRvb2x0aXAtc3R5bGUnLFxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0aGVtZS4gWW91IGNhbiB1c2UgdGhlIENTUyBjbGFzcyBjYWxsZWQgW1RIRU1FXS10aGVtZSB0byBzdHlsZSB0aGUgdG9vbHRpcHMuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHByZWRlZmluZWQgdGhlbWVzOiBcImxpZ2h0XCIgKGRlZmF1bHQpIGFuZCBcImRhcmtcIi5cbiAgICAgKi9cbiAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAvKipcbiAgICAgKiBEbyBub3QgdXNlIHRoZSBkZWZhdWx0IHN0eWxlcyBwcm92aWRlZCBieSBWZWdhIFRvb2x0aXAuIElmIHlvdSBlbmFibGUgdGhpcyBvcHRpb24sIHlvdSBuZWVkIHRvIHVzZSB5b3VyIG93biBzdHlsZXMuIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gZGlzYWJsZSB0aGUgZGVmYXVsdCBzdHlsZSB3aGVuIHVzaW5nIGEgY3VzdG9tIHRoZW1lLlxuICAgICAqL1xuICAgIGRpc2FibGVEZWZhdWx0U3R5bGU6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEhUTUwgc2FuaXRpemVyIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyBkYW5nZXJvdXMgSFRNTCB0byBwcmV2ZW50IFhTUy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGEgZnVuY3Rpb24gZnJvbSBzdHJpbmcgdG8gc3RyaW5nLiBZb3UgbWF5IHJlcGxhY2UgaXQgd2l0aCBhIGZvcm1hdHRlciBzdWNoIGFzIGEgbWFya2Rvd24gZm9ybWF0dGVyLlxuICAgICAqL1xuICAgIHNhbml0aXplOiBlc2NhcGVIVE1MLFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aCB3aGVuIHByaW50aW5nIG9iamVjdHMgaW4gdGhlIHRvb2x0aXAuXG4gICAgICovXG4gICAgbWF4RGVwdGg6IDIsXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byBjdXN0b21pemUgdGhlIHJlbmRlcmVkIEhUTUwgb2YgdGhlIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgc3RyaW5nLCBvciBvYmplY3Qgb2YgdmFsdWUgc3RyaW5ncyBrZXllZCBieSBmaWVsZFxuICAgICAqIEBwYXJhbSBzYW5pdGl6ZSBUaGUgYHNhbml0aXplYCBmdW5jdGlvbiBmcm9tIGBvcHRpb25zLnNhbml0aXplYFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXR1cm5lZCBzdHJpbmcgd2lsbCBiZWNvbWUgdGhlIGBpbm5lckhUTUxgIG9mIHRoZSB0b29sdGlwIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmb3JtYXRUb29sdGlwOiBmb3JtYXRWYWx1ZSxcbn07XG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIEhUTUwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0byBjb252ZXJ0IHRvIHN0cmluZyBhbmQgSFRNTC1lc2NhcGUuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUhUTUwodmFsdWUpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdHlsZShpZCkge1xuICAgIC8vIEp1c3QgaW4gY2FzZSB0aGlzIGlkIGNvbWVzIGZyb20gYSB1c2VyLCBlbnN1cmUgdGhlc2UgaXMgbm8gc2VjdXJpdHkgaXNzdWVzXG4gICAgaWYgKCEvXltBLVphLXpdK1stOi5cXHddKiQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBIVE1MIElEJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3R5bGUudG9TdHJpbmcoKS5yZXBsYWNlKEVMX0lELCBpZCk7XG59XG5cbi8qKlxuICogUG9zaXRpb24gdGhlIHRvb2x0aXBcbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIG1vdXNlIGV2ZW50LlxuICogQHBhcmFtIHRvb2x0aXBCb3hcbiAqIEBwYXJhbSBvZmZzZXRYIEhvcml6b250YWwgb2Zmc2V0LlxuICogQHBhcmFtIG9mZnNldFkgVmVydGljYWwgb2Zmc2V0LlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbihldmVudCwgdG9vbHRpcEJveCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIGxldCB4ID0gZXZlbnQuY2xpZW50WCArIG9mZnNldFg7XG4gICAgaWYgKHggKyB0b29sdGlwQm94LndpZHRoID4gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICAgICAgeCA9ICtldmVudC5jbGllbnRYIC0gb2Zmc2V0WCAtIHRvb2x0aXBCb3gud2lkdGg7XG4gICAgfVxuICAgIGxldCB5ID0gZXZlbnQuY2xpZW50WSArIG9mZnNldFk7XG4gICAgaWYgKHkgKyB0b29sdGlwQm94LmhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICB5ID0gK2V2ZW50LmNsaWVudFkgLSBvZmZzZXRZIC0gdG9vbHRpcEJveC5oZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cblxuLyoqXG4gKiBUaGUgdG9vbHRpcCBoYW5kbGVyIGNsYXNzLlxuICovXG5jbGFzcyBIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRvb2x0aXAgaGFuZGxlciBhbmQgaW5pdGlhbGl6ZSB0aGUgZWxlbWVudCBhbmQgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUb29sdGlwIE9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRJZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgICAgIC8vIGJpbmQgdGhpcyB0byBjYWxsXG4gICAgICAgIHRoaXMuY2FsbCA9IHRoaXMudG9vbHRpcEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gcHJlcGVuZCBhIGRlZmF1bHQgc3R5bGVzaGVldCBmb3IgdG9vbHRpcHMgdG8gdGhlIGhlYWRcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZURlZmF1bHRTdHlsZSAmJiAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLnN0eWxlSWQpKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5vcHRpb25zLnN0eWxlSWQpO1xuICAgICAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gY3JlYXRlRGVmYXVsdFN0eWxlKGVsZW1lbnRJZCk7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgIGlmIChoZWFkLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRvb2x0aXAgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB0b29sdGlwSGFuZGxlcihoYW5kbGVyLCBldmVudCwgaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coaGFuZGxlciwgZXZlbnQsIGl0ZW0sIHZhbHVlKTtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBhcHBlbmQgYSBkaXYgZWxlbWVudCB0aGF0IHdlIHVzZSBhcyBhIHRvb2x0aXAgdW5sZXNzIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuaWQpO1xuICAgICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMub3B0aW9ucy5pZCk7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3ZnLXRvb2x0aXAnKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBDb250YWluZXIgPSAoX2EgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIHRvb2x0aXBDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGlkZSB0b29sdGlwIGZvciBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZXNcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnLCBgJHt0aGlzLm9wdGlvbnMudGhlbWV9LXRoZW1lYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuZm9ybWF0VG9vbHRpcCh2YWx1ZSwgdGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMubWF4RGVwdGgpO1xuICAgICAgICAvLyBtYWtlIHRoZSB0b29sdGlwIHZpc2libGVcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJywgYCR7dGhpcy5vcHRpb25zLnRoZW1lfS10aGVtZWApO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGNhbGN1bGF0ZVBvc2l0aW9uKGV2ZW50LCB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLm9wdGlvbnMub2Zmc2V0WCwgdGhpcy5vcHRpb25zLm9mZnNldFkpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgICB9XG59XG5cbmNvbnN0IHZlcnNpb24gPSBwa2cudmVyc2lvbjtcbi8qKlxuICogQ3JlYXRlIGEgdG9vbHRpcCBoYW5kbGVyIGFuZCByZWdpc3RlciBpdCB3aXRoIHRoZSBwcm92aWRlZCB2aWV3LlxuICpcbiAqIEBwYXJhbSB2aWV3IFRoZSBWZWdhIHZpZXcuXG4gKiBAcGFyYW0gb3B0IFRvb2x0aXAgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gaW5kZXggKHZpZXcsIG9wdCkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgSGFuZGxlcihvcHQpO1xuICAgIHZpZXcudG9vbHRpcChoYW5kbGVyLmNhbGwpLnJ1bigpO1xuICAgIHJldHVybiBoYW5kbGVyO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX09QVElPTlMsIEhhbmRsZXIsIGNhbGN1bGF0ZVBvc2l0aW9uLCBjcmVhdGVEZWZhdWx0U3R5bGUsIGluZGV4IGFzIGRlZmF1bHQsIGVzY2FwZUhUTUwsIGZvcm1hdFZhbHVlLCByZXBsYWNlciwgc3RyaW5naWZ5LCB2ZXJzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWdhLXRvb2x0aXAubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9