"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_webidl_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/webidl.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/webidl.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   webIDL: () => (/* binding */ webIDL)
/* harmony export */ });
function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b");
};

var builtinArray = [
  "Clamp",
  "Constructor",
  "EnforceRange",
  "Exposed",
  "ImplicitThis",
  "Global", "PrimaryGlobal",
  "LegacyArrayClass",
  "LegacyUnenumerableNamedProperties",
  "LenientThis",
  "NamedConstructor",
  "NewObject",
  "NoInterfaceObject",
  "OverrideBuiltins",
  "PutForwards",
  "Replaceable",
  "SameObject",
  "TreatNonObjectAsNull",
  "TreatNullAs",
    "EmptyString",
  "Unforgeable",
  "Unscopeable"
];
var builtins = wordRegexp(builtinArray);

var typeArray = [
  "unsigned", "short", "long",                  // UnsignedIntegerType
  "unrestricted", "float", "double",            // UnrestrictedFloatType
  "boolean", "byte", "octet",                   // Rest of PrimitiveType
  "Promise",                                    // PromiseType
  "ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array",
  "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray",
  "Float32Array", "Float64Array",               // BufferRelatedType
  "ByteString", "DOMString", "USVString", "sequence", "object", "RegExp",
  "Error", "DOMException", "FrozenArray",       // Rest of NonAnyType
  "any",                                        // Rest of SingleType
  "void"                                        // Rest of ReturnType
];
var types = wordRegexp(typeArray);

var keywordArray = [
  "attribute", "callback", "const", "deleter", "dictionary", "enum", "getter",
  "implements", "inherit", "interface", "iterable", "legacycaller", "maplike",
  "partial", "required", "serializer", "setlike", "setter", "static",
  "stringifier", "typedef",                     // ArgumentNameKeyword except
                                                // "unrestricted"
  "optional", "readonly", "or"
];
var keywords = wordRegexp(keywordArray);

var atomArray = [
  "true", "false",                              // BooleanLiteral
  "Infinity", "NaN",                            // FloatLiteral
  "null"                                        // Rest of ConstValue
];
var atoms = wordRegexp(atomArray);

var startDefArray = ["callback", "dictionary", "enum", "interface"];
var startDefs = wordRegexp(startDefArray);

var endDefArray = ["typedef"];
var endDefs = wordRegexp(endDefArray);

var singleOperators = /^[:<=>?]/;
var integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;
var floats = /^-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;
var identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;
var identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\s*;)/;
var strings = /^"[^"]*"/;
var multilineComments = /^\/\*.*?\*\//;
var multilineCommentsStart = /^\/\*.*/;
var multilineCommentsEnd = /^.*?\*\//;

function readToken(stream, state) {
  // whitespace
  if (stream.eatSpace()) return null;

  // comment
  if (state.inComment) {
    if (stream.match(multilineCommentsEnd)) {
      state.inComment = false;
      return "comment";
    }
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match("//")) {
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match(multilineComments)) return "comment";
  if (stream.match(multilineCommentsStart)) {
    state.inComment = true;
    return "comment";
  }

  // integer and float
  if (stream.match(/^-?[0-9\.]/, false)) {
    if (stream.match(integers) || stream.match(floats)) return "number";
  }

  // string
  if (stream.match(strings)) return "string";

  // identifier
  if (state.startDef && stream.match(identifiers)) return "def";

  if (state.endDef && stream.match(identifiersEnd)) {
    state.endDef = false;
    return "def";
  }

  if (stream.match(keywords)) return "keyword";

  if (stream.match(types)) {
    var lastToken = state.lastToken;
    var nextToken = (stream.match(/^\s*(.+?)\b/, false) || [])[1];

    if (lastToken === ":" || lastToken === "implements" ||
        nextToken === "implements" || nextToken === "=") {
      // Used as identifier
      return "builtin";
    } else {
      // Used as type
      return "type";
    }
  }

  if (stream.match(builtins)) return "builtin";
  if (stream.match(atoms)) return "atom";
  if (stream.match(identifiers)) return "variable";

  // other
  if (stream.match(singleOperators)) return "operator";

  // unrecognized
  stream.next();
  return null;
};

const webIDL = {
  name: "webidl",
  startState: function() {
    return {
      // Is in multiline comment
      inComment: false,
      // Last non-whitespace, matched token
      lastToken: "",
      // Next token is a definition
      startDef: false,
      // Last token of the statement is a definition
      endDef: false
    };
  },
  token: function(stream, state) {
    var style = readToken(stream, state);

    if (style) {
      var cur = stream.current();
      state.lastToken = cur;
      if (style === "keyword") {
        state.startDef = startDefs.test(cur);
        state.endDef = state.endDef || endDefs.test(cur);
      } else {
        state.startDef = false;
      }
    }

    return style;
  },

  languageData: {
    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfd2ViaWRsX2pzLmNlNGQ2MWYwYjk5ZjdlNTk2MTc5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvd2ViaWRsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG59O1xuXG52YXIgYnVpbHRpbkFycmF5ID0gW1xuICBcIkNsYW1wXCIsXG4gIFwiQ29uc3RydWN0b3JcIixcbiAgXCJFbmZvcmNlUmFuZ2VcIixcbiAgXCJFeHBvc2VkXCIsXG4gIFwiSW1wbGljaXRUaGlzXCIsXG4gIFwiR2xvYmFsXCIsIFwiUHJpbWFyeUdsb2JhbFwiLFxuICBcIkxlZ2FjeUFycmF5Q2xhc3NcIixcbiAgXCJMZWdhY3lVbmVudW1lcmFibGVOYW1lZFByb3BlcnRpZXNcIixcbiAgXCJMZW5pZW50VGhpc1wiLFxuICBcIk5hbWVkQ29uc3RydWN0b3JcIixcbiAgXCJOZXdPYmplY3RcIixcbiAgXCJOb0ludGVyZmFjZU9iamVjdFwiLFxuICBcIk92ZXJyaWRlQnVpbHRpbnNcIixcbiAgXCJQdXRGb3J3YXJkc1wiLFxuICBcIlJlcGxhY2VhYmxlXCIsXG4gIFwiU2FtZU9iamVjdFwiLFxuICBcIlRyZWF0Tm9uT2JqZWN0QXNOdWxsXCIsXG4gIFwiVHJlYXROdWxsQXNcIixcbiAgICBcIkVtcHR5U3RyaW5nXCIsXG4gIFwiVW5mb3JnZWFibGVcIixcbiAgXCJVbnNjb3BlYWJsZVwiXG5dO1xudmFyIGJ1aWx0aW5zID0gd29yZFJlZ2V4cChidWlsdGluQXJyYXkpO1xuXG52YXIgdHlwZUFycmF5ID0gW1xuICBcInVuc2lnbmVkXCIsIFwic2hvcnRcIiwgXCJsb25nXCIsICAgICAgICAgICAgICAgICAgLy8gVW5zaWduZWRJbnRlZ2VyVHlwZVxuICBcInVucmVzdHJpY3RlZFwiLCBcImZsb2F0XCIsIFwiZG91YmxlXCIsICAgICAgICAgICAgLy8gVW5yZXN0cmljdGVkRmxvYXRUeXBlXG4gIFwiYm9vbGVhblwiLCBcImJ5dGVcIiwgXCJvY3RldFwiLCAgICAgICAgICAgICAgICAgICAvLyBSZXN0IG9mIFByaW1pdGl2ZVR5cGVcbiAgXCJQcm9taXNlXCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvbWlzZVR5cGVcbiAgXCJBcnJheUJ1ZmZlclwiLCBcIkRhdGFWaWV3XCIsIFwiSW50OEFycmF5XCIsIFwiSW50MTZBcnJheVwiLCBcIkludDMyQXJyYXlcIixcbiAgXCJVaW50OEFycmF5XCIsIFwiVWludDE2QXJyYXlcIiwgXCJVaW50MzJBcnJheVwiLCBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiRmxvYXQzMkFycmF5XCIsIFwiRmxvYXQ2NEFycmF5XCIsICAgICAgICAgICAgICAgLy8gQnVmZmVyUmVsYXRlZFR5cGVcbiAgXCJCeXRlU3RyaW5nXCIsIFwiRE9NU3RyaW5nXCIsIFwiVVNWU3RyaW5nXCIsIFwic2VxdWVuY2VcIiwgXCJvYmplY3RcIiwgXCJSZWdFeHBcIixcbiAgXCJFcnJvclwiLCBcIkRPTUV4Y2VwdGlvblwiLCBcIkZyb3plbkFycmF5XCIsICAgICAgIC8vIFJlc3Qgb2YgTm9uQW55VHlwZVxuICBcImFueVwiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0IG9mIFNpbmdsZVR5cGVcbiAgXCJ2b2lkXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdCBvZiBSZXR1cm5UeXBlXG5dO1xudmFyIHR5cGVzID0gd29yZFJlZ2V4cCh0eXBlQXJyYXkpO1xuXG52YXIga2V5d29yZEFycmF5ID0gW1xuICBcImF0dHJpYnV0ZVwiLCBcImNhbGxiYWNrXCIsIFwiY29uc3RcIiwgXCJkZWxldGVyXCIsIFwiZGljdGlvbmFyeVwiLCBcImVudW1cIiwgXCJnZXR0ZXJcIixcbiAgXCJpbXBsZW1lbnRzXCIsIFwiaW5oZXJpdFwiLCBcImludGVyZmFjZVwiLCBcIml0ZXJhYmxlXCIsIFwibGVnYWN5Y2FsbGVyXCIsIFwibWFwbGlrZVwiLFxuICBcInBhcnRpYWxcIiwgXCJyZXF1aXJlZFwiLCBcInNlcmlhbGl6ZXJcIiwgXCJzZXRsaWtlXCIsIFwic2V0dGVyXCIsIFwic3RhdGljXCIsXG4gIFwic3RyaW5naWZpZXJcIiwgXCJ0eXBlZGVmXCIsICAgICAgICAgICAgICAgICAgICAgLy8gQXJndW1lbnROYW1lS2V5d29yZCBleGNlcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwidW5yZXN0cmljdGVkXCJcbiAgXCJvcHRpb25hbFwiLCBcInJlYWRvbmx5XCIsIFwib3JcIlxuXTtcbnZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAoa2V5d29yZEFycmF5KTtcblxudmFyIGF0b21BcnJheSA9IFtcbiAgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuTGl0ZXJhbFxuICBcIkluZmluaXR5XCIsIFwiTmFOXCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb2F0TGl0ZXJhbFxuICBcIm51bGxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0IG9mIENvbnN0VmFsdWVcbl07XG52YXIgYXRvbXMgPSB3b3JkUmVnZXhwKGF0b21BcnJheSk7XG5cbnZhciBzdGFydERlZkFycmF5ID0gW1wiY2FsbGJhY2tcIiwgXCJkaWN0aW9uYXJ5XCIsIFwiZW51bVwiLCBcImludGVyZmFjZVwiXTtcbnZhciBzdGFydERlZnMgPSB3b3JkUmVnZXhwKHN0YXJ0RGVmQXJyYXkpO1xuXG52YXIgZW5kRGVmQXJyYXkgPSBbXCJ0eXBlZGVmXCJdO1xudmFyIGVuZERlZnMgPSB3b3JkUmVnZXhwKGVuZERlZkFycmF5KTtcblxudmFyIHNpbmdsZU9wZXJhdG9ycyA9IC9eWzo8PT4/XS87XG52YXIgaW50ZWdlcnMgPSAvXi0/KFsxLTldWzAtOV0qfDBbWHhdWzAtOUEtRmEtZl0rfDBbMC03XSopLztcbnZhciBmbG9hdHMgPSAvXi0/KChbMC05XStcXC5bMC05XSp8WzAtOV0qXFwuWzAtOV0rKShbRWVdWystXT9bMC05XSspP3xbMC05XStbRWVdWystXT9bMC05XSspLztcbnZhciBpZGVudGlmaWVycyA9IC9eXz9bQS1aYS16XVswLTlBLVpfYS16LV0qLztcbnZhciBpZGVudGlmaWVyc0VuZCA9IC9eXz9bQS1aYS16XVswLTlBLVpfYS16LV0qKD89XFxzKjspLztcbnZhciBzdHJpbmdzID0gL15cIlteXCJdKlwiLztcbnZhciBtdWx0aWxpbmVDb21tZW50cyA9IC9eXFwvXFwqLio/XFwqXFwvLztcbnZhciBtdWx0aWxpbmVDb21tZW50c1N0YXJ0ID0gL15cXC9cXCouKi87XG52YXIgbXVsdGlsaW5lQ29tbWVudHNFbmQgPSAvXi4qP1xcKlxcLy87XG5cbmZ1bmN0aW9uIHJlYWRUb2tlbihzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIHdoaXRlc3BhY2VcbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAvLyBjb21tZW50XG4gIGlmIChzdGF0ZS5pbkNvbW1lbnQpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKG11bHRpbGluZUNvbW1lbnRzRW5kKSkge1xuICAgICAgc3RhdGUuaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cbiAgaWYgKHN0cmVhbS5tYXRjaChcIi8vXCIpKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKG11bHRpbGluZUNvbW1lbnRzKSkgcmV0dXJuIFwiY29tbWVudFwiO1xuICBpZiAoc3RyZWFtLm1hdGNoKG11bHRpbGluZUNvbW1lbnRzU3RhcnQpKSB7XG4gICAgc3RhdGUuaW5Db21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICAvLyBpbnRlZ2VyIGFuZCBmbG9hdFxuICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9bMC05XFwuXS8sIGZhbHNlKSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goaW50ZWdlcnMpIHx8IHN0cmVhbS5tYXRjaChmbG9hdHMpKSByZXR1cm4gXCJudW1iZXJcIjtcbiAgfVxuXG4gIC8vIHN0cmluZ1xuICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ3MpKSByZXR1cm4gXCJzdHJpbmdcIjtcblxuICAvLyBpZGVudGlmaWVyXG4gIGlmIChzdGF0ZS5zdGFydERlZiAmJiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKSByZXR1cm4gXCJkZWZcIjtcblxuICBpZiAoc3RhdGUuZW5kRGVmICYmIHN0cmVhbS5tYXRjaChpZGVudGlmaWVyc0VuZCkpIHtcbiAgICBzdGF0ZS5lbmREZWYgPSBmYWxzZTtcbiAgICByZXR1cm4gXCJkZWZcIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgaWYgKHN0cmVhbS5tYXRjaCh0eXBlcykpIHtcbiAgICB2YXIgbGFzdFRva2VuID0gc3RhdGUubGFzdFRva2VuO1xuICAgIHZhciBuZXh0VG9rZW4gPSAoc3RyZWFtLm1hdGNoKC9eXFxzKiguKz8pXFxiLywgZmFsc2UpIHx8IFtdKVsxXTtcblxuICAgIGlmIChsYXN0VG9rZW4gPT09IFwiOlwiIHx8IGxhc3RUb2tlbiA9PT0gXCJpbXBsZW1lbnRzXCIgfHxcbiAgICAgICAgbmV4dFRva2VuID09PSBcImltcGxlbWVudHNcIiB8fCBuZXh0VG9rZW4gPT09IFwiPVwiKSB7XG4gICAgICAvLyBVc2VkIGFzIGlkZW50aWZpZXJcbiAgICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlZCBhcyB0eXBlXG4gICAgICByZXR1cm4gXCJ0eXBlXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChidWlsdGlucykpIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgaWYgKHN0cmVhbS5tYXRjaChhdG9tcykpIHJldHVybiBcImF0b21cIjtcbiAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHJldHVybiBcInZhcmlhYmxlXCI7XG5cbiAgLy8gb3RoZXJcbiAgaWYgKHN0cmVhbS5tYXRjaChzaW5nbGVPcGVyYXRvcnMpKSByZXR1cm4gXCJvcGVyYXRvclwiO1xuXG4gIC8vIHVucmVjb2duaXplZFxuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCB3ZWJJREwgPSB7XG4gIG5hbWU6IFwid2ViaWRsXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBJcyBpbiBtdWx0aWxpbmUgY29tbWVudFxuICAgICAgaW5Db21tZW50OiBmYWxzZSxcbiAgICAgIC8vIExhc3Qgbm9uLXdoaXRlc3BhY2UsIG1hdGNoZWQgdG9rZW5cbiAgICAgIGxhc3RUb2tlbjogXCJcIixcbiAgICAgIC8vIE5leHQgdG9rZW4gaXMgYSBkZWZpbml0aW9uXG4gICAgICBzdGFydERlZjogZmFsc2UsXG4gICAgICAvLyBMYXN0IHRva2VuIG9mIHRoZSBzdGF0ZW1lbnQgaXMgYSBkZWZpbml0aW9uXG4gICAgICBlbmREZWY6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSByZWFkVG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgc3RhdGUubGFzdFRva2VuID0gY3VyO1xuICAgICAgaWYgKHN0eWxlID09PSBcImtleXdvcmRcIikge1xuICAgICAgICBzdGF0ZS5zdGFydERlZiA9IHN0YXJ0RGVmcy50ZXN0KGN1cik7XG4gICAgICAgIHN0YXRlLmVuZERlZiA9IHN0YXRlLmVuZERlZiB8fCBlbmREZWZzLnRlc3QoY3VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnN0YXJ0RGVmID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGF1dG9jb21wbGV0ZTogYnVpbHRpbkFycmF5LmNvbmNhdCh0eXBlQXJyYXkpLmNvbmNhdChrZXl3b3JkQXJyYXkpLmNvbmNhdChhdG9tQXJyYXkpXG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=