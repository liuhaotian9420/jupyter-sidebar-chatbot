"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_dylan_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/dylan.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/dylan.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dylan: () => (/* binding */ dylan)
/* harmony export */ });
function forEach(arr, f) {
  for (var i = 0; i < arr.length; i++) f(arr[i], i)
}
function some(arr, f) {
  for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true
  return false
}

// Words
var words = {
  // Words that introduce unnamed definitions like "define interface"
  unnamedDefinition: ["interface"],

  // Words that introduce simple named definitions like "define library"
  namedDefinition: ["module", "library", "macro",
                    "C-struct", "C-union",
                    "C-function", "C-callable-wrapper"
                   ],

  // Words that introduce type definitions like "define class".
  // These are also parameterized like "define method" and are
  // appended to otherParameterizedDefinitionWords
  typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

  // Words that introduce trickier definitions like "define method".
  // These require special definitions to be added to startExpressions
  otherParameterizedDefinition: ["method", "function",
                                 "C-variable", "C-address"
                                ],

  // Words that introduce module constant definitions.
  // These must also be simple definitions and are
  // appended to otherSimpleDefinitionWords
  constantSimpleDefinition: ["constant"],

  // Words that introduce module variable definitions.
  // These must also be simple definitions and are
  // appended to otherSimpleDefinitionWords
  variableSimpleDefinition: ["variable"],

  // Other words that introduce simple definitions
  // (without implicit bodies).
  otherSimpleDefinition: ["generic", "domain",
                          "C-pointer-type",
                          "table"
                         ],

  // Words that begin statements with implicit bodies.
  statement: ["if", "block", "begin", "method", "case",
              "for", "select", "when", "unless", "until",
              "while", "iterate", "profiling", "dynamic-bind"
             ],

  // Patterns that act as separators in compound statements.
  // This may include any general pattern that must be indented
  // specially.
  separator: ["finally", "exception", "cleanup", "else",
              "elseif", "afterwards"
             ],

  // Keywords that do not require special indentation handling,
  // but which should be highlighted
  other: ["above", "below", "by", "from", "handler", "in",
          "instance", "let", "local", "otherwise", "slot",
          "subclass", "then", "to", "keyed-by", "virtual"
         ],

  // Condition signaling function calls
  signalingCalls: ["signal", "error", "cerror",
                   "break", "check-type", "abort"
                  ]
};

words["otherDefinition"] =
  words["unnamedDefinition"]
  .concat(words["namedDefinition"])
  .concat(words["otherParameterizedDefinition"]);

words["definition"] =
  words["typeParameterizedDefinition"]
  .concat(words["otherDefinition"]);

words["parameterizedDefinition"] =
  words["typeParameterizedDefinition"]
  .concat(words["otherParameterizedDefinition"]);

words["simpleDefinition"] =
  words["constantSimpleDefinition"]
  .concat(words["variableSimpleDefinition"])
  .concat(words["otherSimpleDefinition"]);

words["keyword"] =
  words["statement"]
  .concat(words["separator"])
  .concat(words["other"]);

// Patterns
var symbolPattern = "[-_a-zA-Z?!*@<>$%]+";
var symbol = new RegExp("^" + symbolPattern);
var patterns = {
  // Symbols with special syntax
  symbolKeyword: symbolPattern + ":",
  symbolClass: "<" + symbolPattern + ">",
  symbolGlobal: "\\*" + symbolPattern + "\\*",
  symbolConstant: "\\$" + symbolPattern
};
var patternStyles = {
  symbolKeyword: "atom",
  symbolClass: "tag",
  symbolGlobal: "variableName.standard",
  symbolConstant: "variableName.constant"
};

// Compile all patterns to regular expressions
for (var patternName in patterns)
  if (patterns.hasOwnProperty(patternName))
    patterns[patternName] = new RegExp("^" + patterns[patternName]);

// Names beginning "with-" and "without-" are commonly
// used as statement macro
patterns["keyword"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];

var styles = {};
styles["keyword"] = "keyword";
styles["definition"] = "def";
styles["simpleDefinition"] = "def";
styles["signalingCalls"] = "builtin";

// protected words lookup table
var wordLookup = {};
var styleLookup = {};

forEach([
  "keyword",
  "definition",
  "simpleDefinition",
  "signalingCalls"
], function(type) {
  forEach(words[type], function(word) {
    wordLookup[word] = type;
    styleLookup[word] = styles[type];
  });
});


function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

function tokenBase(stream, state) {
  // String
  var ch = stream.peek();
  if (ch == "'" || ch == '"') {
    stream.next();
    return chain(stream, state, tokenString(ch, "string"));
  }
  // Comment
  else if (ch == "/") {
    stream.next();
    if (stream.eat("*")) {
      return chain(stream, state, tokenComment);
    } else if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
    stream.backUp(1);
  }
  // Decimal
  else if (/[+\-\d\.]/.test(ch)) {
    if (stream.match(/^[+-]?[0-9]*\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||
        stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||
        stream.match(/^[+-]?\d+/)) {
      return "number";
    }
  }
  // Hash
  else if (ch == "#") {
    stream.next();
    // Symbol with string syntax
    ch = stream.peek();
    if (ch == '"') {
      stream.next();
      return chain(stream, state, tokenString('"', "string"));
    }
    // Binary number
    else if (ch == "b") {
      stream.next();
      stream.eatWhile(/[01]/);
      return "number";
    }
    // Hex number
    else if (ch == "x") {
      stream.next();
      stream.eatWhile(/[\da-f]/i);
      return "number";
    }
    // Octal number
    else if (ch == "o") {
      stream.next();
      stream.eatWhile(/[0-7]/);
      return "number";
    }
    // Token concatenation in macros
    else if (ch == '#') {
      stream.next();
      return "punctuation";
    }
    // Sequence literals
    else if ((ch == '[') || (ch == '(')) {
      stream.next();
      return "bracket";
      // Hash symbol
    } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {
      return "atom";
    } else {
      stream.eatWhile(/[-a-zA-Z]/);
      return "error";
    }
  } else if (ch == "~") {
    stream.next();
    ch = stream.peek();
    if (ch == "=") {
      stream.next();
      ch = stream.peek();
      if (ch == "=") {
        stream.next();
        return "operator";
      }
      return "operator";
    }
    return "operator";
  } else if (ch == ":") {
    stream.next();
    ch = stream.peek();
    if (ch == "=") {
      stream.next();
      return "operator";
    } else if (ch == ":") {
      stream.next();
      return "punctuation";
    }
  } else if ("[](){}".indexOf(ch) != -1) {
    stream.next();
    return "bracket";
  } else if (".,".indexOf(ch) != -1) {
    stream.next();
    return "punctuation";
  } else if (stream.match("end")) {
    return "keyword";
  }
  for (var name in patterns) {
    if (patterns.hasOwnProperty(name)) {
      var pattern = patterns[name];
      if ((pattern instanceof Array && some(pattern, function(p) {
        return stream.match(p);
      })) || stream.match(pattern))
        return patternStyles[name];
    }
  }
  if (/[+\-*\/^=<>&|]/.test(ch)) {
    stream.next();
    return "operator";
  }
  if (stream.match("define")) {
    return "def";
  } else {
    stream.eatWhile(/[\w\-]/);
    // Keyword
    if (wordLookup.hasOwnProperty(stream.current())) {
      return styleLookup[stream.current()];
    } else if (stream.current().match(symbol)) {
      return "variable";
    } else {
      stream.next();
      return "variableName.standard";
    }
  }
}

function tokenComment(stream, state) {
  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
  while ((ch = stream.next())) {
    if (ch == "/" && maybeEnd) {
      if (nestedCount > 0) {
        nestedCount--;
      } else {
        state.tokenize = tokenBase;
        break;
      }
    } else if (ch == "*" && maybeNested) {
      nestedCount++;
    }
    maybeEnd = (ch == "*");
    maybeNested = (ch == "/");
  }
  return "comment";
}

function tokenString(quote, style) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    if (end || !escaped) {
      state.tokenize = tokenBase;
    }
    return style;
  };
}

// Interface
const dylan = {
  name: "dylan",
  startState: function() {
    return {
      tokenize: tokenBase,
      currentIndent: 0
    };
  },
  token: function(stream, state) {
    if (stream.eatSpace())
      return null;
    var style = state.tokenize(stream, state);
    return style;
  },
  languageData: {
    commentTokens: {block: {open: "/*", close: "*/"}}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZHlsYW5fanMuYzg4ZTNhYmJjZjRkMmE5YjFhYzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2R5bGFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGZvckVhY2goYXJyLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmKGFycltpXSwgaSlcbn1cbmZ1bmN0aW9uIHNvbWUoYXJyLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBpZiAoZihhcnJbaV0sIGkpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gV29yZHNcbnZhciB3b3JkcyA9IHtcbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgdW5uYW1lZCBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIGludGVyZmFjZVwiXG4gIHVubmFtZWREZWZpbml0aW9uOiBbXCJpbnRlcmZhY2VcIl0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2Ugc2ltcGxlIG5hbWVkIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgbGlicmFyeVwiXG4gIG5hbWVkRGVmaW5pdGlvbjogW1wibW9kdWxlXCIsIFwibGlicmFyeVwiLCBcIm1hY3JvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQy1zdHJ1Y3RcIiwgXCJDLXVuaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQy1mdW5jdGlvblwiLCBcIkMtY2FsbGFibGUtd3JhcHBlclwiXG4gICAgICAgICAgICAgICAgICAgXSxcblxuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSB0eXBlIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgY2xhc3NcIi5cbiAgLy8gVGhlc2UgYXJlIGFsc28gcGFyYW1ldGVyaXplZCBsaWtlIFwiZGVmaW5lIG1ldGhvZFwiIGFuZCBhcmVcbiAgLy8gYXBwZW5kZWQgdG8gb3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbldvcmRzXG4gIHR5cGVQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbjogW1wiY2xhc3NcIiwgXCJDLXN1YnR5cGVcIiwgXCJDLW1hcHBlZC1zdWJ0eXBlXCJdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHRyaWNraWVyIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgbWV0aG9kXCIuXG4gIC8vIFRoZXNlIHJlcXVpcmUgc3BlY2lhbCBkZWZpbml0aW9ucyB0byBiZSBhZGRlZCB0byBzdGFydEV4cHJlc3Npb25zXG4gIG90aGVyUGFyYW1ldGVyaXplZERlZmluaXRpb246IFtcIm1ldGhvZFwiLCBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkMtdmFyaWFibGVcIiwgXCJDLWFkZHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIG1vZHVsZSBjb25zdGFudCBkZWZpbml0aW9ucy5cbiAgLy8gVGhlc2UgbXVzdCBhbHNvIGJlIHNpbXBsZSBkZWZpbml0aW9ucyBhbmQgYXJlXG4gIC8vIGFwcGVuZGVkIHRvIG90aGVyU2ltcGxlRGVmaW5pdGlvbldvcmRzXG4gIGNvbnN0YW50U2ltcGxlRGVmaW5pdGlvbjogW1wiY29uc3RhbnRcIl0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgbW9kdWxlIHZhcmlhYmxlIGRlZmluaXRpb25zLlxuICAvLyBUaGVzZSBtdXN0IGFsc28gYmUgc2ltcGxlIGRlZmluaXRpb25zIGFuZCBhcmVcbiAgLy8gYXBwZW5kZWQgdG8gb3RoZXJTaW1wbGVEZWZpbml0aW9uV29yZHNcbiAgdmFyaWFibGVTaW1wbGVEZWZpbml0aW9uOiBbXCJ2YXJpYWJsZVwiXSxcblxuICAvLyBPdGhlciB3b3JkcyB0aGF0IGludHJvZHVjZSBzaW1wbGUgZGVmaW5pdGlvbnNcbiAgLy8gKHdpdGhvdXQgaW1wbGljaXQgYm9kaWVzKS5cbiAgb3RoZXJTaW1wbGVEZWZpbml0aW9uOiBbXCJnZW5lcmljXCIsIFwiZG9tYWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiQy1wb2ludGVyLXR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgXSxcblxuICAvLyBXb3JkcyB0aGF0IGJlZ2luIHN0YXRlbWVudHMgd2l0aCBpbXBsaWNpdCBib2RpZXMuXG4gIHN0YXRlbWVudDogW1wiaWZcIiwgXCJibG9ja1wiLCBcImJlZ2luXCIsIFwibWV0aG9kXCIsIFwiY2FzZVwiLFxuICAgICAgICAgICAgICBcImZvclwiLCBcInNlbGVjdFwiLCBcIndoZW5cIiwgXCJ1bmxlc3NcIiwgXCJ1bnRpbFwiLFxuICAgICAgICAgICAgICBcIndoaWxlXCIsIFwiaXRlcmF0ZVwiLCBcInByb2ZpbGluZ1wiLCBcImR5bmFtaWMtYmluZFwiXG4gICAgICAgICAgICAgXSxcblxuICAvLyBQYXR0ZXJucyB0aGF0IGFjdCBhcyBzZXBhcmF0b3JzIGluIGNvbXBvdW5kIHN0YXRlbWVudHMuXG4gIC8vIFRoaXMgbWF5IGluY2x1ZGUgYW55IGdlbmVyYWwgcGF0dGVybiB0aGF0IG11c3QgYmUgaW5kZW50ZWRcbiAgLy8gc3BlY2lhbGx5LlxuICBzZXBhcmF0b3I6IFtcImZpbmFsbHlcIiwgXCJleGNlcHRpb25cIiwgXCJjbGVhbnVwXCIsIFwiZWxzZVwiLFxuICAgICAgICAgICAgICBcImVsc2VpZlwiLCBcImFmdGVyd2FyZHNcIlxuICAgICAgICAgICAgIF0sXG5cbiAgLy8gS2V5d29yZHMgdGhhdCBkbyBub3QgcmVxdWlyZSBzcGVjaWFsIGluZGVudGF0aW9uIGhhbmRsaW5nLFxuICAvLyBidXQgd2hpY2ggc2hvdWxkIGJlIGhpZ2hsaWdodGVkXG4gIG90aGVyOiBbXCJhYm92ZVwiLCBcImJlbG93XCIsIFwiYnlcIiwgXCJmcm9tXCIsIFwiaGFuZGxlclwiLCBcImluXCIsXG4gICAgICAgICAgXCJpbnN0YW5jZVwiLCBcImxldFwiLCBcImxvY2FsXCIsIFwib3RoZXJ3aXNlXCIsIFwic2xvdFwiLFxuICAgICAgICAgIFwic3ViY2xhc3NcIiwgXCJ0aGVuXCIsIFwidG9cIiwgXCJrZXllZC1ieVwiLCBcInZpcnR1YWxcIlxuICAgICAgICAgXSxcblxuICAvLyBDb25kaXRpb24gc2lnbmFsaW5nIGZ1bmN0aW9uIGNhbGxzXG4gIHNpZ25hbGluZ0NhbGxzOiBbXCJzaWduYWxcIiwgXCJlcnJvclwiLCBcImNlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgIFwiYnJlYWtcIiwgXCJjaGVjay10eXBlXCIsIFwiYWJvcnRcIlxuICAgICAgICAgICAgICAgICAgXVxufTtcblxud29yZHNbXCJvdGhlckRlZmluaXRpb25cIl0gPVxuICB3b3Jkc1tcInVubmFtZWREZWZpbml0aW9uXCJdXG4gIC5jb25jYXQod29yZHNbXCJuYW1lZERlZmluaXRpb25cIl0pXG4gIC5jb25jYXQod29yZHNbXCJvdGhlclBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdKTtcblxud29yZHNbXCJkZWZpbml0aW9uXCJdID1cbiAgd29yZHNbXCJ0eXBlUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl1cbiAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyRGVmaW5pdGlvblwiXSk7XG5cbndvcmRzW1wicGFyYW1ldGVyaXplZERlZmluaXRpb25cIl0gPVxuICB3b3Jkc1tcInR5cGVQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXSk7XG5cbndvcmRzW1wic2ltcGxlRGVmaW5pdGlvblwiXSA9XG4gIHdvcmRzW1wiY29uc3RhbnRTaW1wbGVEZWZpbml0aW9uXCJdXG4gIC5jb25jYXQod29yZHNbXCJ2YXJpYWJsZVNpbXBsZURlZmluaXRpb25cIl0pXG4gIC5jb25jYXQod29yZHNbXCJvdGhlclNpbXBsZURlZmluaXRpb25cIl0pO1xuXG53b3Jkc1tcImtleXdvcmRcIl0gPVxuICB3b3Jkc1tcInN0YXRlbWVudFwiXVxuICAuY29uY2F0KHdvcmRzW1wic2VwYXJhdG9yXCJdKVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJcIl0pO1xuXG4vLyBQYXR0ZXJuc1xudmFyIHN5bWJvbFBhdHRlcm4gPSBcIlstX2EtekEtWj8hKkA8PiQlXStcIjtcbnZhciBzeW1ib2wgPSBuZXcgUmVnRXhwKFwiXlwiICsgc3ltYm9sUGF0dGVybik7XG52YXIgcGF0dGVybnMgPSB7XG4gIC8vIFN5bWJvbHMgd2l0aCBzcGVjaWFsIHN5bnRheFxuICBzeW1ib2xLZXl3b3JkOiBzeW1ib2xQYXR0ZXJuICsgXCI6XCIsXG4gIHN5bWJvbENsYXNzOiBcIjxcIiArIHN5bWJvbFBhdHRlcm4gKyBcIj5cIixcbiAgc3ltYm9sR2xvYmFsOiBcIlxcXFwqXCIgKyBzeW1ib2xQYXR0ZXJuICsgXCJcXFxcKlwiLFxuICBzeW1ib2xDb25zdGFudDogXCJcXFxcJFwiICsgc3ltYm9sUGF0dGVyblxufTtcbnZhciBwYXR0ZXJuU3R5bGVzID0ge1xuICBzeW1ib2xLZXl3b3JkOiBcImF0b21cIixcbiAgc3ltYm9sQ2xhc3M6IFwidGFnXCIsXG4gIHN5bWJvbEdsb2JhbDogXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIixcbiAgc3ltYm9sQ29uc3RhbnQ6IFwidmFyaWFibGVOYW1lLmNvbnN0YW50XCJcbn07XG5cbi8vIENvbXBpbGUgYWxsIHBhdHRlcm5zIHRvIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbmZvciAodmFyIHBhdHRlcm5OYW1lIGluIHBhdHRlcm5zKVxuICBpZiAocGF0dGVybnMuaGFzT3duUHJvcGVydHkocGF0dGVybk5hbWUpKVxuICAgIHBhdHRlcm5zW3BhdHRlcm5OYW1lXSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuc1twYXR0ZXJuTmFtZV0pO1xuXG4vLyBOYW1lcyBiZWdpbm5pbmcgXCJ3aXRoLVwiIGFuZCBcIndpdGhvdXQtXCIgYXJlIGNvbW1vbmx5XG4vLyB1c2VkIGFzIHN0YXRlbWVudCBtYWNyb1xucGF0dGVybnNbXCJrZXl3b3JkXCJdID0gWy9ed2l0aCg/Om91dCk/LVstX2EtekEtWj8hKkA8PiQlXSsvXTtcblxudmFyIHN0eWxlcyA9IHt9O1xuc3R5bGVzW1wia2V5d29yZFwiXSA9IFwia2V5d29yZFwiO1xuc3R5bGVzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmXCI7XG5zdHlsZXNbXCJzaW1wbGVEZWZpbml0aW9uXCJdID0gXCJkZWZcIjtcbnN0eWxlc1tcInNpZ25hbGluZ0NhbGxzXCJdID0gXCJidWlsdGluXCI7XG5cbi8vIHByb3RlY3RlZCB3b3JkcyBsb29rdXAgdGFibGVcbnZhciB3b3JkTG9va3VwID0ge307XG52YXIgc3R5bGVMb29rdXAgPSB7fTtcblxuZm9yRWFjaChbXG4gIFwia2V5d29yZFwiLFxuICBcImRlZmluaXRpb25cIixcbiAgXCJzaW1wbGVEZWZpbml0aW9uXCIsXG4gIFwic2lnbmFsaW5nQ2FsbHNcIlxuXSwgZnVuY3Rpb24odHlwZSkge1xuICBmb3JFYWNoKHdvcmRzW3R5cGVdLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgd29yZExvb2t1cFt3b3JkXSA9IHR5cGU7XG4gICAgc3R5bGVMb29rdXBbd29yZF0gPSBzdHlsZXNbdHlwZV07XG4gIH0pO1xufSk7XG5cblxuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBTdHJpbmdcbiAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCwgXCJzdHJpbmdcIikpO1xuICB9XG4gIC8vIENvbW1lbnRcbiAgZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuQ29tbWVudCk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICB9XG4gIC8vIERlY2ltYWxcbiAgZWxzZSBpZiAoL1srXFwtXFxkXFwuXS8udGVzdChjaCkpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWystXT9bMC05XSpcXC5bMC05XSooW2VzZHhdWystXT9bMC05XSspPy9pKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goL15bKy1dP1swLTldKyhbZXNkeF1bKy1dP1swLTldKykvaSkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eWystXT9cXGQrLykpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgfVxuICAvLyBIYXNoXG4gIGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICAvLyBTeW1ib2wgd2l0aCBzdHJpbmcgc3ludGF4XG4gICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKCdcIicsIFwic3RyaW5nXCIpKTtcbiAgICB9XG4gICAgLy8gQmluYXJ5IG51bWJlclxuICAgIGVsc2UgaWYgKGNoID09IFwiYlwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bMDFdLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gSGV4IG51bWJlclxuICAgIGVsc2UgaWYgKGNoID09IFwieFwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkYS1mXS9pKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICAvLyBPY3RhbCBudW1iZXJcbiAgICBlbHNlIGlmIChjaCA9PSBcIm9cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzAtN10vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICAvLyBUb2tlbiBjb25jYXRlbmF0aW9uIGluIG1hY3Jvc1xuICAgIGVsc2UgaWYgKGNoID09ICcjJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gICAgfVxuICAgIC8vIFNlcXVlbmNlIGxpdGVyYWxzXG4gICAgZWxzZSBpZiAoKGNoID09ICdbJykgfHwgKGNoID09ICcoJykpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICAvLyBIYXNoIHN5bWJvbFxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9mfHR8YWxsLWtleXN8aW5jbHVkZXxrZXl8bmV4dHxyZXN0L2kpKSB7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWy1hLXpBLVpdLyk7XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaCA9PSBcIn5cIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwiW10oKXt9XCIuaW5kZXhPZihjaCkgIT0gLTEpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgfSBlbHNlIGlmIChcIi4sXCIuaW5kZXhPZihjaCkgIT0gLTEpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiZW5kXCIpKSB7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gcGF0dGVybnMpIHtcbiAgICBpZiAocGF0dGVybnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbbmFtZV07XG4gICAgICBpZiAoKHBhdHRlcm4gaW5zdGFuY2VvZiBBcnJheSAmJiBzb21lKHBhdHRlcm4sIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaChwKTtcbiAgICAgIH0pKSB8fCBzdHJlYW0ubWF0Y2gocGF0dGVybikpXG4gICAgICAgIHJldHVybiBwYXR0ZXJuU3R5bGVzW25hbWVdO1xuICAgIH1cbiAgfVxuICBpZiAoL1srXFwtKlxcL149PD4mfF0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG4gIGlmIChzdHJlYW0ubWF0Y2goXCJkZWZpbmVcIikpIHtcbiAgICByZXR1cm4gXCJkZWZcIjtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC1dLyk7XG4gICAgLy8gS2V5d29yZFxuICAgIGlmICh3b3JkTG9va3VwLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICByZXR1cm4gc3R5bGVMb29rdXBbc3RyZWFtLmN1cnJlbnQoKV07XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpLm1hdGNoKHN5bWJvbCkpIHtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIG1heWJlTmVzdGVkID0gZmFsc2UsIG5lc3RlZENvdW50ID0gMCwgY2g7XG4gIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgaWYgKG5lc3RlZENvdW50ID4gMCkge1xuICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIqXCIgJiYgbWF5YmVOZXN0ZWQpIHtcbiAgICAgIG5lc3RlZENvdW50Kys7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICBtYXliZU5lc3RlZCA9IChjaCA9PSBcIi9cIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSwgc3R5bGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICBpZiAoZW5kIHx8ICFlc2NhcGVkKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG4vLyBJbnRlcmZhY2VcbmV4cG9ydCBjb25zdCBkeWxhbiA9IHtcbiAgbmFtZTogXCJkeWxhblwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGN1cnJlbnRJbmRlbnQ6IDBcbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2Jsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9