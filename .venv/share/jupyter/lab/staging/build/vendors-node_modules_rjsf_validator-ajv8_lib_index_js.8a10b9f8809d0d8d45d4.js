"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_rjsf_validator-ajv8_lib_index_js"],{

/***/ "./node_modules/@rjsf/validator-ajv8/lib/createAjvInstance.js":
/*!********************************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/createAjvInstance.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AJV_CONFIG: () => (/* binding */ AJV_CONFIG),
/* harmony export */   COLOR_FORMAT_REGEX: () => (/* binding */ COLOR_FORMAT_REGEX),
/* harmony export */   DATA_URL_FORMAT_REGEX: () => (/* binding */ DATA_URL_FORMAT_REGEX),
/* harmony export */   "default": () => (/* binding */ createAjvInstance)
/* harmony export */ });
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ajv */ "./node_modules/ajv/dist/ajv.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ajv_formats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ajv-formats */ "./node_modules/ajv-formats/dist/index.js");
/* harmony import */ var ajv_formats__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ajv_formats__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_3__);




const AJV_CONFIG = {
    allErrors: true,
    multipleOfPrecision: 8,
    strict: false,
    verbose: true,
};
const COLOR_FORMAT_REGEX = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/;
const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.
 * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the
 * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If
 * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing
 * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By
 * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`
 * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of
 * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.
 *
 * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access
 * @param [customFormats] - The set of additional custom formats that the validator will support
 * @param [ajvOptionsOverrides={}] - The set of validator config override options
 * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it
 * @param [AjvClass] - The `Ajv` class to use when creating the validator instance
 */
function createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides = {}, ajvFormatOptions, AjvClass = (ajv__WEBPACK_IMPORTED_MODULE_0___default())) {
    const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });
    if (ajvFormatOptions) {
        ajv_formats__WEBPACK_IMPORTED_MODULE_1___default()(ajv, ajvFormatOptions);
    }
    else if (ajvFormatOptions !== false) {
        ajv_formats__WEBPACK_IMPORTED_MODULE_1___default()(ajv);
    }
    // add custom formats
    ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);
    ajv.addFormat('color', COLOR_FORMAT_REGEX);
    // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.
    ajv.addKeyword(_rjsf_utils__WEBPACK_IMPORTED_MODULE_3__.ADDITIONAL_PROPERTY_FLAG);
    ajv.addKeyword(_rjsf_utils__WEBPACK_IMPORTED_MODULE_3__.RJSF_ADDITONAL_PROPERTIES_FLAG);
    // add more schemas to validate against
    if (Array.isArray(additionalMetaSchemas)) {
        ajv.addMetaSchema(additionalMetaSchemas);
    }
    // add more custom formats to validate against
    if (lodash_isObject__WEBPACK_IMPORTED_MODULE_2___default()(customFormats)) {
        Object.keys(customFormats).forEach((formatName) => {
            ajv.addFormat(formatName, customFormats[formatName]);
        });
    }
    return ajv;
}
//# sourceMappingURL=createAjvInstance.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/createPrecompiledValidator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/createPrecompiledValidator.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createPrecompiledValidator)
/* harmony export */ });
/* harmony import */ var _precompiledValidator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./precompiledValidator */ "./node_modules/@rjsf/validator-ajv8/lib/precompiledValidator.js");

/** Creates and returns a `ValidatorType` interface that is implemented with a precompiled validator. If a `localizer`
 * is provided, it is used to translate the messages generated by the underlying AJV validation.
 *
 * NOTE: The `validateFns` parameter is an object obtained by importing from a precompiled validation file created via
 * the `compileSchemaValidators()` function.
 *
 * @param validateFns - The map of the validation functions that are created by the `compileSchemaValidators()` function
 * @param rootSchema - The root schema that was used with the `compileSchemaValidators()` function
 * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
 * @returns - The precompiled validator implementation resulting from the set of parameters provided
 */
function createPrecompiledValidator(validateFns, rootSchema, localizer) {
    return new _precompiledValidator__WEBPACK_IMPORTED_MODULE_0__["default"](validateFns, rootSchema, localizer);
}
//# sourceMappingURL=createPrecompiledValidator.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/customizeValidator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/customizeValidator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ customizeValidator)
/* harmony export */ });
/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validator */ "./node_modules/@rjsf/validator-ajv8/lib/validator.js");

/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if
 * provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV
 * validation.
 *
 * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance
 * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
 * @returns - The custom validator implementation resulting from the set of parameters provided
 */
function customizeValidator(options = {}, localizer) {
    return new _validator__WEBPACK_IMPORTED_MODULE_0__["default"](options, localizer);
}
//# sourceMappingURL=customizeValidator.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPrecompiledValidator: () => (/* reexport safe */ _createPrecompiledValidator__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   customizeValidator: () => (/* reexport safe */ _customizeValidator__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _customizeValidator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./customizeValidator */ "./node_modules/@rjsf/validator-ajv8/lib/customizeValidator.js");
/* harmony import */ var _createPrecompiledValidator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createPrecompiledValidator */ "./node_modules/@rjsf/validator-ajv8/lib/createPrecompiledValidator.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/@rjsf/validator-ajv8/lib/types.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_customizeValidator__WEBPACK_IMPORTED_MODULE_0__["default"])());
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/precompiledValidator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/precompiledValidator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AJV8PrecompiledValidator)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js");
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _processRawValidationErrors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./processRawValidationErrors */ "./node_modules/@rjsf/validator-ajv8/lib/processRawValidationErrors.js");




/** `ValidatorType` implementation that uses an AJV 8 precompiled validator as created by the
 * `compileSchemaValidators()` function provided by the `@rjsf/validator-ajv8` library.
 */
class AJV8PrecompiledValidator {
    /** Constructs an `AJV8PrecompiledValidator` instance using the `validateFns` and `rootSchema`
     *
     * @param validateFns - The map of the validation functions that are generated by the `schemaCompile()` function
     * @param rootSchema - The root schema that was used with the `compileSchema()` function
     * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
     * @throws - Error when the base schema of the precompiled validator does not have a matching validator function
     */
    constructor(validateFns, rootSchema, localizer) {
        this.rootSchema = rootSchema;
        this.validateFns = validateFns;
        this.localizer = localizer;
        this.mainValidator = this.getValidator(rootSchema);
    }
    /** Returns the precompiled validator associated with the given `schema` from the map of precompiled validator
     * functions.
     *
     * @param schema - The schema for which a precompiled validator function is desired
     * @returns - The precompiled validator function associated with this schema
     */
    getValidator(schema) {
        const key = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ID_KEY) || (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.hashForSchema)(schema);
        const validator = this.validateFns[key];
        if (!validator) {
            throw new Error(`No precompiled validator function was found for the given schema for "${key}"`);
        }
        return validator;
    }
    /** Ensures that the validator is using the same schema as the root schema used to construct the precompiled
     * validator. It first compares the given `schema` against the root schema and if they aren't the same, then it
     * checks against the resolved root schema, on the chance that a resolved version of the root schema was passed in
     * instead of the raw root schema.
     *
     * @param schema - The schema against which to validate the form data
     * @param [formData] - The form data to validate if any
     */
    ensureSameRootSchema(schema, formData) {
        if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(schema, this.rootSchema)) {
            // Resolve the root schema with the passed in form data since that may affect the resolution
            const resolvedRootSchema = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.retrieveSchema)(this, this.rootSchema, this.rootSchema, formData);
            if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_1___default()(schema, resolvedRootSchema)) {
                throw new Error('The schema associated with the precompiled validator differs from the rootSchema provided for validation');
            }
        }
        return true;
    }
    /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
     *
     * @param errorSchema - The `ErrorSchema` instance to convert
     * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
     * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in
     *        the next major release.
     */
    toErrorList(errorSchema, fieldPath = []) {
        return (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.toErrorList)(errorSchema, fieldPath);
    }
    /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
     * by the playground. Returns the `errors` from the validation
     *
     * @param schema - The schema against which to validate the form data
     * @param [formData] - The form data to validate, if any
     * @throws - Error when the schema provided does not match the base schema of the precompiled validator
     */
    rawValidation(schema, formData) {
        this.ensureSameRootSchema(schema, formData);
        this.mainValidator(formData);
        if (typeof this.localizer === 'function') {
            this.localizer(this.mainValidator.errors);
        }
        const errors = this.mainValidator.errors || undefined;
        // Clear errors to prevent persistent errors, see #1104
        this.mainValidator.errors = null;
        return { errors: errors };
    }
    /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
     * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
     * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
     * transform them in what ever way it chooses.
     *
     * @param formData - The form data to validate
     * @param schema - The schema against which to validate the form data
     * @param [customValidate] - An optional function that is used to perform custom validation
     * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
     * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
     */
    validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {
        const rawErrors = this.rawValidation(schema, formData);
        return (0,_processRawValidationErrors__WEBPACK_IMPORTED_MODULE_3__["default"])(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);
    }
    /** Validates data against a schema, returning true if the data is valid, or false otherwise. If the schema is
     * invalid, then this function will return false.
     *
     * @param schema - The schema against which to validate the form data
     * @param formData - The form data to validate
     * @param rootSchema - The root schema used to provide $ref resolutions
     * @returns - true if the formData validates against the schema, false otherwise
     * @throws - Error when the schema provided does not match the base schema of the precompiled validator OR if there
     *        isn't a precompiled validator function associated with the schema
     */
    isValid(schema, formData, rootSchema) {
        this.ensureSameRootSchema(rootSchema, formData);
        if (lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(schema, _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ID_KEY) === _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.JUNK_OPTION_ID) {
            return false;
        }
        const validator = this.getValidator(schema);
        return validator(formData);
    }
}
//# sourceMappingURL=precompiledValidator.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/processRawValidationErrors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/processRawValidationErrors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ processRawValidationErrors),
/* harmony export */   transformRJSFValidationErrors: () => (/* binding */ transformRJSFValidationErrors)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** Transforming the error output from ajv to format used by @rjsf/utils.
 * At some point, components should be updated to support ajv.
 *
 * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`
 * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
 */
function transformRJSFValidationErrors(errors = [], uiSchema) {
    return errors.map((e) => {
        const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;
        let { message = '' } = rest;
        let property = instancePath.replace(/\//g, '.');
        let stack = `${property} ${message}`.trim();
        if ('missingProperty' in params) {
            property = property ? `${property}.${params.missingProperty}` : params.missingProperty;
            const currentProperty = params.missingProperty;
            const uiSchemaTitle = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(uiSchema, `${property.replace(/^\./, '')}`)).title;
            if (uiSchemaTitle) {
                message = message.replace(currentProperty, uiSchemaTitle);
            }
            else {
                const parentSchemaTitle = lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(parentSchema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.PROPERTIES_KEY, currentProperty, 'title']);
                if (parentSchemaTitle) {
                    message = message.replace(currentProperty, parentSchemaTitle);
                }
            }
            stack = message;
        }
        else {
            const uiSchemaTitle = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(uiSchema, `${property.replace(/^\./, '')}`)).title;
            if (uiSchemaTitle) {
                stack = `'${uiSchemaTitle}' ${message}`.trim();
            }
            else {
                const parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;
                if (parentSchemaTitle) {
                    stack = `'${parentSchemaTitle}' ${message}`.trim();
                }
            }
        }
        // put data in expected format
        return {
            name: keyword,
            property,
            message,
            params,
            stack,
            schemaPath,
        };
    });
}
/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
 * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
 * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
 * transform them in what ever way it chooses.
 *
 * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call
 * @param rawErrors - The list of raw `ErrorObject`s to process
 * @param formData - The form data to validate
 * @param schema - The schema against which to validate the form data
 * @param [customValidate] - An optional function that is used to perform custom validation
 * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
 * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
 */
function processRawValidationErrors(validator, rawErrors, formData, schema, customValidate, transformErrors, uiSchema) {
    const { validationError: invalidSchemaError } = rawErrors;
    let errors = transformRJSFValidationErrors(rawErrors.errors, uiSchema);
    if (invalidSchemaError) {
        errors = [...errors, { stack: invalidSchemaError.message }];
    }
    if (typeof transformErrors === 'function') {
        errors = transformErrors(errors, uiSchema);
    }
    let errorSchema = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.toErrorSchema)(errors);
    if (invalidSchemaError) {
        errorSchema = {
            ...errorSchema,
            $schema: {
                __errors: [invalidSchemaError.message],
            },
        };
    }
    if (typeof customValidate !== 'function') {
        return { errors, errorSchema };
    }
    // Include form data with undefined values, which is required for custom validation.
    const newFormData = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getDefaultFormState)(validator, schema, formData, schema, true);
    const errorHandler = customValidate(newFormData, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.createErrorHandler)(newFormData), uiSchema);
    const userErrorSchema = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.unwrapErrorHandler)(errorHandler);
    return (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.validationDataMerge)({ errors, errorSchema }, userErrorSchema);
}
//# sourceMappingURL=processRawValidationErrors.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/types.js":
/*!********************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/types.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@rjsf/validator-ajv8/lib/validator.js":
/*!************************************************************!*\
  !*** ./node_modules/@rjsf/validator-ajv8/lib/validator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AJV8Validator)
/* harmony export */ });
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _createAjvInstance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createAjvInstance */ "./node_modules/@rjsf/validator-ajv8/lib/createAjvInstance.js");
/* harmony import */ var _processRawValidationErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processRawValidationErrors */ "./node_modules/@rjsf/validator-ajv8/lib/processRawValidationErrors.js");



/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.
 */
class AJV8Validator {
    /** Constructs an `AJV8Validator` instance using the `options`
     *
     * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
     * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
     */
    constructor(options, localizer) {
        const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;
        this.ajv = (0,_createAjvInstance__WEBPACK_IMPORTED_MODULE_1__["default"])(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);
        this.localizer = localizer;
    }
    /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
     *
     * @param errorSchema - The `ErrorSchema` instance to convert
     * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
     * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in
     *        the next major release.
     */
    toErrorList(errorSchema, fieldPath = []) {
        return (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.toErrorList)(errorSchema, fieldPath);
    }
    /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
     * by the playground. Returns the `errors` from the validation
     *
     * @param schema - The schema against which to validate the form data   * @param schema
     * @param formData - The form data to validate
     */
    rawValidation(schema, formData) {
        let compilationError = undefined;
        let compiledValidator;
        if (schema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ID_KEY]) {
            compiledValidator = this.ajv.getSchema(schema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ID_KEY]);
        }
        try {
            if (compiledValidator === undefined) {
                compiledValidator = this.ajv.compile(schema);
            }
            compiledValidator(formData);
        }
        catch (err) {
            compilationError = err;
        }
        let errors;
        if (compiledValidator) {
            if (typeof this.localizer === 'function') {
                this.localizer(compiledValidator.errors);
            }
            errors = compiledValidator.errors || undefined;
            // Clear errors to prevent persistent errors, see #1104
            compiledValidator.errors = null;
        }
        return {
            errors: errors,
            validationError: compilationError,
        };
    }
    /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
     * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
     * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
     * transform them in what ever way it chooses.
     *
     * @param formData - The form data to validate
     * @param schema - The schema against which to validate the form data
     * @param [customValidate] - An optional function that is used to perform custom validation
     * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
     * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
     */
    validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {
        const rawErrors = this.rawValidation(schema, formData);
        return (0,_processRawValidationErrors__WEBPACK_IMPORTED_MODULE_2__["default"])(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);
    }
    /** Validates data against a schema, returning true if the data is valid, or
     * false otherwise. If the schema is invalid, then this function will return
     * false.
     *
     * @param schema - The schema against which to validate the form data
     * @param formData - The form data to validate
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    isValid(schema, formData, rootSchema) {
        var _a, _b;
        const rootSchemaId = (_a = rootSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ID_KEY]) !== null && _a !== void 0 ? _a : _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ROOT_SCHEMA_PREFIX;
        try {
            // add the rootSchema ROOT_SCHEMA_PREFIX as id.
            // then rewrite the schema ref's to point to the rootSchema
            // this accounts for the case where schema have references to models
            // that lives in the rootSchema but not in the schema in question.
            // if (this.ajv.getSchema(rootSchemaId) === undefined) {
            // TODO restore the commented out `if` above when the TODO in the `finally` is completed
            this.ajv.addSchema(rootSchema, rootSchemaId);
            // }
            const schemaWithIdRefPrefix = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.withIdRefPrefix)(schema);
            const schemaId = (_b = schemaWithIdRefPrefix[_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ID_KEY]) !== null && _b !== void 0 ? _b : (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.hashForSchema)(schemaWithIdRefPrefix);
            let compiledValidator;
            compiledValidator = this.ajv.getSchema(schemaId);
            if (compiledValidator === undefined) {
                // Add schema by an explicit ID so it can be fetched later
                // Fall back to using compile if necessary
                // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand
                compiledValidator =
                    this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||
                        this.ajv.compile(schemaWithIdRefPrefix);
            }
            const result = compiledValidator(formData);
            return result;
        }
        catch (e) {
            console.warn('Error encountered compiling schema:', e);
            return false;
        }
        finally {
            // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.
            // make sure we remove the rootSchema from the global ajv instance
            this.ajv.removeSchema(rootSchemaId);
        }
    }
}
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ "./node_modules/ajv-formats/dist/formats.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv-formats/dist/formats.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
function fmtDef(validate, compare) {
    return { validate, compare };
}
exports.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true,
};
exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
};
exports.formatNames = Object.keys(exports.fullFormats);
function isLeapYear(year) {
    // https://tools.ietf.org/html/rfc3339#appendix-C
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
    const matches = DATE.exec(str);
    if (!matches)
        return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return (month >= 1 &&
        month <= 12 &&
        day >= 1 &&
        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
}
function compareDate(d1, d2) {
    if (!(d1 && d2))
        return undefined;
    if (d1 > d2)
        return 1;
    if (d1 < d2)
        return -1;
    return 0;
}
const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
        return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (((hour <= 23 && minute <= 59 && second <= 59) ||
        (hour === 23 && minute === 59 && second === 60)) &&
        (!withTimeZone || timeZone !== ""));
}
function compareTime(t1, t2) {
    if (!(t1 && t2))
        return undefined;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
        return undefined;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
        return 1;
    if (t1 < t2)
        return -1;
    return 0;
}
const DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
        return undefined;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === undefined)
        return undefined;
    return res || compareTime(t1, t2);
}
const NOT_URI_FRAGMENT = /\/|:/;
const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
}
const MIN_INT32 = -(2 ** 31);
const MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
    return Number.isInteger(value);
}
function validateNumber() {
    return true;
}
const Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
    if (Z_ANCHOR.test(str))
        return false;
    try {
        new RegExp(str);
        return true;
    }
    catch (e) {
        return false;
    }
}
//# sourceMappingURL=formats.js.map

/***/ }),

/***/ "./node_modules/ajv-formats/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/ajv-formats/dist/index.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const formats_1 = __webpack_require__(/*! ./formats */ "./node_modules/ajv-formats/dist/formats.js");
const limit_1 = __webpack_require__(/*! ./limit */ "./node_modules/ajv-formats/dist/limit.js");
const codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ "./node_modules/ajv/dist/compile/codegen/index.js");
const fullName = new codegen_1.Name("fullFormats");
const fastName = new codegen_1.Name("fastFormats");
const formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
        limit_1.default(ajv);
    return ajv;
};
formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
        throw new Error(`Unknown format "${name}"`);
    return f;
};
function addFormats(ajv, list, fs, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = codegen_1._ `require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
        ajv.addFormat(f, fs[f]);
}
module.exports = exports = formatsPlugin;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = formatsPlugin;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ajv-formats/dist/limit.js":
/*!************************************************!*\
  !*** ./node_modules/ajv-formats/dist/limit.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatLimitDefinition = void 0;
const ajv_1 = __webpack_require__(/*! ajv */ "./node_modules/ajv/dist/ajv.js");
const codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ "./node_modules/ajv/dist/compile/codegen/index.js");
const ops = codegen_1.operators;
const KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error = {
    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
            return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fmt = gen.const("fmt", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != "object"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
            const format = fCxt.schema;
            const fmtDef = self.formats[format];
            if (!fmtDef || fmtDef === true)
                return;
            if (typeof fmtDef != "object" ||
                fmtDef instanceof RegExp ||
                typeof fmtDef.compare != "function") {
                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
                key: format,
                ref: fmtDef,
                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,
            });
            cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
    },
    dependencies: ["format"],
};
const formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
};
exports["default"] = formatLimitPlugin;
//# sourceMappingURL=limit.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmpzZl92YWxpZGF0b3ItYWp2OF9saWJfaW5kZXhfanMuOGExMGI5Zjg4MDlkMGQ4ZDQ1ZDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNCO0FBQ2U7QUFDRTtBQUNnRDtBQUNoRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2Q0FBNkMsRUFBRSxFQUFFLElBQUk7QUFDckQsNkRBQTZELGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNlLHlGQUF5RiwrQkFBK0IsNENBQUc7QUFDMUksK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBLFFBQVEsa0RBQVU7QUFDbEI7QUFDQTtBQUNBLFFBQVEsa0RBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBd0I7QUFDM0MsbUJBQW1CLHVFQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBUTtBQUNoQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNyRDhEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmLGVBQWUsNkRBQXdCO0FBQ3ZDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2Z3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDZSx3Q0FBd0M7QUFDdkQsZUFBZSxrREFBYTtBQUM1QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWnNEO0FBQ2dCO0FBQ1o7QUFDbEM7QUFDeEIsaUVBQWUsK0RBQWtCLEVBQUUsRUFBQztBQUNwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTDZCO0FBQ1E7QUFDNkQ7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QjtBQUNoRiw2REFBNkQsS0FBSyw2QkFBNkIsS0FBSywwQ0FBMEMsSUFBSTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxhQUFhLE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCLEVBQUUsOEJBQThCO0FBQzNHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSSxXQUFXLEtBQUssSUFBSSxXQUFXLElBQUksb0JBQW9CO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdmFsaWRhdG9yLWFqdjgvbGliL2NyZWF0ZUFqdkluc3RhbmNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi92YWxpZGF0b3ItYWp2OC9saWIvY3JlYXRlUHJlY29tcGlsZWRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3ZhbGlkYXRvci1hanY4L2xpYi9jdXN0b21pemVWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3ZhbGlkYXRvci1hanY4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdmFsaWRhdG9yLWFqdjgvbGliL3ByZWNvbXBpbGVkVmFsaWRhdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi92YWxpZGF0b3ItYWp2OC9saWIvcHJvY2Vzc1Jhd1ZhbGlkYXRpb25FcnJvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL3ZhbGlkYXRvci1hanY4L2xpYi90eXBlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvdmFsaWRhdG9yLWFqdjgvbGliL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2xpbWl0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBanYgZnJvbSAnYWp2JztcbmltcG9ydCBhZGRGb3JtYXRzIGZyb20gJ2Fqdi1mb3JtYXRzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICdsb2Rhc2gvaXNPYmplY3QnO1xuaW1wb3J0IHsgQURESVRJT05BTF9QUk9QRVJUWV9GTEFHLCBSSlNGX0FERElUT05BTF9QUk9QRVJUSUVTX0ZMQUcgfSBmcm9tICdAcmpzZi91dGlscyc7XG5leHBvcnQgY29uc3QgQUpWX0NPTkZJRyA9IHtcbiAgICBhbGxFcnJvcnM6IHRydWUsXG4gICAgbXVsdGlwbGVPZlByZWNpc2lvbjogOCxcbiAgICBzdHJpY3Q6IGZhbHNlLFxuICAgIHZlcmJvc2U6IHRydWUsXG59O1xuZXhwb3J0IGNvbnN0IENPTE9SX0ZPUk1BVF9SRUdFWCA9IC9eKCM/KFswLTlBLUZhLWZdezN9KXsxLDJ9XFxifGFxdWF8YmxhY2t8Ymx1ZXxmdWNoc2lhfGdyYXl8Z3JlZW58bGltZXxtYXJvb258bmF2eXxvbGl2ZXxvcmFuZ2V8cHVycGxlfHJlZHxzaWx2ZXJ8dGVhbHx3aGl0ZXx5ZWxsb3d8KHJnYlxcKFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKixcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqXFwpKXwocmdiXFwoXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqLFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccypcXCkpKSQvO1xuZXhwb3J0IGNvbnN0IERBVEFfVVJMX0ZPUk1BVF9SRUdFWCA9IC9eZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKT87KD86bmFtZT0oLiopOyk/YmFzZTY0LCguKikkLztcbi8qKiBDcmVhdGVzIGFuIEFqdiB2ZXJzaW9uIDggaW1wbGVtZW50YXRpb24gb2JqZWN0IHdpdGggc3RhbmRhcmQgc3VwcG9ydCBmb3IgdGhlICdjb2xvcmAgYW5kIGBkYXRhLXVybGAgY3VzdG9tIGZvcm1hdHMuXG4gKiBJZiBgYWRkaXRpb25hbE1ldGFTY2hlbWFzYCBhcmUgcHJvdmlkZWQgdGhlbiB0aGUgQWp2IGluc3RhbmNlIGlzIG1vZGlmaWVkIHRvIGFkZCBlYWNoIG9mIHRoZSBtZXRhIHNjaGVtYXMgaW4gdGhlXG4gKiBsaXN0LiBJZiBgY3VzdG9tRm9ybWF0c2AgYXJlIHByb3ZpZGVkIHRoZW4gdGhvc2UgYWRkaXRpb25hbCBmb3JtYXRzIGFyZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgZm9ybWF0cy4gSWZcbiAqIGBhanZPcHRpb25zT3ZlcnJpZGVzYCBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IGFyZSBzcHJlYWQgb24gdG9wIG9mIHRoZSBkZWZhdWx0IGBBSlZfQ09ORklHYCBvcHRpb25zIHdoZW4gY29uc3RydWN0aW5nXG4gKiB0aGUgYEFqdmAgaW5zdGFuY2UuIFdpdGggQWp2IHY4LCB0aGUgSlNPTiBTY2hlbWEgZm9ybWF0cyBhcmUgbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgcGx1Z2dlZCBpbi4gQnlcbiAqIGRlZmF1bHQsIGFsbCBmb3JtYXRzIGZyb20gdGhlIGBhanYtZm9ybWF0c2AgbGlicmFyeSBhcmUgYWRkZWQuIFRvIGRpc2FibGUgdGhpcyBjYXBhYmlsaXR5LCBzZXQgdGhlIGBhanZGb3JtYXRPcHRpb25zYFxuICogcGFyYW1ldGVyIHRvIGBmYWxzZWAuIEFkZGl0aW9uYWxseSwgeW91IGNhbiBjb25maWd1cmUgdGhlIGBhanYtZm9ybWF0c2AgYnkgcHJvdmlkaW5nIGEgY3VzdG9tIHNldCBvZlxuICogW2Zvcm1hdCBvcHRpb25zXShodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYtZm9ybWF0cykgdG8gdGhlIGBhanZGb3JtYXRPcHRpb25zYCBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIFthZGRpdGlvbmFsTWV0YVNjaGVtYXNdIC0gVGhlIGxpc3Qgb2YgYWRkaXRpb25hbCBtZXRhIHNjaGVtYXMgdGhhdCB0aGUgdmFsaWRhdG9yIGNhbiBhY2Nlc3NcbiAqIEBwYXJhbSBbY3VzdG9tRm9ybWF0c10gLSBUaGUgc2V0IG9mIGFkZGl0aW9uYWwgY3VzdG9tIGZvcm1hdHMgdGhhdCB0aGUgdmFsaWRhdG9yIHdpbGwgc3VwcG9ydFxuICogQHBhcmFtIFthanZPcHRpb25zT3ZlcnJpZGVzPXt9XSAtIFRoZSBzZXQgb2YgdmFsaWRhdG9yIGNvbmZpZyBvdmVycmlkZSBvcHRpb25zXG4gKiBAcGFyYW0gW2FqdkZvcm1hdE9wdGlvbnNdIC0gVGhlIGBhanYtZm9ybWF0YCBvcHRpb25zIHRvIHVzZSB3aGVuIGFkZGluZyBmb3JtYXRzIHRvIGBhanZgOyBwYXNzIGBmYWxzZWAgdG8gZGlzYWJsZSBpdFxuICogQHBhcmFtIFtBanZDbGFzc10gLSBUaGUgYEFqdmAgY2xhc3MgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIHZhbGlkYXRvciBpbnN0YW5jZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVBanZJbnN0YW5jZShhZGRpdGlvbmFsTWV0YVNjaGVtYXMsIGN1c3RvbUZvcm1hdHMsIGFqdk9wdGlvbnNPdmVycmlkZXMgPSB7fSwgYWp2Rm9ybWF0T3B0aW9ucywgQWp2Q2xhc3MgPSBBanYpIHtcbiAgICBjb25zdCBhanYgPSBuZXcgQWp2Q2xhc3MoeyAuLi5BSlZfQ09ORklHLCAuLi5hanZPcHRpb25zT3ZlcnJpZGVzIH0pO1xuICAgIGlmIChhanZGb3JtYXRPcHRpb25zKSB7XG4gICAgICAgIGFkZEZvcm1hdHMoYWp2LCBhanZGb3JtYXRPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWp2Rm9ybWF0T3B0aW9ucyAhPT0gZmFsc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYpO1xuICAgIH1cbiAgICAvLyBhZGQgY3VzdG9tIGZvcm1hdHNcbiAgICBhanYuYWRkRm9ybWF0KCdkYXRhLXVybCcsIERBVEFfVVJMX0ZPUk1BVF9SRUdFWCk7XG4gICAgYWp2LmFkZEZvcm1hdCgnY29sb3InLCBDT0xPUl9GT1JNQVRfUkVHRVgpO1xuICAgIC8vIEFkZCBSSlNGLXNwZWNpZmljIGFkZGl0aW9uYWwgcHJvcGVydGllcyBrZXl3b3JkcyBzbyBBanYgZG9lc24ndCByZXBvcnQgZXJyb3JzIGlmIHN0cmljdCBpcyBlbmFibGVkLlxuICAgIGFqdi5hZGRLZXl3b3JkKEFERElUSU9OQUxfUFJPUEVSVFlfRkxBRyk7XG4gICAgYWp2LmFkZEtleXdvcmQoUkpTRl9BRERJVE9OQUxfUFJPUEVSVElFU19GTEFHKTtcbiAgICAvLyBhZGQgbW9yZSBzY2hlbWFzIHRvIHZhbGlkYXRlIGFnYWluc3RcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhZGRpdGlvbmFsTWV0YVNjaGVtYXMpKSB7XG4gICAgICAgIGFqdi5hZGRNZXRhU2NoZW1hKGFkZGl0aW9uYWxNZXRhU2NoZW1hcyk7XG4gICAgfVxuICAgIC8vIGFkZCBtb3JlIGN1c3RvbSBmb3JtYXRzIHRvIHZhbGlkYXRlIGFnYWluc3RcbiAgICBpZiAoaXNPYmplY3QoY3VzdG9tRm9ybWF0cykpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY3VzdG9tRm9ybWF0cykuZm9yRWFjaCgoZm9ybWF0TmFtZSkgPT4ge1xuICAgICAgICAgICAgYWp2LmFkZEZvcm1hdChmb3JtYXROYW1lLCBjdXN0b21Gb3JtYXRzW2Zvcm1hdE5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhanY7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVBanZJbnN0YW5jZS5qcy5tYXAiLCJpbXBvcnQgQUpWOFByZWNvbXBpbGVkVmFsaWRhdG9yIGZyb20gJy4vcHJlY29tcGlsZWRWYWxpZGF0b3InO1xuLyoqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmFsaWRhdG9yVHlwZWAgaW50ZXJmYWNlIHRoYXQgaXMgaW1wbGVtZW50ZWQgd2l0aCBhIHByZWNvbXBpbGVkIHZhbGlkYXRvci4gSWYgYSBgbG9jYWxpemVyYFxuICogaXMgcHJvdmlkZWQsIGl0IGlzIHVzZWQgdG8gdHJhbnNsYXRlIHRoZSBtZXNzYWdlcyBnZW5lcmF0ZWQgYnkgdGhlIHVuZGVybHlpbmcgQUpWIHZhbGlkYXRpb24uXG4gKlxuICogTk9URTogVGhlIGB2YWxpZGF0ZUZuc2AgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCBvYnRhaW5lZCBieSBpbXBvcnRpbmcgZnJvbSBhIHByZWNvbXBpbGVkIHZhbGlkYXRpb24gZmlsZSBjcmVhdGVkIHZpYVxuICogdGhlIGBjb21waWxlU2NoZW1hVmFsaWRhdG9ycygpYCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdGVGbnMgLSBUaGUgbWFwIG9mIHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9ucyB0aGF0IGFyZSBjcmVhdGVkIGJ5IHRoZSBgY29tcGlsZVNjaGVtYVZhbGlkYXRvcnMoKWAgZnVuY3Rpb25cbiAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hIHRoYXQgd2FzIHVzZWQgd2l0aCB0aGUgYGNvbXBpbGVTY2hlbWFWYWxpZGF0b3JzKClgIGZ1bmN0aW9uXG4gKiBAcGFyYW0gW2xvY2FsaXplcl0gLSBJZiBwcm92aWRlZCwgaXMgdXNlZCB0byBsb2NhbGl6ZSBhIGxpc3Qgb2YgQWp2IGBFcnJvck9iamVjdGBzXG4gKiBAcmV0dXJucyAtIFRoZSBwcmVjb21waWxlZCB2YWxpZGF0b3IgaW1wbGVtZW50YXRpb24gcmVzdWx0aW5nIGZyb20gdGhlIHNldCBvZiBwYXJhbWV0ZXJzIHByb3ZpZGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVByZWNvbXBpbGVkVmFsaWRhdG9yKHZhbGlkYXRlRm5zLCByb290U2NoZW1hLCBsb2NhbGl6ZXIpIHtcbiAgICByZXR1cm4gbmV3IEFKVjhQcmVjb21waWxlZFZhbGlkYXRvcih2YWxpZGF0ZUZucywgcm9vdFNjaGVtYSwgbG9jYWxpemVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVByZWNvbXBpbGVkVmFsaWRhdG9yLmpzLm1hcCIsImltcG9ydCBBSlY4VmFsaWRhdG9yIGZyb20gJy4vdmFsaWRhdG9yJztcbi8qKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY3VzdG9taXplZCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYFZhbGlkYXRvclR5cGVgIHdpdGggdGhlIGdpdmVuIGN1c3RvbWl6YXRpb24gYG9wdGlvbnNgIGlmXG4gKiBwcm92aWRlZC4gSWYgYSBgbG9jYWxpemVyYCBpcyBwcm92aWRlZCwgaXQgaXMgdXNlZCB0byB0cmFuc2xhdGUgdGhlIG1lc3NhZ2VzIGdlbmVyYXRlZCBieSB0aGUgdW5kZXJseWluZyBBSlZcbiAqIHZhbGlkYXRpb24uXG4gKlxuICogQHBhcmFtIFtvcHRpb25zPXt9XSAtIFRoZSBgQ3VzdG9tVmFsaWRhdG9yT3B0aW9uc1R5cGVgIG9wdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBjcmVhdGUgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnN0YW5jZVxuICogQHBhcmFtIFtsb2NhbGl6ZXJdIC0gSWYgcHJvdmlkZWQsIGlzIHVzZWQgdG8gbG9jYWxpemUgYSBsaXN0IG9mIEFqdiBgRXJyb3JPYmplY3Rgc1xuICogQHJldHVybnMgLSBUaGUgY3VzdG9tIHZhbGlkYXRvciBpbXBsZW1lbnRhdGlvbiByZXN1bHRpbmcgZnJvbSB0aGUgc2V0IG9mIHBhcmFtZXRlcnMgcHJvdmlkZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3VzdG9taXplVmFsaWRhdG9yKG9wdGlvbnMgPSB7fSwgbG9jYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBBSlY4VmFsaWRhdG9yKG9wdGlvbnMsIGxvY2FsaXplcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b21pemVWYWxpZGF0b3IuanMubWFwIiwiaW1wb3J0IGN1c3RvbWl6ZVZhbGlkYXRvciBmcm9tICcuL2N1c3RvbWl6ZVZhbGlkYXRvcic7XG5pbXBvcnQgY3JlYXRlUHJlY29tcGlsZWRWYWxpZGF0b3IgZnJvbSAnLi9jcmVhdGVQcmVjb21waWxlZFZhbGlkYXRvcic7XG5leHBvcnQgeyBjdXN0b21pemVWYWxpZGF0b3IsIGNyZWF0ZVByZWNvbXBpbGVkVmFsaWRhdG9yIH07XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCBkZWZhdWx0IGN1c3RvbWl6ZVZhbGlkYXRvcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCB7IGhhc2hGb3JTY2hlbWEsIElEX0tFWSwgSlVOS19PUFRJT05fSUQsIHRvRXJyb3JMaXN0LCByZXRyaWV2ZVNjaGVtYSwgfSBmcm9tICdAcmpzZi91dGlscyc7XG5pbXBvcnQgcHJvY2Vzc1Jhd1ZhbGlkYXRpb25FcnJvcnMgZnJvbSAnLi9wcm9jZXNzUmF3VmFsaWRhdGlvbkVycm9ycyc7XG4vKiogYFZhbGlkYXRvclR5cGVgIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyBhbiBBSlYgOCBwcmVjb21waWxlZCB2YWxpZGF0b3IgYXMgY3JlYXRlZCBieSB0aGVcbiAqIGBjb21waWxlU2NoZW1hVmFsaWRhdG9ycygpYCBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgYEByanNmL3ZhbGlkYXRvci1hanY4YCBsaWJyYXJ5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSlY4UHJlY29tcGlsZWRWYWxpZGF0b3Ige1xuICAgIC8qKiBDb25zdHJ1Y3RzIGFuIGBBSlY4UHJlY29tcGlsZWRWYWxpZGF0b3JgIGluc3RhbmNlIHVzaW5nIHRoZSBgdmFsaWRhdGVGbnNgIGFuZCBgcm9vdFNjaGVtYWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0ZUZucyAtIFRoZSBtYXAgb2YgdGhlIHZhbGlkYXRpb24gZnVuY3Rpb25zIHRoYXQgYXJlIGdlbmVyYXRlZCBieSB0aGUgYHNjaGVtYUNvbXBpbGUoKWAgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gcm9vdFNjaGVtYSAtIFRoZSByb290IHNjaGVtYSB0aGF0IHdhcyB1c2VkIHdpdGggdGhlIGBjb21waWxlU2NoZW1hKClgIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIFtsb2NhbGl6ZXJdIC0gSWYgcHJvdmlkZWQsIGlzIHVzZWQgdG8gbG9jYWxpemUgYSBsaXN0IG9mIEFqdiBgRXJyb3JPYmplY3Rgc1xuICAgICAqIEB0aHJvd3MgLSBFcnJvciB3aGVuIHRoZSBiYXNlIHNjaGVtYSBvZiB0aGUgcHJlY29tcGlsZWQgdmFsaWRhdG9yIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWxpZGF0ZUZucywgcm9vdFNjaGVtYSwgbG9jYWxpemVyKSB7XG4gICAgICAgIHRoaXMucm9vdFNjaGVtYSA9IHJvb3RTY2hlbWE7XG4gICAgICAgIHRoaXMudmFsaWRhdGVGbnMgPSB2YWxpZGF0ZUZucztcbiAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSBsb2NhbGl6ZXI7XG4gICAgICAgIHRoaXMubWFpblZhbGlkYXRvciA9IHRoaXMuZ2V0VmFsaWRhdG9yKHJvb3RTY2hlbWEpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgcHJlY29tcGlsZWQgdmFsaWRhdG9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHNjaGVtYWAgZnJvbSB0aGUgbWFwIG9mIHByZWNvbXBpbGVkIHZhbGlkYXRvclxuICAgICAqIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZvciB3aGljaCBhIHByZWNvbXBpbGVkIHZhbGlkYXRvciBmdW5jdGlvbiBpcyBkZXNpcmVkXG4gICAgICogQHJldHVybnMgLSBUaGUgcHJlY29tcGlsZWQgdmFsaWRhdG9yIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjaGVtYVxuICAgICAqL1xuICAgIGdldFZhbGlkYXRvcihzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0KHNjaGVtYSwgSURfS0VZKSB8fCBoYXNoRm9yU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHRoaXMudmFsaWRhdGVGbnNba2V5XTtcbiAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcHJlY29tcGlsZWQgdmFsaWRhdG9yIGZ1bmN0aW9uIHdhcyBmb3VuZCBmb3IgdGhlIGdpdmVuIHNjaGVtYSBmb3IgXCIke2tleX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgfVxuICAgIC8qKiBFbnN1cmVzIHRoYXQgdGhlIHZhbGlkYXRvciBpcyB1c2luZyB0aGUgc2FtZSBzY2hlbWEgYXMgdGhlIHJvb3Qgc2NoZW1hIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwcmVjb21waWxlZFxuICAgICAqIHZhbGlkYXRvci4gSXQgZmlyc3QgY29tcGFyZXMgdGhlIGdpdmVuIGBzY2hlbWFgIGFnYWluc3QgdGhlIHJvb3Qgc2NoZW1hIGFuZCBpZiB0aGV5IGFyZW4ndCB0aGUgc2FtZSwgdGhlbiBpdFxuICAgICAqIGNoZWNrcyBhZ2FpbnN0IHRoZSByZXNvbHZlZCByb290IHNjaGVtYSwgb24gdGhlIGNoYW5jZSB0aGF0IGEgcmVzb2x2ZWQgdmVyc2lvbiBvZiB0aGUgcm9vdCBzY2hlbWEgd2FzIHBhc3NlZCBpblxuICAgICAqIGluc3RlYWQgb2YgdGhlIHJhdyByb290IHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGFnYWluc3Qgd2hpY2ggdG8gdmFsaWRhdGUgdGhlIGZvcm0gZGF0YVxuICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGZvcm0gZGF0YSB0byB2YWxpZGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBlbnN1cmVTYW1lUm9vdFNjaGVtYShzY2hlbWEsIGZvcm1EYXRhKSB7XG4gICAgICAgIGlmICghaXNFcXVhbChzY2hlbWEsIHRoaXMucm9vdFNjaGVtYSkpIHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHJvb3Qgc2NoZW1hIHdpdGggdGhlIHBhc3NlZCBpbiBmb3JtIGRhdGEgc2luY2UgdGhhdCBtYXkgYWZmZWN0IHRoZSByZXNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFJvb3RTY2hlbWEgPSByZXRyaWV2ZVNjaGVtYSh0aGlzLCB0aGlzLnJvb3RTY2hlbWEsIHRoaXMucm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKHNjaGVtYSwgcmVzb2x2ZWRSb290U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNjaGVtYSBhc3NvY2lhdGVkIHdpdGggdGhlIHByZWNvbXBpbGVkIHZhbGlkYXRvciBkaWZmZXJzIGZyb20gdGhlIHJvb3RTY2hlbWEgcHJvdmlkZWQgZm9yIHZhbGlkYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIGFuIGBlcnJvclNjaGVtYWAgaW50byBhIGxpc3Qgb2YgYFJKU0ZWYWxpZGF0aW9uRXJyb3JzYFxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yU2NoZW1hIC0gVGhlIGBFcnJvclNjaGVtYWAgaW5zdGFuY2UgdG8gY29udmVydFxuICAgICAqIEBwYXJhbSBbZmllbGRQYXRoPVtdXSAtIFRoZSBjdXJyZW50IGZpZWxkIHBhdGgsIGRlZmF1bHRzIHRvIFtdIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAZGVwcmVjYXRlZCAtIFVzZSB0aGUgYHRvRXJyb3JMaXN0KClgIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGBAcmpzZi91dGlsc2AgaW5zdGVhZC4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW5cbiAgICAgKiAgICAgICAgdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgKi9cbiAgICB0b0Vycm9yTGlzdChlcnJvclNjaGVtYSwgZmllbGRQYXRoID0gW10pIHtcbiAgICAgICAgcmV0dXJuIHRvRXJyb3JMaXN0KGVycm9yU2NoZW1hLCBmaWVsZFBhdGgpO1xuICAgIH1cbiAgICAvKiogUnVucyB0aGUgcHVyZSB2YWxpZGF0aW9uIG9mIHRoZSBgc2NoZW1hYCBhbmQgYGZvcm1EYXRhYCB3aXRob3V0IGFueSBvZiB0aGUgUkpTRiBmdW5jdGlvbmFsaXR5LiBQcm92aWRlZCBmb3IgdXNlXG4gICAgICogYnkgdGhlIHBsYXlncm91bmQuIFJldHVybnMgdGhlIGBlcnJvcnNgIGZyb20gdGhlIHZhbGlkYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGFnYWluc3Qgd2hpY2ggdG8gdmFsaWRhdGUgdGhlIGZvcm0gZGF0YVxuICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGZvcm0gZGF0YSB0byB2YWxpZGF0ZSwgaWYgYW55XG4gICAgICogQHRocm93cyAtIEVycm9yIHdoZW4gdGhlIHNjaGVtYSBwcm92aWRlZCBkb2VzIG5vdCBtYXRjaCB0aGUgYmFzZSBzY2hlbWEgb2YgdGhlIHByZWNvbXBpbGVkIHZhbGlkYXRvclxuICAgICAqL1xuICAgIHJhd1ZhbGlkYXRpb24oc2NoZW1hLCBmb3JtRGF0YSkge1xuICAgICAgICB0aGlzLmVuc3VyZVNhbWVSb290U2NoZW1hKHNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICB0aGlzLm1haW5WYWxpZGF0b3IoZm9ybURhdGEpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubG9jYWxpemVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXplcih0aGlzLm1haW5WYWxpZGF0b3IuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLm1haW5WYWxpZGF0b3IuZXJyb3JzIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2xlYXIgZXJyb3JzIHRvIHByZXZlbnQgcGVyc2lzdGVudCBlcnJvcnMsIHNlZSAjMTEwNFxuICAgICAgICB0aGlzLm1haW5WYWxpZGF0b3IuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcnMgfTtcbiAgICB9XG4gICAgLyoqIFRoaXMgZnVuY3Rpb24gcHJvY2Vzc2VzIHRoZSBgZm9ybURhdGFgIHdpdGggYW4gb3B0aW9uYWwgdXNlciBjb250cmlidXRlZCBgY3VzdG9tVmFsaWRhdGVgIGZ1bmN0aW9uLCB3aGljaCByZWNlaXZlc1xuICAgICAqIHRoZSBmb3JtIGRhdGEgYW5kIGEgYGVycm9ySGFuZGxlcmAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gYWRkIGN1c3RvbSB2YWxpZGF0aW9uIGVycm9ycyBmb3IgZWFjaCBmaWVsZC4gQWxzb1xuICAgICAqIHN1cHBvcnRzIGEgYHRyYW5zZm9ybUVycm9yc2AgZnVuY3Rpb24gdGhhdCB3aWxsIHRha2UgdGhlIHJhdyBBSlYgdmFsaWRhdGlvbiBlcnJvcnMsIHByaW9yIHRvIGN1c3RvbSB2YWxpZGF0aW9uIGFuZFxuICAgICAqIHRyYW5zZm9ybSB0aGVtIGluIHdoYXQgZXZlciB3YXkgaXQgY2hvb3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBmb3JtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBhZ2FpbnN0IHdoaWNoIHRvIHZhbGlkYXRlIHRoZSBmb3JtIGRhdGFcbiAgICAgKiBAcGFyYW0gW2N1c3RvbVZhbGlkYXRlXSAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBwZXJmb3JtIGN1c3RvbSB2YWxpZGF0aW9uXG4gICAgICogQHBhcmFtIFt0cmFuc2Zvcm1FcnJvcnNdIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHRyYW5zZm9ybSBlcnJvcnMgYWZ0ZXIgQUpWIHZhbGlkYXRpb25cbiAgICAgKiBAcGFyYW0gW3VpU2NoZW1hXSAtIEFuIG9wdGlvbmFsIHVpU2NoZW1hIHRoYXQgaXMgcGFzc2VkIHRvIGB0cmFuc2Zvcm1FcnJvcnNgIGFuZCBgY3VzdG9tVmFsaWRhdGVgXG4gICAgICovXG4gICAgdmFsaWRhdGVGb3JtRGF0YShmb3JtRGF0YSwgc2NoZW1hLCBjdXN0b21WYWxpZGF0ZSwgdHJhbnNmb3JtRXJyb3JzLCB1aVNjaGVtYSkge1xuICAgICAgICBjb25zdCByYXdFcnJvcnMgPSB0aGlzLnJhd1ZhbGlkYXRpb24oc2NoZW1hLCBmb3JtRGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmF3VmFsaWRhdGlvbkVycm9ycyh0aGlzLCByYXdFcnJvcnMsIGZvcm1EYXRhLCBzY2hlbWEsIGN1c3RvbVZhbGlkYXRlLCB0cmFuc2Zvcm1FcnJvcnMsIHVpU2NoZW1hKTtcbiAgICB9XG4gICAgLyoqIFZhbGlkYXRlcyBkYXRhIGFnYWluc3QgYSBzY2hlbWEsIHJldHVybmluZyB0cnVlIGlmIHRoZSBkYXRhIGlzIHZhbGlkLCBvciBmYWxzZSBvdGhlcndpc2UuIElmIHRoZSBzY2hlbWEgaXNcbiAgICAgKiBpbnZhbGlkLCB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBhZ2FpbnN0IHdoaWNoIHRvIHZhbGlkYXRlIHRoZSBmb3JtIGRhdGFcbiAgICAgKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgZm9ybSBkYXRhIHRvIHZhbGlkYXRlXG4gICAgICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdXNlZCB0byBwcm92aWRlICRyZWYgcmVzb2x1dGlvbnNcbiAgICAgKiBAcmV0dXJucyAtIHRydWUgaWYgdGhlIGZvcm1EYXRhIHZhbGlkYXRlcyBhZ2FpbnN0IHRoZSBzY2hlbWEsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEB0aHJvd3MgLSBFcnJvciB3aGVuIHRoZSBzY2hlbWEgcHJvdmlkZWQgZG9lcyBub3QgbWF0Y2ggdGhlIGJhc2Ugc2NoZW1hIG9mIHRoZSBwcmVjb21waWxlZCB2YWxpZGF0b3IgT1IgaWYgdGhlcmVcbiAgICAgKiAgICAgICAgaXNuJ3QgYSBwcmVjb21waWxlZCB2YWxpZGF0b3IgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzY2hlbWFcbiAgICAgKi9cbiAgICBpc1ZhbGlkKHNjaGVtYSwgZm9ybURhdGEsIHJvb3RTY2hlbWEpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTYW1lUm9vdFNjaGVtYShyb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gICAgICAgIGlmIChnZXQoc2NoZW1hLCBJRF9LRVkpID09PSBKVU5LX09QVElPTl9JRCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHRoaXMuZ2V0VmFsaWRhdG9yKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3IoZm9ybURhdGEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWNvbXBpbGVkVmFsaWRhdG9yLmpzLm1hcCIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgeyBjcmVhdGVFcnJvckhhbmRsZXIsIGdldERlZmF1bHRGb3JtU3RhdGUsIGdldFVpT3B0aW9ucywgUFJPUEVSVElFU19LRVksIHRvRXJyb3JTY2hlbWEsIHVud3JhcEVycm9ySGFuZGxlciwgdmFsaWRhdGlvbkRhdGFNZXJnZSwgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVHJhbnNmb3JtaW5nIHRoZSBlcnJvciBvdXRwdXQgZnJvbSBhanYgdG8gZm9ybWF0IHVzZWQgYnkgQHJqc2YvdXRpbHMuXG4gKiBBdCBzb21lIHBvaW50LCBjb21wb25lbnRzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHN1cHBvcnQgYWp2LlxuICpcbiAqIEBwYXJhbSBlcnJvcnMgLSBUaGUgbGlzdCBvZiBBSlYgZXJyb3JzIHRvIGNvbnZlcnQgdG8gYFJKU0ZWYWxpZGF0aW9uRXJyb3JzYFxuICogQHBhcmFtIFt1aVNjaGVtYV0gLSBBbiBvcHRpb25hbCB1aVNjaGVtYSB0aGF0IGlzIHBhc3NlZCB0byBgdHJhbnNmb3JtRXJyb3JzYCBhbmQgYGN1c3RvbVZhbGlkYXRlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUkpTRlZhbGlkYXRpb25FcnJvcnMoZXJyb3JzID0gW10sIHVpU2NoZW1hKSB7XG4gICAgcmV0dXJuIGVycm9ycy5tYXAoKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBpbnN0YW5jZVBhdGgsIGtleXdvcmQsIHBhcmFtcywgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hLCAuLi5yZXN0IH0gPSBlO1xuICAgICAgICBsZXQgeyBtZXNzYWdlID0gJycgfSA9IHJlc3Q7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGluc3RhbmNlUGF0aC5yZXBsYWNlKC9cXC8vZywgJy4nKTtcbiAgICAgICAgbGV0IHN0YWNrID0gYCR7cHJvcGVydHl9ICR7bWVzc2FnZX1gLnRyaW0oKTtcbiAgICAgICAgaWYgKCdtaXNzaW5nUHJvcGVydHknIGluIHBhcmFtcykge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eSA/IGAke3Byb3BlcnR5fS4ke3BhcmFtcy5taXNzaW5nUHJvcGVydHl9YCA6IHBhcmFtcy5taXNzaW5nUHJvcGVydHk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJvcGVydHkgPSBwYXJhbXMubWlzc2luZ1Byb3BlcnR5O1xuICAgICAgICAgICAgY29uc3QgdWlTY2hlbWFUaXRsZSA9IGdldFVpT3B0aW9ucyhnZXQodWlTY2hlbWEsIGAke3Byb3BlcnR5LnJlcGxhY2UoL15cXC4vLCAnJyl9YCkpLnRpdGxlO1xuICAgICAgICAgICAgaWYgKHVpU2NoZW1hVGl0bGUpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKGN1cnJlbnRQcm9wZXJ0eSwgdWlTY2hlbWFUaXRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWFUaXRsZSA9IGdldChwYXJlbnRTY2hlbWEsIFtQUk9QRVJUSUVTX0tFWSwgY3VycmVudFByb3BlcnR5LCAndGl0bGUnXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNjaGVtYVRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoY3VycmVudFByb3BlcnR5LCBwYXJlbnRTY2hlbWFUaXRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdWlTY2hlbWFUaXRsZSA9IGdldFVpT3B0aW9ucyhnZXQodWlTY2hlbWEsIGAke3Byb3BlcnR5LnJlcGxhY2UoL15cXC4vLCAnJyl9YCkpLnRpdGxlO1xuICAgICAgICAgICAgaWYgKHVpU2NoZW1hVGl0bGUpIHtcbiAgICAgICAgICAgICAgICBzdGFjayA9IGAnJHt1aVNjaGVtYVRpdGxlfScgJHttZXNzYWdlfWAudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U2NoZW1hVGl0bGUgPSBwYXJlbnRTY2hlbWEgPT09IG51bGwgfHwgcGFyZW50U2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRTY2hlbWEudGl0bGU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNjaGVtYVRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrID0gYCcke3BhcmVudFNjaGVtYVRpdGxlfScgJHttZXNzYWdlfWAudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwdXQgZGF0YSBpbiBleHBlY3RlZCBmb3JtYXRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGtleXdvcmQsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKiogVGhpcyBmdW5jdGlvbiBwcm9jZXNzZXMgdGhlIGBmb3JtRGF0YWAgd2l0aCBhbiBvcHRpb25hbCB1c2VyIGNvbnRyaWJ1dGVkIGBjdXN0b21WYWxpZGF0ZWAgZnVuY3Rpb24sIHdoaWNoIHJlY2VpdmVzXG4gKiB0aGUgZm9ybSBkYXRhIGFuZCBhIGBlcnJvckhhbmRsZXJgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFkZCBjdXN0b20gdmFsaWRhdGlvbiBlcnJvcnMgZm9yIGVhY2ggZmllbGQuIEFsc29cbiAqIHN1cHBvcnRzIGEgYHRyYW5zZm9ybUVycm9yc2AgZnVuY3Rpb24gdGhhdCB3aWxsIHRha2UgdGhlIHJhdyBBSlYgdmFsaWRhdGlvbiBlcnJvcnMsIHByaW9yIHRvIGN1c3RvbSB2YWxpZGF0aW9uIGFuZFxuICogdHJhbnNmb3JtIHRoZW0gaW4gd2hhdCBldmVyIHdheSBpdCBjaG9vc2VzLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBUaGUgYFZhbGlkYXRvclR5cGVgIGltcGxlbWVudGF0aW9uIHVzZWQgZm9yIHRoZSBgZ2V0RGVmYXVsdEZvcm1TdGF0ZSgpYCBjYWxsXG4gKiBAcGFyYW0gcmF3RXJyb3JzIC0gVGhlIGxpc3Qgb2YgcmF3IGBFcnJvck9iamVjdGBzIHRvIHByb2Nlc3NcbiAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBmb3JtIGRhdGEgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGFnYWluc3Qgd2hpY2ggdG8gdmFsaWRhdGUgdGhlIGZvcm0gZGF0YVxuICogQHBhcmFtIFtjdXN0b21WYWxpZGF0ZV0gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gcGVyZm9ybSBjdXN0b20gdmFsaWRhdGlvblxuICogQHBhcmFtIFt0cmFuc2Zvcm1FcnJvcnNdIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHRyYW5zZm9ybSBlcnJvcnMgYWZ0ZXIgQUpWIHZhbGlkYXRpb25cbiAqIEBwYXJhbSBbdWlTY2hlbWFdIC0gQW4gb3B0aW9uYWwgdWlTY2hlbWEgdGhhdCBpcyBwYXNzZWQgdG8gYHRyYW5zZm9ybUVycm9yc2AgYW5kIGBjdXN0b21WYWxpZGF0ZWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvY2Vzc1Jhd1ZhbGlkYXRpb25FcnJvcnModmFsaWRhdG9yLCByYXdFcnJvcnMsIGZvcm1EYXRhLCBzY2hlbWEsIGN1c3RvbVZhbGlkYXRlLCB0cmFuc2Zvcm1FcnJvcnMsIHVpU2NoZW1hKSB7XG4gICAgY29uc3QgeyB2YWxpZGF0aW9uRXJyb3I6IGludmFsaWRTY2hlbWFFcnJvciB9ID0gcmF3RXJyb3JzO1xuICAgIGxldCBlcnJvcnMgPSB0cmFuc2Zvcm1SSlNGVmFsaWRhdGlvbkVycm9ycyhyYXdFcnJvcnMuZXJyb3JzLCB1aVNjaGVtYSk7XG4gICAgaWYgKGludmFsaWRTY2hlbWFFcnJvcikge1xuICAgICAgICBlcnJvcnMgPSBbLi4uZXJyb3JzLCB7IHN0YWNrOiBpbnZhbGlkU2NoZW1hRXJyb3IubWVzc2FnZSB9XTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1FcnJvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3JzID0gdHJhbnNmb3JtRXJyb3JzKGVycm9ycywgdWlTY2hlbWEpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JTY2hlbWEgPSB0b0Vycm9yU2NoZW1hKGVycm9ycyk7XG4gICAgaWYgKGludmFsaWRTY2hlbWFFcnJvcikge1xuICAgICAgICBlcnJvclNjaGVtYSA9IHtcbiAgICAgICAgICAgIC4uLmVycm9yU2NoZW1hLFxuICAgICAgICAgICAgJHNjaGVtYToge1xuICAgICAgICAgICAgICAgIF9fZXJyb3JzOiBbaW52YWxpZFNjaGVtYUVycm9yLm1lc3NhZ2VdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdXN0b21WYWxpZGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4geyBlcnJvcnMsIGVycm9yU2NoZW1hIH07XG4gICAgfVxuICAgIC8vIEluY2x1ZGUgZm9ybSBkYXRhIHdpdGggdW5kZWZpbmVkIHZhbHVlcywgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIGN1c3RvbSB2YWxpZGF0aW9uLlxuICAgIGNvbnN0IG5ld0Zvcm1EYXRhID0gZ2V0RGVmYXVsdEZvcm1TdGF0ZSh2YWxpZGF0b3IsIHNjaGVtYSwgZm9ybURhdGEsIHNjaGVtYSwgdHJ1ZSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gY3VzdG9tVmFsaWRhdGUobmV3Rm9ybURhdGEsIGNyZWF0ZUVycm9ySGFuZGxlcihuZXdGb3JtRGF0YSksIHVpU2NoZW1hKTtcbiAgICBjb25zdCB1c2VyRXJyb3JTY2hlbWEgPSB1bndyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyKTtcbiAgICByZXR1cm4gdmFsaWRhdGlvbkRhdGFNZXJnZSh7IGVycm9ycywgZXJyb3JTY2hlbWEgfSwgdXNlckVycm9yU2NoZW1hKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3NSYXdWYWxpZGF0aW9uRXJyb3JzLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImltcG9ydCB7IElEX0tFWSwgUk9PVF9TQ0hFTUFfUFJFRklYLCB0b0Vycm9yTGlzdCwgd2l0aElkUmVmUHJlZml4LCBoYXNoRm9yU2NoZW1hLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmltcG9ydCBjcmVhdGVBanZJbnN0YW5jZSBmcm9tICcuL2NyZWF0ZUFqdkluc3RhbmNlJztcbmltcG9ydCBwcm9jZXNzUmF3VmFsaWRhdGlvbkVycm9ycyBmcm9tICcuL3Byb2Nlc3NSYXdWYWxpZGF0aW9uRXJyb3JzJztcbi8qKiBgVmFsaWRhdG9yVHlwZWAgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIHRoZSBBSlYgOCB2YWxpZGF0aW9uIG1lY2hhbmlzbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUpWOFZhbGlkYXRvciB7XG4gICAgLyoqIENvbnN0cnVjdHMgYW4gYEFKVjhWYWxpZGF0b3JgIGluc3RhbmNlIHVzaW5nIHRoZSBgb3B0aW9uc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGBDdXN0b21WYWxpZGF0b3JPcHRpb25zVHlwZWAgb3B0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIGNyZWF0ZSB0aGUgQUpWIGluc3RhbmNlXG4gICAgICogQHBhcmFtIFtsb2NhbGl6ZXJdIC0gSWYgcHJvdmlkZWQsIGlzIHVzZWQgdG8gbG9jYWxpemUgYSBsaXN0IG9mIEFqdiBgRXJyb3JPYmplY3Rgc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGxvY2FsaXplcikge1xuICAgICAgICBjb25zdCB7IGFkZGl0aW9uYWxNZXRhU2NoZW1hcywgY3VzdG9tRm9ybWF0cywgYWp2T3B0aW9uc092ZXJyaWRlcywgYWp2Rm9ybWF0T3B0aW9ucywgQWp2Q2xhc3MgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYWp2ID0gY3JlYXRlQWp2SW5zdGFuY2UoYWRkaXRpb25hbE1ldGFTY2hlbWFzLCBjdXN0b21Gb3JtYXRzLCBhanZPcHRpb25zT3ZlcnJpZGVzLCBhanZGb3JtYXRPcHRpb25zLCBBanZDbGFzcyk7XG4gICAgICAgIHRoaXMubG9jYWxpemVyID0gbG9jYWxpemVyO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgYW4gYGVycm9yU2NoZW1hYCBpbnRvIGEgbGlzdCBvZiBgUkpTRlZhbGlkYXRpb25FcnJvcnNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JTY2hlbWEgLSBUaGUgYEVycm9yU2NoZW1hYCBpbnN0YW5jZSB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIFtmaWVsZFBhdGg9W11dIC0gVGhlIGN1cnJlbnQgZmllbGQgcGF0aCwgZGVmYXVsdHMgdG8gW10gaWYgbm90IHNwZWNpZmllZFxuICAgICAqIEBkZXByZWNhdGVkIC0gVXNlIHRoZSBgdG9FcnJvckxpc3QoKWAgZnVuY3Rpb24gcHJvdmlkZWQgYnkgYEByanNmL3V0aWxzYCBpbnN0ZWFkLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpblxuICAgICAqICAgICAgICB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAqL1xuICAgIHRvRXJyb3JMaXN0KGVycm9yU2NoZW1hLCBmaWVsZFBhdGggPSBbXSkge1xuICAgICAgICByZXR1cm4gdG9FcnJvckxpc3QoZXJyb3JTY2hlbWEsIGZpZWxkUGF0aCk7XG4gICAgfVxuICAgIC8qKiBSdW5zIHRoZSBwdXJlIHZhbGlkYXRpb24gb2YgdGhlIGBzY2hlbWFgIGFuZCBgZm9ybURhdGFgIHdpdGhvdXQgYW55IG9mIHRoZSBSSlNGIGZ1bmN0aW9uYWxpdHkuIFByb3ZpZGVkIGZvciB1c2VcbiAgICAgKiBieSB0aGUgcGxheWdyb3VuZC4gUmV0dXJucyB0aGUgYGVycm9yc2AgZnJvbSB0aGUgdmFsaWRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgYWdhaW5zdCB3aGljaCB0byB2YWxpZGF0ZSB0aGUgZm9ybSBkYXRhICAgKiBAcGFyYW0gc2NoZW1hXG4gICAgICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIGZvcm0gZGF0YSB0byB2YWxpZGF0ZVxuICAgICAqL1xuICAgIHJhd1ZhbGlkYXRpb24oc2NoZW1hLCBmb3JtRGF0YSkge1xuICAgICAgICBsZXQgY29tcGlsYXRpb25FcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbXBpbGVkVmFsaWRhdG9yO1xuICAgICAgICBpZiAoc2NoZW1hW0lEX0tFWV0pIHtcbiAgICAgICAgICAgIGNvbXBpbGVkVmFsaWRhdG9yID0gdGhpcy5hanYuZ2V0U2NoZW1hKHNjaGVtYVtJRF9LRVldKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVkVmFsaWRhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb21waWxlZFZhbGlkYXRvciA9IHRoaXMuYWp2LmNvbXBpbGUoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBpbGVkVmFsaWRhdG9yKGZvcm1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb21waWxhdGlvbkVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJvcnM7XG4gICAgICAgIGlmIChjb21waWxlZFZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxvY2FsaXplciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxpemVyKGNvbXBpbGVkVmFsaWRhdG9yLmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMgPSBjb21waWxlZFZhbGlkYXRvci5lcnJvcnMgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3JzIHRvIHByZXZlbnQgcGVyc2lzdGVudCBlcnJvcnMsIHNlZSAjMTEwNFxuICAgICAgICAgICAgY29tcGlsZWRWYWxpZGF0b3IuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3I6IGNvbXBpbGF0aW9uRXJyb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBUaGlzIGZ1bmN0aW9uIHByb2Nlc3NlcyB0aGUgYGZvcm1EYXRhYCB3aXRoIGFuIG9wdGlvbmFsIHVzZXIgY29udHJpYnV0ZWQgYGN1c3RvbVZhbGlkYXRlYCBmdW5jdGlvbiwgd2hpY2ggcmVjZWl2ZXNcbiAgICAgKiB0aGUgZm9ybSBkYXRhIGFuZCBhIGBlcnJvckhhbmRsZXJgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFkZCBjdXN0b20gdmFsaWRhdGlvbiBlcnJvcnMgZm9yIGVhY2ggZmllbGQuIEFsc29cbiAgICAgKiBzdXBwb3J0cyBhIGB0cmFuc2Zvcm1FcnJvcnNgIGZ1bmN0aW9uIHRoYXQgd2lsbCB0YWtlIHRoZSByYXcgQUpWIHZhbGlkYXRpb24gZXJyb3JzLCBwcmlvciB0byBjdXN0b20gdmFsaWRhdGlvbiBhbmRcbiAgICAgKiB0cmFuc2Zvcm0gdGhlbSBpbiB3aGF0IGV2ZXIgd2F5IGl0IGNob29zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgZm9ybSBkYXRhIHRvIHZhbGlkYXRlXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgYWdhaW5zdCB3aGljaCB0byB2YWxpZGF0ZSB0aGUgZm9ybSBkYXRhXG4gICAgICogQHBhcmFtIFtjdXN0b21WYWxpZGF0ZV0gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gcGVyZm9ybSBjdXN0b20gdmFsaWRhdGlvblxuICAgICAqIEBwYXJhbSBbdHJhbnNmb3JtRXJyb3JzXSAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byB0cmFuc2Zvcm0gZXJyb3JzIGFmdGVyIEFKViB2YWxpZGF0aW9uXG4gICAgICogQHBhcmFtIFt1aVNjaGVtYV0gLSBBbiBvcHRpb25hbCB1aVNjaGVtYSB0aGF0IGlzIHBhc3NlZCB0byBgdHJhbnNmb3JtRXJyb3JzYCBhbmQgYGN1c3RvbVZhbGlkYXRlYFxuICAgICAqL1xuICAgIHZhbGlkYXRlRm9ybURhdGEoZm9ybURhdGEsIHNjaGVtYSwgY3VzdG9tVmFsaWRhdGUsIHRyYW5zZm9ybUVycm9ycywgdWlTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgcmF3RXJyb3JzID0gdGhpcy5yYXdWYWxpZGF0aW9uKHNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jhd1ZhbGlkYXRpb25FcnJvcnModGhpcywgcmF3RXJyb3JzLCBmb3JtRGF0YSwgc2NoZW1hLCBjdXN0b21WYWxpZGF0ZSwgdHJhbnNmb3JtRXJyb3JzLCB1aVNjaGVtYSk7XG4gICAgfVxuICAgIC8qKiBWYWxpZGF0ZXMgZGF0YSBhZ2FpbnN0IGEgc2NoZW1hLCByZXR1cm5pbmcgdHJ1ZSBpZiB0aGUgZGF0YSBpcyB2YWxpZCwgb3JcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuIElmIHRoZSBzY2hlbWEgaXMgaW52YWxpZCwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuXG4gICAgICogZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBhZ2FpbnN0IHdoaWNoIHRvIHZhbGlkYXRlIHRoZSBmb3JtIGRhdGFcbiAgICAgKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgZm9ybSBkYXRhIHRvIHZhbGlkYXRlXG4gICAgICogQHBhcmFtIHJvb3RTY2hlbWEgLSBUaGUgcm9vdCBzY2hlbWEgdXNlZCB0byBwcm92aWRlICRyZWYgcmVzb2x1dGlvbnNcbiAgICAgKi9cbiAgICBpc1ZhbGlkKHNjaGVtYSwgZm9ybURhdGEsIHJvb3RTY2hlbWEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgcm9vdFNjaGVtYUlkID0gKF9hID0gcm9vdFNjaGVtYVtJRF9LRVldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBST09UX1NDSEVNQV9QUkVGSVg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHJvb3RTY2hlbWEgUk9PVF9TQ0hFTUFfUFJFRklYIGFzIGlkLlxuICAgICAgICAgICAgLy8gdGhlbiByZXdyaXRlIHRoZSBzY2hlbWEgcmVmJ3MgdG8gcG9pbnQgdG8gdGhlIHJvb3RTY2hlbWFcbiAgICAgICAgICAgIC8vIHRoaXMgYWNjb3VudHMgZm9yIHRoZSBjYXNlIHdoZXJlIHNjaGVtYSBoYXZlIHJlZmVyZW5jZXMgdG8gbW9kZWxzXG4gICAgICAgICAgICAvLyB0aGF0IGxpdmVzIGluIHRoZSByb290U2NoZW1hIGJ1dCBub3QgaW4gdGhlIHNjaGVtYSBpbiBxdWVzdGlvbi5cbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmFqdi5nZXRTY2hlbWEocm9vdFNjaGVtYUlkKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHJlc3RvcmUgdGhlIGNvbW1lbnRlZCBvdXQgYGlmYCBhYm92ZSB3aGVuIHRoZSBUT0RPIGluIHRoZSBgZmluYWxseWAgaXMgY29tcGxldGVkXG4gICAgICAgICAgICB0aGlzLmFqdi5hZGRTY2hlbWEocm9vdFNjaGVtYSwgcm9vdFNjaGVtYUlkKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYVdpdGhJZFJlZlByZWZpeCA9IHdpdGhJZFJlZlByZWZpeChzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hSWQgPSAoX2IgPSBzY2hlbWFXaXRoSWRSZWZQcmVmaXhbSURfS0VZXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaGFzaEZvclNjaGVtYShzY2hlbWFXaXRoSWRSZWZQcmVmaXgpO1xuICAgICAgICAgICAgbGV0IGNvbXBpbGVkVmFsaWRhdG9yO1xuICAgICAgICAgICAgY29tcGlsZWRWYWxpZGF0b3IgPSB0aGlzLmFqdi5nZXRTY2hlbWEoc2NoZW1hSWQpO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVkVmFsaWRhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgc2NoZW1hIGJ5IGFuIGV4cGxpY2l0IElEIHNvIGl0IGNhbiBiZSBmZXRjaGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nIGNvbXBpbGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9hanYuanMub3JnL2d1aWRlL21hbmFnaW5nLXNjaGVtYXMuaHRtbCNwcmUtYWRkaW5nLWFsbC1zY2hlbWFzLXZzLWFkZGluZy1vbi1kZW1hbmRcbiAgICAgICAgICAgICAgICBjb21waWxlZFZhbGlkYXRvciA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWp2LmFkZFNjaGVtYShzY2hlbWFXaXRoSWRSZWZQcmVmaXgsIHNjaGVtYUlkKS5nZXRTY2hlbWEoc2NoZW1hSWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFqdi5jb21waWxlKHNjaGVtYVdpdGhJZFJlZlByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21waWxlZFZhbGlkYXRvcihmb3JtRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGVuY291bnRlcmVkIGNvbXBpbGluZyBzY2hlbWE6JywgZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgaWYgdGhlIHJvb3Qgc2NoZW1hIGNoYW5nZXMgc28gd2UgZG9uJ3QgaGF2ZSB0byByZW1vdmUgYW5kIHJlY29tcGlsZSB0aGUgc2NoZW1hIGV2ZXJ5IHJ1bi5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSByZW1vdmUgdGhlIHJvb3RTY2hlbWEgZnJvbSB0aGUgZ2xvYmFsIGFqdiBpbnN0YW5jZVxuICAgICAgICAgICAgdGhpcy5hanYucmVtb3ZlU2NoZW1hKHJvb3RTY2hlbWFJZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYodGltZSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihkYXRlX3RpbWUsIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gICAgcmVnZXgsXG4gICAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICAgIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAgIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAgIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gICAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gICAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gICAgYnl0ZSxcbiAgICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgICBpbnQzMjogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMiB9LFxuICAgIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICAgIGludDY0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0IH0sXG4gICAgLy8gQy10eXBlIGZsb2F0XG4gICAgZmxvYXQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gQy10eXBlIGRvdWJsZVxuICAgIGRvdWJsZTogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgICBiaW5hcnk6IHRydWUsXG59O1xuZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXRzLFxuICAgIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gICAgdGltZTogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuZnVuY3Rpb24gdGltZShzdHIsIHdpdGhUaW1lWm9uZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBob3VyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgY29uc3Qgc2Vjb25kID0gK21hdGNoZXNbM107XG4gICAgY29uc3QgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09PSAyMyAmJiBtaW51dGUgPT09IDU5ICYmIHNlY29uZCA9PT0gNjApKSAmJlxuICAgICAgICAoIXdpdGhUaW1lWm9uZSB8fCB0aW1lWm9uZSAhPT0gXCJcIikpO1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdICsgKGExWzRdIHx8IFwiXCIpO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdICsgKGEyWzRdIHx8IFwiXCIpO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ207XG5mdW5jdGlvbiBieXRlKHN0cikge1xuICAgIEJZVEUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQllURS50ZXN0KHN0cik7XG59XG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlKSB7XG4gICAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRzXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRzXCIpO1xuY29uc3QgbGltaXRfMSA9IHJlcXVpcmUoXCIuL2xpbWl0XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGZ1bGxOYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZnVsbEZvcm1hdHNcIik7XG5jb25zdCBmYXN0TmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZhc3RGb3JtYXRzXCIpO1xuY29uc3QgZm9ybWF0c1BsdWdpbiA9IChhanYsIG9wdHMgPSB7IGtleXdvcmRzOiB0cnVlIH0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICBhZGRGb3JtYXRzKGFqdiwgb3B0cywgZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZSk7XG4gICAgICAgIHJldHVybiBhanY7XG4gICAgfVxuICAgIGNvbnN0IFtmb3JtYXRzLCBleHBvcnROYW1lXSA9IG9wdHMubW9kZSA9PT0gXCJmYXN0XCIgPyBbZm9ybWF0c18xLmZhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZV07XG4gICAgY29uc3QgbGlzdCA9IG9wdHMuZm9ybWF0cyB8fCBmb3JtYXRzXzEuZm9ybWF0TmFtZXM7XG4gICAgYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZvcm1hdHMsIGV4cG9ydE5hbWUpO1xuICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICBsaW1pdF8xLmRlZmF1bHQoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWApO1xuICAgIGZvciAoY29uc3QgZiBvZiBsaXN0KVxuICAgICAgICBhanYuYWRkRm9ybWF0KGYsIGZzW2ZdKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRzUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgY29kZWdlbl8xLl8gYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==