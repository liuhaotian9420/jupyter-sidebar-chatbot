"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_view_dist_index_js"],{

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),
/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),
/* harmony export */   BlockType: () => (/* binding */ BlockType),
/* harmony export */   Decoration: () => (/* binding */ Decoration),
/* harmony export */   Direction: () => (/* binding */ Direction),
/* harmony export */   EditorView: () => (/* binding */ EditorView),
/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),
/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),
/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),
/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),
/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),
/* harmony export */   WidgetType: () => (/* binding */ WidgetType),
/* harmony export */   __test: () => (/* binding */ __test),
/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),
/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),
/* harmony export */   drawSelection: () => (/* binding */ drawSelection),
/* harmony export */   dropCursor: () => (/* binding */ dropCursor),
/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),
/* harmony export */   getPanel: () => (/* binding */ getPanel),
/* harmony export */   getTooltip: () => (/* binding */ getTooltip),
/* harmony export */   gutter: () => (/* binding */ gutter),
/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),
/* harmony export */   gutterWidgetClass: () => (/* binding */ gutterWidgetClass),
/* harmony export */   gutters: () => (/* binding */ gutters),
/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),
/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),
/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),
/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),
/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),
/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),
/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),
/* harmony export */   keymap: () => (/* binding */ keymap),
/* harmony export */   layer: () => (/* binding */ layer),
/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),
/* harmony export */   lineNumberWidgetMarker: () => (/* binding */ lineNumberWidgetMarker),
/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),
/* harmony export */   logException: () => (/* binding */ logException),
/* harmony export */   panels: () => (/* binding */ panels),
/* harmony export */   placeholder: () => (/* binding */ placeholder),
/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),
/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),
/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),
/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),
/* harmony export */   showPanel: () => (/* binding */ showPanel),
/* harmony export */   showTooltip: () => (/* binding */ showTooltip),
/* harmony export */   tooltips: () => (/* binding */ tooltips)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ "webpack/sharing/consume/default/@codemirror/state/@codemirror/state");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! style-mod */ "webpack/sharing/consume/default/style-mod/style-mod");
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(style_mod__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.es.js");




function getSelection(root) {
    let target;
    // Browsers differ on whether shadow roots have a getSelection
    // method. If it exists, use that, otherwise, call it on the
    // document.
    if (root.nodeType == 11) { // Shadow root
        target = root.getSelection ? root : root.ownerDocument;
    }
    else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
                return false;
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
        return {
            left: 0, right: vp.width,
            top: 0, bottom: vp.height
        };
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
        scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
        scaleY = 1;
    return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop;) {
        if (cur.nodeType == 1) { // Element
            let bounding, top = cur == doc.body;
            let scaleX = 1, scaleY = 1;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                    stop = true;
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.assignedSlot || cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                ({ scaleX, scaleY } = getScale(cur, rect));
                // Make sure scrollbar width isn't included in the rectangle
                bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,
                    top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = -(bounding.top - rect.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY)
                        moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                }
                else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && (rect.top - moveY) < bounding.top)
                        moveY = -(bounding.top + moveY - rect.top + yMargin);
                }
            }
            else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                    y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                        rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = -(bounding.left - rect.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX)
                        moveX = rect.right - bounding.right + moveX + xMargin;
                }
                else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX)
                        moveX = -(bounding.left + moveX - rect.left + xMargin);
                }
            }
            else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                    (x == "start") == ltr ? rect.left - xMargin :
                        rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    let movedX = 0, movedY = 0;
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY / scaleY;
                        movedY = (cur.scrollTop - start) * scaleY;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX / scaleX;
                        movedX = (cur.scrollLeft - start) * scaleX;
                    }
                    rect = { left: rect.left - movedX, top: rect.top - movedY,
                        right: rect.right - movedX, bottom: rect.bottom - movedY };
                    if (movedX && Math.abs(movedX - moveX) < 1)
                        x = "nearest";
                    if (movedY && Math.abs(movedY - moveY) < 1)
                        y = "nearest";
                }
            }
            if (top)
                break;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) { // A shadow root
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
function scrollableParents(dom) {
    let doc = dom.ownerDocument, x, y;
    for (let cur = dom.parentNode; cur;) {
        if (cur == doc.body || (x && y)) {
            break;
        }
        else if (cur.nodeType == 1) {
            if (!y && cur.scrollHeight > cur.clientHeight)
                y = cur;
            if (!x && cur.scrollWidth > cur.clientWidth)
                x = cur;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) {
            cur = cur.host;
        }
        else {
            break;
        }
    }
    return { x, y };
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        let { anchorNode, focusNode } = range;
        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt, name, code, mods) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    if (mods)
        ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
        return false;
    // Safari can report bogus offsets (#1152)
    offset = Math.min(offset, maxOffset(node));
    for (;;) {
        if (offset) {
            if (node.nodeType != 1)
                return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
                offset--;
            else {
                node = prev;
                offset = maxOffset(node);
            }
        }
        else if (node == doc) {
            return true;
        }
        else {
            offset = domIndex(node);
            node = node.parentNode;
        }
    }
}
function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset > 0) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset > 0) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node);
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}
function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset;;) {
        if (node.nodeType == 3 && offset < node.nodeValue.length) {
            return { node: node, offset: offset };
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length) {
            if (node.contentEditable == "false")
                return null;
            node = node.childNodes[offset];
            offset = 0;
        }
        else if (node.parentNode && !isBlockElement(node)) {
            offset = domIndex(node) + 1;
            node = node.parentNode;
        }
        else {
            return null;
        }
    }
}

class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const noChildren = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2 /* ViewFlag.NodeDirty */;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    sync(view, track) {
        if (this.flags & 2 /* ViewFlag.NodeDirty */) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                        let contentView = ContentView.get(next);
                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                            child.reuseDOM(next);
                    }
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (track && !track.written && track.node == parent && next != child.dom)
                    track.written = true;
                if (child.dom.parentNode == parent) {
                    while (next && next != child.dom)
                        next = rm$1(next);
                }
                else {
                    parent.insertBefore(child.dom, next);
                }
                prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm$1(next);
        }
        else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
            for (let child of this.children)
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
        }
    }
    reuseDOM(_dom) { }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
    }
    markDirty(andParent = false) {
        this.flags |= 2 /* ViewFlag.NodeDirty */;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.flags |= 2 /* ViewFlag.NodeDirty */;
            if (parent.flags & 1 /* ViewFlag.ChildDirty */)
                return;
            parent.flags |= 1 /* ViewFlag.ChildDirty */;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.flags & 7 /* ViewFlag.Dirty */)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom == dom)
            return;
        if (this.dom)
            this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this && children.indexOf(child) < 0)
                child.destroy();
        }
        if (children.length < 250)
            this.children.splice(from, to - from, ...children);
        else
            this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
    get isEditable() { return true; }
    get isWidget() { return false; }
    get isHidden() { return false; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) { return false; }
    canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() { return 0; }
    destroy() {
        for (let child of this.children)
            if (child.parent == this)
                child.destroy();
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
// Remove a DOM node and return its next sibling.
function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert.length ? insert[insert.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    // Change within a single child
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
    if (toI < children.length) {
        let after = children[toI];
        // Make sure the end of the child after the update is preserved in `after`
        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
            // If we're splitting a child, separate part of it to avoid that
            // being mangled when updating the child before the update.
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            // If the element after the replacement should be merged with
            // the last replacing element, update `content`
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert[insert.length - 1] = after;
            }
            else {
                // Remove the start of the after element, if necessary, and
                // add it to `content`.
                if (toOff || after.children.length && !after.children[0].length)
                    after.merge(0, toOff, null, false, 0, openEnd);
                insert.push(after);
            }
        }
        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            // The element at `toI` is entirely covered by this range.
            // Preserve its line break, if any.
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                before.breakAfter = insert.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    // Try to merge widgets on the boundaries of the replacement
    while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
        }
        else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
        }
        else {
            break;
        }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
    if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert)
        dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}

let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /*@__PURE__*//Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /*@__PURE__*//MSIE \d/.test(nav.userAgent);
const ie_11up = /*@__PURE__*//Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /*@__PURE__*//gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /*@__PURE__*//Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);
const ios = safari && (/*@__PURE__*//Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
    mac: ios || /*@__PURE__*//Mac/.test(nav.platform),
    windows: /*@__PURE__*//Win/.test(nav.platform),
    linux: /*@__PURE__*//Linux|X11/.test(nav.platform),
    ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/*@__PURE__*//Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /*@__PURE__*//Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/*@__PURE__*//\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};

const MaxJoinLen = 256;
class TextView extends ContentView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3)
            this.createDOM(dom);
    }
    merge(from, to, source) {
        if ((this.flags & 8 /* ViewFlag.Composition */) ||
            source && (!(source instanceof TextView) ||
                this.length - (to - from) + source.length > MaxJoinLen ||
                (source.flags & 8 /* ViewFlag.Composition */)))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        result.flags |= this.flags & 8 /* ViewFlag.Composition */;
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
    }
    canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */)
            this.setAttrs(this.dom);
        super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
                result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
                detachFrom = i;
            off = end;
            i++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
            if (pos) {
                from--;
                flatten = 1;
            } // FIXME this is wrong in RTL text
            else if (to < length) {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else if (to < length)
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return null;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
// Also used for collapsed ranges that don't have a placeholder widget!
class WidgetView extends ContentView {
    static create(widget, length, side) {
        return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other instanceof WidgetView && other.side == this.side &&
            this.widget.constructor == other.widget.constructor) {
            if (!this.widget.compare(other.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let { view } = top, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty;
    }
    domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0)
            ? DOMPos.before(this.dom)
            : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return flattenRect(rect, !fromBack);
    }
    get isEditable() { return false; }
    get isWidget() { return true; }
    get isHidden() { return this.widget.isHidden; }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}
// These are drawn around uneditable widgets to avoid a number of
// browser bugs that show up when the cursor is directly next to
// uneditable inline content.
class WidgetBufferView extends ContentView {
    constructor(side) {
        super();
        this.side = side;
    }
    get length() { return 0; }
    merge() { return false; }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() { return new WidgetBufferView(this.side); }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
        }
    }
    getSide() { return this.side; }
    domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }
    localPosFromDOM() { return 0; }
    domBoundsAround() { return null; }
    coordsAt(pos) {
        return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty;
    }
    get isHidden() { return true; }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    for (let j = i; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
            return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
}
// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view, pos) {
        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
            let child = view.children[i], end = off + child.length;
            if (end >= pos) {
                if (child.children.length) {
                    scan(child, pos - off);
                }
                else if ((!after || after.isHidden && side > 0) &&
                    (end > pos || off == end && child.getSide() > 0)) {
                    after = child;
                    afterPos = pos - off;
                }
                else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {
                    before = child;
                    beforePos = pos - off;
                }
            }
            off = end;
        }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
}
function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
        return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}

function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
const noAttrs = /*@__PURE__*/Object.create(null);
function attrsEq(a, b, ignore) {
    if (a == b)
        return true;
    if (!a)
        a = noAttrs;
    if (!b)
        b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
        return false;
    for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs)) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = "";
                else
                    dom.removeAttribute(name);
            }
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name])) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = attrs[name];
                else
                    dom.setAttribute(name, attrs[name]);
            }
    return changed;
}
function getAttrs(dom) {
    let attrs = Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
        let attr = dom.attributes[i];
        attrs[attr.name] = attr.value;
    }
    return attrs;
}

/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even if the decorations
that define them are recreated.
*/
class WidgetType {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) { return false; }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view) { return false; }
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() { return -1; }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() { return 0; }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) { return true; }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queried—less than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) { return null; }
    /**
    @internal
    */
    get isHidden() { return false; }
    /**
    @internal
    */
    get editable() { return false; }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) { }
}
/**
The different types of blocks that can occur in an editor view.
*/
var BlockType = /*@__PURE__*/(function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
return BlockType})(BlockType || (BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
@nonabstract
*/
class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeValue {
    constructor(
    /**
    @internal
    */
    startSide, 
    /**
    @internal
    */
    endSide, 
    /**
    @internal
    */
    widget, 
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() { return false; }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;
        side += (block && !spec.inlineOrder)
            ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)
            : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = -500000000 /* Side.GapStart */;
            endSide = 400000000 /* Side.GapEnd */;
        }
        else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;
            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
        return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
/**
The empty set of decorations.
*/
Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        var _a, _b;
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
                attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration &&
            this.spec.class == other.spec.class &&
            attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
        return this.startSide != this.endSide ? BlockType.WidgetRange
            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}

class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this); // Reuse source.dom when appropriate
        }
        if (hasStart)
            this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        var _a;
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(view, track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
        if (!last || !this.length ||
            last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
            textHeight
        };
    }
    coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        // Correct rectangle height for empty lines when the returned
        // height is larger than the text height.
        if (!this.children.length && rect && this.parent) {
            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
                let dist = (height - heightOracle.textHeight) / 2;
                return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
            }
        }
        return rect;
    }
    become(other) {
        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 &&
            attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() { return true; }
    static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (end > pos)
                    break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() { return noChildren; }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            if (!this.widget.editable)
                this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty;
    }
    domBoundsAround() { return null; }
    become(other) {
        if (other instanceof BlockWidgetView &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.compare(this.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.deco = other.deco;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get isEditable() { return false; }
    get isWidget() { return true; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        if (this.widget instanceof BlockGapWidget)
            return null;
        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
    covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        elt.className = "cm-gap";
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get editable() { return true; }
    get estimatedHeight() { return this.height; }
    ignoreEvent() { return false; }
}

class ContentBuilder {
    constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0 /* Buf.No */;
        this.bufferMarks = [];
        // Set to false directly after a widget that covers the position after it
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0 /* Buf.No */;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
            this.flushBuffer();
        else
            this.pendingBuffer = 0 /* Buf.No */;
        if (!this.posCovered() &&
            !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
            this.getLine();
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.flushBuffer();
                    this.curLine = null;
                    this.atCursorPos = true;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
            this.flushBuffer(active.slice(active.length - openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                if (deco.startSide > 0 && !this.posCovered())
                    this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
            }
            else {
                let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&
                    (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable)
                    this.pendingBuffer = 0 /* Buf.No */;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
                if (this.pendingBuffer)
                    this.bufferMarks = active.slice();
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            // Advance the iterator past the replaced content
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)
        view = new MarkView(mark, [view], view.length);
    return view;
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
    get isHidden() { return true; }
}
NullWidget.inline = /*@__PURE__*/new NullWidget("span");
NullWidget.block = /*@__PURE__*/new NullWidget("div");

/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
var Direction = /*@__PURE__*/(function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
return Direction})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
// Decode a string with each type encoded as log2(type)
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
// Character types for codepoints 0 to 0xf8
const LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
// Character types for codepoints 0x600 to 0x6f9
const ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];
// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for (let p of ["()", "[]", "{}"]) {
    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :
                    0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */ :
                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : 1 /* T.L */;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
class BidiSpan {
    /**
    The direction of this span.
    */
    get dir() { return this.level % 2 ? RTL : LTR; }
    /**
    @internal
    */
    constructor(
    /**
    The start of the span (relative to the start of the line).
    */
    from, 
    /**
    The end of the span.
    */
    to, 
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    /**
    @internal
    */
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    /**
    @internal
    */
    forward(forward, dir) { return forward == (this.dir == dir); }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                // When multiple spans match, if assoc != 0, take the one that
                // covers that side, otherwise take the one with the minimum
                // level.
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
function isolatesEq(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        let iA = a[i], iB = b[i];
        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
            return false;
    }
    return true;
}
// Reused array of character types
const types = [];
// Fill in the character types (in `types`) from `from` to `to` and
// apply W normalization rules.
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        let prevType = iI ? 256 /* T.NI */ : outerType;
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        // (Left after this: L, R, EN, AN, ET, CS, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512 /* T.NSM */)
                type = prev;
            else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
                type = 16 /* T.AN */;
            types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
            prev = type;
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        // (Left after this: L, R, EN+AN, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = types[i];
            if (type == 128 /* T.CS */) {
                if (i < to - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))
                    type = types[i] = prev;
                else
                    types[i] = 256 /* T.NI */;
            }
            else if (type == 64 /* T.ET */) {
                let end = i + 1;
                while (end < to && types[end] == 64 /* T.ET */)
                    end++;
                let replace = (i && prev == 8 /* T.EN */) || (end < rTo && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;
                for (let j = i; j < end; j++)
                    types[j] = replace;
                i = end - 1;
            }
            else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
                types[i] = 1 /* T.L */;
            }
            prev = type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
        }
    }
}
// Process brackets throughout a run sequence.
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N0. Process bracket pairs in an isolating run sequence
        // sequentially in the logical order of the text positions of the
        // opening paired brackets using the logic given below. Within this
        // scope, bidirectional types EN and AN are treated as R.
        for (let i = from, ch, br, type; i < to; i++) {
            // Keeps [startIndex, type, strongSeen] triples for each open
            // bracket on BracketStack.
            if (br = Brackets[ch = line.charCodeAt(i)]) {
                if (br < 0) { // Closing bracket
                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                        if (BracketStack[sJ + 1] == -br) {
                            let flags = BracketStack[sJ + 2];
                            let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :
                                !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :
                                    (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;
                            if (type)
                                types[i] = types[BracketStack[sJ]] = type;
                            sI = sJ;
                            break;
                        }
                    }
                }
                else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
                    break;
                }
                else {
                    BracketStack[sI++] = i;
                    BracketStack[sI++] = ch;
                    BracketStack[sI++] = context;
                }
            }
            else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
                let embed = type == outerType;
                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    let cur = BracketStack[sJ + 2];
                    if (cur & 2 /* Bracketed.EmbedInside */)
                        break;
                    if (embed) {
                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;
                    }
                    else {
                        if (cur & 4 /* Bracketed.OppositeInside */)
                            break;
                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;
                    }
                }
            }
        }
    }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        // (Left after this: L, R, EN+AN)
        for (let i = from; i < to;) {
            let type = types[i];
            if (type == 256 /* T.NI */) {
                let end = i + 1;
                for (;;) {
                    if (end == to) {
                        if (iI == isolates.length)
                            break;
                        end = isolates[iI++].to;
                        to = iI < isolates.length ? isolates[iI].from : rTo;
                    }
                    else if (types[end] == 256 /* T.NI */) {
                        end++;
                    }
                    else {
                        break;
                    }
                }
                let beforeL = prev == 1 /* T.L */;
                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;
                let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;
                for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
                    if (j == fromJ) {
                        j = isolates[--jI].from;
                        fromJ = jI ? isolates[jI - 1].to : rFrom;
                    }
                    types[--j] = replace;
                }
                i = end;
            }
            else {
                prev = type;
                i++;
            }
        }
    }
}
// Find the contiguous ranges of character types in a given range, and
// emit spans for them. Flip the order of the spans as appropriate
// based on the level, and call through to compute the spans for
// isolates at the proper point.
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
    if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip
        for (let iCh = from, iI = 0; iCh < to;) {
            // Scan a section of characters in direction ourType, unless
            // there's another type of char right after iCh, in which case
            // we scan a section of other characters (which, if ourType ==
            // T.L, may contain both T.R and T.AN chars).
            let sameDir = true, isNum = false;
            if (iI == isolates.length || iCh < isolates[iI].from) {
                let next = types[iCh];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            // Holds an array of isolates to pass to a recursive call if we
            // must recurse (to distinguish T.AN inside an RTL section in
            // LTR text), null if we can emit directly
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI < isolates.length && iScan == isolates[iI].from) {
                    if (isNum)
                        break run;
                    let iso = isolates[iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.to, jI = iI + 1;;) {
                            if (upto == to)
                                break run;
                            if (jI < isolates.length && isolates[jI].from == upto)
                                upto = isolates[jI++].to;
                            else if (types[upto] == ourType)
                                break run;
                            else
                                break;
                        }
                    iI++;
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.from > iCh)
                            order.push(new BidiSpan(iCh, iso.from, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.to;
                    }
                    iScan = iso.to;
                }
                else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
                    break;
                }
                else {
                    iScan++;
                }
            }
            if (recurse)
                emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
            else if (iCh < iScan)
                order.push(new BidiSpan(iCh, iScan, localLevel));
            iCh = iScan;
        }
    }
    else {
        // Iterate in reverse to flip the span order. Same code again, but
        // going from the back of the section to the front
        for (let iCh = to, iI = isolates.length; iCh > from;) {
            let sameDir = true, isNum = false;
            if (!iI || iCh > isolates[iI - 1].to) {
                let next = types[iCh - 1];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI && iScan == isolates[iI - 1].to) {
                    if (isNum)
                        break run;
                    let iso = isolates[--iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.from, jI = iI;;) {
                            if (upto == from)
                                break run;
                            if (jI && isolates[jI - 1].to == upto)
                                upto = isolates[--jI].from;
                            else if (types[upto - 1] == ourType)
                                break run;
                            else
                                break;
                        }
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.to < iCh)
                            order.push(new BidiSpan(iso.to, iCh, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.from;
                    }
                    iScan = iso.from;
                }
                else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
                    break;
                }
                else {
                    iScan--;
                }
            }
            if (recurse)
                emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
            else if (iScan < iCh)
                order.push(new BidiSpan(iScan, iCh, localLevel));
            iCh = iScan;
        }
    }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
    if (!line)
        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length);
    if (isolates.length)
        while (line.length > types.length)
            types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
// This implementation moves strictly visually, without concern for a
// traversal visiting every logical position in the string. It will
// still do so for simple input, but situations like multiple isolates
// with the same level next to each other, or text going against the
// main dir at the end of the line, will make some positions
// unreachable with this motion. Each visible cursor position will
// correspond to the lower-level bidi span that touches it.
//
// The alternative would be to solve an order globally for a given
// line, making sure that it includes every position, but that would
// require associating non-canonical (higher bidi span level)
// positions with a given visual position, which is likely to confuse
// people. (And would generally be a lot more complicated.)
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    // End of span
    if (startIndex == spanEnd) {
        let nextI = spanI += forward ? 1 : -1;
        if (nextI < 0 || nextI >= order.length)
            return null;
        span = order[spanI = nextI];
        startIndex = span.side(!forward, dir);
        spanEnd = span.side(forward, dir);
    }
    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to)
        nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
    for (let i = from; i < to; i++) {
        let type = charType(text.charCodeAt(i));
        if (type == 1 /* T.L */)
            return LTR;
        if (type == 2 /* T.R */ || type == 4 /* T.AL */)
            return RTL;
    }
    return LTR;
}

const clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const focusChangeEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const clipboardInputFilter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const clipboardOutputFilter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const perLineTextDirection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine: values => values.some(x => x)
});
const nativeSelectionHidden = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine: values => values.some(x => x)
});
const scrollHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, 
    // This data structure is abused to also store precise scroll
    // snapshots, instead of a `scrollIntoView` request. When this
    // flag is `true`, `range` points at a position in the reference
    // line, `yMargin` holds the difference between the top of that
    // line and the top of the editor, and `xMargin` holds the
    // editor's `scrollLeft`.
    isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
    }
    map(changes) {
        return changes.empty ? this :
            new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
        return this.range.to <= state.doc.length ? this :
            new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
}
const scrollIntoView = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({ map: (t, ch) => t.map(ch) });
const setEditContextFormatting = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror)
        window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({ combine: values => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
class ViewPlugin {
    constructor(
    /**
    @internal
    */
    id, 
    /**
    @internal
    */
    create, 
    /**
    @internal
    */
    domEventHandlers, 
    /**
    @internal
    */
    domEventObservers, buildExtensions) {
        this.id = id;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {
            let ext = [viewPlugin.of(plugin)];
            if (deco)
                ext.push(decorations.of(view => {
                    let pluginInst = view.plugin(plugin);
                    return pluginInst ? deco(pluginInst) : Decoration.none;
                }));
            if (provide)
                ext.push(provide(plugin));
            return ext;
        });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
        return ViewPlugin.define(view => new cls(view), spec);
    }
}
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null;
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null;
    }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.create(view);
                }
                catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                }
                catch (e) {
                    logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy)
                        try {
                            this.value.destroy();
                        }
                        catch (_) { }
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
// Provide decorations
const decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const outerDecorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const atomicRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const bidiIsolatedRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
        return isolates;
    let sets = isolates.map(i => i instanceof Function ? i(view) : i);
    let result = [];
    _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.spans(sets, line.from, line.to, {
        point() { },
        span(fromDoc, toDoc, active, open) {
            let from = fromDoc - line.from, to = toDoc - line.from;
            let level = result;
            for (let i = active.length - 1; i >= 0; i--, open--) {
                let direction = active[i].spec.bidiIsolate, update;
                if (direction == null)
                    direction = autoDirection(line.text, from, to);
                if (open > 0 && level.length &&
                    (update = level[level.length - 1]).to == from && update.direction == direction) {
                    update.to = to;
                    level = update.inner;
                }
                else {
                    let add = { from, to, direction, inner: [] };
                    level.push(add);
                    level = add.inner;
                }
            }
        }
    });
    return result;
}
const scrollMargins = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
function getScrollMargins(view) {
    let left = 0, right = 0, top = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
        let m = source(view);
        if (m) {
            if (m.left != null)
                left = Math.max(left, m.left);
            if (m.right != null)
                right = Math.max(right, m.right);
            if (m.top != null)
                top = Math.max(top, m.top);
            if (m.bottom != null)
                bottom = Math.max(bottom, m.bottom);
        }
    }
    return { left, right, top, bottom };
}
const styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
class ViewUpdate {
    constructor(
    /**
    The editor view that the update is associated with.
    */
    view, 
    /**
    The new editor state.
    */
    state, 
    /**
    The transactions involved in the update. May be empty.
    */
    transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        /**
        @internal
        */
        this.flags = 0;
        this.startState = view.state;
        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
        return (this.flags & 2 /* UpdateFlag.Height */) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
        return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    /**
    @internal
    */
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}

class DocView extends ContentView {
    get length() { return this.view.state.doc.length; }
    constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [false];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = new Set;
        this.editContextFormatting = Decoration.none;
        this.lastCompositionAfterCursor = false;
        // Track a minimum width for the editor. When measuring sizes in
        // measureVisibleLineHeights, this is updated to point at the width
        // of a given element and its extent in the document. When a change
        // happens in that range, these are reset. That way, once we've seen
        // a line/element of a given length, we keep the editor wide enough
        // to fit at least that element, until it is changed, at which point
        // we forget it again.
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        // Used by the resize observer to ignore resizes that we caused
        // ourselves
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update) {
        var _a;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        this.updateEditContextFormatting(update);
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)
                readCompositionAt = this.domChanged.newSel.head;
            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
                readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
            this.markedForComposition.clear();
            let { from, to } = this.hasComposition;
            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))
                .addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if ((browser.ie || browser.chrome) && !composition && update &&
            update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {
            return false;
        }
        else {
            this.updateInner(changedRanges, update.startState.doc.length, composition);
            if (update.transactions.length)
                this.lastUpdate = Date.now();
            return true;
        }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
            // Lock the height during redrawing, since Chrome sometimes
            // messes with the scroll position during DOM mutation (though
            // no relayout is triggered and I cannot imagine how it can
            // recompute the scroll position without a layout)
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            // Chrome will sometimes, when DOM mutations occur directly
            // around the selection, get confused and report a different
            // selection from the one it displays (issue #218). This tries
            // to detect that situation.
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
            this.sync(this.view, track);
            this.flags &= ~7 /* ViewFlag.Dirty */;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
                this.forceSelection = true;
            this.dom.style.height = "";
        });
        this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let child of this.children)
                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                    gaps.push(child.dom);
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor = this.childCursor(oldLength);
        for (let i = ranges.length - 1;; i--) {
            let next = i >= 0 ? ranges[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
                breakAtStart = before.breakAtStart;
                openStart = before.openStart;
                openEnd = after.openEnd;
                let compLine = this.compositionView(composition);
                if (after.breakAtStart) {
                    compLine.breakAfter = 1;
                }
                else if (after.content.length &&
                    compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                    compLine.breakAfter = after.content[0].breakAfter;
                    after.content.shift();
                }
                if (before.content.length &&
                    compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                    before.content.pop();
                }
                content = before.content.concat(compLine).concat(after.content);
            }
            else {
                ({ content, breakAtStart, openStart, openEnd } =
                    ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
            }
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
        if (composition)
            this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
        this.editContextFormatting = this.editContextFormatting.map(update.changes);
        for (let tr of update.transactions)
            for (let effect of tr.effects)
                if (effect.is(setEditContextFormatting)) {
                    this.editContextFormatting = effect.value;
                }
    }
    compositionView(composition) {
        let cur = new TextView(composition.text.nodeValue);
        cur.flags |= 8 /* ViewFlag.Composition */;
        for (let { deco } of composition.marks)
            cur = new MarkView(deco, [cur], cur.length);
        let line = new LineView;
        line.append(cur, 0);
        return line;
    }
    fixCompositionDOM(composition) {
        let fix = (dom, cView) => {
            cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);
            this.markedForComposition.add(cView);
            let prev = ContentView.get(dom);
            if (prev && prev != cView)
                prev.dom = null;
            cView.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i = composition.marks.length - 1; i >= -1; i--) {
            pos = cView.childPos(pos.off, 1);
            cView = cView.children[pos.i];
            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) &&
            hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
            return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
            this.view.observer.ignore(() => {
                // Chrome Android will hide the virtual keyboard when tapping
                // inside an uneditable node, and not bring it back when we
                // move the cursor to its proper position. This tries to
                // restore the keyboard by cycling focus.
                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                    inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({ preventScroll: true });
                }
                let rawSel = getSelection(this.view.root);
                if (!rawSel) ;
                else if (main.empty) {
                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                            let text = (nextTo == 1 /* NextTo.Before */ ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                            if (text)
                                anchor = new DOMPos(text.node, text.offset);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)
                        rawSel.caretBidiLevel = main.bidiLevel;
                }
                else if (rawSel.extend) {
                    // Selection.extend can be used to create an 'inverted' selection
                    // (one where the focus is before the anchor), but not all
                    // browsers support it yet.
                    rawSel.collapse(anchor.node, anchor.offset);
                    // Safari will ignore the call above when the editor is
                    // hidden, and then raise an error on the call to extend
                    // (#940).
                    try {
                        rawSel.extend(head.node, head.offset);
                    }
                    catch (_) { }
                }
                else {
                    // Primitive (IE) way
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
                if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                    this.dom.blur();
                    if (activeElt)
                        activeElt.focus();
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    // If a zero-length widget is inserted next to the cursor during
    // composition, avoid moving it across it and disrupting the
    // composition.
    suppressWidgetCursorChange(sel, cursor) {
        return this.hasComposition && cursor.empty &&
            isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) &&
            this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
        if (this.hasComposition)
            return;
        let { view } = this, cursor = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head);
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        // This can go wrong in corner cases like single-character lines,
        // so check and reset if necessary.
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
            sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
        // Block widgets will return positions before/after them, which
        // are thus directly in the document DOM element.
        let dom = this.dom, newPos;
        if (pos.node != dom)
            return pos;
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(0);
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
            if (end < pos)
                break;
            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) &&
                (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
                best = child;
                bestPos = start;
            }
            else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
                if (child.deco.startSide < 0)
                    break;
                else if (i)
                    best = null;
            }
            off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1), child = this.children[i];
        if (!(child instanceof LineView))
            return null;
        while (child.children.length) {
            let { i, off: childOff } = child.childPos(off, 1);
            for (;; i++) {
                if (i == child.children.length)
                    return null;
                if ((child = child.children[i]).length)
                    break;
            }
            off = childOff;
        }
        if (!(child instanceof TextView))
            return null;
        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(child.text, off);
        if (end == off)
            return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
                return rect;
        }
        return null;
    }
    measureVisibleLineHeights(viewport) {
        let result = [], { from, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            textHeight = rect ? rect.height : lineHeight;
            dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true,
                }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let i = 1;
        let allDeco = this.view.state.facet(decorations).map(d => {
            let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
            return dynamic ? d(this.view) : d;
        });
        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i) => {
            let dynamic = typeof d == "function";
            if (dynamic)
                dynamicOuter = true;
            return dynamic ? d(this.view) : d;
        });
        if (outerDeco.length) {
            this.dynamicDecorationMap[i++] = dynamicOuter;
            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.join(outerDeco));
        }
        this.decorations = [
            this.editContextFormatting,
            ...allDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
        while (i < this.decorations.length)
            this.dynamicDecorationMap[i++] = false;
        return this.decorations;
    }
    scrollIntoView(target) {
        if (target.isSnapshot) {
            let ref = this.view.viewState.lineBlockAt(target.range.head);
            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
            this.view.scrollDOM.scrollLeft = target.xMargin;
            return;
        }
        for (let handler of this.view.state.facet(scrollHandler)) {
            try {
                if (handler(this.view, target.range, target))
                    return true;
            }
            catch (e) {
                logException(this.view.state, e, "scroll handler");
            }
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
            return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
        let margins = getScrollMargins(this.view);
        let targetRect = {
            left: rect.left - margins.left, top: rect.top - margins.top,
            right: rect.right + margins.right, bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode)
        return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
        let descAfter = ContentView.get(textAfter.node);
        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
            textNode = textAfter;
        }
        else if (view.docView.lastCompositionAfterCursor) {
            let descBefore = ContentView.get(textBefore.node);
            if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
                textNode = textAfter;
        }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
        return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
        return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    // Don't try to preserve multi-line compositions
    if (/[\n\r]/.test(text))
        return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
        return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks = [];
    for (let parent = textNode.parentNode;; parent = parent.parentNode) {
        let parentView = ContentView.get(parent);
        if (parentView instanceof MarkView)
            marks.push({ node: parent, deco: parentView.mark });
        else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
            return { range, text: textNode, marks, line: parent };
        else if (parent != view.contentDOM)
            marks.push({ node: parent, deco: new MarkDecoration({
                    inclusive: true,
                    attributes: getAttrs(parent),
                    tagName: parent.tagName.toLowerCase()
                }) });
        else
            return null;
    }
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
}
let DecorationComparator$1 = class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
    boundChange(pos) { addRange(pos, pos, this.changes); }
};
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside) {
    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}
function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
        changes.iterChangedRanges((from, to) => {
            if (from < composition.to && to > composition.from)
                touched = true;
        });
    return touched;
}

function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(line.text, linePos, false);
    else
        to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(from + line.from, to + line.from);
}
// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
                let side = dy ? (y < rect.top ? -1 : 1) : dx ? (x < rect.left ? -1 : 1) : 0;
                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    // Check for RTL on browsers that support getting client
                    // rects for empty ranges.
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
    var _a, _b;
    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y } = coords, yOffset = y - docTop;
    if (yOffset < 0)
        return 0;
    if (yOffset > docHeight)
        return view.state.doc.length;
    // Scan for a text block near the queried y position
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text)
            break;
        for (;;) {
            // Move the y position out of this block
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
                break;
            // If the document consists entirely of replaced widgets, we
            // won't find a text block, so return 0
            if (bounced)
                return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length :
            precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
    let doc = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
        element = null;
    // If the element is unexpected, clip x at the sides of the content area and try again
    if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
    }
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    let node, offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
        if (doc.caretPositionFromPoint) {
            let pos = doc.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (doc.caretRangeFromPoint) {
            let range = doc.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (!view.contentDOM.contains(node) ||
                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                    node = undefined;
            }
        }
        // Chrome will return offsets into <input> elements without child
        // nodes, which will lead to a null deref below, so clip the
        // offset to the node size.
        if (node)
            offset = Math.min(maxOffset(node), offset);
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
        return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
        let rect = nearest.dom.getBoundingClientRect();
        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2
            ? nearest.posAtStart : nearest.posAtEnd;
    }
    else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight;
        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content = view.state.sliceDoc(block.from, block.to);
    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findColumn)(content, into, view.state.tabSize);
}
// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
        if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
// Chrome will move positions between lines to the start of the next line
function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
        return false;
    for (let cur = node;;) {
        let parent = cur.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
        if (parent.classList.contains("cm-line"))
            break;
        cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect()
        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
}
function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
        for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
                return l;
        }
    return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = view.visualLineSide(line, !forward);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.CharCategory.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null)
            goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    }
    else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);
    for (let extra = 0;; extra += 10) {
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
            let charRect = view.docView.coordsForChar(pos);
            let assoc = !charRect || curY < charRect.top ? -1 : 1;
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos, assoc, undefined, goal);
        }
    }
}
function skipAtomicRanges(atoms, pos, bias) {
    for (;;) {
        let moved = 0;
        for (let set of atoms) {
            set.between(pos - 1, pos + 1, (from, to, value) => {
                if (pos > from && pos < to) {
                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);
                    pos = side < 0 ? from : to;
                    moved = side;
                }
            });
        }
        if (!moved)
            return pos;
    }
}
function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}

const LineBreakPlaceholder = "\uffff";
class DOMReader {
    constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start)
            return this;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            let oldLen = this.text.length;
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter :
                (view ? view.breakAfter : isBlockElement(cur)) ||
                    (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen))
                this.lineBreak();
            cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            }
            else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
                break;
            this.lineBreak();
            if (breakSize > 1)
                for (let point of this.points)
                    if (point.node == node && point.pos > this.text.length)
                        point.pos -= breakSize - 1;
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done;) {
                if (i.lineBreak)
                    this.lineBreak();
                else
                    this.append(i.value);
            }
        }
        else if (node.nodeType == 3) {
            this.readTextNode(node);
        }
        else if (node.nodeName == "BR") {
            if (node.nextSibling)
                this.lineBreak();
        }
        else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointInside(node, length) {
        for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
}
function isAtEnd(parent, node, offset) {
    for (;;) {
        if (!node || offset < maxOffset(node))
            return false;
        if (node == parent)
            return true;
        offset = domIndex(node) + 1;
        node = node.parentNode;
    }
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}

class DOMChange {
    constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        this.domChanged = start > -1;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
            // Ignore changes when the editor is read-only
            this.newSel = null;
        }
        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
            let reader = new DOMReader(selPoints, view.state);
            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
            this.text = reader.text;
            this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        }
        else {
            let domSel = view.observer.selectionRange;
            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
                !contains(view.contentDOM, domSel.focusNode)
                ? view.state.selection.main.head
                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
                !contains(view.contentDOM, domSel.anchorNode)
                ? view.state.selection.main.anchor
                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
            // iOS will refuse to select the block gaps when doing
            // select-all.
            // Chrome will put the selection *inside* them, confusing
            // posFromDOM
            let vp = view.viewport;
            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor &&
                (vp.from > 0 || vp.to < view.state.doc.length)) {
                let from = Math.min(head, anchor), to = Math.max(head, anchor);
                let offFrom = vp.from - from, offTo = vp.to - to;
                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
                    head = 0;
                    anchor = view.state.doc.length;
                }
            }
            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.single(anchor, head);
        }
    }
}
function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
        let { from, to } = domChange.bounds;
        let preferredPos = sel.from, preferredSide = null;
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
        if (diff) {
            // Chrome inserts two newlines when pressing shift-enter at the
            // end of a line. DomChange drops one of those.
            if (browser.chrome && lastKey == 13 &&
                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                diff.toB--;
            change = { from: from + diff.from, to: from + diff.toA,
                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
        }
    }
    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
        newSel = null;
    }
    if (!change && !newSel)
        return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
        // Heuristic to notice typing over a selected character
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    }
    else if (change && change.from >= sel.from && change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        (sel.to - sel.from) - (change.to - change.from) <= 4) {
        // If the change is inside the selection and covers most of it,
        // assume it is a selection replace (with identical characters at
        // the start/end not included in the diff)
        change = {
            from: sel.from, to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
    }
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
        // Detect insert-period-on-double-space Mac and Android behavior,
        // and transform it into a regular space insert.
        if (newSel && change.insert.length == 2)
            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.of([" "]) };
    }
    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&
        change.insert.toString() == "\n " && view.lineWrapping) {
        // In Chrome, if you insert a space at the start of a wrapped
        // line, it will actually insert a newline and a space, causing a
        // bogus new line to be created in CodeMirror (#968)
        if (newSel)
            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.of([" "]) };
    }
    if (change) {
        return applyDOMChangeInner(view, change, newSel, lastKey);
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
                scrollIntoView = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent });
        return true;
    }
    else {
        return false;
    }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser.ios && view.inputState.flushIOSKey(change))
        return true;
    let sel = view.state.selection.main;
    // Android browsers don't fire reasonable key events for enter,
    // backspace, or delete. So this detects changes that look like
    // they're caused by those keys, and reinterprets them as key
    // events. (Some of these keys are also handled by beforeinput
    // events and the pendingAndroidKey mechanism, but that's not
    // reliable in all situations.)
    if (browser.android &&
        ((change.to == sel.to &&
            // GBoard will sometimes remove a space it just inserted
            // after a completion when you press enter
            (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") &&
            change.insert.length == 1 && change.insert.lines == 2 &&
            dispatchKey(view.contentDOM, "Enter", 13)) ||
            ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||
                lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&
                dispatchKey(view.contentDOM, "Backspace", 8)) ||
            (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                dispatchKey(view.contentDOM, "Delete", 46))))
        return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0)
        view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert)))
        view.dispatch(defaultInsert());
    return true;
}
function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
        (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
        view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    }
    else {
        let changes = startState.changes(change);
        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
        // Try to apply a composition change to all cursors
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
            change.to <= sel.to && change.to >= sel.to - 10) {
            let replaced = view.state.sliceDoc(change.from, change.to);
            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
            if (composition) {
                let dLen = change.insert.length - (change.to - change.from);
                compositionRange = { from: composition.from, to: composition.to - dLen };
            }
            else {
                compositionRange = view.state.doc.lineAt(sel.head);
            }
            let offset = sel.to - change.to, size = sel.to - sel.from;
            tr = startState.changeByRange(range => {
                if (range.from == sel.from && range.to == sel.to)
                    return { changes, range: mainSel || range.map(changes) };
                let to = range.to - offset, from = to - replaced.length;
                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                    // Unfortunately, there's no way to make multiple
                    // changes in the same node work without aborting
                    // composition, so cursors in the composition range are
                    // ignored.
                    range.to >= compositionRange.from && range.from <= compositionRange.to)
                    return { range };
                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                return {
                    changes: rangeChanges,
                    range: !mainSel ? range.map(rangeChanges) :
                        _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                };
            });
        }
        else {
            tr = {
                changes,
                selection: mainSel && startState.selection.replaceRange(mainSel)
            };
        }
    }
    let userEvent = "input.type";
    if (view.composing ||
        view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
        view.inputState.compositionPendingChange = false;
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
            userEvent += ".start";
            view.inputState.compositionFirstChange = false;
        }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.single(anchor + base, head + base) : null;
}

class InputState {
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        // On iOS, some keys need to have their default behavior happen
        // (after which we retroactively handle them and reset the DOM) to
        // avoid messing up the virtual keyboard state.
        this.pendingIOSKey = undefined;
        /**
        When enabled (>-1), tab presses are not given to key handlers,
        leaving the browser's default behavior. If >0, the mode expires
        at that timestamp, and any other keypress clears it.
        Esc enables temporary tab focus mode for two seconds when not
        otherwise handled.
        */
        this.tabFocusMode = -1;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = Object.create(null);
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1;
        // Tracks whether the next change should be marked as starting the
        // composition (null means no composition, true means next is the
        // first, false means first has already been marked for this
        // composition)
        this.compositionFirstChange = null;
        // End time of the previous composition
        this.compositionEndedAt = 0;
        // Used in a kludge to detect when an Enter keypress should be
        // considered part of the composition on Safari, which fires events
        // in the wrong order
        this.compositionPendingKey = false;
        // Used to categorize changes as part of a composition, even when
        // the mutation events fire shortly after the compositionend event
        this.compositionPendingChange = false;
        this.mouseSelection = null;
        // When a drag from the editor is active, this points at the range
        // being dragged.
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        // On Safari adding an input event handler somehow prevents an
        // issue where the composition vanishes when you press enter.
        if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
            firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
            return;
        if (event.type == "keydown" && this.keydown(event))
            return;
        this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
        let handlers = this.handlers[type];
        if (handlers) {
            for (let observer of handlers.observers)
                observer(this.view, event);
            for (let handler of handlers.handlers) {
                if (event.defaultPrevented)
                    break;
                if (handler(this.view, event)) {
                    event.preventDefault();
                    break;
                }
            }
        }
    }
    ensureHandlers(plugins) {
        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers)
            if (type != "scroll") {
                let passive = !handlers[type].handlers.length;
                let exists = prev[type];
                if (exists && passive != !exists.handlers.length) {
                    dom.removeEventListener(type, this.handleEvent);
                    exists = null;
                }
                if (!exists)
                    dom.addEventListener(type, this.handleEvent, { passive });
            }
        for (let type in prev)
            if (type != "scroll" && !handlers[type])
                dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers;
    }
    keydown(event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
            return true;
        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
            this.tabFocusMode = -1;
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (browser.android && browser.chrome && !event.synthetic &&
            (event.keyCode == 13 || event.keyCode == 8)) {
            this.view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        // Preventing the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
            this.pendingIOSKey = pending || event;
            setTimeout(() => this.flushIOSKey(), 250);
            return true;
        }
        if (event.keyCode != 229)
            this.view.observer.forceFlush();
        return false;
    }
    flushIOSKey(change) {
        let key = this.pendingIOSKey;
        if (!key)
            return false;
        // This looks like an autocorrection before Enter
        if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
            return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
            this.compositionPendingKey = false;
            return true;
        }
        return false;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        this.view.observer.update(update);
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
            this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
function bindHandler(plugin, handler) {
    return (view, event) => {
        try {
            return handler.call(plugin, event, view);
        }
        catch (e) {
            logException(view.state, e);
        }
    };
}
function computeHandlers(plugins) {
    let result = Object.create(null);
    function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
        let spec = plugin.spec;
        if (spec && spec.domEventHandlers)
            for (let type in spec.domEventHandlers) {
                let f = spec.domEventHandlers[type];
                if (f)
                    record(type).handlers.push(bindHandler(plugin.value, f));
            }
        if (spec && spec.domEventObservers)
            for (let type in spec.domEventObservers) {
                let f = spec.domEventObservers[type];
                if (f)
                    record(type).observers.push(bindHandler(plugin.value, f));
            }
    }
    for (let type in handlers)
        record(type).handlers.push(handlers[type]);
    for (let type in observers)
        record(type).observers.push(observers[type]);
    return result;
}
const PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
// Key codes for modifier keys
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist) {
    return Math.max(0, dist) * 0.7 + 8;
}
function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParents = scrollableParents(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map(f => f(view));
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false)
            this.select(event);
    }
    move(event) {
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
            return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
        if (this.scrollParents.x)
            ({ left, right } = this.scrollParents.x.getBoundingClientRect());
        if (this.scrollParents.y)
            ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= left + dragScrollMargin)
            sx = -dragScrollSpeed(left - event.clientX);
        else if (event.clientX + margins.right >= right - dragScrollMargin)
            sx = dragScrollSpeed(event.clientX - right);
        if (event.clientY - margins.top <= top + dragScrollMargin)
            sy = -dragScrollSpeed(top - event.clientY);
        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
            sy = dragScrollSpeed(event.clientY - bottom);
        this.setScrollSpeed(sx, sy);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.lastEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
            if (this.scrolling < 0)
                this.scrolling = setInterval(() => this.scroll(), 50);
        }
        else if (this.scrolling > -1) {
            clearInterval(this.scrolling);
            this.scrolling = -1;
        }
    }
    scroll() {
        let { x, y } = this.scrollSpeed;
        if (x && this.scrollParents.x) {
            this.scrollParents.x.scrollLeft += x;
            x = 0;
        }
        if (y && this.scrollParents.y) {
            this.scrollParents.y.scrollTop += y;
            y = 0;
        }
        if (x || y)
            this.view.win.scrollBy(x, y);
        if (this.dragging === false)
            this.select(this.lastEvent);
    }
    skipAtoms(sel) {
        let ranges = null;
        for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i], updated = null;
            if (range.empty) {
                let pos = skipAtomicRanges(this.atoms, range.from, 0);
                if (pos != range.from)
                    updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos, -1);
            }
            else {
                let from = skipAtomicRanges(this.atoms, range.from, -1);
                let to = skipAtomicRanges(this.atoms, range.to, 1);
                if (from != range.from || to != range.to)
                    updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
            }
            if (updated) {
                if (!ranges)
                    ranges = sel.ranges.slice();
                ranges[i] = updated;
            }
        }
        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
            this.view.dispatch({
                selection,
                userEvent: "select.pointer"
            });
        this.mustSelect = false;
    }
    update(update) {
        if (update.transactions.some(tr => tr.isUserEvent("input.type")))
            this.destroy();
        else if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = /*@__PURE__*/Object.create(null);
const observers = /*@__PURE__*/Object.create(null);
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function textFilter(state, facet, text) {
    for (let filter of state.facet(facet))
        text = filter(text, state);
    return text;
}
function doPaste(view, input) {
    input = textFilter(view.state, clipboardInputFilter, input);
    let { state } = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state.changeByRange(range => {
            let line = state.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
            return { changes: { from: line.from, insert },
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
observers.scroll = view => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
        view.inputState.tabFocusMode = Date.now() + 2000;
    return false;
};
observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = view => {
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000)
        return false; // Ignore touch interaction
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
            view.observer.ignore(() => {
                focusPreventScroll(view.contentDOM);
                let active = view.root.activeElement;
                if (active && !active.contains(view.contentDOM))
                    active.blur();
            });
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
            mouseSel.start(event);
            return mouseSel.dragging === false;
        }
    }
    return false;
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) { // Single click
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos, bias);
    }
    else if (type == 2) { // Double click
        return groupAt(view.state, pos, bias);
    }
    else { // Triple click
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(from, to);
    }
}
let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    // Positions on top of an element point at that element
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    // This is probably a line wrap point. Pick before if the point is
    // above its bottom.
    return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    return {
        update(update) {
            if (update.docChanged) {
                start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
            }
        },
        get(event, extend, multiple) {
            let cur = queryPos(view, event), removed;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
                return removed;
            else if (multiple)
                return startSel.addRange(range);
            else
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create([range]);
        }
    };
}
function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
        let { from, to } = sel.ranges[i];
        if (from <= pos && to >= pos)
            return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
}
handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
            let from = cView.posAtStart, to = from + cView.length;
            if (from >= range.to || to <= range.from)
                range = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(from, to);
        }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
        event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
};
handlers.dragend = view => {
    view.inputState.draggedContent = null;
    return false;
};
function dropText(view, event, text, direct) {
    text = textFilter(view.state, clipboardInputFilter, text);
    if (!text)
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event)
        ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
    if (!event.dataTransfer)
        return false;
    if (view.state.readOnly)
        return true;
    let files = event.dataTransfer.files;
    if (files && files.length) { // For a file drop, read the file's text.
        let text = Array(files.length), read = 0;
        let finishFile = () => {
            if (++read == files.length)
                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = () => {
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                    text[i] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i]);
        }
        return true;
    }
    else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
            dropText(view, event, text, true);
            return true;
        }
    }
    return false;
};
handlers.paste = (view, event) => {
    if (view.state.readOnly)
        return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
        return true;
    }
    else {
        capturePaste(view);
        return false;
    }
};
function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
        return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
        });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        data.clearData();
        data.setData("text/plain", text);
        return true;
    }
    else {
        captureCopy(view, text);
        return false;
    }
};
const isFocusChange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Annotation.define();
function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus);
        if (effect)
            effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
    setTimeout(() => {
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            let tr = focusChangeTransaction(view.state, focus);
            if (tr)
                view.dispatch(tr);
            else
                view.update([]);
        }
    }, 10);
}
observers.focus = view => {
    view.inputState.lastFocusTime = Date.now();
    // When focusing reset the scroll position, move it back to where it was
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
};
observers.blur = view => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = view => {
    if (view.observer.editContext)
        return; // Composition handled by edit context
    if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0;
    }
};
observers.compositionend = view => {
    if (view.observer.editContext)
        return; // Composition handled by edit context
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
        // Delay flushing for a bit on Android because it'll often fire a
        // bunch of contradictory changes in a row at end of compositon
        view.observer.flushSoon();
    }
    else if (view.inputState.compositionPendingChange) {
        // If we found pending records, schedule a flush.
        Promise.resolve().then(() => view.observer.flush());
    }
    else {
        // Otherwise, make sure that, if no changes come in soon, the
        // composition view is cleared.
        setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.hasComposition)
                view.update([]);
        }, 50);
    }
};
observers.contextmenu = view => {
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
    var _a, _b;
    // In EditContext mode, we must handle insertReplacementText events
    // directly, to make spell checking corrections work
    if (event.inputType == "insertReplacementText" && view.observer.editContext) {
        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/plain"), ranges = event.getTargetRanges();
        if (text && ranges.length) {
            let r = ranges[0];
            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
            applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
            return true;
        }
    }
    // Because Chrome Android doesn't fire useful key events, use
    // beforeinput to detect backspace (and possibly enter and delete,
    // but those usually don't even seem to fire beforeinput events at
    // the moment) and fake a key event for it.
    //
    // (preventDefault on beforeinput, though supported in the spec,
    // seems to do nothing at all on Chrome).
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
            setTimeout(() => {
                var _a;
                // Backspacing near uneditable nodes on Chrome Android sometimes
                // closes the virtual keyboard. This tries to crudely detect
                // that and refocus to get it back.
                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
        // For some reason, DOM changes (and beforeinput) happen _before_
        // the key event for ctrl-d on iOS when using an external
        // keyboard.
        view.observer.flushSoon();
    }
    // Safari will occasionally forget to fire compositionend at the end of a dead-key composition
    if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
        setTimeout(() => observers.compositionend(view, event), 20);
    }
    return false;
};
const appliedFirefoxHack = /*@__PURE__*/new Set;
// In Firefox, when cut/copy handlers are added to the document, that
// somehow avoids a bug where those events aren't fired when the
// selection is empty. See https://github.com/codemirror/dev/issues/1082
// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
function firefoxCopyCutHack(doc) {
    if (!appliedFirefoxHack.has(doc)) {
        appliedFirefoxHack.add(doc);
        doc.addEventListener("copy", () => { });
        doc.addEventListener("cut", () => { });
    }
}

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
// Used to track, during updateHeight, if any actual heights changed
let heightChangeFlag = false;
function clearHeightChangeFlag() { heightChangeFlag = false; }
class HeightOracle {
    constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty;
        this.heightSamples = {};
        this.lineHeight = 14; // The height of an entire line (line-height)
        this.charWidth = 7;
        this.textHeight = 14; // The height of the actual font (font-size)
        this.lineLength = 30;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefreshForWrapping(whiteSpace) {
        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
/**
Record used to represent information about a block-level element
in the editor view.
*/
class BlockInfo {
    /**
    @internal
    */
    constructor(
    /**
    The start of the element in the document.
    */
    from, 
    /**
    The length of the element.
    */
    length, 
    /**
    The top position of the element (relative to the top of the
    document).
    */
    top, 
    /**
    Its height.
    */
    height, 
    /**
    @internal Weird packed field that holds an array of children
    for composite blocks, a decoration for block widgets, and a
    number indicating the amount of widget-create line breaks for
    text blocks.
    */
    _content) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
        return typeof this._content == "number" ? BlockType.Text :
            Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() { return this.from + this.length; }
    /**
    The bottom position of the element.
    */
    get bottom() { return this.top + this.height; }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other) {
        let content = (Array.isArray(this._content) ? this._content : [this])
            .concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
    }
}
var QueryType = /*@__PURE__*/(function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
return QueryType})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
    constructor(length, // The number of characters covered
    height, // Height of this part of the document
    flags = 2 /* Flag.Outdated */) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }
    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }
    setHeight(height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                heightChangeFlag = true;
            this.height = height;
        }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this, doc = oracle.doc;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
            me = replace(me, me.replace(fromA, toA, nodes));
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
function replace(old, val) {
    if (old == val)
        return old;
    if (old.constructor != val.constructor)
        heightChangeFlag = true;
    return val;
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, oracle, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0; // Amount of collapsed content in the line
        this.widgetHeight = 0; // Maximum inline widget height
        this.breaks = 0; // Number of widget-introduced line breaks on the line
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
                this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
            perLine = totalPerLine / lines;
            if (this.length > lines + 1)
                perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        }
        else {
            perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
            let guess = offset + (height < oracle.lineHeight ? 0
                : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));
            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
            let lineTop = Math.max(top, height - lineHeight / 2);
            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        }
        else {
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
            let { from, length } = oracle.doc.line(firstLine + line);
            return new BlockInfo(from, length, top + perLine * line, perLine, 0);
        }
    }
    lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, oracle, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = oracle.doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset);
        to = Math.min(to, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from, lineTop = top; pos <= to;) {
            let line = oracle.doc.lineAt(pos);
            if (pos == from) {
                let linesAbove = line.number - firstLine;
                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
            }
            let lineHeight = perLine + perChar * line.length;
            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
            lineTop += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            // Fill in part of this gap with measured lines. We know there
            // can't be widgets or collapsed ranges in those lines, because
            // they would already have been added to the heightmap (gaps
            // only contain plain text).
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1)
                    singleHeight = height;
                else if (Math.abs(height - singleHeight) >= Epsilon)
                    singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
                heightChangeFlag = true;
            return replace(this, result);
        }
        else if (force || this.outdated) {
            this.setHeight(oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1 /* Flag.Break */; }
    blockAt(height, oracle, top, offset) {
        let mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top, offset)
            : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, oracle, top, offset)
            : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, oracle, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = replace(this.left, left);
        this.right = replace(this.right, right);
        this.setHeight(left.height + right.height);
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            let breaks = deco.widget ? deco.widget.lineBreaks : 0;
            if (height < 0)
                height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco));
            }
            else if (len || breaks || height >= relevantWidgetHeight) {
                this.addLineDeco(height, breaks, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4 /* Flag.SingleLine */;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
            this.covering = block;
    }
    addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}

function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc.body;) {
        if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                style.overflow != "visible") {
                let parentRect = elt.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        }
        else if (parent.nodeType == 11) { // Shadow root
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
}
function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return { left: 0, right: rect.right - rect.left,
        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
}
// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
class LineGap {
    constructor(from, to, size, displaySize) {
        this.from = from;
        this.to = to;
        this.size = size;
        this.displaySize = displaySize;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(viewState, wrapping) {
        return Decoration.replace({
            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state) {
        this.state = state;
        // These are contentDOM-local coordinates
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0; // Padding above the document, scaled
        this.paddingBottom = 0; // Padding below the document, scaled
        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width
        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height
        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled
        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled
        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled
        this.scrolledToBottom = false;
        // The CSS-transformation scale of the editor (transformed size /
        // concrete size)
        this.scaleX = 1;
        this.scaleY = 1;
        // The vertical position (document-relative) to which to anchor the
        // scroll position. -1 means anchor to the end of the document.
        this.scrollAnchorPos = 0;
        // The height at the anchor position. Set by the DOM update phase.
        // -1 means no height available.
        this.scrollAnchorHeight = -1;
        // See VP.MaxDOMHeight
        this.scaler = IdScaler;
        this.scrollTarget = null;
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false;
        // Flag set when editor content was redrawn, so that the next
        // measure stage knows it must read DOM layout
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.LTR;
        this.visibleRanges = [];
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be significant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        for (let i = 0; i < 2; i++) {
            this.viewport = this.getViewport(0, null);
            if (!this.updateForViewport())
                break;
        }
        this.updateViewportLines();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        return this.updateScaler();
    }
    updateScaler() {
        let scaler = this.scaler;
        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :
            new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */;
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
            this.viewportLines.push(scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag();
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight || heightChangeFlag)
            update.flags |= 2 /* UpdateFlag.Height */;
        if (scrollAnchor) {
            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
            this.scrollAnchorHeight = scrollAnchor.top;
        }
        else {
            this.scrollAnchorPos = -1;
            this.scrollAnchorHeight = this.heightMap.height;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
            !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        update.flags |= this.updateForViewport();
        if (viewportChange || !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */))
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges();
        if (scrollTarget)
            this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc &&
            !update.state.facet(nativeSelectionHidden))
            this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
            let { scaleX, scaleY } = getScale(dom, domRect);
            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 ||
                scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                result |= 8 /* UpdateFlag.Geometry */;
                refresh = measureContent = true;
            }
        }
        // Vertical padding
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
                measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
            this.scrollAnchorHeight = -1;
            this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        // Pixel viewport
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView)
                measureContent = true;
        }
        if (!this.inView && !this.scrollTarget)
            return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = domRect.width;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
                refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= 8 /* UpdateFlag.Geometry */;
                }
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
            clearHeightChangeFlag();
            for (let vp of this.viewports) {
                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (heightChangeFlag)
                result |= 2 /* UpdateFlag.Height */;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||
                this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) {
            if (result & 2 /* UpdateFlag.Height */)
                result |= this.updateScaler();
            this.viewport = this.getViewport(bias, this.scrollTarget);
            result |= this.updateForViewport();
        }
        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            // This is done in the read stage, because moving the selection
            // to a line end is going to trigger a layout anyway, so it
            // can't be a pure write. It should be rare that it does any
            // writing.
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
    getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
        let map = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
                if (scrollTarget.y == "center")
                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                    topPos = block.top;
                else
                    topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView)
            return true;
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&
            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
        return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
            return [];
        let gaps = [];
        let addGap = (from, to, line, structure) => {
            if (to - from < halfMargin)
                return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
                avoid.push(sel.to);
            for (let pos of avoid) {
                if (pos > from && pos < to) {
                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
                    return;
                }
            }
            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                !avoid.some(pos => gap.from < pos && gap.to > pos));
            if (!gap) {
                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
                if (to < line.to && mayMeasure && wrapping &&
                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(to), false, true).head;
                    if (lineStart > from)
                        to = lineStart;
                }
                let size = this.gapSize(line, from, to, structure);
                let displaySize = wrapping || size < 2000000 /* VP.MaxHorizGap */ ? size : 2000000 /* VP.MaxHorizGap */;
                gap = new LineGap(from, to, size, displaySize);
            }
            gaps.push(gap);
        };
        let checkLine = (line) => {
            if (line.length < doubleMargin || line.type != BlockType.Text)
                return;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
                return;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                let top, bot;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                    top = targetFrac - spaceFrac;
                    bot = targetFrac + spaceFrac;
                }
                else {
                    top = (this.visibleTop - line.top - marginHeight) / line.height;
                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                }
                viewFrom = findPosition(structure, top);
                viewTo = findPosition(structure, bot);
            }
            else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                let marginWidth = margin * this.heightOracle.charWidth;
                let horizOffset = 0;
                if (totalWidth > 2000000 /* VP.MaxHorizGap */)
                    for (let old of current) {
                        if (old.from >= line.from && old.from < line.to && old.size != old.displaySize &&
                            old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                            horizOffset = old.size - old.displaySize;
                    }
                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
                let left, right;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
                    left = targetFrac - spaceFrac;
                    right = targetFrac + spaceFrac;
                }
                else {
                    left = (pxLeft - marginWidth) / totalWidth;
                    right = (pxRight + marginWidth) / totalWidth;
                }
                viewFrom = findPosition(structure, left);
                viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
                addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
                addGap(viewTo, line.to, line, structure);
        };
        for (let line of this.viewportLines) {
            if (Array.isArray(line.type))
                line.type.forEach(checkLine);
            else
                checkLine(line);
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        }
        else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
        }
    }
    computeVisibleRanges() {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        let changed = ranges.length != this.visibleRanges.length ||
            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
        this.visibleRanges = ranges;
        return changed ? 4 /* UpdateFlag.Viewport */ : 0;
    }
    lineBlockAt(pos) {
        return (pos >= this.viewport.from && pos <= this.viewport.to &&
            this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return (height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom &&
            this.viewportLines.find(l => l.top <= height && l.bottom >= height)) ||
            scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.spans(stateDeco, from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
// Don't scale when the document height is within the range of what
// the DOM can handle.
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1,
    eq(other) { return other == this; }
};
// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler {
    constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    eq(other) {
        if (!(other instanceof BigScaler))
            return false;
        return this.scale == other.scale && this.viewports.length == other.viewports.length &&
            this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
}

const theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({ combine: strs => strs.join(" ") });
const darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.newName(), baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.newName(), baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme$1 = /*@__PURE__*/buildTheme("." + baseThemeID, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
        overflowAnchor: "none",
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal", // https://github.com/codemirror/dev/issues/456
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only",
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap", // For IE
        whiteSpace: "break-spaces",
        wordBreak: "break-word", // For Safari, which doesn't support overflow-wrap: anywhere
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
    },
    ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
            position: "absolute"
        }
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
        position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
    },
    ".cm-iso": {
        unicodeBidi: "isolate"
    },
    ".cm-announced": {
        position: "fixed",
        top: "-10000px"
    },
    "@media print": {
        ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        insetInlineStart: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important", // Necessary -- prevents margin collapsing
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
        zIndex: 300
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
    },
    ".cm-highlightSpace": {
        backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
        backgroundPosition: "center",
    },
    ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);

const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
// IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view) {
        this.view = view;
        this.active = false;
        this.editContext = null;
        // The known selection. Kept in our own object, as opposed to just
        // directly accessing the selection because:
        //  - Safari doesn't report the right selection in shadow DOM
        //  - Reading from the selection forces a DOM layout
        //  - This way, we can ignore selectionchange events if we have
        //    already seen the 'new' selection
        this.selectionRange = new DOMSelectionState;
        // Set when a selection change is detected, cleared on flush
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        this.printQuery = null;
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            // IE11 will sometimes (on typing over a selection or
            // backspacing out a single character text node) call the
            // observer callback before actually updating the DOM.
            //
            // Unrelatedly, iOS Safari will, when ending a composition,
            // sometimes first clear it, deliver the mutations, and then
            // reinsert the finished text. CodeMirror's handling of the
            // deletion will prevent the reinsertion from happening,
            // breaking composition.
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (window.EditContext && view.constructor.EDIT_CONTEXT !== false &&
            // Chrome <126 doesn't support inverted selections in edit context (#1392)
            !(browser.chrome && browser.chrome_version < 126)) {
            this.editContext = new EditContextManager(view);
            if (view.state.facet(editable))
                view.contentDOM.editContext = this.editContext.editContext;
        }
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (window.matchMedia)
            this.printQuery = window.matchMedia("print");
        if (typeof ResizeObserver == "function") {
            this.resizeScroll = new ResizeObserver(() => {
                var _a;
                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                    this.onResize();
            });
            this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, { threshold: [0, .001] });
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver(entries => {
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                    this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
            this.view.measure();
    }
    onScroll(e) {
        if (this.intersecting)
            this.flush(false);
        if (this.editContext)
            this.view.requestMeasure(this.editContext.measureReq);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = -1;
                this.view.requestMeasure();
            }, 50);
    }
    onPrint(event) {
        if ((event.type == "change" || !event.type) && !event.matches)
            return;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
        }, 500);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
                this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
            if (!wasChanged)
                this.selectionChanged = false;
            return;
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
            // (Selection.isCollapsed isn't reliable on IE)
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush(false);
    }
    readSelectionRange() {
        let { view } = this;
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        let selection = getSelection(view.root);
        if (!selection)
            return false;
        let range = browser.safari && view.root.nodeType == 11 &&
            view.root.activeElement == this.dom &&
            safariSelectionRangeHack(this.view, selection) || selection;
        if (!range || this.selectionRange.eq(range))
            return false;
        let local = hasSelection(this.dom, range);
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (local && !this.selectionChanged &&
            view.inputState.lastFocusTime > Date.now() - 200 &&
            view.inputState.lastTouchTime < Date.now() - 300 &&
            atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
        }
        this.selectionRange.setRange(range);
        if (local)
            this.selectionChanged = true;
        return true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            }
            else if (dom.nodeType == 11) { // Shadow root
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
        var _a;
        if (!this.delayedAndroidKey) {
            let flush = () => {
                let key = this.delayedAndroidKey;
                if (key) {
                    this.clearDelayedAndroidKey();
                    this.view.inputState.lastKeyCode = key.keyCode;
                    this.view.inputState.lastKeyTime = Date.now();
                    let flushed = this.flush();
                    if (!flushed && key.force)
                        dispatchKey(this.dom, key.key, key.keyCode);
                }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
                key, keyCode,
                // Only run the key handler when no changes are detected if
                // this isn't coming right after another change, in which case
                // it is probably part of a weird chain of updates, and should
                // be ignored if it returns the DOM to its previous state.
                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
            };
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
        }
        this.flush();
    }
    pendingRecords() {
        for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
    }
    processRecords() {
        let records = this.pendingRecords();
        if (records.length)
            this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return { from, to, typeOver };
    }
    readChange() {
        let { from, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel)
            return null;
        if (from > -1)
            this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from, to, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
        // Completely hold off flushing when pending keys are set—the code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
        if (readSelection)
            this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
            this.view.requestMeasure();
            return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        // The view wasn't updated but DOM/selection changes were seen. Reset the view.
        if (this.view.state == startState &&
            (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
            this.view.update([]);
        return handled;
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
            cView.flags |= 4 /* ViewFlag.AttrsDirty */;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
        else {
            return null;
        }
    }
    setWindow(win) {
        if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
        }
    }
    addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.addEventListener)
                this.printQuery.addEventListener("change", this.onPrint);
            else
                this.printQuery.addListener(this.onPrint);
        }
        else
            win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        if (this.printQuery) {
            if (this.printQuery.removeEventListener)
                this.printQuery.removeEventListener("change", this.onPrint);
            else
                this.printQuery.removeListener(this.onPrint);
        }
        else
            win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
        if (this.editContext) {
            this.editContext.update(update);
            if (update.startState.facet(editable) != update.state.facet(editable))
                update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
        }
    }
    destroy() {
        var _a, _b, _c;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        if (this.editContext) {
            this.view.contentDOM.editContext = null;
            this.editContext.destroy();
        }
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    // Since such a range doesn't distinguish between anchor and head,
    // use a heuristic that flips it around if its end matches the
    // current anchor.
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
}
// Used to work around a Safari Selection/shadow DOM bug (#414)
function safariSelectionRangeHack(view, selection) {
    if (selection.getComposedRanges) {
        let range = selection.getComposedRanges(view.root)[0];
        if (range)
            return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    // Because Safari (at least in 2018-2021) doesn't provide regular
    // access to the selection inside a shadowroot, we have to perform a
    // ridiculous hack to get at it—using `execCommand` to trigger a
    // `beforeInput` event so that we can read the target range from the
    // event.
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
    constructor(view) {
        // The document window for which the text in the context is
        // maintained. For large documents, this may be smaller than the
        // editor document. This window always includes the selection head.
        this.from = 0;
        this.to = 0;
        // When applying a transaction, this is used to compare the change
        // made to the context content to the change in the transaction in
        // order to make the minimal changes to the context (since touching
        // that sometimes breaks series of multiple edits made for a single
        // user action on some Android keyboards)
        this.pendingContextChange = null;
        this.handlers = Object.create(null);
        // Kludge to work around the fact that EditContext does not respond
        // well to having its content updated during a composition (see #1472)
        this.composing = null;
        this.resetRange(view.state);
        let context = this.editContext = new window.EditContext({
            text: view.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(view.state.selection.main.head)
        });
        this.handlers.textupdate = e => {
            let { anchor } = view.state.selection.main;
            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
            if (view.inputState.composing >= 0 && !this.composing)
                this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
            let change = { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Text.of(e.text.split("\n")) };
            // If the window doesn't include the anchor, assume changes
            // adjacent to a side go up to the anchor.
            if (change.from == this.from && anchor < this.from)
                change.from = anchor;
            else if (change.to == this.to && anchor > this.to)
                change.to = anchor;
            // Edit contexts sometimes fire empty changes
            if (change.from == change.to && !change.insert.length)
                return;
            this.pendingContextChange = change;
            if (!view.state.readOnly) {
                let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
                applyDOMChangeInner(view, change, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
            }
            // If the transaction didn't flush our change, revert it so
            // that the context is in sync with the editor state again.
            if (this.pendingContextChange) {
                this.revertPending(view.state);
                this.setSelection(view.state);
            }
        };
        this.handlers.characterboundsupdate = e => {
            let rects = [], prev = null;
            for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
                let rect = view.coordsForChar(i);
                prev = (rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top))
                    || prev || new DOMRect;
                rects.push(prev);
            }
            context.updateCharacterBounds(e.rangeStart, rects);
        };
        this.handlers.textformatupdate = e => {
            let deco = [];
            for (let format of e.getTextFormats()) {
                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
                if (lineStyle != "None" && thickness != "None") {
                    let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
                    if (from < to) {
                        let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
                        deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
                    }
                }
            }
            view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
        };
        this.handlers.compositionstart = () => {
            if (view.inputState.composing < 0) {
                view.inputState.composing = 0;
                view.inputState.compositionFirstChange = true;
            }
        };
        this.handlers.compositionend = () => {
            view.inputState.composing = -1;
            view.inputState.compositionFirstChange = null;
            if (this.composing) {
                let { drifted } = this.composing;
                this.composing = null;
                if (drifted)
                    this.reset(view.state);
            }
        };
        for (let event in this.handlers)
            context.addEventListener(event, this.handlers[event]);
        this.measureReq = { read: view => {
                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());
                let sel = getSelection(view.root);
                if (sel && sel.rangeCount)
                    this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
            } };
    }
    applyEdits(update) {
        let off = 0, abort = false, pending = this.pendingContextChange;
        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) => {
            if (abort)
                return;
            let dLen = insert.length - (toA - fromA);
            if (pending && toA >= pending.to) {
                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {
                    pending = this.pendingContextChange = null; // Match
                    off += dLen;
                    this.to += dLen;
                    return;
                }
                else { // Mismatch, revert
                    pending = null;
                    this.revertPending(update.state);
                }
            }
            fromA += off;
            toA += off;
            if (toA <= this.from) { // Before the window
                this.from += dLen;
                this.to += dLen;
            }
            else if (fromA < this.to) { // Overlaps with window
                if (fromA < this.from || toA > this.to || (this.to - this.from) + insert.length > 30000 /* CxVp.MaxSize */) {
                    abort = true;
                    return;
                }
                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());
                this.to += dLen;
            }
            off += dLen;
        });
        if (pending && !abort)
            this.revertPending(update.state);
        return !abort;
    }
    update(update) {
        let reverted = this.pendingContextChange;
        if (this.composing && (this.composing.drifted || update.transactions.some(tr => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
            this.composing.drifted = true;
            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
        }
        else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
            this.pendingContextChange = null;
            this.reset(update.state);
        }
        else if (update.docChanged || update.selectionSet || reverted) {
            this.setSelection(update.state);
        }
        if (update.geometryChanged || update.docChanged || update.selectionSet)
            update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
        let { head } = state.selection.main;
        this.from = Math.max(0, head - 10000 /* CxVp.Margin */);
        this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */);
    }
    reset(state) {
        this.resetRange(state);
        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
        this.setSelection(state);
    }
    revertPending(state) {
        let pending = this.pendingContextChange;
        this.pendingContextChange = null;
        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
        let { main } = state.selection;
        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
        let end = this.toContextPos(main.head);
        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
            this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
        let { head } = state.selection.main;
        return !(this.from > 0 && head - this.from < 500 /* CxVp.MinMargin */ ||
            this.to < state.doc.length && this.to - head < 500 /* CxVp.MinMargin */ ||
            this.to - this.from > 10000 /* CxVp.Margin */ * 3);
    }
    toEditorPos(contextPos, clipLen = this.to - this.from) {
        contextPos = Math.min(contextPos, clipLen);
        let c = this.composing;
        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
    }
    toContextPos(editorPos) {
        let c = this.composing;
        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
    }
    destroy() {
        for (let event in this.handlers)
            this.editContext.removeEventListener(event, this.handlers[event]);
    }
}

// The editor's update state machine looks something like this:
//
//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
//                                         ↑      ↓
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
class EditorView {
    /**
    The current editor state.
    */
    get state() { return this.viewState.state; }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() { return this.viewState.viewport; }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() { return this.viewState.visibleRanges; }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() { return this.viewState.inView; }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() { return this.inputState.composing > 0; }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() { return this.inputState.composing >= 0; }
    /**
    The document or shadow root that the view lives in.
    */
    get root() { return this._root; }
    /**
    @internal
    */
    get win() { return this.dom.ownerDocument.defaultView || window; }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config = {}) {
        var _a;
        this.plugins = [];
        this.pluginMap = new Map;
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        /**
        @internal
        */
        this.updateState = 2 /* UpdateState.Updating */;
        /**
        @internal
        */
        this.measureScheduled = -1;
        /**
        @internal
        */
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config.parent)
            config.parent.appendChild(this.dom);
        let { dispatch } = config;
        this.dispatchTransactions = config.dispatchTransactions ||
            (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||
            ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = (config.root || getRoot(config.parent) || document);
        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create(config));
        if (config.scrollTo && config.scrollTo.is(scrollIntoView))
            this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
        for (let plugin of this.plugins)
            plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0 /* UpdateState.Idle */;
        this.requestMeasure();
        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready)
            document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction ? input
            : input.length == 1 && Array.isArray(input[0]) ? input[0]
                : [this.state.update(...input)];
        this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
            if (tr.startState != state)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state = tr.state;
        }
        if (this.destroyed) {
            this.viewState.state = state;
            return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some(tr => tr.annotation(isFocusChange))) {
            this.inputState.notifiedFocused = focus;
            // If a focus-change transaction is being dispatched, set this update flag.
            focusFlag = 1 /* UpdateFlag.Focus */;
        }
        else if (focus != this.inputState.notifiedFocused) {
            this.inputState.notifiedFocused = focus;
            // Schedule a separate focus transaction if necessary, otherwise
            // add a flag to this update
            dispatchFocus = focusChangeTransaction(state, focus);
            if (!dispatchFocus)
                focusFlag = 1 /* UpdateFlag.Focus */;
        }
        // If there was a pending DOM change, eagerly read it and try to
        // apply it after the given transactions.
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
            this.observer.clearDelayedAndroidKey();
            domChange = this.observer.readChange();
            // Only try to apply DOM changes if the transactions didn't
            // change the doc or selection.
            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
                domChange = null;
        }
        else {
            this.observer.clear();
        }
        // When the phrases change, redraw the editor
        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.phrases))
            return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = 2 /* UpdateState.Updating */;
            for (let tr of transactions) {
                if (scrollTarget)
                    scrollTarget = scrollTarget.map(tr.changes);
                if (tr.scrollIntoView) {
                    let { main } = tr.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr.effects)
                    if (e.is(scrollIntoView))
                        scrollTarget = e.value.clip(this.state);
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
        if (redrawn)
            this.docViewUpdate();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener)) {
                try {
                    listener(update);
                }
                catch (e) {
                    logException(this.state, e, "update listener");
                }
            }
        if (dispatchFocus || domChange)
            Promise.resolve().then(() => {
                if (dispatchFocus && this.state == dispatchFocus.startState)
                    this.dispatch(dispatchFocus);
                if (domChange) {
                    if (!applyDOMChange(this, domChange) && pendingKey.force)
                        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
                }
            });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = 2 /* UpdateState.Updating */;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin of this.plugins)
                plugin.update(this);
            this.docView.destroy();
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (hadFocus)
            this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        if (prevSpecs != specs)
            this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
        for (let plugin of this.plugins) {
            let val = plugin.value;
            if (val && val.docViewUpdate) {
                try {
                    val.docViewUpdate(this);
                }
                catch (e) {
                    logException(this.state, e, "doc view update listener");
                }
            }
        }
    }
    /**
    @internal
    */
    measure(flush = true) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
            this.measureScheduled = -1;
            this.requestMeasure();
            return;
        }
        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
        if (flush)
            this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
            scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
            for (let i = 0;; i++) {
                if (scrollAnchorHeight < 0) {
                    if (isScrolledToBottom(sDOM)) {
                        scrollAnchorPos = -1;
                        scrollAnchorHeight = this.viewState.heightMap.height;
                    }
                    else {
                        let block = this.viewState.scrollAnchorAt(scrollTop);
                        scrollAnchorPos = block.from;
                        scrollAnchorHeight = block.top;
                    }
                }
                this.updateState = 1 /* UpdateState.Measuring */;
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (i > 5) {
                    console.warn(this.measureRequests.length
                        ? "Measure loop restarted more than 5 times"
                        : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                // Only run measure requests in this cycle when the viewport didn't change
                if (!(changed & 4 /* UpdateFlag.Viewport */))
                    [this.measureRequests, measuring] = [measuring, this.measureRequests];
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = ViewUpdate.create(this, this.state, []), redrawn = false;
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2 /* UpdateState.Updating */;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                    if (redrawn)
                        this.docViewUpdate();
                }
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            let m = measuring[i];
                            if (m.write)
                                m.write(measured[i], this);
                        }
                        catch (e) {
                            logException(this.state, e);
                        }
                    }
                if (redrawn)
                    this.docView.updateSelection(true);
                if (!update.viewportChanged && this.measureRequests.length == 0) {
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget);
                            this.viewState.scrollTarget = null;
                            scrollAnchorHeight = -1;
                            continue;
                        }
                        else {
                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :
                                this.viewState.lineBlockAt(scrollAnchorPos).top;
                            let diff = newAnchorHeight - scrollAnchorHeight;
                            if (diff > 1 || diff < -1) {
                                scrollTop = scrollTop + diff;
                                sDOM.scrollTop = scrollTop / this.scaleY;
                                scrollAnchorHeight = -1;
                                continue;
                            }
                        }
                    }
                    break;
                }
            }
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            writingsuggestions: "false",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(EditorView.cspNonce);
        style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);
    }
    readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)
            this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
            if (this.measureRequests.indexOf(request) > -1)
                return;
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.spec != plugin)
            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
        return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() { return this.viewState.scaleX; }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() { return this.viewState.scaleY; }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
    }
    /**
    Get the cursor position visually at the start or end of a line.
    Note that this may differ from the _logical_ position at its
    start or end (which is simply at `line.from`/`line.to`) if text
    at the start or end goes against the line's base text direction.
    */
    visualLineSide(line, end) {
        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
        let span = order[end ? order.length - 1 : 0];
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() { return this.viewState.defaultTextDirection; }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
            if (entry.from == line.from && entry.dir == dir &&
                (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
                return entry.order;
        }
        if (!isolates)
            isolates = getIsolatedRanges(this, line);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
        var _a;
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
            this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
        if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
        }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
        if (this.root.activeElement == this.contentDOM)
            this.contentDOM.blur();
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    /**
    Enable or disable tab-focus mode, which disables key bindings
    for Tab and Shift-Tab, letting the browser's default
    focus-changing behavior go through instead. This is useful to
    prevent trapping keyboard users in your editor.
    
    Without argument, this toggles the mode. With a boolean, it
    enables (true) or disables it (false). Given a number, it
    temporarily enables the mode until that number of milliseconds
    have passed or another non-Tab key is pressed.
    */
    setTabFocusMode(to) {
        if (to == null)
            this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
        else if (typeof to == "boolean")
            this.inputState.tabFocusMode = to ? 0 : -1;
        else if (this.inputState.tabFocusMode != 0)
            this.inputState.tabFocusMode = Date.now() + to;
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers) {
        return ViewPlugin.define(() => ({}), { eventObservers: observers });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
    added—need to be explicitly differentiated by adding an `&` to
    the selector for that element—for example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
        var _a;
        let content = dom.querySelector(".cm-content");
        let cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
    }
}
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.

The `insert` argument can be used to get the default transaction
that would be applied for this input. This can be useful when
dispatching the custom behavior as a separate transaction.
*/
EditorView.inputHandler = inputHandler;
/**
Functions provided in this facet will be used to transform text
pasted or dropped into the editor.
*/
EditorView.clipboardInputFilter = clipboardInputFilter;
/**
Transform text copied or dragged from the editor.
*/
EditorView.clipboardOutputFilter = clipboardOutputFilter;
/**
Scroll handlers can override how things are scrolled into view.
If they return `true`, no further handling happens for the
scrolling. If they return false, the default scroll behavior is
applied. Scroll handlers should never initiate editor updates.
*/
EditorView.scrollHandler = scrollHandler;
/**
This facet can be used to provide functions that create effects
to be dispatched when the editor's focus state changes.
*/
EditorView.focusChangeEffect = focusChangeEffect;
/**
By default, the editor assumes all its content has the same
[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
value to make it read the text direction of every (rendered)
line separately.
*/
EditorView.perLineTextDirection = perLineTextDirection;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/
EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not have its `contenteditable` attribute set. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/
EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds a
new range to the existing selection or replaces it entirely. The
default behavior is to check `event.metaKey` on macOS, and
`event.ctrlKey` elsewhere.
*/
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. Decorations can be provided in two
ways—directly, or via a function that takes an editor view.

Only decoration sets provided directly are allowed to influence
the editor's vertical layout structure. The ones provided as
functions are called _after_ the new viewport has been computed,
and thus **must not** introduce block widgets or replacing
decorations that cover line breaks.

If you want decorated ranges to behave like atomic units for
cursor motion and deletion purposes, also provide the range set
containing the decorations to
[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
*/
EditorView.decorations = decorations;
/**
Facet that works much like
[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its
inputs at the very bottom of the precedence stack, meaning mark
decorations provided here will only be split by other, partially
overlapping \`outerDecorations\` ranges, and wrap around all
regular decorations. Use this for mark elements that should, as
much as possible, remain in one piece.
*/
EditorView.outerDecorations = outerDecorations;
/**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/
EditorView.atomicRanges = atomicRanges;
/**
When range decorations add a `unicode-bidi: isolate` style, they
should also include a
[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
in their decoration spec, and be exposed through this facet, so
that the editor can compute the proper text order. (Other values
for `unicode-bidi`, except of course `normal`, are not
supported.)
*/
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
/**
Facet that allows extensions to provide additional scroll
margins (space around the sides of the scrolling element that
should be considered invisible). This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
EditorView.scrollMargins = scrollMargins;
/**
This facet records whether a dark theme is active. The extension
returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
includes an instance of this when the `dark` option is set to
true.
*/
EditorView.darkTheme = darkTheme;
/**
Provides a Content Security Policy nonce to use when creating
the style sheets for the editor. Holds the empty string when no
nonce has been provided.
*/
EditorView.cspNonce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({ combine: values => values.length ? values[0] : "" });
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/
EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
EditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();
// Maximum line length for which we compute accurate bidi info
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty && !cache.some(c => c.fresh))
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
        let source = sources[i], value = typeof source == "function" ? source(view) : source;
        if (value)
            combineAttrs(value, base);
    }
    return base;
}

const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Prec.default(/*@__PURE__*/EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
}));
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
const keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({ enables: handleKeyEvents });
const Keymaps = /*@__PURE__*/new WeakMap();
// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be a `"keydown"` event. Returns true if any of the
handlers handled it.
*/
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault, stopPropagation) => {
        var _a, _b;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    stopPropagation: false,
                    run: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => { if (storedPrefix == ourObj)
                                storedPrefix = null; }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
        });
        if (command)
            binding.run.push(command);
        if (preventDefault)
            binding.preventDefault = true;
        if (stopPropagation)
            binding.stopPropagation = true;
    };
    for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
            for (let scope of scopes) {
                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                if (!scopeObj._any)
                    scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
                let { any } = b;
                for (let key in scopeObj)
                    scopeObj[key].run.push(view => any(view, currentKeyEvent));
            }
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
        }
    }
    return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
    currentKeyEvent = event;
    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.keyName)(event);
    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.codePointSize)(charCode) == name.length && name != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (modifierCodes.indexOf(event.keyCode) < 0) {
            prevented = true;
            storedPrefix = null;
        }
    }
    let ran = new Set;
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.run)
                if (!ran.has(cmd)) {
                    ran.add(cmd);
                    if (cmd(view)) {
                        if (binding.stopPropagation)
                            stopPropagation = true;
                        return true;
                    }
                }
            if (binding.preventDefault) {
                if (binding.stopPropagation)
                    stopPropagation = true;
                prevented = true;
            }
        }
        return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
            handled = true;
        }
        else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
            // Ctrl-Alt may be used for AltGr on Windows
            !(browser.windows && event.ctrlKey && event.altKey) &&
            (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
                handled = true;
            }
            else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.shift[event.keyCode]) != name && shiftName != baseName &&
                runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
                handled = true;
            }
        }
        else if (isChar && event.shiftKey &&
            runFor(scopeObj[prefix + modifiers(name, event, true)])) {
            handled = true;
        }
        if (!handled && runFor(scopeObj._any))
            handled = true;
    }
    if (prevented)
        handled = true;
    if (handled && stopPropagation)
        event.stopPropagation();
    currentKeyEvent = null;
    return handled;
}

/**
Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates
a rectangle at a given set of coordinates.
*/
class RectangleMarker {
    /**
    Create a marker with the given class and dimensions. If `width`
    is null, the DOM element will get no width style.
    */
    constructor(className, 
    /**
    The left position of the marker (in pixels, document-relative).
    */
    left, 
    /**
    The top position of the marker.
    */
    top, 
    /**
    The width of the marker, or null if it shouldn't get a width assigned.
    */
    width, 
    /**
    The height of the marker.
    */
    height) {
        this.className = className;
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    update(elt, prev) {
        if (prev.className != this.className)
            return false;
        this.adjust(elt);
        return true;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width != null)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
    /**
    Create a set of rectangles for the given selection range,
    assigning them theclass`className`. Will create a single
    rectangle for empty ranges, and a set of selection-style
    rectangles covering the range's content (in a bidi-aware
    way) for non-empty ones.
    */
    static forRange(view, className, range) {
        if (range.empty) {
            let pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (!pos)
                return [];
            let base = getBase(view);
            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
        }
        else {
            return rectanglesForRange(view, className, range);
        }
    }
}
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
    let coords = view.coordsAtPos(pos, side * 2);
    if (!coords)
        return inside;
    let editorRect = view.dom.getBoundingClientRect();
    let y = (coords.top + coords.bottom) / 2;
    let left = view.posAtCoords({ x: editorRect.left + 1, y });
    let right = view.posAtCoords({ x: editorRect.right - 1, y });
    if (left == null || right == null)
        return inside;
    return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left +
        (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from, 1, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to, -1, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
            startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    // Gets passed from/to in line-local positions
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            // Passing 2/-2 is a kludge to force the view to return
            // coordinates on the proper side of block widgets, since
            // normalizing the side there, though appropriate for most
            // coordsAtPos queries, would break selection drawing.
            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
            if (!fromCoords || !toCoords)
                return;
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
    function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
    }
}
function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
    constructor(view, layer) {
        this.view = view;
        this.layer = layer;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer.above)
            this.dom.classList.add("cm-layer-above");
        if (layer.class)
            this.dom.classList.add(layer.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer.mount)
            layer.mount(this.dom, view);
    }
    update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
            this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
            this.scale();
            update.view.requestMeasure(this.measureReq);
        }
    }
    docViewUpdate(view) {
        if (this.layer.updateOnDocViewUpdate !== false)
            view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
            pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
        return this.layer.markers(this.view);
    }
    scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
    }
    draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
            let old = this.dom.firstChild, oldI = 0;
            for (let marker of markers) {
                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&
                    marker.update(old, this.drawn[oldI])) {
                    old = old.nextSibling;
                    oldI++;
                }
                else {
                    this.dom.insertBefore(marker.draw(), old);
                }
            }
            while (old) {
                let next = old.nextSibling;
                old.remove();
                old = next;
            }
            this.drawn = markers;
        }
    }
    destroy() {
        if (this.layer.destroy)
            this.layer.destroy(this.dom, this.view);
        this.dom.remove();
    }
}
const layerOrder = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
/**
Define a layer.
*/
function layer(config) {
    return [
        ViewPlugin.define(v => new LayerView(v, config)),
        layerOrder.of(config)
    ];
}

const CanHidePrimary = !(browser.ios && browser.webkit && browser.webkit_version < 534);
const selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
function drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
    ];
}
/**
Retrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration
for this state. (Note that this will return a set of defaults even
if `drawSelection` isn't enabled.)
*/
function getDrawSelectionConfig(state) {
    return state.facet(selectionConfig);
}
function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = /*@__PURE__*/layer({
    above: true,
    markers(view) {
        let { state } = view, conf = state.facet(selectionConfig);
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                for (let piece of RectangleMarker.forRange(view, className, cursor))
                    cursors.push(piece);
            }
        }
        return cursors;
    },
    update(update, dom) {
        if (update.transactions.some(tr => tr.selection))
            dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
            setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
        setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = /*@__PURE__*/layer({
    above: false,
    markers(view) {
        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))
            .reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
});
const themeSpec = {
    ".cm-line": {
        "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    },
    ".cm-content": {
        "& :focus": {
            caretColor: "initial !important",
            "&::selection, & ::selection": {
                backgroundColor: "Highlight !important"
            }
        }
    }
};
if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
const hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));

const setDropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
});
const dropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create() { return null; },
    update(pos, tr) {
        if (pos != null)
            pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
    }
});
const drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
        var _a;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                this.cursor = null;
            }
        }
        else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
            return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            let { scaleX, scaleY } = this.view;
            if (pos) {
                this.cursor.style.left = pos.left / scaleX + "px";
                this.cursor.style.top = pos.top / scaleY + "px";
                this.cursor.style.height = pos.height / scaleY + "px";
            }
            else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor)
            this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
}, {
    eventObservers: {
        dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                this.setDropPos(null);
        },
        dragend() {
            this.setDropPos(null);
        },
        drop() {
            this.setDropPos(null);
        }
    }
});
/**
Draws a cursor at the current drop position when something is
dragged over the editor.
*/
function dropCursor() {
    return [dropCursorPos, drawDropCursor];
}

function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to)
        return visible;
    let result = [];
    for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
        else
            result.push({ from, to });
    }
    return result;
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
class MatchDecorator {
    /**
    Create a decorator.
    */
    constructor(config) {
        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
        }
        else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
                let deco = decoration(match, view, from);
                if (deco)
                    add(from, from + match[0].length, deco);
            };
        }
        else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
        }
        else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSetBuilder(), add = build.add.bind(build);
        for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
        return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to > update.view.viewport.from && from < update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportChanged || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                let add = (from, to, deco) => ranges.push(deco.range(from, to));
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                        this.addMatch(m, view, m.index + fromLine.from, add);
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
            }
        }
        return deco;
    }
}

const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /*@__PURE__*/new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine(configs) {
        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
/**
Returns an extension that installs highlighting of special
characters.
*/
function highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.codePointAt)(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(line.text, size, pos - line.from);
                        return Decoration.replace({
                            widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)
                        });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends WidgetType {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}

const plugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1000;
        this.attrs = { style: "padding-bottom: 1000px" };
    }
    update(update) {
        let { view } = update;
        let height = view.viewState.editorHeight -
            view.defaultLineHeight - view.documentPadding.top - 0.5;
        if (height >= 0 && height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
        }
    }
});
/**
Returns an extension that makes sure the content has a bottom
margin equivalent to the height of the editor, minus one line
height, so that every line in the document can be scrolled to the
top of the editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/
function scrollPastEnd() {
    return [plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];
}

/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = /*@__PURE__*/Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});

class Placeholder extends WidgetType {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM(view) {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) :
            typeof this.content == "function" ? this.content(view) :
                this.content.cloneNode(true));
        if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
        else
            wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
        if (!rects.length)
            return null;
        let style = window.getComputedStyle(dom.parentNode);
        let rect = flattenRect(rects[0], style.direction != "rtl");
        let lineHeight = parseInt(style.lineHeight);
        if (rect.bottom - rect.top > lineHeight * 1.5)
            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
        return rect;
    }
    ignoreEvent() { return false; }
}
/**
Extension that enables a placeholder—a piece of example content
to show when the editor is empty.
*/
function placeholder(content) {
    return ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = content
                ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])
                : Decoration.none;
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
}

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;
function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            if (line.length <= endOff)
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findColumn)(line.text, startCol, state.tabSize, true);
            if (start < 0) {
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(line.to));
            }
            else {
                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.findColumn)(line.text, endCol, state.tabSize);
                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.countColumn)(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges.concat(startSel.ranges));
            else
                return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges);
        }
    };
}
/**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
    Alt: [18, e => !!e.altKey],
    Control: [17, e => !!e.ctrlKey],
    Shift: [16, e => !!e.shiftKey],
    Meta: [91, e => !!e.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
/**
Returns an extension that turns the pointer cursor into a
crosshair when a given modifier key, defaulting to Alt, is held
down. Can serve as a visual hint that rectangular selection is
going to happen when paired with
[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
*/
function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.isDown = false;
        }
        set(isDown) {
            if (this.isDown != isDown) {
                this.isDown = isDown;
                this.view.update([]);
            }
        }
    }, {
        eventObservers: {
            keydown(e) {
                this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
                if (e.keyCode == code || !getter(e))
                    this.set(false);
            },
            mousemove(e) {
                this.set(getter(e));
            }
        }
    });
    return [
        plugin,
        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
    ];
}

const Outside = "-10000px";
class TooltipViewManager {
    constructor(view, facet, createTooltipView, removeTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.removeTooltipView = removeTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter(t => t);
        let prev = null;
        this.tooltipViews = this.tooltips.map(t => prev = createTooltipView(t, prev));
    }
    update(update, above) {
        var _a;
        let input = update.state.facet(this.facet);
        let tooltips = input.filter(x => x);
        if (input === this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
            return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i = 0; i < tooltips.length; i++) {
            let tip = tooltips[i], known = -1;
            if (!tip)
                continue;
            for (let i = 0; i < this.tooltips.length; i++) {
                let other = this.tooltips[i];
                if (other && other.create == tip.create)
                    known = i;
            }
            if (known < 0) {
                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
                if (newAbove)
                    newAbove[i] = !!tip.above;
            }
            else {
                let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                if (newAbove)
                    newAbove[i] = above[known];
                if (tooltipView.update)
                    tooltipView.update(update);
            }
        }
        for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0) {
                this.removeTooltipView(t);
                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
            }
        if (above) {
            newAbove.forEach((val, i) => above[i] = val);
            above.length = newAbove.length;
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
/**
Creates an extension that configures tooltip behavior.
*/
function tooltips(config = {}) {
    return tooltipConfig.of(config);
}
function windowSpace(view) {
    let { win } = view;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
const tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine: values => {
        var _a, _b, _c;
        return ({
            position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
        });
    }
});
const knownHeight = /*@__PURE__*/new WeakMap();
const tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
        this.manager = new TooltipViewManager(view, showTooltip, (t, p) => this.createTooltip(t, p), t => {
            if (this.resizeObserver)
                this.resizeObserver.unobserve(t.dom);
            t.dom.remove();
        });
        this.above = this.manager.tooltips.map(t => !!t.above);
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
            if (Date.now() > this.lastTransaction - 50 &&
                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        }
        else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
                this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
                this.measureTimeout = -1;
                this.maybeMeasure();
            }, 50);
    }
    update(update) {
        if (update.transactions.length)
            this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
            this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent)
                this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
                this.container.appendChild(t.dom);
            shouldMeasure = true;
        }
        else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
            this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
        let tooltipView = tooltip.create(this.view);
        let before = prev ? prev.dom : null;
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.insertBefore(tooltipView.dom, before);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        if (this.resizeObserver)
            this.resizeObserver.observe(tooltipView.dom);
        return tooltipView;
    }
    destroy() {
        var _a, _b, _c;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove();
            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
        }
        if (this.parent)
            this.container.remove();
        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0];
            if (browser.gecko) {
                // Firefox sets the element's `offsetParent` to the
                // transformed element when a transform interferes with fixed
                // positioning.
                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
            }
            else if (dom.style.top == Outside && dom.style.left == "0px") {
                // On other browsers, we have to awkwardly try and use other
                // information to detect a transform.
                let rect = dom.getBoundingClientRect();
                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;
            }
        }
        if (makeAbsolute || this.position == "absolute") {
            if (this.parent) {
                let rect = this.parent.getBoundingClientRect();
                if (rect.width && rect.height) {
                    scaleX = rect.width / this.parent.offsetWidth;
                    scaleY = rect.height / this.parent.offsetHeight;
                }
            }
            else {
                ({ scaleX, scaleY } = this.view.viewState);
            }
        }
        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
        return {
            visible: {
                left: visible.left + margins.left, top: visible.top + margins.top,
                right: visible.right - margins.right, bottom: visible.bottom - margins.bottom
            },
            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
            pos: this.manager.tooltips.map((t, i) => {
                let tv = this.manager.tooltipViews[i];
                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX, scaleY, makeAbsolute
        };
    }
    writeMeasure(measured) {
        var _a;
        if (measured.makeAbsolute) {
            this.madeAbsolute = true;
            this.position = "absolute";
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = "absolute";
        }
        let { visible, space, scaleX, scaleY } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) ||
                pos.top >= Math.min(visible.bottom, space.bottom) ||
                pos.right < Math.max(visible.left, space.left) - .1 ||
                pos.left > Math.min(visible.right, space.right) + .1)) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
            let left = size.width > space.right - space.left
                ? (ltr ? space.left : space.right - size.width)
                : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width))
                    : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x), space.right - width);
            let above = this.above[i];
            if (!tooltip.strictSide && (above
                ? pos.top - height - arrowHeight - offset.y < space.top
                : pos.bottom + height + arrowHeight + offset.y > space.bottom) &&
                above == (space.bottom - pos.bottom > pos.top - space.top))
                above = this.above[i] = !above;
            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
            if (spaceVert < height && tView.resize !== false) {
                if (spaceVert < this.view.defaultLineHeight) {
                    dom.style.top = Outside;
                    continue;
                }
                knownHeight.set(tView, height);
                dom.style.height = (height = spaceVert) / scaleY + "px";
            }
            else if (dom.style.height) {
                dom.style.height = "";
            }
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true)
                for (let r of others)
                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            if (this.position == "absolute") {
                dom.style.top = (top - measured.parent.top) / scaleY + "px";
                setLeftStyle(dom, (left - measured.parent.left) / scaleX);
            }
            else {
                dom.style.top = top / scaleY + "px";
                setLeftStyle(dom, left / scaleX);
            }
            if (arrow) {
                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);
                arrow.style.left = arrowLeft / scaleX + "px";
            }
            if (tView.overlap !== true)
                others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned(measured.space);
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView)
                this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView)
                    for (let tv of this.manager.tooltipViews)
                        tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventObservers: {
        scroll() { this.maybeMeasure(); }
    }
});
function setLeftStyle(elt, value) {
    let current = parseInt(elt.style.left, 10);
    if (isNaN(current) || Math.abs(value - current) > 1)
        elt.style.left = value + "px";
}
const baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 500,
        boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${7 /* Arrow.Size */}px`,
        width: `${7 /* Arrow.Size */ * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
            borderRight: `${7 /* Arrow.Size */}px solid transparent`,
        },
        ".cm-tooltip-above &": {
            bottom: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                top: "1px"
            }
        },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = { x: 0, y: 0 };
/**
Facet to which an extension can add a value to show a tooltip.
*/
const showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine: inputs => inputs.reduce((a, i) => a.concat(i), [])
});
class HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view) {
        return new HoverTooltipHost(view);
    }
    constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p) => this.createHostedView(t, p), t => t.dom.remove());
    }
    createHostedView(tooltip, prev) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
        if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
                hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
                hostedView.positioned(space);
        }
    }
    update(update) {
        this.manager.update(update);
    }
    destroy() {
        var _a;
        for (let t of this.manager.tooltipViews)
            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
    }
    passProp(name) {
        let value = undefined;
        for (let view of this.manager.tooltipViews) {
            let given = view[name];
            if (given !== undefined) {
                if (value === undefined)
                    value = given;
                else if (value !== given)
                    return undefined;
            }
        }
        return value;
    }
    get offset() { return this.passProp("offset"); }
    get getCoords() { return this.passProp("getCoords"); }
    get overlap() { return this.passProp("overlap"); }
    get resize() { return this.passProp("resize"); }
}
const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {
    let tooltips = state.facet(showHoverTooltip);
    if (tooltips.length === 0)
        return null;
    return {
        pos: Math.min(...tooltips.map(t => t.pos)),
        end: Math.max(...tooltips.map(t => { var _a; return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos; })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some(t => t.arrow),
    };
});
class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active.length)
            return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
            this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
            return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
            pos = desc.posAtStart;
        }
        else {
            pos = view.posAtCoords(lastMove);
            if (pos == null)
                return;
            let posCoords = view.coordsAtPos(pos);
            if (!posCoords ||
                lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
                lastMove.x < posCoords.left - view.defaultCharacterWidth ||
                lastMove.x > posCoords.right + view.defaultCharacterWidth)
                return;
            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
            side = (lastMove.x < posCoords.left ? -rtl : rtl);
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result && !(Array.isArray(result) && !result.length))
                        view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
                }
            }, e => logException(view.state, e, "hover tooltip"));
        }
        else if (open && !(Array.isArray(open) && !open.length)) {
            view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
        }
    }
    get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;
        return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
        var _a, _b;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;
            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {
                this.view.dispatch({ effects: this.setHover.of([]) });
                this.pending = null;
            }
        }
    }
    mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active.length) {
            let { tooltip } = this;
            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
            if (!inTooltip)
                this.view.dispatch({ effects: this.setHover.of([]) });
            else
                this.watchTooltipLeave(tooltip.dom);
        }
    }
    watchTooltipLeave(tooltip) {
        let watch = (event) => {
            tooltip.removeEventListener("mouseleave", watch);
            if (this.active.length && !this.view.dom.contains(event.relatedTarget))
                this.view.dispatch({ effects: this.setHover.of([]) });
        };
        tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
        let arrowRect = arrow.getBoundingClientRect();
        top = Math.min(arrowRect.top, top);
        bottom = Math.max(arrowRect.bottom, bottom);
    }
    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin &&
        event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
        return false;
    let pos = view.posAtCoords({ x, y }, false);
    return pos >= from && pos <= to;
}
/**
Set up a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos`, return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer is—it will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.

The return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)
but also provides an `active` property holding a state field that
can be used to read the currently active tooltips produced by this
extension.
*/
function hoverTooltip(source, options = {}) {
    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();
    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
        create() { return []; },
        update(value, tr) {
            if (value.length) {
                if (options.hideOnChange && (tr.docChanged || tr.selection))
                    value = [];
                else if (options.hideOn)
                    value = value.filter(v => !options.hideOn(tr, v));
                if (tr.docChanged) {
                    let mapped = [];
                    for (let tooltip of value) {
                        let newPos = tr.changes.mapPos(tooltip.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackDel);
                        if (newPos != null) {
                            let copy = Object.assign(Object.create(null), tooltip);
                            copy.pos = newPos;
                            if (copy.end != null)
                                copy.end = tr.changes.mapPos(copy.end);
                            mapped.push(copy);
                        }
                    }
                    value = mapped;
                }
            }
            for (let effect of tr.effects) {
                if (effect.is(setHover))
                    value = effect.value;
                if (effect.is(closeHoverTooltipEffect))
                    value = [];
            }
            return value;
        },
        provide: f => showHoverTooltip.from(f)
    });
    return {
        active: hoverState,
        extension: [
            hoverState,
            ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),
            showHoverTooltipHost
        ]
    };
}
/**
Get the active tooltip view for a given tooltip, if available.
*/
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
        return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
/**
Returns true if any hover tooltips are currently active.
*/
function hasHoverTooltips(state) {
    return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();
/**
Transaction effect that closes all hover tooltips.
*/
const closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);
/**
Tell the tooltip extension to recompute the position of the active
tooltips. This can be useful when something happens (such as a
re-positioning or CSS change affecting the editor) that could
invalidate the existing tooltip positions.
*/
function repositionTooltips(view) {
    let plugin = view.plugin(tooltipPlugin);
    if (plugin)
        plugin.maybeMeasure();
}

const panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
/**
Configures the panel-managing extension.
*/
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        for (let p of this.panels)
            if (p.destroy && panels.indexOf(p) < 0)
                p.destroy();
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ?
                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
const showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    enables: panelPlugin
});

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeValue {
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) { return false; }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) { }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
/**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/
const gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
/**
Facet used to add a class to all gutter elements next to a widget.
Should not provide widgets with a `toDOM` method.
*/
const gutterWidgetClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
function gutters(config) {
    let result = [
        gutterView,
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        for (let gutter of this.gutters)
            this.dom.appendChild(gutter.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (this.updateGutters(update)) {
            // Detach during sync when the viewport changed significantly
            // (such as during scrolling), since for large updates that is
            // faster.
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) {
            this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        }
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach)
            this.dom.remove();
        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
            if (classSet.length)
                classSet = [];
            if (Array.isArray(line.type)) {
                let first = true;
                for (let b of line.type) {
                    if (b.type == BlockType.Text && first) {
                        advanceCursor(lineClasses, classSet, b.from);
                        for (let cx of contexts)
                            cx.line(this.view, b, classSet);
                        first = false;
                    }
                    else if (b.widget) {
                        for (let cx of contexts)
                            cx.widget(this.view, b);
                    }
                }
            }
            else if (line.type == BlockType.Text) {
                advanceCursor(lineClasses, classSet, line.from);
                for (let cx of contexts)
                    cx.line(this.view, line, classSet);
            }
            else if (line.widget) {
                for (let cx of contexts)
                    cx.widget(this.view, line);
            }
        }
        for (let cx of contexts)
            cx.finish();
        if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged ||
            !_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters) {
                g.dom.remove();
                if (gutters.indexOf(g) < 0)
                    g.destroy();
            }
            for (let g of gutters)
                this.dom.appendChild(g.dom);
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)
            view.destroy();
        this.dom.remove();
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
        return view.textDirection == Direction.LTR
            ? { left: value.dom.offsetWidth * view.scaleX }
            : { right: value.dom.offsetWidth * view.scaleX };
    })
});
function asArray(val) { return (Array.isArray(val) ? val : [val]); }
function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos)
            collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    constructor(gutter, viewport, height) {
        this.gutter = gutter;
        this.height = height;
        this.i = 0;
        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.iter(gutter.markers, viewport.from);
    }
    addElement(view, block, markers) {
        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, height, above, markers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            gutter.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
    }
    line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
            localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
            localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
        for (let cls of view.state.facet(gutterWidgetClass)) {
            let marker = cls(view, block.widget, block);
            if (marker)
                (markers || (markers = [])).push(marker);
        }
        if (markers)
            this.addElement(view, block, markers);
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i) {
            let last = gutter.elements.pop();
            gutter.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let target = event.target, y;
                if (target != this.dom && this.dom.contains(target)) {
                    while (target.parentNode != this.dom)
                        target = target.parentNode;
                    let rect = target.getBoundingClientRect();
                    y = (rect.top + rect.bottom) / 2;
                }
                else {
                    y = event.clientY;
                }
                let line = view.lineBlockAtHeight(y - view.documentTop);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||
            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt of this.elements)
            elt.destroy();
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height) {
            this.height = height;
            this.dom.style.height = height + "px";
        }
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0;;) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c)
                    cls += " " + c;
                for (let i = iOld; i < this.markers.length; i++)
                    if (this.markers[i].compare(marker)) {
                        skipTo = i;
                        matched = true;
                        break;
                    }
            }
            else {
                skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker)
                break;
            if (marker.toDOM) {
                if (matched)
                    domPos = domPos.nextSibling;
                else
                    this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
                iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []); // First argument not used unless creating markers
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
/**
Facet used to provide markers to the line number gutter.
*/
const lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
/**
Facet used to create markers in the line number gutter next to widgets.
*/
const lineNumberWidgetMarker = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();
const lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({
    combine(values) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() { return document.createTextNode(this.number); }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.some(m => m.toDOM))
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view, widget, block) => {
        for (let m of view.state.facet(lineNumberWidgetMarker)) {
            let result = m(view, widget, block);
            if (result)
                return result;
        }
        return null;
    },
    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
/**
Create a line number gutter extension.
*/
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {
    constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
    }
};
const activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute(["selection"], state => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.of(marks);
});
/**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}

function matcher(decorator) {
    return ViewPlugin.define(view => ({
        decorations: decorator.createDeco(view),
        update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations);
        },
    }), {
        decorations: v => v.decorations
    });
}
const tabDeco = /*@__PURE__*/Decoration.mark({ class: "cm-highlightTab" });
const spaceDeco = /*@__PURE__*/Decoration.mark({ class: "cm-highlightSpace" });
const whitespaceHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({
    regexp: /\t| /g,
    decoration: match => match[0] == "\t" ? tabDeco : spaceDeco,
    boundary: /\S/,
}));
/**
Returns an extension that highlights whitespace, adding a
`cm-highlightSpace` class to stretches of spaces, and a
`cm-highlightTab` class to individual tab characters. By default,
the former are shown as faint dots, and the latter as arrows.
*/
function highlightWhitespace() {
    return whitespaceHighlighter;
}
const trailingHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({
    regexp: /\s+$/g,
    decoration: /*@__PURE__*/Decoration.mark({ class: "cm-trailingSpace" }),
    boundary: /\S/,
}));
/**
Returns an extension that adds a `cm-trailingSpace` class to all
trailing whitespace.
*/
function highlightTrailingWhitespace() {
    return trailingHighlighter;
}

/**
@internal
*/
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder,
    moveVisually, clearHeightChangeFlag, getHeightChangeFlag: () => heightChangeFlag };




/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base: () => (/* binding */ base),
/* harmony export */   keyName: () => (/* binding */ keyName),
/* harmony export */   shift: () => (/* binding */ shift)
/* harmony export */ });
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
}

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent)
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent)
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
var brokenModifierNames = mac || chrome && +chrome[1] < 57

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    ie && event.shiftKey && event.key && event.key.length == 1 ||
    event.key == "Unidentified"
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl92aWV3X2Rpc3RfaW5kZXhfanMuYzUxODlmZDZhNjhlNDMwY2I0NjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFTO0FBQzdQO0FBQ1c7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyREFBMkQ7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDBEQUEwRDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkMsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOERBQWU7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDZCQUE2QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCLGVBQWU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJCQUEyQixrQkFBa0IsbURBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhEQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVcsOEJBQThCLDBEQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsd0VBQXdFLDhEQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCLElBQUksbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBVyw2RUFBNkUsUUFBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDJFQUEyRSw4REFBZTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxrREFBa0QsOERBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUsseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssMkJBQTJCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQVc7QUFDaEMsc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBSyxVQUFVLG1EQUFtRDtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDRCQUE0QjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG9EQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7O0FBRXhCO0FBQ0EsZ0JBQWdCLFNBQVM7O0FBRXpCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHQsIFJhbmdlU2V0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBmaW5kQ2x1c3RlckJyZWFrLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBmaW5kQ29sdW1uLCBDaGFyQ2F0ZWdvcnksIEVkaXRvclN0YXRlLCBBbm5vdGF0aW9uLCBUcmFuc2FjdGlvbiwgUHJlYywgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFJhbmdlU2V0QnVpbGRlciwgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlLCBzaGlmdCB9IGZyb20gJ3czYy1rZXluYW1lJztcblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHJvb3QpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIC8vIEJyb3dzZXJzIGRpZmZlciBvbiB3aGV0aGVyIHNoYWRvdyByb290cyBoYXZlIGEgZ2V0U2VsZWN0aW9uXG4gICAgLy8gbWV0aG9kLiBJZiBpdCBleGlzdHMsIHVzZSB0aGF0LCBvdGhlcndpc2UsIGNhbGwgaXQgb24gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgaWYgKHJvb3Qubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgdGFyZ2V0ID0gcm9vdC5nZXRTZWxlY3Rpb24gPyByb290IDogcm9vdC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZG9tID09IG5vZGUgfHwgZG9tLmNvbnRhaW5zKG5vZGUubm9kZVR5cGUgIT0gMSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24oZG9tLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHRleHRSYW5nZShkb20sIDAsIGRvbS5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICByZXR1cm4gZG9tLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW107XG59XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBtYXhPZmZzZXQobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBtYXhPZmZzZXQobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5SZWN0KHJlY3QsIGxlZnQpIHtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XG59XG5mdW5jdGlvbiB3aW5kb3dSZWN0KHdpbikge1xuICAgIGxldCB2cCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgICBpZiAodnApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCByaWdodDogdnAud2lkdGgsXG4gICAgICAgICAgICB0b3A6IDAsIGJvdHRvbTogdnAuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTY2FsZShlbHQsIHJlY3QpIHtcbiAgICBsZXQgc2NhbGVYID0gcmVjdC53aWR0aCAvIGVsdC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBlbHQub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChzY2FsZVggPiAwLjk5NSAmJiBzY2FsZVggPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVYKSB8fCBNYXRoLmFicyhyZWN0LndpZHRoIC0gZWx0Lm9mZnNldFdpZHRoKSA8IDEpXG4gICAgICAgIHNjYWxlWCA9IDE7XG4gICAgaWYgKHNjYWxlWSA+IDAuOTk1ICYmIHNjYWxlWSA8IDEuMDA1IHx8ICFpc0Zpbml0ZShzY2FsZVkpIHx8IE1hdGguYWJzKHJlY3QuaGVpZ2h0IC0gZWx0Lm9mZnNldEhlaWdodCkgPCAxKVxuICAgICAgICBzY2FsZVkgPSAxO1xuICAgIHJldHVybiB7IHNjYWxlWCwgc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcoZG9tLCByZWN0LCBzaWRlLCB4LCB5LCB4TWFyZ2luLCB5TWFyZ2luLCBsdHIpIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLCBzdG9wID0gZmFsc2U7IGN1ciAmJiAhc3RvcDspIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7IC8vIEVsZW1lbnRcbiAgICAgICAgICAgIGxldCBib3VuZGluZywgdG9wID0gY3VyID09IGRvYy5ib2R5O1xuICAgICAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB3aW5kb3dSZWN0KHdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShjdXIpLnBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPD0gY3VyLmNsaWVudEhlaWdodCAmJiBjdXIuc2Nyb2xsV2lkdGggPD0gY3VyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGN1ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAoeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoY3VyLCByZWN0KSk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIGN1ci5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGN1ci5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgICAgIGlmICh5ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgKHJlY3QudG9wIC0gbW92ZVkpIDwgYm91bmRpbmcudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCArIG1vdmVZIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AsIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRUb3AgPSB5ID09IFwiY2VudGVyXCIgJiYgcmVjdEhlaWdodCA8PSBib3VuZGluZ0hlaWdodCA/IHJlY3QudG9wICsgcmVjdEhlaWdodCAvIDIgLSBib3VuZGluZ0hlaWdodCAvIDIgOlxuICAgICAgICAgICAgICAgICAgICB5ID09IFwic3RhcnRcIiB8fCB5ID09IFwiY2VudGVyXCIgJiYgc2lkZSA8IDAgPyByZWN0LnRvcCAtIHlNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5ib3R0b20gLSBib3VuZGluZ0hlaWdodCArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVkgPSB0YXJnZXRUb3AgLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVggKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgKyBtb3ZlWCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMZWZ0ID0geCA9PSBcImNlbnRlclwiID8gcmVjdC5sZWZ0ICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMiAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpIC8gMiA6XG4gICAgICAgICAgICAgICAgICAgICh4ID09IFwic3RhcnRcIikgPT0gbHRyID8gcmVjdC5sZWZ0IC0geE1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnJpZ2h0IC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVYID0gdGFyZ2V0TGVmdCAtIGJvdW5kaW5nLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVkWCA9IDAsIG1vdmVkWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFkgPSAoY3VyLnNjcm9sbFRvcCAtIHN0YXJ0KSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbExlZnQgKz0gbW92ZVggLyBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFggPSAoY3VyLnNjcm9sbExlZnQgLSBzdGFydCkgKiBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gbW92ZWRYLCB0b3A6IHJlY3QudG9wIC0gbW92ZWRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgLSBtb3ZlZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBtb3ZlZFkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWCAmJiBNYXRoLmFicyhtb3ZlZFggLSBtb3ZlWCkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRZICYmIE1hdGguYWJzKG1vdmVkWSAtIG1vdmVZKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7IC8vIEEgc2hhZG93IHJvb3RcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzY3JvbGxhYmxlUGFyZW50cyhkb20pIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHgsIHk7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLnBhcmVudE5vZGU7IGN1cjspIHtcbiAgICAgICAgaWYgKGN1ciA9PSBkb2MuYm9keSB8fCAoeCAmJiB5KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmICgheSAmJiBjdXIuc2Nyb2xsSGVpZ2h0ID4gY3VyLmNsaWVudEhlaWdodClcbiAgICAgICAgICAgICAgICB5ID0gY3VyO1xuICAgICAgICAgICAgaWYgKCF4ICYmIGN1ci5zY3JvbGxXaWR0aCA+IGN1ci5jbGllbnRXaWR0aClcbiAgICAgICAgICAgICAgICB4ID0gY3VyO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xufVxuY2xhc3MgRE9NU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGZvY3VzTm9kZSB9ID0gcmFuZ2U7XG4gICAgICAgIC8vIENsaXAgb2Zmc2V0cyB0byBub2RlIHNpemUgdG8gYXZvaWQgY3Jhc2hlcyB3aGVuIFNhZmFyaSByZXBvcnRzIGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgICAgICB0aGlzLnNldChhbmNob3JOb2RlLCBNYXRoLm1pbihyYW5nZS5hbmNob3JPZmZzZXQsIGFuY2hvck5vZGUgPyBtYXhPZmZzZXQoYW5jaG9yTm9kZSkgOiAwKSwgZm9jdXNOb2RlLCBNYXRoLm1pbihyYW5nZS5mb2N1c09mZnNldCwgZm9jdXNOb2RlID8gbWF4T2Zmc2V0KGZvY3VzTm9kZSkgOiAwKSk7XG4gICAgfVxuICAgIHNldChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoY3VyID09IGN1ci5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBzdGFja1tpKytdLCB0b3AgPSBzdGFja1tpKytdLCBsZWZ0ID0gc3RhY2tbaSsrXTtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsVG9wICE9IHRvcClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHNjcmF0Y2hSYW5nZTtcbmZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgcmFuZ2UgPSBzY3JhdGNoUmFuZ2UgfHwgKHNjcmF0Y2hSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSk7XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoZWx0LCBuYW1lLCBjb2RlLCBtb2RzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBpZiAobW9kcylcbiAgICAgICAgKHsgYWx0S2V5OiBvcHRpb25zLmFsdEtleSwgY3RybEtleTogb3B0aW9ucy5jdHJsS2V5LCBzaGlmdEtleTogb3B0aW9ucy5zaGlmdEtleSwgbWV0YUtleTogb3B0aW9ucy5tZXRhS2V5IH0gPSBtb2RzKTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PSA5IHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgJiYgbm9kZS5ob3N0KSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcyhub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShub2RlLmF0dHJpYnV0ZXNbMF0pO1xufVxuZnVuY3Rpb24gYXRFbGVtZW50U3RhcnQoZG9jLCBzZWxlY3Rpb24pIHtcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9IG9mZnNldClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFNhZmFyaSBjYW4gcmVwb3J0IGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KG5vZGUpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRUb0JvdHRvbShlbHQpIHtcbiAgICByZXR1cm4gZWx0LnNjcm9sbFRvcCA+IE1hdGgubWF4KDEsIGVsdC5zY3JvbGxIZWlnaHQgLSBlbHQuY2xpZW50SGVpZ2h0IC0gNCk7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaXNCbG9ja0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFpc0Jsb2NrRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBET01Qb3Mge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCwgcHJlY2lzZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IHByZWNpc2U7XG4gICAgfVxuICAgIHN0YXRpYyBiZWZvcmUoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pLCBwcmVjaXNlKTsgfVxuICAgIHN0YXRpYyBhZnRlcihkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSkgKyAxLCBwcmVjaXNlKTsgfVxufVxuY29uc3Qgbm9DaGlsZHJlbiA9IFtdO1xuY2xhc3MgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbGFncyA9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmUodGhpcykgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQXRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgcG9zQmVmb3JlKHZpZXcpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkID09IHZpZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjaGlsZCBpbiBwb3NCZWZvcmVcIik7XG4gICAgfVxuICAgIHBvc0FmdGVyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlKHZpZXcpICsgdmlldy5sZW5ndGg7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsLCBuZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5kb20gJiYgKG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50VmlldyB8fCAhY29udGVudFZpZXcucGFyZW50ICYmIGNvbnRlbnRWaWV3LmNhblJldXNlRE9NKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZXVzZURPTShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZmxhZ3MgJj0gfjcgLyogVmlld0ZsYWcuRGlydHkgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjayAmJiAhdHJhY2sud3JpdHRlbiAmJiB0cmFjay5ub2RlID09IHBhcmVudCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZC5kb20sIG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGQuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiB0cmFjayAmJiB0cmFjay5ub2RlID09IHBhcmVudClcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KVxuICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZmxhZ3MgJj0gfjcgLyogVmlld0ZsYWcuRGlydHkgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKF9kb20pIHsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGFmdGVyO1xuICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLmRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IG1heE9mZnNldChub2RlKSA9PSAwID8gMCA6IG9mZnNldCA9PSAwID8gLTEgOiAxO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXMgPT0gMCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09IHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlciA9PSB0aGlzLmRvbS5maXJzdENoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHdoaWxlIChhZnRlciAmJiAhQ29udGVudFZpZXcuZ2V0KGFmdGVyKSlcbiAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmRvbSA9PSBhZnRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBmcm9tSSA9IC0xLCBmcm9tU3RhcnQgPSAtMSwgdG9JID0gLTEsIHRvRW5kID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBvZmZzZXQsIHByZXZFbmQgPSBvZmZzZXQ7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBwb3MpO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBmcm9tICYmIGZyb21JID09IC0xKSB7XG4gICAgICAgICAgICAgICAgZnJvbUkgPSBpO1xuICAgICAgICAgICAgICAgIGZyb21TdGFydCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPiB0byAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRvSSA9IGk7XG4gICAgICAgICAgICAgICAgdG9FbmQgPSBwcmV2RW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkVuZCA9IGVuZDtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbVN0YXJ0LCB0bzogdG9FbmQgPCAwID8gb2Zmc2V0ICsgdGhpcy5sZW5ndGggOiB0b0VuZCxcbiAgICAgICAgICAgIHN0YXJ0RE9NOiAoZnJvbUkgPyB0aGlzLmNoaWxkcmVuW2Zyb21JIC0gMV0uZG9tLm5leHRTaWJsaW5nIDogbnVsbCkgfHwgdGhpcy5kb20uZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIGVuZERPTTogdG9JIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgdG9JID49IDAgPyB0aGlzLmNoaWxkcmVuW3RvSV0uZG9tIDogbnVsbCB9O1xuICAgIH1cbiAgICBtYXJrRGlydHkoYW5kUGFyZW50ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mbGFncyB8PSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KGFuZFBhcmVudCk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoY2hpbGRMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXMucGFyZW50OyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZExpc3QpXG4gICAgICAgICAgICAgICAgcGFyZW50LmZsYWdzIHw9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5mbGFncyAmIDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwYXJlbnQuZmxhZ3MgfD0gMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovO1xuICAgICAgICAgICAgY2hpbGRMaXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLylcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RE9NKGRvbSkge1xuICAgICAgICBpZiAodGhpcy5kb20gPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmRvbS5jbVZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgZG9tLmNtVmlldyA9IHRoaXM7XG4gICAgfVxuICAgIGdldCByb290VmlldygpIHtcbiAgICAgICAgZm9yIChsZXQgdiA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHYucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB2ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VDaGlsZHJlbihmcm9tLCB0bywgY2hpbGRyZW4gPSBub0NoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcyAmJiBjaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA8IDApXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPCAyNTApXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmcm9tLCB0byAtIGZyb20sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdLmNvbmNhdCh0aGlzLmNoaWxkcmVuLnNsaWNlKDAsIGZyb20pLCBjaGlsZHJlbiwgdGhpcy5jaGlsZHJlbi5zbGljZSh0bykpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY2hpbGRyZW5baV0uc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihfcmVjKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlnbm9yZUV2ZW50KF9ldmVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICBjaGlsZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIGJpYXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZShcIlZpZXdcIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBuYW1lICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyB0aGlzLmNoaWxkcmVuLmpvaW4oKSArIFwiKVwiIDpcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID8gXCJbXCIgKyAobmFtZSA9PSBcIlRleHRcIiA/IHRoaXMudGV4dCA6IHRoaXMubGVuZ3RoKSArIFwiXVwiIDogXCJcIikgK1xuICAgICAgICAgICAgKHRoaXMuYnJlYWtBZnRlciA/IFwiI1wiIDogXCJcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQobm9kZSkgeyByZXR1cm4gbm9kZS5jbVZpZXc7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjYW5SZXVzZURPTShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIuY29uc3RydWN0b3IgPT0gdGhpcy5jb25zdHJ1Y3RvciAmJiAhKCh0aGlzLmZsYWdzIHwgb3RoZXIuZmxhZ3MpICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhpcyBpcyBhIHplcm8tbGVuZ3RoIHZpZXcgd2l0aCBhIHNpZGUsIHRoaXMgc2hvdWxkIHJldHVybiBhXG4gICAgLy8gbnVtYmVyIDw9IDAgdG8gaW5kaWNhdGUgaXQgaXMgYmVmb3JlIGl0cyBwb3NpdGlvbiwgb3IgYVxuICAgIC8vIG51bWJlciA+IDAgd2hlbiBhZnRlciBpdHMgcG9zaXRpb24uXG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cbkNvbnRlbnRWaWV3LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtJDEoZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNsYXNzIENoaWxkQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgcG9zLCBpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZmluZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0aGlzLnBvcyB8fCBwb3MgPT0gdGhpcy5wb3MgJiZcbiAgICAgICAgICAgICAgICAoYmlhcyA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmID0gcG9zIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bLS10aGlzLmldO1xuICAgICAgICAgICAgdGhpcy5wb3MgLT0gbmV4dC5sZW5ndGggKyBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuW2Zyb21JXSA6IG51bGw7XG4gICAgbGV0IGxhc3QgPSBpbnNlcnQubGVuZ3RoID8gaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgbGV0IGJyZWFrQXRFbmQgPSBsYXN0ID8gbGFzdC5icmVha0FmdGVyIDogYnJlYWtBdFN0YXJ0O1xuICAgIC8vIENoYW5nZSB3aXRoaW4gYSBzaW5nbGUgY2hpbGRcbiAgICBpZiAoZnJvbUkgPT0gdG9JICYmIGJlZm9yZSAmJiAhYnJlYWtBdFN0YXJ0ICYmICFicmVha0F0RW5kICYmIGluc2VydC5sZW5ndGggPCAyICYmXG4gICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCB0b09mZiwgaW5zZXJ0Lmxlbmd0aCA/IGxhc3QgOiBudWxsLCBmcm9tT2ZmID09IDAsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IGNoaWxkcmVuW3RvSV07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW5kIG9mIHRoZSBjaGlsZCBhZnRlciB0aGUgdXBkYXRlIGlzIHByZXNlcnZlZCBpbiBgYWZ0ZXJgXG4gICAgICAgIGlmIChhZnRlciAmJiAodG9PZmYgPCBhZnRlci5sZW5ndGggfHwgYWZ0ZXIuYnJlYWtBZnRlciAmJiAobGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmJyZWFrQWZ0ZXIpKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGEgY2hpbGQsIHNlcGFyYXRlIHBhcnQgb2YgaXQgdG8gYXZvaWQgdGhhdFxuICAgICAgICAgICAgLy8gYmVpbmcgbWFuZ2xlZCB3aGVuIHVwZGF0aW5nIHRoZSBjaGlsZCBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIGlmIChmcm9tSSA9PSB0b0kpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNwbGl0KHRvT2ZmKTtcbiAgICAgICAgICAgICAgICB0b09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgcmVwbGFjZW1lbnQgc2hvdWxkIGJlIG1lcmdlZCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCByZXBsYWNpbmcgZWxlbWVudCwgdXBkYXRlIGBjb250ZW50YFxuICAgICAgICAgICAgaWYgKCFicmVha0F0RW5kICYmIGxhc3QgJiYgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIGxhc3QsIHRydWUsIDAsIG9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYWZ0ZXIgZWxlbWVudCwgaWYgbmVjZXNzYXJ5LCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gYGNvbnRlbnRgLlxuICAgICAgICAgICAgICAgIGlmICh0b09mZiB8fCBhZnRlci5jaGlsZHJlbi5sZW5ndGggJiYgIWFmdGVyLmNoaWxkcmVuWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIG51bGwsIGZhbHNlLCAwLCBvcGVuRW5kKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLmJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGF0IGB0b0lgIGlzIGVudGlyZWx5IGNvdmVyZWQgYnkgdGhpcyByYW5nZS5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGl0cyBsaW5lIGJyZWFrLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICBsYXN0LmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2UndmUgaGFuZGxlZCB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudHNcbiAgICAgICAgLy8gbm93LCBtYWtlIHN1cmUgYHRvSWAgcG9pbnRzIGFmdGVyIHRoYXQuXG4gICAgICAgIHRvSSsrO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gYnJlYWtBdFN0YXJ0O1xuICAgICAgICBpZiAoZnJvbU9mZiA+IDApIHtcbiAgICAgICAgICAgIGlmICghYnJlYWtBdFN0YXJ0ICYmIGluc2VydC5sZW5ndGggJiYgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIGluc2VydFswXSwgZmFsc2UsIG9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGluc2VydC5zaGlmdCgpLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tT2ZmIDwgYmVmb3JlLmxlbmd0aCB8fCBiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoICYmIGJlZm9yZS5jaGlsZHJlbltiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgbnVsbCwgZmFsc2UsIG9wZW5TdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBtZXJnZSB3aWRnZXRzIG9uIHRoZSBib3VuZGFyaWVzIG9mIHRoZSByZXBsYWNlbWVudFxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBpbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblt0b0kgLSAxXS5iZWNvbWUoaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHRvSS0tO1xuICAgICAgICAgICAgaW5zZXJ0LnBvcCgpO1xuICAgICAgICAgICAgb3BlbkVuZCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlblN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2Zyb21JXS5iZWNvbWUoaW5zZXJ0WzBdKSkge1xuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgICAgIGluc2VydC5zaGlmdCgpO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbnNlcnQubGVuZ3RoICYmIGZyb21JICYmIHRvSSA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhY2hpbGRyZW5bZnJvbUkgLSAxXS5icmVha0FmdGVyICYmXG4gICAgICAgIGNoaWxkcmVuW3RvSV0ubWVyZ2UoMCwgMCwgY2hpbGRyZW5bZnJvbUkgLSAxXSwgZmFsc2UsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIGZyb21JLS07XG4gICAgaWYgKGZyb21JIDwgdG9JIHx8IGluc2VydC5sZW5ndGgpXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGRyZW4oZnJvbUksIHRvSSwgaW5zZXJ0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW5JbnRvKHBhcmVudCwgZnJvbSwgdG8sIGluc2VydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IGN1ciA9IHBhcmVudC5jaGlsZEN1cnNvcigpO1xuICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3VyLmZpbmRQb3ModG8sIDEpO1xuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcbiAgICBsZXQgZExlbiA9IGZyb20gLSB0bztcbiAgICBmb3IgKGxldCB2aWV3IG9mIGluc2VydClcbiAgICAgICAgZExlbiArPSB2aWV3Lmxlbmd0aDtcbiAgICBwYXJlbnQubGVuZ3RoICs9IGRMZW47XG4gICAgcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgMCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHNhZmFyaSxcbiAgICB3ZWJraXRfdmVyc2lvbjogd2Via2l0ID8gKygvKkBfX1BVUkVfXyovL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIHRhYlNpemU6IGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUudGFiU2l6ZSAhPSBudWxsID8gXCJ0YWItc2l6ZVwiIDogXCItbW96LXRhYi1zaXplXCJcbn07XG5cbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgY3JlYXRlRE9NKHRleHRET00pIHtcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTShkb20pO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XG4gICAgICAgIGlmICgodGhpcy5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pIHx8XG4gICAgICAgICAgICBzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZS5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmVzdWx0LmZsYWdzIHw9IHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBub2RlID09IHRoaXMuZG9tID8gb2Zmc2V0IDogb2Zmc2V0ID8gdGhpcy50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gbmV3IERPTVBvcyh0aGlzLmRvbSwgcG9zKTsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChfZnJvbSwgX3RvLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2Zmc2V0LCB0bzogb2Zmc2V0ICsgdGhpcy5sZW5ndGgsIHN0YXJ0RE9NOiB0aGlzLmRvbSwgZW5kRE9NOiB0aGlzLmRvbS5uZXh0U2libGluZyB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxufVxuY2xhc3MgTWFya1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IobWFyaywgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGNoLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgc2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIGNsZWFyQXR0cmlidXRlcyhkb20pO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IHRoaXMubWFyay5jbGFzcztcbiAgICAgICAgaWYgKHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdGhpcy5tYXJrLmF0dHJzW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhblJldXNlRE9NKG90aGVyKSAmJiAhKCh0aGlzLmZsYWdzIHwgb3RoZXIuZmxhZ3MpICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMuc2V0QXR0cnMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1hcmsudGFnTmFtZSkpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBzb3VyY2UubWFyay5lcSh0aGlzLm1hcmspKSB8fFxuICAgICAgICAgICAgKGZyb20gJiYgb3BlblN0YXJ0IDw9IDApIHx8ICh0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuLnNsaWNlKCkgOiBbXSwgb3BlblN0YXJ0IC0gMSwgb3BlbkVuZCAtIDEpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIG9mZiA9IDAsIGRldGFjaEZyb20gPSAtMSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gb2ZmICsgZWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9mZiA8IGZyb20gPyBlbHQuc3BsaXQoZnJvbSAtIG9mZikgOiBlbHQpO1xuICAgICAgICAgICAgaWYgKGRldGFjaEZyb20gPCAwICYmIG9mZiA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIGRldGFjaEZyb20gPSBpO1xuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbTtcbiAgICAgICAgaWYgKGRldGFjaEZyb20gPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBkZXRhY2hGcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3KHRoaXMubWFyaywgcmVzdWx0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGxlbmd0aCA9IHRleHQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBpZiAocG9zID4gbGVuZ3RoKVxuICAgICAgICBwb3MgPSBsZW5ndGg7XG4gICAgbGV0IGZyb20gPSBwb3MsIHRvID0gcG9zLCBmbGF0dGVuID0gMDtcbiAgICBpZiAocG9zID09IDAgJiYgc2lkZSA8IDAgfHwgcG9zID09IGxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgaWYgKCEoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykpIHsgLy8gVGhlc2UgYnJvd3NlcnMgcmVsaWFibHkgcmV0dXJuIHZhbGlkIHJlY3RhbmdsZXMgZm9yIGVtcHR5IHJhbmdlc1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gMTtcbiAgICAgICAgICAgIH0gLy8gRklYTUUgdGhpcyBpcyB3cm9uZyBpbiBSVEwgdGV4dFxuICAgICAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgfVxuICAgIGxldCByZWN0cyA9IHRleHRSYW5nZSh0ZXh0LCBmcm9tLCB0bykuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlY3QgPSByZWN0c1soZmxhdHRlbiA/IGZsYXR0ZW4gPCAwIDogc2lkZSA+PSAwKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWZsYXR0ZW4gJiYgcmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZWN0ID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgciA9PiByLndpZHRoKSB8fCByZWN0O1xuICAgIHJldHVybiBmbGF0dGVuID8gZmxhdHRlblJlY3QocmVjdCwgZmxhdHRlbiA8IDApIDogcmVjdCB8fCBudWxsO1xufVxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcbmNsYXNzIFdpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgc3RhdGljIGNyZWF0ZSh3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdpZGdldFZpZXcod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFdpZGdldFZpZXcuY3JlYXRlKHRoaXMud2lkZ2V0LCB0aGlzLmxlbmd0aCAtIGZyb20sIHRoaXMuc2lkZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IGZyb207XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZSAmJlxuICAgICAgICAgICAgdGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmNvbXBhcmUob3RoZXIud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodG9wLnBhcmVudClcbiAgICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRvcCwgdGV4dCA9IHZpZXcgJiYgdmlldy5zdGF0ZS5kb2MsIHN0YXJ0ID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4gdGV4dCA/IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sZW5ndGggPyBwb3MgPT0gMCA6IHRoaXMuc2lkZSA+IDApXG4gICAgICAgICAgICA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pXG4gICAgICAgICAgICA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZyb21CYWNrID0gdGhpcy5zaWRlID8gdGhpcy5zaWRlIDwgMCA6IHBvcyA+IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tQmFjayA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAoZnJvbUJhY2sgPyAtMSA6IDEpKSB7XG4gICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocG9zID4gMCA/IGkgPT0gMCA6IGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAhZnJvbUJhY2spO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LmlzSGlkZGVuOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG4vLyBUaGVzZSBhcmUgZHJhd24gYXJvdW5kIHVuZWRpdGFibGUgd2lkZ2V0cyB0byBhdm9pZCBhIG51bWJlciBvZlxuLy8gYnJvd3NlciBidWdzIHRoYXQgc2hvdyB1cCB3aGVuIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgbmV4dCB0b1xuLy8gdW5lZGl0YWJsZSBpbmxpbmUgY29udGVudC5cbmNsYXNzIFdpZGdldEJ1ZmZlclZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuICAgIG1lcmdlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0QnVmZmVyVmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZTtcbiAgICB9XG4gICAgc3BsaXQoKSB7IHJldHVybiBuZXcgV2lkZ2V0QnVmZmVyVmlldyh0aGlzLnNpZGUpOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS13aWRnZXRCdWZmZXJcIjtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIHRoaXMuc2lkZSA+IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSk7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oKSB7IHJldHVybiAwOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG59XG5UZXh0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldEJ1ZmZlclZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gbm9DaGlsZHJlbjtcbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKHBhcmVudCwgcG9zKSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudC5kb20sIHsgY2hpbGRyZW4gfSA9IHBhcmVudCwgaSA9IDA7XG4gICAgZm9yIChsZXQgb2ZmID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmICYmIGNoaWxkLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwb3MgPiBvZmYgJiYgcG9zIDwgZW5kICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21BdFBvcyhwb3MgLSBvZmYpO1xuICAgICAgICBpZiAocG9zIDw9IG9mZilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvZmYgPSBlbmQ7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICBpZiAocHJldi5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gcHJldi5kb21BdFBvcyhwcmV2Lmxlbmd0aCk7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKG5leHQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tQXRQb3MoMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NUG9zKGRvbSwgMCk7XG59XG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cbmZ1bmN0aW9uIGpvaW5JbmxpbmVJbnRvKHBhcmVudCwgdmlldywgb3Blbikge1xuICAgIGxldCBsYXN0LCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBsYXN0Lm1hcmsuZXEodmlldy5tYXJrKSkge1xuICAgICAgICBqb2luSW5saW5lSW50byhsYXN0LCB2aWV3LmNoaWxkcmVuWzBdLCBvcGVuIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQubGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xufVxuZnVuY3Rpb24gY29vcmRzSW5DaGlsZHJlbih2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgYmVmb3JlID0gbnVsbCwgYmVmb3JlUG9zID0gLTEsIGFmdGVyID0gbnVsbCwgYWZ0ZXJQb3MgPSAtMTtcbiAgICBmdW5jdGlvbiBzY2FuKHZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IHZpZXcuY2hpbGRyZW4ubGVuZ3RoICYmIG9mZiA8PSBwb3M7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW4oY2hpbGQsIHBvcyAtIG9mZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuaXNIaWRkZW4gJiYgc2lkZSA+IDApICYmXG4gICAgICAgICAgICAgICAgICAgIChlbmQgPiBwb3MgfHwgb2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhZnRlclBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmIDwgcG9zIHx8IChvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA8IDApICYmICFjaGlsZC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuKHZpZXcsIHBvcyk7XG4gICAgbGV0IHRhcmdldCA9IChzaWRlIDwgMCA/IGJlZm9yZSA6IGFmdGVyKSB8fCBiZWZvcmUgfHwgYWZ0ZXI7XG4gICAgaWYgKHRhcmdldClcbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb29yZHNBdChNYXRoLm1heCgwLCB0YXJnZXQgPT0gYmVmb3JlID8gYmVmb3JlUG9zIDogYWZ0ZXJQb3MpLCBzaWRlKTtcbiAgICByZXR1cm4gZmFsbGJhY2tSZWN0KHZpZXcpO1xufVxuZnVuY3Rpb24gZmFsbGJhY2tSZWN0KHZpZXcpIHtcbiAgICBsZXQgbGFzdCA9IHZpZXcuZG9tLmxhc3RDaGlsZDtcbiAgICBpZiAoIWxhc3QpXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihsYXN0KTtcbiAgICByZXR1cm4gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tYmluZUF0dHJzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiICYmIHRhcmdldC5jbGFzcylcbiAgICAgICAgICAgIHRhcmdldC5jbGFzcyArPSBcIiBcIiArIHNvdXJjZS5jbGFzcztcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIgJiYgdGFyZ2V0LnN0eWxlKVxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlICs9IFwiO1wiICsgc291cmNlLnN0eWxlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBub0F0dHJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBhdHRyc0VxKGEsIGIsIGlnbm9yZSkge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghYSlcbiAgICAgICAgYSA9IG5vQXR0cnM7XG4gICAgaWYgKCFiKVxuICAgICAgICBiID0gbm9BdHRycztcbiAgICBsZXQga2V5c0EgPSBPYmplY3Qua2V5cyhhKSwga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQS5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSAhPVxuICAgICAgICBrZXlzQi5sZW5ndGggLSAoaWdub3JlICYmIGtleXNCLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XG4gICAgICAgIGlmIChrZXkgIT0gaWdub3JlICYmIChrZXlzQi5pbmRleE9mKGtleSkgPT0gLTEgfHwgYVtrZXldICE9PSBiW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKGRvbSwgcHJldiwgYXR0cnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHIgPSBkb20uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gaWYgdGhlIGRlY29yYXRpb25zXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXG4qL1xuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAoVHlwZVNjcmlwdCBjYW4ndCBleHByZXNzIHRoaXMsIGJ1dCBvbmx5IGluc3RhbmNlcyBvZiB0aGUgc2FtZVxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXG4gICAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICAgIGRlY29yYXRpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdFxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cbiAgICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgICAqL1xuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShkb20sIHZpZXcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBGb3IgaW5saW5lIHdpZGdldHMgdGhhdCBhcmUgZGlzcGxheWVkIGlubGluZSAoYXMgb3Bwb3NlZCB0b1xuICAgIGBpbmxpbmUtYmxvY2tgKSBhbmQgaW50cm9kdWNlIGxpbmUgYnJlYWtzICh0aHJvdWdoIGA8YnI+YCB0YWdzXG4gICAgb3IgdGV4dHVhbCBuZXdsaW5lcyksIHRoaXMgbXVzdCBpbmRpY2F0ZSB0aGUgYW1vdW50IG9mIGxpbmVcbiAgICBicmVha3MgdGhleSBpbnRyb2R1Y2UuIERlZmF1bHRzIHRvIDAuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrcygpIHsgcmV0dXJuIDA7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG4gICAgLyoqXG4gICAgT3ZlcnJpZGUgdGhlIHdheSBzY3JlZW4gY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9ucyBhdC9pbiB0aGVcbiAgICB3aWRnZXQgYXJlIGZvdW5kLiBgcG9zYCB3aWxsIGJlIHRoZSBvZmZzZXQgaW50byB0aGUgd2lkZ2V0LCBhbmRcbiAgICBgc2lkZWAgdGhlIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgcXVlcmllZOKAlGxlc3MgdGhhblxuICAgIHplcm8gZm9yIGJlZm9yZSwgZ3JlYXRlciB0aGFuIHplcm8gZm9yIGFmdGVyLCBhbmQgemVybyBmb3JcbiAgICBkaXJlY3RseSBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICovXG4gICAgY29vcmRzQXQoZG9tLCBwb3MsIHNpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IE1hdGgubWF4KC0xMDAwMCwgTWF0aC5taW4oMTAwMDAsIHNwZWMuc2lkZSB8fCAwKSksIGJsb2NrID0gISFzcGVjLmJsb2NrO1xuICAgICAgICBzaWRlICs9IChibG9jayAmJiAhc3BlYy5pbmxpbmVPcmRlcilcbiAgICAgICAgICAgID8gKHNpZGUgPiAwID8gMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tBZnRlciAqLyA6IC00MDAwMDAwMDAgLyogU2lkZS5CbG9ja0JlZm9yZSAqLylcbiAgICAgICAgICAgIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBSYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IHNwZWMuY2xhc3MgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBNYXJrRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xhc3MgfHwgKChfYSA9IHRoaXMuYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzcykpID09IChvdGhlci5jbGFzcyB8fCAoKF9iID0gb3RoZXIuYXR0cnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzcykpICYmXG4gICAgICAgICAgICAgICAgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycywgXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXJrIGRlY29yYXRpb25zIG1heSBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTWFya0RlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5jbGFzcyBMaW5lRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCBudWxsLCBzcGVjKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZURlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMuc3BlYy5jbGFzcyA9PSBvdGhlci5zcGVjLmNsYXNzICYmXG4gICAgICAgICAgICBhdHRyc0VxKHRoaXMuc3BlYy5hdHRyaWJ1dGVzLCBvdGhlci5zcGVjLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmUgZGVjb3JhdGlvbiByYW5nZXMgbXVzdCBiZSB6ZXJvLWxlbmd0aFwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuY2xhc3MgUG9pbnREZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgd2lkZ2V0LCBpc1JlcGxhY2UpIHtcbiAgICAgICAgc3VwZXIoc3RhcnRTaWRlLCBlbmRTaWRlLCB3aWRnZXQsIHNwZWMpO1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIHRoaXMuaXNSZXBsYWNlID0gaXNSZXBsYWNlO1xuICAgICAgICB0aGlzLm1hcE1vZGUgPSAhYmxvY2sgPyBNYXBNb2RlLlRyYWNrRGVsIDogc3RhcnRTaWRlIDw9IDAgPyBNYXBNb2RlLlRyYWNrQmVmb3JlIDogTWFwTW9kZS5UcmFja0FmdGVyO1xuICAgIH1cbiAgICAvLyBPbmx5IHJlbGV2YW50IHdoZW4gdGhpcy5ibG9jayA9PSB0cnVlXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2lkZSAhPSB0aGlzLmVuZFNpZGUgPyBCbG9ja1R5cGUuV2lkZ2V0UmFuZ2VcbiAgICAgICAgICAgIDogdGhpcy5zdGFydFNpZGUgPD0gMCA/IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgOiBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XG4gICAgfVxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgfHwgISF0aGlzLndpZGdldCAmJiAodGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDUgfHwgdGhpcy53aWRnZXQubGluZUJyZWFrcyA+IDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcGxhY2UgJiYgdG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrID0gZmFsc2UpIHtcbiAgICBsZXQgeyBpbmNsdXNpdmVTdGFydDogc3RhcnQsIGluY2x1c2l2ZUVuZDogZW5kIH0gPSBzcGVjO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICBzdGFydCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGJsb2NrLCBlbmQ6IGVuZCAhPT0gbnVsbCAmJiBlbmQgIT09IHZvaWQgMCA/IGVuZCA6IGJsb2NrIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+PSBmcm9tKVxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4uc2xpY2UoKSA6IFtdLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKGF0KTtcbiAgICAgICAgaWYgKG9mZikge1xuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNwbGl0KG9mZiksIDApO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5tZXJnZShvZmYsIHRoaXMuY2hpbGRyZW5baV0ubGVuZ3RoLCBudWxsLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2pdLCAwKTtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIHRoaXMuY2hpbGRyZW5baSAtIDFdLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblstLWldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICB0cmFuc2ZlckRPTShvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBvdGhlci5zZXRET00odGhpcy5kb20pO1xuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgIH1cbiAgICBzZXREZWNvKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnNFcSh0aGlzLmF0dHJzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZChjaGlsZCwgb3BlblN0YXJ0KSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKHRoaXMsIGNoaWxkLCBvcGVuU3RhcnQpO1xuICAgIH1cbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGJ1aWxkaW5nIGEgbGluZSB2aWV3IGluIENvbnRlbnRCdWlsZGVyXG4gICAgYWRkTGluZURlY28oZGVjbykge1xuICAgICAgICBsZXQgYXR0cnMgPSBkZWNvLnNwZWMuYXR0cmlidXRlcywgY2xzID0gZGVjby5zcGVjLmNsYXNzO1xuICAgICAgICBpZiAoYXR0cnMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKGF0dHJzLCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoeyBjbGFzczogY2xzIH0sIHRoaXMuYXR0cnMgfHwge30pO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovKSB7XG4gICAgICAgICAgICBjbGVhckF0dHJpYnV0ZXModGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZBdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5wcmV2QXR0cnMsIHRoaXMuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxpbmVcIik7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChsYXN0ICYmIENvbnRlbnRWaWV3LmdldChsYXN0KSBpbnN0YW5jZW9mIE1hcmtWaWV3KVxuICAgICAgICAgICAgbGFzdCA9IGxhc3QubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgIXRoaXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBsYXN0Lm5vZGVOYW1lICE9IFwiQlJcIiAmJiAoKF9hID0gQ29udGVudFZpZXcuZ2V0KGxhc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAoIWJyb3dzZXIuaW9zIHx8ICF0aGlzLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUZXh0VmlldykpKSB7XG4gICAgICAgICAgICBsZXQgaGFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCUlwiKTtcbiAgICAgICAgICAgIGhhY2suY21JZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCB0aGlzLmxlbmd0aCA+IDIwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gMCwgdGV4dEhlaWdodDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgL1teIC1+XS8udGVzdChjaGlsZC50ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkLmRvbSk7XG4gICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJlY3RzWzBdLndpZHRoO1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3RzWzBdLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRvdGFsV2lkdGggPyBudWxsIDoge1xuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgICAgICAgY2hhcldpZHRoOiB0b3RhbFdpZHRoIC8gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgcmVjdCA9IGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICAgICAgLy8gQ29ycmVjdCByZWN0YW5nbGUgaGVpZ2h0IGZvciBlbXB0eSBsaW5lcyB3aGVuIHRoZSByZXR1cm5lZFxuICAgICAgICAvLyBoZWlnaHQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRleHQgaGVpZ2h0LlxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHJlY3QgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlaWdodE9yYWNsZSB9ID0gdGhpcy5wYXJlbnQudmlldy52aWV3U3RhdGUsIGhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQpIDwgMiAmJiBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gKGhlaWdodCAtIGhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiByZWN0LnRvcCArIGRpc3QsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkaXN0LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVWaWV3ICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiYgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmIHRoaXMuYnJlYWtBZnRlciA9PSBvdGhlci5icmVha0FmdGVyO1xuICAgIH1cbiAgICBjb3ZlcnMoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgc3RhdGljIGZpbmQoZG9jVmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgZG9jVmlldy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gZG9jVmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgYmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCbG9ja1dpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIGRlY28pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfdGFrZURlY28sIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMubGVuZ3RoIC0gYXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgQmxvY2tXaWRnZXRWaWV3KHRoaXMud2lkZ2V0LCBsZW4sIHRoaXMuZGVjbyk7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub0NoaWxkcmVuOyB9XG4gICAgc3luYyh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMud2lkZ2V0LnVwZGF0ZURPTSh0aGlzLmRvbSwgdmlldykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKHZpZXcpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWRnZXQuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnZpZXcuc3RhdGUuZG9jLnNsaWNlKHRoaXMucG9zQXRTdGFydCwgdGhpcy5wb3NBdEVuZCkgOiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJlxuICAgICAgICAgICAgb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yID09IHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIW90aGVyLndpZGdldC5jb21wYXJlKHRoaXMud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVjbyA9IG90aGVyLmRlY287XG4gICAgICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSBvdGhlci5icmVha0FmdGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHRoaXMud2lkZ2V0LmNvb3Jkc0F0KHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLmxlbmd0aCA/IHBvcyA9PSAwIDogc2lkZSA8PSAwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG4gICAgY292ZXJzKHNpZGUpIHtcbiAgICAgICAgbGV0IHsgc3RhcnRTaWRlLCBlbmRTaWRlIH0gPSB0aGlzLmRlY287XG4gICAgICAgIHJldHVybiBzdGFydFNpZGUgPT0gZW5kU2lkZSA/IGZhbHNlIDogc2lkZSA8IDAgPyBzdGFydFNpZGUgPCAwIDogZW5kU2lkZSA+IDA7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tZ2FwXCI7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNsYXNzIENvbnRlbnRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MsIHBvcywgZW5kLCBkaXNhbGxvd0Jsb2NrRWZmZWN0c0Zvcikge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yID0gZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gW107XG4gICAgICAgIC8vIFNldCB0byBmYWxzZSBkaXJlY3RseSBhZnRlciBhIHdpZGdldCB0aGF0IGNvdmVycyB0aGUgcG9zaXRpb24gYWZ0ZXIgaXRcbiAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IC0xO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgICAgIHRoaXMuc2tpcCA9IHBvcztcbiAgICB9XG4gICAgcG9zQ292ZXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5icmVha0F0U3RhcnQgJiYgdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tICE9IHRoaXMucG9zO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiAhKGxhc3QuYnJlYWtBZnRlciB8fCBsYXN0IGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGxhc3QuZGVjby5lbmRTaWRlIDwgMCk7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh0aGlzLmN1ckxpbmUgPSBuZXcgTGluZVZpZXcpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyTGluZTtcbiAgICB9XG4gICAgZmx1c2hCdWZmZXIoYWN0aXZlID0gdGhpcy5idWZmZXJNYXJrcykge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygtMSksIGFjdGl2ZSksIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQmxvY2tXaWRnZXQodmlldykge1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyICYmIG9wZW5FbmQgPD0gdGhpcy5idWZmZXJNYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpICYmXG4gICAgICAgICAgICAhKG9wZW5FbmQgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCAmJiB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3KSlcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgIH1cbiAgICBidWlsZFRleHQobGVuZ3RoLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUuc2xpY2UoYWN0aXZlLmxlbmd0aCAtIG9wZW5TdGFydCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKHdyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gdGFrZTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0YWtlO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmJ1aWxkVGV4dCh0byAtIGZyb20sIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yW2luZGV4XSAmJiBkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgaWYgKHRvID4gdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS50bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlY29yYXRpb25zIHRoYXQgcmVwbGFjZSBsaW5lIGJyZWFrcyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjby5zdGFydFNpZGUgPiAwICYmICF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9ja1dpZGdldChuZXcgQmxvY2tXaWRnZXRWaWV3KGRlY28ud2lkZ2V0IHx8IE51bGxXaWRnZXQuYmxvY2ssIGxlbiwgZGVjbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBOdWxsV2lkZ2V0LmlubGluZSwgbGVuLCBsZW4gPyAwIDogZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlICYmICF2aWV3LmlzRWRpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBCdWYuTm8gKi8gOiBmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCA/IDEgLyogQnVmLlllcyAqLyA6IDIgLyogQnVmLklmQ3Vyc29yICovO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8sIGR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuTnVsbFdpZGdldC5pbmxpbmUgPSAvKkBfX1BVUkVfXyovbmV3IE51bGxXaWRnZXQoXCJzcGFuXCIpO1xuTnVsbFdpZGdldC5ibG9jayA9IC8qQF9fUFVSRV9fKi9uZXcgTnVsbFdpZGdldChcImRpdlwiKTtcblxuLyoqXG5Vc2VkIHRvIGluZGljYXRlIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4qL1xudmFyIERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIC8vIChUaGVzZSBhcmUgY2hvc2VuIHRvIG1hdGNoIHRoZSBiYXNlIGxldmVscywgaW4gYmlkaSBhbGdvcml0aG1cbiAgICAvLyB0ZXJtcywgb2Ygc3BhbnMgaW4gdGhhdCBkaXJlY3Rpb24uKVxuICAgIC8qKlxuICAgIExlZnQtdG8tcmlnaHQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgIFJpZ2h0LXRvLWxlZnQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xucmV0dXJuIERpcmVjdGlvbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IExUUiA9IERpcmVjdGlvbi5MVFIsIFJUTCA9IERpcmVjdGlvbi5SVEw7XG4vLyBEZWNvZGUgYSBzdHJpbmcgd2l0aCBlYWNoIHR5cGUgZW5jb2RlZCBhcyBsb2cyKHR5cGUpXG5mdW5jdGlvbiBkZWMoc3RyKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaCgxIDw8ICtzdHJbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGY4XG5jb25zdCBMb3dUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODY2Njg4ODg4ODc4NzgzMzMzMzMzMzMzNzg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4Nzg2NjY2ODg4ODA4ODg4ODY2MzM4MDg4ODMwODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOFwiKTtcbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuY29uc3QgQXJhYmljVHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCksIEJyYWNrZXRTdGFjayA9IFtdO1xuLy8gVGhlcmUncyBhIGxvdCBtb3JlIGluXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvQmlkaUJyYWNrZXRzLnR4dCxcbi8vIHdoaWNoIGFyZSBsZWZ0IG91dCB0byBrZWVwIGNvZGUgc2l6ZSBkb3duLlxuZm9yIChsZXQgcCBvZiBbXCIoKVwiLCBcIltdXCIsIFwie31cIl0pIHtcbiAgICBsZXQgbCA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMCksIHIgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBULlIgKi8gOlxuICAgICAgICAgICAgMHg2MDAgPD0gY2ggJiYgY2ggPD0gMHg2ZjkgPyBBcmFiaWNUeXBlc1tjaCAtIDB4NjAwXSA6XG4gICAgICAgICAgICAgICAgMHg2ZWUgPD0gY2ggJiYgY2ggPD0gMHg4YWMgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAweDIwMDAgPD0gY2ggJiYgY2ggPD0gMHgyMDBjID8gMjU2IC8qIFQuTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgMHhmYjUwIDw9IGNoICYmIGNoIDw9IDB4ZmRmZiA/IDQgLyogVC5BTCAqLyA6IDEgLyogVC5MICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICAqL1xuICAgIGdldCBkaXIoKSB7IHJldHVybiB0aGlzLmxldmVsICUgMiA/IFJUTCA6IExUUjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChyZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgW1wiYmlkaVxuICAgIGxldmVsXCJdKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0Jhc2ljX0Rpc3BsYXlfQWxnb3JpdGhtKVxuICAgIG9mIHRoZSBzcGFuIChpbiB0aGlzIGNvbnRleHQsIDAgbWVhbnNcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxuICAgIG51bWJlciBpbnNpZGUgcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiAgICAqL1xuICAgIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcndhcmQoZm9yd2FyZCwgZGlyKSB7IHJldHVybiBmb3J3YXJkID09ICh0aGlzLmRpciA9PSBkaXIpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xuICAgICAgICBsZXQgbWF5YmUgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gaW5kZXggJiYgc3Bhbi50byA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuLmxldmVsID09IGxldmVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG11bHRpcGxlIHNwYW5zIG1hdGNoLCBpZiBhc3NvYyAhPSAwLCB0YWtlIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGNvdmVycyB0aGF0IHNpZGUsIG90aGVyd2lzZSB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChtYXliZSA8IDAgfHwgKGFzc29jICE9IDAgPyAoYXNzb2MgPCAwID8gc3Bhbi5mcm9tIDwgaW5kZXggOiBzcGFuLnRvID4gaW5kZXgpIDogb3JkZXJbbWF5YmVdLmxldmVsID4gc3Bhbi5sZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgIG1heWJlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc29sYXRlc0VxKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlBID0gYVtpXSwgaUIgPSBiW2ldO1xuICAgICAgICBpZiAoaUEuZnJvbSAhPSBpQi5mcm9tIHx8IGlBLnRvICE9IGlCLnRvIHx8IGlBLmRpcmVjdGlvbiAhPSBpQi5kaXJlY3Rpb24gfHwgIWlzb2xhdGVzRXEoaUEuaW5uZXIsIGlCLmlubmVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZXVzZWQgYXJyYXkgb2YgY2hhcmFjdGVyIHR5cGVzXG5jb25zdCB0eXBlcyA9IFtdO1xuLy8gRmlsbCBpbiB0aGUgY2hhcmFjdGVyIHR5cGVzIChpbiBgdHlwZXNgKSBmcm9tIGBmcm9tYCB0byBgdG9gIGFuZFxuLy8gYXBwbHkgVyBub3JtYWxpemF0aW9uIHJ1bGVzLlxuZnVuY3Rpb24gY29tcHV0ZUNoYXJUeXBlcyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICBsZXQgcHJldlR5cGUgPSBpSSA/IDI1NiAvKiBULk5JICovIDogb3V0ZXJUeXBlO1xuICAgICAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgICAgLy8gbnVtYmVyLlxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgcHJldiA9IHByZXZUeXBlLCBwcmV2U3Ryb25nID0gcHJldlR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZSA9PSA0IC8qIFQuQUwgKi8gPyAyIC8qIFQuUiAqLyA6IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgICAgICAvLyBOZXV0cmFsLlxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDEyOCAvKiBULkNTICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0byAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBULkVUICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbmQgPCB0byAmJiB0eXBlc1tlbmRdID09IDY0IC8qIFQuRVQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gKGkgJiYgcHJldiA9PSA4IC8qIFQuRU4gKi8pIHx8IChlbmQgPCByVG8gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIFQuRU4gKi8pID8gKHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8gPyAxIC8qIFQuTCAqLyA6IDggLyogVC5FTiAqLykgOiAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gUHJvY2VzcyBicmFja2V0cyB0aHJvdWdob3V0IGEgcnVuIHNlcXVlbmNlLlxuZnVuY3Rpb24gcHJvY2Vzc0JyYWNrZXRQYWlycyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgbGV0IG9wcG9zaXRlVHlwZSA9IG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgZm9yIChsZXQgaUkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgICAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIGNoLCBiciwgdHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICAgICAgaWYgKGJyID0gQnJhY2tldHNbY2ggPSBsaW5lLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcmFja2V0U3RhY2tbc0ogKyAxXSA9PSAtYnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKSA/IG91dGVyVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlc1tCcmFja2V0U3RhY2tbc0pdXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCcmFja2V0U3RhY2subGVuZ3RoID09IDE4OSAvKiBCcmFja2V0ZWQuTWF4RGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9IHR5cGVzW2ldKSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGVtYmVkID8gMCA6IDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXV0cmFscyhyRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlzb2xhdGVzW2lJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW2VuZF0gPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSBwcmV2ID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckwgPSAoZW5kIDwgclRvID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGVuZCwgakkgPSBpSSwgZnJvbUogPSBqSSA/IGlzb2xhdGVzW2pJIC0gMV0udG8gOiByRnJvbTsgaiA+IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGZyb21KKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbLS1qXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGaW5kIHRoZSBjb250aWd1b3VzIHJhbmdlcyBvZiBjaGFyYWN0ZXIgdHlwZXMgaW4gYSBnaXZlbiByYW5nZSwgYW5kXG4vLyBlbWl0IHNwYW5zIGZvciB0aGVtLiBGbGlwIHRoZSBvcmRlciBvZiB0aGUgc3BhbnMgYXMgYXBwcm9wcmlhdGVcbi8vIGJhc2VkIG9uIHRoZSBsZXZlbCwgYW5kIGNhbGwgdGhyb3VnaCB0byBjb21wdXRlIHRoZSBzcGFucyBmb3Jcbi8vIGlzb2xhdGVzIGF0IHRoZSBwcm9wZXIgcG9pbnQuXG5mdW5jdGlvbiBlbWl0U3BhbnMobGluZSwgZnJvbSwgdG8sIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBvcmRlcikge1xuICAgIGxldCBvdXJUeXBlID0gbGV2ZWwgJSAyID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoKGxldmVsICUgMikgPT0gKGJhc2VMZXZlbCAlIDIpKSB7IC8vIFNhbWUgZGlyIGFzIGJhc2UgZGlyZWN0aW9uLCBkb24ndCBmbGlwXG4gICAgICAgIGZvciAobGV0IGlDaCA9IGZyb20sIGlJID0gMDsgaUNoIDwgdG87KSB7XG4gICAgICAgICAgICAvLyBTY2FuIGEgc2VjdGlvbiBvZiBjaGFyYWN0ZXJzIGluIGRpcmVjdGlvbiBvdXJUeXBlLCB1bmxlc3NcbiAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW5vdGhlciB0eXBlIG9mIGNoYXIgcmlnaHQgYWZ0ZXIgaUNoLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBzY2FuIGEgc2VjdGlvbiBvZiBvdGhlciBjaGFyYWN0ZXJzICh3aGljaCwgaWYgb3VyVHlwZSA9PVxuICAgICAgICAgICAgLy8gVC5MLCBtYXkgY29udGFpbiBib3RoIFQuUiBhbmQgVC5BTiBjaGFycykuXG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaUkgPT0gaXNvbGF0ZXMubGVuZ3RoIHx8IGlDaCA8IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2hdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb2xkcyBhbiBhcnJheSBvZiBpc29sYXRlcyB0byBwYXNzIHRvIGEgcmVjdXJzaXZlIGNhbGwgaWYgd2VcbiAgICAgICAgICAgIC8vIG11c3QgcmVjdXJzZSAodG8gZGlzdGluZ3Vpc2ggVC5BTiBpbnNpZGUgYW4gUlRMIHNlY3Rpb24gaW5cbiAgICAgICAgICAgIC8vIExUUiB0ZXh0KSwgbnVsbCBpZiB3ZSBjYW4gZW1pdCBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgPCBpc29sYXRlcy5sZW5ndGggJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUldLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNvID0gaXNvbGF0ZXNbaUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLnRvLCBqSSA9IGlJICsgMTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwdG8gPT0gdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgPCBpc29sYXRlcy5sZW5ndGggJiYgaXNvbGF0ZXNbakldLmZyb20gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzW2pJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW3VwdG9dID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpSSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLmZyb20gPiBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpc28uZnJvbSwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpclN3YXAgPSAoaXNvLmRpcmVjdGlvbiA9PSBMVFIpICE9ICEobG9jYWxMZXZlbCAlIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBkaXJTd2FwID8gbGV2ZWwgKyAxIDogbGV2ZWwsIGJhc2VMZXZlbCwgaXNvLmlubmVyLCBpc28uZnJvbSwgaXNvLnRvLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ2ggPSBpc28udG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28udG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IHRvIHx8IChzYW1lRGlyID8gdHlwZXNbaVNjYW5dICE9IG91clR5cGUgOiB0eXBlc1tpU2Nhbl0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2NhbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpQ2gsIGlTY2FuLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaUNoIDwgaVNjYW4pXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpU2NhbiwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSB0byBmbGlwIHRoZSBzcGFuIG9yZGVyLiBTYW1lIGNvZGUgYWdhaW4sIGJ1dFxuICAgICAgICAvLyBnb2luZyBmcm9tIHRoZSBiYWNrIG9mIHRoZSBzZWN0aW9uIHRvIHRoZSBmcm9udFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSB0bywgaUkgPSBpc29sYXRlcy5sZW5ndGg7IGlDaCA+IGZyb207KSB7XG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlJIHx8IGlDaCA+IGlzb2xhdGVzW2lJIC0gMV0udG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHR5cGVzW2lDaCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVjdXJzZSA9ICFzYW1lRGlyICYmIG91clR5cGUgPT0gMSAvKiBULkwgKi8gPyBbXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbCA9IHNhbWVEaXIgPyBsZXZlbCA6IGxldmVsICsgMTtcbiAgICAgICAgICAgIGxldCBpU2NhbiA9IGlDaDtcbiAgICAgICAgICAgIHJ1bjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChpSSAmJiBpU2NhbiA9PSBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzWy0taUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLmZyb20sIGpJID0gaUk7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgJiYgaXNvbGF0ZXNbakkgLSAxXS50byA9PSB1cHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHRvID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvIC0gMV0gPT0gb3VyVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlLnB1c2goaXNvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc28udG8gPCBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaXNvLnRvLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28uZnJvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPT0gZnJvbSB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuIC0gMV0gIT0gb3VyVHlwZSA6IHR5cGVzW2lTY2FuIC0gMV0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2Nhbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpU2NhbiwgaUNoLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPCBpQ2gpXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaVNjYW4sIGlDaCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBmcm9tLCB0bywgb3JkZXIpIHtcbiAgICBsZXQgb3V0ZXJUeXBlID0gKGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi8pO1xuICAgIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NOZXV0cmFscyhmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbiwgaXNvbGF0ZXMpIHtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIDAsIGRpcmVjdGlvbiA9PSBSVEwgPyAxIDogMCldO1xuICAgIGlmIChkaXJlY3Rpb24gPT0gTFRSICYmICFpc29sYXRlcy5sZW5ndGggJiYgIUJpZGlSRS50ZXN0KGxpbmUpKVxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICBpZiAoaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiB0eXBlcy5sZW5ndGgpXG4gICAgICAgICAgICB0eXBlc1t0eXBlcy5sZW5ndGhdID0gMjU2IC8qIFQuTkkgKi87IC8vIE1ha2Ugc3VyZSB0eXBlcyBhcnJheSBoYXMgbm8gZ2Fwc1xuICAgIGxldCBvcmRlciA9IFtdLCBsZXZlbCA9IGRpcmVjdGlvbiA9PSBMVFIgPyAwIDogMTtcbiAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBsZXZlbCwgaXNvbGF0ZXMsIDAsIGxpbmUubGVuZ3RoLCBvcmRlcik7XG4gICAgcmV0dXJuIG9yZGVyO1xufVxuZnVuY3Rpb24gdHJpdmlhbE9yZGVyKGxlbmd0aCkge1xuICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIGxlbmd0aCwgMCldO1xufVxubGV0IG1vdmVkT3ZlciA9IFwiXCI7XG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG1vdmVzIHN0cmljdGx5IHZpc3VhbGx5LCB3aXRob3V0IGNvbmNlcm4gZm9yIGFcbi8vIHRyYXZlcnNhbCB2aXNpdGluZyBldmVyeSBsb2dpY2FsIHBvc2l0aW9uIGluIHRoZSBzdHJpbmcuIEl0IHdpbGxcbi8vIHN0aWxsIGRvIHNvIGZvciBzaW1wbGUgaW5wdXQsIGJ1dCBzaXR1YXRpb25zIGxpa2UgbXVsdGlwbGUgaXNvbGF0ZXNcbi8vIHdpdGggdGhlIHNhbWUgbGV2ZWwgbmV4dCB0byBlYWNoIG90aGVyLCBvciB0ZXh0IGdvaW5nIGFnYWluc3QgdGhlXG4vLyBtYWluIGRpciBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLCB3aWxsIG1ha2Ugc29tZSBwb3NpdGlvbnNcbi8vIHVucmVhY2hhYmxlIHdpdGggdGhpcyBtb3Rpb24uIEVhY2ggdmlzaWJsZSBjdXJzb3IgcG9zaXRpb24gd2lsbFxuLy8gY29ycmVzcG9uZCB0byB0aGUgbG93ZXItbGV2ZWwgYmlkaSBzcGFuIHRoYXQgdG91Y2hlcyBpdC5cbi8vXG4vLyBUaGUgYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gc29sdmUgYW4gb3JkZXIgZ2xvYmFsbHkgZm9yIGEgZ2l2ZW5cbi8vIGxpbmUsIG1ha2luZyBzdXJlIHRoYXQgaXQgaW5jbHVkZXMgZXZlcnkgcG9zaXRpb24sIGJ1dCB0aGF0IHdvdWxkXG4vLyByZXF1aXJlIGFzc29jaWF0aW5nIG5vbi1jYW5vbmljYWwgKGhpZ2hlciBiaWRpIHNwYW4gbGV2ZWwpXG4vLyBwb3NpdGlvbnMgd2l0aCBhIGdpdmVuIHZpc3VhbCBwb3NpdGlvbiwgd2hpY2ggaXMgbGlrZWx5IHRvIGNvbmZ1c2Vcbi8vIHBlb3BsZS4gKEFuZCB3b3VsZCBnZW5lcmFsbHkgYmUgYSBsb3QgbW9yZSBjb21wbGljYXRlZC4pXG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgb3JkZXIsIGRpciwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5oZWFkIC0gbGluZS5mcm9tO1xuICAgIGxldCBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXSwgc3BhbkVuZCA9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpO1xuICAgIC8vIEVuZCBvZiBzcGFuXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3BhbkVuZCkge1xuICAgICAgICBsZXQgbmV4dEkgPSBzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBpZiAobmV4dEkgPCAwIHx8IG5leHRJID49IG9yZGVyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgPSBuZXh0SV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgICAgIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICB9XG4gICAgbGV0IG5leHRJbmRleCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBzdGFydEluZGV4LCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSk7XG4gICAgaWYgKG5leHRJbmRleCA8IHNwYW4uZnJvbSB8fCBuZXh0SW5kZXggPiBzcGFuLnRvKVxuICAgICAgICBuZXh0SW5kZXggPSBzcGFuRW5kO1xuICAgIG1vdmVkT3ZlciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihzdGFydEluZGV4LCBuZXh0SW5kZXgpLCBNYXRoLm1heChzdGFydEluZGV4LCBuZXh0SW5kZXgpKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRJbmRleCA9PSBzcGFuRW5kICYmIG5leHRTcGFuLmxldmVsICsgKGZvcndhcmQgPyAwIDogMSkgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBuZXh0U3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikgPyAxIDogLTEsIG5leHRTcGFuLmxldmVsKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0SW5kZXggKyBsaW5lLmZyb20sIHNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cbmZ1bmN0aW9uIGF1dG9EaXJlY3Rpb24odGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZSh0ZXh0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBpZiAodHlwZSA9PSAxIC8qIFQuTCAqLylcbiAgICAgICAgICAgIHJldHVybiBMVFI7XG4gICAgICAgIGlmICh0eXBlID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gNCAvKiBULkFMICovKVxuICAgICAgICAgICAgcmV0dXJuIFJUTDtcbiAgICB9XG4gICAgcmV0dXJuIExUUjtcbn1cblxuY29uc3QgY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkcmFnTW92ZXNTZWxlY3Rpb24kMSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG1vdXNlU2VsZWN0aW9uU3R5bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBleGNlcHRpb25TaW5rID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdXBkYXRlTGlzdGVuZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmb2N1c0NoYW5nZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNsaXBib2FyZElucHV0RmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgY2xpcGJvYXJkT3V0cHV0RmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBzY3JvbGxIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgU2Nyb2xsVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgeSA9IFwibmVhcmVzdFwiLCB4ID0gXCJuZWFyZXN0XCIsIHlNYXJnaW4gPSA1LCB4TWFyZ2luID0gNSwgXG4gICAgLy8gVGhpcyBkYXRhIHN0cnVjdHVyZSBpcyBhYnVzZWQgdG8gYWxzbyBzdG9yZSBwcmVjaXNlIHNjcm9sbFxuICAgIC8vIHNuYXBzaG90cywgaW5zdGVhZCBvZiBhIGBzY3JvbGxJbnRvVmlld2AgcmVxdWVzdC4gV2hlbiB0aGlzXG4gICAgLy8gZmxhZyBpcyBgdHJ1ZWAsIGByYW5nZWAgcG9pbnRzIGF0IGEgcG9zaXRpb24gaW4gdGhlIHJlZmVyZW5jZVxuICAgIC8vIGxpbmUsIGB5TWFyZ2luYCBob2xkcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhhdFxuICAgIC8vIGxpbmUgYW5kIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgYW5kIGB4TWFyZ2luYCBob2xkcyB0aGVcbiAgICAvLyBlZGl0b3IncyBgc2Nyb2xsTGVmdGAuXG4gICAgaXNTbmFwc2hvdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICAgICAgdGhpcy5pc1NuYXBzaG90ID0gaXNTbmFwc2hvdDtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDpcbiAgICAgICAgICAgIG5ldyBTY3JvbGxUYXJnZXQodGhpcy5yYW5nZS5tYXAoY2hhbmdlcyksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG4gICAgY2xpcChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZS50byA8PSBzdGF0ZS5kb2MubGVuZ3RoID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhdGUuZG9jLmxlbmd0aCksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xuY29uc3Qgc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5Mb2cgb3IgcmVwb3J0IGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaW4gY2xpZW50IGNvZGUuIFNob3VsZFxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXG5wcm92aWRlIGZ1bmN0aW9ucywgYW5kIGNhbGxzIHRob3NlIGZ1bmN0aW9ucyBpbiBhIGNvbnRleHQgd2hlcmUgYW5cbmV4Y2VwdGlvbiBjYW4ndCBiZSBwcm9wYWdhdGVkIHRvIGNhbGxpbmcgY29kZSBpbiBhIHJlYXNvbmFibGUgd2F5XG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cblxuRWl0aGVyIGNhbGxzIGEgaGFuZGxlciByZWdpc3RlcmVkIHdpdGhcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXG5gd2luZG93Lm9uZXJyb3JgLCBpZiBkZWZpbmVkLCBvciBgY29uc29sZS5lcnJvcmAgKGluIHdoaWNoIGNhc2Vcbml0J2xsIHBhc3MgYGNvbnRleHRgLCB3aGVuIGdpdmVuLCBhcyBmaXJzdCBhcmd1bWVudCkuXG4qL1xuZnVuY3Rpb24gbG9nRXhjZXB0aW9uKHN0YXRlLCBleGNlcHRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgaGFuZGxlciA9IHN0YXRlLmZhY2V0KGV4Y2VwdGlvblNpbmspO1xuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcbiAgICAgICAgaGFuZGxlclswXShleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKVxuICAgICAgICB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAoY29udGV4dClcbiAgICAgICAgY29uc29sZS5lcnJvcihjb250ZXh0ICsgXCI6XCIsIGV4Y2VwdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBjb25zb2xlLmVycm9yKGV4Y2VwdGlvbik7XG59XG5jb25zdCBlZGl0YWJsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblZpZXcgcGx1Z2lucyBhc3NvY2lhdGUgc3RhdGVmdWwgdmFsdWVzIHdpdGggYSB2aWV3LiBUaGV5IGNhblxuaW5mbHVlbmNlIHRoZSB3YXkgdGhlIGNvbnRlbnQgaXMgZHJhd24sIGFuZCBhcmUgbm90aWZpZWQgb2YgdGhpbmdzXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy5cbiovXG5jbGFzcyBWaWV3UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudEhhbmRsZXJzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50T2JzZXJ2ZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5kb21FdmVudE9ic2VydmVycyA9IGRvbUV2ZW50T2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IGJ1aWxkRXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgcGx1Z2luIGZyb20gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlXG4gICAgcGx1Z2luJ3MgdmFsdWUsIGdpdmVuIGFuIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjcmVhdGUsIHNwZWMpIHtcbiAgICAgICAgY29uc3QgeyBldmVudEhhbmRsZXJzLCBldmVudE9ic2VydmVycywgcHJvdmlkZSwgZGVjb3JhdGlvbnM6IGRlY28gfSA9IHNwZWMgfHwge307XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBldmVudEhhbmRsZXJzLCBldmVudE9ic2VydmVycywgcGx1Z2luID0+IHtcbiAgICAgICAgICAgIGxldCBleHQgPSBbdmlld1BsdWdpbi5vZihwbHVnaW4pXTtcbiAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKGRlY29yYXRpb25zLm9mKHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luSW5zdCA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5JbnN0ID8gZGVjbyhwbHVnaW5JbnN0KSA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZSlcbiAgICAgICAgICAgICAgICBleHQucHVzaChwcm92aWRlKHBsdWdpbikpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbiBmb3IgYSBjbGFzcyB3aG9zZSBjb25zdHJ1Y3RvciB0YWtlcyBhIHNpbmdsZVxuICAgIGVkaXRvciB2aWV3IGFzIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21DbGFzcyhjbHMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IGNscyh2aWV3KSwgc3BlYyk7XG4gICAgfVxufVxuY2xhc3MgUGx1Z2luSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLy8gV2hlbiBzdGFydGluZyBhbiB1cGRhdGUsIGFsbCBwbHVnaW5zIGhhdmUgdGhpcyBmaWVsZCBzZXQgdG8gdGhlXG4gICAgICAgIC8vIHVwZGF0ZSBvYmplY3QsIGluZGljYXRpbmcgdGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQuIFdoZW4gZmluaXNoZWRcbiAgICAgICAgLy8gdXBkYXRpbmcsIGl0IGlzIHNldCB0byBgZmFsc2VgLiBSZXRyaWV2aW5nIGEgcGx1Z2luIHRoYXQgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgdXBkYXRlZCB3aXRoIGB2aWV3LnBsdWdpbmAgZm9yY2VzIGFuIGVhZ2VyIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBpcyBudWxsIHdoZW4gdGhlIHBsdWdpbiBpcyBpbml0aWFsbHkgY3JlYXRlZCwgYnV0XG4gICAgICAgIC8vIGluaXRpYWxpemVkIG9uIHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGUodmlldykge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zcGVjLmNyZWF0ZSh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubXVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IHRoaXMubXVzdFVwZGF0ZTtcbiAgICAgICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odXBkYXRlLnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3kodmlldykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnNwZWMgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG59XG5jb25zdCBlZGl0b3JBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgY29udGVudEF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vLyBQcm92aWRlIGRlY29yYXRpb25zXG5jb25zdCBkZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG91dGVyRGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhdG9taWNSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBiaWRpSXNvbGF0ZWRSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5mdW5jdGlvbiBnZXRJc29sYXRlZFJhbmdlcyh2aWV3LCBsaW5lKSB7XG4gICAgbGV0IGlzb2xhdGVzID0gdmlldy5zdGF0ZS5mYWNldChiaWRpSXNvbGF0ZWRSYW5nZXMpO1xuICAgIGlmICghaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gaXNvbGF0ZXM7XG4gICAgbGV0IHNldHMgPSBpc29sYXRlcy5tYXAoaSA9PiBpIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBpKHZpZXcpIDogaSk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIFJhbmdlU2V0LnNwYW5zKHNldHMsIGxpbmUuZnJvbSwgbGluZS50bywge1xuICAgICAgICBwb2ludCgpIHsgfSxcbiAgICAgICAgc3Bhbihmcm9tRG9jLCB0b0RvYywgYWN0aXZlLCBvcGVuKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGZyb21Eb2MgLSBsaW5lLmZyb20sIHRvID0gdG9Eb2MgLSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSByZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tLCBvcGVuLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gYWN0aXZlW2ldLnNwZWMuYmlkaUlzb2xhdGUsIHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IGF1dG9EaXJlY3Rpb24obGluZS50ZXh0LCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW4gPiAwICYmIGxldmVsLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAodXBkYXRlID0gbGV2ZWxbbGV2ZWwubGVuZ3RoIC0gMV0pLnRvID09IGZyb20gJiYgdXBkYXRlLmRpcmVjdGlvbiA9PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnRvID0gdG87XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gdXBkYXRlLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IHsgZnJvbSwgdG8sIGRpcmVjdGlvbiwgaW5uZXI6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgIGxldmVsLnB1c2goYWRkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBhZGQuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHNjcm9sbE1hcmdpbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5mdW5jdGlvbiBnZXRTY3JvbGxNYXJnaW5zKHZpZXcpIHtcbiAgICBsZXQgbGVmdCA9IDAsIHJpZ2h0ID0gMCwgdG9wID0gMCwgYm90dG9tID0gMDtcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygdmlldy5zdGF0ZS5mYWNldChzY3JvbGxNYXJnaW5zKSkge1xuICAgICAgICBsZXQgbSA9IHNvdXJjZSh2aWV3KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGlmIChtLmxlZnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgbS5sZWZ0KTtcbiAgICAgICAgICAgIGlmIChtLnJpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgbS5yaWdodCk7XG4gICAgICAgICAgICBpZiAobS50b3AgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIG0udG9wKTtcbiAgICAgICAgICAgIGlmIChtLmJvdHRvbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgbS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9O1xufVxuY29uc3Qgc3R5bGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBDaGFuZ2VkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpIHtcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xuICAgICAgICB0aGlzLnRvQSA9IHRvQTtcbiAgICAgICAgdGhpcy5mcm9tQiA9IGZyb21CO1xuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcbiAgICB9XG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2V0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50b0EgPCBtZS5mcm9tQSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1lID0gbWUuam9pbihyYW5nZSk7XG4gICAgICAgICAgICBzZXQuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuc3BsaWNlKGksIDAsIG1lKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgc3RhdGljIGV4dGVuZFdpdGhSYW5nZXMoZGlmZiwgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkSSA9IDAsIHJJID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOzsgZEkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBkSSA9PSBkaWZmLmxlbmd0aCA/IG51bGwgOiBkaWZmW2RJXSwgb2ZmID0gcG9zQSAtIHBvc0I7XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbUIgOiAxZTk7XG4gICAgICAgICAgICB3aGlsZSAockkgPCByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1tySV0gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tySV0sIHRvID0gcmFuZ2VzW3JJICsgMV07XG4gICAgICAgICAgICAgICAgbGV0IGZyb21CID0gTWF0aC5tYXgocG9zQiwgZnJvbSksIHRvQiA9IE1hdGgubWluKGVuZCwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQiA8PSB0b0IpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUIgKyBvZmYsIHRvQiArIG9mZiwgZnJvbUIsIHRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgckkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShuZXh0LmZyb21BLCBuZXh0LnRvQSwgbmV4dC5mcm9tQiwgbmV4dC50b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICBwb3NBID0gbmV4dC50b0E7XG4gICAgICAgICAgICBwb3NCID0gbmV4dC50b0I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblZpZXcgW3BsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKSBhcmUgZ2l2ZW4gaW5zdGFuY2VzIG9mIHRoaXNcbmNsYXNzLCB3aGljaCBkZXNjcmliZSB3aGF0IGhhcHBlbmVkLCB3aGVuZXZlciB0aGUgdmlldyBpcyB1cGRhdGVkLlxuKi9cbmNsYXNzIFZpZXdVcGRhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IgdmlldyB0aGF0IHRoZSB1cGRhdGUgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICovXG4gICAgdmlldywgXG4gICAgLyoqXG4gICAgVGhlIG5ldyBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9ucyBpbnZvbHZlZCBpbiB0aGUgdXBkYXRlLiBNYXkgYmUgZW1wdHkuXG4gICAgKi9cbiAgICB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbXBvc2UodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gY2hhbmdlZFJhbmdlcy5wdXNoKG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gY2hhbmdlZFJhbmdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3VXBkYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgW3ZpZXdwb3J0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aWV3cG9ydCkgb3JcbiAgICBbdmlzaWJsZSByYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpc2libGVSYW5nZXMpIGNoYW5nZWQgaW4gdGhpc1xuICAgIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgaGVpZ2h0IG9mIGEgYmxvY2sgZWxlbWVudCBpbiB0aGUgZWRpdG9yXG4gICAgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBoZWlnaHRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCB3YXMgbW9kaWZpZWQgb3IgdGhlIHNpemUgb2YgdGhlXG4gICAgZWRpdG9yLCBvciBlbGVtZW50cyB3aXRoaW4gdGhlIGVkaXRvciwgY2hhbmdlZC5cbiAgICAqL1xuICAgIGdldCBnZW9tZXRyeUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0NoYW5nZWQgfHwgKHRoaXMuZmxhZ3MgJiAoOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBmb2N1c0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBkb2N1bWVudCBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZsYWdzID09IDAgJiYgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoID09IDA7IH1cbn1cblxuY2xhc3MgRG9jVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCA9IFtmYWxzZV07XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uID0gbmV3IFNldDtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIHRoaXMubGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgLy8gVHJhY2sgYSBtaW5pbXVtIHdpZHRoIGZvciB0aGUgZWRpdG9yLiBXaGVuIG1lYXN1cmluZyBzaXplcyBpblxuICAgICAgICAvLyBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzLCB0aGlzIGlzIHVwZGF0ZWQgdG8gcG9pbnQgYXQgdGhlIHdpZHRoXG4gICAgICAgIC8vIG9mIGEgZ2l2ZW4gZWxlbWVudCBhbmQgaXRzIGV4dGVudCBpbiB0aGUgZG9jdW1lbnQuIFdoZW4gYSBjaGFuZ2VcbiAgICAgICAgLy8gaGFwcGVucyBpbiB0aGF0IHJhbmdlLCB0aGVzZSBhcmUgcmVzZXQuIFRoYXQgd2F5LCBvbmNlIHdlJ3ZlIHNlZW5cbiAgICAgICAgLy8gYSBsaW5lL2VsZW1lbnQgb2YgYSBnaXZlbiBsZW5ndGgsIHdlIGtlZXAgdGhlIGVkaXRvciB3aWRlIGVub3VnaFxuICAgICAgICAvLyB0byBmaXQgYXQgbGVhc3QgdGhhdCBlbGVtZW50LCB1bnRpbCBpdCBpcyBjaGFuZ2VkLCBhdCB3aGljaCBwb2ludFxuICAgICAgICAvLyB3ZSBmb3JnZXQgaXQgYWdhaW4uXG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIERPTSBzZWxlY3Rpb24gd2FzIHNldCBpbiBhIGxvc3N5IHdheSwgc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBtZXNzIGl0IHVwIHdoZW4gcmVhZGluZyBpdCBiYWNrIGl0XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIGJ5IHRoZSByZXNpemUgb2JzZXJ2ZXIgdG8gaWdub3JlIHJlc2l6ZXMgdGhhdCB3ZSBjYXVzZWRcbiAgICAgICAgLy8gb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2V0RE9NKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExpbmVWaWV3XTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudCB2aWV3IHRvIGEgZ2l2ZW4gc3RhdGUuXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGlmICh0aGlzLm1pbldpZHRoID4gMCAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VkUmFuZ2VzLmV2ZXJ5KCh7IGZyb21BLCB0b0EgfSkgPT4gdG9BIDwgdGhpcy5taW5XaWR0aEZyb20gfHwgZnJvbUEgPiB0aGlzLm1pbldpZHRoVG8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IHRoaXMubWluV2lkdGhGcm9tID0gdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhGcm9tLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aFRvLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRDb250ZXh0Rm9ybWF0dGluZyh1cGRhdGUpO1xuICAgICAgICBsZXQgcmVhZENvbXBvc2l0aW9uQXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmICF0aGlzLnZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLmRvbUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXdTZWwpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB0aGlzLmRvbUNoYW5nZWQubmV3U2VsLmhlYWQ7XG4gICAgICAgICAgICBlbHNlIGlmICghdG91Y2hlc0NvbXBvc2l0aW9uKHVwZGF0ZS5jaGFuZ2VzLCB0aGlzLmhhc0NvbXBvc2l0aW9uKSAmJiAhdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHJlYWRDb21wb3NpdGlvbkF0ID4gLTEgPyBmaW5kQ29tcG9zaXRpb25SYW5nZSh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzLCByZWFkQ29tcG9zaXRpb25BdCkgOiBudWxsO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5jbGVhcigpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuaGFzQ29tcG9zaXRpb247XG4gICAgICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gbmV3IENoYW5nZWRSYW5nZShmcm9tLCB0bywgdXBkYXRlLmNoYW5nZXMubWFwUG9zKGZyb20sIC0xKSwgdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRvLCAxKSlcbiAgICAgICAgICAgICAgICAuYWRkVG9TZXQoY2hhbmdlZFJhbmdlcy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gPyB7IGZyb206IGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0bzogY29tcG9zaXRpb24ucmFuZ2UudG9CIH0gOiBudWxsO1xuICAgICAgICAvLyBXaGVuIHRoZSBET00gbm9kZXMgYXJvdW5kIHRoZSBzZWxlY3Rpb24gYXJlIG1vdmVkIHRvIGFub3RoZXJcbiAgICAgICAgLy8gcGFyZW50LCBDaHJvbWUgc29tZXRpbWVzIHJlcG9ydHMgYSBkaWZmZXJlbnQgc2VsZWN0aW9uIHRocm91Z2hcbiAgICAgICAgLy8gZ2V0U2VsZWN0aW9uIHRoYW4gdGhlIG9uZSB0aGF0IGl0IGFjdHVhbGx5IHNob3dzIHRvIHRoZSB1c2VyLlxuICAgICAgICAvLyBUaGlzIGZvcmNlcyBhIHNlbGVjdGlvbiB1cGRhdGUgd2hlbiBsaW5lcyBhcmUgam9pbmVkIHRvIHdvcmtcbiAgICAgICAgLy8gYXJvdW5kIHRoYXQuIElzc3VlICM1NFxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgfHwgYnJvd3Nlci5jaHJvbWUpICYmICFjb21wb3NpdGlvbiAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICghKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCBieSB1cGRhdGUgYW5kIHRoZSBjb25zdHJ1Y3RvciBkbyBwZXJmb3JtIHRoZSBhY3R1YWwgRE9NXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlSW5uZXIoY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbik7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBoZWlnaHQgZHVyaW5nIHJlZHJhd2luZywgc2luY2UgQ2hyb21lIHNvbWV0aW1lc1xuICAgICAgICAgICAgLy8gbWVzc2VzIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgRE9NIG11dGF0aW9uICh0aG91Z2hcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aXRob3V0IGEgbGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmZsZXhCYXNpcyA9IHRoaXMubWluV2lkdGggPyB0aGlzLm1pbldpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcywgd2hlbiBET00gbXV0YXRpb25zIG9jY3VyIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBhcm91bmQgdGhlIHNlbGVjdGlvbiwgZ2V0IGNvbmZ1c2VkIGFuZCByZXBvcnQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBmcm9tIHRoZSBvbmUgaXQgZGlzcGxheXMgKGlzc3VlICMyMTgpLiBUaGlzIHRyaWVzXG4gICAgICAgICAgICAvLyB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSBicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmlvcyA/IHsgbm9kZTogb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zeW5jKHRoaXMudmlldywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5mb3JFYWNoKGNWaWV3ID0+IGNWaWV3LmZsYWdzICY9IH44IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgY2hpbGQud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGdhcHMucHVzaChjaGlsZC5kb20pO1xuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBjb21wb3NpdGlvbiA/IGNvbXBvc2l0aW9uLnJhbmdlLmFkZFRvU2V0KGNoYW5nZXMuc2xpY2UoKSkgOiBjaGFuZ2VzO1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jaGlsZEN1cnNvcihvbGRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gcmFuZ2VzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IG5leHQsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CIDwgdG9CICYmIGNvbXBvc2l0aW9uLnJhbmdlLnRvQiA+IGZyb21CKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgY29tcG9zaXRpb24ucmFuZ2UudG9CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IGJlZm9yZS5icmVha0F0U3RhcnQ7XG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYmVmb3JlLm9wZW5TdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gYWZ0ZXIub3BlbkVuZDtcbiAgICAgICAgICAgICAgICBsZXQgY29tcExpbmUgPSB0aGlzLmNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLmJyZWFrQXRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIuY29udGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUubWVyZ2UoY29tcExpbmUubGVuZ3RoLCBjb21wTGluZS5sZW5ndGgsIGFmdGVyLmNvbnRlbnRbMF0sIGZhbHNlLCBhZnRlci5vcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSBhZnRlci5jb250ZW50WzBdLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmNvbnRlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZSgwLCAwLCBiZWZvcmUuY29udGVudFtiZWZvcmUuY29udGVudC5sZW5ndGggLSAxXSwgdHJ1ZSwgMCwgYmVmb3JlLm9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZS5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmNvbnRlbnQuY29uY2F0KGNvbXBMaW5lKS5jb25jYXQoYWZ0ZXIuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID1cbiAgICAgICAgICAgICAgICAgICAgQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyh0b0EsIDEpO1xuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcbiAgICAgICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgICAgIHRoaXMuZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICB1cGRhdGVFZGl0Q29udGV4dEZvcm1hdHRpbmcodXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nID0gdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgY3VyID0gbmV3IFRleHRWaWV3KGNvbXBvc2l0aW9uLnRleHQubm9kZVZhbHVlKTtcbiAgICAgICAgY3VyLmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi87XG4gICAgICAgIGZvciAobGV0IHsgZGVjbyB9IG9mIGNvbXBvc2l0aW9uLm1hcmtzKVxuICAgICAgICAgICAgY3VyID0gbmV3IE1hcmtWaWV3KGRlY28sIFtjdXJdLCBjdXIubGVuZ3RoKTtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGxpbmUuYXBwZW5kKGN1ciwgMCk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBmaXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgZml4ID0gKGRvbSwgY1ZpZXcpID0+IHtcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8gfCAoY1ZpZXcuY2hpbGRyZW4uc29tZShjID0+IGMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSA/IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLyA6IDApO1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5hZGQoY1ZpZXcpO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT0gY1ZpZXcpXG4gICAgICAgICAgICAgICAgcHJldi5kb20gPSBudWxsO1xuICAgICAgICAgICAgY1ZpZXcuc2V0RE9NKGRvbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmNoaWxkUG9zKGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCAxKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgIGZpeChjb21wb3NpdGlvbi5saW5lLCBjVmlldyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb21wb3NpdGlvbi5tYXJrcy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcbiAgICAgICAgICAgIHBvcyA9IGNWaWV3LmNoaWxkUG9zKHBvcy5vZmYsIDEpO1xuICAgICAgICAgICAgY1ZpZXcgPSBjVmlldy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgICAgICBmaXgoaSA+PSAwID8gY29tcG9zaXRpb24ubWFya3NbaV0ubm9kZSA6IGNvbXBvc2l0aW9uLnRleHQsIGNWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG11c3RSZWFkIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYWN0aXZlRWx0ID0gdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCwgZm9jdXNlZCA9IGFjdGl2ZUVsdCA9PSB0aGlzLmRvbTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbk5vdEZvY3VzID0gIWZvY3VzZWQgJiYgISh0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IHRoaXMuZG9tLnRhYkluZGV4ID4gLTEpICYmXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmVFbHQgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlRWx0KSk7XG4gICAgICAgIGlmICghKGZvY3VzZWQgfHwgZnJvbVBvaW50ZXIgfHwgc2VsZWN0aW9uTm90Rm9jdXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgYW5jaG9yID0gdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKSk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmICF0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHwgKCFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgJiYgIXRoaXMuc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UoZG9tU2VsLCBtYWluKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IChuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gdGV4dE5vZGVCZWZvcmUgOiB0ZXh0Tm9kZUFmdGVyKShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dC5ub2RlLCB0ZXh0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYmlkaUxldmVsICE9IG51bGwgJiYgcmF3U2VsLmNhcmV0QmlkaUxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob3RGb2N1cyAmJiB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsdC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSB6ZXJvLWxlbmd0aCB3aWRnZXQgaXMgaW5zZXJ0ZWQgbmV4dCB0byB0aGUgY3Vyc29yIGR1cmluZ1xuICAgIC8vIGNvbXBvc2l0aW9uLCBhdm9pZCBtb3ZpbmcgaXQgYWNyb3NzIGl0IGFuZCBkaXNydXB0aW5nIHRoZVxuICAgIC8vIGNvbXBvc2l0aW9uLlxuICAgIHN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlKHNlbCwgY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGN1cnNvci5lbXB0eSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIHRoaXMucG9zRnJvbURPTShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpID09IGN1cnNvci5oZWFkO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIGEgcG9zaXRpb24gaXMgaW4vbmVhciBhIGJsb2NrIHdpZGdldCwgbW92ZSBpdCB0byBhIG5lYXJieSB0ZXh0XG4gICAgLy8gbGluZSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGUgY3Vyc29yIGluc2lkZSBhIGJsb2NrIHdpZGdldC5cbiAgICBtb3ZlVG9MaW5lKHBvcykge1xuICAgICAgICAvLyBCbG9jayB3aWRnZXRzIHdpbGwgcmV0dXJuIHBvc2l0aW9ucyBiZWZvcmUvYWZ0ZXIgdGhlbSwgd2hpY2hcbiAgICAgICAgLy8gYXJlIHRodXMgZGlyZWN0bHkgaW4gdGhlIGRvY3VtZW50IERPTSBlbGVtZW50LlxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb20sIG5ld1BvcztcbiAgICAgICAgaWYgKHBvcy5ub2RlICE9IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0OyAhbmV3UG9zICYmIGkgPCBkb20uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0IC0gMTsgIW5ld1BvcyAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKHZpZXcubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UG9zID8gbmV3IERPTVBvcyhuZXdQb3Mubm9kZSwgbmV3UG9zLm9mZnNldCwgdHJ1ZSkgOiBwb3M7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGJlc3QgPSBudWxsLCBiZXN0UG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyLCBzdGFydCA9IGVuZCAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcG9zICYmIChzdGFydCA8IHBvcyB8fCBjaGlsZC5jb3ZlcnMoLTEpKSAmJiAoZW5kID4gcG9zIHx8IGNoaWxkLmNvdmVycygxKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlc3QgfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiAhKGJlc3QgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiBzaWRlID49IDApKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBiZXN0UG9zID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZXN0ICYmIHN0YXJ0ID09IHBvcyAmJiBlbmQgPT0gcG9zICYmIGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIE1hdGguYWJzKHNpZGUpIDwgMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kZWNvLnN0YXJ0U2lkZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3QgPyBiZXN0LmNvb3Jkc0F0KHBvcyAtIGJlc3RQb3MsIHNpZGUpIDogbnVsbDtcbiAgICB9XG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSksIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgaSwgb2ZmOiBjaGlsZE9mZiB9ID0gY2hpbGQuY2hpbGRQb3Mob2ZmLCAxKTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoKGNoaWxkID0gY2hpbGQuY2hpbGRyZW5baV0pLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBjaGlsZE9mZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gZmluZENsdXN0ZXJCcmVhayhjaGlsZC50ZXh0LCBvZmYpO1xuICAgICAgICBpZiAoZW5kID09IG9mZilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQuZG9tLCBvZmYsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSAmJiByZWN0LmxlZnQgPCByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMSwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSZWN0ID0gY2hpbGQuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1dpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2hpbGQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gbGFzdCA/IGNsaWVudFJlY3RzRm9yKGxhc3QpIDogW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBsdHIgPyByZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LmxlZnQgOiBjaGlsZFJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiB3aWRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgeyBpIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSk7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuY2hpbGRyZW5baV0uZG9tKS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmUgPSBjaGlsZC5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gd29ya2FibGUgbGluZSBleGlzdHMsIGZvcmNlIGEgbGF5b3V0IG9mIGEgbWVhc3VyYWJsZSBlbGVtZW50XG4gICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodDtcbiAgICAgICAgZHVtbXkuY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgIGR1bW15LnN0eWxlLndpZHRoID0gXCI5OTk5OXB4XCI7XG4gICAgICAgIGR1bW15LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0ID8gcmVjdC5oZWlnaHQgOiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfTtcbiAgICB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTW92ZSBiYWNrIHRvIHN0YXJ0IG9mIGxhc3QgZWxlbWVudCB3aGVuIHBvc3NpYmxlLCBzbyB0aGF0XG4gICAgICAgIC8vIGBDaGlsZEN1cnNvci5maW5kUG9zYCBkb2Vzbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoZSBlZGdlIGNhc2VcbiAgICAgICAgLy8gb2YgYmVpbmcgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgbGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwb3MgLT0gdGhpcy5jaGlsZHJlblstLWldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIGkpO1xuICAgIH1cbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgICAgICBsZXQgZGVjbyA9IFtdLCB2cyA9IHRoaXMudmlldy52aWV3U3RhdGU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbSAtIDEgOiB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gKHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3ApIC8gdGhpcy52aWV3LnNjYWxlWTtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQmxvY2tHYXBXaWRnZXQoaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9ja0dhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dC50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbiAgICB1cGRhdGVEZWNvKCkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoZCA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkeW5hbWljT3V0ZXIgPSBmYWxzZSwgb3V0ZXJEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KG91dGVyRGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgICAgICBkeW5hbWljT3V0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dGVyRGVjby5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGR5bmFtaWNPdXRlcjtcbiAgICAgICAgICAgIGFsbERlY28ucHVzaChSYW5nZVNldC5qb2luKG91dGVyRGVjbykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyxcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucztcbiAgICB9XG4gICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuaXNTbmFwc2hvdCkge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQodGFyZ2V0LnJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSByZWYudG9wIC0gdGFyZ2V0LnlNYXJnaW47XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB0YXJnZXQueE1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHRoaXMudmlldy5zdGF0ZS5mYWNldChzY3JvbGxIYW5kbGVyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIHRhcmdldC5yYW5nZSwgdGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwic2Nyb2xsIGhhbmRsZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1hcmdpbnMubGVmdCwgdG9wOiByZWN0LnRvcCAtIG1hcmdpbnMudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtYXJnaW5zLnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbWFyZ2lucy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gdGhpcy52aWV3LnNjcm9sbERPTTtcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnhNYXJnaW4sIG9mZnNldFdpZHRoKSwgLW9mZnNldFdpZHRoKSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnlNYXJnaW4sIG9mZnNldEhlaWdodCksIC1vZmZzZXRIZWlnaHQpLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiZXR3ZWVuVW5lZGl0YWJsZShwb3MpIHtcbiAgICByZXR1cm4gcG9zLm5vZGUubm9kZVR5cGUgPT0gMSAmJiBwb3Mubm9kZS5maXJzdENoaWxkICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IDAgfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgaGVhZFBvcykge1xuICAgIGxldCBzZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRleHRCZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSB0ZXh0Tm9kZUFmdGVyKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHROb2RlID0gdGV4dEJlZm9yZSB8fCB0ZXh0QWZ0ZXI7XG4gICAgaWYgKHRleHRBZnRlciAmJiB0ZXh0QmVmb3JlICYmIHRleHRBZnRlci5ub2RlICE9IHRleHRCZWZvcmUubm9kZSkge1xuICAgICAgICBsZXQgZGVzY0FmdGVyID0gQ29udGVudFZpZXcuZ2V0KHRleHRBZnRlci5ub2RlKTtcbiAgICAgICAgaWYgKCFkZXNjQWZ0ZXIgfHwgZGVzY0FmdGVyIGluc3RhbmNlb2YgVGV4dFZpZXcgJiYgZGVzY0FmdGVyLnRleHQgIT0gdGV4dEFmdGVyLm5vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHRBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmRvY1ZpZXcubGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IpIHtcbiAgICAgICAgICAgIGxldCBkZXNjQmVmb3JlID0gQ29udGVudFZpZXcuZ2V0KHRleHRCZWZvcmUubm9kZSk7XG4gICAgICAgICAgICBpZiAoISghZGVzY0JlZm9yZSB8fCBkZXNjQmVmb3JlIGluc3RhbmNlb2YgVGV4dFZpZXcgJiYgZGVzY0JlZm9yZS50ZXh0ICE9IHRleHRCZWZvcmUubm9kZS5ub2RlVmFsdWUpKVxuICAgICAgICAgICAgICAgIHRleHROb2RlID0gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9jVmlldy5sYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvciA9IHRleHROb2RlICE9IHRleHRCZWZvcmU7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSBoZWFkUG9zIC0gdGV4dE5vZGUub2Zmc2V0O1xuICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgdGV4dE5vZGUubm9kZS5ub2RlVmFsdWUubGVuZ3RoLCBub2RlOiB0ZXh0Tm9kZS5ub2RlIH07XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25SYW5nZSh2aWV3LCBjaGFuZ2VzLCBoZWFkUG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBub2RlOiB0ZXh0Tm9kZSwgZnJvbSwgdG8gfSA9IGZvdW5kLCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgIC8vIERvbid0IHRyeSB0byBwcmVzZXJ2ZSBtdWx0aS1saW5lIGNvbXBvc2l0aW9uc1xuICAgIGlmICgvW1xcblxccl0vLnRlc3QodGV4dCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmb3VuZC5mcm9tLCBmb3VuZC50bykgIT0gdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGludiA9IGNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgIGxldCByYW5nZSA9IG5ldyBDaGFuZ2VkUmFuZ2UoaW52Lm1hcFBvcyhmcm9tKSwgaW52Lm1hcFBvcyh0byksIGZyb20sIHRvKTtcbiAgICBsZXQgbWFya3MgPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlOzsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgbGV0IHBhcmVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IHBhcmVudFZpZXcubWFyayB9KTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50VmlldyBpbnN0YW5jZW9mIExpbmVWaWV3IHx8IHBhcmVudC5ub2RlTmFtZSA9PSBcIkRJVlwiICYmIHBhcmVudC5wYXJlbnROb2RlID09IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0OiB0ZXh0Tm9kZSwgbWFya3MsIGxpbmU6IHBhcmVudCB9O1xuICAgICAgICBlbHNlIGlmIChwYXJlbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5vZGU6IHBhcmVudCwgZGVjbzogbmV3IE1hcmtEZWNvcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBnZXRBdHRycyhwYXJlbnQpLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5leHRUb1VuZWRpdGFibGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAxIC8qIE5leHRUby5CZWZvcmUgKi8gOiAwKSB8XG4gICAgICAgIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAyIC8qIE5leHRUby5BZnRlciAqLyA6IDApO1xufVxubGV0IERlY29yYXRpb25Db21wYXJhdG9yJDEgPSBjbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBib3VuZENoYW5nZShwb3MpIHsgYWRkUmFuZ2UocG9zLCBwb3MsIHRoaXMuY2hhbmdlcyk7IH1cbn07XG5mdW5jdGlvbiBmaW5kQ2hhbmdlZERlY28oYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yJDE7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gaW5VbmVkaXRhYmxlKG5vZGUsIGluc2lkZSkge1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1ciAmJiBjdXIgIT0gaW5zaWRlOyBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvdWNoZXNDb21wb3NpdGlvbihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgIGxldCB0b3VjaGVkID0gZmFsc2U7XG4gICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPCBjb21wb3NpdGlvbi50byAmJiB0byA+IGNvbXBvc2l0aW9uLmZyb20pXG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGVkO1xufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZLCBjbG9zZXN0T3ZlcmxhcCA9IGZhbHNlO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gZHkgPyAoeSA8IHJlY3QudG9wID8gLTEgOiAxKSA6IGR4ID8gKHggPCByZWN0LmxlZnQgPyAtMSA6IDEpIDogMDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T3ZlcmxhcCA9ICFzaWRlIHx8IChzaWRlID4gMCA/IGkgPCByZWN0cy5sZW5ndGggLSAxIDogaSA+IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA8IHJlY3QudG9wICYmICghYmVsb3dSZWN0IHx8IGJlbG93UmVjdC50b3AgPiByZWN0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHVwQm90KGFib3ZlUmVjdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSB1cFRvcChiZWxvd1JlY3QsIHJlY3QudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJvdmVSZWN0ICYmIGFib3ZlUmVjdC5ib3R0b20gPj0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYWJvdmVSZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBiZWxvdztcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBiZWxvd1JlY3Q7XG4gICAgfVxuICAgIGlmICghY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQ6IDAgfTtcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xuICAgIGlmIChjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBkb21Qb3NJblRleHQoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGlmIChjbG9zZXN0T3ZlcmxhcCAmJiBjbG9zZXN0LmNvbnRlbnRFZGl0YWJsZSAhPSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBkb21Qb3NBdENvb3JkcyhjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgbGV0IG9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkTm9kZXMsIGNsb3Nlc3QpICtcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IGNsb3Nlc3RPZmZzZXQgPSAtMSwgY2xvc2VzdERZID0gMWU5LCBnZW5lcmFsU2lkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2Uobm9kZSwgaSwgaSArIDEpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxuICAgICAgICAgICAgICAgIGdlbmVyYWxTaWRlID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIGxldCBkeSA9IChyZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiB5IC0gcmVjdC5ib3R0b20pIC0gMTtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHggPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgYWZ0ZXIgPSByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0cyBmb3IgZW1wdHkgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHRleHRSYW5nZShub2RlLCBpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAhcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoYWZ0ZXIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T2Zmc2V0ID0gaSArIChhZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGNsb3Nlc3RPZmZzZXQgPiAtMSA/IGNsb3Nlc3RPZmZzZXQgOiBnZW5lcmFsU2lkZSA+IDAgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMsIHByZWNpc2UsIGJpYXMgPSAtMSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgYmxvY2ssIHsgZG9jSGVpZ2h0IH0gPSB2aWV3LnZpZXdTdGF0ZTtcbiAgICBsZXQgeyB4LCB5IH0gPSBjb29yZHMsIHlPZmZzZXQgPSB5IC0gZG9jVG9wO1xuICAgIGlmICh5T2Zmc2V0IDwgMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHlPZmZzZXQgPiBkb2NIZWlnaHQpXG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgLy8gU2NhbiBmb3IgYSB0ZXh0IGJsb2NrIG5lYXIgdGhlIHF1ZXJpZWQgeSBwb3NpdGlvblxuICAgIGZvciAobGV0IGhhbGZMaW5lID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgLyAyLCBib3VuY2VkID0gZmFsc2U7Oykge1xuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB5IHBvc2l0aW9uIG91dCBvZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICB5T2Zmc2V0ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBjb25zaXN0cyBlbnRpcmVseSBvZiByZXBsYWNlZCB3aWRnZXRzLCB3ZVxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzZSA/IG51bGwgOiAwO1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICBiaWFzID0gLWJpYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeSA9IGRvY1RvcCArIHlPZmZzZXQ7XG4gICAgbGV0IGxpbmVTdGFydCA9IGJsb2NrLmZyb207XG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cbiAgICBpZiAobGluZVN0YXJ0IDwgdmlldy52aWV3cG9ydC5mcm9tKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LnRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6XG4gICAgICAgICAgICBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYztcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgKChfYSA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgIT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICh7IG9mZnNldE5vZGU6IG5vZGUsIG9mZnNldCB9ID0gcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKG5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jaHJvbWUgJiYgaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaHJvbWUgd2lsbCByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gZWxlbWVudHMgd2l0aG91dCBjaGlsZFxuICAgICAgICAvLyBub2Rlcywgd2hpY2ggd2lsbCBsZWFkIHRvIGEgbnVsbCBkZXJlZiBiZWxvdywgc28gY2xpcCB0aGVcbiAgICAgICAgLy8gb2Zmc2V0IHRvIHRoZSBub2RlIHNpemUuXG4gICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4obWF4T2Zmc2V0KG5vZGUpLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxuICAgIGlmICghbm9kZSB8fCAhdmlldy5kb2NWaWV3LmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBsaW5lU3RhcnQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm4geU9mZnNldCA+IGJsb2NrLnRvcCArIGJsb2NrLmhlaWdodCAvIDIgPyBibG9jay50byA6IGJsb2NrLmZyb207XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChub2RlKTtcbiAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChuZWFyZXN0LmlzV2lkZ2V0ICYmICgoX2IgPSBuZWFyZXN0LmRvbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vZGVUeXBlKSA9PSAxKSB7XG4gICAgICAgIGxldCByZWN0ID0gbmVhcmVzdC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBjb29yZHMueSA8IHJlY3QudG9wIHx8IGNvb3Jkcy55IDw9IHJlY3QuYm90dG9tICYmIGNvb3Jkcy54IDw9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDJcbiAgICAgICAgICAgID8gbmVhcmVzdC5wb3NBdFN0YXJ0IDogbmVhcmVzdC5wb3NBdEVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgbmVhcmVzdC5wb3NBdFN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnRSZWN0LCBibG9jaywgeCwgeSkge1xuICAgIGxldCBpbnRvID0gTWF0aC5yb3VuZCgoeCAtIGNvbnRlbnRSZWN0LmxlZnQpICogdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZyAmJiBibG9jay5oZWlnaHQgPiB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0ICogMS41KSB7XG4gICAgICAgIGxldCB0ZXh0SGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lID0gTWF0aC5mbG9vcigoeSAtIGJsb2NrLnRvcCAtICh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdGV4dEhlaWdodCkgKiAwLjUpIC8gdGV4dEhlaWdodCk7XG4gICAgICAgIGludG8gKz0gbGluZSAqIHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoYmxvY2suZnJvbSwgYmxvY2sudG8pO1xuICAgIHJldHVybiBibG9jay5mcm9tICsgZmluZENvbHVtbihjb250ZW50LCBpbnRvLCB2aWV3LnN0YXRlLnRhYlNpemUpO1xufVxuLy8gSW4gY2FzZSBvZiBhIGhpZ2ggbGluZSBoZWlnaHQsIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgdHJlYXRzXG4vLyB0aGUgc3BhY2UgYmV0d2VlbiBsaW5lcyBhcyBiZWxvbmdpbmcgdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZVxuLy8gbGluZSBiZWZvcmUuIFRoaXMgaXMgdXNlZCB0byBkZXRlY3Qgc3VjaCBhIHJlc3VsdCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gaWdub3JlZCAoaXNzdWUgIzQwMSkuXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBsZXQgbGVuO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7IG5leHQ7IG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKVxuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSAhPSAxIHx8IG5leHQubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0ZXh0UmFuZ2Uobm9kZSwgbGVuIC0gMSwgbGVuKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4geDtcbn1cbi8vIENocm9tZSB3aWxsIG1vdmUgcG9zaXRpb25zIGJldHdlZW4gbGluZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGxpbmVcbmZ1bmN0aW9uIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGlmIChvZmZzZXQgIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7Oykge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IHBhcmVudC5maXJzdENoaWxkICE9IGN1cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN1ciA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlY3QgPSBub2RlLm5vZGVUeXBlID09IDEgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogdGV4dFJhbmdlKG5vZGUsIDAsIE1hdGgubWF4KG5vZGUubm9kZVZhbHVlLmxlbmd0aCwgMSkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSlcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLnRvID4gcG9zIHx8IGwudG8gPT0gcG9zICYmIChsLnRvID09IGxpbmUudG8gfHwgbC50eXBlID09IEJsb2NrVHlwZS5UZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gYmxvY2tBdCh2aWV3LCBzdGFydC5oZWFkKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dCB8fCAhKHZpZXcubGluZVdyYXBwaW5nIHx8IGxpbmUud2lkZ2V0TGluZUJyZWFrcykgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gdmlldy52aXN1YWxMaW5lU2lkZShsaW5lLCAhZm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyB8fCAtMSksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSkge1xuICAgICAgICAgICAgbGV0IGNoYXJSZWN0ID0gdmlldy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICAgICAgICAgIGxldCBhc3NvYyA9ICFjaGFyUmVjdCB8fCBjdXJZIDwgY2hhclJlY3QudG9wID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBhc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHBvcywgYmlhcykge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MgLSAxLCBwb3MgKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBtb3ZlZCB8fCBiaWFzIHx8IChwb3MgLSBmcm9tIDwgdG8gLSBwb3MgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzaWRlIDwgMCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSBzaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBuZXdQb3MgPSBza2lwQXRvbWljUmFuZ2VzKHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgcG9zLmZyb20sIG9sZFBvcy5oZWFkID4gcG9zLmZyb20gPyAtMSA6IDEpO1xuICAgIHJldHVybiBuZXdQb3MgPT0gcG9zLmZyb20gPyBwb3MgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgbmV3UG9zIDwgcG9zLmZyb20gPyAxIDogLTEpO1xufVxuXG5jb25zdCBMaW5lQnJlYWtQbGFjZWhvbGRlciA9IFwiXFx1ZmZmZlwiO1xuY2xhc3MgRE9NUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpbmVTZXBhcmF0b3IgPSBzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKTtcbiAgICB9XG4gICAgYXBwZW5kKHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IHRleHQ7XG4gICAgfVxuICAgIGxpbmVCcmVhaygpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IExpbmVCcmVha1BsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZWFkUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSBzdGFydC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGN1cik7XG4gICAgICAgICAgICBsZXQgb2xkTGVuID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucmVhZE5vZGUoY3VyKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKSwgbmV4dFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICBpZiAodmlldyAmJiBuZXh0VmlldyA/IHZpZXcuYnJlYWtBZnRlciA6XG4gICAgICAgICAgICAgICAgKHZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOiBpc0Jsb2NrRWxlbWVudChjdXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNCbG9ja0VsZW1lbnQobmV4dCkgJiYgKGN1ci5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgY3VyLmNtSWdub3JlKSAmJiB0aGlzLnRleHQubGVuZ3RoID4gb2xkTGVuKSlcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFkVGV4dE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSAwLCByZSA9IHRoaXMubGluZVNlcGFyYXRvciA/IG51bGwgOiAvXFxyXFxuP3xcXG4vZzs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gLTEsIGJyZWFrU2l6ZSA9IDEsIG07XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKHRoaXMubGluZVNlcGFyYXRvciwgb2ZmKTtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmQodGV4dC5zbGljZShvZmYsIG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaykpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgcG9pbnQucG9zID4gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEJyZWFrICsgYnJlYWtTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY21JZ25vcmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQgZnJvbVZpZXcgPSB2aWV3ICYmIHZpZXcub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUobm9kZSwgZnJvbVZpZXcubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVmlldy5pdGVyKCk7ICFpLm5leHQoKS5kb25lOykge1xuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yZWFkVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRQb2ludEJlZm9yZShub2RlLCBuZXh0KSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBub2RlLmNoaWxkTm9kZXNbcG9pbnQub2Zmc2V0XSA9PSBuZXh0KVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmRQb2ludEluc2lkZShub2RlLCBsZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgKGlzQXRFbmQobm9kZSwgcG9pbnQubm9kZSwgcG9pbnQub2Zmc2V0KSA/IGxlbmd0aCA6IDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQXRFbmQocGFyZW50LCBub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghbm9kZSB8fCBvZmZzZXQgPCBtYXhPZmZzZXQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IHN0YXJ0ID4gLTE7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAvLyBpT1Mgd2lsbCByZWZ1c2UgdG8gc2VsZWN0IHRoZSBibG9jayBnYXBzIHdoZW4gZG9pbmdcbiAgICAgICAgICAgIC8vIHNlbGVjdC1hbGwuXG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiAqaW5zaWRlKiB0aGVtLCBjb25mdXNpbmdcbiAgICAgICAgICAgIC8vIHBvc0Zyb21ET01cbiAgICAgICAgICAgIGxldCB2cCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaW9zIHx8IGJyb3dzZXIuY2hyb21lKSAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIGhlYWQgIT0gYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgKHZwLmZyb20gPiAwIHx8IHZwLnRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oaGVhZCwgYW5jaG9yKSwgdG8gPSBNYXRoLm1heChoZWFkLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGxldCBvZmZGcm9tID0gdnAuZnJvbSAtIGZyb20sIG9mZlRvID0gdnAudG8gLSB0bztcbiAgICAgICAgICAgICAgICBpZiAoKG9mZkZyb20gPT0gMCB8fCBvZmZGcm9tID09IDEgfHwgZnJvbSA9PSAwKSAmJiAob2ZmVG8gPT0gMCB8fCBvZmZUbyA9PSAtMSB8fCB0byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZSh2aWV3LCBkb21DaGFuZ2UpIHtcbiAgICBsZXQgY2hhbmdlO1xuICAgIGxldCB7IG5ld1NlbCB9ID0gZG9tQ2hhbmdlLCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBsYXN0S2V5ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID4gRGF0ZS5ub3coKSAtIDEwMCA/IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA6IC0xO1xuICAgIGlmIChkb21DaGFuZ2UuYm91bmRzKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBkb21DaGFuZ2UuYm91bmRzO1xuICAgICAgICBsZXQgcHJlZmVycmVkUG9zID0gc2VsLmZyb20sIHByZWZlcnJlZFNpZGUgPSBudWxsO1xuICAgICAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkIChvciwgb25cbiAgICAgICAgLy8gQW5kcm9pZCwgd2hlbiBzb21ldGhpbmcgd2FzIGRlbGV0ZWQpXG4gICAgICAgIGlmIChsYXN0S2V5ID09PSA4IHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcbiAgICAgICAgICAgIHByZWZlcnJlZFBvcyA9IHNlbC50bztcbiAgICAgICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSwgZG9tQ2hhbmdlLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBEb21DaGFuZ2UgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGxhc3RLZXkgPT0gMTMgJiZcbiAgICAgICAgICAgICAgICBkaWZmLnRvQiA9PSBkaWZmLmZyb20gKyAyICYmIGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpID09IExpbmVCcmVha1BsYWNlaG9sZGVyICsgTGluZUJyZWFrUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgZGlmZi50b0ItLTtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFRleHQub2YoZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoTGluZUJyZWFrUGxhY2Vob2xkZXIpKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAoIXZpZXcuaGFzRm9jdXMgJiYgdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgbmV3U2VsLm1haW4uZXEoc2VsKSkpIHtcbiAgICAgICAgbmV3U2VsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UgJiYgIW5ld1NlbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY2hhbmdlICYmIGRvbUNoYW5nZS50eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSkge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gbm90aWNlIHR5cGluZyBvdmVyIGEgc2VsZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIHNlbC50bykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAtIDEgJiZcbiAgICAgICAgL15cXC4gPyQvLnRlc3QoY2hhbmdlLmluc2VydC50b1N0cmluZygpKSAmJiB2aWV3LmNvbnRlbnRET00uZ2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIikgPT0gXCJvZmZcIikge1xuICAgICAgICAvLyBEZXRlY3QgaW5zZXJ0LXBlcmlvZC1vbi1kb3VibGUtc3BhY2UgTWFjIGFuZCBBbmRyb2lkIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByZWd1bGFyIHNwYWNlIGluc2VydC5cbiAgICAgICAgaWYgKG5ld1NlbCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAyKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyLmNocm9tZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkICYmXG4gICAgICAgIGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSA9PSBcIlxcbiBcIiAmJiB2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGlmIHlvdSBpbnNlcnQgYSBzcGFjZSBhdCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkXG4gICAgICAgIC8vIGxpbmUsIGl0IHdpbGwgYWN0dWFsbHkgaW5zZXJ0IGEgbmV3bGluZSBhbmQgYSBzcGFjZSwgY2F1c2luZyBhXG4gICAgICAgIC8vIGJvZ3VzIG5ldyBsaW5lIHRvIGJlIGNyZWF0ZWQgaW4gQ29kZU1pcnJvciAoIzk2OClcbiAgICAgICAgaWYgKG5ld1NlbClcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgICByZXR1cm4gYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCBjaGFuZ2UsIG5ld1NlbCwgbGFzdEtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAhbmV3U2VsLm1haW4uZXEoc2VsKSkge1xuICAgICAgICBsZXQgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSwgdXNlckV2ZW50ID0gXCJzZWxlY3RcIjtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luID09IFwic2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgdXNlckV2ZW50ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogbmV3U2VsLCBzY3JvbGxJbnRvVmlldywgdXNlckV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgbmV3U2VsLCBsYXN0S2V5ID0gLTEpIHtcbiAgICBpZiAoYnJvd3Nlci5pb3MgJiYgdmlldy5pbnB1dFN0YXRlLmZsdXNoSU9TS2V5KGNoYW5nZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIC8vIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgZmlyZSByZWFzb25hYmxlIGtleSBldmVudHMgZm9yIGVudGVyLFxuICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgIC8vIHRoZXkncmUgY2F1c2VkIGJ5IHRob3NlIGtleXMsIGFuZCByZWludGVycHJldHMgdGhlbSBhcyBrZXlcbiAgICAvLyBldmVudHMuIChTb21lIG9mIHRoZXNlIGtleXMgYXJlIGFsc28gaGFuZGxlZCBieSBiZWZvcmVpbnB1dFxuICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAvLyByZWxpYWJsZSBpbiBhbGwgc2l0dWF0aW9ucy4pXG4gICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJlxuICAgICAgICAoKGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgIC8vIEdCb2FyZCB3aWxsIHNvbWV0aW1lcyByZW1vdmUgYSBzcGFjZSBpdCBqdXN0IGluc2VydGVkXG4gICAgICAgICAgICAvLyBhZnRlciBhIGNvbXBsZXRpb24gd2hlbiB5b3UgcHJlc3MgZW50ZXJcbiAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSB8fCBjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgc2VsLmZyb20pID09IFwiIFwiKSAmJlxuICAgICAgICAgICAgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UuaW5zZXJ0LmxpbmVzID09IDIgJiZcbiAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgICAgICBsYXN0S2V5ID09IDggJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPCBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSAmJiBjaGFuZ2UudG8gPiBzZWwuaGVhZCkgJiZcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gKyAxICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRGVsZXRlXCIsIDQ2KSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgdGV4dCA9IGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgbGV0IGRlZmF1bHRUcjtcbiAgICBsZXQgZGVmYXVsdEluc2VydCA9ICgpID0+IGRlZmF1bHRUciB8fCAoZGVmYXVsdFRyID0gYXBwbHlEZWZhdWx0SW5zZXJ0KHZpZXcsIGNoYW5nZSwgbmV3U2VsKSk7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCwgZGVmYXVsdEluc2VydCkpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmF1bHRJbnNlcnQoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpIHtcbiAgICBsZXQgdHIsIHN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlLCBzZWwgPSBzdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byAtIGNoYW5nZS5mcm9tID49IChzZWwudG8gLSBzZWwuZnJvbSkgLyAzICYmXG4gICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkgJiZcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHNlbC5mcm9tIDwgY2hhbmdlLmZyb20gPyBzdGFydFN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkgOiBcIlwiO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBzZWwudG8gPiBjaGFuZ2UudG8gPyBzdGFydFN0YXRlLnNsaWNlRG9jKGNoYW5nZS50bywgc2VsLnRvKSA6IFwiXCI7XG4gICAgICAgIHRyID0gc3RhcnRTdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHZpZXcuc3RhdGUudG9UZXh0KGJlZm9yZSArIGNoYW5nZS5pbnNlcnQuc2xpY2VTdHJpbmcoMCwgdW5kZWZpbmVkLCB2aWV3LnN0YXRlLmxpbmVCcmVhaykgKyBhZnRlcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgbGV0IG1haW5TZWwgPSBuZXdTZWwgJiYgbmV3U2VsLm1haW4udG8gPD0gY2hhbmdlcy5uZXdMZW5ndGggPyBuZXdTZWwubWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVHJ5IHRvIGFwcGx5IGEgY29tcG9zaXRpb24gY2hhbmdlIHRvIGFsbCBjdXJzb3JzXG4gICAgICAgIGlmIChzdGFydFN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoID4gMSAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiZcbiAgICAgICAgICAgIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvID49IHNlbC50byAtIDEwKSB7XG4gICAgICAgICAgICBsZXQgcmVwbGFjZWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0aW9uUmFuZ2UsIGNvbXBvc2l0aW9uID0gbmV3U2VsICYmIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgbmV3U2VsLm1haW4uaGVhZCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgZExlbiA9IGNoYW5nZS5pbnNlcnQubGVuZ3RoIC0gKGNoYW5nZS50byAtIGNoYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblJhbmdlID0geyBmcm9tOiBjb21wb3NpdGlvbi5mcm9tLCB0bzogY29tcG9zaXRpb24udG8gLSBkTGVuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblJhbmdlID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHNlbC5oZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBzZWwudG8gLSBjaGFuZ2UudG8sIHNpemUgPSBzZWwudG8gLSBzZWwuZnJvbTtcbiAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiByYW5nZS50byA9PSBzZWwudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXMsIHJhbmdlOiBtYWluU2VsIHx8IHJhbmdlLm1hcChjaGFuZ2VzKSB9O1xuICAgICAgICAgICAgICAgIGxldCB0byA9IHJhbmdlLnRvIC0gb2Zmc2V0LCBmcm9tID0gdG8gLSByZXBsYWNlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvIC0gcmFuZ2UuZnJvbSAhPSBzaXplIHx8IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pICE9IHJlcGxhY2VkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgc2FtZSBub2RlIHdvcmsgd2l0aG91dCBhYm9ydGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGlvbiwgc28gY3Vyc29ycyBpbiB0aGUgY29tcG9zaXRpb24gcmFuZ2UgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnRvID49IGNvbXBvc2l0aW9uUmFuZ2UuZnJvbSAmJiByYW5nZS5mcm9tIDw9IGNvbXBvc2l0aW9uUmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlQ2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyh7IGZyb20sIHRvLCBpbnNlcnQ6IGNoYW5nZS5pbnNlcnQgfSksIHNlbE9mZiA9IHJhbmdlLnRvIC0gc2VsLnRvO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6ICFtYWluU2VsID8gcmFuZ2UubWFwKHJhbmdlQ2hhbmdlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWF4KDAsIG1haW5TZWwuYW5jaG9yICsgc2VsT2ZmKSwgTWF0aC5tYXgoMCwgbWFpblNlbC5oZWFkICsgc2VsT2ZmKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ciA9IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWFpblNlbCAmJiBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobWFpblNlbClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHVzZXJFdmVudCA9IFwiaW5wdXQudHlwZVwiO1xuICAgIGlmICh2aWV3LmNvbXBvc2luZyB8fFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB1c2VyRXZlbnQgKz0gXCIuY29tcG9zZVwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5zdGFydFwiO1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRTdGF0ZS51cGRhdGUodHIsIHsgdXNlckV2ZW50LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBtaW5MZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBmcm9tID0gMDtcbiAgICB3aGlsZSAoZnJvbSA8IG1pbkxlbiAmJiBhLmNoYXJDb2RlQXQoZnJvbSkgPT0gYi5jaGFyQ29kZUF0KGZyb20pKVxuICAgICAgICBmcm9tKys7XG4gICAgaWYgKGZyb20gPT0gbWluTGVuICYmIGEubGVuZ3RoID09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdG9BID0gYS5sZW5ndGgsIHRvQiA9IGIubGVuZ3RoO1xuICAgIHdoaWxlICh0b0EgPiAwICYmIHRvQiA+IDAgJiYgYS5jaGFyQ29kZUF0KHRvQSAtIDEpID09IGIuY2hhckNvZGVBdCh0b0IgLSAxKSkge1xuICAgICAgICB0b0EtLTtcbiAgICAgICAgdG9CLS07XG4gICAgfVxuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIGZyb20gLSBNYXRoLm1pbih0b0EsIHRvQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gdG9BICsgYWRqdXN0IC0gZnJvbTtcbiAgICB9XG4gICAgaWYgKHRvQSA8IGZyb20gJiYgYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0EgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0IgPSBmcm9tICsgKHRvQiAtIHRvQSk7XG4gICAgICAgIHRvQSA9IGZyb207XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvQiA8IGZyb20pIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9CID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9BID0gZnJvbSArICh0b0EgLSB0b0IpO1xuICAgICAgICB0b0IgPSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0b0EsIHRvQiB9O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uUG9pbnRzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBsZXQgeyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGFuY2hvck5vZGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkpO1xuICAgICAgICBpZiAoZm9jdXNOb2RlICE9IGFuY2hvck5vZGUgfHwgZm9jdXNPZmZzZXQgIT0gYW5jaG9yT2Zmc2V0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21Qb2ludHMocG9pbnRzLCBiYXNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvciA9IHBvaW50c1swXS5wb3MsIGhlYWQgPSBwb2ludHMubGVuZ3RoID09IDIgPyBwb2ludHNbMV0ucG9zIDogYW5jaG9yO1xuICAgIHJldHVybiBhbmNob3IgPiAtMSAmJiBoZWFkID4gLTEgPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciArIGJhc2UsIGhlYWQgKyBiYXNlKSA6IG51bGw7XG59XG5cbmNsYXNzIElucHV0U3RhdGUge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZW5hYmxlZCAoPi0xKSwgdGFiIHByZXNzZXMgYXJlIG5vdCBnaXZlbiB0byBrZXkgaGFuZGxlcnMsXG4gICAgICAgIGxlYXZpbmcgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yLiBJZiA+MCwgdGhlIG1vZGUgZXhwaXJlc1xuICAgICAgICBhdCB0aGF0IHRpbWVzdGFtcCwgYW5kIGFueSBvdGhlciBrZXlwcmVzcyBjbGVhcnMgaXQuXG4gICAgICAgIEVzYyBlbmFibGVzIHRlbXBvcmFyeSB0YWIgZm9jdXMgbW9kZSBmb3IgdHdvIHNlY29uZHMgd2hlbiBub3RcbiAgICAgICAgb3RoZXJ3aXNlIGhhbmRsZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFiRm9jdXNNb2RlID0gLTE7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb250ZXh0TWVudSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIC0xIG1lYW5zIG5vdCBpbiBhIGNvbXBvc2l0aW9uLiBPdGhlcndpc2UsIHRoaXMgY291bnRzIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgY2hhbmdlcyBtYWRlIGR1cmluZyB0aGUgY29tcG9zaXRpb24uIFRoZSBjb3VudCBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcbiAgICAgICAgLy8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSwgYXMgcGFydCBvZiB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gLTE7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiAobnVsbCBtZWFucyBubyBjb21wb3NpdGlvbiwgdHJ1ZSBtZWFucyBuZXh0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCwgZmFsc2UgbWVhbnMgZmlyc3QgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgIC8vIEVuZCB0aW1lIG9mIHRoZSBwcmV2aW91cyBjb21wb3NpdGlvblxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgIC8vIFVzZWQgaW4gYSBrbHVkZ2UgdG8gZGV0ZWN0IHdoZW4gYW4gRW50ZXIga2V5cHJlc3Mgc2hvdWxkIGJlXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgY29tcG9zaXRpb24gb24gU2FmYXJpLCB3aGljaCBmaXJlcyBldmVudHNcbiAgICAgICAgLy8gaW4gdGhlIHdyb25nIG9yZGVyXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgdG8gY2F0ZWdvcml6ZSBjaGFuZ2VzIGFzIHBhcnQgb2YgYSBjb21wb3NpdGlvbiwgZXZlbiB3aGVuXG4gICAgICAgIC8vIHRoZSBtdXRhdGlvbiBldmVudHMgZmlyZSBzaG9ydGx5IGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgLy8gV2hlbiBhIGRyYWcgZnJvbSB0aGUgZWRpdG9yIGlzIGFjdGl2ZSwgdGhpcyBwb2ludHMgYXQgdGhlIHJhbmdlXG4gICAgICAgIC8vIGJlaW5nIGRyYWdnZWQuXG4gICAgICAgIHRoaXMuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGlmaWVkRm9jdXNlZCA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIC8vIE9uIFNhZmFyaSBhZGRpbmcgYW4gaW5wdXQgZXZlbnQgaGFuZGxlciBzb21laG93IHByZXZlbnRzIGFuXG4gICAgICAgIC8vIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuIHlvdSBwcmVzcyBlbnRlci5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpKVxuICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pXG4gICAgICAgICAgICBmaXJlZm94Q29weUN1dEhhY2sodmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50QmVsb25nc1RvRWRpdG9yKHRoaXMudmlldywgZXZlbnQpIHx8IHRoaXMuaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiB0aGlzLmtleWRvd24oZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJ1bkhhbmRsZXJzKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICB9XG4gICAgcnVuSGFuZGxlcnModHlwZSwgZXZlbnQpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBvYnNlcnZlciBvZiBoYW5kbGVycy5vYnNlcnZlcnMpXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIodGhpcy52aWV3LCBldmVudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKHRoaXMudmlldywgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnN1cmVIYW5kbGVycyhwbHVnaW5zKSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IGNvbXB1dGVIYW5kbGVycyhwbHVnaW5zKSwgcHJldiA9IHRoaXMuaGFuZGxlcnMsIGRvbSA9IHRoaXMudmlldy5jb250ZW50RE9NO1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJzY3JvbGxcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXNzaXZlID0gIWhhbmRsZXJzW3R5cGVdLmhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcHJldlt0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzICYmIHBhc3NpdmUgIT0gIWV4aXN0cy5oYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50LCB7IHBhc3NpdmUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gcHJldilcbiAgICAgICAgICAgIGlmICh0eXBlICE9IFwic2Nyb2xsXCIgJiYgIWhhbmRsZXJzW3R5cGVdKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgfVxuICAgIGtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gTXVzdCBhbHdheXMgcnVuLCBldmVuIGlmIGEgY3VzdG9tIGhhbmRsZXIgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5ICYmIHRoaXMudGFiRm9jdXNNb2RlID4gLTEgJiYgKCF0aGlzLnRhYkZvY3VzTW9kZSB8fCBEYXRlLm5vdygpIDw9IHRoaXMudGFiRm9jdXNNb2RlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy50YWJGb2N1c01vZGUgPiAwICYmIGV2ZW50LmtleUNvZGUgIT0gMjcgJiYgbW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMudGFiRm9jdXNNb2RlID0gLTE7XG4gICAgICAgIC8vIENocm9tZSBmb3IgQW5kcm9pZCB1c3VhbGx5IGRvZXNuJ3QgZmlyZSBwcm9wZXIga2V5IGV2ZW50cywgYnV0XG4gICAgICAgIC8vIG9jY2FzaW9uYWxseSBkb2VzLCB1c3VhbGx5IHN1cnJvdW5kZWQgYnkgYSBidW5jaCBvZiBjb21wbGljYXRlZFxuICAgICAgICAvLyBjb21wb3NpdGlvbiBjaGFuZ2VzLiBXaGVuIGFuIGVudGVyIG9yIGJhY2tzcGFjZSBrZXkgZXZlbnQgaXNcbiAgICAgICAgLy8gc2VlbiwgaG9sZCBvZmYgb24gaGFuZGxpbmcgRE9NIGV2ZW50cyBmb3IgYSBiaXQsIGFuZCB0aGVuXG4gICAgICAgIC8vIGRpc3BhdGNoIGl0LlxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lICYmICFldmVudC5zeW50aGV0aWMgJiZcbiAgICAgICAgICAgIChldmVudC5rZXlDb2RlID09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT0gOCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkoZXZlbnQua2V5LCBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgRW50ZXIgb24gaU9TIG1ha2VzIHRoZVxuICAgICAgICAvLyB2aXJ0dWFsIGtleWJvYXJkIGdldCBzdHVjayBpbiB0aGUgd3JvbmcgKGxvd2VyY2FzZSlcbiAgICAgICAgLy8gc3RhdGUuIFNvIHdlIGxldCBpdCBnbyB0aHJvdWdoLCBhbmQgdGhlbiwgaW5cbiAgICAgICAgLy8gYXBwbHlET01DaGFuZ2UsIG5vdGlmeSBrZXkgaGFuZGxlcnMgb2YgaXQgYW5kIHJlc2V0IHRvXG4gICAgICAgIC8vIHRoZSBzdGF0ZSB0aGV5IHByb2R1Y2UuXG4gICAgICAgIGxldCBwZW5kaW5nO1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAgICAgICAoKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkua2V5Q29kZSA9PSBldmVudC5rZXlDb2RlKSkgJiYgIWV2ZW50LmN0cmxLZXkgfHxcbiAgICAgICAgICAgICAgICBFbWFjc3lQZW5kaW5nS2V5cy5pbmRleE9mKGV2ZW50LmtleSkgPiAtMSAmJiBldmVudC5jdHJsS2V5ICYmICFldmVudC5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHBlbmRpbmcgfHwgZXZlbnQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2hJT1NLZXkoKSwgMjUwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmx1c2hJT1NLZXkoY2hhbmdlKSB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLnBlbmRpbmdJT1NLZXk7XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYW4gYXV0b2NvcnJlY3Rpb24gYmVmb3JlIEVudGVyXG4gICAgICAgIGlmIChrZXkua2V5ID09IFwiRW50ZXJcIiAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPCBjaGFuZ2UudG8gJiYgL15cXFMrJC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEtleSh0aGlzLnZpZXcuY29udGVudERPTSwga2V5LmtleSwga2V5LmtleUNvZGUsIGtleSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQgPyBrZXkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIS9ea2V5Ly50ZXN0KGV2ZW50LnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAgICAgLy8gT24gc29tZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0b1xuICAgICAgICAvLyBjb25maXJtIGNoYXJhY3RlciBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLFxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlIHNvbWV0aW1lcyBlbWl0dGVkIGluIHRoZVxuICAgICAgICAvLyB3cm9uZyBvcmRlci4gVGhlIGtleSBldmVudCBzaG91bGQgc3RpbGwgYmUgaWdub3JlZCwgZXZlbiB3aGVuXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50LlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWJyb3dzZXIuaW9zICYmIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ICYmIERhdGUubm93KCkgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRNb3VzZVNlbGVjdGlvbihtb3VzZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbW91c2VTZWxlY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRDb250ZW50ICYmIHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IHRoaXMuZHJhZ2dlZENvbnRlbnQubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJpbmRIYW5kbGVyKHBsdWdpbiwgaGFuZGxlcikge1xuICAgIHJldHVybiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwocGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSGFuZGxlcnMocGx1Z2lucykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIHJlY29yZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbdHlwZV0gfHwgKHJlc3VsdFt0eXBlXSA9IHsgb2JzZXJ2ZXJzOiBbXSwgaGFuZGxlcnM6IFtdIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBsZXQgc3BlYyA9IHBsdWdpbi5zcGVjO1xuICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmRvbUV2ZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIGluIHNwZWMuZG9tRXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGxldCBmID0gc3BlYy5kb21FdmVudEhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChiaW5kSGFuZGxlcihwbHVnaW4udmFsdWUsIGYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMgJiYgc3BlYy5kb21FdmVudE9ic2VydmVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc3BlYy5kb21FdmVudE9ic2VydmVycykge1xuICAgICAgICAgICAgICAgIGxldCBmID0gc3BlYy5kb21FdmVudE9ic2VydmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKVxuICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChoYW5kbGVyc1t0eXBlXSk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBvYnNlcnZlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5vYnNlcnZlcnMucHVzaChvYnNlcnZlcnNbdHlwZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0TGluZUJyZWFrXCIgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cbl07XG5jb25zdCBFbWFjc3lQZW5kaW5nS2V5cyA9IFwiZHRoa29cIjtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5jb25zdCBkcmFnU2Nyb2xsTWFyZ2luID0gNjtcbmZ1bmN0aW9uIGRyYWdTY3JvbGxTcGVlZChkaXN0KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGRpc3QpICogMC43ICsgODtcbn1cbmZ1bmN0aW9uIGRpc3QoYSwgYikge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhhLmNsaWVudFggLSBiLmNsaWVudFgpLCBNYXRoLmFicyhhLmNsaWVudFkgLSBiLmNsaWVudFkpKTtcbn1cbmNsYXNzIE1vdXNlU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMgPSBzY3JvbGxhYmxlUGFyZW50cyh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIGRpc3QodGhpcy5zdGFydEV2ZW50LCBldmVudCkgPCAxMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwLCB0b3AgPSAwLCByaWdodCA9IHRoaXMudmlldy53aW4uaW5uZXJXaWR0aCwgYm90dG9tID0gdGhpcy52aWV3Lndpbi5pbm5lckhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50cy54KVxuICAgICAgICAgICAgKHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMuc2Nyb2xsUGFyZW50cy54LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50cy55KVxuICAgICAgICAgICAgKHsgdG9wLCBib3R0b20gfSA9IHRoaXMuc2Nyb2xsUGFyZW50cy55LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbWFyZ2lucy5sZWZ0IDw9IGxlZnQgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSAtZHJhZ1Njcm9sbFNwZWVkKGxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCArIG1hcmdpbnMucmlnaHQgPj0gcmlnaHQgLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WCAtIHJpZ2h0KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFkgLSBtYXJnaW5zLnRvcCA8PSB0b3AgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHRvcCAtIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZICsgbWFyZ2lucy5ib3R0b20gPj0gYm90dG9tIC0gZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gZHJhZ1Njcm9sbFNwZWVkKGV2ZW50LmNsaWVudFkgLSBib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IHRoaXMudmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xuICAgICAgICBpZiAoc3ggfHwgc3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGluZyA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxpbmcgPiAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCgpIHtcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gdGhpcy5zY3JvbGxTcGVlZDtcbiAgICAgICAgaWYgKHggJiYgdGhpcy5zY3JvbGxQYXJlbnRzLngpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy54LnNjcm9sbExlZnQgKz0geDtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ICYmIHRoaXMuc2Nyb2xsUGFyZW50cy55KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMueS5zY3JvbGxUb3AgKz0geTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IHx8IHkpXG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHgsIHkpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgfVxuICAgIHNraXBBdG9tcyhzZWwpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsLnJhbmdlc1tpXSwgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS5mcm9tLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICE9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgdG8gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLnRvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPSByYW5nZS5mcm9tIHx8IHRvICE9IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20gPT0gcmFuZ2UuYW5jaG9yID8gZnJvbSA6IHRvLCByYW5nZS5mcm9tID09IHJhbmdlLmhlYWQgPyBmcm9tIDogdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gc2VsLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlc1tpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcyA/IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSA6IHNlbDtcbiAgICB9XG4gICAgc2VsZWN0KGV2ZW50KSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbGVjdGlvbiA9IHRoaXMuc2tpcEF0b21zKHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSkpO1xuICAgICAgICBpZiAodGhpcy5tdXN0U2VsZWN0IHx8ICFzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3QucG9pbnRlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikpKVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChkcmFnTW92ZXNTZWxlY3Rpb24kMSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gIWV2ZW50LmFsdEtleSA6ICFldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIGJvdW5kYXJ5IGNsaWNrcywgY2hlY2sgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSB0aGVcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoIXNlbCB8fCBzZWwucmFuZ2VDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVjdHMgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSA+PSBldmVudC5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIGNWaWV3OyBub2RlICE9IHZpZXcuY29udGVudERPTTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHwgKChjVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKSkgJiYgY1ZpZXcuaWdub3JlRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGhhbmRsZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBvYnNlcnZlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIHRleHRGaWx0ZXIoc3RhdGUsIGZhY2V0LCB0ZXh0KSB7XG4gICAgZm9yIChsZXQgZmlsdGVyIG9mIHN0YXRlLmZhY2V0KGZhY2V0KSlcbiAgICAgICAgdGV4dCA9IGZpbHRlcih0ZXh0LCBzdGF0ZSk7XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIGlucHV0KSB7XG4gICAgaW5wdXQgPSB0ZXh0RmlsdGVyKHZpZXcuc3RhdGUsIGNsaXBib2FyZElucHV0RmlsdGVyLCBpbnB1dCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMsIGkgPSAxLCB0ZXh0ID0gc3RhdGUudG9UZXh0KGlucHV0KTtcbiAgICBsZXQgYnlMaW5lID0gdGV4dC5saW5lcyA9PSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDtcbiAgICBsZXQgbGluZXdpc2UgPSBsYXN0TGluZXdpc2VDb3B5ICE9IG51bGwgJiYgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5ldmVyeShyID0+IHIuZW1wdHkpICYmIGxhc3RMaW5ld2lzZUNvcHkgPT0gdGV4dC50b1N0cmluZygpO1xuICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICBsZXQgbGFzdExpbmUgPSAtMTtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA9PSBsYXN0TGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgbGFzdExpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gc3RhdGUudG9UZXh0KChieUxpbmUgPyB0ZXh0LmxpbmUoaSsrKS50ZXh0IDogaW5wdXQpICsgc3RhdGUubGluZUJyZWFrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgaW5zZXJ0Lmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5TGluZSkge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRleHQubGluZShpKyspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogbGluZS50ZXh0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGxpbmUubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKGNoYW5nZXMsIHtcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnBhc3RlXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgfSk7XG59XG5vYnNlcnZlcnMuc2Nyb2xsID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3A7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0ID0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdDtcbn07XG5oYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdFwiKTtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNyAmJiB2aWV3LmlucHV0U3RhdGUudGFiRm9jdXNNb2RlICE9IDApXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSBEYXRlLm5vdygpICsgMjAwMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xub2JzZXJ2ZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xub2JzZXJ2ZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID4gRGF0ZS5ub3coKSAtIDIwMDApXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgbGV0IHN0eWxlID0gbnVsbDtcbiAgICBmb3IgKGxldCBtYWtlU3R5bGUgb2Ygdmlldy5zdGF0ZS5mYWNldChtb3VzZVNlbGVjdGlvblN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XG4gICAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlICYmIGV2ZW50LmJ1dHRvbiA9PSAwKVxuICAgICAgICBzdHlsZSA9IGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgbXVzdEZvY3VzID0gIXZpZXcuaGFzRm9jdXM7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKG5ldyBNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCwgc3R5bGUsIG11c3RGb2N1cykpO1xuICAgICAgICBpZiAobXVzdEZvY3VzKVxuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlICYmICFhY3RpdmUuY29udGFpbnModmlldy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLmJsdXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsZXQgbW91c2VTZWwgPSB2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb247XG4gICAgICAgIGlmIChtb3VzZVNlbCkge1xuICAgICAgICAgICAgbW91c2VTZWwuc3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIG1vdXNlU2VsLmRyYWdnaW5nID09PSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gcmFuZ2VGb3JDbGljayh2aWV3LCBwb3MsIGJpYXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSAxKSB7IC8vIFNpbmdsZSBjbGlja1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09IDIpIHsgLy8gRG91YmxlIGNsaWNrXG4gICAgICAgIHJldHVybiBncm91cEF0KHZpZXcuc3RhdGUsIHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBUcmlwbGUgY2xpY2tcbiAgICAgICAgbGV0IHZpc3VhbCA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0U3RhcnQgOiBsaW5lLmZyb20sIHRvID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogbGluZS50bztcbiAgICAgICAgaWYgKHRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoICYmIHRvID09IGxpbmUudG8pXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5sZXQgaW5zaWRlID0gKHgsIHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbSAmJiB4ID49IHJlY3QubGVmdCAmJiB4IDw9IHJlY3QucmlnaHQ7XG4vLyBUcnkgdG8gZGV0ZXJtaW5lLCBmb3IgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxuLy8gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuZnVuY3Rpb24gZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIHgsIHkpIHtcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcbiAgICAvLyBMaW5lIGJvdW5kYXJpZXMgcG9pbnQgaW50byB0aGUgbGluZVxuICAgIGlmIChvZmYgPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG9mZiA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcbiAgICBsZXQgYmVmb3JlID0gbGluZS5jb29yZHNBdChvZmYsIC0xKTtcbiAgICBpZiAoYmVmb3JlICYmIGluc2lkZSh4LCB5LCBiZWZvcmUpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGFmdGVyID0gbGluZS5jb29yZHNBdChvZmYsIDEpO1xuICAgIGlmIChhZnRlciAmJiBpbnNpZGUoeCwgeSwgYWZ0ZXIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGluZSB3cmFwIHBvaW50LiBQaWNrIGJlZm9yZSBpZiB0aGUgcG9pbnQgaXNcbiAgICAvLyBhYm92ZSBpdHMgYm90dG9tLlxuICAgIHJldHVybiBiZWZvcmUgJiYgYmVmb3JlLmJvdHRvbSA+PSB5ID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gcXVlcnlQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIHJldHVybiB7IHBvcywgYmlhczogZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpIH07XG59XG5jb25zdCBCYWRNb3VzZURldGFpbCA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xubGV0IGxhc3RNb3VzZURvd24gPSBudWxsLCBsYXN0TW91c2VEb3duQ291bnQgPSAwLCBsYXN0TW91c2VEb3duVGltZSA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgbGFzdE1vdXNlRG93blRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxuICAgICAgICBNYXRoLmFicyhsYXN0LmNsaWVudFkgLSBldmVudC5jbGllbnRZKSA8IDIpID8gKGxhc3RNb3VzZURvd25Db3VudCArIDEpICUgMyA6IDE7XG59XG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCB0eXBlID0gZ2V0Q2xpY2tUeXBlKGV2ZW50KTtcbiAgICBsZXQgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgcmVtb3ZlZDtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUgJiYgdHlwZSA9PSAxICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIChyZW1vdmVkID0gcmVtb3ZlUmFuZ2VBcm91bmQoc3RhcnRTZWwsIGN1ci5wb3MpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFuZ2VBcm91bmQoc2VsLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLnNsaWNlKDAsIGkpLmNvbmNhdChzZWwucmFuZ2VzLnNsaWNlKGkgKyAxKSksIHNlbC5tYWluSW5kZXggPT0gaSA/IDAgOiBzZWwubWFpbkluZGV4IC0gKHNlbC5tYWluSW5kZXggPiBpID8gMSA6IDApKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbjogcmFuZ2UgfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgY1ZpZXcgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoY1ZpZXcgJiYgY1ZpZXcuaXNXaWRnZXQpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY1ZpZXcucG9zQXRTdGFydCwgdG8gPSBmcm9tICsgY1ZpZXcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgaW5wdXRTdGF0ZSB9ID0gdmlldztcbiAgICBpZiAoaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IHRydWU7XG4gICAgaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IHJhbmdlO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkT3V0cHV0RmlsdGVyLCB2aWV3LnN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgZGlyZWN0KSB7XG4gICAgdGV4dCA9IHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkSW5wdXRGaWx0ZXIsIHRleHQpO1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCB7IGRyYWdnZWRDb250ZW50IH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBkcmFnZ2VkQ29udGVudCAmJiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpXG4gICAgICAgID8geyBmcm9tOiBkcmFnZ2VkQ29udGVudC5mcm9tLCB0bzogZHJhZ2dlZENvbnRlbnQudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgZGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogdGV4dEZpbHRlcihzdGF0ZSwgY2xpcGJvYXJkT3V0cHV0RmlsdGVyLCBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IGlzRm9jdXNDaGFuZ2UgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBnZXRFZmZlY3Qgb2Ygc3RhdGUuZmFjZXQoZm9jdXNDaGFuZ2VFZmZlY3QpKSB7XG4gICAgICAgIGxldCBlZmZlY3QgPSBnZXRFZmZlY3Qoc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgaWYgKGVmZmVjdClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cyA/IHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHMsIGFubm90YXRpb25zOiBpc0ZvY3VzQ2hhbmdlLm9mKHRydWUpIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24odmlldy5zdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfVxuICAgIH0sIDEwKTtcbn1cbm9ic2VydmVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBXaGVuIGZvY3VzaW5nIHJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24sIG1vdmUgaXQgYmFjayB0byB3aGVyZSBpdCB3YXNcbiAgICBpZiAoIXZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAmJiAodmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgfHwgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0KSkge1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25zdGFydCA9IG9ic2VydmVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KVxuICAgICAgICByZXR1cm47IC8vIENvbXBvc2l0aW9uIGhhbmRsZWQgYnkgZWRpdCBjb250ZXh0XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID09IG51bGwpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgLy8gRklYTUUgcG9zc2libHkgc2V0IGEgdGltZW91dCB0byBjbGVhciBpdCBhZ2FpbiBvbiBBbmRyb2lkXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgIH1cbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25lbmQgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5vYnNlcnZlci5lZGl0Q29udGV4dClcbiAgICAgICAgcmV0dXJuOyAvLyBDb21wb3NpdGlvbiBoYW5kbGVkIGJ5IGVkaXQgY29udGV4dFxuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAtMTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gdHJ1ZTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gdmlldy5vYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA+IDA7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQpIHtcbiAgICAgICAgLy8gRGVsYXkgZmx1c2hpbmcgZm9yIGEgYml0IG9uIEFuZHJvaWQgYmVjYXVzZSBpdCdsbCBvZnRlbiBmaXJlIGFcbiAgICAgICAgLy8gYnVuY2ggb2YgY29udHJhZGljdG9yeSBjaGFuZ2VzIGluIGEgcm93IGF0IGVuZCBvZiBjb21wb3NpdG9uXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UpIHtcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgcGVuZGluZyByZWNvcmRzLCBzY2hlZHVsZSBhIGZsdXNoLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcub2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIG1ha2Ugc3VyZSB0aGF0LCBpZiBubyBjaGFuZ2VzIGNvbWUgaW4gc29vbiwgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIHZpZXcgaXMgY2xlYXJlZC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDAgJiYgdmlldy5kb2NWaWV3Lmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG5vYnNlcnZlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdENvbnRleHRNZW51ID0gRGF0ZS5ub3coKTtcbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gSW4gRWRpdENvbnRleHQgbW9kZSwgd2UgbXVzdCBoYW5kbGUgaW5zZXJ0UmVwbGFjZW1lbnRUZXh0IGV2ZW50c1xuICAgIC8vIGRpcmVjdGx5LCB0byBtYWtlIHNwZWxsIGNoZWNraW5nIGNvcnJlY3Rpb25zIHdvcmtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgJiYgdmlldy5vYnNlcnZlci5lZGl0Q29udGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IChfYSA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCByYW5nZXMgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRleHQgJiYgcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHIgPSByYW5nZXNbMF07XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZpZXcucG9zQXRET00oci5zdGFydENvbnRhaW5lciwgci5zdGFydE9mZnNldCksIHRvID0gdmlldy5wb3NBdERPTShyLmVuZENvbnRhaW5lciwgci5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCB7IGZyb20sIHRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUudG9UZXh0KHRleHQpIH0sIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmVjYXVzZSBDaHJvbWUgQW5kcm9pZCBkb2Vzbid0IGZpcmUgdXNlZnVsIGtleSBldmVudHMsIHVzZVxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxuICAgIC8vIGJ1dCB0aG9zZSB1c3VhbGx5IGRvbid0IGV2ZW4gc2VlbSB0byBmaXJlIGJlZm9yZWlucHV0IGV2ZW50cyBhdFxuICAgIC8vIHRoZSBtb21lbnQpIGFuZCBmYWtlIGEga2V5IGV2ZW50IGZvciBpdC5cbiAgICAvL1xuICAgIC8vIChwcmV2ZW50RGVmYXVsdCBvbiBiZWZvcmVpbnB1dCwgdGhvdWdoIHN1cHBvcnRlZCBpbiB0aGUgc3BlYyxcbiAgICAvLyBzZWVtcyB0byBkbyBub3RoaW5nIGF0IGFsbCBvbiBDaHJvbWUpLlxuICAgIGxldCBwZW5kaW5nO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkuaW5wdXRUeXBlID09IGV2ZW50LmlucHV0VHlwZSkpKSB7XG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHBlbmRpbmcua2V5LCBwZW5kaW5nLmtleUNvZGUpO1xuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRWaWV3SGVpZ2h0ID0gKChfYiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrc3BhY2luZyBuZWFyIHVuZWRpdGFibGUgbm9kZXMgb24gQ2hyb21lIEFuZHJvaWQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzIHRoZSB2aXJ0dWFsIGtleWJvYXJkLiBUaGlzIHRyaWVzIHRvIGNydWRlbHkgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDApID4gc3RhcnRWaWV3SGVpZ2h0ICsgMTAgJiYgdmlldy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYnJvd3Nlci5pb3MgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIikge1xuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIERPTSBjaGFuZ2VzIChhbmQgYmVmb3JlaW5wdXQpIGhhcHBlbiBfYmVmb3JlX1xuICAgICAgICAvLyB0aGUga2V5IGV2ZW50IGZvciBjdHJsLWQgb24gaU9TIHdoZW4gdXNpbmcgYW4gZXh0ZXJuYWxcbiAgICAgICAgLy8ga2V5Ym9hcmQuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgfVxuICAgIC8vIFNhZmFyaSB3aWxsIG9jY2FzaW9uYWxseSBmb3JnZXQgdG8gZmlyZSBjb21wb3NpdGlvbmVuZCBhdCB0aGUgZW5kIG9mIGEgZGVhZC1rZXkgY29tcG9zaXRpb25cbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0VGV4dFwiICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9ic2VydmVycy5jb21wb3NpdGlvbmVuZCh2aWV3LCBldmVudCksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGFwcGxpZWRGaXJlZm94SGFjayA9IC8qQF9fUFVSRV9fKi9uZXcgU2V0O1xuLy8gSW4gRmlyZWZveCwgd2hlbiBjdXQvY29weSBoYW5kbGVycyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50LCB0aGF0XG4vLyBzb21laG93IGF2b2lkcyBhIGJ1ZyB3aGVyZSB0aG9zZSBldmVudHMgYXJlbid0IGZpcmVkIHdoZW4gdGhlXG4vLyBzZWxlY3Rpb24gaXMgZW1wdHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzEwODJcbi8vIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05OTU5NjFcbmZ1bmN0aW9uIGZpcmVmb3hDb3B5Q3V0SGFjayhkb2MpIHtcbiAgICBpZiAoIWFwcGxpZWRGaXJlZm94SGFjay5oYXMoZG9jKSkge1xuICAgICAgICBhcHBsaWVkRmlyZWZveEhhY2suYWRkKGRvYyk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCAoKSA9PiB7IH0pO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCAoKSA9PiB7IH0pO1xuICAgIH1cbn1cblxuY29uc3Qgd3JhcHBpbmdXaGl0ZVNwYWNlID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcbi8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG5sZXQgaGVpZ2h0Q2hhbmdlRmxhZyA9IGZhbHNlO1xuZnVuY3Rpb24gY2xlYXJIZWlnaHRDaGFuZ2VGbGFnKCkgeyBoZWlnaHRDaGFuZ2VGbGFnID0gZmFsc2U7IH1cbmNsYXNzIEhlaWdodE9yYWNsZSB7XG4gICAgY29uc3RydWN0b3IobGluZVdyYXBwaW5nKSB7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmRvYyA9IFRleHQuZW1wdHk7XG4gICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiBhbiBlbnRpcmUgbGluZSAobGluZS1oZWlnaHQpXG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgdGhlIGFjdHVhbCBmb250IChmb250LXNpemUpXG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IDMwO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgKiBsaW5lcztcbiAgICB9XG4gICAgaGVpZ2h0Rm9yTGluZShsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lcyA9IDEgKyBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlbmd0aCAtIHRoaXMubGluZUxlbmd0aCkgLyAodGhpcy5saW5lTGVuZ3RoIC0gNSkpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xuICAgIH1cbiAgICBzZXREb2MoZG9jKSB7IHRoaXMuZG9jID0gZG9jOyByZXR1cm4gdGhpczsgfVxuICAgIG11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSkge1xuICAgICAgICByZXR1cm4gKHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTEpICE9IHRoaXMubGluZVdyYXBwaW5nO1xuICAgIH1cbiAgICBtdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpIHtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVIZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGxpbmVIZWlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldKSB7IC8vIFJvdW5kIHRvIC4xIHBpeGVsc1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuICAgIHJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5yb3VuZChsaW5lSGVpZ2h0KSAhPSBNYXRoLnJvdW5kKHRoaXMubGluZUhlaWdodCkgfHwgdGhpcy5saW5lV3JhcHBpbmcgIT0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSBjaGFyV2lkdGg7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRleHRIZWlnaHQ7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IGxpbmVMZW5ndGg7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga25vd25IZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBrbm93bkhlaWdodHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGggPCAwKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxufVxuLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBieSBgdXBkYXRlSGVpZ2h0YCB0byBtYWtlIERPTSBtZWFzdXJlbWVudHNcbi8vIGFycml2ZSBhdCB0aGUgcmlnaHQgbmlkZXMuIFRoZSBgaGVpZ2h0c2AgYXJyYXkgaXMgYSBzZXF1ZW5jZSBvZlxuLy8gYmxvY2sgaGVpZ2h0cywgc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiBgZnJvbWAuXG5jbGFzcyBNZWFzdXJlZEhlaWdodHMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIGhlaWdodHMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5oZWlnaHRzID0gaGVpZ2h0cztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIGdldCBtb3JlKCkgeyByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuaGVpZ2h0cy5sZW5ndGg7IH1cbn1cbi8qKlxuUmVjb3JkIHVzZWQgdG8gcmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgYmxvY2stbGV2ZWwgZWxlbWVudFxuaW4gdGhlIGVkaXRvciB2aWV3LlxuKi9cbmNsYXNzIEJsb2NrSW5mbyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICBkb2N1bWVudCkuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIEl0cyBoZWlnaHQuXG4gICAgKi9cbiAgICBoZWlnaHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbCBXZWlyZCBwYWNrZWQgZmllbGQgdGhhdCBob2xkcyBhbiBhcnJheSBvZiBjaGlsZHJlblxuICAgIGZvciBjb21wb3NpdGUgYmxvY2tzLCBhIGRlY29yYXRpb24gZm9yIGJsb2NrIHdpZGdldHMsIGFuZCBhXG4gICAgbnVtYmVyIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiB3aWRnZXQtY3JlYXRlIGxpbmUgYnJlYWtzIGZvclxuICAgIHRleHQgYmxvY2tzLlxuICAgICovXG4gICAgX2NvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IF9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBlbGVtZW50IHRoaXMgaXMuIFdoZW4gcXVlcnlpbmcgbGluZXMsIHRoaXMgbWF5IGJlXG4gICAgYW4gYXJyYXkgb2YgYWxsIHRoZSBibG9ja3MgdGhhdCBtYWtlIHVwIHRoZSBsaW5lLlxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gQmxvY2tUeXBlLlRleHQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiB0aGlzLl9jb250ZW50LnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHdpZGdldCBibG9jaywgdGhpcyB3aWxsIHJldHVybiB0aGUgd2lkZ2V0XG4gICAgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gPyB0aGlzLl9jb250ZW50LndpZGdldCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB0ZXh0YmxvY2ssIHRoaXMgaG9sZHMgdGhlIG51bWJlciBvZiBsaW5lIGJyZWFrc1xuICAgIHRoYXQgYXBwZWFyIGluIHdpZGdldHMgaW5zaWRlIHRoZSBibG9jay5cbiAgICAqL1xuICAgIGdldCB3aWRnZXRMaW5lQnJlYWtzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IHRoaXMuX2NvbnRlbnQgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAoQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIuX2NvbnRlbnQpID8gb3RoZXIuX2NvbnRlbnQgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBjb250ZW50KTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcbmNvbnN0IEVwc2lsb24gPSAxZS0zO1xuY2xhc3MgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2YgdGhpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgIGZsYWdzID0gMiAvKiBGbGFnLk91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogRmxhZy5PdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSB8ICh0aGlzLmZsYWdzICYgfjIgLyogRmxhZy5PdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIGhlaWdodCkgPiBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsIGRvYyA9IG9yYWNsZS5kb2M7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLnNldERvYyhvbGREb2MpLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLnNldERvYyhkb2MpLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IHJlcGxhY2UobWUsIG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWUudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHsgcmV0dXJuIG5ldyBIZWlnaHRNYXBUZXh0KDAsIDApOyB9XG4gICAgLy8gbm9kZXMgdXNlcyBudWxsIHZhbHVlcyB0byBpbmRpY2F0ZSB0aGUgcG9zaXRpb24gb2YgbGluZSBicmVha3MuXG4gICAgLy8gVGhlcmUgYXJlIG5ldmVyIGxpbmUgYnJlYWtzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGFycmF5LCBvclxuICAgIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxuICAgIC8vIHRvIGJlIGVtcHR5IChzYW1lIHJlc3RyaWN0aW9ucyBhcyByZXR1cm4gdmFsdWUgZnJvbSB0aGUgYnVpbGRlcikuXG4gICAgc3RhdGljIG9mKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICAgICAgbGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoLCBiZWZvcmUgPSAwLCBhZnRlciA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID4gYWZ0ZXIgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMSArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPiBiZWZvcmUgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDIgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSA8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1tpKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1stLWpdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBhZnRlciArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJyayA9IDA7XG4gICAgICAgIGlmIChub2Rlc1tpIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2Rlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGVpZ2h0TWFwQnJhbmNoKEhlaWdodE1hcC5vZihub2Rlcy5zbGljZSgwLCBpKSksIGJyaywgSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKGopKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZShvbGQsIHZhbCkge1xuICAgIGlmIChvbGQgPT0gdmFsKVxuICAgICAgICByZXR1cm4gb2xkO1xuICAgIGlmIChvbGQuY29uc3RydWN0b3IgIT0gdmFsLmNvbnN0cnVjdG9yKVxuICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICByZXR1cm4gdmFsO1xufVxuSGVpZ2h0TWFwLnByb3RvdHlwZS5zaXplID0gMTtcbmNsYXNzIEhlaWdodE1hcEJsb2NrIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCwgZGVjbykge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuZGVjbyA9IGRlY287XG4gICAgfVxuICAgIGJsb2NrQXQoX2hlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy5kZWNvIHx8IDApO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KDAsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBpZiAoZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiB0byA+PSBvZmZzZXQpXG4gICAgICAgICAgICBmKHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIF9mb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBibG9jaygke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBUZXh0IGV4dGVuZHMgSGVpZ2h0TWFwQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0LCBudWxsKTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSAwOyAvLyBBbW91bnQgb2YgY29sbGFwc2VkIGNvbnRlbnQgaW4gdGhlIGxpbmVcbiAgICAgICAgdGhpcy53aWRnZXRIZWlnaHQgPSAwOyAvLyBNYXhpbXVtIGlubGluZSB3aWRnZXQgaGVpZ2h0XG4gICAgICAgIHRoaXMuYnJlYWtzID0gMDsgLy8gTnVtYmVyIG9mIHdpZGdldC1pbnRyb2R1Y2VkIGxpbmUgYnJlYWtzIG9uIHRoZSBsaW5lXG4gICAgfVxuICAgIGJsb2NrQXQoX2hlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy5icmVha3MpO1xuICAgIH1cbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSAmJiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJiAobm9kZS5mbGFncyAmIDQgLyogRmxhZy5TaW5nbGVMaW5lICovKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMubGVuZ3RoIC0gbm9kZS5sZW5ndGgpIDwgMTApIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgSGVpZ2h0TWFwVGV4dChub2RlLmxlbmd0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0ZGF0ZWQpXG4gICAgICAgICAgICAgICAgbm9kZS5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSArXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3MgKiBvcmFjbGUubGluZUhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYGxpbmUoJHt0aGlzLmxlbmd0aH0ke3RoaXMuY29sbGFwc2VkID8gLXRoaXMuY29sbGFwc2VkIDogXCJcIn0ke3RoaXMud2lkZ2V0SGVpZ2h0ID8gXCI6XCIgKyB0aGlzLndpZGdldEhlaWdodCA6IFwiXCJ9KWA7XG4gICAgfVxufVxuY2xhc3MgSGVpZ2h0TWFwR2FwIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHsgc3VwZXIobGVuZ3RoLCAwKTsgfVxuICAgIGhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IG9yYWNsZS5kb2MubGluZUF0KG9mZnNldCkubnVtYmVyLCBsYXN0TGluZSA9IG9yYWNsZS5kb2MubGluZUF0KG9mZnNldCArIHRoaXMubGVuZ3RoKS5udW1iZXI7XG4gICAgICAgIGxldCBsaW5lcyA9IGxhc3RMaW5lIC0gZmlyc3RMaW5lICsgMTtcbiAgICAgICAgbGV0IHBlckxpbmUsIHBlckNoYXIgPSAwO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IHRvdGFsUGVyTGluZSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCBvcmFjbGUubGluZUhlaWdodCAqIGxpbmVzKTtcbiAgICAgICAgICAgIHBlckxpbmUgPSB0b3RhbFBlckxpbmUgLyBsaW5lcztcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IGxpbmVzICsgMSlcbiAgICAgICAgICAgICAgICBwZXJDaGFyID0gKHRoaXMuaGVpZ2h0IC0gdG90YWxQZXJMaW5lKSAvICh0aGlzLmxlbmd0aCAtIGxpbmVzIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZXJMaW5lID0gdGhpcy5oZWlnaHQgLyBsaW5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ3Vlc3MgPSBvZmZzZXQgKyAoaGVpZ2h0IDwgb3JhY2xlLmxpbmVIZWlnaHQgPyAwXG4gICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChoZWlnaHQgLSB0b3ApIC8gdGhpcy5oZWlnaHQpKSAqIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KGd1ZXNzKSwgbGluZUhlaWdodCA9IHBlckxpbmUgKyBsaW5lLmxlbmd0aCAqIHBlckNoYXI7XG4gICAgICAgICAgICBsZXQgbGluZVRvcCA9IE1hdGgubWF4KHRvcCwgaGVpZ2h0IC0gbGluZUhlaWdodCAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gcGVyTGluZSkpKTtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIGxlbmd0aCB9ID0gb3JhY2xlLmRvYy5saW5lKGZpcnN0TGluZSArIGxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBwZXJMaW5lICogbGluZSwgcGVyTGluZSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQodmFsdWUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IG9yYWNsZS5kb2MubGluZUF0KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIHRvIC0gZnJvbSwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KHZhbHVlKSwgbGluZUhlaWdodCA9IHBlckxpbmUgKyBsaW5lLmxlbmd0aCAqIHBlckNoYXI7XG4gICAgICAgIGxldCBsaW5lc0Fib3ZlID0gbGluZS5udW1iZXIgLSBmaXJzdExpbmU7XG4gICAgICAgIGxldCBsaW5lVG9wID0gdG9wICsgcGVyTGluZSAqIGxpbmVzQWJvdmUgKyBwZXJDaGFyICogKGxpbmUuZnJvbSAtIG9mZnNldCAtIGxpbmVzQWJvdmUpO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBNYXRoLm1heCh0b3AsIE1hdGgubWluKGxpbmVUb3AsIHRvcCArIHRoaXMuaGVpZ2h0IC0gbGluZUhlaWdodCkpLCBsaW5lSGVpZ2h0LCAwKTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIG9mZnNldCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odG8sIG9mZnNldCArIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tLCBsaW5lVG9wID0gdG9wOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zID09IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICAgICAgICAgIGxpbmVUb3AgKz0gcGVyTGluZSAqIGxpbmVzQWJvdmUgKyBwZXJDaGFyICogKGZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIHBlckNoYXIgKiBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGYobmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCAwKSk7XG4gICAgICAgICAgICBsaW5lVG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxlbmd0aCAtIHRvO1xuICAgICAgICBpZiAoYWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gPSBuZXcgSGVpZ2h0TWFwR2FwKGxhc3QubGVuZ3RoICsgYWZ0ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChhZnRlciAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA+IDApIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzWzBdID0gbmV3IEhlaWdodE1hcEdhcChmcm9tICsgZmlyc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy51bnNoaWZ0KG5ldyBIZWlnaHRNYXBHYXAoZnJvbSAtIDEpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBIZWlnaHRNYXBHYXAodG8gLSAxKSwgbnVsbCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKHRoaXMubGVuZ3RoIC0gZnJvbSAtIDEpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICAvLyBGaWxsIGluIHBhcnQgb2YgdGhpcyBnYXAgd2l0aCBtZWFzdXJlZCBsaW5lcy4gV2Uga25vdyB0aGVyZVxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgd2lkZ2V0cyBvciBjb2xsYXBzZWQgcmFuZ2VzIGluIHRob3NlIGxpbmVzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGV5IHdvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBoZWlnaHRtYXAgKGdhcHNcbiAgICAgICAgICAgIC8vIG9ubHkgY29udGFpbiBwbGFpbiB0ZXh0KS5cbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdLCBwb3MgPSBNYXRoLm1heChvZmZzZXQsIG1lYXN1cmVkLmZyb20pLCBzaW5nbGVIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIGlmIChtZWFzdXJlZC5mcm9tID4gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IEhlaWdodE1hcEdhcChtZWFzdXJlZC5mcm9tIC0gb2Zmc2V0IC0gMSkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDw9IGVuZCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IG9yYWNsZS5kb2MubGluZUF0KHBvcykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUhlaWdodCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGhlaWdodCAtIHNpbmdsZUhlaWdodCkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gLTI7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dChsZW4sIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGluZS5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoZW5kIC0gcG9zKS51cGRhdGVIZWlnaHQob3JhY2xlLCBwb3MpKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUhlaWdodCA8IDAgfHwgTWF0aC5hYnMocmVzdWx0LmhlaWdodCAtIHRoaXMuaGVpZ2h0KSA+PSBFcHNpbG9uIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoc2luZ2xlSGVpZ2h0IC0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KS5wZXJMaW5lKSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcEJyYW5jaCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgYnJrLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkpO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgfVxuICAgIGdldCBicmVhaygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxIC8qIEZsYWcuQnJlYWsgKi87IH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgbWlkID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8IG1pZCA/IHRoaXMubGVmdC5ibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5ibG9ja0F0KGhlaWdodCwgb3JhY2xlLCBtaWQsIG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGxldCBsZWZ0ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQgPyB2YWx1ZSA8IHJpZ2h0VG9wIDogdmFsdWUgPCByaWdodE9mZnNldDtcbiAgICAgICAgbGV0IGJhc2UgPSBsZWZ0ID8gdGhpcy5sZWZ0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgfHwgKGxlZnQgPyBiYXNlLnRvIDwgcmlnaHRPZmZzZXQgOiBiYXNlLmZyb20gPiByaWdodE9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xuICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmpvaW4odGhpcy5yaWdodC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIG9yYWNsZSwgdG9wLCBvZmZzZXQpLmpvaW4oYmFzZSk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAodG8gPj0gcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBtaWQuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgbWlkLmZyb20gLSAxLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcbiAgICAgICAgICAgICAgICBmKG1pZCk7XG4gICAgICAgICAgICBpZiAodG8gPiBtaWQudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0byA8IHJpZ2h0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcbiAgICAgICAgaWYgKGZyb20gPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZnJvbSAtIHJpZ2h0U3RhcnQsIHRvIC0gcmlnaHRTdGFydCwgbm9kZXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZUxlZnQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIGxlZnQgLSAxKTtcbiAgICAgICAgaWYgKHRvIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVJpZ2h0KHRvLCByZXN1bHQpO1xuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YocmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRvIDw9IGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBpZiAodG8gPj0gbGVmdClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPiBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KHRvIC0gbGVmdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCwgcmlnaHQgPSBsZWZ0ICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kZWNvbXBvc2VSaWdodChmcm9tIC0gcmlnaHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChmcm9tIDwgbGVmdClcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayAmJiBmcm9tIDwgcmlnaHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGJhbGFuY2VkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YodGhpcy5icmVhayA/IFtsZWZ0LCBudWxsLCByaWdodF0gOiBbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gcmVwbGFjZSh0aGlzLmxlZnQsIGxlZnQpO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmVwbGFjZSh0aGlzLnJpZ2h0LCByaWdodCk7XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrICsgcmlnaHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIGxlZnQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSBsZWZ0ID0gbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IHJpZ2h0U3RhcnQgKyByaWdodC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UpO1xuICAgICAgICBpZiAocmViYWxhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyB0aGlzLnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxufVxuZnVuY3Rpb24gbWVyZ2VHYXBzKG5vZGVzLCBhcm91bmQpIHtcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICBpZiAobm9kZXNbYXJvdW5kXSA9PSBudWxsICYmXG4gICAgICAgIChiZWZvcmUgPSBub2Rlc1thcm91bmQgLSAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiZcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICBub2Rlcy5zcGxpY2UoYXJvdW5kIC0gMSwgMywgbmV3IEhlaWdodE1hcEdhcChiZWZvcmUubGVuZ3RoICsgMSArIGFmdGVyLmxlbmd0aCkpO1xufVxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xuY2xhc3MgTm9kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgb3JhY2xlKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm9yYWNsZSA9IG9yYWNsZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSAtMTtcbiAgICAgICAgdGhpcy5jb3ZlcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xuICAgIH1cbiAgICBnZXQgaXNDb3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcbiAgICB9XG4gICAgc3BhbihfZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0bywgdGhpcy5saW5lRW5kKSwgbGFzdCA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA+IHRoaXMucG9zIHx8ICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoZW5kIC0gdGhpcy5wb3MsIC0xKSk7XG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcbiAgICAgICAgICAgIGlmICh0byA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBkZWNvLmhlaWdodFJlbGV2YW50KSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgOiAwO1xuICAgICAgICAgICAgbGV0IGJyZWFrcyA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQubGluZUJyZWFrcyA6IDA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMClcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBicmVha3MgfHwgaGVpZ2h0ID49IHJlbGV2YW50V2lkZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhbihmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5saW5lRW5kID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcykudG87XG4gICAgfVxuICAgIGVudGVyTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcbiAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQodGhpcy5wb3MgLSBmcm9tLCAtMSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBibGFua0NvbnRlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG5ldyBIZWlnaHRNYXBHYXAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXG4gICAgICAgICAgICBnYXAuZmxhZ3MgfD0gNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi87XG4gICAgICAgIHJldHVybiBnYXA7XG4gICAgfVxuICAgIGVuc3VyZUxpbmUoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGFkZEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBkZWNvID0gYmxvY2suZGVjbztcbiAgICAgICAgaWYgKGRlY28gJiYgZGVjby5zdGFydFNpZGUgPiAwICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uZW5kU2lkZSA+IDApXG4gICAgICAgICAgICB0aGlzLmNvdmVyaW5nID0gYmxvY2s7XG4gICAgfVxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgYnJlYWtzLCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIGxpbmUuYnJlYWtzICs9IGJyZWFrcztcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2goZnJvbSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID09IDAgPyBudWxsIDogdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSAmJiAhKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KSAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoMCwgLTEpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBsYXN0ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIHRoaXMucG9zKSk7XG4gICAgICAgIGxldCBwb3MgPSBmcm9tO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUhlaWdodCh0aGlzLm9yYWNsZSwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBub2RlID8gbm9kZS5sZW5ndGggOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbGVkIHdpdGggYSByZWdpb24gdGhhdCBvbiBib3RoIHNpZGVzIGVpdGhlciBzdHJldGNoZXNcbiAgICAvLyB0byBhIGxpbmUgYnJlYWsgb3IgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgLy8gVGhlIHJldHVybmVkIGFycmF5IHVzZXMgbnVsbCB0byBpbmRpY2F0ZSBsaW5lIGJyZWFrcywgYnV0IG5ldmVyXG4gICAgLy8gc3RhcnRzIG9yIGVuZHMgaW4gYSBsaW5lIGJyZWFrLCBvciBoYXMgbXVsdGlwbGUgbGluZSBicmVha3MgbmV4dFxuICAgIC8vIHRvIGVhY2ggb3RoZXIuXG4gICAgc3RhdGljIGJ1aWxkKG9yYWNsZSwgZGVjb3JhdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IE5vZGVCdWlsZGVyKGZyb20sIG9yYWNsZSk7XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlciwgMCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaChmcm9tKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvcjtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXAsIDApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoKSB7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8sIGEsIGIpIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBhICYmIGEuaGVpZ2h0UmVsZXZhbnQgfHwgYiAmJiBiLmhlaWdodFJlbGV2YW50KVxuICAgICAgICAgICAgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcywgNSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXNpYmxlUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKHdpbi5pbm5lcldpZHRoLCByZWN0LnJpZ2h0KTtcbiAgICBsZXQgdG9wID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApLCBib3R0b20gPSBNYXRoLm1pbih3aW4uaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keTspIHtcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWx0KTtcbiAgICAgICAgICAgIGlmICgoZWx0LnNjcm9sbEhlaWdodCA+IGVsdC5jbGllbnRIZWlnaHQgfHwgZWx0LnNjcm9sbFdpZHRoID4gZWx0LmNsaWVudFdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBhcmVudFJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGFyZW50UmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4ocGFyZW50ID09IGRvbS5wYXJlbnROb2RlID8gd2luLmlubmVySGVpZ2h0IDogYm90dG9tLCBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBzdHlsZS5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIgfHwgc3R5bGUucG9zaXRpb24gPT0gXCJmaXhlZFwiID8gZWx0Lm9mZnNldFBhcmVudCA6IGVsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gcmVjdC5sZWZ0LCByaWdodDogTWF0aC5tYXgobGVmdCwgcmlnaHQpIC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApLCBib3R0b206IE1hdGgubWF4KHRvcCwgYm90dG9tKSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG5mdW5jdGlvbiBmdWxsUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBwYWRkaW5nVG9wLCBib3R0b206IHJlY3QuYm90dG9tIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbi8vIExpbmUgZ2FwcyBhcmUgcGxhY2Vob2xkZXIgd2lkZ2V0cyB1c2VkIHRvIGhpZGUgcGllY2VzIG9mIG92ZXJsb25nXG4vLyBsaW5lcyB3aXRoaW4gdGhlIHZpZXdwb3J0LCBhcyBhIGtsdWRnZSB0byBrZWVwIHRoZSBlZGl0b3Jcbi8vIHJlc3BvbnNpdmUgd2hlbiBhIHJpZGljdWxvdXNseSBsb25nIGxpbmUgaXMgbG9hZGVkIGludG8gaXQuXG5jbGFzcyBMaW5lR2FwIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgc2l6ZSwgZGlzcGxheVNpemUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmRpc3BsYXlTaXplID0gZGlzcGxheVNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBzYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBnQSA9IGFbaV0sIGdCID0gYltpXTtcbiAgICAgICAgICAgIGlmIChnQS5mcm9tICE9IGdCLmZyb20gfHwgZ0EudG8gIT0gZ0IudG8gfHwgZ0Euc2l6ZSAhPSBnQi5zaXplKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJhdyh2aWV3U3RhdGUsIHdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgd2lkZ2V0OiBuZXcgTGluZUdhcFdpZGdldCh0aGlzLmRpc3BsYXlTaXplICogKHdyYXBwaW5nID8gdmlld1N0YXRlLnNjYWxlWSA6IHZpZXdTdGF0ZS5zY2FsZVgpLCB3cmFwcGluZylcbiAgICAgICAgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgdmVydGljYWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xOyB9XG59XG5jbGFzcyBWaWV3U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDsgLy8gUGFkZGluZyBhYm92ZSB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwOyAvLyBQYWRkaW5nIGJlbG93IHRoZSBkb2N1bWVudCwgc2NhbGVkXG4gICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSAwOyAvLyBjb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IDA7IC8vIHNjcm9sbERPTS5jbGllbnRIZWlnaHQsIHVuc2NhbGVkXG4gICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSAwOyAvLyBzY3JvbGxET00uY2xpZW50V2lkdGgsIHVuc2NhbGVkXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDsgLy8gTGFzdCBzZWVuIHNjcm9sbERPTS5zY3JvbGxUb3AsIHNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSBmYWxzZTtcbiAgICAgICAgLy8gVGhlIENTUy10cmFuc2Zvcm1hdGlvbiBzY2FsZSBvZiB0aGUgZWRpdG9yICh0cmFuc2Zvcm1lZCBzaXplIC9cbiAgICAgICAgLy8gY29uY3JldGUgc2l6ZSlcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIC8vIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAoZG9jdW1lbnQtcmVsYXRpdmUpIHRvIHdoaWNoIHRvIGFuY2hvciB0aGVcbiAgICAgICAgLy8gc2Nyb2xsIHBvc2l0aW9uLiAtMSBtZWFucyBhbmNob3IgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gMDtcbiAgICAgICAgLy8gVGhlIGhlaWdodCBhdCB0aGUgYW5jaG9yIHBvc2l0aW9uLiBTZXQgYnkgdGhlIERPTSB1cGRhdGUgcGhhc2UuXG4gICAgICAgIC8vIC0xIG1lYW5zIG5vIGhlaWdodCBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIC8vIFNlZSBWUC5NYXhET01IZWlnaHRcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBCcmllZmx5IHNldCB0byB0cnVlIHdoZW4gcHJpbnRpbmcsIHRvIGRpc2FibGUgdmlld3BvcnQgbGltaXRpbmdcbiAgICAgICAgdGhpcy5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBGbGFnIHNldCB3aGVuIGVkaXRvciBjb250ZW50IHdhcyByZWRyYXduLCBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgc3RhZ2Uga25vd3MgaXQgbXVzdCByZWFkIERPTSBsYXlvdXRcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gW107XG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxuICAgICAgICAvLyB3cmFwIHBvaW50LCB3aGVyZSBpdCBtdXN0IHN0aWNrIHRvIHRoZSBjaGFyYWN0ZXIgdGhhdCBpdCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGguIFNpbmNlIGJyb3dzZXJzIGRvbid0IHByb3ZpZGUgYSByZWFzb25hYmxlXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxuICAgICAgICAvLyBtaWdodCBjYXVzZSB0aGlzIHRvIGJlIHNpZ25pZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICBsZXQgZ3Vlc3NXcmFwcGluZyA9IHN0YXRlLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IEhlaWdodE9yYWNsZShndWVzc1dyYXBwaW5nKTtcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlRm9yVmlld3BvcnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVNjYWxlcigpO1xuICAgIH1cbiAgICB1cGRhdGVTY2FsZXIoKSB7XG4gICAgICAgIGxldCBzY2FsZXIgPSB0aGlzLnNjYWxlcjtcbiAgICAgICAgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gPyBJZFNjYWxlciA6XG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgICAgICByZXR1cm4gc2NhbGVyLmVxKHRoaXMuc2NhbGVyKSA/IDAgOiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaChzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICBsZXQgY29udGVudENoYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjb250ZW50Q2hhbmdlcywgaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhwcmV2RGVjbywgdGhpcy5zdGF0ZURlY28sIHVwZGF0ZSA/IHVwZGF0ZS5jaGFuZ2VzIDogQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIGxldCBzY3JvbGxBbmNob3IgPSB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPyBudWxsIDogdGhpcy5zY3JvbGxBbmNob3JBdCh0aGlzLnNjcm9sbFRvcCk7XG4gICAgICAgIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZygpO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0IHx8IGhlaWdodENoYW5nZUZsYWcpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgaWYgKHNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc2Nyb2xsQW5jaG9yLmZyb20sIC0xKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gc2Nyb2xsQW5jaG9yLnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnQgPSBoZWlnaHRDaGFuZ2VzLmxlbmd0aCA/IHRoaXMubWFwVmlld3BvcnQodGhpcy52aWV3cG9ydCwgdXBkYXRlLmNoYW5nZXMpIDogdGhpcy52aWV3cG9ydDtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCAmJiAoc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdmlld3BvcnQudG8pIHx8XG4gICAgICAgICAgICAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodmlld3BvcnQpKVxuICAgICAgICAgICAgdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgIGxldCB2aWV3cG9ydENoYW5nZSA9IHZpZXdwb3J0LmZyb20gIT0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHZpZXdwb3J0LnRvICE9IHRoaXMudmlld3BvcnQudG87XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlIHx8ICF1cGRhdGUuY2hhbmdlcy5lbXB0eSB8fCAodXBkYXRlLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHModGhpcy5tYXBMaW5lR2Fwcyh0aGlzLmxpbmVHYXBzLCB1cGRhdGUuY2hhbmdlcykpKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyAmJiB1cGRhdGUuc2VsZWN0aW9uU2V0ICYmIHVwZGF0ZS52aWV3LmxpbmVXcmFwcGluZyAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hc3NvYyAmJlxuICAgICAgICAgICAgIXVwZGF0ZS5zdGF0ZS5mYWNldChuYXRpdmVTZWxlY3Rpb25IaWRkZW4pKVxuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVhc3VyZSh2aWV3KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LmNvbnRlbnRET00sIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcbiAgICAgICAgbGV0IG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgd2hpdGVTcGFjZSA9IHN0eWxlLndoaXRlU3BhY2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBzdHlsZS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBsZXQgcmVmcmVzaCA9IHRoaXMuaGVpZ2h0T3JhY2xlLm11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSk7XG4gICAgICAgIGxldCBkb21SZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgbWVhc3VyZUNvbnRlbnQgPSByZWZyZXNoIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50IHx8IHRoaXMuY29udGVudERPTUhlaWdodCAhPSBkb21SZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCByZXN1bHQgPSAwLCBiaWFzID0gMDtcbiAgICAgICAgaWYgKGRvbVJlY3Qud2lkdGggJiYgZG9tUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSBnZXRTY2FsZShkb20sIGRvbVJlY3QpO1xuICAgICAgICAgICAgaWYgKHNjYWxlWCA+IC4wMDUgJiYgTWF0aC5hYnModGhpcy5zY2FsZVggLSBzY2FsZVgpID4gLjAwNSB8fFxuICAgICAgICAgICAgICAgIHNjYWxlWSA+IC4wMDUgJiYgTWF0aC5hYnModGhpcy5zY2FsZVkgLSBzY2FsZVkpID4gLjAwNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3ApIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdUb3AgIT0gcGFkZGluZ1RvcCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gcGFkZGluZ0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSBpc1Njcm9sbGVkVG9Cb3R0b20odmlldy5zY3JvbGxET00pO1xuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxuICAgICAgICBsZXQgcGl4ZWxWaWV3cG9ydCA9ICh0aGlzLnByaW50aW5nID8gZnVsbFBpeGVsUmFuZ2UgOiB2aXNpYmxlUGl4ZWxSYW5nZSkoZG9tLCB0aGlzLnBhZGRpbmdUb3ApO1xuICAgICAgICBsZXQgZFRvcCA9IHBpeGVsVmlld3BvcnQudG9wIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCwgZEJvdHRvbSA9IHBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcbiAgICAgICAgbGV0IGluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoaW5WaWV3ICE9IHRoaXMuaW5WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcbiAgICAgICAgICAgIGlmIChpblZpZXcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcgJiYgIXRoaXMuc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NV2lkdGggIT0gY29udGVudFdpZHRoIHx8IHRoaXMuZWRpdG9ySGVpZ2h0ICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWFzdXJlQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHRzID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModGhpcy52aWV3cG9ydCk7XG4gICAgICAgICAgICBpZiAob3JhY2xlLm11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykpXG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fCBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudERPTVdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfSA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbGluZUhlaWdodCA+IDAgJiYgb3JhY2xlLnJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkVG9wID4gMCAmJiBkQm90dG9tID4gMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkVG9wIDwgMCAmJiBkQm90dG9tIDwgMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5taW4oZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBjbGVhckhlaWdodENoYW5nZUZsYWcoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0Q2hhbmdlRmxhZylcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodGhpcy52aWV3cG9ydCwgYmlhcykgfHxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHRoaXMudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKVxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnVwZGF0ZVNjYWxlcigpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoYmlhcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgcmVzdWx0IHw9IHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodmlzaWJsZVRvcCAtIG1hcmdpblRvcCAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh2aXNpYmxlQm90dG9tICsgKDEgLSBtYXJnaW5Ub3ApICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlYWQgfSA9IHNjcm9sbFRhcmdldC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChoZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBoZWFkID4gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IE1hdGgubWluKHRoaXMuZWRpdG9ySGVpZ2h0LCB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gbWFwLmxpbmVBdChoZWFkLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCksIHRvcFBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJjZW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gKGJsb2NrLnRvcCArIGJsb2NrLmJvdHRvbSkgLyAyIC0gdmlld0hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJzdGFydFwiIHx8IHNjcm9sbFRhcmdldC55ID09IFwibmVhcmVzdFwiICYmIGhlYWQgPCB2aWV3cG9ydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay5ib3R0b20gLSB2aWV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodG9wUG9zIC0gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh0b3BQb3MgKyB2aWV3SGVpZ2h0ICsgMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgbWFwVmlld3BvcnQodmlld3BvcnQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdwb3J0KHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS5mcm9tLCB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLnRvKTtcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXG4gICAgLy8gZG9jdW1lbnQgYW5kIG5vdCB0b28gbXVjaCBiZXlvbmQgdGhhdC5cbiAgICB2aWV3cG9ydElzQXBwcm9wcmlhdGUoeyBmcm9tLCB0byB9LCBiaWFzID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB7IHRvcCB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyBib3R0b20gfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IHRvcCA8PSB2aXNpYmxlVG9wIC0gTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKC1iaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0byA9PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICBib3R0b20gPj0gdmlzaWJsZUJvdHRvbSArIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbihiaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0b3AgPiB2aXNpYmxlVG9wIC0gMiAqIDEwMDAgLyogVlAuTWFyZ2luICovICYmIGJvdHRvbSA8IHZpc2libGVCb3R0b20gKyAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICBtYXBMaW5lR2FwcyhnYXBzLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghZ2Fwcy5sZW5ndGggfHwgY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBnYXBzO1xuICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnRvdWNoZXNSYW5nZShnYXAuZnJvbSwgZ2FwLnRvKSlcbiAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChuZXcgTGluZUdhcChjaGFuZ2VzLm1hcFBvcyhnYXAuZnJvbSksIGNoYW5nZXMubWFwUG9zKGdhcC50byksIGdhcC5zaXplLCBnYXAuZGlzcGxheVNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXlTaXplID0gd3JhcHBpbmcgfHwgc2l6ZSA8IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi8gPyBzaXplIDogMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLztcbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgc2l6ZSwgZGlzcGxheVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Fwcy5wdXNoKGdhcCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjaGVja0xpbmUgPSAobGluZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc3RydWN0dXJlID0gbGluZVN0cnVjdHVyZShsaW5lLmZyb20sIGxpbmUudG8sIHRoaXMuc3RhdGVEZWNvKTtcbiAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmUudG90YWwgPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5IZWlnaHQgPSAobWFyZ2luIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLnZpc2libGVUb3AgLSBsaW5lLnRvcCAtIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHRvcCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5XaWR0aCA9IG1hcmdpbiAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgaG9yaXpPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoID4gMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb2xkIG9mIGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGQuZnJvbSA+PSBsaW5lLmZyb20gJiYgb2xkLmZyb20gPCBsaW5lLnRvICYmIG9sZC5zaXplICE9IG9sZC5kaXNwbGF5U2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5mcm9tICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICsgaG9yaXpPZmZzZXQgPCB0aGlzLnBpeGVsVmlld3BvcnQubGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3Jpek9mZnNldCA9IG9sZC5zaXplIC0gb2xkLmRpc3BsYXlTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHB4TGVmdCA9IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0ICsgaG9yaXpPZmZzZXQsIHB4UmlnaHQgPSB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgKyBob3Jpek9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgocHhSaWdodCAtIHB4TGVmdCkgLyAyICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAocHhMZWZ0IC0gbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAocHhSaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgICAgICAgICAgbGluZS50eXBlLmZvckVhY2goY2hlY2tMaW5lKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGVja0xpbmUobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgfVxuICAgIGdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkge1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0bykgLSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaGVpZ2h0ICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGluZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAoIUxpbmVHYXAuc2FtZShnYXBzLCB0aGlzLmxpbmVHYXBzKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwcyA9IGdhcHM7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQoZ2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlVmlzaWJsZVJhbmdlcygpIHtcbiAgICAgICAgbGV0IGRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoKVxuICAgICAgICAgICAgZGVjbyA9IGRlY28uY29uY2F0KHRoaXMubGluZUdhcERlY28pO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY28sIHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywge1xuICAgICAgICAgICAgc3Bhbihmcm9tLCB0bykgeyByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pOyB9LFxuICAgICAgICAgICAgcG9pbnQoKSB7IH1cbiAgICAgICAgfSwgMjApO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHJhbmdlcy5sZW5ndGggIT0gdGhpcy52aXNpYmxlUmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzLnNvbWUoKHIsIGkpID0+IHIuZnJvbSAhPSByYW5nZXNbaV0uZnJvbSB8fCByLnRvICE9IHJhbmdlc1tpXS50byk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQgPyA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8gOiAwO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIChwb3MgPj0gdGhpcy52aWV3cG9ydC5mcm9tICYmIHBvcyA8PSB0aGlzLnZpZXdwb3J0LnRvICYmXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMuZmluZChiID0+IGIuZnJvbSA8PSBwb3MgJiYgYi50byA+PSBwb3MpKSB8fFxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQocG9zLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChoZWlnaHQgPj0gdGhpcy52aWV3cG9ydExpbmVzWzBdLnRvcCAmJiBoZWlnaHQgPD0gdGhpcy52aWV3cG9ydExpbmVzW3RoaXMudmlld3BvcnRMaW5lcy5sZW5ndGggLSAxXS5ib3R0b20gJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRMaW5lcy5maW5kKGwgPT4gbC50b3AgPD0gaGVpZ2h0ICYmIGwuYm90dG9tID49IGhlaWdodCkpIHx8XG4gICAgICAgICAgICBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIFF1ZXJ5VHlwZS5CeUhlaWdodCwgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIHNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCkge1xuICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLmxpbmVCbG9ja0F0SGVpZ2h0KHNjcm9sbFRvcCArIDgpO1xuICAgICAgICByZXR1cm4gYmxvY2suZnJvbSA+PSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3cG9ydExpbmVzWzBdLnRvcCAtIHNjcm9sbFRvcCA+IDIwMCA/IGJsb2NrIDogdGhpcy52aWV3cG9ydExpbmVzWzBdO1xuICAgIH1cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmJsb2NrQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgZ2V0IGRvY0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVyLnRvRE9NKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCk7XG4gICAgfVxuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NIZWlnaHQgKyB0aGlzLnBhZGRpbmdUb3AgKyB0aGlzLnBhZGRpbmdCb3R0b207XG4gICAgfVxufVxuY2xhc3MgVmlld3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBsaW5lU3RydWN0dXJlKGZyb20sIHRvLCBzdGF0ZURlY28pIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIHBvcyA9IGZyb20sIHRvdGFsID0gMDtcbiAgICBSYW5nZVNldC5zcGFucyhzdGF0ZURlY28sIGZyb20sIHRvLCB7XG4gICAgICAgIHNwYW4oKSB7IH0sXG4gICAgICAgIHBvaW50KGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogZnJvbSB9KTtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmcm9tIC0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgIH1cbiAgICB9LCAyMCk7IC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBjb2xsYXBzZWQgcmFuZ2VzIG9mIGEgc2lnbmlmaWNhbnQgc2l6ZVxuICAgIGlmIChwb3MgPCB0bykge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG8gfSk7XG4gICAgICAgIHRvdGFsICs9IHRvIC0gcG9zO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3RhbCwgcmFuZ2VzIH07XG59XG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oeyB0b3RhbCwgcmFuZ2VzIH0sIHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDw9IDApXG4gICAgICAgIHJldHVybiByYW5nZXNbMF0uZnJvbTtcbiAgICBpZiAocmF0aW8gPj0gMSlcbiAgICAgICAgcmV0dXJuIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgbGV0IGRpc3QgPSBNYXRoLmZsb29yKHRvdGFsICogcmF0aW8pO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV0sIHNpemUgPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkaXN0IDw9IHNpemUpXG4gICAgICAgICAgICByZXR1cm4gZnJvbSArIGRpc3Q7XG4gICAgICAgIGRpc3QgLT0gc2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpIHtcbiAgICBsZXQgY291bnRlZCA9IDA7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHN0cnVjdHVyZS5yYW5nZXMpIHtcbiAgICAgICAgaWYgKHBvcyA8PSB0bykge1xuICAgICAgICAgICAgY291bnRlZCArPSBwb3MgLSBmcm9tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlZCArPSB0byAtIGZyb207XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVkIC8gc3RydWN0dXJlLnRvdGFsO1xufVxuZnVuY3Rpb24gZmluZChhcnJheSwgZikge1xuICAgIGZvciAobGV0IHZhbCBvZiBhcnJheSlcbiAgICAgICAgaWYgKGYodmFsKSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIERvbid0IHNjYWxlIHdoZW4gdGhlIGRvY3VtZW50IGhlaWdodCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHdoYXRcbi8vIHRoZSBET00gY2FuIGhhbmRsZS5cbmNvbnN0IElkU2NhbGVyID0ge1xuICAgIHRvRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgZnJvbURPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIHNjYWxlOiAxLFxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlciA9PSB0aGlzOyB9XG59O1xuLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIHRvbyBiaWcgKD4gVlAuTWF4RE9NSGVpZ2h0KSwgc2NhbGUgZG93biB0aGVcbi8vIHJlZ2lvbnMgb3V0c2lkZSB0aGUgdmlld3BvcnRzIHNvIHRoYXQgdGhlIHRvdGFsIGhlaWdodCBpc1xuLy8gVlAuTWF4RE9NSGVpZ2h0LlxuY2xhc3MgQmlnU2NhbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmFjbGUsIGhlaWdodE1hcCwgdmlld3BvcnRzKSB7XG4gICAgICAgIGxldCB2cEhlaWdodCA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDtcbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS50b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLmJvdHRvbTtcbiAgICAgICAgICAgIHZwSGVpZ2h0ICs9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0b3AsIGJvdHRvbSwgZG9tVG9wOiAwLCBkb21Cb3R0b206IDAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAoNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gLSB2cEhlaWdodCkgLyAoaGVpZ2h0TWFwLmhlaWdodCAtIHZwSGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICBvYmouZG9tVG9wID0gZG9tQmFzZSArIChvYmoudG9wIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgZG9tQmFzZSA9IG9iai5kb21Cb3R0b20gPSBvYmouZG9tVG9wICsgKG9iai5ib3R0b20gLSBvYmoudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSBvYmouYm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLnRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmFzZSArIChuIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuYm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC5kb21Ub3AgKyAobiAtIHZwLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLmRvbVRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZSArIChuIC0gZG9tQmFzZSkgLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuZG9tQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC50b3AgKyAobiAtIHZwLmRvbVRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEJpZ1NjYWxlcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlID09IG90aGVyLnNjYWxlICYmIHRoaXMudmlld3BvcnRzLmxlbmd0aCA9PSBvdGhlci52aWV3cG9ydHMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0cy5ldmVyeSgodnAsIGkpID0+IHZwLmZyb20gPT0gb3RoZXIudmlld3BvcnRzW2ldLmZyb20gJiYgdnAudG8gPT0gb3RoZXIudmlld3BvcnRzW2ldLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2FsZUJsb2NrKGJsb2NrLCBzY2FsZXIpIHtcbiAgICBpZiAoc2NhbGVyLnNjYWxlID09IDEpXG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICBsZXQgYlRvcCA9IHNjYWxlci50b0RPTShibG9jay50b3ApLCBiQm90dG9tID0gc2NhbGVyLnRvRE9NKGJsb2NrLmJvdHRvbSk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oYmxvY2suZnJvbSwgYmxvY2subGVuZ3RoLCBiVG9wLCBiQm90dG9tIC0gYlRvcCwgQXJyYXkuaXNBcnJheShibG9jay5fY29udGVudCkgPyBibG9jay5fY29udGVudC5tYXAoYiA9PiBzY2FsZUJsb2NrKGIsIHNjYWxlcikpIDogYmxvY2suX2NvbnRlbnQpO1xufVxuXG5jb25zdCB0aGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiBzdHJzID0+IHN0cnMuam9pbihcIiBcIikgfSk7XG5jb25zdCBkYXJrVGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5pbmRleE9mKHRydWUpID4gLTEgfSk7XG5jb25zdCBiYXNlVGhlbWVJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VMaWdodElEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZURhcmtJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG5jb25zdCBsaWdodERhcmtJRHMgPSB7IFwiJmxpZ2h0XCI6IFwiLlwiICsgYmFzZUxpZ2h0SUQsIFwiJmRhcmtcIjogXCIuXCIgKyBiYXNlRGFya0lEIH07XG5mdW5jdGlvbiBidWlsZFRoZW1lKG1haW4sIHNwZWMsIHNjb3Blcykge1xuICAgIHJldHVybiBuZXcgU3R5bGVNb2R1bGUoc3BlYywge1xuICAgICAgICBmaW5pc2goc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gLyYvLnRlc3Qoc2VsKSA/IHNlbC5yZXBsYWNlKC8mXFx3Ki8sIG0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtID09IFwiJlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlcyB8fCAhc2NvcGVzW21dKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgc2VsZWN0b3I6ICR7bX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVzW21dO1xuICAgICAgICAgICAgfSkgOiBtYWluICsgXCIgXCIgKyBzZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL2J1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwge1xuICAgIFwiJlwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlICFpbXBvcnRhbnRcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgXCImLmNtLWZvY3VzZWRcIjoge1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHNpbXBsZSBkZWZhdWx0IG91dGxpbmUgdG8gbWFrZSBzdXJlIGEgZm9jdXNlZFxuICAgICAgICAgICAgLy8gZWRpdG9yIGlzIHZpc3VhbGx5IGRpc3RpbmN0LiBDYW4ndCBsZWF2ZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdpbGwgYXBwbHkgdG8gdGhlIGNvbnRlbnQgZWxlbWVudCwgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGluc2lkZSB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgYW5kIGRvZXNuJ3QgaW5jbHVkZSB0aGVcbiAgICAgICAgICAgIC8vIGd1dHRlcnMuIFdlIGFsc28gY2FuJ3QgdXNlIGFuICdhdXRvJyBvdXRsaW5lLCBzaW5jZSB0aG9zZVxuICAgICAgICAgICAgLy8gYXJlLCBmb3Igc29tZSByZWFzb24sIGRyYXduIGJlaGluZCB0aGUgZWxlbWVudCBjb250ZW50LCB3aGljaFxuICAgICAgICAgICAgLy8gd2lsbCBjYXVzZSB0aGluZ3MgbGlrZSB0aGUgYWN0aXZlIGxpbmUgYmFja2dyb3VuZCB0byBjb3ZlclxuICAgICAgICAgICAgLy8gdGhlIG91dGxpbmUgKCMyOTcpLlxuICAgICAgICAgICAgb3V0bGluZTogXCIxcHggZG90dGVkICMyMTIxMjFcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiXG4gICAgfSxcbiAgICBcIi5jbS1zY3JvbGxlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEuNCxcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgb3ZlcmZsb3dYOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgekluZGV4OiAwLFxuICAgICAgICBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBmbGV4R3JvdzogMixcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAgICAgICB3b3JkV3JhcDogXCJub3JtYWxcIiwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80NTZcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgcGFkZGluZzogXCI0cHggMFwiLFxuICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgXCImW2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiOiB7XG4gICAgICAgICAgICBXZWJraXRVc2VyTW9kaWZ5OiBcInJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHlcIixcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGluZVdyYXBwaW5nXCI6IHtcbiAgICAgICAgd2hpdGVTcGFjZV9mYWxsYmFjazogXCJwcmUtd3JhcFwiLCAvLyBGb3IgSUVcbiAgICAgICAgd2hpdGVTcGFjZTogXCJicmVhay1zcGFjZXNcIixcbiAgICAgICAgd29yZEJyZWFrOiBcImJyZWFrLXdvcmRcIiwgLy8gRm9yIFNhZmFyaSwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IG92ZXJmbG93LXdyYXA6IGFueXdoZXJlXG4gICAgICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAxXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwiYmxhY2tcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcIndoaXRlXCIgfSxcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMnB4IDAgNnB4XCJcbiAgICB9LFxuICAgIFwiLmNtLWxheWVyXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIixcbiAgICAgICAgXCImID4gKlwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDlkOWQ5XCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMjJcIlxuICAgIH0sXG4gICAgXCImbGlnaHQuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q3ZDRmMFwiXG4gICAgfSxcbiAgICBcIiZkYXJrLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMzNcIlxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBhbmltYXRpb246IFwic3RlcHMoMSkgY20tYmxpbmsgMS4ycyBpbmZpbml0ZVwiXG4gICAgfSxcbiAgICAvLyBUd28gYW5pbWF0aW9ucyBkZWZpbmVkIHNvIHRoYXQgd2UgY2FuIHN3aXRjaCBiZXR3ZWVuIHRoZW0gdG9cbiAgICAvLyByZXN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aG91dCBmb3JjaW5nIGFub3RoZXIgc3R5bGVcbiAgICAvLyByZWNvbXB1dGF0aW9uLlxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGlua1wiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmsyXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiLmNtLWN1cnNvciwgLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuMnB4IHNvbGlkIGJsYWNrXCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTAuNnB4XCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnRDb2xvcjogXCIjZGRkXCJcbiAgICB9LFxuICAgIFwiLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllciAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSxcbiAgICBcIi5jbS1pc29cIjoge1xuICAgICAgICB1bmljb2RlQmlkaTogXCJpc29sYXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLWFubm91bmNlZFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgIHRvcDogXCItMTAwMDBweFwiXG4gICAgfSxcbiAgICBcIkBtZWRpYSBwcmludFwiOiB7XG4gICAgICAgIFwiLmNtLWFubm91bmNlZFwiOiB7IGRpc3BsYXk6IFwibm9uZVwiIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNjY2VlZmY0NFwiIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTllZWZmMzNcIiB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcInJlZFwiIH0sXG4gICAgXCImZGFyayAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCIjZjc4XCIgfSxcbiAgICBcIi5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIGluc2V0SW5saW5lU3RhcnQ6IDAsXG4gICAgICAgIHpJbmRleDogMjAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcIiM2YzZjNmNcIixcbiAgICAgICAgYm9yZGVyUmlnaHQ6IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIiNjY2NcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIiwgLy8gTmVjZXNzYXJ5IC0tIHByZXZlbnRzIG1hcmdpbiBjb2xsYXBzaW5nXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgM3B4IDAgNXB4XCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjIwcHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjIyMjI3XCJcbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgekluZGV4OiAzMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcInJhZGlhbC1ncmFkaWVudChjaXJjbGUgYXQgNTAlIDU1JSwgI2FhYSAyMCUsIHRyYW5zcGFyZW50IDUlKVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwiY2VudGVyXCIsXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRUYWJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwXCI+PHBhdGggc3Ryb2tlPVwiJTIzODg4XCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZD1cIk0xIDEwSDE5NkwxOTAgNU0xOTAgMTVMMTk2IDEwTTE5NyA0TDE5NyAxNlwiLz48L3N2Zz4nKWAsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiBcImF1dG8gMTAwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwicmlnaHQgOTAlXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCJcbiAgICB9LFxuICAgIFwiLmNtLXRyYWlsaW5nU3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvXG4vLyBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgdGhlcmVcbmNvbnN0IHVzZUNoYXJEYXRhID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGtub3duIHNlbGVjdGlvbi4gS2VwdCBpbiBvdXIgb3duIG9iamVjdCwgYXMgb3Bwb3NlZCB0byBqdXN0XG4gICAgICAgIC8vIGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgc2VsZWN0aW9uIGJlY2F1c2U6XG4gICAgICAgIC8vICAtIFNhZmFyaSBkb2Vzbid0IHJlcG9ydCB0aGUgcmlnaHQgc2VsZWN0aW9uIGluIHNoYWRvdyBET01cbiAgICAgICAgLy8gIC0gUmVhZGluZyBmcm9tIHRoZSBzZWxlY3Rpb24gZm9yY2VzIGEgRE9NIGxheW91dFxuICAgICAgICAvLyAgLSBUaGlzIHdheSwgd2UgY2FuIGlnbm9yZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnRzIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gICAgYWxyZWFkeSBzZWVuIHRoZSAnbmV3JyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZSA9IG5ldyBET01TZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgLy8gU2V0IHdoZW4gYSBzZWxlY3Rpb24gY2hhbmdlIGlzIGRldGVjdGVkLCBjbGVhcmVkIG9uIGZsdXNoXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2FwcyA9IFtdO1xuICAgICAgICB0aGlzLnByaW50UXVlcnkgPSBudWxsO1xuICAgICAgICAvLyBUaW1lb3V0IGZvciBzY2hlZHVsaW5nIGNoZWNrIG9mIHRoZSBwYXJlbnRzIHRoYXQgbmVlZCBzY3JvbGwgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgbXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gdHlwaW5nIG92ZXIgYSBzZWxlY3Rpb24gb3JcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXIgdGV4dCBub2RlKSBjYWxsIHRoZVxuICAgICAgICAgICAgLy8gb2JzZXJ2ZXIgY2FsbGJhY2sgYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5yZWxhdGVkbHksIGlPUyBTYWZhcmkgd2lsbCwgd2hlbiBlbmRpbmcgYSBjb21wb3NpdGlvbixcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBmaXJzdCBjbGVhciBpdCwgZGVsaXZlciB0aGUgbXV0YXRpb25zLCBhbmQgdGhlblxuICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGZpbmlzaGVkIHRleHQuIENvZGVNaXJyb3IncyBoYW5kbGluZyBvZiB0aGVcbiAgICAgICAgICAgIC8vIGRlbGV0aW9uIHdpbGwgcHJldmVudCB0aGUgcmVpbnNlcnRpb24gZnJvbSBoYXBwZW5pbmcsXG4gICAgICAgICAgICAvLyBicmVha2luZyBjb21wb3NpdGlvbi5cbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5pb3MgJiYgdmlldy5jb21wb3NpbmcpICYmXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2luZG93LkVkaXRDb250ZXh0ICYmIHZpZXcuY29uc3RydWN0b3IuRURJVF9DT05URVhUICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgLy8gQ2hyb21lIDwxMjYgZG9lc24ndCBzdXBwb3J0IGludmVydGVkIHNlbGVjdGlvbnMgaW4gZWRpdCBjb250ZXh0ICgjMTM5MilcbiAgICAgICAgICAgICEoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5jaHJvbWVfdmVyc2lvbiA8IDEyNikpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQgPSBuZXcgRWRpdENvbnRleHRNYW5hZ2VyKHZpZXcpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpKVxuICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5lZGl0Q29udGV4dCA9IHRoaXMuZWRpdENvbnRleHQuZWRpdENvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJpbnQgPSB0aGlzLm9uUHJpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKVxuICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoXCJwcmludFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luID0gdmlldy53aW4pO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDaGVjayA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSBzZXRUaW1lb3V0KHRoaXMubGlzdGVuRm9yU2Nyb2xsLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgKGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApICE9IHRoaXMuaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gIXRoaXMuaW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcgIT0gdGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMCwgLjAwMV0gfSk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG4gICAgb25TY3JvbGxDaGFuZ2VkKGUpIHtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUucnVuSGFuZGxlcnMoXCJzY3JvbGxcIiwgZSk7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMuZWRpdENvbnRleHQubWVhc3VyZVJlcSk7XG4gICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGUpO1xuICAgIH1cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb25QcmludChldmVudCkge1xuICAgICAgICBpZiAoKGV2ZW50LnR5cGUgPT0gXCJjaGFuZ2VcIiB8fCAhZXZlbnQudHlwZSkgJiYgIWV2ZW50Lm1hdGNoZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICB1cGRhdGVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FwSW50ZXJzZWN0aW9uICYmIChnYXBzLmxlbmd0aCAhPSB0aGlzLmdhcHMubGVuZ3RoIHx8IHRoaXMuZ2Fwcy5zb21lKChnLCBpKSA9PiBnICE9IGdhcHNbaV0pKSkge1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24ub2JzZXJ2ZShnYXApO1xuICAgICAgICAgICAgdGhpcy5nYXBzID0gZ2FwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZG9tIDogIWhhc1NlbGVjdGlvbih0aGlzLmRvbSwgc2VsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzZWwuYW5jaG9yTm9kZSAmJiB2aWV3LmRvY1ZpZXcubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuaWdub3JlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIXdhc0NoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCBoYXMgYSBzaW1pbGFyIGlzc3VlIHdoZW4gYmFja3NwYWNpbmcgb3V0IGFcbiAgICAgICAgLy8gc2VsZWN0aW9uICgjNjQ1KS5cbiAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUpICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmXG4gICAgICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgIH1cbiAgICByZWFkU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBTZWxlY3Rpb24gb2JqZWN0IGlzIGJyb2tlbiBpbiBzaGFkb3cgcm9vdHMgaW4gU2FmYXJpLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTRcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJhbmdlID0gYnJvd3Nlci5zYWZhcmkgJiYgdmlldy5yb290Lm5vZGVUeXBlID09IDExICYmXG4gICAgICAgICAgICB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbSAmJlxuICAgICAgICAgICAgc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHRoaXMudmlldywgc2VsZWN0aW9uKSB8fCBzZWxlY3Rpb247XG4gICAgICAgIGlmICghcmFuZ2UgfHwgdGhpcy5zZWxlY3Rpb25SYW5nZS5lcShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBsb2NhbCA9IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgcmFuZ2UpO1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgYnJvd3NlciBoYXMsIG9uIGZvY3VzLCBtb3ZlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgY29udGVudCBlbGVtZW50LiBSZXNldCBpdCB0byB0aGVcbiAgICAgICAgLy8gcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuICAgICAgICBpZiAobG9jYWwgJiYgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIGF0RWxlbWVudFN0YXJ0KHRoaXMuZG9tLCByYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICAgICAgdmlldy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAobG9jYWwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KG51bGwsIDAsIG51bGwsIDApO1xuICAgIH1cbiAgICBsaXN0ZW5Gb3JTY3JvbGwoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwLCBjaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gdGhpcy5kb207IGRvbTspIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiBpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiB0aGlzLnNjcm9sbFRhcmdldHNbaV0gPT0gZG9tKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQucHVzaChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5hc3NpZ25lZFNsb3QgfHwgZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiAhY2hhbmdlZClcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgIH1cbiAgICAvLyBUaHJvdyBhd2F5IGFueSBwZW5kaW5nIGNoYW5nZXNcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCwgZXNwZWNpYWxseSBpbiBjb21iaW5hdGlvbiB3aXRoIEdCb2FyZCwgbm90IG9ubHlcbiAgICAvLyBkb2Vzbid0IHJlbGlhYmx5IGZpcmUgcmVndWxhciBrZXkgZXZlbnRzLCBidXQgYWxzbyBvZnRlblxuICAgIC8vIHN1cnJvdW5kcyB0aGUgZWZmZWN0IG9mIGVudGVyIG9yIGJhY2tzcGFjZSB3aXRoIGEgYnVuY2ggb2ZcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgdGhhdCwgd2hlbiBpbnRlcnJ1cHRlZCwgY2F1c2UgdGV4dCBkdXBsaWNhdGlvblxuICAgIC8vIG9yIG90aGVyIGtpbmRzIG9mIGNvcnJ1cHRpb24uIFRoaXMgaGFjayBtYWtlcyB0aGUgZWRpdG9yIGJhY2sgb2ZmXG4gICAgLy8gZnJvbSBoYW5kbGluZyBET00gY2hhbmdlcyBmb3IgYSBtb21lbnQgd2hlbiBzdWNoIGEga2V5IGlzXG4gICAgLy8gZGV0ZWN0ZWQgKHZpYSBiZWZvcmVpbnB1dCBvciBrZXlkb3duKSwgYW5kIHRoZW4gdHJpZXMgdG8gZmx1c2hcbiAgICAvLyB0aGVtIG9yLCBpZiB0aGF0IGhhcyBubyBlZmZlY3QsIGRpc3BhdGNoZXMgdGhlIGdpdmVuIGtleS5cbiAgICBkZWxheUFuZHJvaWRLZXkoa2V5LCBrZXlDb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICBsZXQgZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPSBrZXkua2V5Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmx1c2hlZCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVzaGVkICYmIGtleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuZG9tLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGJhY2tzcGFjZSBiZWZvcmVpbnB1dCBpcyBzb21ldGltZXMgc2lnbmFsbGVkIHNwdXJpb3VzbHksXG4gICAgICAgIC8vIEVudGVyIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICAgICAgICAgICAga2V5LCBrZXlDb2RlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb21pbmcgcmlnaHQgYWZ0ZXIgYW5vdGhlciBjaGFuZ2UsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JjZTogdGhpcy5sYXN0Q2hhbmdlIDwgRGF0ZS5ub3coKSAtIDUwIHx8ICEhKChfYSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZSlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0pO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWFkTXV0YXRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKHJhbmdlLmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcbiAgICB9XG4gICAgcmVhZENoYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgaWYgKGZyb20gPCAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGZyb20gPiAtMSlcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IG5ldyBET01DaGFuZ2UodGhpcy52aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICB0aGlzLnZpZXcuZG9jVmlldy5kb21DaGFuZ2VkID0geyBuZXdTZWw6IGNoYW5nZS5uZXdTZWwgPyBjaGFuZ2UubmV3U2VsLm1haW4gOiBudWxsIH07XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XG4gICAgZmx1c2gocmVhZFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBob2xkIG9mZiBmbHVzaGluZyB3aGVuIHBlbmRpbmcga2V5cyBhcmUgc2V04oCUdGhlIGNvZGVcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcbiAgICAgICAgLy8gdmlldyBpcyByZXN5bmNocm9uaXplZCBhZnRlclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocmVhZFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgaWYgKCFkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGFwcGx5RE9NQ2hhbmdlKHRoaXMudmlldywgZG9tQ2hhbmdlKTtcbiAgICAgICAgLy8gVGhlIHZpZXcgd2Fzbid0IHVwZGF0ZWQgYnV0IERPTS9zZWxlY3Rpb24gY2hhbmdlcyB3ZXJlIHNlZW4uIFJlc2V0IHRoZSB2aWV3LlxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09IHN0YXJ0U3RhdGUgJiZcbiAgICAgICAgICAgIChkb21DaGFuZ2UuZG9tQ2hhbmdlZCB8fCBkb21DaGFuZ2UubmV3U2VsICYmICFkb21DaGFuZ2UubmV3U2VsLm1haW4uZXEodGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluKSkpXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdChyZWMudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjVmlldyB8fCBjVmlldy5pZ25vcmVNdXRhdGlvbihyZWMpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNWaWV3Lm1hcmtEaXJ0eShyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIik7XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIilcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLztcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEJlZm9yZSA9IGZpbmRDaGlsZChjVmlldywgcmVjLnByZXZpb3VzU2libGluZyB8fCByZWMudGFyZ2V0LnByZXZpb3VzU2libGluZywgLTEpO1xuICAgICAgICAgICAgbGV0IGNoaWxkQWZ0ZXIgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5uZXh0U2libGluZyB8fCByZWMudGFyZ2V0Lm5leHRTaWJsaW5nLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gY1ZpZXcucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogY1ZpZXcucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogY2hpbGRBZnRlciA/IGNWaWV3LnBvc0JlZm9yZShjaGlsZEFmdGVyKSA6IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY1ZpZXcucG9zQXRTdGFydCwgdG86IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRXaW5kb3cod2luKSB7XG4gICAgICAgIGlmICh3aW4gIT0gdGhpcy53aW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgICAgIHRoaXMud2luID0gd2luO1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkuYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5hZGRMaXN0ZW5lcih0aGlzLm9uUHJpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25QcmludCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHRoaXMub25QcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChlZGl0YWJsZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSlcbiAgICAgICAgICAgICAgICB1cGRhdGUudmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHRoaXMuZWRpdENvbnRleHQuZWRpdENvbnRleHQgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgKF9hID0gdGhpcy5pbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYiA9IHRoaXMuZ2FwSW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLnJlc2l6ZVNjcm9sbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhcmVudENoZWNrKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmNvbnRlbnRET00uZWRpdENvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGQoY1ZpZXcsIGRvbSwgZGlyKSB7XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBsZXQgY3VyVmlldyA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICBpZiAoY3VyVmlldyAmJiBjdXJWaWV3LnBhcmVudCA9PSBjVmlldylcbiAgICAgICAgICAgIHJldHVybiBjdXJWaWV3O1xuICAgICAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGRvbSA9IHBhcmVudCAhPSBjVmlldy5kb20gPyBwYXJlbnQgOiBkaXIgPiAwID8gZG9tLm5leHRTaWJsaW5nIDogZG9tLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBidWlsZFNlbGVjdGlvblJhbmdlRnJvbVJhbmdlKHZpZXcsIHJhbmdlKSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IHJhbmdlLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VyQW5jaG9yLm5vZGUsIGN1ckFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWcgKCM0MTQpXG5mdW5jdGlvbiBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgcmFuZ2UpO1xuICAgIH1cbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjEpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93cm9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgdmlldy5kb20ub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmNvbnRlbnRET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgZm91bmQpIDogbnVsbDtcbn1cbmNsYXNzIEVkaXRDb250ZXh0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAvLyBUaGUgZG9jdW1lbnQgd2luZG93IGZvciB3aGljaCB0aGUgdGV4dCBpbiB0aGUgY29udGV4dCBpc1xuICAgICAgICAvLyBtYWludGFpbmVkLiBGb3IgbGFyZ2UgZG9jdW1lbnRzLCB0aGlzIG1heSBiZSBzbWFsbGVyIHRoYW4gdGhlXG4gICAgICAgIC8vIGVkaXRvciBkb2N1bWVudC4gVGhpcyB3aW5kb3cgYWx3YXlzIGluY2x1ZGVzIHRoZSBzZWxlY3Rpb24gaGVhZC5cbiAgICAgICAgdGhpcy5mcm9tID0gMDtcbiAgICAgICAgdGhpcy50byA9IDA7XG4gICAgICAgIC8vIFdoZW4gYXBwbHlpbmcgYSB0cmFuc2FjdGlvbiwgdGhpcyBpcyB1c2VkIHRvIGNvbXBhcmUgdGhlIGNoYW5nZVxuICAgICAgICAvLyBtYWRlIHRvIHRoZSBjb250ZXh0IGNvbnRlbnQgdG8gdGhlIGNoYW5nZSBpbiB0aGUgdHJhbnNhY3Rpb24gaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gbWFrZSB0aGUgbWluaW1hbCBjaGFuZ2VzIHRvIHRoZSBjb250ZXh0IChzaW5jZSB0b3VjaGluZ1xuICAgICAgICAvLyB0aGF0IHNvbWV0aW1lcyBicmVha3Mgc2VyaWVzIG9mIG11bHRpcGxlIGVkaXRzIG1hZGUgZm9yIGEgc2luZ2xlXG4gICAgICAgIC8vIHVzZXIgYWN0aW9uIG9uIHNvbWUgQW5kcm9pZCBrZXlib2FyZHMpXG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIHRoZSBmYWN0IHRoYXQgRWRpdENvbnRleHQgZG9lcyBub3QgcmVzcG9uZFxuICAgICAgICAvLyB3ZWxsIHRvIGhhdmluZyBpdHMgY29udGVudCB1cGRhdGVkIGR1cmluZyBhIGNvbXBvc2l0aW9uIChzZWUgIzE0NzIpXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuZWRpdENvbnRleHQgPSBuZXcgd2luZG93LkVkaXRDb250ZXh0KHtcbiAgICAgICAgICAgIHRleHQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHRoaXMuZnJvbSwgdGhpcy50byksXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogdGhpcy50b0NvbnRleHRQb3MoTWF0aC5tYXgodGhpcy5mcm9tLCBNYXRoLm1pbih0aGlzLnRvLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcikpKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogdGhpcy50b0NvbnRleHRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy50ZXh0dXBkYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG9FZGl0b3JQb3MoZS51cGRhdGVSYW5nZVN0YXJ0KSwgdG8gPSB0aGlzLnRvRWRpdG9yUG9zKGUudXBkYXRlUmFuZ2VFbmQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJiAhdGhpcy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSB7IGNvbnRleHRCYXNlOiBlLnVwZGF0ZVJhbmdlU3RhcnQsIGVkaXRvckJhc2U6IGZyb20sIGRyaWZ0ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICBsZXQgY2hhbmdlID0geyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGUudGV4dC5zcGxpdChcIlxcblwiKSkgfTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aW5kb3cgZG9lc24ndCBpbmNsdWRlIHRoZSBhbmNob3IsIGFzc3VtZSBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBhZGphY2VudCB0byBhIHNpZGUgZ28gdXAgdG8gdGhlIGFuY2hvci5cbiAgICAgICAgICAgIGlmIChjaGFuZ2UuZnJvbSA9PSB0aGlzLmZyb20gJiYgYW5jaG9yIDwgdGhpcy5mcm9tKVxuICAgICAgICAgICAgICAgIGNoYW5nZS5mcm9tID0gYW5jaG9yO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnRvID09IHRoaXMudG8gJiYgYW5jaG9yID4gdGhpcy50bylcbiAgICAgICAgICAgICAgICBjaGFuZ2UudG8gPSBhbmNob3I7XG4gICAgICAgICAgICAvLyBFZGl0IGNvbnRleHRzIHNvbWV0aW1lcyBmaXJlIGVtcHR5IGNoYW5nZXNcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgIWNoYW5nZS5pbnNlcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBjaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIXZpZXcuc3RhdGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy50byAtIHRoaXMuZnJvbSArIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSh0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uU3RhcnQsIG5ld0xlbiksIHRoaXMudG9FZGl0b3JQb3MoZS5zZWxlY3Rpb25FbmQsIG5ld0xlbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBkaWRuJ3QgZmx1c2ggb3VyIGNoYW5nZSwgcmV2ZXJ0IGl0IHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBjb250ZXh0IGlzIGluIHN5bmMgd2l0aCB0aGUgZWRpdG9yIHN0YXRlIGFnYWluLlxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24odmlldy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY2hhcmFjdGVyYm91bmRzdXBkYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy50b0VkaXRvclBvcyhlLnJhbmdlU3RhcnQpLCBlbmQgPSB0aGlzLnRvRWRpdG9yUG9zKGUucmFuZ2VFbmQpOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHZpZXcuY29vcmRzRm9yQ2hhcihpKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gKHJlY3QgJiYgbmV3IERPTVJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCAtIHJlY3QubGVmdCwgcmVjdC5ib3R0b20gLSByZWN0LnRvcCkpXG4gICAgICAgICAgICAgICAgICAgIHx8IHByZXYgfHwgbmV3IERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaChwcmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudXBkYXRlQ2hhcmFjdGVyQm91bmRzKGUucmFuZ2VTdGFydCwgcmVjdHMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnRleHRmb3JtYXR1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCBkZWNvID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBmb3JtYXQgb2YgZS5nZXRUZXh0Rm9ybWF0cygpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVTdHlsZSA9IGZvcm1hdC51bmRlcmxpbmVTdHlsZSwgdGhpY2tuZXNzID0gZm9ybWF0LnVuZGVybGluZVRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAobGluZVN0eWxlICE9IFwiTm9uZVwiICYmIHRoaWNrbmVzcyAhPSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG9FZGl0b3JQb3MoZm9ybWF0LnJhbmdlU3RhcnQpLCB0byA9IHRoaXMudG9FZGl0b3JQb3MoZm9ybWF0LnJhbmdlRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gYHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lICR7bGluZVN0eWxlID09IFwiRGFzaGVkXCIgPyBcImRhc2hlZCBcIiA6IGxpbmVTdHlsZSA9PSBcIlNxdWlnZ2xlXCIgPyBcIndhdnkgXCIgOiBcIlwifSR7dGhpY2tuZXNzID09IFwiVGhpblwiID8gMSA6IDJ9cHhgO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ubWFyayh7IGF0dHJpYnV0ZXM6IHsgc3R5bGUgfSB9KS5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZy5vZihEZWNvcmF0aW9uLnNldChkZWNvKSkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgIGxldCB7IGRyaWZ0ZWQgfSA9IHRoaXMuY29tcG9zaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZHJpZnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gdGhpcy5oYW5kbGVycylcbiAgICAgICAgICAgIGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVyc1tldmVudF0pO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlQ29udHJvbEJvdW5kcyh2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsICYmIHNlbC5yYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVNlbGVjdGlvbkJvdW5kcyhzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICB9IH07XG4gICAgfVxuICAgIGFwcGx5RWRpdHModXBkYXRlKSB7XG4gICAgICAgIGxldCBvZmYgPSAwLCBhYm9ydCA9IGZhbHNlLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZTtcbiAgICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKGZyb21BLCB0b0EsIF9mcm9tQiwgX3RvQiwgaW5zZXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAoYWJvcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGRMZW4gPSBpbnNlcnQubGVuZ3RoIC0gKHRvQSAtIGZyb21BKTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nICYmIHRvQSA+PSBwZW5kaW5nLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcuZnJvbSA9PSBmcm9tQSAmJiBwZW5kaW5nLnRvID09IHRvQSAmJiBwZW5kaW5nLmluc2VydC5lcShpbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDsgLy8gTWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IGRMZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gKz0gZExlbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTWlzbWF0Y2gsIHJldmVydFxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnRQZW5kaW5nKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUEgKz0gb2ZmO1xuICAgICAgICAgICAgdG9BICs9IG9mZjtcbiAgICAgICAgICAgIGlmICh0b0EgPD0gdGhpcy5mcm9tKSB7IC8vIEJlZm9yZSB0aGUgd2luZG93XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tICs9IGRMZW47XG4gICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbUEgPCB0aGlzLnRvKSB7IC8vIE92ZXJsYXBzIHdpdGggd2luZG93XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgdGhpcy5mcm9tIHx8IHRvQSA+IHRoaXMudG8gfHwgKHRoaXMudG8gLSB0aGlzLmZyb20pICsgaW5zZXJ0Lmxlbmd0aCA+IDMwMDAwIC8qIEN4VnAuTWF4U2l6ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVUZXh0KHRoaXMudG9Db250ZXh0UG9zKGZyb21BKSwgdGhpcy50b0NvbnRleHRQb3ModG9BKSwgaW5zZXJ0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gKz0gZExlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBkTGVuO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBlbmRpbmcgJiYgIWFib3J0KVxuICAgICAgICAgICAgdGhpcy5yZXZlcnRQZW5kaW5nKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhYWJvcnQ7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHJldmVydGVkID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICYmICh0aGlzLmNvbXBvc2luZy5kcmlmdGVkIHx8IHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykpKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcuZHJpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZy5lZGl0b3JCYXNlID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMuY29tcG9zaW5nLmVkaXRvckJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFwcGx5RWRpdHModXBkYXRlKSB8fCAhdGhpcy5yYW5nZUlzVmFsaWQodXBkYXRlLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCByZXZlcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24odXBkYXRlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICB9XG4gICAgcmVzZXRSYW5nZShzdGF0ZSkge1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5tYXgoMCwgaGVhZCAtIDEwMDAwIC8qIEN4VnAuTWFyZ2luICovKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGhlYWQgKyAxMDAwMCAvKiBDeFZwLk1hcmdpbiAqLyk7XG4gICAgfVxuICAgIHJlc2V0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMucmVzZXRSYW5nZShzdGF0ZSk7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlVGV4dCgwLCB0aGlzLmVkaXRDb250ZXh0LnRleHQubGVuZ3RoLCBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHN0YXRlKTtcbiAgICB9XG4gICAgcmV2ZXJ0UGVuZGluZyhzdGF0ZSkge1xuICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQodGhpcy50b0NvbnRleHRQb3MocGVuZGluZy5mcm9tKSwgdGhpcy50b0NvbnRleHRQb3MocGVuZGluZy5mcm9tICsgcGVuZGluZy5pbnNlcnQubGVuZ3RoKSwgc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHBlbmRpbmcuZnJvbSwgcGVuZGluZy50bykpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgbGV0IHsgbWFpbiB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnRvQ29udGV4dFBvcyhNYXRoLm1heCh0aGlzLmZyb20sIE1hdGgubWluKHRoaXMudG8sIG1haW4uYW5jaG9yKSkpO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy50b0NvbnRleHRQb3MobWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQuc2VsZWN0aW9uU3RhcnQgIT0gc3RhcnQgfHwgdGhpcy5lZGl0Q29udGV4dC5zZWxlY3Rpb25FbmQgIT0gZW5kKVxuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVTZWxlY3Rpb24oc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHJhbmdlSXNWYWxpZChzdGF0ZSkge1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgcmV0dXJuICEodGhpcy5mcm9tID4gMCAmJiBoZWFkIC0gdGhpcy5mcm9tIDwgNTAwIC8qIEN4VnAuTWluTWFyZ2luICovIHx8XG4gICAgICAgICAgICB0aGlzLnRvIDwgc3RhdGUuZG9jLmxlbmd0aCAmJiB0aGlzLnRvIC0gaGVhZCA8IDUwMCAvKiBDeFZwLk1pbk1hcmdpbiAqLyB8fFxuICAgICAgICAgICAgdGhpcy50byAtIHRoaXMuZnJvbSA+IDEwMDAwIC8qIEN4VnAuTWFyZ2luICovICogMyk7XG4gICAgfVxuICAgIHRvRWRpdG9yUG9zKGNvbnRleHRQb3MsIGNsaXBMZW4gPSB0aGlzLnRvIC0gdGhpcy5mcm9tKSB7XG4gICAgICAgIGNvbnRleHRQb3MgPSBNYXRoLm1pbihjb250ZXh0UG9zLCBjbGlwTGVuKTtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNvbXBvc2luZztcbiAgICAgICAgcmV0dXJuIGMgJiYgYy5kcmlmdGVkID8gYy5lZGl0b3JCYXNlICsgKGNvbnRleHRQb3MgLSBjLmNvbnRleHRCYXNlKSA6IGNvbnRleHRQb3MgKyB0aGlzLmZyb207XG4gICAgfVxuICAgIHRvQ29udGV4dFBvcyhlZGl0b3JQb3MpIHtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNvbXBvc2luZztcbiAgICAgICAgcmV0dXJuIGMgJiYgYy5kcmlmdGVkID8gYy5jb250ZXh0QmFzZSArIChlZGl0b3JQb3MgLSBjLmVkaXRvckJhc2UpIDogZWRpdG9yUG9zIC0gdGhpcy5mcm9tO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZXJzW2V2ZW50XSk7XG4gICAgfVxufVxuXG4vLyBUaGUgZWRpdG9yJ3MgdXBkYXRlIHN0YXRlIG1hY2hpbmUgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgICAgSWRsZSDihpIgVXBkYXRpbmcg4oeGIElkbGUgKHVuY2hlY2tlZCkg4oaSIE1lYXN1cmluZyDihpIgSWRsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSAgICAgIOKGk1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0aW5nIChtZWFzdXJlKVxuLy9cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0lkbGUnIGFuZCAnSWRsZSAodW5jaGVja2VkKScgbGllcyBpblxuLy8gd2hldGhlciBhIGxheW91dCBjaGVjayBoYXMgYmVlbiBzY2hlZHVsZWQuIEEgcmVndWxhciB1cGRhdGUgdGhyb3VnaFxuLy8gdGhlIGB1cGRhdGVgIG1ldGhvZCB1cGRhdGVzIHRoZSBET00gaW4gYSB3cml0ZS1vbmx5IGZhc2hpb24sIGFuZFxuLy8gcmVsaWVzIG9uIGEgY2hlY2sgKHNjaGVkdWxlZCB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKSB0byBtYWtlXG4vLyBzdXJlIGV2ZXJ5dGhpbmcgaXMgd2hlcmUgaXQgc2hvdWxkIGJlIGFuZCB0aGUgdmlld3BvcnQgY292ZXJzIHRoZVxuLy8gdmlzaWJsZSBjb2RlLiBUaGF0IGNoZWNrIGNvbnRpbnVlcyB0byBtZWFzdXJlIGFuZCB0aGVuIG9wdGlvbmFsbHlcbi8vIHVwZGF0ZSB1bnRpbCBpdCByZWFjaGVzIGEgY29oZXJlbnQgc3RhdGUuXG4vKipcbkFuIGVkaXRvciB2aWV3IHJlcHJlc2VudHMgdGhlIGVkaXRvcidzIHVzZXIgaW50ZXJmYWNlLiBJdCBob2xkc1xudGhlIGVkaXRhYmxlIERPTSBzdXJmYWNlLCBhbmQgcG9zc2libHkgb3RoZXIgZWxlbWVudHMgc3VjaCBhcyB0aGVcbmxpbmUgbnVtYmVyIGd1dHRlci4gSXQgaGFuZGxlcyBldmVudHMgYW5kIGRpc3BhdGNoZXMgc3RhdGVcbnRyYW5zYWN0aW9ucyBmb3IgZWRpdGluZyBhY3Rpb25zLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlOyB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkaXNwbGF5IGxhcmdlIGRvY3VtZW50cyB3aXRob3V0IGNvbnN1bWluZyB0b28gbXVjaFxuICAgIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xuICAgIHByb3BlcnR5IHRlbGxzIHlvdSB0aGUgZXh0ZW50IG9mIHRoZSBjdXJyZW50IGRyYXduIHZpZXdwb3J0LCBpblxuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0OyB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICAgIHZpZXdwb3J0LCBpdHMgc2l6ZSBjYW4gYmUgYSBsb3QgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCB2aXNpYmxlXG4gICAgY29udGVudC4gVGh1cywgaWYgeW91IGFyZSBkb2luZyBzb21ldGhpbmcgbGlrZSBzdHlsaW5nIHRoZVxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gICAgdGhlc2UgcmFuZ2VzLCB3aGljaCBhcmUgdGhlIHN1YnNldCBvZiB0aGUgdmlld3BvcnQgdGhhdCBpc1xuICAgIGFjdHVhbGx5IGRyYXduLlxuICAgICovXG4gICAgZ2V0IHZpc2libGVSYW5nZXMoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcbiAgICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAgICovXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLCBhbmQgYXQgbGVhc3RcbiAgICBvbmUgY2hhbmdlIGhhcyBiZWVuIG1hZGUgaW4gdGhlIGN1cnJlbnQgY29tcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgaW4gY29tcG9zaW5nIHN0YXRlLiBOb3RlXG4gICAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxuICAgIGxvdCwgc2luY2UganVzdCBwdXR0aW5nIHRoZSBjdXJzb3Igb24gYSB3b3JkIHN0YXJ0cyBhXG4gICAgY29tcG9zaXRpb24gdGhlcmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaXRpb25TdGFydGVkKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IG9yIHNoYWRvdyByb290IHRoYXQgdGhlIHZpZXcgbGl2ZXMgaW4uXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aW4oKSB7IHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB2aWV3LiBZb3UnbGwgd2FudCB0byBlaXRoZXIgcHJvdmlkZSBhIGBwYXJlbnRgXG4gICAgb3B0aW9uLCBvciBwdXQgYHZpZXcuZG9tYCBpbnRvIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYVxuICAgIHZpZXcsIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHNlZSB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5NYXAgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0ge307XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0ge307XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5jbGFzc05hbWUgPSBcImNtLXNjcm9sbGVyXCI7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLmNsYXNzTmFtZSA9IFwiY20tYW5ub3VuY2VkXCI7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbERPTSk7XG4gICAgICAgIGlmIChjb25maWcucGFyZW50KVxuICAgICAgICAgICAgY29uZmlnLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIGxldCB7IGRpc3BhdGNoIH0gPSBjb25maWc7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgPSBjb25maWcuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgfHxcbiAgICAgICAgICAgIChkaXNwYXRjaCAmJiAoKHRycykgPT4gdHJzLmZvckVhY2godHIgPT4gZGlzcGF0Y2godHIsIHRoaXMpKSkpIHx8XG4gICAgICAgICAgICAoKHRycykgPT4gdGhpcy51cGRhdGUodHJzKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoY29uZmlnLnJvb3QgfHwgZ2V0Um9vdChjb25maWcucGFyZW50KSB8fCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xuICAgICAgICBpZiAoY29uZmlnLnNjcm9sbFRvICYmIGNvbmZpZy5zY3JvbGxUby5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBjb25maWcuc2Nyb2xsVG8udmFsdWUuY2xpcCh0aGlzLnZpZXdTdGF0ZS5zdGF0ZSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMuc3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZSA9IG5ldyBJbnB1dFN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmICgoX2EgPSBkb2N1bWVudC5mb250cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5KVxuICAgICAgICAgICAgZG9jdW1lbnQuZm9udHMucmVhZHkudGhlbigoKSA9PiB0aGlzLnJlcXVlc3RNZWFzdXJlKCkpO1xuICAgIH1cbiAgICBkaXNwYXRjaCguLi5pbnB1dCkge1xuICAgICAgICBsZXQgdHJzID0gaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IGlucHV0XG4gICAgICAgICAgICA6IGlucHV0Lmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoaW5wdXRbMF0pID8gaW5wdXRbMF1cbiAgICAgICAgICAgICAgICA6IFt0aGlzLnN0YXRlLnVwZGF0ZSguLi5pbnB1dCldO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zKHRycywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIGF0dHJzQ2hhbmdlZCA9IGZhbHNlLCB1cGRhdGU7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUgPSB0ci5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvY3VzID0gdGhpcy5oYXNGb2N1cywgZm9jdXNGbGFnID0gMCwgZGlzcGF0Y2hGb2N1cyA9IG51bGw7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5hbm5vdGF0aW9uKGlzRm9jdXNDaGFuZ2UpKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gSWYgYSBmb2N1cy1jaGFuZ2UgdHJhbnNhY3Rpb24gaXMgYmVpbmcgZGlzcGF0Y2hlZCwgc2V0IHRoaXMgdXBkYXRlIGZsYWcuXG4gICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXMgIT0gdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBzZXBhcmF0ZSBmb2N1cyB0cmFuc2FjdGlvbiBpZiBuZWNlc3NhcnksIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYWRkIGEgZmxhZyB0byB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgZGlzcGF0Y2hGb2N1cyA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICghZGlzcGF0Y2hGb2N1cylcbiAgICAgICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBET00gY2hhbmdlLCBlYWdlcmx5IHJlYWQgaXQgYW5kIHRyeSB0b1xuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxuICAgICAgICBsZXQgcGVuZGluZ0tleSA9IHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXksIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgIGRvbUNoYW5nZSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gT25seSB0cnkgdG8gYXBwbHkgRE9NIGNoYW5nZXMgaWYgdGhlIHRyYW5zYWN0aW9ucyBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChkb21DaGFuZ2UgJiYgIXRoaXMuc3RhdGUuZG9jLmVxKHN0YXRlLmRvYykgfHwgIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBwaHJhc2VzIGNoYW5nZSwgcmVkcmF3IHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gZm9jdXNGbGFnO1xuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0ID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQobWFpbi5lbXB0eSA/IG1haW4gOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG1haW4uaGVhZCwgbWFpbi5oZWFkID4gbWFpbi5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBlLnZhbHVlLmNsaXAodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBDYWNoZWRPcmRlci51cGRhdGUodGhpcy5iaWRpQ2FjaGUsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKSAhPSB0aGlzLnN0eWxlTW9kdWxlcylcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHJlZHJhd24sIHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwic2VsZWN0LnBvaW50ZXJcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHRoZW1lKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhlbWUpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlZHJhd24gfHwgYXR0cnNDaGFuZ2VkIHx8IHNjcm9sbFRhcmdldCB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0RW5mb3JjZUN1cnNvckFzc29jIHx8IHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudClcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXdVcGRhdGUoKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlLCBcInVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaEZvY3VzIHx8IGRvbUNoYW5nZSlcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaEZvY3VzICYmIHRoaXMuc3RhdGUgPT0gZGlzcGF0Y2hGb2N1cy5zdGFydFN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRpc3BhdGNoRm9jdXMpO1xuICAgICAgICAgICAgICAgIGlmIChkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcHBseURPTUNoYW5nZSh0aGlzLCBkb21DaGFuZ2UpICYmIHBlbmRpbmdLZXkuZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmNvbnRlbnRET00sIHBlbmRpbmdLZXkua2V5LCBwZW5kaW5nS2V5LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNldCB0aGUgdmlldyB0byB0aGUgZ2l2ZW4gc3RhdGUuIChUaGlzIHdpbGwgY2F1c2UgdGhlIGVudGlyZVxuICAgIGRvY3VtZW50IHRvIGJlIHJlZHJhd24gYW5kIGFsbCB2aWV3IHBsdWdpbnMgdG8gYmUgcmVpbml0aWFsaXplZCxcbiAgICBzbyB5b3Ugc2hvdWxkIHByb2JhYmx5IG9ubHkgdXNlIGl0IHdoZW4gdGhlIG5ldyBzdGF0ZSBpc24ndFxuICAgIGRlcml2ZWQgZnJvbSB0aGUgb2xkIHN0YXRlLiBPdGhlcndpc2UsIHVzZVxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZC4pXG4gICAgKi9cbiAgICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnNldFN0YXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgbGV0IGhhZEZvY3VzID0gdGhpcy5oYXNGb2N1cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3U3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWRGb2N1cylcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5zKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldlNwZWNzID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodmlld1BsdWdpbiksIHNwZWNzID0gdXBkYXRlLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UGx1Z2lucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHByZXZTcGVjcy5pbmRleE9mKHNwZWMpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5tdXN0VXBkYXRlICE9IHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgICAgIGlmIChwcmV2U3BlY3MgIT0gc3BlY3MpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICB9XG4gICAgZG9jVmlld1VwZGF0ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHBsdWdpbi52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsLmRvY1ZpZXdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWwuZG9jVmlld1VwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUsIFwiZG9jIHZpZXcgdXBkYXRlIGxpc3RlbmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1lYXN1cmUoZmx1c2ggPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IDA7IC8vIFByZXZlbnQgcmVxdWVzdE1lYXN1cmUgY2FsbHMgZnJvbSBzY2hlZHVsaW5nIGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgIGlmIChmbHVzaClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgIGxldCBzRE9NID0gdGhpcy5zY3JvbGxET00sIHNjcm9sbFRvcCA9IHNET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxldCB7IHNjcm9sbEFuY2hvclBvcywgc2Nyb2xsQW5jaG9ySGVpZ2h0IH0gPSB0aGlzLnZpZXdTdGF0ZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNjcm9sbFRvcCAtIHRoaXMudmlld1N0YXRlLnNjcm9sbFRvcCkgPiAxKVxuICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQW5jaG9ySGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTY3JvbGxlZFRvQm90dG9tKHNET00pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IHRoaXMudmlld1N0YXRlLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gYmxvY2suZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IGJsb2NrLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMSAvKiBVcGRhdGVTdGF0ZS5NZWFzdXJpbmcgKi87XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIk1lYXN1cmUgbG9vcCByZXN0YXJ0ZWQgbW9yZSB0aGFuIDUgdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gW107XG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VkICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSlcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMubWVhc3VyZVJlcXVlc3RzLCBtZWFzdXJpbmddID0gW21lYXN1cmluZywgdGhpcy5tZWFzdXJlUmVxdWVzdHNdO1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlZCA9IG1lYXN1cmluZy5tYXAobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5yZWFkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFkTWVhc3VyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCB0aGlzLnN0YXRlLCBbXSksIHJlZHJhd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlld1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtZWFzdXJpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ud3JpdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS52aWV3cG9ydENoYW5nZWQgJiYgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLmVkaXRvckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3QW5jaG9ySGVpZ2h0ID0gc2Nyb2xsQW5jaG9yUG9zIDwgMCA/IHRoaXMudmlld1N0YXRlLmhlaWdodE1hcC5oZWlnaHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChzY3JvbGxBbmNob3JQb3MpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IG5ld0FuY2hvckhlaWdodCAtIHNjcm9sbEFuY2hvckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDEgfHwgZGlmZiA8IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCArIGRpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNET00uc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC8gdGhpcy5zY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkICYmICF1cGRhdGVkLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXG4gICAgKi9cbiAgICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS5mYWNldChkYXJrVGhlbWUpID8gYmFzZURhcmtJRCA6IGJhc2VMaWdodElEKSArIFwiIFwiICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmFjZXQodGhlbWUpO1xuICAgIH1cbiAgICB1cGRhdGVBdHRycygpIHtcbiAgICAgICAgbGV0IGVkaXRvckF0dHJzID0gYXR0cnNGcm9tRmFjZXQodGhpcywgZWRpdG9yQXR0cmlidXRlcywge1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZWRpdG9yXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNvbnRlbnRBdHRycyA9IHtcbiAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0OiBcIm9mZlwiLFxuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICAgICAgICB3cml0aW5nc3VnZ2VzdGlvbnM6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogXCJub1wiLFxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiAhdGhpcy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWNvbnRlbnRcIixcbiAgICAgICAgICAgIHN0eWxlOiBgJHticm93c2VyLnRhYlNpemV9OiAke3RoaXMuc3RhdGUudGFiU2l6ZX1gLFxuICAgICAgICAgICAgcm9sZTogXCJ0ZXh0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IFwidHJ1ZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgY29udGVudEF0dHJzW1wiYXJpYS1yZWFkb25seVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICBhdHRyc0Zyb21GYWNldCh0aGlzLCBjb250ZW50QXR0cmlidXRlcywgY29udGVudEF0dHJzKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZENvbnRlbnQgPSB1cGRhdGVBdHRycyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY29udGVudEF0dHJzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRFZGl0b3IgPSB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5lZGl0b3JBdHRycywgZWRpdG9yQXR0cnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRDb250ZW50IHx8IGNoYW5nZWRFZGl0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0gZWRpdG9yQXR0cnM7XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0gY29udGVudEF0dHJzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgc2hvd0Fubm91bmNlbWVudHModHJzKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRycylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoRWRpdG9yVmlldy5hbm5vdW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZURPTS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLmFubm91bmNlRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudFN0eWxlcygpIHtcbiAgICAgICAgdGhpcy5zdHlsZU1vZHVsZXMgPSB0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKTtcbiAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LmNzcE5vbmNlKTtcbiAgICAgICAgU3R5bGVNb2R1bGUubW91bnQodGhpcy5yb290LCB0aGlzLnN0eWxlTW9kdWxlcy5jb25jYXQoYmFzZVRoZW1lJDEpLnJldmVyc2UoKSwgbm9uY2UgPyB7IG5vbmNlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovICYmIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICAgIGRvIGN1c3RvbSBET00gbWVhc3VyaW5nIGZvbGxvd2VkIGJ5IGEgRE9NIHdyaXRlIHBoYXNlLiBVc2luZ1xuICAgIHRoaXMgaXMgcHJlZmVyYWJsZSByZWFkaW5nIERPTSBsYXlvdXQgZGlyZWN0bHkgZnJvbSwgZm9yXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICAgIGRyYXdpbmcgZG9uZSBieSBvdGhlciBjb21wb25lbnRzIGlzIHN5bmNocm9uaXplZCwgYXZvaWRpbmdcbiAgICB1bm5lY2Vzc2FyeSBET00gbGF5b3V0IGNvbXB1dGF0aW9ucy5cbiAgICAqL1xuICAgIHJlcXVlc3RNZWFzdXJlKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzLmluZGV4T2YocmVxdWVzdCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChrbm93biA9PT0gdW5kZWZpbmVkIHx8IGtub3duICYmIGtub3duLnNwZWMgIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAuc3BlYyA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgSWYgdGhlIGVkaXRvciBpcyB0cmFuc2Zvcm1lZCB3aXRoIENTUywgdGhpcyBwcm92aWRlcyB0aGUgc2NhbGVcbiAgICBhbG9uZyB0aGUgWCBheGlzLiBPdGhlcndpc2UsIGl0IHdpbGwganVzdCBiZSAxLiBOb3RlIHRoYXRcbiAgICB0cmFuc2Zvcm1zIG90aGVyIHRoYW4gdHJhbnNsYXRpb24gYW5kIHNjYWxpbmcgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVYKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVYOyB9XG4gICAgLyoqXG4gICAgUHJvdmlkZSB0aGUgQ1NTIHRyYW5zZm9ybWVkIHNjYWxlIGFsb25nIHRoZSBZIGF4aXMuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVZKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVZOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrLCBvciB0aGVcbiAgICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xuICAgIHdpZGdldHMuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspLiBgZm9yd2FyZGAgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gICAgdGhlIG1vdGlvbiBpcyBhd2F5IGZyb20gdGhlIGxpbmUgc3RhcnQsIG9yIHRvd2FyZHMgaXQuIEluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0LCB0aGUgbGluZSBpcyB0cmF2ZXJzZWQgaW4gdmlzdWFsIG9yZGVyLCB1c2luZ1xuICAgIHRoZSBlZGl0b3IncyBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuICAgIFdoZW4gdGhlIHN0YXJ0IHBvc2l0aW9uIHdhcyB0aGUgbGFzdCBvbmUgb24gdGhlIGxpbmUsIHRoZVxuICAgIHJldHVybmVkIHBvc2l0aW9uIHdpbGwgYmUgYWNyb3NzIHRoZSBsaW5lIGJyZWFrLiBJZiB0aGVyZSBpcyBub1xuICAgIGZ1cnRoZXIgbGluZSwgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIG1vdmVzIG92ZXIgYSBzaW5nbGUgY2x1c3Rlci4gVGhlXG4gICAgb3B0aW9uYWwgYGJ5YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFjcm9zcyBtb3JlLiBJdCB3aWxsXG4gICAgYmUgY2FsbGVkIHdpdGggdGhlIGZpcnN0IGNsdXN0ZXIgYXMgYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuXG4gICAgYSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzLCBmb3IgZWFjaCBzdWJzZXF1ZW50IGNsdXN0ZXIsXG4gICAgd2hldGhlciBpdCBzaG91bGQgYWxzbyBiZSBtb3ZlZCBvdmVyLlxuICAgICovXG4gICAgbW92ZUJ5Q2hhcihzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgYnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBhY3Jvc3MgdGhlIG5leHQgZ3JvdXAgb2YgZWl0aGVyXG4gICAgW2xldHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBvciBub24tbGV0dGVyXG4gICAgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIG1vdmVCeUdyb3VwKHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGluaXRpYWwgPT4gYnlHcm91cCh0aGlzLCBzdGFydC5oZWFkLCBpbml0aWFsKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB2aXN1YWxseSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbGluZS5cbiAgICBOb3RlIHRoYXQgdGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIF9sb2dpY2FsXyBwb3NpdGlvbiBhdCBpdHNcbiAgICBzdGFydCBvciBlbmQgKHdoaWNoIGlzIHNpbXBseSBhdCBgbGluZS5mcm9tYC9gbGluZS50b2ApIGlmIHRleHRcbiAgICBhdCB0aGUgc3RhcnQgb3IgZW5kIGdvZXMgYWdhaW5zdCB0aGUgbGluZSdzIGJhc2UgdGV4dCBkaXJlY3Rpb24uXG4gICAgKi9cbiAgICB2aXN1YWxMaW5lU2lkZShsaW5lLCBlbmQpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSksIGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbZW5kID8gb3JkZXIubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzcGFuLnNpZGUoZW5kLCBkaXIpICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoIWVuZCwgZGlyKSA/IDEgOiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcbiAgICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICAgIHdoZW4gYG5vZGVgIGlzbid0IHBhcnQgb2YgdGhlIGVkaXRvciBjb250ZW50LlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zQXRDb29yZHMoY29vcmRzLCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgICBlbGVtZW50IGJlZm9yZSAoLTEpIG9yIGFmdGVyICgxKSB0aGUgcG9zaXRpb24gKGlmIG5vIGVsZW1lbnQgaXNcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxuICAgIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9jVmlldy5jb29yZHNBdChwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKSwgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAoc3Bhbi5kaXIgPT0gRGlyZWN0aW9uLkxUUikgPT0gKHNpZGUgPiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgcmVjdGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGNoYXJhY3Rlci4gSWYgYHBvc2AgZG9lcyBub3RcbiAgICBwb2ludCBpbiBmcm9udCBvZiBhIGNoYXJhY3RlciB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCBhbmRcbiAgICByZW5kZXJlZCAoaS5lLiBub3QgcmVwbGFjZWQsIG5vdCBhIGxpbmUgYnJlYWspLCB0aGlzIHdpbGwgcmV0dXJuXG4gICAgbnVsbC4gRm9yIHNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYSBsaW5lIHdyYXAgcG9pbnQsIHRoaXMgd2lsbFxuICAgIHJldHVybiB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBsaW5lIGJyZWFrLlxuICAgICovXG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHdpZHRoIG9mIGEgY2hhcmFjdGVyIGluIHRoZSBlZGl0b3IuIE1heSBub3RcbiAgICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7IH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBsaW5lIGluIHRoZSBlZGl0b3IuIE1heSBub3QgYmUgYWNjdXJhdGVcbiAgICBmb3IgYWxsIGxpbmVzLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRMaW5lSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7IH1cbiAgICAvKipcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cbiAgICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICAgIENTUyBwcm9wZXJ0eSkgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnQgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCB0ZXh0RGlyZWN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuZGVmYXVsdFRleHREaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xuICAgIGFzc2lnbmVkIGJ5IENTUy4gSWZcbiAgICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxuICAgIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGFzXG4gICAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxuICAgICovXG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXBlckxpbmUgfHwgcG9zIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHBvcyA+IHRoaXMudmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbinigJRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pLCBpc29sYXRlcztcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgdGhpcy5iaWRpQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyICYmXG4gICAgICAgICAgICAgICAgKGVudHJ5LmZyZXNoIHx8IGlzb2xhdGVzRXEoZW50cnkuaXNvbGF0ZXMsIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkub3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc29sYXRlcylcbiAgICAgICAgICAgIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSk7XG4gICAgICAgIGxldCBvcmRlciA9IGNvbXB1dGVPcmRlcihsaW5lLnRleHQsIGRpciwgaXNvbGF0ZXMpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgaXNvbGF0ZXMsIHRydWUsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKCkgfHwgYnJvd3Nlci5zYWZhcmkgJiYgKChfYSA9IHRoaXMuaW5wdXRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDb250ZXh0TWVudSkgPiBEYXRlLm5vdygpIC0gM2U0KSAmJlxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcbiAgICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT0gcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTS5ibHVyKCk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IGNhbiBiZVxuICAgIFthZGRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdG8gYSB0cmFuc2FjdGlvbiB0b1xuICAgIGNhdXNlIGl0IHRvIHNjcm9sbCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgcmFuZ2UgaW50byB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIHNjcm9sbEludG9WaWV3KHBvcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KHR5cGVvZiBwb3MgPT0gXCJudW1iZXJcIiA/IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKSA6IHBvcywgb3B0aW9ucy55LCBvcHRpb25zLngsIG9wdGlvbnMueU1hcmdpbiwgb3B0aW9ucy54TWFyZ2luKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhbiBlZmZlY3QgdGhhdCByZXNldHMgdGhlIGVkaXRvciB0byBpdHMgY3VycmVudCAoYXQgdGhlXG4gICAgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkKSBzY3JvbGwgcG9zaXRpb24uIE5vdGUgdGhhdCB0aGlzXG4gICAgb25seSBhZmZlY3RzIHRoZSBlZGl0b3IncyBvd24gc2Nyb2xsYWJsZSBlbGVtZW50LCBub3QgcGFyZW50cy5cbiAgICBTZWUgYWxzb1xuICAgIFtgRWRpdG9yVmlld0NvbmZpZy5zY3JvbGxUb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvKS5cbiAgICBcbiAgICBUaGUgZWZmZWN0IHNob3VsZCBiZSB1c2VkIHdpdGggYSBkb2N1bWVudCBpZGVudGljYWwgdG8gdGhlIG9uZVxuICAgIGl0IHdhcyBjcmVhdGVkIGZvci4gRmFpbGluZyB0byBkbyBzbyBpcyBub3QgYW4gZXJyb3IsIGJ1dCBtYXlcbiAgICBub3Qgc2Nyb2xsIHRvIHRoZSBleHBlY3RlZCBwb3NpdGlvbi4gWW91IGNhblxuICAgIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0aGUgZWZmZWN0IHRvIGFjY291bnQgZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBzY3JvbGxTbmFwc2hvdCgpIHtcbiAgICAgICAgbGV0IHsgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmVmLmZyb20pLCBcInN0YXJ0XCIsIFwic3RhcnRcIiwgcmVmLnRvcCAtIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBFbmFibGUgb3IgZGlzYWJsZSB0YWItZm9jdXMgbW9kZSwgd2hpY2ggZGlzYWJsZXMga2V5IGJpbmRpbmdzXG4gICAgZm9yIFRhYiBhbmQgU2hpZnQtVGFiLCBsZXR0aW5nIHRoZSBicm93c2VyJ3MgZGVmYXVsdFxuICAgIGZvY3VzLWNoYW5naW5nIGJlaGF2aW9yIGdvIHRocm91Z2ggaW5zdGVhZC4gVGhpcyBpcyB1c2VmdWwgdG9cbiAgICBwcmV2ZW50IHRyYXBwaW5nIGtleWJvYXJkIHVzZXJzIGluIHlvdXIgZWRpdG9yLlxuICAgIFxuICAgIFdpdGhvdXQgYXJndW1lbnQsIHRoaXMgdG9nZ2xlcyB0aGUgbW9kZS4gV2l0aCBhIGJvb2xlYW4sIGl0XG4gICAgZW5hYmxlcyAodHJ1ZSkgb3IgZGlzYWJsZXMgaXQgKGZhbHNlKS4gR2l2ZW4gYSBudW1iZXIsIGl0XG4gICAgdGVtcG9yYXJpbHkgZW5hYmxlcyB0aGUgbW9kZSB1bnRpbCB0aGF0IG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICBoYXZlIHBhc3NlZCBvciBhbm90aGVyIG5vbi1UYWIga2V5IGlzIHByZXNzZWQuXG4gICAgKi9cbiAgICBzZXRUYWJGb2N1c01vZGUodG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA8IDAgPyAwIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0byA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSB0byA/IDAgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSAhPSAwKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IERhdGUubm93KCkgKyB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICAgIFRoZSB2YWx1ZSBzaG91bGQgYmUgYW4gb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gaGFuZGxlclxuICAgIGZ1bmN0aW9ucy4gRm9yIGFueSBnaXZlbiBldmVudCwgc3VjaCBmdW5jdGlvbnMgYXJlIG9yZGVyZWQgYnlcbiAgICBleHRlbnNpb24gcHJlY2VkZW5jZSwgYW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRvIHJldHVybiB0cnVlIHdpbGxcbiAgICBiZSBhc3N1bWVkIHRvIGhhdmUgaGFuZGxlZCB0aGF0IGV2ZW50LCBhbmQgbm8gb3RoZXIgaGFuZGxlcnMgb3JcbiAgICBidWlsdC1pbiBiZWhhdmlvciB3aWxsIGJlIGFjdGl2YXRlZCBmb3IgaXQuIFRoZXNlIGFyZSByZWdpc3RlcmVkXG4gICAgb24gdGhlIFtjb250ZW50IGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHRcbiAgICBmb3IgYHNjcm9sbGAgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZVxuICAgIGVkaXRvcidzIFtzY3JvbGwgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2Nyb2xsRE9NKSBvciBvbmUgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGVzIGlzIHNjcm9sbGVkLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50SGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRIYW5kbGVyczogaGFuZGxlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCByZWdpc3RlcnMgRE9NIGV2ZW50IG9ic2VydmVycy4gQ29udHJhcnlcbiAgICB0byBldmVudCBbaGFuZGxlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRvbUV2ZW50SGFuZGxlcnMpLFxuICAgIG9ic2VydmVycyBjYW4ndCBiZSBwcmV2ZW50ZWQgZnJvbSBydW5uaW5nIGJ5IGEgaGlnaGVyLXByZWNlZGVuY2VcbiAgICBoYW5kbGVyIHJldHVybmluZyB0cnVlLiBUaGV5IGFsc28gZG9uJ3QgcHJldmVudCBvdGhlciBoYW5kbGVyc1xuICAgIGFuZCBvYnNlcnZlcnMgZnJvbSBydW5uaW5nIHdoZW4gdGhleSByZXR1cm4gdHJ1ZSwgYW5kIHNob3VsZCBub3RcbiAgICBjYWxsIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRPYnNlcnZlcnMob2JzZXJ2ZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50T2JzZXJ2ZXJzOiBvYnNlcnZlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbilcbiAgICBzdHlsZSBzcGVjIHByb3ZpZGluZyB0aGUgc3R5bGVzIGZvciB0aGUgdGhlbWUuIFRoZXNlIHdpbGwgYmVcbiAgICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXG4gICAgXG4gICAgQmVjYXVzZSB0aGUgc2VsZWN0b3JzIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCBhIHNjb3BlIGNsYXNzLCBydWxlXG4gICAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcbiAgICBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb20p4oCUdG8gd2hpY2ggdGhlIHNjb3BlIGNsYXNzIHdpbGwgYmVcbiAgICBhZGRlZOKAlG5lZWQgdG8gYmUgZXhwbGljaXRseSBkaWZmZXJlbnRpYXRlZCBieSBhZGRpbmcgYW4gYCZgIHRvXG4gICAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnTigJRmb3IgZXhhbXBsZVxuICAgIGAmLmNtLWZvY3VzZWRgLlxuICAgIFxuICAgIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcbiAgICB3aGljaCB3aWxsIGNhdXNlIHRoZSBgJmRhcmtgIHJ1bGVzIGZyb20gW2Jhc2VcbiAgICB0aGVtZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmJhc2VUaGVtZSkgdG8gYmUgdXNlZCAoYXMgb3Bwb3NlZCB0b1xuICAgIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxuICAgICovXG4gICAgc3RhdGljIHRoZW1lKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFt0aGVtZS5vZihwcmVmaXgpLCBzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKGAuJHtwcmVmaXh9YCwgc3BlYykpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kYXJrKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGFya1RoZW1lLm9mKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgc3R5bGVzIHRvIHRoZSBiYXNlIHRoZW1lLiBMaWtlXG4gICAgd2l0aCBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpLCB1c2UgYCZgIHRvIGluZGljYXRlIHRoZVxuICAgIHBsYWNlIG9mIHRoZSBlZGl0b3Igd3JhcHBlciBlbGVtZW50IHdoZW4gZGlyZWN0bHkgdGFyZ2V0aW5nXG4gICAgdGhhdC4gWW91IGNhbiBhbHNvIHVzZSBgJmRhcmtgIG9yIGAmbGlnaHRgIGluc3RlYWQgdG8gb25seVxuICAgIHRhcmdldCBlZGl0b3JzIHdpdGggYSBkYXJrIG9yIGxpZ2h0IHRoZW1lLlxuICAgICovXG4gICAgc3RhdGljIGJhc2VUaGVtZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBQcmVjLmxvd2VzdChzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHNwZWMsIGxpZ2h0RGFya0lEcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYW4gZWRpdG9yIHZpZXcgaW5zdGFuY2UgZnJvbSB0aGUgdmlldydzIERPTVxuICAgIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tRE9NKGRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZW50ID0gZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tY29udGVudFwiKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gY29udGVudCAmJiBDb250ZW50Vmlldy5nZXQoY29udGVudCkgfHwgQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIHJldHVybiAoKF9hID0gY1ZpZXcgPT09IG51bGwgfHwgY1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNWaWV3LnJvb3RWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlldykgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkZhY2V0IHRvIGFkZCBhIFtzdHlsZVxubW9kdWxlXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbikgdG9cbmFuIGVkaXRvciB2aWV3LiBUaGUgdmlldyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBtb2R1bGUgaXNcbm1vdW50ZWQgaW4gaXRzIFtkb2N1bWVudFxucm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29uc3RydWN0b3JeY29uZmlnLnJvb3QpLlxuKi9cbkVkaXRvclZpZXcuc3R5bGVNb2R1bGUgPSBzdHlsZU1vZHVsZTtcbi8qKlxuQW4gaW5wdXQgaGFuZGxlciBjYW4gb3ZlcnJpZGUgdGhlIHdheSBjaGFuZ2VzIHRvIHRoZSBlZGl0YWJsZVxuRE9NIGNvbnRlbnQgYXJlIGhhbmRsZWQuIEhhbmRsZXJzIGFyZSBwYXNzZWQgdGhlIGRvY3VtZW50XG5wb3NpdGlvbnMgYmV0d2VlbiB3aGljaCB0aGUgY2hhbmdlIHdhcyBmb3VuZCwgYW5kIHRoZSBuZXdcbmNvbnRlbnQuIFdoZW4gb25lIHJldHVybnMgdHJ1ZSwgbm8gZnVydGhlciBpbnB1dCBoYW5kbGVycyBhcmVcbmNhbGxlZCBhbmQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLlxuXG5UaGUgYGluc2VydGAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBkZWZhdWx0IHRyYW5zYWN0aW9uXG50aGF0IHdvdWxkIGJlIGFwcGxpZWQgZm9yIHRoaXMgaW5wdXQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuXG5kaXNwYXRjaGluZyB0aGUgY3VzdG9tIGJlaGF2aW9yIGFzIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkZ1bmN0aW9ucyBwcm92aWRlZCBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgdXNlZCB0byB0cmFuc2Zvcm0gdGV4dFxucGFzdGVkIG9yIGRyb3BwZWQgaW50byB0aGUgZWRpdG9yLlxuKi9cbkVkaXRvclZpZXcuY2xpcGJvYXJkSW5wdXRGaWx0ZXIgPSBjbGlwYm9hcmRJbnB1dEZpbHRlcjtcbi8qKlxuVHJhbnNmb3JtIHRleHQgY29waWVkIG9yIGRyYWdnZWQgZnJvbSB0aGUgZWRpdG9yLlxuKi9cbkVkaXRvclZpZXcuY2xpcGJvYXJkT3V0cHV0RmlsdGVyID0gY2xpcGJvYXJkT3V0cHV0RmlsdGVyO1xuLyoqXG5TY3JvbGwgaGFuZGxlcnMgY2FuIG92ZXJyaWRlIGhvdyB0aGluZ3MgYXJlIHNjcm9sbGVkIGludG8gdmlldy5cbklmIHRoZXkgcmV0dXJuIGB0cnVlYCwgbm8gZnVydGhlciBoYW5kbGluZyBoYXBwZW5zIGZvciB0aGVcbnNjcm9sbGluZy4gSWYgdGhleSByZXR1cm4gZmFsc2UsIHRoZSBkZWZhdWx0IHNjcm9sbCBiZWhhdmlvciBpc1xuYXBwbGllZC4gU2Nyb2xsIGhhbmRsZXJzIHNob3VsZCBuZXZlciBpbml0aWF0ZSBlZGl0b3IgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbEhhbmRsZXIgPSBzY3JvbGxIYW5kbGVyO1xuLyoqXG5UaGlzIGZhY2V0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGVmZmVjdHNcbnRvIGJlIGRpc3BhdGNoZWQgd2hlbiB0aGUgZWRpdG9yJ3MgZm9jdXMgc3RhdGUgY2hhbmdlcy5cbiovXG5FZGl0b3JWaWV3LmZvY3VzQ2hhbmdlRWZmZWN0ID0gZm9jdXNDaGFuZ2VFZmZlY3Q7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXPigJRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5GYWNldCB0aGF0IHdvcmtzIG11Y2ggbGlrZVxuW2BkZWNvcmF0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgYnV0IHB1dHMgaXRzXG5pbnB1dHMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBwcmVjZWRlbmNlIHN0YWNrLCBtZWFuaW5nIG1hcmtcbmRlY29yYXRpb25zIHByb3ZpZGVkIGhlcmUgd2lsbCBvbmx5IGJlIHNwbGl0IGJ5IG90aGVyLCBwYXJ0aWFsbHlcbm92ZXJsYXBwaW5nIFxcYG91dGVyRGVjb3JhdGlvbnNcXGAgcmFuZ2VzLCBhbmQgd3JhcCBhcm91bmQgYWxsXG5yZWd1bGFyIGRlY29yYXRpb25zLiBVc2UgdGhpcyBmb3IgbWFyayBlbGVtZW50cyB0aGF0IHNob3VsZCwgYXNcbm11Y2ggYXMgcG9zc2libGUsIHJlbWFpbiBpbiBvbmUgcGllY2UuXG4qL1xuRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zID0gb3V0ZXJEZWNvcmF0aW9ucztcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cbkVkaXRvclZpZXcuYXRvbWljUmFuZ2VzID0gYXRvbWljUmFuZ2VzO1xuLyoqXG5XaGVuIHJhbmdlIGRlY29yYXRpb25zIGFkZCBhIGB1bmljb2RlLWJpZGk6IGlzb2xhdGVgIHN0eWxlLCB0aGV5XG5zaG91bGQgYWxzbyBpbmNsdWRlIGFcbltgYmlkaUlzb2xhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTWFya0RlY29yYXRpb25TcGVjLmJpZGlJc29sYXRlKSBwcm9wZXJ0eVxuaW4gdGhlaXIgZGVjb3JhdGlvbiBzcGVjLCBhbmQgYmUgZXhwb3NlZCB0aHJvdWdoIHRoaXMgZmFjZXQsIHNvXG50aGF0IHRoZSBlZGl0b3IgY2FuIGNvbXB1dGUgdGhlIHByb3BlciB0ZXh0IG9yZGVyLiAoT3RoZXIgdmFsdWVzXG5mb3IgYHVuaWNvZGUtYmlkaWAsIGV4Y2VwdCBvZiBjb3Vyc2UgYG5vcm1hbGAsIGFyZSBub3RcbnN1cHBvcnRlZC4pXG4qL1xuRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMgPSBiaWRpSXNvbGF0ZWRSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcblByb3ZpZGVzIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbnRoZSBzdHlsZSBzaGVldHMgZm9yIHRoZSBlZGl0b3IuIEhvbGRzIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBub1xubm9uY2UgaGFzIGJlZW4gcHJvdmlkZWQuXG4qL1xuRWRpdG9yVmlldy5jc3BOb25jZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IFwiXCIgfSk7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBpc29sYXRlcywgZnJlc2gsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuaXNvbGF0ZXMgPSBpc29sYXRlcztcbiAgICAgICAgdGhpcy5mcmVzaCA9IGZyZXNoO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgJiYgIWNhY2hlLnNvbWUoYyA9PiBjLmZyZXNoKSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5pc29sYXRlcywgZmFsc2UsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSAvKkBfX1BVUkVfXyovUHJlYy5kZWZhdWx0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIFwiZWRpdG9yXCIpO1xuICAgIH1cbn0pKTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBUaGlzIGlzIGhpZGRlbiBiZWhpbmQgYW4gaW5kaXJlY3Rpb24sIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbXB1dGVkXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXG5mdW5jdGlvbiBnZXRLZXltYXAoc3RhdGUpIHtcbiAgICBsZXQgYmluZGluZ3MgPSBzdGF0ZS5mYWNldChrZXltYXApO1xuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XG4gICAgaWYgKCFtYXApXG4gICAgICAgIEtleW1hcHMuc2V0KGJpbmRpbmdzLCBtYXAgPSBidWlsZEtleW1hcChiaW5kaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpKTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcbm9iamVjdCBzaG91bGQgYmUgYSBgXCJrZXlkb3duXCJgIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZVxuaGFuZGxlcnMgaGFuZGxlZCBpdC5cbiovXG5mdW5jdGlvbiBydW5TY29wZUhhbmRsZXJzKHZpZXcsIGV2ZW50LCBzY29wZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBzY29wZSk7XG59XG5sZXQgc3RvcmVkUHJlZml4ID0gbnVsbDtcbmNvbnN0IFByZWZpeFRpbWVvdXQgPSA0MDAwO1xuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XG4gICAgbGV0IGJvdW5kID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaXNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IGlzUHJlZml4W25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCAhPSBpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBiaW5kaW5nIFwiICsgbmFtZSArIFwiIGlzIHVzZWQgYm90aCBhcyBhIHJlZ3VsYXIgYmluZGluZyBhbmQgYXMgYSBtdWx0aS1zdHJva2UgcHJlZml4XCIpO1xuICAgIH07XG4gICAgbGV0IGFkZCA9IChzY29wZSwga2V5LCBjb21tYW5kLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgYmluZGluZy5zdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBzdG9wUHJvcGFnYXRpb246IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgbGV0IHsgYW55IH0gPSBiO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzY29wZU9iailcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmpba2V5XS5ydW4ucHVzaCh2aWV3ID0+IGFueSh2aWV3LCBjdXJyZW50S2V5RXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbn1cbmxldCBjdXJyZW50S2V5RXZlbnQgPSBudWxsO1xuZnVuY3Rpb24gcnVuSGFuZGxlcnMobWFwLCBldmVudCwgdmlldywgc2NvcGUpIHtcbiAgICBjdXJyZW50S2V5RXZlbnQgPSBldmVudDtcbiAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpO1xuICAgIGxldCBjaGFyQ29kZSA9IGNvZGVQb2ludEF0KG5hbWUsIDApLCBpc0NoYXIgPSBjb2RlUG9pbnRTaXplKGNoYXJDb2RlKSA9PSBuYW1lLmxlbmd0aCAmJiBuYW1lICE9IFwiIFwiO1xuICAgIGxldCBwcmVmaXggPSBcIlwiLCBoYW5kbGVkID0gZmFsc2UsIHByZXZlbnRlZCA9IGZhbHNlLCBzdG9wUHJvcGFnYXRpb24gPSBmYWxzZTtcbiAgICBpZiAoc3RvcmVkUHJlZml4ICYmIHN0b3JlZFByZWZpeC52aWV3ID09IHZpZXcgJiYgc3RvcmVkUHJlZml4LnNjb3BlID09IHNjb3BlKSB7XG4gICAgICAgIHByZWZpeCA9IHN0b3JlZFByZWZpeC5wcmVmaXggKyBcIiBcIjtcbiAgICAgICAgaWYgKG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApIHtcbiAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByYW4gPSBuZXcgU2V0O1xuICAgIGxldCBydW5Gb3IgPSAoYmluZGluZykgPT4ge1xuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgY21kIG9mIGJpbmRpbmcucnVuKVxuICAgICAgICAgICAgICAgIGlmICghcmFuLmhhcyhjbWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbi5hZGQoY21kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZCh2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWUsIHNoaWZ0TmFtZTtcbiAgICBpZiAoc2NvcGVPYmopIHtcbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkgJiZcbiAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAhKGJyb3dzZXIud2luZG93cyAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSkgJiZcbiAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHNoaWZ0W2V2ZW50LmtleUNvZGVdKSAhPSBuYW1lICYmIHNoaWZ0TmFtZSAhPSBiYXNlTmFtZSAmJlxuICAgICAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoc2hpZnROYW1lLCBldmVudCwgZmFsc2UpXSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkgJiZcbiAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCAmJiBydW5Gb3Ioc2NvcGVPYmouX2FueSkpXG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnRlZClcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgaWYgKGhhbmRsZWQgJiYgc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjdXJyZW50S2V5RXZlbnQgPSBudWxsO1xuICAgIHJldHVybiBoYW5kbGVkO1xufVxuXG4vKipcbkltcGxlbWVudGF0aW9uIG9mIFtgTGF5ZXJNYXJrZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTGF5ZXJNYXJrZXIpIHRoYXQgY3JlYXRlc1xuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXG4qL1xuY2xhc3MgUmVjdGFuZ2xlTWFya2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrZXIgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGRpbWVuc2lvbnMuIElmIGB3aWR0aGBcbiAgICBpcyBudWxsLCB0aGUgRE9NIGVsZW1lbnQgd2lsbCBnZXQgbm8gd2lkdGggc3R5bGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgKGluIHBpeGVscywgZG9jdW1lbnQtcmVsYXRpdmUpLlxuICAgICovXG4gICAgbGVmdCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgb3IgbnVsbCBpZiBpdCBzaG91bGRuJ3QgZ2V0IGEgd2lkdGggYXNzaWduZWQuXG4gICAgKi9cbiAgICB3aWR0aCwgXG4gICAgLyoqXG4gICAgVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgdXBkYXRlKGVsdCwgcHJldikge1xuICAgICAgICBpZiAocHJldi5jbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIHJlY3RhbmdsZXMgZm9yIHRoZSBnaXZlbiBzZWxlY3Rpb24gcmFuZ2UsXG4gICAgYXNzaWduaW5nIHRoZW0gdGhlY2xhc3NgY2xhc3NOYW1lYC4gV2lsbCBjcmVhdGUgYSBzaW5nbGVcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxuICAgIHJlY3RhbmdsZXMgY292ZXJpbmcgdGhlIHJhbmdlJ3MgY29udGVudCAoaW4gYSBiaWRpLWF3YXJlXG4gICAgd2F5KSBmb3Igbm9uLWVtcHR5IG9uZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgcG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgbnVsbCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGggKiB2aWV3LnNjYWxlWDtcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgc2lkZSwgaW5zaWRlKSB7XG4gICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zLCBzaWRlICogMik7XG4gICAgaWYgKCFjb29yZHMpXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgeSA9IChjb29yZHMudG9wICsgY29vcmRzLmJvdHRvbSkgLyAyO1xuICAgIGxldCBsZWZ0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGVkaXRvclJlY3QubGVmdCArIDEsIHkgfSk7XG4gICAgbGV0IHJpZ2h0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGVkaXRvclJlY3QucmlnaHQgLSAxLCB5IH0pO1xuICAgIGlmIChsZWZ0ID09IG51bGwgfHwgcmlnaHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICByZXR1cm4geyBmcm9tOiBNYXRoLm1heChpbnNpZGUuZnJvbSwgTWF0aC5taW4obGVmdCwgcmlnaHQpKSwgdG86IE1hdGgubWluKGluc2lkZS50bywgTWF0aC5tYXgobGVmdCwgcmlnaHQpKSB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UudG8gPD0gdmlldy52aWV3cG9ydC5mcm9tIHx8IHJhbmdlLmZyb20gPj0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBmcm9tID0gTWF0aC5tYXgocmFuZ2UuZnJvbSwgdmlldy52aWV3cG9ydC5mcm9tKSwgdG8gPSBNYXRoLm1pbihyYW5nZS50bywgdmlldy52aWV3cG9ydC50byk7XG4gICAgbGV0IGx0ciA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIGxldCBsaW5lRWx0ID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmNtLWxpbmVcIiksIGxpbmVTdHlsZSA9IGxpbmVFbHQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUobGluZUVsdCk7XG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArXG4gICAgICAgIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ0xlZnQpICsgTWF0aC5taW4oMCwgcGFyc2VJbnQobGluZVN0eWxlLnRleHRJbmRlbnQpKSA6IDApO1xuICAgIGxldCByaWdodFNpZGUgPSBjb250ZW50UmVjdC5yaWdodCAtIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgIGxldCBzdGFydEJsb2NrID0gYmxvY2tBdCh2aWV3LCBmcm9tKSwgZW5kQmxvY2sgPSBibG9ja0F0KHZpZXcsIHRvKTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBzdGFydEJsb2NrIDogbnVsbDtcbiAgICBsZXQgdmlzdWFsRW5kID0gZW5kQmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGVuZEJsb2NrIDogbnVsbDtcbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgKHZpZXcubGluZVdyYXBwaW5nIHx8IHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbFN0YXJ0ID0gd3JhcHBlZExpbmUodmlldywgZnJvbSwgMSwgdmlzdWFsU3RhcnQpO1xuICAgIGlmICh2aXN1YWxFbmQgJiYgKHZpZXcubGluZVdyYXBwaW5nIHx8IGVuZEJsb2NrLndpZGdldExpbmVCcmVha3MpKVxuICAgICAgICB2aXN1YWxFbmQgPSB3cmFwcGVkTGluZSh2aWV3LCB0bywgLTEsIHZpc3VhbEVuZCk7XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCAmJiB2aXN1YWxTdGFydC5mcm9tID09IHZpc3VhbEVuZC5mcm9tICYmIHZpc3VhbFN0YXJ0LnRvID09IHZpc3VhbEVuZC50bykge1xuICAgICAgICByZXR1cm4gcGllY2VzKGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIHJhbmdlLnRvLCB2aXN1YWxTdGFydCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvcCA9IHZpc3VhbFN0YXJ0ID8gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpIDogZHJhd0ZvcldpZGdldChzdGFydEJsb2NrLCBmYWxzZSk7XG4gICAgICAgIGxldCBib3R0b20gPSB2aXN1YWxFbmQgPyBkcmF3Rm9yTGluZShudWxsLCByYW5nZS50bywgdmlzdWFsRW5kKSA6IGRyYXdGb3JXaWRnZXQoZW5kQmxvY2ssIHRydWUpO1xuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xuICAgICAgICBpZiAoKHZpc3VhbFN0YXJ0IHx8IHN0YXJ0QmxvY2spLnRvIDwgKHZpc3VhbEVuZCB8fCBlbmRCbG9jaykuZnJvbSAtICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgPyAxIDogMCkgfHxcbiAgICAgICAgICAgIHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcyA+IDEgJiYgdG9wLmJvdHRvbSArIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyIDwgYm90dG9tLnRvcClcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogQy5FcHNpbG9uICovLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCArIDAuMDEgLyogQy5FcHNpbG9uICovKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQ29vcmRzIHx8ICF0b0Nvb3JkcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuY2xhc3MgTGF5ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBsYXllcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuZHJhd24gPSBbXTtcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5tZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXcuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XG4gICAgICAgIGlmIChsYXllci5hYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllci1hYm92ZVwiKTtcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChsYXllci5jbGFzcyk7XG4gICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNldE9yZGVyKHZpZXcuc3RhdGUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmIChsYXllci5tb3VudClcbiAgICAgICAgICAgIGxheWVyLm1vdW50KHRoaXMuZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGF5ZXJPcmRlcikgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxheWVyT3JkZXIpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGUodXBkYXRlLCB0aGlzLmRvbSkgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb2NWaWV3VXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIudXBkYXRlT25Eb2NWaWV3VXBkYXRlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICB9XG4gICAgc2V0T3JkZXIoc3RhdGUpIHtcbiAgICAgICAgbGV0IHBvcyA9IDAsIG9yZGVyID0gc3RhdGUuZmFjZXQobGF5ZXJPcmRlcik7XG4gICAgICAgIHdoaWxlIChwb3MgPCBvcmRlci5sZW5ndGggJiYgb3JkZXJbcG9zXSAhPSB0aGlzLmxheWVyKVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLnpJbmRleCA9IFN0cmluZygodGhpcy5sYXllci5hYm92ZSA/IDE1MCA6IC0xKSAtIHBvcyk7XG4gICAgfVxuICAgIG1lYXN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyLm1hcmtlcnModGhpcy52aWV3KTtcbiAgICB9XG4gICAgc2NhbGUoKSB7XG4gICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIGlmIChzY2FsZVggIT0gdGhpcy5zY2FsZVggfHwgc2NhbGVZICE9IHRoaXMuc2NhbGVZKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIHNjYWxlWH0sICR7MSAvIHNjYWxlWX0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoICE9IHRoaXMuZHJhd24ubGVuZ3RoIHx8IG1hcmtlcnMuc29tZSgocCwgaSkgPT4gIXNhbWVNYXJrZXIocCwgdGhpcy5kcmF3bltpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkID0gdGhpcy5kb20uZmlyc3RDaGlsZCwgb2xkSSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBtYXJrZXIgb2YgbWFya2Vycykge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIudXBkYXRlICYmIG9sZCAmJiBtYXJrZXIuY29uc3RydWN0b3IgJiYgdGhpcy5kcmF3bltvbGRJXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIudXBkYXRlKG9sZCwgdGhpcy5kcmF3bltvbGRJXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkID0gb2xkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvbGRJKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLmRyYXcoKSwgb2xkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2xkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgb2xkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIG9sZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYXduID0gbWFya2VycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sYXllci5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5sYXllci5kZXN0cm95KHRoaXMuZG9tLCB0aGlzLnZpZXcpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59XG5jb25zdCBsYXllck9yZGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYSBsYXllci5cbiovXG5mdW5jdGlvbiBsYXllcihjb25maWcpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2ID0+IG5ldyBMYXllclZpZXcodiwgY29uZmlnKSksXG4gICAgICAgIGxheWVyT3JkZXIub2YoY29uZmlnKVxuICAgIF07XG59XG5cbmNvbnN0IENhbkhpZGVQcmltYXJ5ID0gIShicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdCAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNTM0KTtcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjdXJzb3JMYXllcixcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIsXG4gICAgICAgIGhpZGVOYXRpdmVTZWxlY3Rpb24sXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxuICAgIF07XG59XG4vKipcblJldHJpZXZlIHRoZSBbYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY29uZmlndXJhdGlvblxuZm9yIHRoaXMgc3RhdGUuIChOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBhIHNldCBvZiBkZWZhdWx0cyBldmVuXG5pZiBgZHJhd1NlbGVjdGlvbmAgaXNuJ3QgZW5hYmxlZC4pXG4qL1xuZnVuY3Rpb24gZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xufVxuZnVuY3Rpb24gY29uZmlnQ2hhbmdlZCh1cGRhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmNvbnN0IGN1cnNvckxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogdHJ1ZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCB0aGVtZVNwZWMgPSB7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvbiwgJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIFwiJiA6Zm9jdXNcIjoge1xuICAgICAgICAgICAgY2FyZXRDb2xvcjogXCJpbml0aWFsICFpbXBvcnRhbnRcIixcbiAgICAgICAgICAgIFwiJjo6c2VsZWN0aW9uLCAmIDo6c2VsZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiSGlnaGxpZ2h0ICFpbXBvcnRhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmlmIChDYW5IaWRlUHJpbWFyeSlcbiAgICB0aGVtZVNwZWNbXCIuY20tbGluZVwiXS5jYXJldENvbG9yID0gdGhlbWVTcGVjW1wiLmNtLWNvbnRlbnRcIl0uY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiO1xuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0IC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIC8gdGhpcy52aWV3LnNjYWxlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgLVxuICAgICAgICAgICAgdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCA+PSAwICYmIGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5saW5lKHsgY2xhc3M6IFwiY20tYWN0aXZlTGluZVwiIH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChyLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2gobGluZURlY28ucmFuZ2UobGluZS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuXG5jbGFzcyBQbGFjZWhvbGRlciBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgd3JhcC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jb250ZW50KSA6XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5jb250ZW50ID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuY29udGVudCh2aWV3KSA6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJwbGFjZWhvbGRlciBcIiArIHRoaXMuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICByZXR1cm4gd3JhcDtcbiAgICB9XG4gICAgY29vcmRzQXQoZG9tKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGRvbS5maXJzdENoaWxkID8gY2xpZW50UmVjdHNGb3IoZG9tLmZpcnN0Q2hpbGQpIDogW107XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5wYXJlbnROb2RlKTtcbiAgICAgICAgbGV0IHJlY3QgPSBmbGF0dGVuUmVjdChyZWN0c1swXSwgc3R5bGUuZGlyZWN0aW9uICE9IFwicnRsXCIpO1xuICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBhcnNlSW50KHN0eWxlLmxpbmVIZWlnaHQpO1xuICAgICAgICBpZiAocmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGxpbmVIZWlnaHQgKiAxLjUpXG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbGluZUhlaWdodCB9O1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLyoqXG5FeHRlbnNpb24gdGhhdCBlbmFibGVzIGEgcGxhY2Vob2xkZXLigJRhIHBpZWNlIG9mIGV4YW1wbGUgY29udGVudFxudG8gc2hvdyB3aGVuIHRoZSBlZGl0b3IgaXMgZW1wdHkuXG4qL1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIoY29udGVudCkge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gY29udGVudFxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi5zZXQoW0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiBuZXcgUGxhY2Vob2xkZXIoY29udGVudCksIHNpZGU6IDEgfSkucmFuZ2UoMCldKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZWNvcmF0aW9ucygpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gRGVjb3JhdGlvbi5ub25lIDogdGhpcy5wbGFjZWhvbGRlcjsgfVxuICAgIH0sIHsgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9ucyB9KTtcbn1cblxuLy8gRG9uJ3QgY29tcHV0ZSBwcmVjaXNlIGNvbHVtbiBwb3NpdGlvbnMgZm9yIGxpbmUgb2Zmc2V0cyBhYm92ZSB0aGlzXG4vLyAoc2luY2UgaXQgY291bGQgZ2V0IGV4cGVuc2l2ZSkuIEFzc3VtZSBvZmZzZXQ9PWNvbHVtbiBmb3IgdGhlbS5cbmNvbnN0IE1heE9mZiA9IDIwMDA7XG5mdW5jdGlvbiByZWN0YW5nbGVGb3Ioc3RhdGUsIGEsIGIpIHtcbiAgICBsZXQgc3RhcnRMaW5lID0gTWF0aC5taW4oYS5saW5lLCBiLmxpbmUpLCBlbmRMaW5lID0gTWF0aC5tYXgoYS5saW5lLCBiLmxpbmUpO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBpZiAoYS5vZmYgPiBNYXhPZmYgfHwgYi5vZmYgPiBNYXhPZmYgfHwgYS5jb2wgPCAwIHx8IGIuY29sIDwgMCkge1xuICAgICAgICBsZXQgc3RhcnRPZmYgPSBNYXRoLm1pbihhLm9mZiwgYi5vZmYpLCBlbmRPZmYgPSBNYXRoLm1heChhLm9mZiwgYi5vZmYpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSBlbmRPZmYpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0T2ZmLCBsaW5lLnRvICsgZW5kT2ZmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBzdGFydENvbCA9IE1hdGgubWluKGEuY29sLCBiLmNvbCksIGVuZENvbCA9IE1hdGgubWF4KGEuY29sLCBiLmNvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZmluZENvbHVtbihsaW5lLnRleHQsIHN0YXJ0Q29sLCBzdGF0ZS50YWJTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgZW5kQ29sLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnQsIGxpbmUuZnJvbSArIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBhYnNvbHV0ZUNvbHVtbih2aWV3LCB4KSB7XG4gICAgbGV0IHJlZiA9IHZpZXcuY29vcmRzQXRQb3Modmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICByZXR1cm4gcmVmID8gTWF0aC5yb3VuZChNYXRoLmFicygocmVmLmxlZnQgLSB4KSAvIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSkgOiAtMTtcbn1cbmZ1bmN0aW9uIGdldFBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBvZmZzZXQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KSwgb2ZmID0gb2Zmc2V0IC0gbGluZS5mcm9tO1xuICAgIGxldCBjb2wgPSBvZmYgPiBNYXhPZmYgPyAtMVxuICAgICAgICA6IG9mZiA9PSBsaW5lLmxlbmd0aCA/IGFic29sdXRlQ29sdW1uKHZpZXcsIGV2ZW50LmNsaWVudFgpXG4gICAgICAgICAgICA6IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgdmlldy5zdGF0ZS50YWJTaXplLCBvZmZzZXQgLSBsaW5lLmZyb20pO1xuICAgIHJldHVybiB7IGxpbmU6IGxpbmUubnVtYmVyLCBjb2wsIG9mZiB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBnZXRQb3ModmlldywgZXZlbnQpLCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghc3RhcnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZShzdGFydC5saW5lKS5mcm9tKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGluZSA9IHVwZGF0ZS5zdGF0ZS5kb2MubGluZUF0KG5ld1N0YXJ0KTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHsgbGluZTogbmV3TGluZS5udW1iZXIsIGNvbDogc3RhcnQuY29sLCBvZmY6IE1hdGgubWluKHN0YXJ0Lm9mZiwgbmV3TGluZS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIF9leHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZ2V0UG9zKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghY3VyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSByZWN0YW5nbGVGb3Iodmlldy5zdGF0ZSwgc3RhcnQsIGN1cik7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5jb25jYXQoc3RhcnRTZWwucmFuZ2VzKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHJlY3Rhbmd1bGFyIHNlbGVjdGlvbnMuIEJ5XG5kZWZhdWx0LCBpdCB3aWxsIHJlYWN0IHRvIGxlZnQgbW91c2UgZHJhZyB3aXRoIHRoZSBBbHQga2V5IGhlbGRcbmRvd24uIFdoZW4gc3VjaCBhIHNlbGVjdGlvbiBvY2N1cnMsIHRoZSB0ZXh0IHdpdGhpbiB0aGUgcmVjdGFuZ2xlXG50aGF0IHdhcyBkcmFnZ2VkIG92ZXIgd2lsbCBiZSBzZWxlY3RlZCwgYXMgb25lIHNlbGVjdGlvblxuW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlKSBwZXIgbGluZS5cbiovXG5mdW5jdGlvbiByZWN0YW5ndWxhclNlbGVjdGlvbihvcHRpb25zKSB7XG4gICAgbGV0IGZpbHRlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRGaWx0ZXIpIHx8IChlID0+IGUuYWx0S2V5ICYmIGUuYnV0dG9uID09IDApO1xuICAgIHJldHVybiBFZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUub2YoKHZpZXcsIGV2ZW50KSA9PiBmaWx0ZXIoZXZlbnQpID8gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIDogbnVsbCk7XG59XG5jb25zdCBrZXlzID0ge1xuICAgIEFsdDogWzE4LCBlID0+ICEhZS5hbHRLZXldLFxuICAgIENvbnRyb2w6IFsxNywgZSA9PiAhIWUuY3RybEtleV0sXG4gICAgU2hpZnQ6IFsxNiwgZSA9PiAhIWUuc2hpZnRLZXldLFxuICAgIE1ldGE6IFs5MSwgZSA9PiAhIWUubWV0YUtleV1cbn07XG5jb25zdCBzaG93Q3Jvc3NoYWlyID0geyBzdHlsZTogXCJjdXJzb3I6IGNyb3NzaGFpclwiIH07XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgdHVybnMgdGhlIHBvaW50ZXIgY3Vyc29yIGludG8gYVxuY3Jvc3NoYWlyIHdoZW4gYSBnaXZlbiBtb2RpZmllciBrZXksIGRlZmF1bHRpbmcgdG8gQWx0LCBpcyBoZWxkXG5kb3duLiBDYW4gc2VydmUgYXMgYSB2aXN1YWwgaGludCB0aGF0IHJlY3Rhbmd1bGFyIHNlbGVjdGlvbiBpc1xuZ29pbmcgdG8gaGFwcGVuIHdoZW4gcGFpcmVkIHdpdGhcbltgcmVjdGFuZ3VsYXJTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcucmVjdGFuZ3VsYXJTZWxlY3Rpb24pLlxuKi9cbmZ1bmN0aW9uIGNyb3NzaGFpckN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICBsZXQgW2NvZGUsIGdldHRlcl0gPSBrZXlzW29wdGlvbnMua2V5IHx8IFwiQWx0XCJdO1xuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNldChpc0Rvd24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG93biAhPSBpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRG93biA9IGlzRG93bjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZXZlbnRPYnNlcnZlcnM6IHtcbiAgICAgICAgICAgIGtleWRvd24oZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGUua2V5Q29kZSA9PSBjb2RlIHx8IGdldHRlcihlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5dXAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gY29kZSB8fCAhZ2V0dGVyKGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2Vtb3ZlKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcGx1Z2luLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRG93bikgPyBzaG93Q3Jvc3NoYWlyIDogbnVsbDsgfSlcbiAgICBdO1xufVxuXG5jb25zdCBPdXRzaWRlID0gXCItMTAwMDBweFwiO1xuY2xhc3MgVG9vbHRpcFZpZXdNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBmYWNldCwgY3JlYXRlVG9vbHRpcFZpZXcsIHJlbW92ZVRvb2x0aXBWaWV3KSB7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwVmlldyA9IGNyZWF0ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLnJlbW92ZVRvb2x0aXBWaWV3ID0gcmVtb3ZlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRoaXMuaW5wdXQuZmlsdGVyKHQgPT4gdCk7XG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0aGlzLnRvb2x0aXBzLm1hcCh0ID0+IHByZXYgPSBjcmVhdGVUb29sdGlwVmlldyh0LCBwcmV2KSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIGFib3ZlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoaXMuZmFjZXQpO1xuICAgICAgICBsZXQgdG9vbHRpcHMgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIGlmICh0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9vbHRpcFZpZXdzID0gW10sIG5ld0Fib3ZlID0gYWJvdmUgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aXAgPSB0b29sdGlwc1tpXSwga25vd24gPSAtMTtcbiAgICAgICAgICAgIGlmICghdGlwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyID0gdGhpcy50b29sdGlwc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgJiYgb3RoZXIuY3JlYXRlID09IHRpcC5jcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIGtub3duID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwVmlld3NbaV0gPSB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3KHRpcCwgaSA/IHRvb2x0aXBWaWV3c1tpIC0gMV0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gISF0aXAuYWJvdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwVmlld3NbaV0gPSB0aGlzLnRvb2x0aXBWaWV3c1trbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9IGFib3ZlW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcodCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFib3ZlKSB7XG4gICAgICAgICAgICBuZXdBYm92ZS5mb3JFYWNoKCh2YWwsIGkpID0+IGFib3ZlW2ldID0gdmFsKTtcbiAgICAgICAgICAgIGFib3ZlLmxlbmd0aCA9IG5ld0Fib3ZlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0b29sdGlwVmlld3M7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlcyBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIHRvb2x0aXAgYmVoYXZpb3IuXG4qL1xuZnVuY3Rpb24gdG9vbHRpcHMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdG9vbHRpcENvbmZpZy5vZihjb25maWcpO1xufVxuZnVuY3Rpb24gd2luZG93U3BhY2Uodmlldykge1xuICAgIGxldCB7IHdpbiB9ID0gdmlldztcbiAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0LCByaWdodDogd2luLmlubmVyV2lkdGggfTtcbn1cbmNvbnN0IHRvb2x0aXBDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwb3NpdGlvbjogYnJvd3Nlci5pb3MgPyBcImFic29sdXRlXCIgOiAoKF9hID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBvc2l0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKSB8fCBcImZpeGVkXCIsXG4gICAgICAgICAgICBwYXJlbnQ6ICgoX2IgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucGFyZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBTcGFjZTogKChfYyA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi50b29sdGlwU3BhY2UpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHRpcFNwYWNlKSB8fCB3aW5kb3dTcGFjZSxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBrbm93bkhlaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFib3ZlID0gW107XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSAwO1xuICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGNvbmZpZy5wYXJlbnQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZE1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMud3JpdGVNZWFzdXJlLmJpbmQodGhpcyksIGtleTogdGhpcyB9O1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLm1lYXN1cmVTb29uKCkpIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgKHQsIHApID0+IHRoaXMuY3JlYXRlVG9vbHRpcCh0LCBwKSwgdCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcilcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0LmRvbSk7XG4gICAgICAgICAgICB0LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWJvdmUgPSB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKHQgPT4gISF0LmFib3ZlKTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRoaXMubGFzdFRyYW5zYWN0aW9uIC0gNTAgJiZcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvIDwgMSlcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTb29uKCk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMV0gfSkgOiBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgdmlldy53aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uID0gdGhpcy5tZWFzdXJlU29vbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSwgdGhpcy5hYm92ZSk7XG4gICAgICAgIGlmICh1cGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIGxldCBzaG91bGRNZWFzdXJlID0gdXBkYXRlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkO1xuICAgICAgICBsZXQgbmV3Q29uZmlnID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICBpZiAobmV3Q29uZmlnLnBvc2l0aW9uICE9IHRoaXMucG9zaXRpb24gJiYgIXRoaXMubWFkZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3Q29uZmlnLnBvc2l0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcucGFyZW50ICE9IHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG5ld0NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQuZG9tKTtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRNZWFzdXJlKVxuICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCh0b29sdGlwLCBwcmV2KSB7XG4gICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGxldCBiZWZvcmUgPSBwcmV2ID8gcHJldi5kb20gOiBudWxsO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XG4gICAgICAgIGlmICh0b29sdGlwLmFycm93ICYmICF0b29sdGlwVmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwID4gLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRvb2x0aXBWaWV3LmRvbSwgYmVmb3JlKTtcbiAgICAgICAgaWYgKHRvb2x0aXBWaWV3Lm1vdW50KVxuICAgICAgICAgICAgdG9vbHRpcFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodG9vbHRpcFZpZXcuZG9tKTtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBWaWV3O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xuICAgICAgICBmb3IgKGxldCB0b29sdGlwVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIChfYiA9IHRoaXMucmVzaXplT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lYXN1cmVUaW1lb3V0KTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmUoKSB7XG4gICAgICAgIGxldCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBtYWtlQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJmaXhlZFwiICYmIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBkb20gfSA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbMF07XG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc2V0cyB0aGUgZWxlbWVudCdzIGBvZmZzZXRQYXJlbnRgIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybWVkIGVsZW1lbnQgd2hlbiBhIHRyYW5zZm9ybSBpbnRlcmZlcmVzIHdpdGggZml4ZWRcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgICAgICBtYWtlQWJzb2x1dGUgPSBkb20ub2Zmc2V0UGFyZW50ICE9IHRoaXMuY29udGFpbmVyLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS50b3AgPT0gT3V0c2lkZSAmJiBkb20uc3R5bGUubGVmdCA9PSBcIjBweFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gb3RoZXIgYnJvd3NlcnMsIHdlIGhhdmUgdG8gYXdrd2FyZGx5IHRyeSBhbmQgdXNlIG90aGVyXG4gICAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24gdG8gZGV0ZWN0IGEgdHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IE1hdGguYWJzKHJlY3QudG9wICsgMTAwMDApID4gMSB8fCBNYXRoLmFicyhyZWN0LmxlZnQpID4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFrZUFic29sdXRlIHx8IHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyB0aGlzLnBhcmVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyB0aGlzLnBhcmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldy52aWV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2aXNpYmxlID0gdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB2aXNpYmxlLmxlZnQgKyBtYXJnaW5zLmxlZnQsIHRvcDogdmlzaWJsZS50b3AgKyBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogdmlzaWJsZS5yaWdodCAtIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogdmlzaWJsZS5ib3R0b20gLSBtYXJnaW5zLmJvdHRvbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBwb3M6IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICAgICAgc2NhbGVYLCBzY2FsZVksIG1ha2VBYnNvbHV0ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobWVhc3VyZWQubWFrZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHZpc2libGUsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCB0b29sdGlwLmNsaXAgIT09IGZhbHNlICYmIChwb3MuYm90dG9tIDw9IE1hdGgubWF4KHZpc2libGUudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbih2aXNpYmxlLmJvdHRvbSwgc3BhY2UuYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgIHBvcy5yaWdodCA8IE1hdGgubWF4KHZpc2libGUubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4odmlzaWJsZS5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSB0b29sdGlwLmFycm93ID8gdFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyb3dIZWlnaHQgPSBhcnJvdyA/IDcgLyogQXJyb3cuU2l6ZSAqLyA6IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzaXplLnJpZ2h0IC0gc2l6ZS5sZWZ0LCBoZWlnaHQgPSAoX2EgPSBrbm93bkhlaWdodC5nZXQodFZpZXcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzaXplLmJvdHRvbSAtIHNpemUudG9wO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRWaWV3Lm9mZnNldCB8fCBub09mZnNldCwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gc2l6ZS53aWR0aCA+IHNwYWNlLnJpZ2h0IC0gc3BhY2UubGVmdFxuICAgICAgICAgICAgICAgID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1heChzcGFjZS5sZWZ0LCBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1hdGgubWF4KHNwYWNlLmxlZnQsIHBvcy5sZWZ0IC0gd2lkdGggKyAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSAtIG9mZnNldC54KSwgc3BhY2UucmlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSB0aGlzLmFib3ZlW2ldO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA8IHNwYWNlLnRvcFxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIGhlaWdodCArIGFycm93SGVpZ2h0ICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9IHRoaXMuYWJvdmVbaV0gPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZXRMZWZ0U3R5bGUoZG9tLCAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSAvIHNjYWxlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNldExlZnRTdHlsZShkb20sIGxlZnQgLyBzY2FsZVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFycm93TGVmdCA9IHBvcy5sZWZ0ICsgKGx0ciA/IG9mZnNldC54IDogLW9mZnNldC54KSAtIChsZWZ0ICsgMTQgLyogQXJyb3cuT2Zmc2V0ICovIC0gNyAvKiBBcnJvdy5TaXplICovKTtcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYXJyb3dMZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V0TGVmdFN0eWxlKGVsdCwgdmFsdWUpIHtcbiAgICBsZXQgY3VycmVudCA9IHBhcnNlSW50KGVsdC5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgaWYgKGlzTmFOKGN1cnJlbnQpIHx8IE1hdGguYWJzKHZhbHVlIC0gY3VycmVudCkgPiAxKVxuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHZhbHVlICsgXCJweFwiO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgekluZGV4OiA1MDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICB3aWR0aDogYCR7NyAvKiBBcnJvdy5TaXplICovICogMn1weGAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBcIiY6YmVmb3JlLCAmOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1hYm92ZSAmXCI6IHtcbiAgICAgICAgICAgIGJvdHRvbTogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWJlbG93ICZcIjoge1xuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCIjMzMzMzM4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4vKipcbkZhY2V0IHRvIHdoaWNoIGFuIGV4dGVuc2lvbiBjYW4gYWRkIGEgdmFsdWUgdG8gc2hvdyBhIHRvb2x0aXAuXG4qL1xuY29uc3Qgc2hvd1Rvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbdG9vbHRpcFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5jb25zdCBzaG93SG92ZXJUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogaW5wdXRzID0+IGlucHV0cy5yZWR1Y2UoKGEsIGkpID0+IGEuY29uY2F0KGkpLCBbXSlcbn0pO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCwgcCksIHQgPT4gdC5kb20ucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUoaG9zdGVkVmlldy5kb20sIHByZXYgPyBwcmV2LmRvbS5uZXh0U2libGluZyA6IHRoaXMuZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgfVxuICAgIHBhc3NQcm9wKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBnaXZlbiA9IHZpZXdbbmFtZV07XG4gICAgICAgICAgICBpZiAoZ2l2ZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdpdmVuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBnaXZlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib2Zmc2V0XCIpOyB9XG4gICAgZ2V0IGdldENvb3JkcygpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJnZXRDb29yZHNcIik7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvdmVybGFwXCIpOyB9XG4gICAgZ2V0IHJlc2l6ZSgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJyZXNpemVcIik7IH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLm1hcCh0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHQucG9zOyB9KSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcbiAgICAgICAgaWYgKGhvdmVyZWQgPCB0aGlzLmhvdmVyVGltZSlcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lIC0gaG92ZXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgIGxldCB7IHZpZXcsIGxhc3RNb3ZlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGxhc3RNb3ZlLnRhcmdldCk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcywgc2lkZSA9IDE7XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgV2lkZ2V0Vmlldykge1xuICAgICAgICAgICAgcG9zID0gZGVzYy5wb3NBdFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgICAgIGlmICghcG9zQ29vcmRzIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgLSB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYmlkaSA9IHZpZXcuYmlkaVNwYW5zKHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICAgICAgc2lkZSA9IChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHZpZXcsIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgIShBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgIXJlc3VsdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0IDogW3Jlc3VsdF0pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiaG92ZXIgdG9vbHRpcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiAhKEFycmF5LmlzQXJyYXkob3BlbikgJiYgIW9wZW4ubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShvcGVuKSA/IG9wZW4gOiBbb3Blbl0pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkge1xuICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy52aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuZmluZEluZGV4KHQgPT4gdC5jcmVhdGUgPT0gSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUpIDogLTE7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgdGltZTogRGF0ZS5ub3coKSB9O1xuICAgICAgICBpZiAodGhpcy5ob3ZlclRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUpO1xuICAgICAgICBsZXQgeyBhY3RpdmUsIHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICYmIHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRvb2x0aXAuZG9tLCBldmVudCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IGFjdGl2ZVswXSB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYiA9IChfYSA9IGFjdGl2ZVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcG9zO1xuICAgICAgICAgICAgaWYgKChwb3MgPT0gZW5kID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHRoaXMubGFzdE1vdmUpICE9IHBvc1xuICAgICAgICAgICAgICAgIDogIWlzT3ZlclJhbmdlKHRoaXMudmlldywgcG9zLCBlbmQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgeyBhY3RpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGluVG9vbHRpcCA9IHRvb2x0aXAgJiYgdG9vbHRpcC5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWluVG9vbHRpcClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoVG9vbHRpcExlYXZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwKSB7XG4gICAgICAgIGxldCB3YXRjaCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3YXRjaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUubGVuZ3RoICYmICF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmNvbnN0IHRvb2x0aXBNYXJnaW4gPSA0O1xuZnVuY3Rpb24gaXNJblRvb2x0aXAodG9vbHRpcCwgZXZlbnQpIHtcbiAgICBsZXQgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHRvb2x0aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFycm93O1xuICAgIGlmIChhcnJvdyA9IHRvb2x0aXAucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgIGxldCBhcnJvd1JlY3QgPSBhcnJvdy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdG9wID0gTWF0aC5taW4oYXJyb3dSZWN0LnRvcCwgdG9wKTtcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYXJyb3dSZWN0LmJvdHRvbSwgYm90dG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50LmNsaWVudFggPj0gbGVmdCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WCA8PSByaWdodCArIHRvb2x0aXBNYXJnaW4gJiZcbiAgICAgICAgZXZlbnQuY2xpZW50WSA+PSB0b3AgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFkgPD0gYm90dG9tICsgdG9vbHRpcE1hcmdpbjtcbn1cbmZ1bmN0aW9uIGlzT3ZlclJhbmdlKHZpZXcsIGZyb20sIHRvLCB4LCB5LCBtYXJnaW4pIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBkb2NCb3R0b20gPSB2aWV3LmRvY3VtZW50VG9wICsgdmlldy5kb2N1bWVudFBhZGRpbmcudG9wICsgdmlldy5jb250ZW50SGVpZ2h0O1xuICAgIGlmIChyZWN0LmxlZnQgPiB4IHx8IHJlY3QucmlnaHQgPCB4IHx8IHJlY3QudG9wID4geSB8fCBNYXRoLm1pbihyZWN0LmJvdHRvbSwgZG9jQm90dG9tKSA8IHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHgsIHkgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG87XG59XG4vKipcblNldCB1cCBhIGhvdmVyIHRvb2x0aXAsIHdoaWNoIHNob3dzIHVwIHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzXG5vdmVyIHJhbmdlcyBvZiB0ZXh0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhvdmVyc1xub3ZlciB0aGUgZG9jdW1lbnQgdGV4dC4gSXQgc2hvdWxkLCBpZiB0aGVyZSBpcyBhIHRvb2x0aXBcbmFzc29jaWF0ZWQgd2l0aCBwb3NpdGlvbiBgcG9zYCwgcmV0dXJuIHRoZSB0b29sdGlwIGRlc2NyaXB0aW9uXG4oZWl0aGVyIGRpcmVjdGx5IG9yIGluIGEgcHJvbWlzZSkuIFRoZSBgc2lkZWAgYXJndW1lbnQgaW5kaWNhdGVzXG5vbiB3aGljaCBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGUgcG9pbnRlciBpc+KAlGl0IHdpbGwgYmUgLTEgaWYgdGhlXG5wb2ludGVyIGlzIGJlZm9yZSB0aGUgcG9zaXRpb24sIDEgaWYgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuXG5Ob3RlIHRoYXQgYWxsIGhvdmVyIHRvb2x0aXBzIGFyZSBob3N0ZWQgd2l0aGluIGEgc2luZ2xlIHRvb2x0aXBcbmNvbnRhaW5lciBlbGVtZW50LiBUaGlzIGFsbG93cyBtdWx0aXBsZSB0b29sdGlwcyBvdmVyIHRoZSBzYW1lXG5yYW5nZSB0byBiZSBcIm1lcmdlZFwiIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcmxhcHBpbmcuXG5cblRoZSByZXR1cm4gdmFsdWUgaXMgYSB2YWxpZCBbZWRpdG9yIGV4dGVuc2lvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pXG5idXQgYWxzbyBwcm92aWRlcyBhbiBgYWN0aXZlYCBwcm9wZXJ0eSBob2xkaW5nIGEgc3RhdGUgZmllbGQgdGhhdFxuY2FuIGJlIHVzZWQgdG8gcmVhZCB0aGUgY3VycmVudGx5IGFjdGl2ZSB0b29sdGlwcyBwcm9kdWNlZCBieSB0aGlzXG5leHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gaG92ZXJUb29sdGlwKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHNldEhvdmVyID0gU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4gICAgbGV0IGhvdmVyU3RhdGUgPSBTdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oaWRlT24pXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKHYgPT4gIW9wdGlvbnMuaGlkZU9uKHRyLCB2KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModG9vbHRpcC5wb3MsIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB0b29sdGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnBvcyA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29weS5lbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5lbmQgPSB0ci5jaGFuZ2VzLm1hcFBvcyhjb3B5LmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkLnB1c2goY29weSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEhvdmVyKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGYgPT4gc2hvd0hvdmVyVG9vbHRpcC5mcm9tKGYpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlOiBob3ZlclN0YXRlLFxuICAgICAgICBleHRlbnNpb246IFtcbiAgICAgICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBIb3ZlclBsdWdpbih2aWV3LCBzb3VyY2UsIGhvdmVyU3RhdGUsIHNldEhvdmVyLCBvcHRpb25zLmhvdmVyVGltZSB8fCAzMDAgLyogSG92ZXIuVGltZSAqLykpLFxuICAgICAgICAgICAgc2hvd0hvdmVyVG9vbHRpcEhvc3RcbiAgICAgICAgXVxuICAgIH07XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHRvb2x0aXAgdmlldyBmb3IgYSBnaXZlbiB0b29sdGlwLCBpZiBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcCh2aWV3LCB0b29sdGlwKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgIGlmICghcGx1Z2luKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5pbmRleE9mKHRvb2x0aXApO1xuICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ZvdW5kXTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIGFueSBob3ZlciB0b29sdGlwcyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBoYXNIb3ZlclRvb2x0aXBzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLnNvbWUoeCA9PiB4KTtcbn1cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxuKi9cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwcyA9IC8qQF9fUFVSRV9fKi9jbG9zZUhvdmVyVG9vbHRpcEVmZmVjdC5vZihudWxsKTtcbi8qKlxuVGVsbCB0aGUgdG9vbHRpcCBleHRlbnNpb24gdG8gcmVjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0aXZlXG50b29sdGlwcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgKHN1Y2ggYXMgYVxucmUtcG9zaXRpb25pbmcgb3IgQ1NTIGNoYW5nZSBhZmZlY3RpbmcgdGhlIGVkaXRvcikgdGhhdCBjb3VsZFxuaW52YWxpZGF0ZSB0aGUgZXhpc3RpbmcgdG9vbHRpcCBwb3NpdGlvbnMuXG4qL1xuZnVuY3Rpb24gcmVwb3NpdGlvblRvb2x0aXBzKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLm1heWJlTWVhc3VyZSgpO1xufVxuXG5jb25zdCBwYW5lbENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICAgICAgdG9wQ29udGFpbmVyID0gdG9wQ29udGFpbmVyIHx8IGMudG9wQ29udGFpbmVyO1xuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyIH07XG4gICAgfVxufSk7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBwYW5lbHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxuVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHlvdXIgcGFuZWxzJyBET01cbnN0cnVjdHVyZS5cbiovXG5mdW5jdGlvbiBnZXRQYW5lbCh2aWV3LCBwYW5lbCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihwYW5lbFBsdWdpbik7XG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ucGFuZWxzW2luZGV4XSA6IG51bGw7XG59XG5jb25zdCBwYW5lbFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB0aGlzLnNwZWNzLm1hcChzcGVjID0+IHNwZWModmlldykpO1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh2aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB0aGlzLnRvcC5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+IHAudG9wKSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHAudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XG4gICAgfSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXG4gICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICB0aGlzLnN5bmNET00oKTtcbiAgICB9XG4gICAgc3luY0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlW3RoaXMudG9wID8gXCJ0b3BcIiA6IFwiYm90dG9tXCJdID0gXCIwXCI7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250YWluZXIgfHwgdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyRE9NID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJET00gIT0gcGFuZWwuZG9tKVxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IGN1ckRPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShwYW5lbC5kb20sIGN1ckRPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1ckRPTSlcbiAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgfVxuICAgIHNjcm9sbE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRvbSB8fCB0aGlzLmNvbnRhaW5lciA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIE1hdGgubWF4KDAsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBwYW5lbFBsdWdpblxufSk7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIuZWxlbWVudENsYXNzKSwgbm90IGFcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxuaW4gYWxsIGd1dHRlcnMgZm9yIHRoZSBsaW5lKS5cbiovXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBuZXh0IHRvIGEgd2lkZ2V0LlxuU2hvdWxkIG5vdCBwcm92aWRlIHdpZGdldHMgd2l0aCBhIGB0b0RPTWAgbWV0aG9kLlxuKi9cbmNvbnN0IGd1dHRlcldpZGdldENsYXNzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IFJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgd2lkZ2V0TWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYW4gZWRpdG9yIGd1dHRlci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBndXR0ZXJzIGFwcGVhciBpc1xuZGV0ZXJtaW5lZCBieSB0aGVpciBleHRlbnNpb24gcHJpb3JpdHkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVyKGNvbmZpZykge1xuICAgIHJldHVybiBbZ3V0dGVycygpLCBhY3RpdmVHdXR0ZXJzLm9mKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpLCBjb25maWcpKV07XG59XG5jb25zdCB1bmZpeEd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG4vKipcblRoZSBndXR0ZXItZHJhd2luZyBwbHVnaW4gaXMgYXV0b21hdGljYWxseSBlbmFibGVkIHdoZW4geW91IGFkZCBhXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxuXG5Vbmxlc3MgYGZpeGVkYCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLCB0aGUgZ3V0dGVycyBhcmVcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcbmhvcml6b250YWxseSAoZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBkb2Vzbid0IHN1cHBvcnRcbkNTUyBbYHBvc2l0aW9uOlxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxuKi9cbmZ1bmN0aW9uIGd1dHRlcnMoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtcbiAgICAgICAgZ3V0dGVyVmlldyxcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiBmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGIuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgYiwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLndpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGxpbmUsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayksIG1hcmtlcnMgPSBtYXJrZXIgPyBbbWFya2VyXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB2aWV3LnN0YXRlLmZhY2V0KGd1dHRlcldpZGdldENsYXNzKSkge1xuICAgICAgICAgICAgbGV0IG1hcmtlciA9IGNscyh2aWV3LCBibG9jay53aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICAgICAgKG1hcmtlcnMgfHwgKG1hcmtlcnMgPSBbXSkpLnB1c2gobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VycylcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBibG9jaywgbWFya2Vycyk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQucGFyZW50Tm9kZSAhPSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KHkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYm92ZSAhPSBhYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNyZWF0ZSBtYXJrZXJzIGluIHRoZSBsaW5lIG51bWJlciBndXR0ZXIgbmV4dCB0byB3aWRnZXRzLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIHdpZGdldE1hcmtlcjogKHZpZXcsIHdpZGdldCwgYmxvY2spID0+IHtcbiAgICAgICAgZm9yIChsZXQgbSBvZiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbSh2aWV3LCB3aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IHVwZGF0ZSA9PiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZyksXG4gICAgaW5pdGlhbFNwYWNlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCBtYXhMaW5lTnVtYmVyKHZpZXcuc3RhdGUuZG9jLmxpbmVzKSkpO1xuICAgIH0sXG4gICAgdXBkYXRlU3BhY2VyKHNwYWNlciwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBtYXggPSBmb3JtYXROdW1iZXIodXBkYXRlLnZpZXcsIG1heExpbmVOdW1iZXIodXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVzKSk7XG4gICAgICAgIHJldHVybiBtYXggPT0gc3BhY2VyLm51bWJlciA/IHNwYWNlciA6IG5ldyBOdW1iZXJNYXJrZXIobWF4KTtcbiAgICB9LFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmRvbUV2ZW50SGFuZGxlcnNcbn0pKTtcbi8qKlxuQ3JlYXRlIGEgbGluZSBudW1iZXIgZ3V0dGVyIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW5lTnVtYmVycyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbmVOdW1iZXJDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgZ3V0dGVycygpLFxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcbiAgICBsZXQgbGFzdCA9IDk7XG4gICAgd2hpbGUgKGxhc3QgPCBsaW5lcylcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVyTWFya2VyID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gXCJjbS1hY3RpdmVMaW5lR3V0dGVyXCI7XG4gICAgfVxufTtcbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9ndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlID0+IHtcbiAgICBsZXQgbWFya3MgPSBbXSwgbGFzdCA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGxpbmVQb3MgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgICAgIGlmIChsaW5lUG9zID4gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+ICh7XG4gICAgICAgIGRlY29yYXRpb25zOiBkZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KSxcbiAgICAgICAgdXBkYXRlKHUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0b3IudXBkYXRlRGVjbyh1LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9KSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSk7XG59XG5jb25zdCB0YWJEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWhpZ2hsaWdodFRhYlwiIH0pO1xuY29uc3Qgc3BhY2VEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWhpZ2hsaWdodFNwYWNlXCIgfSk7XG5jb25zdCB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHR8IC9nLFxuICAgIGRlY29yYXRpb246IG1hdGNoID0+IG1hdGNoWzBdID09IFwiXFx0XCIgPyB0YWJEZWNvIDogc3BhY2VEZWNvLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWdobGlnaHRzIHdoaXRlc3BhY2UsIGFkZGluZyBhXG5gY20taGlnaGxpZ2h0U3BhY2VgIGNsYXNzIHRvIHN0cmV0Y2hlcyBvZiBzcGFjZXMsIGFuZCBhXG5gY20taGlnaGxpZ2h0VGFiYCBjbGFzcyB0byBpbmRpdmlkdWFsIHRhYiBjaGFyYWN0ZXJzLiBCeSBkZWZhdWx0LFxudGhlIGZvcm1lciBhcmUgc2hvd24gYXMgZmFpbnQgZG90cywgYW5kIHRoZSBsYXR0ZXIgYXMgYXJyb3dzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFdoaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VIaWdobGlnaHRlcjtcbn1cbmNvbnN0IHRyYWlsaW5nSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHMrJC9nLFxuICAgIGRlY29yYXRpb246IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS10cmFpbGluZ1NwYWNlXCIgfSksXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tdHJhaWxpbmdTcGFjZWAgY2xhc3MgdG8gYWxsXG50cmFpbGluZyB3aGl0ZXNwYWNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHJhaWxpbmdIaWdobGlnaHRlcjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3Rlc3QgPSB7IEhlaWdodE1hcCwgSGVpZ2h0T3JhY2xlLCBNZWFzdXJlZEhlaWdodHMsIFF1ZXJ5VHlwZSwgQ2hhbmdlZFJhbmdlLCBjb21wdXRlT3JkZXIsXG4gICAgbW92ZVZpc3VhbGx5LCBjbGVhckhlaWdodENoYW5nZUZsYWcsIGdldEhlaWdodENoYW5nZUZsYWc6ICgpID0+IGhlaWdodENoYW5nZUZsYWcgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFJlY3RhbmdsZU1hcmtlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBjbG9zZUhvdmVyVG9vbHRpcHMsIGNyb3NzaGFpckN1cnNvciwgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZywgZ2V0UGFuZWwsIGdldFRvb2x0aXAsIGd1dHRlciwgZ3V0dGVyTGluZUNsYXNzLCBndXR0ZXJXaWRnZXRDbGFzcywgZ3V0dGVycywgaGFzSG92ZXJUb29sdGlwcywgaGlnaGxpZ2h0QWN0aXZlTGluZSwgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UsIGhpZ2hsaWdodFdoaXRlc3BhY2UsIGhvdmVyVG9vbHRpcCwga2V5bWFwLCBsYXllciwgbGluZU51bWJlck1hcmtlcnMsIGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIsIGxpbmVOdW1iZXJzLCBsb2dFeGNlcHRpb24sIHBhbmVscywgcGxhY2Vob2xkZXIsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCByZXBvc2l0aW9uVG9vbHRpcHMsIHJ1blNjb3BlSGFuZGxlcnMsIHNjcm9sbFBhc3RFbmQsIHNob3dQYW5lbCwgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XG4iLCJleHBvcnQgdmFyIGJhc2UgPSB7XG4gIDg6IFwiQmFja3NwYWNlXCIsXG4gIDk6IFwiVGFiXCIsXG4gIDEwOiBcIkVudGVyXCIsXG4gIDEyOiBcIk51bUxvY2tcIixcbiAgMTM6IFwiRW50ZXJcIixcbiAgMTY6IFwiU2hpZnRcIixcbiAgMTc6IFwiQ29udHJvbFwiLFxuICAxODogXCJBbHRcIixcbiAgMjA6IFwiQ2Fwc0xvY2tcIixcbiAgMjc6IFwiRXNjYXBlXCIsXG4gIDMyOiBcIiBcIixcbiAgMzM6IFwiUGFnZVVwXCIsXG4gIDM0OiBcIlBhZ2VEb3duXCIsXG4gIDM1OiBcIkVuZFwiLFxuICAzNjogXCJIb21lXCIsXG4gIDM3OiBcIkFycm93TGVmdFwiLFxuICAzODogXCJBcnJvd1VwXCIsXG4gIDM5OiBcIkFycm93UmlnaHRcIixcbiAgNDA6IFwiQXJyb3dEb3duXCIsXG4gIDQ0OiBcIlByaW50U2NyZWVuXCIsXG4gIDQ1OiBcIkluc2VydFwiLFxuICA0NjogXCJEZWxldGVcIixcbiAgNTk6IFwiO1wiLFxuICA2MTogXCI9XCIsXG4gIDkxOiBcIk1ldGFcIixcbiAgOTI6IFwiTWV0YVwiLFxuICAxMDY6IFwiKlwiLFxuICAxMDc6IFwiK1wiLFxuICAxMDg6IFwiLFwiLFxuICAxMDk6IFwiLVwiLFxuICAxMTA6IFwiLlwiLFxuICAxMTE6IFwiL1wiLFxuICAxNDQ6IFwiTnVtTG9ja1wiLFxuICAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAxNjA6IFwiU2hpZnRcIixcbiAgMTYxOiBcIlNoaWZ0XCIsXG4gIDE2MjogXCJDb250cm9sXCIsXG4gIDE2MzogXCJDb250cm9sXCIsXG4gIDE2NDogXCJBbHRcIixcbiAgMTY1OiBcIkFsdFwiLFxuICAxNzM6IFwiLVwiLFxuICAxODY6IFwiO1wiLFxuICAxODc6IFwiPVwiLFxuICAxODg6IFwiLFwiLFxuICAxODk6IFwiLVwiLFxuICAxOTA6IFwiLlwiLFxuICAxOTE6IFwiL1wiLFxuICAxOTI6IFwiYFwiLFxuICAyMTk6IFwiW1wiLFxuICAyMjA6IFwiXFxcXFwiLFxuICAyMjE6IFwiXVwiLFxuICAyMjI6IFwiJ1wiXG59XG5cbmV4cG9ydCB2YXIgc2hpZnQgPSB7XG4gIDQ4OiBcIilcIixcbiAgNDk6IFwiIVwiLFxuICA1MDogXCJAXCIsXG4gIDUxOiBcIiNcIixcbiAgNTI6IFwiJFwiLFxuICA1MzogXCIlXCIsXG4gIDU0OiBcIl5cIixcbiAgNTU6IFwiJlwiLFxuICA1NjogXCIqXCIsXG4gIDU3OiBcIihcIixcbiAgNTk6IFwiOlwiLFxuICA2MTogXCIrXCIsXG4gIDE3MzogXCJfXCIsXG4gIDE4NjogXCI6XCIsXG4gIDE4NzogXCIrXCIsXG4gIDE4ODogXCI8XCIsXG4gIDE4OTogXCJfXCIsXG4gIDE5MDogXCI+XCIsXG4gIDE5MTogXCI/XCIsXG4gIDE5MjogXCJ+XCIsXG4gIDIxOTogXCJ7XCIsXG4gIDIyMDogXCJ8XCIsXG4gIDIyMTogXCJ9XCIsXG4gIDIyMjogXCJcXFwiXCJcbn1cblxudmFyIGNocm9tZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gbWFjIHx8IGNocm9tZSAmJiArY2hyb21lWzFdIDwgNTdcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIHZhciBpZ25vcmVLZXkgPSBicm9rZW5Nb2RpZmllck5hbWVzICYmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5KSB8fFxuICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICBldmVudC5rZXkgPT0gXCJVbmlkZW50aWZpZWRcIlxuICB2YXIgbmFtZSA9ICghaWdub3JlS2V5ICYmIGV2ZW50LmtleSkgfHxcbiAgICAoZXZlbnQuc2hpZnRLZXkgPyBzaGlmdCA6IGJhc2UpW2V2ZW50LmtleUNvZGVdIHx8XG4gICAgZXZlbnQua2V5IHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxuICBpZiAobmFtZSA9PSBcIkVzY1wiKSBuYW1lID0gXCJFc2NhcGVcIlxuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xuICBpZiAobmFtZSA9PSBcIkxlZnRcIikgbmFtZSA9IFwiQXJyb3dMZWZ0XCJcbiAgaWYgKG5hbWUgPT0gXCJVcFwiKSBuYW1lID0gXCJBcnJvd1VwXCJcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCJcbiAgaWYgKG5hbWUgPT0gXCJEb3duXCIpIG5hbWUgPSBcIkFycm93RG93blwiXG4gIHJldHVybiBuYW1lXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=